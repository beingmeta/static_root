/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file was created from several component files, some of
      which have different restrictions.

   For purposes of inclusion of this code in non-commercial web documents,
     use and redistribution of this file is permitted under the terms of
     the Creative Commons "Attribution-NonCommercial" license:
          http://creativecommons.org/licenses/by-nc/3.0/ 

   For all other purposes, the contents of this file are licensed
    under the terms of the nearest preceding copyright notice.  The
    copyright notices of the individual files are all prefixed by
    a line of the form "Copyright (C) ...".

    Other uses may be allowed based on prior agreement with
      beingmeta, inc.  Inquiries can be addressed to:

       licensing@biz.beingmeta.com

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

*/

window._metabook_amalgam=(document)&&(document.currentScript)&&(document.currentScript.src);
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/core.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* globals Promise */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
//var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
//var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));
//var iScroll=((typeof iScroll !== "undefined")?(iScroll):({}));
//var fdjtMap=fdjt.Map;

var _checkOpenSans=
    (function(){
        var start=(new Date()).getTime();
        var timeout_after=60*1000, check_interval=100, setup=false;
        var sample_text="QW@HhsXJ.,+";
        var html=document.documentElement, body=document.body;
        var div1=document.createElement("DIV");
        var div2=document.createElement("DIV");
        var text1=document.createTextNode(sample_text);
        var text2=document.createTextNode(sample_text);
        var style1=div1.style, style2=div2.style;
        style1.position=style2.position='absolute';
        style1.top=style2.top="-5000px";
        style1.left=style2.left='-5000px';
        style1.pointerEvents=style2.pointerEvents='none';
        style1.zIndex=style2.zIndex='500';
        style1.opacity=style2.opacity=0.0;
        style1.fontSize=style2.fontSize="250px";
        style1.fontFamily="'Open Sans','Comic Sans MS','Comic Sans',Serif";
        style2.fontFamily="'Comic Sans MS','Comic Sans',Serif"
        div1.id="METABOOK_FONTCHECK1";
        div2.id="METABOOK_FONTCHECK2";
        div1.className=div2.className="_ignoreme";
        div1.appendChild(text1);
        div2.appendChild(text2);
        body.appendChild(div1);
        body.appendChild(div2);
        setup=true;
        var itimer, timeout, tries=0;
        function cleanup(){
	    if (itimer) clearInterval(itimer);
	    if (timeout) clearTimeout(timeout);
            if (div1.parentNode)
	        div1.parentNode.removeChild(div1);
            if (div2.parentNode)
	        div2.parentNode.removeChild(div2);
            setup=false;}
        function checking(){
            if (!(setup)) {
                body.appendChild(div1);
                body.appendChild(div2);
                setup=true;}
	    var w1=div1.offsetWidth;
	    var w2=div2.offsetWidth;
	    var now=(new Date()).getTime();
            tries++;
	    if (w1!==w2) {
	        if (console.log)
		    console.log("["+(now-start)/1000+"s] Open Sans loaded, "+
			        "divs at @ "+w1+"!="+w2);
	        if (html.className)
		    html.className=html.className+" _HAVEOPENSANS";
	        else html.className="_HAVEOPENSANS";
	        cleanup();
                return false;}
	    else if ((console.log)&&((tries%20)===0))
	        console.log("["+(now-start)/1000+"s] unloaded, "+
			    "divs still equal @ "+w1+"!="+w2);
	    else {}
            return true;}
        function giveup(){
	    var w1=div1.offsetWidth;
	    var w2=div2.offsetWidth;
	    var now=(new Date()).getTime();
            if (console.log)
                console.log("Giving up on loading Open Sans after "+
                            (now-start)/1000+"s, "+w1+"=="+w2);
            cleanup();}
        if (checking()) {
            itimer=setInterval(checking,check_interval);
            timeout=setTimeout(giveup,timeout_after);}
        return checking;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* From https://github.com/axemclion/IndexedDBShim, BSD License */
/* jshint strict: false, evil: true, expr: true, browser: true */
/* globals console: false, DOMException: false */
var idbModules = {};
(function(idbModules) {
  function callback(fn, context, event, func) {
    event.target = context;
    (typeof context[fn] === "function") && context[fn].apply(context, [event]);
    (typeof func === "function") && func();
  }

  function throwDOMException(name, message, error) {
    var e = new DOMException.constructor(0, message);
    e.name = name;
    e.message = message;
    e.stack = arguments.callee.caller;
    idbModules.DEBUG && console.log(name, message, error, e);
    throw e;
  }
  var StringList = function() {
      this.length = 0;
      this._items = [];
    };
  StringList.prototype = {
    contains: function(str) {
      return -1 !== this._items.indexOf(str);
    },
    item: function(key) {
      return this._items[key];
    },
    indexOf: function(str) {
      return this._items.indexOf(str);
    },
    push: function(item) {
      this._items.push(item);
      this.length += 1;
    },
    splice: function() {
      this._items.splice.apply(this._items, arguments);
      this.length = this._items.length;
    }
  };
  idbModules.util = {
    "throwDOMException": throwDOMException,
    "callback": callback,
    "quote": function(arg) {
      return "'" + arg + "'";
    },
    "StringList": StringList
  };
}(idbModules));
(function(idbModules) {
  var Sca = (function() {
    return {
      "encode": function(val) {
        return JSON.stringify(val);
      },
      "decode": function(val) {
        return JSON.parse(val);
      }
    };
  }());
  idbModules.Sca = Sca;
}(idbModules));
(function(idbModules) {
  var collations = ["", "number", "string", "boolean", "object", "undefined"];
  var getGenericEncoder = function() {
      return {
        "encode": function(key) {
          return collations.indexOf(typeof key) + "-" + JSON.stringify(key);
        },
        "decode": function(key) {
          if (typeof key === "undefined") {
            return undefined;
          } else {
            return JSON.parse(key.substring(2));
          }
        }
      };
    };
  var types = {
    "number": getGenericEncoder("number"),
    "boolean": getGenericEncoder(),
    "object": getGenericEncoder(),
    "string": {
      "encode": function(key) {
        return collations.indexOf("string") + "-" + key;
      },
      "decode": function(key) {
        return "" + key.substring(2);
      }
    },
    "undefined": {
      "encode": function(key) {
        return collations.indexOf("undefined") + "-undefined";
      },
      "decode": function(key) {
        return undefined;
      }
    }
  };
  var Key = (function() {
    return {
      encode: function(key) {
        return types[typeof key].encode(key);
      },
      decode: function(key) {
        return types[collations[key.substring(0, 1)]].decode(key);
      }
    };
  }());
  idbModules.Key = Key;
}(idbModules));
(function(idbModules, undefined) {
  var Event = function(type, debug) {
      return {
        "type": type,
        debug: debug,
        bubbles: false,
        cancelable: false,
        eventPhase: 0,
        timeStamp: new Date()
      };
    };
  idbModules.Event = Event;
}(idbModules));
(function(idbModules) {
  var IDBRequest = function() {
      this.onsuccess = this.onerror = this.result = this.error = this.source = this.transaction = null;
      this.readyState = "pending";
    };
  var IDBOpenRequest = function() {
      this.onblocked = this.onupgradeneeded = null;
    };
  IDBOpenRequest.prototype = IDBRequest;
  idbModules.IDBRequest = IDBRequest;
  idbModules.IDBOpenRequest = IDBOpenRequest;
}(idbModules));
(function(idbModules, undefined) {
  var IDBKeyRange = function(lower, upper, lowerOpen, upperOpen) {
      this.lower = lower;
      this.upper = upper;
      this.lowerOpen = lowerOpen;
      this.upperOpen = upperOpen;
    };
  IDBKeyRange.only = function(value) {
    return new IDBKeyRange(value, value, true, true);
  };
  IDBKeyRange.lowerBound = function(value, open) {
    return new IDBKeyRange(value, undefined, open, undefined);
  };
  IDBKeyRange.upperBound = function(value) {
    return new IDBKeyRange(undefined, value, undefined, open);
  };
  IDBKeyRange.bound = function(lower, upper, lowerOpen, upperOpen) {
    return new IDBKeyRange(lower, upper, lowerOpen, upperOpen);
  };
  idbModules.IDBKeyRange = IDBKeyRange;
}(idbModules));
(function(idbModules, undefined) {
  function IDBCursor(range, direction, idbObjectStore, cursorRequest, keyColumnName, valueColumnName) {
    this.__range = range;
    this.source = this.__idbObjectStore = idbObjectStore;
    this.__req = cursorRequest;
    this.key = undefined;
    this.direction = direction;
    this.__keyColumnName = keyColumnName;
    this.__valueColumnName = valueColumnName;
    if (!this.source.transaction.__active) {
      idbModules.util.throwDOMException("TransactionInactiveError - The transaction this IDBObjectStore belongs to is not active.");
    }
    this.__offset = -1;
    this.__lastKeyContinued = undefined;
    this["continue"]();
  }
  IDBCursor.prototype.__find = function(key, tx, success, error) {
    var me = this;
    var sql = ["SELECT * FROM ", idbModules.util.quote(me.__idbObjectStore.name)];
    var sqlValues = [];
    sql.push("WHERE ", me.__keyColumnName, " NOT NULL");
    if (me.__range && (me.__range.lower || me.__range.upper)) {
      sql.push("AND");
      if (me.__range.lower) {
        sql.push(me.__keyColumnName + (me.__range.lowerOpen ? " >=" : " >") + " ?");
        sqlValues.push(idbModules.Key.encode(me.__range.lower));
      }
      (me.__range.lower && me.__range.upper) && sql.push("AND");
      if (me.__range.upper) {
        sql.push(me.__keyColumnName + (me.__range.upperOpen ? " <= " : " < ") + " ?");
        sqlValues.push(idbModules.Key.encode(me.__range.upper));
      }
    }
    if (typeof key !== "undefined") {
      me.__lastKeyContinued = key;
      me.__offset = 0;
    }
    if (me.__lastKeyContinued !== undefined) {
      sql.push("AND " + me.__keyColumnName + " >= ?");
      sqlValues.push(idbModules.Key.encode(me.__lastKeyContinued));
    }
    sql.push("ORDER BY ", me.__keyColumnName);
    sql.push("LIMIT 1 OFFSET " + me.__offset);
    idbModules.DEBUG && console.log(sql.join(" "), sqlValues);
    tx.executeSql(sql.join(" "), sqlValues, function(tx, data) {
      if (data.rows.length === 1) {
        var key = idbModules.Key.decode(data.rows.item(0)[me.__keyColumnName]);
        var val = me.__valueColumnName === "value" ? idbModules.Sca.decode(data.rows.item(0)[me.__valueColumnName]) : idbModules.Key.decode(data.rows.item(0)[me.__valueColumnName]);
        success(key, val);
      } else {
        idbModules.DEBUG && console.log("Reached end of cursors");
        success(undefined, undefined);
      }
    }, function(tx, data) {
      idbModules.DEBUG && console.log("Could not execute Cursor.continue");
      error(data);
    });
  };
  IDBCursor.prototype["continue"] = function(key) {
    var me = this;
    this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__offset++;
      me.__find(key, tx, function(key, val) {
        me.key = key;
        me.value = val;
        success(typeof me.key !== "undefined" ? me : undefined, me.__req);
      }, function(data) {
        error(data);
      });
    });
  };
  IDBCursor.prototype.advance = function(count) {
    if (count <= 0) {
      idbModules.util.throwDOMException("Type Error - Count is invalid - 0 or negative", count);
    }
    var me = this;
    this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__offset += count;
      me.__find(undefined, tx, function(key, value) {
        me.key = key;
        me.value = value;
        success(typeof me.key !== "undefined" ? me : undefined, me.__req);
      }, function(data) {
        error(data);
      });
    });
  };
  IDBCursor.prototype.update = function(valueToUpdate) {
    var me = this;
    return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__find(undefined, tx, function(key, value) {
        var sql = "UPDATE " + idbModules.util.quote(me.__idbObjectStore.name) + " SET value = ? WHERE key = ?";
        idbModules.DEBUG && console.log(sql, valueToUpdate, key);
        tx.executeSql(sql, [idbModules.Sca.encode(valueToUpdate), idbModules.Key.encode(key)], function(tx, data) {
          if (data.rowsAffected === 1) {
            success(key);
          } else {
            error("No rowns with key found" + key);
          }
        }, function(tx, data) {
          error(data);
        });
      }, function(data) {
        error(data);
      });
    });
  };
  IDBCursor.prototype["delete"] = function() {
    var me = this;
    return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__find(undefined, tx, function(key, value) {
        var sql = "DELETE FROM  " + idbModules.util.quote(me.__idbObjectStore.name) + " WHERE key = ?";
        idbModules.DEBUG && console.log(sql, key);
        tx.executeSql(sql, [idbModules.Key.encode(key)], function(tx, data) {
          if (data.rowsAffected === 1) {
            success(undefined);
          } else {
            error("No rowns with key found" + key);
          }
        }, function(tx, data) {
          error(data);
        });
      }, function(data) {
        error(data);
      });
    });
  };
  idbModules.IDBCursor = IDBCursor;
}(idbModules));
(function(idbModules, undefined) {
  function IDBIndex(indexName, idbObjectStore) {
    this.indexName = indexName;
    this.__idbObjectStore = this.source = idbObjectStore;
  }
  IDBIndex.prototype.__createIndex = function(indexName, keyPath, optionalParameters) {
    var me = this;
    var transaction = me.__idbObjectStore.transaction;
    transaction.__addToTransactionQueue(function(tx, args, success, failure) {
      me.__idbObjectStore.__getStoreProps(tx, function() {
        function error() {
          idbModules.util.throwDOMException(0, "Could not create new index", arguments);
        }
        if (transaction.mode !== 2) {
          idbModules.util.throwDOMException(0, "Invalid State error, not a version transaction", me.transaction);
        }
        var idxList = JSON.parse(me.__idbObjectStore.__storeProps.indexList);
        if (typeof idxList[indexName] !== "undefined") {
          idbModules.util.throwDOMException(0, "Index already exists on store", idxList);
        }
        var columnName = indexName;
        idxList[indexName] = {
          "columnName": columnName,
          "keyPath": keyPath,
          "optionalParams": optionalParameters
        };
        me.__idbObjectStore.__storeProps.indexList = JSON.stringify(idxList);
        var sql = ["ALTER TABLE", idbModules.util.quote(me.__idbObjectStore.name), "ADD", columnName, "BLOB"].join(" ");
        idbModules.DEBUG && console.log(sql);
        tx.executeSql(sql, [], function(tx, data) {
          tx.executeSql("SELECT * FROM " + idbModules.util.quote(me.__idbObjectStore.name), [], function(tx, data) {
            (function initIndexForRow(i) {
              if (i < data.rows.length) {
                try {
                  var value = idbModules.Sca.decode(data.rows.item(i).value);
                  var indexKey = eval("value['" + keyPath + "']");
                  tx.executeSql("UPDATE " + idbModules.util.quote(me.__idbObjectStore.name) + " set " + columnName + " = ? where key = ?", [idbModules.Key.encode(indexKey), data.rows.item(i).key], function(tx, data) {
                    initIndexForRow(i + 1);
                  }, error);
                } catch (e) {
                  initIndexForRow(i + 1);
                }
              } else {
                idbModules.DEBUG && console.log("Updating the indexes in table", me.__idbObjectStore.__storeProps);
                tx.executeSql("UPDATE __sys__ set indexList = ? where name = ?", [me.__idbObjectStore.__storeProps.indexList, me.__idbObjectStore.name], function() {
                  me.__idbObjectStore.__setReadyState("createIndex", true);
                  success(me);
                }, error);
              }
            }(0));
          }, error);
        }, error);
      }, "createObjectStore");
    });
  };
  IDBIndex.prototype.openCursor = function(range, direction) {
    var cursorRequest = new idbModules.IDBRequest();
    var cursor = new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, "value");
    return cursorRequest;
  };
  IDBIndex.prototype.openKeyCursor = function(range, direction) {
    var cursorRequest = new idbModules.IDBRequest();
    var cursor = new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, "key");
    return cursorRequest;
  };
  IDBIndex.prototype.__fetchIndexData = function(key, opType) {
    var me = this;
    return me.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      var sql = ["SELECT * FROM ", idbModules.util.quote(me.__idbObjectStore.name), " WHERE", me.indexName, "NOT NULL"];
      var sqlValues = [];
      if (typeof key !== "undefined") {
        sql.push("AND", me.indexName, " = ?");
        sqlValues.push(idbModules.Key.encode(key));
      }
      idbModules.DEBUG && console.log("Trying to fetch data for Index", sql.join(" "), sqlValues);
      tx.executeSql(sql.join(" "), sqlValues, function(tx, data) {
        var d;
        if (typeof opType === "count") {
          d = data.rows.length;
        } else if (data.rows.length === 0) {
          d = undefined;
        } else if (opType === "key") {
          d = idbModules.Key.decode(data.rows.item(0).key);
        } else {
          d = idbModules.Sca.decode(data.rows.item(0).value);
        }
        success(d);
      }, error);
    });
  };
  IDBIndex.prototype.get = function(key) {
    return this.__fetchIndexData(key, "value");
  };
  IDBIndex.prototype.getKey = function(key) {
    return this.__fetchIndexData(key, "key");
  };
  IDBIndex.prototype.count = function(key) {
    return this.__fetchIndexData(key, "count");
  };
  idbModules.IDBIndex = IDBIndex;
}(idbModules));
(function(idbModules) {
  var IDBObjectStore = function(name, idbTransaction, ready) {
      this.name = name;
      this.transaction = idbTransaction;
      this.__ready = {};
      this.__setReadyState("createObjectStore", typeof ready === "undefined" ? true : ready);
      this.indexNames = new idbModules.util.StringList();
    };
  IDBObjectStore.prototype.__setReadyState = function(key, val) {
    this.__ready[key] = val;
  };
  IDBObjectStore.prototype.__waitForReady = function(callback, key) {
    var ready = true;
    if (typeof key !== "undefined") {
      ready = (typeof this.__ready[key] === "undefined") ? true : this.__ready[key];
    } else {
      for (var x in this.__ready) {
        if (!this.__ready[x]) {
          ready = false;
        }
      }
    }
    if (ready) {
      callback();
    } else {
      idbModules.DEBUG && console.log("Waiting for to be ready", key);
      var me = this;
      window.setTimeout(function() {
        me.__waitForReady(callback, key);
      }, 100);
    }
  };
  IDBObjectStore.prototype.__getStoreProps = function(tx, callback, waitOnProperty) {
    var me = this;
    this.__waitForReady(function() {
      if (me.__storeProps) {
        idbModules.DEBUG && console.log("Store properties - cached", me.__storeProps);
        callback(me.__storeProps);
      } else {
        tx.executeSql("SELECT * FROM __sys__ where name = ?", [me.name], function(tx, data) {
          if (data.rows.length !== 1) {
            callback();
          } else {
            me.__storeProps = {
              "name": data.rows.item(0).name,
              "indexList": data.rows.item(0).indexList,
              "autoInc": data.rows.item(0).autoInc,
              "keyPath": data.rows.item(0).keyPath
            };
            idbModules.DEBUG && console.log("Store properties", me.__storeProps);
            callback(me.__storeProps);
          }
        }, function() {
          callback();
        });
      }
    }, waitOnProperty);
  };
  IDBObjectStore.prototype.__deriveKey = function(tx, value, key, callback) {
    function getNextAutoIncKey() {
      tx.executeSql("SELECT * FROM sqlite_sequence where name like ?", [me.name], function(tx, data) {
        if (data.rows.length !== 1) {
          callback(0);
        } else {
          callback(data.rows.item(0).seq);
        }
      }, function(tx, error) {
        idbModules.util.throwDOMException(0, "Data Error - Could not get the auto increment value for key", error);
      });
    }
    var me = this;
    me.__getStoreProps(tx, function(props) {
      if (!props) {
        idbModules.util.throwDOMException(0, "Data Error - Could not locate defination for this table", props);
      }
      if (props.keyPath) {
        if (typeof key !== "undefined") {
          idbModules.util.throwDOMException(0, "Data Error - The object store uses in-line keys and the key parameter was provided", props);
        }
        if (value) {
          try {
            var primaryKey = eval("value['" + props.keyPath + "']");
            if (!primaryKey) {
              if (props.autoInc === "true") {
                getNextAutoIncKey();
              } else {
                idbModules.util.throwDOMException(0, "Data Error - Could not eval key from keyPath");
              }
            } else {
              callback(primaryKey);
            }
          } catch (e) {
            idbModules.util.throwDOMException(0, "Data Error - Could not eval key from keyPath", e);
          }
        } else {
          idbModules.util.throwDOMException(0, "Data Error - KeyPath was specified, but value was not");
        }
      } else {
        if (typeof key !== "undefined") {
          callback(key);
        } else {
          if (props.autoInc === "false") {
            idbModules.util.throwDOMException(0, "Data Error - The object store uses out-of-line keys and has no key generator and the key parameter was not provided. ", props);
          } else {
            getNextAutoIncKey();
          }
        }
      }
    });
  };
  IDBObjectStore.prototype.__insertData = function(tx, value, primaryKey, success, error) {
    var paramMap = {};
    if (typeof primaryKey !== "undefined") {
      paramMap.key = idbModules.Key.encode(primaryKey);
    }
    var indexes = JSON.parse(this.__storeProps.indexList);
    for (var key in indexes) {
      try {
        paramMap[indexes[key].columnName] = idbModules.Key.encode(eval("value['" + indexes[key].keyPath + "']"));
      } catch (e) {
        error(e);
      }
    }
    var sqlStart = ["INSERT INTO ", idbModules.util.quote(this.name), "("];
    var sqlEnd = [" VALUES ("];
    var sqlValues = [];
    for (key in paramMap) {
      sqlStart.push(key + ",");
      sqlEnd.push("?,");
      sqlValues.push(paramMap[key]);
    }
    sqlStart.push("value )");
    sqlEnd.push("?)");
    sqlValues.push(idbModules.Sca.encode(value));
    var sql = sqlStart.join(" ") + sqlEnd.join(" ");
    idbModules.DEBUG && console.log("SQL for adding", sql, sqlValues);
    tx.executeSql(sql, sqlValues, function(tx, data) {
      success(primaryKey);
    }, function(tx, err) {
      error(err);
    });
  };
  IDBObjectStore.prototype.add = function(value, key) {
    var me = this;
    return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__deriveKey(tx, value, key, function(primaryKey) {
        me.__insertData(tx, value, primaryKey, success, error);
      });
    });
  };
  IDBObjectStore.prototype.put = function(value, key) {
    var me = this;
    return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__deriveKey(tx, value, key, function(primaryKey) {
        var sql = "DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?";
        tx.executeSql(sql, [idbModules.Key.encode(primaryKey)], function(tx, data) {
          idbModules.DEBUG && console.log("Did the row with the", primaryKey, "exist? ", data.rowsAffected);
          me.__insertData(tx, value, primaryKey, success, error);
        }, function(tx, err) {
          error(err);
        });
      });
    });
  };
  IDBObjectStore.prototype.get = function(key) {
    var me = this;
    return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__waitForReady(function() {
        var primaryKey = idbModules.Key.encode(key);
        idbModules.DEBUG && console.log("Fetching", me.name, primaryKey);
        tx.executeSql("SELECT * FROM " + idbModules.util.quote(me.name) + " where key = ?", [primaryKey], function(tx, data) {
          idbModules.DEBUG && console.log("Fetched data", data);
          try {
            if (0 === data.rows.length) {
              return success();
            }
            success(idbModules.Sca.decode(data.rows.item(0).value));
          } catch (e) {
            idbModules.DEBUG && console.log(e);
            success(undefined);
          }
        }, function(tx, err) {
          error(err);
        });
      });
    });
  };
  IDBObjectStore.prototype["delete"] = function(key) {
    var me = this;
    return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__waitForReady(function() {
        var primaryKey = idbModules.Key.encode(key);
        idbModules.DEBUG && console.log("Fetching", me.name, primaryKey);
        tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?", [primaryKey], function(tx, data) {
          idbModules.DEBUG && console.log("Deleted from database", data.rowsAffected);
          success();
        }, function(tx, err) {
          error(err);
        });
      });
    });
  };
  IDBObjectStore.prototype.clear = function() {
    var me = this;
    return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__waitForReady(function() {
        tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name), [], function(tx, data) {
          idbModules.DEBUG && console.log("Cleared all records from database", data.rowsAffected);
          success();
        }, function(tx, err) {
          error(err);
        });
      });
    });
  };
  IDBObjectStore.prototype.count = function(key) {
    var me = this;
    return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
      me.__waitForReady(function() {
        var sql = "SELECT * FROM " + idbModules.util.quote(me.name) + ((typeof key !== "undefined") ? " WHERE key = ?" : "");
        var sqlValues = [];
        (typeof key !== "undefined") && sqlValues.push(idbModules.Key.encode(key));
        tx.executeSql(sql, sqlValues, function(tx, data) {
          success(data.rows.length);
        }, function(tx, err) {
          error(err);
        });
      });
    });
  };
  IDBObjectStore.prototype.openCursor = function(range, direction) {
    var cursorRequest = new idbModules.IDBRequest();
    var cursor = new idbModules.IDBCursor(range, direction, this, cursorRequest, "key", "value");
    return cursorRequest;
  };
  IDBObjectStore.prototype.index = function(indexName) {
    var index = new idbModules.IDBIndex(indexName, this);
    return index;
  };
  IDBObjectStore.prototype.createIndex = function(indexName, keyPath, optionalParameters) {
    var me = this;
    optionalParameters = optionalParameters || {};
    me.__setReadyState("createIndex", false);
    var result = new idbModules.IDBIndex(indexName, me);
    me.__waitForReady(function() {
      result.__createIndex(indexName, keyPath, optionalParameters);
    }, "createObjectStore");
    me.indexNames.push(indexName);
    return result;
  };
  IDBObjectStore.prototype.deleteIndex = function(indexName) {
    var result = new idbModules.IDBIndex(indexName, this, false);
    result.__deleteIndex(indexName);
    return result;
  };
  idbModules.IDBObjectStore = IDBObjectStore;
}(idbModules));
(function(idbModules) {
  var READ = 0;
  var READ_WRITE = 1;
  var VERSION_TRANSACTION = 2;
  var IDBTransaction = function(storeNames, mode, db) {
      if (typeof mode === "number") {
        this.mode = mode;
        (mode !== 2) && idbModules.DEBUG && console.log("Mode should be a string, but was specified as ", mode);
      } else if (typeof mode === "string") {
        switch (mode) {
        case "readonly":
          this.mode = READ_WRITE;
          break;
        case "readwrite":
          this.mode = READ;
          break;
        default:
          this.mode = READ;
          break;
        }
      }
      this.storeNames = typeof storeNames === "string" ? [storeNames] : storeNames;
      for (var i = 0; i < this.storeNames.length; i++) {
        if (!db.objectStoreNames.contains(this.storeNames[i])) {
          idbModules.util.throwDOMException(0, "The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.", this.storeNames[i]);
        }
      }
      this.__active = true;
      this.__running = false;
      this.__requests = [];
      this.__aborted = false;
      this.db = db;
      this.error = null;
      this.onabort = this.onerror = this.oncomplete = null;
      var me = this;
    };
  IDBTransaction.prototype.__executeRequests = function() {
    if (this.__running && this.mode !== VERSION_TRANSACTION) {
      idbModules.DEBUG && console.log("Looks like the request set is already running", this.mode);
      return;
    }
    this.__running = true;
    var me = this;
    window.setTimeout(function() {
      if (me.mode !== 2 && !me.__active) {
        idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished", me.__active);
      }
      me.db.__db.transaction(function(tx) {
        me.__tx = tx;
        var q = null,
          i = 0;

        function success(result, req) {
          if (req) {
            q.req = req;
          }
          q.req.readyState = "done";
          q.req.result = result;
          delete q.req.error;
          var e = idbModules.Event("success");
          idbModules.util.callback("onsuccess", q.req, e);
          i++;
          executeRequest();
        }

        function error(errorVal) {
          q.req.readyState = "done";
          q.req.error = "DOMError";
          var e = idbModules.Event("error", arguments);
          idbModules.util.callback("onerror", q.req, e);
          i++;
          executeRequest();
        }
        try {
          function executeRequest() {
            if (i >= me.__requests.length) {
              me.__active = false;
              me.__requests = [];
              return;
            }
            q = me.__requests[i];
            q.op(tx, q.args, success, error);
          }
          executeRequest();
        } catch (e) {
          idbModules.DEBUG && console.log("An exception occured in transaction", arguments);
          typeof me.onerror === "function" && me.onerror();
        }
      }, function() {
        idbModules.DEBUG && console.log("An error in transaction", arguments);
        typeof me.onerror === "function" && me.onerror();
      }, function() {
        idbModules.DEBUG && console.log("Transaction completed", arguments);
        typeof me.oncomplete === "function" && me.oncomplete();
      });
    }, 1);
  };
  IDBTransaction.prototype.__addToTransactionQueue = function(callback, args) {
    if (!this.__active && this.mode !== VERSION_TRANSACTION) {
      idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished.", this.__mode);
    }
    var request = new idbModules.IDBRequest();
    request.source = this.db;
    this.__requests.push({
      "op": callback,
      "args": args,
      "req": request
    });
    this.__executeRequests();
    return request;
  };
  IDBTransaction.prototype.objectStore = function(objectStoreName) {
    return new idbModules.IDBObjectStore(objectStoreName, this);
  };
  IDBTransaction.prototype.abort = function() {
    !this.__active && idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished", this.__active);
  };
  IDBTransaction.prototype.READ_ONLY = 0;
  IDBTransaction.prototype.READ_WRITE = 1;
  IDBTransaction.prototype.VERSION_CHANGE = 2;
  idbModules.IDBTransaction = IDBTransaction;
}(idbModules));
(function(idbModules) {
  var IDBDatabase = function(db, name, version, storeProperties) {
      this.__db = db;
      this.version = version;
      this.__storeProperties = storeProperties;
      this.objectStoreNames = new idbModules.util.StringList();
      for (var i = 0; i < storeProperties.rows.length; i++) {
        this.objectStoreNames.push(storeProperties.rows.item(i).name);
      }
      this.name = name;
      this.onabort = this.onerror = this.onversionchange = null;
    };
  IDBDatabase.prototype.createObjectStore = function(storeName, createOptions) {
    var me = this;
    createOptions = createOptions || {};
    createOptions.keyPath = createOptions.keyPath || null;
    var result = new idbModules.IDBObjectStore(storeName, me.__versionTransaction, false);
    var transaction = me.__versionTransaction;
    transaction.__addToTransactionQueue(function(tx, args, success, failure) {
      function error() {
        idbModules.util.throwDOMException(0, "Could not create new object store", arguments);
      }
      if (!me.__versionTransaction) {
        idbModules.util.throwDOMException(0, "Invalid State error", me.transaction);
      }
      var sql = ["CREATE TABLE", idbModules.util.quote(storeName), "(key BLOB", createOptions.autoIncrement ? ", inc INTEGER PRIMARY KEY AUTOINCREMENT" : "PRIMARY KEY", ", value BLOB)"].join(" ");
      idbModules.DEBUG && console.log(sql);
      tx.executeSql(sql, [], function(tx, data) {
        tx.executeSql("INSERT INTO __sys__ VALUES (?,?,?,?)", [storeName, createOptions.keyPath, createOptions.autoIncrement ? true : false, "{}"], function() {
          result.__setReadyState("createObjectStore", true);
          success(result);
        }, error);
      }, error);
    });
    me.objectStoreNames.push(storeName);
    return result;
  };
  IDBDatabase.prototype.deleteObjectStore = function(storeName) {
    var error = function() {
        idbModules.util.throwDOMException(0, "Could not delete ObjectStore", arguments);
      };
    var me = this;
    !me.objectStoreNames.contains(storeName) && error("Object Store does not exist");
    me.objectStoreNames.splice(me.objectStoreNames.indexOf(storeName), 1);
    var transaction = me.__versionTransaction;
    transaction.__addToTransactionQueue(function(tx, args, success, failure) {
      if (!me.__versionTransaction) {
        idbModules.util.throwDOMException(0, "Invalid State error", me.transaction);
      }
      me.__db.transaction(function(tx) {
        tx.executeSql("SELECT * FROM __sys__ where name = ?", [storeName], function(tx, data) {
          if (data.rows.length > 0) {
            tx.executeSql("DROP TABLE " + idbModules.util.quote(storeName), [], function() {
              tx.executeSql("DELETE FROM __sys__ WHERE name = ?", [storeName], function() {}, error);
            }, error);
          }
        });
      });
    });
  };
  IDBDatabase.prototype.close = function() {};
  IDBDatabase.prototype.transaction = function(storeNames, mode) {
    var transaction = new idbModules.IDBTransaction(storeNames, mode || 1, this);
    return transaction;
  };
  idbModules.IDBDatabase = IDBDatabase;
}(idbModules));
(function(idbModules) {
  var DEFAULT_DB_SIZE = 4 * 1024 * 1024;
  if (!window.openDatabase) {
    return;
  }
  var sysdb = window.openDatabase("__sysdb__", 1, "System Database", DEFAULT_DB_SIZE);
  sysdb.transaction(function(tx) {
    tx.executeSql("SELECT * FROM dbVersions", [], function(t, data) {}, function() {
      sysdb.transaction(function(tx) {
        tx.executeSql("CREATE TABLE IF NOT EXISTS dbVersions (name VARCHAR(255), version INT);", [], function() {}, function() {
          idbModules.util.throwDOMException("Could not create table __sysdb__ to save DB versions");
        });
      });
    });
  }, function() {
    idbModules.DEBUG && console.log("Error in sysdb transaction - when selecting from dbVersions", arguments);
  });
  var shimIndexedDB = {
    open: function(name, version) {
      var req = new idbModules.IDBOpenRequest();
      var calledDbCreateError = false;

      function dbCreateError() {
        if (calledDbCreateError) {
          return;
        }
        var e = idbModules.Event("error", arguments);
        req.readyState = "done";
        req.error = "DOMError";
        idbModules.util.callback("onerror", req, e);
        calledDbCreateError = true;
      }

      function openDB(oldVersion) {
        var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
        req.readyState = "done";
        if (typeof version === "undefined") {
          version = oldVersion || 1;
        }
        if (version <= 0 || oldVersion > version) {
          idbModules.util.throwDOMException(0, "An attempt was made to open a database using a lower version than the existing version.", version);
        }
        db.transaction(function(tx) {
          tx.executeSql("CREATE TABLE IF NOT EXISTS __sys__ (name VARCHAR(255), keyPath VARCHAR(255), autoInc BOOLEAN, indexList BLOB)", [], function() {
            tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
              var e = idbModules.Event("success");
              req.source = req.result = new idbModules.IDBDatabase(db, name, version, data);
              if (oldVersion < version) {
                sysdb.transaction(function(systx) {
                  systx.executeSql("UPDATE dbVersions set version = ? where name = ?", [version, name], function() {
                    var e = idbModules.Event("upgradeneeded");
                    e.oldVersion = oldVersion;
                    e.newVersion = version;
                    req.transaction = req.result.__versionTransaction = new idbModules.IDBTransaction([], 2, req.source);
                    idbModules.util.callback("onupgradeneeded", req, e, function() {
                      var e = idbModules.Event("success");
                      idbModules.util.callback("onsuccess", req, e);
                    });
                  }, dbCreateError);
                }, dbCreateError);
              } else {
                idbModules.util.callback("onsuccess", req, e);
              }
            }, dbCreateError);
          }, dbCreateError);
        }, dbCreateError);
      }
      sysdb.transaction(function(tx) {
        tx.executeSql("SELECT * FROM dbVersions where name = ?", [name], function(tx, data) {
          if (data.rows.length === 0) {
            tx.executeSql("INSERT INTO dbVersions VALUES (?,?)", [name, version || 1], function() {
              openDB(0);
            }, dbCreateError);
          } else {
            openDB(data.rows.item(0).version);
          }
        }, dbCreateError);
      }, dbCreateError);
      return req;
    },
    "deleteDatabase": function(name) {
      var req = new idbModules.IDBOpenRequest();
      var calledDBError = false;

      function dbError(msg) {
        if (calledDBError) {
          return;
        }
        req.readyState = "done";
        req.error = "DOMError";
        var e = idbModules.Event("error");
        e.message = msg;
        e.debug = arguments;
        idbModules.util.callback("onerror", req, e);
        calledDBError = true;
      }
      var version = null;

      function deleteFromDbVersions() {
        sysdb.transaction(function(systx) {
          systx.executeSql("DELETE FROM dbVersions where name = ? ", [name], function() {
            req.result = undefined;
            var e = idbModules.Event("success");
            e.newVersion = null;
            e.oldVersion = version;
            idbModules.util.callback("onsuccess", req, e);
          }, dbError);
        }, dbError);
      }
      sysdb.transaction(function(systx) {
        systx.executeSql("SELECT * FROM dbVersions where name = ?", [name], function(tx, data) {
          if (data.rows.length === 0) {
            req.result = undefined;
            var e = idbModules.Event("success");
            e.newVersion = null;
            e.oldVersion = version;
            idbModules.util.callback("onsuccess", req, e);
            return;
          }
          version = data.rows.item(0).version;
          var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
          db.transaction(function(tx) {
            tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
              var tables = data.rows;
              (function deleteTables(i) {
                if (i >= tables.length) {
                  tx.executeSql("DROP TABLE __sys__", [], function() {
                    deleteFromDbVersions();
                  }, dbError);
                } else {
                  tx.executeSql("DROP TABLE " + idbModules.util.quote(tables.item(i).name), [], function() {
                    deleteTables(i + 1);
                  }, function() {
                    deleteTables(i + 1);
                  });
                }
              }(0));
            }, function(e) {
              deleteFromDbVersions();
            });
          }, dbError);
        });
      }, dbError);
      return req;
    },
    "cmp": function(key1, key2) {
      return idbModules.Key.encode(key1) > idbModules.Key.encode(key2) ? 1 : key1 === key2 ? 0 : -1;
    }
  };
  idbModules.shimIndexedDB = shimIndexedDB;
}(idbModules));
(function(window, idbModules) {
  if (typeof window.openDatabase !== "undefined") {
    window.shimIndexedDB = idbModules.shimIndexedDB;
    if (window.shimIndexedDB) {
      window.shimIndexedDB.__useShim = function() {
        window.indexedDB = idbModules.shimIndexedDB;
        window.IDBDatabase = idbModules.IDBDatabase;
        window.IDBTransaction = idbModules.IDBTransaction;
        window.IDBCursor = idbModules.IDBCursor;
        window.IDBKeyRange = idbModules.IDBKeyRange;
      };
      window.shimIndexedDB.__debug = function(val) {
        idbModules.DEBUG = val;
      };
    }
  }
  window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB;
  if (typeof window.indexedDB === "undefined" && typeof window.openDatabase !== "undefined") {
    window.shimIndexedDB.__useShim();
  } else {
    window.IDBDatabase = window.IDBDatabase || window.webkitIDBDatabase;
    window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
    window.IDBCursor = window.IDBCursor || window.webkitIDBCursor;
    window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
    window.IDBTransaction.READ_ONLY = window.IDBTransaction.READ_ONLY || "readonly";
    window.IDBTransaction.READ_WRITE = window.IDBTransaction.READ_WRITE || "readwrite";
  }
}(window, idbModules));

/* -*- Mode: Javascript; -*- */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file was created from several component files and is
   part of the FDJT web toolkit (www.fdjt.org)

   Portions of this code are available under the following license:
   * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
   * Released under MIT license, http://cubiq.org/license

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   The copyright notice of the individual files are all prefixed by
   a copyright notice of the form "Copyright (C) ...".

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

var fdjt=((typeof fdjt === "undefined")?({}):(fdjt));
var fdjt_versions=((typeof fdjt_versions === "undefined")?([]):
		   ((fdjt_versions)||[]));
(function(){
    "use strict";
    fdjt_versions.decl=function(name,num){
        if ((!(fdjt_versions[name]))||(fdjt_versions[name]<num))
            fdjt_versions[name]=num;};

    // Some augmentations
    if (!(Array.prototype.indexOf))
        Array.prototype.indexOf=function(elt,i){
            if (!(i)) i=0; var len=this.length;
            while (i<len) if (this[i]===elt) return i; else i++;
            return -1;};
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
    if (!Object.keys) {
        Object.keys = function(o){
            if (o !== Object(o))
                throw new TypeError('Object.keys called on non-object');
            var ret=[], p;
            for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) ret.push(p);
            return ret;};}

    if (!String.prototype.trim) {
        String.prototype.trim = (function () {
            var trimLeft  = /^\s+/, trimRight = /\s+$/;
            
            return function () {
                return this.replace(trimLeft, "").replace(trimRight, "");};});}
})();
(function() {
    "use strict";
    /* For jshint */
    /* global global: false, window: false, 
              module: false, setTimeout: false */
    var root;

    if (typeof window === 'object' && window) {
        root = window;
    } else {
        root = global;
    }

    // Use polyfill for setImmediate for performance gains
    var asap = ((root.Promise)&&(root.Promise.immediateFn)) ||
        root.setImmediate ||
        function(fn) { setTimeout(fn, 1); };

    // Polyfill for Function.prototype.bind
    function bind(fn, thisArg) {
        return function() {
            fn.apply(thisArg, arguments);
        };
    }

    var isArray = Array.isArray || function(value) {
        return Object.prototype.toString.call(value) ===
            "[object Array]"; };

    function PromiseFillIn(fn) {
        if (typeof this !== 'object')
            throw new TypeError('Use "new" to make Promises');
        if (typeof fn !== 'function')
            throw new TypeError('not a function');
        this._state = null;
        this._value = null;
        this._deferreds = [];

        doResolve(fn, bind(resolve, this), bind(reject, this));
    }

    function handle(deferred) {
	// jshint validthis: true
        var me = this;
        if (this._state === null) {
            this._deferreds.push(deferred);
            return;
        }
        asap(function() {
            var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
            if (cb === null) {
                (me._state ? deferred.resolve : deferred.reject)(me._value);
                return;
            }
            var ret;
            try {
                ret = cb(me._value);
            }
            catch (e) {
                deferred.reject(e);
                return;
            }
            deferred.resolve(ret);
        });
    }

    function resolve(newValue) {
	// jshint validthis: true
        try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
            if (newValue === this)
                throw new TypeError(
                    'A promise cannot be resolved with itself.');
            if (newValue &&
                (typeof newValue === 'object' ||
                 typeof newValue === 'function')) {
                var then = newValue.then;
                if (typeof then === 'function') {
                    doResolve(bind(then, newValue),
                              bind(resolve, this),
                              bind(reject, this));
                    return;
                }
            }
            this._state = true;
            this._value = newValue;
            finale.call(this);
        } catch (e) { reject.call(this, e); }
    }

    function reject(newValue) {
	// jshint validthis: true
        this._state = false;
        this._value = newValue;
        finale.call(this);
    }

    function finale() {
	// jshint validthis: true
        for (var i = 0, len = this._deferreds.length;
             i < len;
             i++) {
            handle.call(this, this._deferreds[i]);
        }
        this._deferreds = null;
    }
    
    function Handler(onFulfilled, onRejected, resolve, reject){
        this.onFulfilled =
            typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected =
            typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
    }

    /**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */
    function doResolve(fn, onFulfilled, onRejected) {
        var done = false;
        try {
            fn(function (value) {
                if (done) return;
                done = true;
                onFulfilled(value);
            }, function (reason) {
                if (done) return;
                done = true;
                onRejected(reason);
            });
        } catch (ex) {
            if (done) return;
            done = true;
            onRejected(ex);
        }
    }

    PromiseFillIn.prototype['catch'] = function (onRejected) {
        return this.then(null, onRejected);
    };

    PromiseFillIn.prototype.then =
        function(onFulfilled, onRejected) {
            var me = this;
            return new PromiseFillIn(function(resolve, reject) {
                handle.call(
                    me,new Handler(onFulfilled, onRejected,
                                   resolve, reject));
            });
        };
    
    PromiseFillIn.all = function () {
        var args = Array.prototype.slice.call(
            arguments.length === 1 && isArray(arguments[0]) ?
                arguments[0] : arguments);

        return new PromiseFillIn(function (resolve, reject) {
            if (args.length === 0) return resolve([]);
            var remaining = args.length;
            function res(i, val) {
                try {
                    if (val &&
                        (typeof val === 'object' ||
                         typeof val === 'function')) {
                        var then = val.then;
                        if (typeof then === 'function') {
                            then.call(val, function (val) {
                                res(i, val); }, reject);
                            return;
                        }
                    }
                    args[i] = val;
                    if (--remaining === 0) {
                        resolve(args);
                    }
                } catch (ex) {
                    reject(ex);
                }
            }
            for (var i = 0; i < args.length; i++) {
                res(i, args[i]);
            }
        });
    };

    PromiseFillIn.resolve = function (value) {
        if (value && typeof value === 'object' &&
            value.constructor === PromiseFillIn) {
            return value;
        }

        return new PromiseFillIn(function (resolve) {
            resolve(value);
        });
    };

    PromiseFillIn.reject = function (value) {
        return new PromiseFillIn(function (resolve, reject) {
            reject(value);
        });
    };

    PromiseFillIn.race = function (values) {
        return new PromiseFillIn(function (resolve, reject) {
            for(var i = 0, len = values.length; i < len; i++) {
                values[i].then(resolve, reject);
            }
        });
    };

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = PromiseFillIn;
    } else if (!root.Promise) {
        root.Promise = PromiseFillIn;
    }
})();
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/async.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
    of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use, modification, and redistribution of this program is permitted
    under either the GNU General Public License (GPL) Version 2 (or
    any later version) or under the GNU Lesser General Public License
    (version 3 or later).

    These licenses may be found at www.gnu.org, particularly:
      http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
      http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

/* Time functions */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.Async=fdjt.ASync=fdjt.async=
    (function (){
        "use strict";
        /* global
           setTimeout: false, clearTimeout: false,
           Promise: false */

        function fdjtAsync(fn,args){
            function async_call(resolve,reject){
                function doit(){
                    var value;
                    try {
                        if (args) value=fn.call(null,args);
                        else value=fn();
                        resolve(value);}
                    catch (ex) {reject(ex);}}
                setTimeout(doit,1);}
            return new Promise(async_call);}

        function getnow() {return (new Date()).getTime();}

        function timeslice(fcns,slice,space,stop,done,fail){
            var timer=false;
            if (typeof slice !== 'number') slice=100;
            if (typeof space !== 'number') space=100;
            var i=0; var lim=fcns.length;
            var slicefn=function(){
                var timelim=getnow()+slice;
                var nextspace=false;
                while (i<lim) {
                    var fcn=fcns[i++];
                    if (!(fcn)) continue;
                    else if (typeof fcn === 'number') {
                        nextspace=fcn; break;}
                    else {
                        try {fcn();} catch (ex) {fail(ex);}}
                    if (getnow()>timelim) break;}
                if ((i<lim)&&((!(stop))||(!(stop()))))
                    timer=setTimeout(slicefn,nextspace||space);
                else {
                    clearTimeout(timer); 
                    timer=false;
                    done(false);}};
            return slicefn();}
        fdjtAsync.timeslice=function(fcns,opts){
            if (!(opts)) opts={};
            var slice=opts.slice||100, space=opts.space||100;
            var stop=opts.stop||false;
            function timeslicing(success,failure){
                timeslice(fcns,slice,space,stop,success,failure);}
            return new Promise(timeslicing);};

        function slowmap(fn,vec,watch,done,failed,slice,space,onerr,watch_slice){
            var i=0; var lim=vec.length; var chunks=0;
            var used=0; var zerostart=getnow();
            var timer=false;
            if (!(slice)) slice=100;
            if (!(space)) space=slice;
            if (!(watch_slice)) watch_slice=0;
            var stepfn=function(){
                try {
                    var started=getnow(); var now=started;
                    var stopat=started+slice;
                    if (watch)
                        watch(((i===0)?'start':'resume'),i,lim,chunks,used,
                              zerostart);
                    while ((i<lim)&&((now=getnow())<stopat)) {
                        var elt=vec[i];
                        if ((watch)&&(((watch_slice)&&((i%watch_slice)===0))||
                                      (i+1===lim)))
                            watch('element',i,lim,elt,used,now-zerostart);
                        try {fn(elt);}
                        catch (ex) {
                            var exdata={elt: elt,i: i,lim: lim,vec: vec};
                            if ((onerr)&&(onerr(ex,elt,exdata))) continue;
                            if (failed) return failed(ex);
                            else throw ex;}
                        if ((watch)&&(((watch_slice)&&((i%watch_slice)===0))||
                                      (i+1===lim)))
                            watch('after',i,lim,elt,used+(getnow()-started),
                                  zerostart,getnow()-now);
                        i++;}
                    chunks=chunks+1;
                    if (i<lim) {
                        used=used+(now-started);
                        if (watch) watch('suspend',i,lim,chunks,used,
                                         zerostart);
                        timer=setTimeout(stepfn,space);}
                    else {
                        now=getnow(); used=used+(now-started);
                        clearTimeout(timer); timer=false;
                        if (watch)
                            watch('finishing',i,lim,chunks,used,zerostart);
                        var donetime=((done)&&(getnow()-now));
                        now=getnow(); used=used+(now-started);
                        if (watch)
                            watch('done',i,lim,chunks,used,zerostart,donetime);
                        if ((done)&&(done.call)) 
                            done(vec,now-zerostart,used);}}
                catch (ex) {if (failed) failed(ex);}};
            timer=setTimeout(stepfn,space);}
        fdjtAsync.slowmap=function(fcn,vec,opts){
            if (!(opts)) opts={};
            var slice=opts.slice, space=opts.space, onerr=opts.onerr;
            var watchfn=opts.watchfn, watch_slice=opts.watch;
            var sync=((opts.hasOwnProperty("sync"))?(opts.sync):
                      ((opts.hasOwnProperty("async"))?(!(opts.async)):
                       (false)));
            var donefn=opts.done;
            function slowmapping(resolve,reject){
                if (sync) {
                    var i=0, lim=vec.length; while (i<lim) {
                        var elt=vec[i++];
                        try { fcn(vec[elt]); }
                        catch (ex) {
                            var exdata={elt: elt,i: i,lim: lim,vec: vec};
                            if ((onerr)&&(onerr(ex,elt,exdata))) continue;
                            if (reject) return reject(ex);
                            else throw ex;}}
                    if (resolve) resolve(vec);}
                else slowmap(fcn,vec,watchfn,
                             ((donefn)?(function(){
                                 donefn(); if (resolve) resolve(vec);}):
                              (resolve)),
                             reject,
                             slice,space,onerr,watch_slice);}
            if (watch_slice<1) watch_slice=vec.length*watch_slice;
            return new Promise(slowmapping);};

        // Returns a function, that, as long as it continues to be invoked, will not
        // be triggered. The function will be called after it stops being called for
        // N milliseconds. If `immediate` is passed, trigger the function on the
        // leading edge, instead of the trailing.
        function debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this, args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        }
        fdjtAsync.debounce=debounce;

        function poll(fn, callback, errback, timeout, interval) {
            var endTime = Number(new Date()) + (timeout || 2000);
            interval = interval || 100;

            (function p() {
                // If the condition is met, we're done! 
                if(fn()) {
                    callback();
                }
                // If the condition isn't met but the timeout hasn't elapsed, go again
                else if (Number(new Date()) < endTime) {
                    setTimeout(p, interval);
                }
                // Didn't match and too much time, reject!
                else {
                    errback(new Error('timed out for ' + fn + ': ' + arguments));
                }
            })();
        }
        fdjtAsync.poll=poll;

        function once(fn, context) { 
            var result;

            return function() { 
                if(fn) {
                    result = fn.apply(context || this, arguments);
                    fn = null;
                }

                return result;
            };
        }
        fdjtAsync.once=once;

        return fdjtAsync;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/string.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.charnames={"AElig": "Æ",
		"Aacgr": "Ά",
		"Aacute": "Á",
		"Abreve": "Ă",
		"Acirc": "Â",
		"Acy": "А",
		"Agr": "Α",
		"Agrave": "À",
		"Alpha": "Α",
		"Amacr": "Ā",
		"Aogon": "Ą",
		"Aring": "Å",
		"Atilde": "Ã",
		"Auml": "Ä",
		"Barwed": "⌆",
		"Bcy": "Б",
		"Beta": "Β",
		"Bgr": "Β",
		"CHcy": "Ч",
		"Cacute": "Ć",
		"Cap": "⋒",
		"Ccaron": "Č",
		"Ccedil": "Ç",
		"Ccirc": "Ĉ",
		"Cdot": "Ċ",
		"Chi": "Χ",
		"Cup": "⋓",
		"DJcy": "Ђ",
		"DScy": "Ѕ",
		"DZcy": "Џ",
		"Dagger": "‡",
		"Dcaron": "Ď",
		"Dcy": "Д",
		"Delta": "Δ",
		"Dgr": "Δ",
		"Dot": "¨",
		"DotDot": "⃜",
		"Dstrok": "Đ",
		"EEacgr": "Ή",
		"EEgr": "Η",
		"ENG": "Ŋ",
		"ETH": "Ð",
		"Eacgr": "Έ",
		"Eacute": "É",
		"Ecaron": "Ě",
		"Ecirc": "Ê",
		"Ecy": "Э",
		"Edot": "Ė",
		"Egr": "Ε",
		"Egrave": "È",
		"Emacr": "Ē",
		"Eogon": "Ę",
		"Epsilon": "Ε",
		"Eta": "Η",
		"Euml": "Ë",
		"Fcy": "Ф",
		"GJcy": "Ѓ",
		"Gamma": "Γ",
		"Gbreve": "Ğ",
		"Gcedil": "Ģ",
		"Gcirc": "Ĝ",
		"Gcy": "Г",
		"Gdot": "Ġ",
		"Gg": "⋙",
		"Ggr": "Γ",
		"Gt": "≫",
		"HARDcy": "Ъ",
		"Hcirc": "Ĥ",
		"Hstrok": "Ħ",
		"IEcy": "Е",
		"IJlig": "Ĳ",
		"IOcy": "Ё",
		"Iacgr": "Ί",
		"Iacute": "Í",
		"Icirc": "Î",
		"Icy": "И",
		"Idigr": "Ϊ",
		"Idot": "İ",
		"Igr": "Ι",
		"Igrave": "Ì",
		"Imacr": "Ī",
		"Iogon": "Į",
		"Iota": "Ι",
		"Itilde": "Ĩ",
		"Iukcy": "І",
		"Iuml": "Ï",
		"Jcirc": "Ĵ",
		"Jcy": "Й",
		"Jsercy": "Ј",
		"Jukcy": "Є",
		"KHcy": "Х",
		"KHgr": "Χ",
		"KJcy": "Ќ",
		"Kappa": "Κ",
		"Kcedil": "Ķ",
		"Kcy": "К",
		"Kgr": "Κ",
		"LJcy": "Љ",
		"Lacute": "Ĺ",
		"Lambda": "Λ",
		"Larr": "↞",
		"Lcaron": "Ľ",
		"Lcedil": "Ļ",
		"Lcy": "Л",
		"Lgr": "Λ",
		"Ll": "⋘",
		"Lmidot": "Ŀ",
		"Lstrok": "Ł",
		"Lt": "≪",
		"Mcy": "М",
		"Mgr": "Μ",
		"Mu": "Μ",
		"NJcy": "Њ",
		"Nacute": "Ń",
		"Ncaron": "Ň",
		"Ncedil": "Ņ",
		"Ncy": "Н",
		"Ngr": "Ν",
		"Ntilde": "Ñ",
		"Nu": "Ν",
		"OElig": "Œ",
		"OHacgr": "Ώ",
		"OHgr": "Ω",
		"Oacgr": "Ό",
		"Oacute": "Ó",
		"Ocirc": "Ô",
		"Ocy": "О",
		"Odblac": "Ő",
		"Ogr": "Ο",
		"Ograve": "Ò",
		"Omacr": "Ō",
		"Omega": "Ω",
		"Omicron": "Ο",
		"Oslash": "Ø",
		"Otilde": "Õ",
		"Ouml": "Ö",
		"PHgr": "Φ",
		"PSgr": "Ψ",
		"Pcy": "П",
		"Pgr": "Π",
		"Phi": "Φ",
		"Pi": "Π",
		"Prime": "″",
		"Psi": "Ψ",
		"Racute": "Ŕ",
		"Rarr": "↠",
		"Rcaron": "Ř",
		"Rcedil": "Ŗ",
		"Rcy": "Р",
		"Rgr": "Ρ",
		"Rho": "Ρ",
		"SHCHcy": "Щ",
		"SHcy": "Ш",
		"SOFTcy": "Ь",
		"Sacute": "Ś",
		"Scaron": "Š",
		"Scedil": "Ş",
		"Scirc": "Ŝ",
		"Scy": "С",
		"Sgr": "Σ",
		"Sigma": "Σ",
		"Sub": "⋐",
		"Sup": "⋑",
		"THORN": "Þ",
		"THgr": "Θ",
		"TSHcy": "Ћ",
		"TScy": "Ц",
		"Tau": "Τ",
		"Tcaron": "Ť",
		"Tcedil": "Ţ",
		"Tcy": "Т",
		"Tgr": "Τ",
		"Theta": "Θ",
		"Tstrok": "Ŧ",
		"Uacgr": "Ύ",
		"Uacute": "Ú",
		"Ubrcy": "Ў",
		"Ubreve": "Ŭ",
		"Ucirc": "Û",
		"Ucy": "У",
		"Udblac": "Ű",
		"Ugr": "Υ",
		"Ugrave": "Ù",
		"Umacr": "Ū",
		"Uogon": "Ų",
		"Upsi": "Υ",
		"Upsilon": "Υ",
		"Uring": "Ů",
		"Utilde": "Ũ",
		"Uuml": "Ü",
		"Vcy": "В",
		"Vdash": "⊩",
		"Verbar": "‖",
		"Vvdash": "⊪",
		"Wcirc": "Ŵ",
		"Xgr": "Ξ",
		"Xi": "Ξ",
		"YAcy": "Я",
		"YIcy": "Ї",
		"YUcy": "Ю",
		"Yacute": "Ý",
		"Ycirc": "Ŷ",
		"Ycy": "Ы",
		"Yuml": "Ÿ",
		"ZHcy": "Ж",
		"Zacute": "Ź",
		"Zcaron": "Ž",
		"Zcy": "З",
		"Zdot": "Ż",
		"Zeta": "Ζ",
		"Zgr": "Ζ",
		"aacgr": "ά",
		"aacute": "á",
		"abreve": "ă",
		"acirc": "â",
		"acute": "´",
		"acy": "а",
		"aelig": "æ",
		"agr": "α",
		"agrave": "à",
		"alefsym": "ℵ",
		"aleph": "ℵ",
		"alpha": "α",
		"amacr": "ā",
		"amalg": "∐",
		"amp": "&",
		"and": "∧",
		"ang": "∠",
		"ang90": "∟",
		"angmsd": "∡",
		"angsph": "∢",
		"angst": "Å",
		"aogon": "ą",
		"ap": "≈",
		"ape": "≊",
		"apos": "'",
		"aposmod": "ʼ",
		"aring": "å",
		"ast": "*",
		"asymp": "≈",
		"atilde": "ã",
		"auml": "ä",
		"b.Delta": "Δ",
		"b.Gamma": "Γ",
		"b.Lambda": "Λ",
		"b.Omega": "Ω",
		"b.Phi": "Φ",
		"b.Pi": "Π",
		"b.Psi": "Ψ",
		"b.Sigma": "Σ",
		"b.Theta": "Θ",
		"b.Upsi": "Υ",
		"b.Xi": "Ξ",
		"b.alpha": "α",
		"b.beta": "β",
		"b.chi": "χ",
		"b.delta": "δ",
		"b.epsi": "ε",
		"b.epsis": "ε",
		"b.epsiv": "ε",
		"b.eta": "η",
		"b.gamma": "γ",
		"b.gammad": "Ϝ",
		"b.iota": "ι",
		"b.kappa": "κ",
		"b.kappav": "ϰ",
		"b.lambda": "λ",
		"b.mu": "μ",
		"b.nu": "ν",
		"b.omega": "ώ",
		"b.phis": "φ",
		"b.phiv": "ϕ",
		"b.pi": "π",
		"b.piv": "ϖ",
		"b.psi": "ψ",
		"b.rho": "ρ",
		"b.rhov": "ϱ",
		"b.sigma": "σ",
		"b.sigmav": "ς",
		"b.tau": "τ",
		"b.thetas": "θ",
		"b.thetav": "ϑ",
		"b.upsi": "υ",
		"b.xi": "ξ",
		"b.zeta": "ζ",
		"barwed": "⊼",
		"bcong": "≌",
		"bcy": "б",
		"bdquo": "„",
		"becaus": "∵",
		"bepsi": "∍",
		"bernou": "ℬ",
		"beta": "β",
		"beth": "ℶ",
		"bgr": "β",
		"blackstar": "✦",
		"blank": "␣",
		"blk12": "▒",
		"blk14": "░",
		"blk34": "▓",
		"block": "█",
		"bottom": "⊥",
		"bowtie": "⋈",
		"boxDL": "╗",
		"boxDR": "╔",
		"boxDl": "╖",
		"boxDr": "╓",
		"boxH": "═",
		"boxHD": "╦",
		"boxHU": "╩",
		"boxHd": "╤",
		"boxHu": "╧",
		"boxUL": "╝",
		"boxUR": "╚",
		"boxUl": "╜",
		"boxUr": "╙",
		"boxV": "║",
		"boxVH": "╬",
		"boxVL": "╣",
		"boxVR": "╠",
		"boxVh": "╫",
		"boxVl": "╢",
		"boxVr": "╟",
		"boxdL": "╕",
		"boxdR": "╒",
		"boxdl": "┐",
		"boxdr": "┌",
		"boxh": "─",
		"boxhD": "╥",
		"boxhU": "╨",
		"boxhd": "┬",
		"boxhu": "┴",
		"boxuL": "╛",
		"boxuR": "╘",
		"boxul": "┘",
		"boxur": "└",
		"boxv": "│",
		"boxvH": "╪",
		"boxvL": "╡",
		"boxvR": "╞",
		"boxvh": "┼",
		"boxvl": "┤",
		"boxvr": "├",
		"bprime": "‵",
		"breve": "˘",
		"brvbar": "¦",
		"bsim": "∽",
		"bsime": "⋍",
		"bsol": "\\",
		"bull": "•",
		"bump": "≎",
		"bumpe": "≏",
		"cacute": "ć",
		"cap": "∩",
		"caret": "⁁",
		"caron": "ˇ",
		"ccaron": "č",
		"ccedil": "ç",
		"ccirc": "ĉ",
		"cdot": "ċ",
		"cedil": "¸",
		"cent": "¢",
		"chcy": "ч",
		"check": "✓",
		"chi": "χ",
		"cir": "○",
		"circ": "ˆ",
		"cire": "≗",
		"clubs": "♣",
		"colon": ":",
		"colone": "≔",
		"comma": ",",
		"commat": "@",
		"comp": "∁",
		"compfn": "∘",
		"cong": "≅",
		"conint": "∮",
		"coprod": "∐",
		"copy": "©",
		"copysr": "℗",
		"crarr": "↵",
		"cross": "✗",
		"cuepr": "⋞",
		"cuesc": "⋟",
		"cularr": "↶",
		"cup": "∪",
		"cupre": "≼",
		"curarr": "↷",
		"curren": "¤",
		"cuvee": "⋎",
		"cuwed": "⋏",
		"dArr": "⇓",
		"dagger": "†",
		"daleth": "ℸ",
		"darr": "↓",
		"darr2": "⇊",
		"dash": "‐",
		"dashv": "⊣",
		"dblac": "˝",
		"dcaron": "ď",
		"dcy": "д",
		"deg": "°",
		"delta": "δ",
		"dgr": "δ",
		"dharl": "⇃",
		"dharr": "⇂",
		"diam": "⋄",
		"diams": "♦",
		"die": "¨",
		"divide": "÷",
		"divonx": "⋇",
		"djcy": "ђ",
		"dlarr": "↙",
		"dlcorn": "⌞",
		"dlcrop": "⌍",
		"dollar": "$",
		"dot": "˙",
		"drarr": "↘",
		"drcorn": "⌟",
		"drcrop": "⌌",
		"dscy": "ѕ",
		"dstrok": "đ",
		"dtri": "▿",
		"dtrif": "▾",
		"dzcy": "џ",
		"eDot": "≑",
		"eacgr": "έ",
		"eacute": "é",
		"ecaron": "ě",
		"ecir": "≖",
		"ecirc": "ê",
		"ecolon": "≕",
		"ecy": "э",
		"edot": "ė",
		"eeacgr": "ή",
		"eegr": "η",
		"efDot": "≒",
		"egr": "ε",
		"egrave": "è",
		"egs": "⋝",
		"ell": "ℓ",
		"els": "⋜",
		"emacr": "ē",
		"empty": "∅",
		"emsp": " ",
		"emsp13": " ",
		"emsp14": " ",
		"eng": "ŋ",
		"ensp": " ",
		"eogon": "ę",
		"epsi": "ε",
		"epsilon": "ε",
		"epsis": "∊",
		"epsiv": "ο",
		"equals": "=",
		"equiv": "≡",
		"erDot": "≓",
		"esdot": "≐",
		"eta": "η",
		"eth": "ð",
		"euml": "ë",
		"euro": "€",
		"excl": "!",
		"exist": "∃",
		"fcy": "ф",
		"female": "♀",
		"ffilig": "ﬃ",
		"fflig": "ﬀ",
		"ffllig": "ﬄ",
		"filig": "ﬁ",
		"flat": "♭",
		"fllig": "ﬂ",
		"fnof": "ƒ",
		"forall": "∀",
		"fork": "⋔",
		"frac12": "½",
		"frac13": "⅓",
		"frac14": "¼",
		"frac15": "⅕",
		"frac16": "⅙",
		"frac18": "⅛",
		"frac23": "⅔",
		"frac25": "⅖",
		"frac34": "¾",
		"frac35": "⅗",
		"frac38": "⅜",
		"frac45": "⅘",
		"frac56": "⅚",
		"frac58": "⅝",
		"frac78": "⅞",
		"frasl": "⁄",
		"frown": "⌢",
		"gE": "≧",
		"gEl": "⪌",
		"gacute": "ǵ",
		"gamma": "γ",
		"gammad": "Ϝ",
		"gap": "⪆",
		"gbreve": "ğ",
		"gcedil": "ģ",
		"gcirc": "ĝ",
		"gcy": "г",
		"gdot": "ġ",
		"ge": "≥",
		"gel": "⋛",
		"ges": "≥",
		"ggr": "γ",
		"gimel": "ℷ",
		"gjcy": "ѓ",
		"gl": "≷",
		"gnE": "≩",
		"gnap": "⪊",
		"gne": "≩",
		"gnsim": "⋧",
		"grave": "`",
		"gsdot": "⋗",
		"gsim": "≳",
		"gt": ">",
		"gvnE": "≩",
		"hArr": "⇔",
		"hairsp": " ",
		"half": "½",
		"hamilt": "ℋ",
		"hardcy": "ъ",
		"harr": "↔",
		"harrw": "↭",
		"hcirc": "ĥ",
		"hearts": "♥",
		"hellip": "…",
		"horbar": "―",
		"hstrok": "ħ",
		"hybull": "⁃",
		"hyphen": "-",
		"iacgr": "ί",
		"iacute": "í",
		"icirc": "î",
		"icy": "и",
		"idiagr": "ΐ",
		"idigr": "ϊ",
		"iecy": "е",
		"iexcl": "¡",
		"iff": "⇔",
		"igr": "ι",
		"igrave": "ì",
		"ijlig": "ĳ",
		"imacr": "ī",
		"image": "ℑ",
		"incare": "℅",
		"infin": "∞",
		"inodot": "ı",
		"int": "∫",
		"intcal": "⊺",
		"iocy": "ё",
		"iogon": "į",
		"iota": "ι",
		"iquest": "¿",
		"isin": "∈",
		"itilde": "ĩ",
		"iukcy": "і",
		"iuml": "ï",
		"jcirc": "ĵ",
		"jcy": "й",
		"jsercy": "ј",
		"jukcy": "є",
		"kappa": "κ",
		"kappav": "ϰ",
		"kcedil": "ķ",
		"kcy": "к",
		"kgr": "κ",
		"kgreen": "ĸ",
		"khcy": "х",
		"khgr": "χ",
		"kjcy": "ќ",
		"lAarr": "⇚",
		"lArr": "⇐",
		"lE": "≦",
		"lEg": "⪋",
		"lacute": "ĺ",
		"lagran": "ℒ",
		"lambda": "λ",
		"lang": "〈",
		"lap": "⪅",
		"laquo": "«",
		"larr": "←",
		"larr2": "⇇",
		"larrhk": "↩",
		"larrlp": "↫",
		"larrtl": "↢",
		"lcaron": "ľ",
		"lcedil": "ļ",
		"lceil": "⌈",
		"lcub": "{",
		"lcy": "л",
		"ldot": "⋖",
		"ldquo": "“",
		"ldquor": "„",
		"le": "≤",
		"leg": "⋚",
		"les": "≤",
		"lfloor": "⌊",
		"lg": "≶",
		"lgr": "λ",
		"lhard": "↽",
		"lharu": "↼",
		"lhblk": "▄",
		"ljcy": "љ",
		"lmidot": "ŀ",
		"lnE": "≨",
		"lnap": "⪉",
		"lne": "≨",
		"lnsim": "⋦",
		"lowast": "∗",
		"lowbar": "_",
		"loz": "◊",
		"lozf": "✦",
		"lpar": "(",
		"lrarr2": "⇆",
		"lrhar2": "⇋",
		"lrm": "‎",
		"lsaquo": "‹",
		"lsh": "↰",
		"lsim": "≲",
		"lsqb": "[",
		"lsquo": "‘",
		"lsquor": "‚",
		"lstrok": "ł",
		"lt": "<",
		"lthree": "⋋",
		"ltimes": "⋉",
		"ltri": "◃",
		"ltrie": "⊴",
		"ltrif": "◂",
		"lvnE": "≨",
		"macr": "¯",
		"male": "♂",
		"malt": "✠",
		"map": "↦",
		"marker": "▮",
		"mcy": "м",
		"mdash": "—",
		"mgr": "μ",
		"micro": "µ",
		"mid": "∣",
		"middot": "·",
		"minus": "−",
		"minusb": "⊟",
		"mldr": "…",
		"mnplus": "∓",
		"models": "⊧",
		"mu": "μ",
		"mumap": "⊸",
		"nVDash": "⊯",
		"nVdash": "⊮",
		"nabla": "∇",
		"nacute": "ń",
		"nap": "≉",
		"napos": "ŉ",
		"natur": "♮",
		"nbsp": " ",
		"ncaron": "ň",
		"ncedil": "ņ",
		"ncong": "≇",
		"ncy": "н",
		"ndash": "–",
		"ne": "≠",
		"nearr": "↗",
		"nequiv": "≢",
		"nexist": "∄",
		"nge": "≱",
		"nges": "≱",
		"ngr": "ν",
		"ngt": "≯",
		"nhArr": "⇎",
		"nharr": "↮",
		"ni": "∋",
		"njcy": "њ",
		"nlArr": "⇍",
		"nlarr": "↚",
		"nldr": "‥",
		"nle": "≰",
		"nles": "≰",
		"nlt": "≮",
		"nltri": "⋪",
		"nltrie": "⋬",
		"nmid": "∤",
		"not": "¬",
		"notin": "∉",
		"npar": "∦",
		"npr": "⊀",
		"npre": "⋠",
		"nrArr": "⇏",
		"nrarr": "↛",
		"nrtri": "⋫",
		"nrtrie": "⋭",
		"nsc": "⊁",
		"nsce": "⋡",
		"nsim": "≁",
		"nsime": "≄",
		"nsmid": "∤",
		"nspar": "∦",
		"nsub": "⊄",
		"nsubE": "⊈",
		"nsube": "⊈",
		"nsup": "⊅",
		"nsupE": "⊉",
		"nsupe": "⊉",
		"ntilde": "ñ",
		"nu": "ν",
		"num": "#",
		"numero": "№",
		"numsp": " ",
		"nvDash": "⊭",
		"nvdash": "⊬",
		"oS": "Ⓢ",
		"oacgr": "ό",
		"oacute": "ó",
		"oast": "⊛",
		"ocir": "⊚",
		"ocirc": "ô",
		"ocy": "о",
		"odash": "⊝",
		"odblac": "ő",
		"odot": "⊙",
		"oelig": "œ",
		"ogon": "˛",
		"ogr": "ο",
		"ograve": "ò",
		"ohacgr": "ώ",
		"ohgr": "ω",
		"ohm": "Ω",
		"olarr": "↺",
		"oline": "‾",
		"omacr": "ō",
		"omega": "ω",
		"omicron": "ο",
		"ominus": "⊖",
		"oplus": "⊕",
		"or": "∨",
		"orarr": "↻",
		"order": "ℴ",
		"ordf": "ª",
		"ordm": "º",
		"oslash": "ø",
		"osol": "⊘",
		"otilde": "õ",
		"otimes": "⊗",
		"ouml": "ö",
		"par": "∥",
		"para": "¶",
		"part": "∂",
		"pcy": "п",
		"percnt": "%",
		"period": ".",
		"permil": "‰",
		"perp": "⊥",
		"pgr": "π",
		"phgr": "φ",
		"phi": "φ",
		"phis": "φ",
		"phiv": "ϕ",
		"phmmat": "ℳ",
		"phone": "☎",
		"pi": "π",
		"piv": "ϖ",
		"planck": "ℏ",
		"plus": "+",
		"plusb": "⊞",
		"plusdo": "∔",
		"plusmn": "±",
		"pound": "£",
		"pr": "≺",
		"prap": "⪷",
		"pre": "≼",
		"prime": "′",
		"prnE": "⪵",
		"prnap": "⪹",
		"prnsim": "⋨",
		"prod": "∏",
		"prop": "∝",
		"prsim": "≾",
		"psgr": "ψ",
		"psi": "ψ",
		"puncsp": " ",
		"quest": "?",
		"quot": "\"",
		"rAarr": "⇛",
		"rArr": "⇒",
		"racute": "ŕ",
		"radic": "√",
		"rang": "〉",
		"raquo": "»",
		"rarr": "→",
		"rarr2": "⇉",
		"rarrhk": "↪",
		"rarrlp": "↬",
		"rarrtl": "↣",
		"rarrw": "↝",
		"rcaron": "ř",
		"rcedil": "ŗ",
		"rceil": "⌉",
		"rcub": "}",
		"rcy": "р",
		"rdquo": "”",
		"rdquor": "“",
		"real": "ℜ",
		"rect": "▭",
		"reg": "®",
		"rfloor": "⌋",
		"rgr": "ρ",
		"rhard": "⇁",
		"rharu": "⇀",
		"rho": "ρ",
		"rhov": "ϱ",
		"ring": "˚",
		"rlarr2": "⇄",
		"rlhar2": "⇌",
		"rlm": "‏",
		"rpar": ")",
		"rpargt": "⦔",
		"rsaquo": "›",
		"rsh": "↱",
		"rsqb": "]",
		"rsquo": "’",
		"rsquor": "‘",
		"rthree": "⋌",
		"rtimes": "⋊",
		"rtri": "▹",
		"rtrie": "⊵",
		"rtrif": "▸",
		"rx": "℞",
		"sacute": "ś",
		"samalg": "∐",
		"sbquo": "‚",
		"sbsol": "\\",
		"sc": "≻",
		"scap": "⪸",
		"scaron": "š",
		"sccue": "≽",
		"sce": "≽",
		"scedil": "ş",
		"scirc": "ŝ",
		"scnE": "⪶",
		"scnap": "⪺",
		"scnsim": "⋩",
		"scsim": "≿",
		"scy": "с",
		"sdot": "⋅",
		"sdotb": "⊡",
		"sect": "§",
		"semi": ";",
		"setmn": "∖",
		"sext": "✶",
		"sfgr": "ς",
		"sfrown": "⌢",
		"sgr": "σ",
		"sharp": "♯",
		"shchcy": "щ",
		"shcy": "ш",
		"shy": "­",
		"sigma": "σ",
		"sigmaf": "ς",
		"sigmav": "ς",
		"sim": "∼",
		"sime": "≃",
		"smid": "∣",
		"smile": "⌣",
		"softcy": "ь",
		"sol": "/",
		"spades": "♠",
		"spar": "∥",
		"sqcap": "⊓",
		"sqcup": "⊔",
		"sqsub": "⊏",
		"sqsube": "⊑",
		"sqsup": "⊐",
		"sqsupe": "⊒",
		"squ": "□",
		"square": "□",
		"squf": "▪",
		"ssetmn": "∖",
		"ssmile": "⌣",
		"sstarf": "⋆",
		"star": "☆",
		"starf": "★",
		"sub": "⊂",
		"subE": "⊆",
		"sube": "⊆",
		"subnE": "⊊",
		"subne": "⊊",
		"sum": "∑",
		"sung": "♪",
		"sup": "⊃",
		"sup1": "¹",
		"sup2": "²",
		"sup3": "³",
		"supE": "⊇",
		"supe": "⊇",
		"supnE": "⊋",
		"supne": "⊋",
		"szlig": "ß",
		"target": "⌖",
		"tau": "τ",
		"tcaron": "ť",
		"tcedil": "ţ",
		"tcy": "т",
		"tdot": "⃛",
		"telrec": "⌕",
		"tgr": "τ",
		"there4": "∴",
		"theta": "θ",
		"thetas": "θ",
		"thetasym": "ϑ",
		"thetav": "ϑ",
		"thgr": "θ",
		"thinsp": " ",
		"thkap": "≈",
		"thksim": "∼",
		"thorn": "þ",
		"tilde": "˜",
		"times": "×",
		"timesb": "⊠",
		"top": "⊤",
		"tprime": "‴",
		"trade": "™",
		"trie": "≜",
		"tscy": "ц",
		"tshcy": "ћ",
		"tstrok": "ŧ",
		"twixt": "≬",
		"uArr": "⇑",
		"uacgr": "ύ",
		"uacute": "ú",
		"uarr": "↑",
		"uarr2": "⇈",
		"ubrcy": "ў",
		"ubreve": "ŭ",
		"ucirc": "û",
		"ucy": "у",
		"udblac": "ű",
		"udiagr": "ΰ",
		"udigr": "ϋ",
		"ugr": "υ",
		"ugrave": "ù",
		"uharl": "↿",
		"uharr": "↾",
		"uhblk": "▀",
		"ulcorn": "⌜",
		"ulcrop": "⌏",
		"umacr": "ū",
		"uml": "¨",
		"uogon": "ų",
		"uplus": "⊎",
		"upsi": "υ",
		"upsih": "ϒ",
		"upsilon": "υ",
		"urcorn": "⌝",
		"urcrop": "⌎",
		"uring": "ů",
		"utilde": "ũ",
		"utri": "▵",
		"utrif": "▴",
		"uuml": "ü",
		"vArr": "⇕",
		"vDash": "⊨",
		"varr": "↕",
		"vcy": "в",
		"vdash": "⊢",
		"veebar": "⊻",
		"vellip": "⋮",
		"verbar": "|",
		"vltri": "⊲",
		"vprime": "′",
		"vprop": "∝",
		"vrtri": "⊳",
		"vsubnE": "⊊",
		"vsubne": "⊊",
		"vsupnE": "⊋",
		"vsupne": "⊋",
		"wcirc": "ŵ",
		"wedgeq": "≙",
		"weierp": "℘",
		"whitestar": "✧",
		"wreath": "≀",
		"xcirc": "○",
		"xdtri": "▽",
		"xgr": "ξ",
		"xhArr": "↔",
		"xharr": "↔",
		"xi": "ξ",
		"xlArr": "⇐",
		"xrArr": "⇒",
		"xutri": "△",
		"yacute": "ý",
		"yacy": "я",
		"ycirc": "ŷ",
		"ycy": "ы",
		"yen": "¥",
		"yicy": "ї",
		"yucy": "ю",
		"yuml": "ÿ",
		"zacute": "ź",
		"zcaron": "ž",
		"zcy": "з",
		"zdot": "ż",
		"zeta": "ζ",
		"zgr": "ζ",
		"zhcy": "ж",
		"zwj": "‍",
		"zwnj": "‌"};


/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/string.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.String=
    (function(){
        "use strict";
        function fdjtString(string){
            if ((typeof string !== 'string')&&
                (!(string instanceof String)))
                return stringify(string);
            var output="", arg;
            var cmd=string.indexOf('%'); var i=1;
            while (cmd>=0) {
                if (cmd>0) output=output+string.slice(0,cmd);
                if (string[cmd+1]==='%') output=output+'%';
                else if (string[cmd+1]==='o') {
                    arg=arguments[i++];
                    if (typeof arg === 'string')
                        output=output+"'"+arg+"'";
                    else if (typeof arg === 'number')
                        output=output+arg;
                    else if (Array.isArray(arg)) {
                        var j=0, len=arg.length;
                        output=output+"[";
                        while (j<len) {
                            output=output+((j>0)?(","):(""))+
                                stringify(arg[j++]);}
                        output=output+"]";}
                    else output=output+stringify(arg);}
                else if (string[cmd+1]==='j') {
                    arg=arguments[i++];
                    if (Array.isArray(arg)) {
                        var k=0, lim=arg.length;
                        output=output+"[";
                        while (k<lim) {
                            output=output+((k>0)?(","):(""))+JSON.stringify(arg[k++]);}}
                    else if (typeof arg === "object") {
                        var objstr=false;
                        try {objstr=JSON.stringify(arg);}
                        catch (ex1) {
                            var norm={}; for (var p in arg) {
                                if (arg.hasOwnProperty(p)) {
                                    var pv=arg[p], nv;
                                    if (Array.isArray(pv)) {
                                        nv=[]; var ei=0, elim=pv.length;
                                        while (ei<elim) {
                                            var e=pv[ei++], sv;
                                            try {sv=fdjtString(e);}
                                            catch (ex2) {sv=e.toString();}
                                            nv.push(sv);}}
                                    else {
                                        try {nv=fdjtString(pv);}
                                        catch (ex) {nv=pv.toString();}}
                                    norm[p]=nv;}}
                            objstr=JSON.stringify(norm);}
                        output=output+objstr;}
                    else output=output+JSON.stringify(arg);}
                else if ((string[cmd+1]==='x')&&
                         (typeof arguments[i] === 'number')&&
                         (arguments[i]>=0)&&
                         ((arguments[i]%1)>=0)) {
                    arg=arguments[i++];
                    output=output+arg.toString(16);}
                else if (arguments[i])
                    output=output+arguments[i++];
                else if (typeof arguments[i] === 'undefined') {
                    output=output+'?undef?'; i++;}
                else output=output+arguments[i++];
                string=string.slice(cmd+2);
                cmd=string.indexOf('%');}
            output=output+string;
            return output;}

        var notspace=/[^ \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff]/g;

        fdjtString.nbsp="\u00A0";
        fdjtString.middot="\u00B7";
        fdjtString.emdash="\u2013";
        fdjtString.endash="\u2014";
        fdjtString.lsq="\u2018";
        fdjtString.rsq="\u2019";
        fdjtString.ldq="\u201C";
        fdjtString.rdq="\u201D";

        function stringify(arg){
            if (typeof arg === 'undefined') return '?undef?';
            else if (!(arg)) return arg;
            else if (typeof arg === 'number') return ""+arg;
            else if (arg.tagName) {
                var output="["+arg.tagName;
                if (arg.className)
                    output=output+"."+arg.className.replace(/\s+/g,'.');
                if (arg.id) output=output+"#"+arg.id;
                if (arg.name) output=output+"[name="+arg.name+"]";
                var txt=((arg.innerText)?(arg.innerText.trim()):
                         (stripMarkup(arg.innerHTML).trim()));
                if ((!(txt))||(txt.length===0)) {}
                else if (txt.length<32)
                    output=output+'\''+txt.replace(/\n/g,'\\n')+'\'';
                else output=output+'\''+txt.slice(0,16).replace(/\n/g,'\\n')+'\'...';
                return output+"]";}
            else if (arg.nodeType) {
                if (arg.nodeType===3)
                    return '["'+arg.nodeValue+'"]';
                else return '<'+arg.nodeType+'>';}
            else if (arg.oid) return arg.oid;
            else if (arg._fdjtid) return '#@'+arg._fdjtid;
            else if ((arg.type)&&((arg.target)||(arg.srcElement))) {
                var target=arg.target||arg.srcElement;
                return "["+arg.type+"@"+stringify(target)+
                    ((((arg.target)||(arg.srcElement)).nodeType)?
                     (getDOMEventInfo(arg)):(""))+"]";}
            else return ""+arg;}

        function getDOMEventInfo(arg){
            var info="(m="+
                ((arg.shiftKey===true)?"s":"")+
                ((arg.ctrlKey===true)?"c":"")+
                ((arg.metaKey===true)?"m":"")+
                ((arg.altKey===true)?"a":"")+
                ((typeof arg.button !== "undefined")?
                 (",b="+(arg.button)):(""))+
                ((typeof arg.which !== "undefined")?
                 (",w="+(arg.which)):(""));
            var ox=arg.clientX, oy=arg.clientY;
            if ((typeof ox === "number")||(typeof oy === "number"))
                info=info+",cx="+ox+",cy="+oy;
            if (arg.touches)
                info=info+",touches="+arg.touches.length;
            if (arg.keyCode) info=info+",kc="+arg.keyCode;
            if (arg.charCode) info=info+",cc="+arg.charCode;
            return info+")";}

        var spacechars=" \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff";

        fdjtString.truncate=function(string,lim){
            if (!(lim)) lim=42;
            if (string.length<lim) return string;
            else return string.slice(0,lim);};

        var floor=Math.floor;

        function ellipsize(string,lim,fudge){
            var before, after;
            var chopped, broke;
            if (typeof fudge !== 'number') fudge=0.1;
            if (!(lim)) return string;
            else if (typeof lim === "number") {}
            else if (lim.constructor === Array) {
                before=lim[0]||0; after=lim[1]||0; lim=after+before;}
            else return string;
            if (!(lim)) return string;
            else if (string.length<(lim+floor(fudge*lim)))
                return string;
            else if ((before)&&(after)) {
                var len=string.length;
                var start, end; // of the elided text
                if (/\s/.test(string[before])===0) 
                    start=before;
                else {
                    chopped=string.slice(0,before);
                    broke=chopped.search(/\s+\w+$/);
                    if (broke>0) start=broke; else start=before;}
                if (/\s/.test(string[len-after])===0) end=len-after;
                else {
                    chopped=string.slice(len-after);
                    broke=chopped.search(/\s+/);
                    if (broke>0) end=(len-after)+broke;
                    else end=after;}
                return [string.slice(0,start),string.slice(end)];}
            else {
                var edge=string[lim];
                if (/\s/.test(edge)===0) 
                    return string.slice(0,lim);
                else {
                    chopped=string.slice(0,lim);
                    broke=chopped.search(/\s+\w+$/);
                    if (broke>0) return chopped.slice(0,broke);
                    else return chopped;}}}
        fdjtString.ellipsize=ellipsize;
                
        function isEmpty(string){
            if (typeof string === "string")  {
                var pt;
                if (string.length===0) return true;
                else pt=string.search(notspace);
                if (pt<0) return true;
                else if (string[pt]!=='&') return false;
                else {
                    string=string.replace(/&nbsp;/g,"\u00a0");
                    pt=string.search(notspace);
                    return (pt<0);}}
            else return false;}
        fdjtString.isEmpty=isEmpty;

        fdjtString.findSplit=function(string,split,escape){
            var start=0;
            var next;
            while ((next=string.indexOf(split,start))>=0) 
                if ((escape) && (next>0) && (string[next-1]===escape))
                    start=next+1;
            else return next;
            return -1;};

        fdjtString.split=function(string,split,escape,mapfn){
            if ((mapfn) || (escape)) {
                var results=[];
                var start=0; var next;
                while ((next=string.indexOf(split,start))>=0) 
                    if ((escape) && (next>0) && (string[next-1]===escape))
                        start=next+1;
                else if ((mapfn) && (next>start)) {
                    results.push(mapfn(string.slice(start,next))); start=next+1;}
                else if (next>start) {
                    results.push(string.slice(start,next)); start=next+1;}
                else start=next+1;
                if (string.length>start)
                    if (mapfn) results.push(mapfn(string.slice(start)));
                else results.push(string.slice(start));
                return results;}
            else return string.split(split);};

        fdjtString.semiSplit=function(string,escape,mapfn){
            if ((mapfn) || (escape)) {
                var results=[];
                var start=0; var next;
                while ((next=string.indexOf(';',start))>=0) 
                    if ((escape) && (next>0) && (string[next-1]===escape))
                        start=next+1;
                else if ((mapfn) && (next>start)) {
                    results.push(mapfn(string.slice(start,next))); start=next+1;}
                else if (next>start) {
                    results.push(string.slice(start,next)); start=next+1;}
                else start=next+1;
                if (string.length>start)
                    if (mapfn) results.push(mapfn(string.slice(start)));
                else results.push(string.slice(start));
                return results;}
            else return string.split(';');};

        fdjtString.lineSplit=function(string,escape,mapfn){
            if ((mapfn) || (escape)) {
                var results=[];
                var start=0; var next;
                while ((next=string.indexOf('\n',start))>=0) 
                    if ((escape) && (next>0) && (string[next-1]===escape))
                        start=next+1;
                else if ((mapfn) && (next>start)) {
                    results.push(mapfn(string.slice(start,next))); start=next+1;}
                else if (next>start) {
                    results.push(string.slice(start,next)); start=next+1;}
                else start=next+1;
                if (string.length>start)
                    if (mapfn) results.push(mapfn(string.slice(start)));
                else results.push(string.slice(start));
                return results;}
            else return string.split('\n');};

        function trim(string){
            var start=0; var len=string.length; 
            if (len<=0) return string;
            while ((start<len)&&
                   (spacechars.indexOf(string.charAt(start))>-1))
                start++;
            if (start===len) return "";
            var end=len-1;
            while ((end>start)&&(spacechars.indexOf(string.charAt(end))>-1))
                end--;
            if ((start>0)||(end<len)) return string.slice(start,end+1);
            else return string;}
        fdjtString.trim=trim;

        function stdspace(string){
            string=string.replace(/\s+/g," ");
            var start=0; var len=string.length; 
            if (len<=0) return string;
            while ((start<len)&&
                   (spacechars.indexOf(string.charAt(start))>-1))
                start++;
            if (start===len) return "";
            var end=len-1;
            while ((end>start)&&(spacechars.indexOf(string.charAt(end))>-1))
                end--;
            if ((start>0)||(end<len)) return string.slice(start,end+1);
            else return string;}
        fdjtString.stdspace=stdspace;

        function stdcap(string){
            var somecaps=
                string.search(/(^|\s)[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/g)>=0;
            if (!(somecaps))
                return string.replace(/\s+/g," ").replace(/(^ | $)/g,"");
            var words=string.split(/\s+/g);
            var i=0, lim=words.length; while (i<lim) {
                var word=words[i];
                var weird=word.slice(1).search(/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/)>=0;
                if (!(weird)) 
                    words[i]=word[0].toUpperCase()+word.slice(1);
                i++;}
            return words.join(" ");}
        fdjtString.stdcap=stdcap;

        function flatten(string){
            return string.replace(/\s+/g," ");}
        fdjtString.flatten=flatten;

        function oneline(string){
            string=trim(string);
            var flat=string.replace(/\s*[\f\n\r]+\s+/gm," //\u00B7 ").
                replace(/\s*[\f\n\r]+\s*/gm," // ");
            var tight=flat.replace(/\s\s+/g,"");
            return tight;}
        fdjtString.oneline=oneline;

        function stripMarkup(string){
            return string.replace(/<[^>]*>/g,"");}
        fdjtString.stripMarkup=stripMarkup;

        function unEscape(string){
            if (string.indexOf('\\')>=0)
                return string.replace(/\\(.)/g,"$1");
            else return string;}
        fdjtString.unEscape=unEscape;

        function normstring(string){
            return string.replace(/\W*\s\W*/g," ").toLowerCase();}
        fdjtString.normString=normstring;

        var entities={};
        fdjtString.entities=entities;
        function dCharCode(whole,paren){
            return String.fromCharCode(parseInt(paren,10));}
        function xCharCode(whole,paren){
            return String.fromCharCode(parseInt(paren,16));}
        function nCharCode(whole,paren){
            return fdjt.charnames[paren]||"&"+paren+";";}
        function expandEntity(whole,paren){
            if (entities.hasOwnProperty(paren))
                return entities[paren];
            else return "&"+paren+";";}
        function decodeEntities(string) {
            return string.replace(/&#(\d+);/g,dCharCode).
                replace(/&#x([0123456789ABCDEFabcdef]+);/g,xCharCode).
                replace(/&([abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.]+)/g,
                        nCharCode).
                replace(/&([A-Za-z][A-Za-z0-9-_.]+;)/g,
                        expandEntity);}
        fdjtString.decodeEntities=decodeEntities;
        function expandEntities(string) {
            return string.replace(/&([A-Za-z][A-Za-z0-9-_.]+);/g,
                                  expandEntity);}
        fdjtString.expandEntities=expandEntities;

        var numpat=/^\d+(\.\d+)$/;
        function getMatch(string,rx,i,literal){
            var match=rx.exec(string);
            if (typeof i === "undefined") i=0;
            if ((match)&&(match.length>i)) {
                if (literal) return match[i];
                else if (numpat.test(match[i]))
                    return parseFloat(match[i]);
                else return match[i];}
            else return false;}
        fdjtString.getMatch=getMatch;

        function segment(string,brk,start,keepspace) {
            if (start) string=string.slice(start);
            var brk_source=((typeof brk === "string")?(brk):(brk.source));
            var brk_flags=((typeof brk === "string")?(""):
                           ((brk.ignoreCase)?("i"):("")));
            var brkpat=new RegExp("("+brk_source+")",brk_flags);
            var results=[], segs=string.split(brkpat);
            var i=0, lim=segs.length, merged=false; while (i<lim) {
                var seg=segs[i++], sep=segs[i++];
                if ((!(seg))||(seg.search(/\S/)<0)) continue;
                if ((seg.length)&&(seg.slice(-1)==="\\")&&
                    ((seg.length<2)||(seg.slice(-2,-1)!=="\\"))) {
                    var unescaped=seg.slice(0,-1)+sep;
                    if (merged) merged=merged+unescaped;
                    else merged=unescaped;}
                else if (merged) {
                    if (keepspace)
                        results.push(merged+seg);
                    else results.push(stdspace(merged+seg));
                    merged=false;}
                else if (keepspace)
                    results.push(seg);
                else results.push(stdspace(seg));}
            return results;}
        fdjtString.segment=segment;
        
        function padNum(num,digits,prec){
            var ndigits=
                ((num<10)?(1):(num<100)?(2):(num<1000)?(3):(num<10000)?(4):
                 (num<100000)?(5):(num<1000000)?(6):(num<1000000)?(7):
                 (num<100000000)?(8):(num<1000000000)?(9):(num<10000000000)?(10):(11));
            if ((!(prec))&&(digits<0)) {prec=-digits; digits=0;}
            var nzeroes=digits-ndigits; var numstring=num.toString();
            var point=numstring.indexOf('.');
            var prefix=""; var suffix=""; var j;
            if (prec) {
                if ((point>=0)&&((point+prec)<numstring.length))
                    numstring=numstring.slice(0,point+prec+1);
                else if ((point<0)||(numstring.length<(point+prec+1))) {
                    j=0; var pad=(point+prec+1)-numstring.length;
                    if (point<0) suffix=suffix+".";
                    while (j<pad) {suffix=suffix+"0"; j++;}}}
            switch (nzeroes) {
            case 0: prefix=""; break;
            case 1: prefix="0"; break;
            case 2: prefix="00"; break;
            case 3: prefix="000"; break;
            case 4: prefix="0000"; break;
            case 5: prefix="00000"; break;
            case 6: prefix="000000"; break;
            case 7: prefix="0000000"; break;
            case 8: prefix="00000000"; break;
            case 9: prefix="000000000"; break;
            case 10: prefix="0000000000"; break;
            default: {
                j=0; while (j<nzeroes) {prefix=prefix+"0"; j++;}}}
            return prefix+numstring+suffix;}
        fdjtString.padNum=padNum;

        function precString(num,prec){
            var numstring=num.toString();
            var suffix="";
            if ((typeof prec === 'number')&&
                (prec>=0)&&(prec<100)) {
                var point=numstring.indexOf('.');
                if ((point>=0)&&((point+prec)<numstring.length))
                    numstring=numstring.slice(0,point+prec+1);
                else if ((point<0)||(numstring.length<(point+prec+1))) {
                    var j=0; var pad=(point+prec+1)-numstring.length;
                    if (point<0) suffix=".";
                    while (j<=pad) {suffix=suffix+"0"; j++;}}}
            return numstring+suffix;}
        fdjtString.precString=precString;

        /* Getting initials */

        function getInitials(string,n){
            var words=string.split(/\W/); var initials="";
            var i=0; var lim=((n)&&(n<words.length))?(n):(words.length);
            while (i<lim) {
                var word=words[i++];
                if (word.length)
                    initials=initials+word.slice(0,1);}
            return initials;}
        fdjtString.getInitials=getInitials;

        /* More string functions */

        function hasPrefix(string,prefix){
            return ((string.indexOf(prefix))===0);}
        fdjtString.hasPrefix=hasPrefix;

        function hasSuffix(string,suffix){
            return ((string.lastIndexOf(suffix))===(string.length-suffix.length));}
        fdjtString.hasSuffix=hasSuffix;

        function commonPrefix(string1,string2,brk,foldcase){
            var i=0; var last=-1;
            while ((i<string1.length) && (i<string2.length)) {
                if ((string1[i]===string2[i])||
                    ((foldcase)&&
                     (string1[i].toLowerCase()===string2[i].toLowerCase()))) {
                    if (brk) {
                        if (brk===string1[i]) {last=i-1; i++;}
                        else i++;}
                    else last=i++;}
                else break;}
            if (last>=0) return string1.slice(0,last+1);
            else return false;}
        fdjtString.commonPrefix=commonPrefix;

        function commonSuffix(string1,string2,brk,foldcase){
            var i=string1.length, j=string2.length; var last=0;
            while ((i>=0) && (j>=0)) {
                if ((string1[i]===string2[j])||
                    ((foldcase)&&
                     (string1[i].toLowerCase()===string2[i].toLowerCase()))) {
                    if (brk) {
                        if (brk===string1[i]) {last=i+1; i--; j--;}
                        else {i--; j--;}}
                    else {last=i; i--; j--;}}
                else break;}
            if (last>0) return string1.slice(last);
            else return false;}
        fdjtString.commonSuffix=commonSuffix;

        function stripSuffix(string){
            var start=string.search(/\.\w+$/);
            if (start>0) return string.slice(0,start);
            else return string;}
        fdjtString.stripSuffix=stripSuffix;

        function arrayContains(array,element){
            if (array.indexOf)
                return (array.indexOf(element)>=0);
            else {
                var i=0; var len=array.length;
                while (i<len)
                    if (array[i]===element) return true;
                else i++;
                return false;}}

        function add_prefix(ptree,string,i) {
            var strings=ptree.strings;
            if (i===string.length) 
                if ((strings.indexOf) ?
                    (strings.indexOf(string)>=0) :
                    (arrayContains(strings,string)))
                    return false;
            else {
                strings.push(string);
                return true;}
            else if (ptree.splits) {
                var splitchar=string[i];
                var split=ptree[splitchar];
                if (!(split)) {
                    // Create a new split
                    split={};
                    split.strings=[];
                    // We don't really use this, but it might be handy for debugging
                    split.splitchar=splitchar;
                    ptree[splitchar]=split;
                    ptree.splits.push(split);}
                if (add_prefix(split,string,i+1)) {
                    strings.push(string);
                    return true;}
                else return false;}
            else if (ptree.strings.length<5)
                if ((strings.indexOf) ?
                    (strings.indexOf(string)>=0) :
                    (arrayContains(strings,string)))
                    return false;
            else {
                strings.push(string);
                return true;}
            else {
                // Subdivide
                ptree.splits=[];
                var pstrings=ptree.strings;
                var j=0; while (j<pstrings.length)
                    add_prefix(ptree,pstrings[j++],i);
                return add_prefix(ptree,string,i);}}
        function prefixAdd(ptree,string,i) {
            if ((typeof i !== "number")||(i<0)) i=0;
            return add_prefix(ptree,string,i);}
        fdjtString.prefixAdd=prefixAdd;

        function find_prefix(ptree,prefix,i,plen){
            if (!(plen)) plen=prefix.length;
            if (i===plen)
                return ptree.strings;
            else if (ptree.strings.length<=5) {
                var strings=ptree.strings;
                var results=[];
                var j=0; while (j<strings.length) {
                    var string=strings[j++];
                    if (hasPrefix(string,prefix)) results.push(string);}
                if (results.length) return results;
                else return false;}
            else {
                var split=ptree[prefix[i]];
                if (split) return find_prefix(split,prefix,i+1,plen);
                else return false;}}
        function prefixFind(ptree,prefix,i,plen){
            if ((typeof i !== "number")||(i<0)) i=0;
            if (!(plen)) plen=prefix.length;
            return find_prefix(ptree,prefix,i,plen);}
        fdjtString.prefixFind=prefixFind;

        function paraHash(node){
            var text=((typeof node.innerText === "string")?
                      (node.innerText):(stripMarkup(node.innerHTML)));
            var words=text.split(/\W*\S+\W*/g);
            var len=words.length;
            return "_H"+
                ((len>0)?(words[0][0]):".")+
                ((len>1)?(words[1][0]):".")+
                ((len>2)?(words[2][0]):".")+
                ((len>3)?(words[3][0]):".")+
                ((len>0)?(words[len-1][0]):".")+
                ((len>1)?(words[len-2][0]):".")+
                ((len>2)?(words[len-3][0]):".")+
                ((len>3)?(words[len-4][0]):".");}
        fdjtString.paraHash=paraHash;

        function escapeRegExp(str) {
            return (str+"").replace(
                    /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&");}
        fdjtString.escapeRegExp=escapeRegExp;
        fdjtString.escapeRX=escapeRegExp;

        fdjtString.templates={};

        function fillIn(text,data){
            /* Filling in templates */
            var dom=false;
            if (typeof data === "string") {
                var tmp=data; data=text; text=tmp;}
            if ((!(text))&&(data)&&(data.template)) text=data.template;
            else if ((!(data))&&(text.template)) {
                data=text; text=data.template;}
            // Maybe a warning?
            if (typeof text === "string") {}
            else if (text.nodeType===3) {
                dom=text; text=dom.nodeValue;}
            else if (text.nodeType===1) {
                dom=text; text=dom.innerHTML;}
            else {
                fdjt.Log.warn("Bad argument %o to Template",text);
                return;}
            var substs=text.match(/\{\{\w+(\|([^\}])*)?\}\}/gm), done={};
            if ((substs)&&(substs.length)) {
                var i=0, n=substs.length; while (i<n) {
                    var match=substs[i++];
                    var prop=match.slice(2,-2);
                    var bar=prop.search(/\|/);
                    var propname=((bar>=0)?(prop.slice(0,bar)):(prop));
                    if ((done[prop])||(done[propname])) continue;
                    else if (data.hasOwnProperty(propname)) {
                        var val=data[propname];
                        done[propname]=prop;
                        if (val) {
                            var pat=new RegExp(
                                "\\{\\{"+propname+"(\\|[^\\}]*)?\\}\\}","gm");
                            var stringval=val.toString();
                            text=text.replace(pat,stringval);}}
                    else if (bar>0) {
                        var replace=prop.slice(bar+1);
                        text=text.replace("{{"+prop+"}}",replace);
                        done[prop]=prop;}
                    else fdjt.Log.warn(
                        "No data for %s in %j to substitute for %s",
                        propname,data,"{{"+prop+"}}");}}
            if (dom) {
                if (dom.nodeType===3) dom.nodeValue=text;
                else dom.innerHTML=text;
                return dom;}
            else return text;}
        fdjtString.fillIn=fillIn;
        
        return fdjtString;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/time.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
    of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use, modification, and redistribution of this program is permitted
    under either the GNU General Public License (GPL) Version 2 (or
    any later version) or under the GNU Lesser General Public License
    (version 3 or later).

    These licenses may be found at www.gnu.org, particularly:
      http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
      http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

/* Time functions */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.Time=
    (function (){
        "use strict";

        function _(x){ return x; }

        function fdjtTime() {
            return (new Date()).getTime();}

        var loaded=fdjtTime.loaded=(new Date()).getTime();
        fdjtTime.tick=function(){
            return Math.floor((new Date()).getTime()/1000);};

        fdjtTime.dateString=function(tstamp){
            if (typeof tstamp === 'number') {
                if (tstamp<131592918600)
                    tstamp=new Date(tstamp*1000);
                else tstamp=new Date(tstamp);}
            return tstamp.toDateString();};
        fdjtTime.timeString=function(tstamp){
            if (typeof tstamp === 'number') {
                if (tstamp<131592918600)
                    tstamp=new Date(tstamp*1000);
                else tstamp=new Date(tstamp);}
            return tstamp.toString();};

        function shortString(tstamp){
            var now=new Date();
            if (typeof tstamp === 'number') {
                if (tstamp<131592918600)
                    tstamp=new Date(tstamp*1000);
                else tstamp=new Date(tstamp);}
            var diff=(now.getTime()-tstamp.getTime())/1000;
            if (diff>(12*3600))
                return tstamp.toDateString();
            else {
                var hours=tstamp.getHours();
                var minutes=tstamp.getMinutes();
                return tstamp.toDateString()+" ("+
                    ((hours<10)?"0":"")+hours+":"+
                    ((minutes===0)?"00":(((minutes<10)?"0":"")+minutes))+
                    ")";}}
        fdjtTime.shortString=shortString;
        fdjtTime.tick2shortstring=function(tick){
            return shortString(new Date(tick*1000));};

        var first_date=false;
        function compactString(tstamp,curdate){
            if (typeof tstamp === 'number') {
                if (tstamp<131592918600)
                    tstamp=new Date(tstamp*1000);
                else tstamp=new Date(tstamp);}
            var date_string=tstamp.toLocaleDateString();
            if (typeof curdate==="undefined") {
                if (first_date) curdate=first_date;
                else first_date=new Date().toLocaleDateString();}
            var show_date=(date_string!==curdate);
            var hours=tstamp.getHours(), minutes=tstamp.getMinutes();
            var seconds=tstamp.getSeconds();
            return ((show_date)?(date_string):(""))+
                ((show_date)?(" - "):(""))+
                ((hours<10)?"0":"")+hours+":"+
                ((minutes===0)?"00":(((minutes<10)?"0":"")+minutes))+":"+
                ((seconds===0)?"00":(((seconds<10)?"0":"")+seconds));}
        fdjtTime.compactString=compactString;
        
        fdjtTime.tick2string=function(tick){
            return (new Date(tick*1000)).toString();};
        fdjtTime.tick2date=function(tick){
            return (new Date(tick*1000)).toDateString();};
        fdjtTime.tick2locale=function(tick){
            return (new Date(tick*1000)).toLocaleString();};
        fdjtTime.tick2time=function(tick){
            return (new Date(tick*1000)).toTimeString();};

        var fmt=fdjt.String;

        fdjtTime.secs2string=function(interval){
            var weeks, days, hours, minutes, seconds;
            if (interval<1)
                return fmt("%f seconds",interval);
            else if (interval===1)
                return fmt("%f second",interval);
            else if (interval<10)
                return fmt("%f seconds",interval);
            else if (interval<60)
                return fmt("~%d seconds",Math.round(interval/60));
            else if (interval<120) {
                minutes=Math.floor(interval/60);
                seconds=Math.round(interval-(minutes*60));
                if (seconds===1)
                    return _("one minute, one second");
                else return fmt("one minute, %d seconds",seconds);}
            else if (interval<3600) {
                minutes=Math.floor(interval/60);
                return fmt("~%d minutes",minutes);}
            else if (interval<(2*3600)) {
                hours=Math.floor(interval/3600);
                minutes=Math.round((interval-(hours*3600))/60);
                if (minutes===1)
                    return _("one hour and one minutes");
                else return fmt("one hour, %d minutes",minutes);}
            else if (interval<(24*3600)) {
                hours=Math.floor(interval/3600);
                return fmt("~%d hours",hours);}
            else if (interval<(2*24*3600)) {
                hours=Math.floor((interval-24*3600)/3600);
                if (hours===1)
                    return _("one day and one hour");
                else return fmt("one day, %d hours",hours);}
            else if (interval<(7*24*3600)) {
                days=Math.floor(interval/(24*3600));
                return fmt("%d days",days);}
            else if (interval<(14*24*3600)) {
                days=Math.floor((interval-(7*24*3600))/(24*3600));
                if (days===1)
                    return "one week and one day";
                else return fmt("one week and %d days",days);}
            else {
                weeks=Math.floor(interval/(7*24*3600));
                days=Math.round((interval-(days*7*24*3600))/(7*24*3600));
                return fmt("%d weeks, %d days",weeks,days);}};

        fdjtTime.secs2short=function(interval){
            // This is designed for short intervals
            if (interval<0.001)
                return Math.round(interval*1000000)+"us";
            else if (interval<0.1)
                return Math.round(interval*1000)+"ms";
            else if (interval<120)
                return (Math.round(interval*100)/100)+"s";
            else {
                var min=Math.floor(interval/60);
                var secs=interval-min*60;
                return min+"m, "+(Math.round(secs*100)/100)+"s";}};

        fdjtTime.runTimes=function(pname,start){
            var point=start; var report="";
            var i=2; while (i<arguments.length) {
                var phase=arguments[i++]; var time=arguments[i++];
                report=report+"; "+phase+": "+
                    ((time.getTime()-point.getTime())/1000)+"s";
                point=time;}
            return pname+" "+
                ((point.getTime()-start.getTime())/1000)+"s"+
                report;};

        fdjtTime.diffTime=function(time1,time2){
            if (!(time2)) time2=new Date();
            var diff=time1.getTime()-time2.getTime();
            if (diff>0) return diff/1000; else return -(diff/1000);};

        fdjtTime.ET=function(arg){
            if (!(arg)) arg=new Date();
            return (arg.getTime()-loaded)/1000;};

        var tzpat=/(EST|EDT|PDT|PST|CST|CDT|ECT|GMT|Z|([+-]\d\d?(:\d+)?))$/i;

        fdjtTime.parse=function(string){
            var value=false;
            try {
                if (Date.parse)
                    value=new Date(Date.parse(string));
                else value=new Date(string);
            } catch (ex) {
                fdjt.Log("Error parsing time '%s': %o",string,ex);}
            if ((value instanceof Date)&&(!(isNaN(value.getYear()))))
                return value;
            else {
                var strip=string.search(tzpat);
                if (strip>0) return fdjtTime.parse(string.slice(0,strip));
                fdjt.Log("Couldn't parse time '%s'",string);
                return string;}};
        
        fdjtTime.timeslice=fdjt.Async.timeslice;
        fdjtTime.slowmap=fdjt.Async.slowmap;

        return fdjtTime;})();

fdjt.ET=fdjt.Time.ET;

/* Emacs local variables
;;;  Local variables: ***
;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
;;;  indent-tabs-mode: nil ***
;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/string.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */
// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.Template=(function(){
    "use strict";
    var templates={};

    function Template(text,data,xdata){ /* Filling in templates */
        var dom=false;
        if (typeof data === "string") {
            var tmp=data; data=text; text=tmp;}
        if ((!(text))&&(data)&&(data.template)) text=data.template;
        // Maybe a warning?
        if (typeof text === "string") {}
        else if (text.nodeType===3) {
            dom=text; text=dom.nodeValue;}
        else if (text.nodeType===1) {
            dom=text; text=dom.innerHTML;}
        else {
            fdjt.Log.warn("Bad argument %o to Template",text);
            return;}
        if (Template.localTemplates.hasOwnProperty(text))
            text=Template.localTemplates[text];
        else if (templates.hasOwnProperty(text))
            text=templates[text];
        else {}
        var substs=text.match(/\{\{\w+\}\}/gm), done={};
        if (substs) {
            var i=0, n=substs.length; while (i<n) {
                var match=substs[i++];
                var prop=match.slice(2,-2);
                var pat=new RegExp("\\{\\{"+prop+"\\}\\}","gm");
                if (done[prop]) continue;
                if (!((data.hasOwnProperty(prop))||
                      ((xdata)&&(xdata.hasOwnProperty(prop))))) {
                    fdjt.Log.warn("No data for %s in %s to use in %s",
                                  prop,data,text);
                    done[prop]=prop;
                    continue;}
                var val=data[prop]||((xdata)&&(xdata[prop]))||"";
                done[prop]=prop;
                text=text.replace(pat,val.toString());}}
        if (dom) {
            if (dom.nodeType===3) dom.nodeValue=text;
            else dom.innerHTML=text;
            return dom;}
        else return text;}

    var template=Template;

    fdjt.Templates=templates;
    Template.localTemplates={};

    function toDOM(text,data,dom_arg){
        var output=template(text,data);
        var dom=((!(dom_arg))?(document.createElement("div")):
                 (dom_arg.nodeType)?(dom_arg):
                 (typeof dom_arg === "string")?
                 (document.createElement(dom_arg)):
                 (document.createElement("div")));
        dom.innerHTML=output;
        if ((dom_arg)&&(dom_arg.nodeType)) return dom;
        else if (!(dom.childNodes)) return false;
        else if (dom.childNodes.length===1)
            return dom.childNodes[0];
        else {
            var frag=document.createDocumentFragment, nodes=[];
            var children=dom.childNodes;
            var i=0, lim=children.length;
            while (i<lim) nodes.push(children[i++]);
            i=0; while (i<lim) frag.appendChild(nodes[i++]);
            return frag;}}

    Template.toDOM=toDOM;

    return Template;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ######################### fdjt/hash.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   It implements a method for breaking narrative HTML content
   across multiple pages, attempting to honor page break constraints,
   etc.

   Check out the 'mini manual' at the bottom of the file or read the
   code itself.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or any
   later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

   Use and redistribution (especially embedding in other CC licensed
   content) is also permitted under the terms of the Creative Commons
   "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

/*
 * A JavaScript implementation of various hashing algorithms, merged
 *   into a single object.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

if (!(fdjt.Hash))
    fdjt.Hash=(function(){
        "use strict";
        /*
         * Configurable variables. You may need to tweak these to be compatible with
         * the server-side, but the defaults work in most cases.
         */
        /* hex output format. 0 - lowercase; 1 - uppercase        */
        var hexcase_default = 0;
        /* base-64 pad character. "=" for strict RFC compliance   */
        var b64pad_default  = "";
        var enc=false;

        function gethexcase(){ return hexcase_default;}
        function sethexcase(v){ hexcase_default=v;}
        function getpadchar(){ return b64pad_default;}
        function setpadchar(v){ b64pad_default=v;}

        function getenc(){ return ;}
        function setenc(v) {
            if (typeof v === 'string')
                enc=fdjt.Hash[v]||false;
            else enc=v;}

        /*
         * Convert a raw string to an array of big-endian words
         * Characters >255 have their high-byte silently ignored.
         */
        function rstr2binb(input)
        {
            var output = new Array(input.length >> 2); var i;
            for(i = 0; i < output.length; i++)
                output[i] = 0;
            for(i = 0; i < input.length * 8; i += 8)
                output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
            return output;
        }

        /*
         * Convert an array of big-endian words to a string
         */
        function binb2rstr(input)
        {
            var output = "";
            for(var i = 0; i < input.length * 32; i += 8)
                output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);
            return output;
        }

        /*
         * Convert a raw string to a hex string
         */
        function rstr2hex(input,hexcase)
        {
            if (typeof hexcase === "undefined") hexcase=hexcase_default;
            var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
            var output = "";
            var x;
            for(var i = 0; i < input.length; i++)
            {
                x = input.charCodeAt(i);
                output += hex_tab.charAt((x >>> 4) & 0x0F)+
                    hex_tab.charAt( x        & 0x0F);
            }
            return output;
        }

        /*
         * Convert a raw string to a base-64 string
         */
        function rstr2b64(input,b64pad)
        {
            if (!(b64pad)) b64pad=b64pad_default;
            var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var output = "";
            var len = input.length;
            for(var i = 0; i < len; i += 3)
            {
                var triplet = (input.charCodeAt(i) << 16)
                    | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                    | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
                for(var j = 0; j < 4; j++)
                {
                    if(i * 8 + j * 6 > input.length * 8) output += b64pad;
                    else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
                }
            }
            return output;
        }

        /*
         * Convert a raw string to an arbitrary string encoding
         */
        function rstr2any(input, encoding)
        {
            if (!(encoding)) {
                if (enc) return enc(input);
                else return rstr2hex(input);}
            var divisor = encoding.length;
            var i, j, q, x, quotient;

            /* Convert to an array of 16-bit big-endian values, forming the dividend */
            var dividend = new Array(Math.ceil(input.length / 2));
            for(i = 0; i < dividend.length; i++)
            {
                dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
            }

            /*
             * Repeatedly perform a long division. The binary array forms the dividend,
             * the length of the encoding is the divisor. Once computed, the quotient
             * forms the dividend for the next step. All remainders are stored for later
             * use.
             */
            var full_length = Math.ceil(input.length * 8 /
                                        (Math.log(encoding.length) / Math.log(2)));
            var remainders = new Array(full_length);
            for(j = 0; j < full_length; j++)
            {
                quotient = [];
                x = 0;
                for(i = 0; i < dividend.length; i++)
                {
                    x = (x << 16) + dividend[i];
                    q = Math.floor(x / divisor);
                    x -= q * divisor;
                    if(quotient.length > 0 || q > 0)
                        quotient[quotient.length] = q;
                }
                remainders[j] = x;
                dividend = quotient;
            }

            /* Convert the remainders to the output string */
            var output = "";
            for(i = remainders.length - 1; i >= 0; i--)
                output += encoding.charAt(remainders[i]);

            return output;
        }

        /*
         * Encode a string as utf-8.
         * For efficiency, this assumes the input is valid utf-16.
         */
        function str2rstr_utf8(input)
        {
            var output = "";
            var i = -1;
            var x, y;

            while(++i < input.length)
            {
                /* Decode utf-16 surrogate pairs */
                x = input.charCodeAt(i);
                y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
                if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
                {
                    x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
                    i++;
                }

                /* Encode output as utf-8 */
                if(x <= 0x7F)
                    output += String.fromCharCode(x);
                else if(x <= 0x7FF)
                    output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                                  0x80 | ( x         & 0x3F));
                else if(x <= 0xFFFF)
                    output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                                  0x80 | ((x >>> 6 ) & 0x3F),
                                                  0x80 | ( x         & 0x3F));
                else if(x <= 0x1FFFFF)
                    output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                                  0x80 | ((x >>> 12) & 0x3F),
                                                  0x80 | ((x >>> 6 ) & 0x3F),
                                                  0x80 | ( x         & 0x3F));
            }
            return output;
        }

        /*
         * Encode a string as utf-16
         */
        function str2rstr_utf16le(input)
        {
            var output = "";
            for(var i = 0; i < input.length; i++)
                output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                               (input.charCodeAt(i) >>> 8) & 0xFF);
            return output;
        }

        function str2rstr_utf16be(input)
        {
            var output = "";
            for(var i = 0; i < input.length; i++)
                output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                              input.charCodeAt(i)        & 0xFF);
            return output;
        }

        /*
         * Convert a raw string to an array of little-endian words
         * Characters >255 have their high-byte silently ignored.
         */
        function rstr2binl(input)
        {
            var output = new Array(input.length >> 2); var i;
            for(i = 0; i < output.length; i++)
                output[i] = 0;
            for(i = 0; i < input.length * 8; i += 8)
                output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
            return output;
        }

        /*
         * Convert an array of little-endian words to a string
         */
        function binl2rstr(input)
        {
            var output = "";
            for(var i = 0; i < input.length * 32; i += 8)
                output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
            return output;
        }

        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        function safe_add(x, y)
        {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        }

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function bit_rol(num, cnt)
        {
            return (num << cnt) | (num >>> (32 - cnt));
        }

        /*
         * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
         * Digest Algorithm, as defined in RFC 1321.
         * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         * Distributed under the BSD License
         * See http://pajhome.org.uk/crypt/md5 for more info.
         */

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
        function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
        function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
        function hex_hmac_md5(k, d)
        { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function b64_hmac_md5(k, d)
        { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function any_hmac_md5(k, d, e)
        { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

        /*
         * Perform a simple self-test to see if the VM is working
         */
        function md5_vm_test()
        {
            return hex_md5("abc").toLowerCase() === "900150983cd24fb0d6963f7d28e17f72";
        }

        /*
         * Calculate the MD5 of a raw string
         */
        function rstr_md5(s)
        {
            return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
        }

        /*
         * Calculate the HMAC-MD5, of a key and some data (raw strings)
         */
        function rstr_hmac_md5(key, data)
        {
            var bkey = rstr2binl(key);
            if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

            var ipad = new Array(16), opad = new Array(16);
            for(var i = 0; i < 16; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
            return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
        }

        /* Calculate the MD5 of an array of little-endian words, and a bit length.
         */
        function binl_md5(x, len)
        {
            /* append padding */
            x[len >> 5] |= 0x80 << ((len) % 32);
            x[(((len + 64) >>> 9) << 4) + 14] = len;

            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;

            for(var i = 0; i < x.length; i += 16)
            {
                var olda = a;
                var oldb = b;
                var oldc = c;
                var oldd = d;

                a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
                d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
                c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
                b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
                a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
                d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
                c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
                b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
                a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
                d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
                c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
                b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
                a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
                d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
                c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
                b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

                a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
                d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
                c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
                b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
                a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
                d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
                c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
                b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
                a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
                d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
                c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
                b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
                a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
                d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
                c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
                b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

                a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
                d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
                c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
                b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
                a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
                d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
                c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
                b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
                a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
                d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
                c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
                b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
                a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
                d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
                c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
                b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

                a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
                d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
                c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
                b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
                a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
                d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
                c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
                b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
                a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
                d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
                c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
                b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
                a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
                d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
                c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
                b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
            }
            return new Array(a, b, c, d);
        }

        /*
         * These functions implement the four basic operations the algorithm uses.
         */
        function md5_cmn(q, a, b, x, s, t)
        {
            return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
        }
        function md5_ff(a, b, c, d, x, s, t)
        {
            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
        }
        function md5_gg(a, b, c, d, x, s, t)
        {
            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
        }
        function md5_hh(a, b, c, d, x, s, t)
        {
            return md5_cmn(b ^ c ^ d, a, b, x, s, t);
        }
        function md5_ii(a, b, c, d, x, s, t)
        {
            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        }

        /*
         * A JavaScript implementation of the RIPEMD-160 Algorithm
         * Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         * Distributed under the BSD License
         * See http://pajhome.org.uk/crypt/md5 for details.
         * Also http://www.ocf.berkeley.edu/~jjlin/jsotp/
         */

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        function hex_rmd160(s)    { return rstr2hex(rstr_rmd160(str2rstr_utf8(s))); }
        function b64_rmd160(s)    { return rstr2b64(rstr_rmd160(str2rstr_utf8(s))); }
        function any_rmd160(s, e) { return rstr2any(rstr_rmd160(str2rstr_utf8(s)), e); }
        function hex_hmac_rmd160(k, d)
        { return rstr2hex(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function b64_hmac_rmd160(k, d)
        { return rstr2b64(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function any_hmac_rmd160(k, d, e)
        { return rstr2any(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

        /*
         * Perform a simple self-test to see if the VM is working
         */
        function rmd160_vm_test()
        {
            return hex_rmd160("abc").toLowerCase() === "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc";
        }

        /*
         * Calculate the rmd160 of a raw string
         */
        function rstr_rmd160(s)
        {
            return binl2rstr(binl_rmd160(rstr2binl(s), s.length * 8));
        }

        /*
         * Calculate the HMAC-rmd160 of a key and some data (raw strings)
         */
        function rstr_hmac_rmd160(key, data)
        {
            var bkey = rstr2binl(key);
            if(bkey.length > 16) bkey = binl_rmd160(bkey, key.length * 8);

            var ipad = new Array(16), opad = new Array(16);
            for(var i = 0; i < 16; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = binl_rmd160(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
            return binl2rstr(binl_rmd160(opad.concat(hash), 512 + 160));
        }


        /*
         * Calculate the RIPE-MD160 of an array of little-endian words, and a bit length.
         */
        function binl_rmd160(x, len)
        {
            /* append padding */
            x[len >> 5] |= 0x80 << (len % 32);
            x[(((len + 64) >>> 9) << 4) + 14] = len;

            var h0 = 0x67452301;
            var h1 = 0xefcdab89;
            var h2 = 0x98badcfe;
            var h3 = 0x10325476;
            var h4 = 0xc3d2e1f0;

            for (var i = 0; i < x.length; i += 16) {
                var T;
                var A1 = h0, B1 = h1, C1 = h2, D1 = h3, E1 = h4;
                var A2 = h0, B2 = h1, C2 = h2, D2 = h3, E2 = h4;
                for (var j = 0; j <= 79; ++j) {
                    T = safe_add(A1, rmd160_f(j, B1, C1, D1));
                    T = safe_add(T, x[i + rmd160_r1[j]]);
                    T = safe_add(T, rmd160_K1(j));
                    T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
                    A1 = E1; E1 = D1; D1 = bit_rol(C1, 10); C1 = B1; B1 = T;
                    T = safe_add(A2, rmd160_f(79-j, B2, C2, D2));
                    T = safe_add(T, x[i + rmd160_r2[j]]);
                    T = safe_add(T, rmd160_K2(j));
                    T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
                    A2 = E2; E2 = D2; D2 = bit_rol(C2, 10); C2 = B2; B2 = T;
                }
                T = safe_add(h1, safe_add(C1, D2));
                h1 = safe_add(h2, safe_add(D1, E2));
                h2 = safe_add(h3, safe_add(E1, A2));
                h3 = safe_add(h4, safe_add(A1, B2));
                h4 = safe_add(h0, safe_add(B1, C2));
                h0 = T;
            }
            return [h0, h1, h2, h3, h4];
        }

        function rmd160_f(j, x, y, z)
        {
            return ( 0 <= j && j <= 15) ? (x ^ y ^ z) :
                (16 <= j && j <= 31) ? (x & y) | (~x & z) :
                (32 <= j && j <= 47) ? (x | ~y) ^ z :
                (48 <= j && j <= 63) ? (x & z) | (y & ~z) :
                (64 <= j && j <= 79) ? x ^ (y | ~z) :
                "rmd160_f: j out of range";
        }
        function rmd160_K1(j)
        {
            return ( 0 <= j && j <= 15) ? 0x00000000 :
                (16 <= j && j <= 31) ? 0x5a827999 :
                (32 <= j && j <= 47) ? 0x6ed9eba1 :
                (48 <= j && j <= 63) ? 0x8f1bbcdc :
                (64 <= j && j <= 79) ? 0xa953fd4e :
                "rmd160_K1: j out of range";
        }
        function rmd160_K2(j)
        {
            return ( 0 <= j && j <= 15) ? 0x50a28be6 :
                (16 <= j && j <= 31) ? 0x5c4dd124 :
                (32 <= j && j <= 47) ? 0x6d703ef3 :
                (48 <= j && j <= 63) ? 0x7a6d76e9 :
                (64 <= j && j <= 79) ? 0x00000000 :
                "rmd160_K2: j out of range";
        }
        var rmd160_r1 = [
            0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
            7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
            3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
            1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
            4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13
        ];
        var rmd160_r2 = [
            5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
            6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
            15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
            8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
            12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11
        ];
        var rmd160_s1 = [
            11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
            7,  6,  8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
            11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
            11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
            9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6
        ];
        var rmd160_s2 = [
            8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
            9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
            9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
            15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
            8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11
        ];

        /*
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
         * in FIPS 180-1
         * Version 2.2 Copyright Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         * Distributed under the BSD License
         * See http://pajhome.org.uk/crypt/md5 for details.
         */

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        function hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }
        function b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }
        function any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }
        function hex_hmac_sha1(k, d)
        { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function b64_hmac_sha1(k, d)
        { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function any_hmac_sha1(k, d, e)
        { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

        /*
         * Perform a simple self-test to see if the VM is working
         */
        function sha1_vm_test()
        {
            return hex_sha1("abc").toLowerCase() === "a9993e364706816aba3e25717850c26c9cd0d89d";
        }

        /*
         * Calculate the SHA1 of a raw string
         */
        function rstr_sha1(s)
        {
            return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
        }

        /*
         * Calculate the HMAC-SHA1 of a key and some data (raw strings)
         */
        function rstr_hmac_sha1(key, data)
        {
            var bkey = rstr2binb(key);
            if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

            var ipad = new Array(16), opad = new Array(16);
            for(var i = 0; i < 16; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
            return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
        }

        /*
         * Calculate the SHA-1 of an array of big-endian words, and a bit length
         */
        function binb_sha1(x, len)
        {
            /* append padding */
            x[len >> 5] |= 0x80 << (24 - len % 32);
            x[((len + 64 >> 9) << 4) + 15] = len;

            var w = new Array(80);
            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;
            var e = -1009589776;

            for(var i = 0; i < x.length; i += 16)
            {
                var olda = a;
                var oldb = b;
                var oldc = c;
                var oldd = d;
                var olde = e;

                for(var j = 0; j < 80; j++)
                {
                    if(j < 16) w[j] = x[i + j];
                    else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
                    var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
                                     safe_add(safe_add(e, w[j]), sha1_kt(j)));
                    e = d;
                    d = c;
                    c = bit_rol(b, 30);
                    b = a;
                    a = t;
                }

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
                e = safe_add(e, olde);
            }
            return new Array(a, b, c, d, e);

        }

        /*
         * Perform the appropriate triplet combination function for the current
         * iteration
         */
        function sha1_ft(t, b, c, d)
        {
            if(t < 20) return (b & c) | ((~b) & d);
            if(t < 40) return b ^ c ^ d;
            if(t < 60) return (b & c) | (b & d) | (c & d);
            return b ^ c ^ d;
        }

        /*
         * Determine the appropriate additive constant for the current iteration
         */
        function sha1_kt(t)
        {
            return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
                (t < 60) ? -1894007588 : -899497514;
        }

        /*
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
         * in FIPS 180-2
         * Version 2.2 Copyright Angel Marin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         * Distributed under the BSD License
         * See http://pajhome.org.uk/crypt/md5 for details.
         * Also http://anmar.eu.org/projects/jssha2/
         */

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        function hex_sha256(s)    { return rstr2hex(rstr_sha256(str2rstr_utf8(s))); }
        function b64_sha256(s)    { return rstr2b64(rstr_sha256(str2rstr_utf8(s))); }
        function any_sha256(s, e) { return rstr2any(rstr_sha256(str2rstr_utf8(s)), e); }
        function hex_hmac_sha256(k, d)
        { return rstr2hex(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function b64_hmac_sha256(k, d)
        { return rstr2b64(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function any_hmac_sha256(k, d, e)
        { return rstr2any(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

        /*
         * Perform a simple self-test to see if the VM is working
         */
        function sha256_vm_test()
        {
            return hex_sha256("abc").toLowerCase() ===
                "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad";
        }

        /*
         * Calculate the sha256 of a raw string
         */
        function rstr_sha256(s)
        {
            return binb2rstr(binb_sha256(rstr2binb(s), s.length * 8));
        }

        /*
         * Calculate the HMAC-sha256 of a key and some data (raw strings)
         */
        function rstr_hmac_sha256(key, data)
        {
            var bkey = rstr2binb(key);
            if(bkey.length > 16) bkey = binb_sha256(bkey, key.length * 8);

            var ipad = new Array(16), opad = new Array(16);
            for(var i = 0; i < 16; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = binb_sha256(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
            return binb2rstr(binb_sha256(opad.concat(hash), 512 + 256));
        }

        /*
         * Main sha256 function, with its support functions
         */
        function sha256_S (X, n) {return ( X >>> n ) | (X << (32 - n));}
        function sha256_R (X, n) {return ( X >>> n );}
        function sha256_Ch(x, y, z) {return ((x & y) ^ ((~x) & z));}
        function sha256_Maj(x, y, z) {return ((x & y) ^ (x & z) ^ (y & z));}
        function sha256_Sigma0256(x) {return (sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22));}
        function sha256_Sigma1256(x) {return (sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25));}
        function sha256_Gamma0256(x) {return (sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3));}
        function sha256_Gamma1256(x) {return (sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10));}
        function sha256_Sigma0512(x) {return (sha256_S(x, 28) ^ sha256_S(x, 34) ^ sha256_S(x, 39));}
        function sha256_Sigma1512(x) {return (sha256_S(x, 14) ^ sha256_S(x, 18) ^ sha256_S(x, 41));}
        function sha256_Gamma0512(x) {return (sha256_S(x, 1)  ^ sha256_S(x, 8) ^ sha256_R(x, 7));}
        function sha256_Gamma1512(x) {return (sha256_S(x, 19) ^ sha256_S(x, 61) ^ sha256_R(x, 6));}

        var sha256_K = new Array
        (
            1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993,
                -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987,
            1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522,
            264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
                -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585,
            113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
            1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885,
                -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344,
            430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
            1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872,
                -1866530822, -1538233109, -1090935817, -965641998
        );

        function binb_sha256(m, l)
        {
            var HASH = new Array(1779033703, -1150833019, 1013904242, -1521486534,
                                 1359893119, -1694144372, 528734635, 1541459225);
            var W = new Array(64);
            var a, b, c, d, e, f, g, h;
            var i, j, T1, T2;

            /* append padding */
            m[l >> 5] |= 0x80 << (24 - l % 32);
            m[((l + 64 >> 9) << 4) + 15] = l;

            for(i = 0; i < m.length; i += 16)
            {
                a = HASH[0];
                b = HASH[1];
                c = HASH[2];
                d = HASH[3];
                e = HASH[4];
                f = HASH[5];
                g = HASH[6];
                h = HASH[7];

                for(j = 0; j < 64; j++)
                {
                    if (j < 16) W[j] = m[j + i];
                    else W[j] = safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]),
                                                  sha256_Gamma0256(W[j - 15])), W[j - 16]);

                    T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)),
                                           sha256_K[j]), W[j]);
                    T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c));
                    h = g;
                    g = f;
                    f = e;
                    e = safe_add(d, T1);
                    d = c;
                    c = b;
                    b = a;
                    a = safe_add(T1, T2);
                }

                HASH[0] = safe_add(a, HASH[0]);
                HASH[1] = safe_add(b, HASH[1]);
                HASH[2] = safe_add(c, HASH[2]);
                HASH[3] = safe_add(d, HASH[3]);
                HASH[4] = safe_add(e, HASH[4]);
                HASH[5] = safe_add(f, HASH[5]);
                HASH[6] = safe_add(g, HASH[6]);
                HASH[7] = safe_add(h, HASH[7]);
            }
            return HASH;
        }

        /*
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-512, as defined
         * in FIPS 180-2
         * Version 2.2 Copyright Anonymous Contributor, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         * Distributed under the BSD License
         * See http://pajhome.org.uk/crypt/md5 for details.
         */

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        function hex_sha512(s)    { return rstr2hex(rstr_sha512(str2rstr_utf8(s))); }
        function b64_sha512(s)    { return rstr2b64(rstr_sha512(str2rstr_utf8(s))); }
        function any_sha512(s, e) { return rstr2any(rstr_sha512(str2rstr_utf8(s)), e);}
        function hex_hmac_sha512(k, d)
        { return rstr2hex(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function b64_hmac_sha512(k, d)
        { return rstr2b64(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d))); }
        function any_hmac_sha512(k, d, e)
        { return rstr2any(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)), e);}

        /*
         * Perform a simple self-test to see if the VM is working
         */
        function sha512_vm_test()
        {
            return hex_sha512("abc").toLowerCase() ===
                "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" +
                "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f";
        }

        /*
         * Calculate the SHA-512 of a raw string
         */
        function rstr_sha512(s)
        {
            return binb2rstr(binb_sha512(rstr2binb(s), s.length * 8));
        }

        /*
         * Calculate the HMAC-SHA-512 of a key and some data (raw strings)
         */
        function rstr_hmac_sha512(key, data)
        {
            var bkey = rstr2binb(key);
            if(bkey.length > 32) bkey = binb_sha512(bkey, key.length * 8);

            var ipad = new Array(32), opad = new Array(32);
            for(var i = 0; i < 32; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = binb_sha512(ipad.concat(rstr2binb(data)), 1024 + data.length * 8);
            return binb2rstr(binb_sha512(opad.concat(hash), 1024 + 512));
        }

        /*
         * Calculate the SHA-512 of an array of big-endian dwords, and a bit length
         */
        var sha512_k;
        function binb_sha512(x, len)
        {
            if(sha512_k === undefined)
            {
                //SHA512 constants
                sha512_k = new Array(
                    new Int64(0x428a2f98, -685199838), new Int64(0x71374491, 0x23ef65cd),
                    new Int64(-1245643825, -330482897), new Int64(-373957723, -2121671748),
                    new Int64(0x3956c25b, -213338824), new Int64(0x59f111f1, -1241133031),
                    new Int64(-1841331548, -1357295717), new Int64(-1424204075, -630357736),
                    new Int64(-670586216, -1560083902), new Int64(0x12835b01, 0x45706fbe),
                    new Int64(0x243185be, 0x4ee4b28c), new Int64(0x550c7dc3, -704662302),
                    new Int64(0x72be5d74, -226784913), new Int64(-2132889090, 0x3b1696b1),
                    new Int64(-1680079193, 0x25c71235), new Int64(-1046744716, -815192428),
                    new Int64(-459576895, -1628353838), new Int64(-272742522, 0x384f25e3),
                    new Int64(0xfc19dc6, -1953704523), new Int64(0x240ca1cc, 0x77ac9c65),
                    new Int64(0x2de92c6f, 0x592b0275), new Int64(0x4a7484aa, 0x6ea6e483),
                    new Int64(0x5cb0a9dc, -1119749164), new Int64(0x76f988da, -2096016459),
                    new Int64(-1740746414, -295247957), new Int64(-1473132947, 0x2db43210),
                    new Int64(-1341970488, -1728372417), new Int64(-1084653625, -1091629340),
                    new Int64(-958395405, 0x3da88fc2), new Int64(-710438585, -1828018395),
                    new Int64(0x6ca6351, -536640913), new Int64(0x14292967, 0xa0e6e70),
                    new Int64(0x27b70a85, 0x46d22ffc), new Int64(0x2e1b2138, 0x5c26c926),
                    new Int64(0x4d2c6dfc, 0x5ac42aed), new Int64(0x53380d13, -1651133473),
                    new Int64(0x650a7354, -1951439906), new Int64(0x766a0abb, 0x3c77b2a8),
                    new Int64(-2117940946, 0x47edaee6), new Int64(-1838011259, 0x1482353b),
                    new Int64(-1564481375, 0x4cf10364), new Int64(-1474664885, -1136513023),
                    new Int64(-1035236496, -789014639), new Int64(-949202525, 0x654be30),
                    new Int64(-778901479, -688958952), new Int64(-694614492, 0x5565a910),
                    new Int64(-200395387, 0x5771202a), new Int64(0x106aa070, 0x32bbd1b8),
                    new Int64(0x19a4c116, -1194143544), new Int64(0x1e376c08, 0x5141ab53),
                    new Int64(0x2748774c, -544281703), new Int64(0x34b0bcb5, -509917016),
                    new Int64(0x391c0cb3, -976659869), new Int64(0x4ed8aa4a, -482243893),
                    new Int64(0x5b9cca4f, 0x7763e373), new Int64(0x682e6ff3, -692930397),
                    new Int64(0x748f82ee, 0x5defb2fc), new Int64(0x78a5636f, 0x43172f60),
                    new Int64(-2067236844, -1578062990), new Int64(-1933114872, 0x1a6439ec),
                    new Int64(-1866530822, 0x23631e28), new Int64(-1538233109, -561857047),
                    new Int64(-1090935817, -1295615723), new Int64(-965641998, -479046869),
                    new Int64(-903397682, -366583396), new Int64(-779700025, 0x21c0c207),
                    new Int64(-354779690, -840897762), new Int64(-176337025, -294727304),
                    new Int64(0x6f067aa, 0x72176fba), new Int64(0xa637dc5, -1563912026),
                    new Int64(0x113f9804, -1090974290), new Int64(0x1b710b35, 0x131c471b),
                    new Int64(0x28db77f5, 0x23047d84), new Int64(0x32caab7b, 0x40c72493),
                    new Int64(0x3c9ebe0a, 0x15c9bebc), new Int64(0x431d67c4, -1676669620),
                    new Int64(0x4cc5d4be, -885112138), new Int64(0x597f299c, -60457430),
                    new Int64(0x5fcb6fab, 0x3ad6faec), new Int64(0x6c44198c, 0x4a475817));
            }

            //Initial hash values
            var H = new Array(
                new Int64(0x6a09e667, -205731576),
                new Int64(-1150833019, -2067093701),
                new Int64(0x3c6ef372, -23791573),
                new Int64(-1521486534, 0x5f1d36f1),
                new Int64(0x510e527f, -1377402159),
                new Int64(-1694144372, 0x2b3e6c1f),
                new Int64(0x1f83d9ab, -79577749),
                new Int64(0x5be0cd19, 0x137e2179));

            var T1 = new Int64(0, 0),
            T2 = new Int64(0, 0),
            a = new Int64(0,0),
            b = new Int64(0,0),
            c = new Int64(0,0),
            d = new Int64(0,0),
            e = new Int64(0,0),
            f = new Int64(0,0),
            g = new Int64(0,0),
            h = new Int64(0,0),
            //Temporary variables not specified by the document
            s0 = new Int64(0, 0),
            s1 = new Int64(0, 0),
            Ch = new Int64(0, 0),
            Maj = new Int64(0, 0),
            r1 = new Int64(0, 0),
            r2 = new Int64(0, 0),
            r3 = new Int64(0, 0);
            var j, i;
            var W = new Array(80);
            for(i=0; i<80; i++)
                W[i] = new Int64(0, 0);

            // append padding to the source string. The format is described in the FIPS.
            x[len >> 5] |= 0x80 << (24 - (len & 0x1f));
            x[((len + 128 >> 10)<< 5) + 31] = len;

            for(i = 0; i<x.length; i+=32) //32 dwords is the block size
            {
                int64copy(a, H[0]);
                int64copy(b, H[1]);
                int64copy(c, H[2]);
                int64copy(d, H[3]);
                int64copy(e, H[4]);
                int64copy(f, H[5]);
                int64copy(g, H[6]);
                int64copy(h, H[7]);

                for(j=0; j<16; j++)
                {
                    W[j].h = x[i + 2*j];
                    W[j].l = x[i + 2*j + 1];
                }

                for(j=16; j<80; j++)
                {
                    //sigma1
                    int64rrot(r1, W[j-2], 19);
                    int64revrrot(r2, W[j-2], 29);
                    int64shr(r3, W[j-2], 6);
                    s1.l = r1.l ^ r2.l ^ r3.l;
                    s1.h = r1.h ^ r2.h ^ r3.h;
                    //sigma0
                    int64rrot(r1, W[j-15], 1);
                    int64rrot(r2, W[j-15], 8);
                    int64shr(r3, W[j-15], 7);
                    s0.l = r1.l ^ r2.l ^ r3.l;
                    s0.h = r1.h ^ r2.h ^ r3.h;

                    int64add4(W[j], s1, W[j-7], s0, W[j-16]);
                }

                for(j = 0; j < 80; j++)
                {
                    //Ch
                    Ch.l = (e.l & f.l) ^ (~e.l & g.l);
                    Ch.h = (e.h & f.h) ^ (~e.h & g.h);

                    //Sigma1
                    int64rrot(r1, e, 14);
                    int64rrot(r2, e, 18);
                    int64revrrot(r3, e, 9);
                    s1.l = r1.l ^ r2.l ^ r3.l;
                    s1.h = r1.h ^ r2.h ^ r3.h;

                    //Sigma0
                    int64rrot(r1, a, 28);
                    int64revrrot(r2, a, 2);
                    int64revrrot(r3, a, 7);
                    s0.l = r1.l ^ r2.l ^ r3.l;
                    s0.h = r1.h ^ r2.h ^ r3.h;

                    //Maj
                    Maj.l = (a.l & b.l) ^ (a.l & c.l) ^ (b.l & c.l);
                    Maj.h = (a.h & b.h) ^ (a.h & c.h) ^ (b.h & c.h);

                    int64add5(T1, h, s1, Ch, sha512_k[j], W[j]);
                    int64add(T2, s0, Maj);

                    int64copy(h, g);
                    int64copy(g, f);
                    int64copy(f, e);
                    int64add(e, d, T1);
                    int64copy(d, c);
                    int64copy(c, b);
                    int64copy(b, a);
                    int64add(a, T1, T2);
                }
                int64add(H[0], H[0], a);
                int64add(H[1], H[1], b);
                int64add(H[2], H[2], c);
                int64add(H[3], H[3], d);
                int64add(H[4], H[4], e);
                int64add(H[5], H[5], f);
                int64add(H[6], H[6], g);
                int64add(H[7], H[7], h);
            }

            //represent the hash as an array of 32-bit dwords
            var hash = new Array(16);
            for(i=0; i<8; i++)
            {
                hash[2*i] = H[i].h;
                hash[2*i + 1] = H[i].l;
            }
            return hash;
        }

        //A constructor for 64-bit numbers
        function Int64(h, l)
        {
            this.h = h;
            this.l = l;
            //this.toString = int64toString;
        }

        //Copies src into dst, assuming both are 64-bit numbers
        function int64copy(dst, src)
        {
            dst.h = src.h;
            dst.l = src.l;
        }

        //Right-rotates a 64-bit number by shift
        //Won't handle cases of shift>=32
        //The function revrrot() is for that
        function int64rrot(dst, x, shift)
        {
            dst.l = (x.l >>> shift) | (x.h << (32-shift));
            dst.h = (x.h >>> shift) | (x.l << (32-shift));
        }

        //Reverses the dwords of the source and then rotates right by shift.
        //This is equivalent to rotation by 32+shift
        function int64revrrot(dst, x, shift)
        {
            dst.l = (x.h >>> shift) | (x.l << (32-shift));
            dst.h = (x.l >>> shift) | (x.h << (32-shift));
        }

        //Bitwise-shifts right a 64-bit number by shift
        //Won't handle shift>=32, but it's never needed in SHA512
        function int64shr(dst, x, shift)
        {
            dst.l = (x.l >>> shift) | (x.h << (32-shift));
            dst.h = (x.h >>> shift);
        }

        //Adds two 64-bit numbers
        //Like the original implementation, does not rely on 32-bit operations
        function int64add(dst, x, y)
        {
            var w0 = (x.l & 0xffff) + (y.l & 0xffff);
            var w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16);
            var w2 = (x.h & 0xffff) + (y.h & 0xffff) + (w1 >>> 16);
            var w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);
            dst.l = (w0 & 0xffff) | (w1 << 16);
            dst.h = (w2 & 0xffff) | (w3 << 16);
        }

        //Same, except with 4 addends. Works faster than adding them one by one.
        function int64add4(dst, a, b, c, d)
        {
            var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff);
            var w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (w0 >>> 16);
            var w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (w1 >>> 16);
            var w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (w2 >>> 16);
            dst.l = (w0 & 0xffff) | (w1 << 16);
            dst.h = (w2 & 0xffff) | (w3 << 16);
        }

        //Same, except with 5 addends
        function int64add5(dst, a, b, c, d, e)
        {
            var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff) + (e.l & 0xffff);
            var w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (e.l >>> 16) + (w0 >>> 16);
            var w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (e.h & 0xffff) + (w1 >>> 16);
            var w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (e.h >>> 16) + (w2 >>> 16);
            dst.l = (w0 & 0xffff) | (w1 << 16);
            dst.h = (w2 & 0xffff) | (w3 << 16);
        }

        return {
            "_get_hexcase_": gethexcase, "_set_hexcase_": sethexcase,
            "_get_padchar_": getpadchar, "_set_padchar_": setpadchar,
            "_get_outenc_": getenc, "_set_outenc_": setenc,
            "hex": rstr2hex, b64: "rst2b64", base64: "rst2b64",
            "array": rstr2binl, "binl": rstr2binl,
            hex_md5: hex_md5,
            b64_md5: b64_md5,
            md5: any_md5,
            hex_hmac_md5: hex_hmac_md5,
            b64_hmac_md5: b64_hmac_md5,
            hmac_md5: any_hmac_md5,
            hex_rmd160: hex_rmd160,
            b64_rmd160: b64_rmd160,
            rmd160: any_rmd160,
            hex_hmac_rmd160: hex_hmac_rmd160,
            b64_hmac_rmd160: b64_hmac_rmd160,
            hmac_rmd160: any_hmac_rmd160,
            hex_sha1: hex_sha1,
            b64_sha1: b64_sha1,
            sha1: any_sha1,
            hex_hmac_sha1: hex_hmac_sha1,
            b64_hmac_sha1: b64_hmac_sha1,
            hmac_sha1: any_hmac_sha1,
            hex_sha256: hex_sha256,
            b64_sha256: b64_sha256,
            sha256: any_sha256,
            hex_hmac_sha256: hex_hmac_sha256,
            b64_hmac_sha256: b64_hmac_sha256,
            hmac_sha256: any_hmac_sha256,
            hex_sha512: hex_sha512,
            b64_sha512: b64_sha512,
            sha512: any_sha512,
            hex_hmac_sha512: hex_hmac_sha512,
            b64_hmac_sha512: b64_hmac_sha512,
            hmac_sha512: any_hmac_sha512};

    })();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/log.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.Log=(function(){
    "use strict";
    var fdjtString=fdjt.String;

    var backlog=[];

    var use_console_log;
    var compactString=fdjt.Time.compactString, ET=fdjt.ET;

    function fdjtLog(string){
        var output=false; var now=ET(), date=new Date();
        var i, lim;
        if (((fdjtLog.doformat)||(string.search("%j")))&&
            (typeof fdjtString !== 'undefined'))
            output=fdjtString.apply(null,arguments);
        if (fdjtLog.console_fn) {
            if (output) fdjtLog.console_fn.call(fdjtLog.console,output);
            else fdjtLog.console_fn.apply(fdjtLog.console,arguments);}
        if (fdjtLog.logurl) {
            var msg="["+now+"s "+compactString(date,false)+"] "+
                fdjtString.apply(null,arguments);
            if (window.console)
                window.console.log("remote logging %s",msg);
            remote_log(msg);}
        if (fdjtLog.console) {
            var domconsole=fdjtLog.console;
            var timespan=fdjt.DOM("span.time",now);
            var abstime=fdjt.DOM("span.abstime",compactString(date));
            var entry=fdjt.DOM("div.fdjtlog");
            if (output) entry.innerHTML=output;
            else entry.innerHTML=fdjtString.apply(null,arguments);
            fdjt.DOM.prepend(entry,timespan);
            fdjt.DOM.prepend(entry,abstime);
            if (typeof domconsole === 'string') {
                var found=document.getElementById(domconsole);
                if (found) {
                    domconsole=fdjtLog.console=found;}
                else domconsole=false;}
            if ((domconsole)&&(!(domconsole.nodeType))) domconsole=false;
            if ((domconsole)&&(fdjtLog.livelog)) {
                update_log(domconsole);
                domconsole.appendChild(entry);
                domconsole.appendChild(document.createTextNode("\n"));}
            else if ((!(domconsole))||(domconsole.offsetHeight===0))
                backlog.push(entry);
            else {
                update_log(domconsole);
                domconsole.appendChild(entry);
                domconsole.appendChild(document.createTextNode("\n"));}}
        if ((fdjtLog.useconsole)||
            ((!(fdjtLog.console))&&(!(fdjtLog.console_fn)))) {
            if (typeof use_console_log === 'undefined')
                init_use_console_log();
            if (use_console_log) {
                if (!(window.console.log.call)) 
                    // In IE, window.console.log is an object, not a function,
                    //  but a straight call still works.
                    window.console.log(
                        "["+now+"s] "+fdjtString.apply(null,arguments));
                else if (output)
                    window.console.log.call(
                        window.console,"["+now+"s] "+output);
                else {
                    var newargs=new Array(arguments.length+1);
                    newargs[0]="[%fs] "+string;
                    newargs[1]=now;
                    i=1; lim=arguments.length;
                    while (i<lim) {newargs[i+1]=arguments[i]; i++;}
                    window.console.log.apply(window.console,newargs);}}}}
    fdjtLog.console=null;

    function update_log(domconsole){
        if ((backlog)&&(backlog.length)) {
            var frag=document.createDocumentFragment();
            var log=backlog; backlog=false;
            var i=0, lim=log.length; while (i<lim) {
                frag.appendChild(log[i++]);
                frag.appendChild(document.createTextNode("\n"));}
            domconsole.appendChild(frag);
            backlog=[];}}
    fdjtLog.update=function(){
        if (fdjtLog.console) update_log(fdjtLog.console);};

    function remote_log(msg){
        var req=new XMLHttpRequest();
        req.open('POST',fdjtLog.logurl,(!(fdjtLog.logsync)));
        req.setRequestHeader("Content-type","text; charset=utf-8");
        req.send(msg);
        return req;}

    fdjtLog.warn=function(){
        if ((!(fdjtLog.console_fn))&&
            (!(window.console)&&(window.console.log)&&
             (window.console.log.count))) {
            var output=fdjtString.apply(null,arguments);
            window.alert(output);}
        else fdjtLog.apply(null,arguments);};

    fdjtLog.uhoh=function(){
        if (fdjtLog.debugging) fdjtLog.warn.call(this,arguments);};

    fdjtLog.bkpt=function(){
        var output=false;
        if ((fdjtLog.doformat)&&(typeof fdjtString !== 'undefined'))
            output=fdjtString.apply(null,arguments);
        if (fdjtLog.console_fn)
            if (output) fdjtLog.console_fn(fdjtLog.console,output);
        else fdjtLog.console_fn.apply(fdjtLog.console,arguments);
        else if ((window.console) && (window.console.log) &&
                 (window.console.count))
            if (output)
                window.console.log.call(window.console,output);
        else window.console.log.apply(window.console,arguments);
    };

    fdjtLog.useconsole=true;

    function init_use_console_log() {
        if ((window.console)&&(window.console.log)) {
            if (window.console.count) use_console_log=true;
            else {
                use_console_log=true;
                try {window.console.log("Testing console");}
                catch (ex) { use_console_log=false;}}}
        else use_console_log=false;}


    // This is for temporary trace statements; we use a different name
    //  so that they're easy to find.
    fdjt.Trace=fdjt.Log;
    
    return fdjtLog;})(window,document);


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/init.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

//var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

(function(){
    "use strict";
    var fdjtLog=fdjt.Log;
    var inits_run=false;
    var inits=[], run=[];
    var init_names={};

    function addInit(fcn,name,runagain){
        if (!(checkInit(fcn,name))) return;
        var replace=((name)&&(init_names[name]));
        var i=0, lim=inits.length;
        while (i<lim) {
            if ((replace)&&(inits[i]===replace)) {
                if (inits_run) {
                    fdjtLog.warn(
                        "Replacing init %s which has already run",name);
                    if (runagain) {
                        fdjtLog.warn("Running the new version");
                        inits[i]=fcn; init_names[name]=fcn; fcn();
                        return;}}
                else {
                    inits[i]=fcn; init_names[name]=fcn;
                    return;}}
            else if (inits[i]===fcn) return;
            else i++;}
        if (name) init_names[name]=fcn;
        inits.push(fcn);
        if (inits_run) {
            fcn(); run.push(true);}
        else run.push(false);}
    fdjt.addInit=addInit;
    
    function checkInit(fcn,name){
        if ((!(fcn))||(!(fcn.call))) {
            fdjtLog.warn("Bad argument to addInit(): %s",
                        name||"anonymous",fcn);
            return false;}
        else return true;}
    
    fdjt.Init=function fdjtInit(){
        var names=[];
        if (inits_run) return false;
        for (var name in init_names)
            if (init_names.hasOwnProperty(name)) names.push(name);
        if (names.length===0)
            fdjtLog("Running %d DOM inits",inits.length);
        else if (names.length===inits.length)
            fdjtLog("Running %d DOM inits (%s)",
                    inits.length,names.join());
        else fdjtLog("Running %d DOM inits (including %s)",
                     inits.length,names.join());
        var i=0; var lim=inits.length;
        while (i<lim) {
            if (run[i]) i++; 
            else {
                run[i]=true; 
                inits[i]();
                i++;}}
        inits_run=true;};

    var numpat=/^\d+(\.\d+)$/;
    function getMatch(string,rx,i,literal){
        var match=rx.exec(string);
        if (typeof i === "undefined") i=0;
        if ((match)&&(match.length>i)) {
            if (literal) return match[i];
            else if (numpat.test(match[i]))
                return parseFloat(match[i]);
            else return match[i];}
        else return false;}
    
    var spacechars="\n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff";

    function stdspace(string){
        string=string.replace(/\s+/g," ");
        var start=0; var len=string.length; 
        if (len<=0) return string;
        while ((start<len)&&
               (spacechars.indexOf(string.charAt(start))>-1))
            start++;
        if (start===len) return "";
        var end=len-1;
        while ((end>start)&&(spacechars.indexOf(string.charAt(end))>-1))
            end--;
        if ((start>0)||(end<len)) return string.slice(start,end+1);
        else return string;}
    
    var device=(fdjt.device)||(fdjt.device={});
        /* Setting up media info */
    function identifyDevice(){
        if ((fdjt.device)&&(fdjt.device.started)) return;
        var navigator=window.navigator;
        var appversion=navigator.userAgent;
        
        var isAndroid = getMatch(appversion,/\bAndroid +(\d+\.\d+)\b/g,1);
        var isWebKit = getMatch(appversion,/\bAppleWebKit\/(\d+\.\d+)\b/g,1);
        var isGecko = getMatch(appversion,/\bGecko\/(\d+)\b/gi,1,true);
        var isChrome = getMatch(appversion,/\bChrome\/(\d+\.\d+)\b/g,1);
        var isFirefox = getMatch(appversion,/\bFirefox\/(\d+\.\d+)\b/gi,1);
        var isSafari = getMatch(appversion,/\bSafari\/(\d+\.\d+)\b/gi,1);
        var isOSX = getMatch(appversion,/\bMac OS X \/(\d+\_\d+)\b/gi,1,true);
        var isMobileSafari = (isSafari)&&(getMatch(appversion,/\bMobile\/(\w+)\b/gi,1,true));
        var isMobileWebKit = (isWebKit)&&(getMatch(appversion,/\bMobile\/(\w+)\b/gi,1,true));
        var isMobile = (getMatch(appversion,/\bMobile\/(\w+)\b/gi,1,true));
        var hasVersion = getMatch(appversion,/\bVersion\/(\d+\.\d+)\b/gi,1);
        
        var isUbuntu = (/ubuntu/gi).test(appversion);
        var isRedHat = (/redhat/gi).test(appversion);
        var isLinux = (/linux/gi).test(appversion);
        var isMacintosh = (/Macintosh/gi).test(appversion);
        
        var isTouchPad = (/Touchpad/gi).test(appversion);
        var iPhone = (/iphone/gi).test(appversion);
        var iPad = (/ipad/gi).test(appversion);
        var isTouch = iPhone || iPad || isAndroid || isTouchPad;
        var isIOS=((iPhone)||(iPad))&&
            ((getMatch(appversion,/\bVersion\/(\d+\.\d+)\b/gi,1))||(true));
        
        var opt_string=stdspace(
            ((isAndroid)?(" Android/"+isAndroid):(""))+
                ((isWebKit)?(" WebKit/"+isWebKit):(""))+
                ((isGecko)?(" Gecko/"+isGecko):(""))+
                ((isChrome)?(" Chrome/"+isChrome):(""))+
                ((isFirefox)?(" Firefox/"+isFirefox):(""))+
                ((isSafari)?(" Safari/"+isSafari):(""))+
                ((isMobileSafari)?(" MobileSafari/"+isMobileSafari):(""))+
                ((isMobileWebKit)?(" MobileWebKit/"+isMobileWebKit):(""))+
                ((isIOS)?(" IOS/"+isIOS):(""))+
                ((isOSX)?(" OSX/"+isOSX):(""))+
                ((navigator.platform)?(" "+navigator.platform):(""))+
                ((iPhone)?(" iPhone"):(""))+
                ((iPad)?(" iPad"):(""))+
                ((isTouchPad)?(" TouchPad"):(""))+
                ((isTouch)?(" touch"):(" mouse")));
        if (navigator.vendor) device.vendor=navigator.vendor;
        if (navigator.platform) device.platform=navigator.platform;
        if (navigator.oscpu) device.oscpu=navigator.oscpu;
        if (navigator.cookieEnabled) device.cookies=navigator.cookies;
        if (navigator.doNotTrack) device.notrack=navigator.doNotTrack;
        if (navigator.standalone) device.standalone=navigator.standalone;
        device.string=opt_string;
        if (isAndroid) device.android=isAndroid;
        if (isIOS) {
            device.ios=isIOS;
            if (iPhone) device.iphone=isIOS;
            if (iPad) device.ipad=isIOS;}
        if (isChrome) device.chrome=isChrome;
        if (iPad) device.iPad=true;
        if (iPhone) device.iPhone=true;
        if (isIOS) device.ios=true;
        if (isOSX) device.osx=true;
        if (isWebKit) device.webkit=isWebKit;
        if (isSafari) device.safari=isSafari;
        if (isMobileSafari) device.mobilesafari=isMobileSafari;
        if (isMobileWebKit) device.mobilewebkit=isMobileWebKit;
        if (isMobile) device.mobile=isMobile;
        if (hasVersion) device.version=hasVersion;
        if (isMacintosh) device.isMacintosh=true;
        if (isUbuntu) device.ubuntu=true;
        if (isRedHat) device.redhat=true;
        if (isLinux) device.linux=true;
        if (isTouch) device.touch=true;
        else device.mouse=true;
        fdjtLog("Device: %j",device);}
    
    (function(){
        /* global window: false */
        if ((typeof window !=="undefined")&&(window.navigator)&&
            (window.navigator.appVersion))
            identifyDevice();})();
})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/state.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true, sub: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.State=
    (function(){
        "use strict";
        var fdjtLog=fdjt.Log;
        var fdjtString=fdjt.String;

        function fdjtState(name,val,persist){
            if (arguments.length===1)
                return ((window.sessionStorage)&&(getSession(name)))||
                ((window.sessionStorage)&&(getLocal(name)))||
                getCookie(name);
            else if (persist)
                if (window.localStorage)
                    if (val) setLocal(name,val);
            else dropLocal(name);
            else {
                var domain=fdjtState.domain||location.hostname;
                var path=fdjtState.path||"/";
                var duration=fdjtState.duration||(3600*24*365*7);
                if (val) setCookie(name,val,duration,path,domain);
                else clearCookie(name,path,domain);}
            else if (val)
                if (window.sessionStorage) setSession(name,val);
            else setCookie(name,val);
            else if (window.sessionStorage) dropSession(name);
            else clearCookie(name);}
        fdjtState.domain=false;
        fdjtState.path=false;
        fdjtState.duration=false;

        /* Old-school cookies */

        function getCookie(name,parse){
            try {
                var cookies=document.cookie;
                var namepat=new RegExp("(^|(; ))"+name+"=","g");
                var pos=cookies.search(namepat);
                var valuestring;
                if (pos>=0) {
                    var start=cookies.indexOf('=',pos)+1;
                    var end=cookies.indexOf(';',start);
                    if (end>0) valuestring=cookies.slice(start,end);
                    else valuestring=cookies.slice(start);}
                else return false;
                if (parse)
                    return JSON.parse(decodeURIComponent(valuestring));
                else return decodeURIComponent(valuestring);}
            catch (ex) {
                return false;}}
        fdjtState.getCookie=getCookie;

        function setCookie(name,value,expires,path,domain){
            try {
                if (value) {
                    var valuestring=
                        ((typeof value === 'string') ? (value) :
                         (value.toJSON) ? (value.toJSON()) :
                         (value.toString) ? (value.toString()) : (value));
                    var cookietext=name+"="+encodeURIComponent(valuestring);
                    if (expires)
                        if (typeof(expires)==='string')
                            cookietext=cookietext+'; '+expires;
                    else if (expires.toGMTString)
                        cookietext=cookietext+"; expires="+expires.toGMTString();
                    else if (typeof(expires)==='number')
                        if (expires>0) {
                            var now=new Date();
                            now.setTime(now.getTime()+expires);
                            cookietext=cookietext+"; expires="+now.toGMTString;}
                    else cookietext=cookietext+"; expires=Sun 1 Jan 2000 00:00:00 UTC";
                    else {}
                    if (path) cookietext=cookietext+"; path="+path;
                    // This certainly doesn't work generally and might not work ever
                    if (domain) cookietext=cookietext+"; domain="+domain;
                    // fdjtTrace("Setting cookie %o cookietext=%o",name,cookietext);
                    document.cookie=cookietext;}
                else clearCookie(name,path,domain);}
            catch (ex) {
                fdjtLog.warn("Error setting cookie %s",name);}}
        fdjtState.setCookie=setCookie;
        
        function clearCookie(name,path,domain){
            try {
                var cookietext=encodeURIComponent(name)+
                    "=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
                if (path) cookietext=cookietext=cookietext+"; path="+path;
                if (domain) cookietext=cookietext=cookietext+"; domain="+domain;
                document.cookie=cookietext;}
            catch (ex) {
                fdjtLog.warn("Error clearing cookie %s: %s",
                             name,ex);}
            if (getCookie(name)) {
                var altcookietext=encodeURIComponent(name)+
                    "=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
                document.cookie=altcookietext;}}
        fdjtState.clearCookie=clearCookie;

        /* Session storage */

        function setSession(name,val,unparse){
            if (unparse) val=JSON.stringify(val);
            if (window.sessionStorage)
                window.sessionStorage[name]=val;
            else setCookie(name,val);}
        fdjtState.setSession=setSession;

        function getSession(name,parse){
            var val=((window.sessionStorage)?
                     (window.sessionStorage[name]):
                     (getCookie(name)));
            if (val)
                if (parse) return JSON.parse(val); else return val;
            else return false;}
        fdjtState.getSession=getSession;

        function existsSession(name){
            if (!(name)) throw { error: "bad name",name: name};
            else if (window.sessionStorage) {
                if (name instanceof RegExp) {
                    var storage=window.sessionStorage;
                    var i=0; var lim=storage.length;
                    while (i<lim) {
                        var key=storage.key(i++);
                        if (key.search(name)>=0) return true;}
                    return false;}
                else {
                    var val=window.sessionStorage[name];
                    if (typeof val === "undefined") return false;
                    else return true;}}
            else return false;}
        fdjtState.existsSession=existsSession;

        function dropSession(name){
            if (window.sessionStorage)
                return window.sessionStorage.removeItem(name);
            else clearCookie(name);}
        fdjtState.dropSession=dropSession;

        function clearSession(){
            if (window.sessionStorage) {
                var storage=window.localStorage;
                var i=0; var lim=storage.length;
                var keys=[];
                while (i<lim) keys.push(storage.key(i++));
                i=0; while (i<lim) storage.removeItem(keys[i++]);}}
        fdjtState.clearSession=clearSession;
        
        function listSession(name){
            var keys=[];
            if (typeof name === "string")
                name=new RegExp("^"+fdjtString.escapeRX(name),"g");
            if (window.sessionStorage) {
                var storage=window.sessionStorage;
                var i=0, lim=storage.length, key=false;
                if (!(name)) {
                    while (i<lim) keys.push(storage.key(i++));}
                else if (name instanceof RegExp) while (i<lim) {
                    key=storage.key(i++);
                    if (key.search(name)>=0) keys.push(key);}
                else {}}
            return keys;}
        fdjtState.listSession=listSession;

        /* Local storage (persists between sessions) */

        function setLocal(name,val,unparse){
            if (!(name)) throw { error: "bad name",name: name};
            if (typeof val === "undefined")
                throw { error: "undefined value", name: name};
            if (!(val)) {dropLocal(name); return;}
            if (unparse) val=JSON.stringify(val);
            if (window.localStorage) {
                if (name instanceof RegExp) {
                    var keys=[];
                    var storage=window.localStorage;
                    var i=0; var lim=storage.length;
                    while (i<lim) {
                        var key=storage.key(i++);
                        if (key.search(name)>=0) keys.push(key);}
                    i=0; lim=keys.length; while (i<lim) {
                        storage[keys[i++]]=val;}}
                else window.localStorage[name]=val;}}
        fdjtState.setLocal=setLocal;

        function getLocal(name,parse){
            if (!(name)) throw { error: "bad name",name: name};
            else if (window.localStorage) {
                if (name instanceof RegExp) {
                    var storage=window.localStorage;
                    var i=0; var lim=storage.length;
                    while (i<lim) {
                        var key=storage.key(i++);
                        if (key.search(name)>=0) {
                            return ((parse)?(JSON.parse(storage[key])):
                                    (storage[key]));}}
                    return false;}
                else {
                    var val=window.localStorage[name];
                    if (val)
                        if (parse) return JSON.parse(val); else return val;
                    else return false;}}
            else return false;}
        fdjtState.getLocal=getLocal;

        function pushLocal(name,val){
            if (!(name)) throw { error: "bad name",name: name};
            var fetched=window.localStorage[name], array=false;
            if (fetched) {
                array=JSON.parse(fetched);
                if (!(Array.isArray(array))) array=[array];
                if (array.indexOf(val)<0) array.push(val);
                else return false;}
            else array=[val];
            window.localStorage[name]=JSON.stringify(array);
            return true;}
        fdjtState.pushLocal=pushLocal;

        function removeLocal(name,val){
            if (!(name)) throw { error: "bad name",name: name};
            var fetched=window.localStorage[name];
            if (fetched) {
                var array=JSON.parse(fetched), loc;
                if (array===val) {
                    dropLocal(name); return;}
                else if (!(Array.isArray(array))) return;
                else loc=array.indexOf(val);
                if (loc<0) return; else array.splice(loc,1);
                window.localStorage[name]=JSON.stringify(array);}
            return true;}
        fdjtState.removeLocal=removeLocal;

        function existsLocal(name){
            if (!(name)) throw { error: "bad name",name: name};
            else if (window.localStorage) {
                if (name instanceof RegExp) {
                    var storage=window.localStorage;
                    var i=0; var lim=storage.length;
                    while (i<lim) {
                        var key=storage.key(i++);
                        if (key.search(name)>=0) return true;}
                    return false;}
                else {
                    var val=window.localStorage[name];
                    if (typeof val === "undefined") return false;
                    else return true;}}
            else return false;}
        fdjtState.existsLocal=existsLocal;

        function findLocal(name,val,parse){
            if (window.localStorage) {
                var result={};
                var storage=window.localStorage;
                var i=0; var lim=storage.length;
                while (i<lim) {
                    var key=storage.key(i++);
                    if ((!(name))||(key.search(name)>=0)) {
                        var v=storage[key];
                        if ((!(val))||(v.search(val)>=0)) {
                            if (parse) {
                                try {v=JSON.parse(v);} catch (ex) {}}
                            result[key]=v;}}}
                return result;}
            else return false;}
        fdjtState.findLocal=findLocal;

        function dropLocal(name){
            if (window.localStorage) {
                if (name instanceof RegExp) {
                    var drop=[];
                    var storage=window.localStorage;
                    var i=0; var lim=storage.length;
                    while (i<lim) {
                        var key=storage.key(i++);
                        if (key.search(name)>=0) drop.push(key);}
                    i=0; lim=drop.length; while (i<lim) {
                        storage.removeItem(drop[i++]);}}
                else return window.localStorage.removeItem(name);}
            else return false;}
        fdjtState.dropLocal=dropLocal;
        
        function listLocal(name){
            var keys=[];
            if (typeof name === "string")
                name=new RegExp("^"+fdjtString.escapeRX(name),"g");
            if (window.localStorage) {
                var storage=window.localStorage;
                var i=0, lim=storage.length, key=false;
                if (!(name)) {
                    while (i<lim) keys.push(storage.key(i++));}
                else if (name instanceof RegExp) while (i<lim) {
                    key=storage.key(i++);
                    if (key.search(name)>=0) keys.push(key);}
                else {}}
            return keys;}
        fdjtState.listLocal=listLocal;

        function clearLocal(){
            if (window.localStorage) {
                var storage=window.localStorage;
                var i=0; var lim=storage.length;
                var keys=[];
                while (i<lim) keys.push(storage.key(i++));
                i=0; while (i<lim) storage.removeItem(keys[i++]);}}
        fdjtState.clearLocal=clearLocal;

        /* Gets arguments from the query string */
        function getParam(from,name,multiple,matchcase,verbatim,start){
            var results=[];
            var ename=encodeURIComponent(name);
            var namepat=new RegExp("(&|^)"+ename+"(=|&|$)",
                                   ((matchcase)?"g":"gi"));
            start=from.search(namepat);
            while (start>=0) {
                // Skip over separator if non-initial
                var valstart=start+ename.length;
                var valstring=from.slice(valstart+1);
                var end=valstring.search(/(&|$)/g);
                if (from[valstart]==="=") {
                    if (end<=0) {
                        results.push("");
                        if (!(multiple)) break;}
                    else {
                        results.push(valstring.slice(0,end));
                        end=end+valstart+1;
                        if (!(multiple)) break;}}
                else if (multiple) 
                    results.push(from.slice(start,end));
                else if (verbatim) 
                    return from.slice(start,end);
                else return querydecode(from.slice(start,end));
                if (end>0) {
                    from=from.slice(end);
                    start=from.search(namepat);}}
            if (!(verbatim)) {
                var i=0; var lim=results.length;
                while (i<lim) {results[i]=querydecode(results[i]); i++;}}
            if (multiple) return results;
            else if (results.length)
                return results[0];
            else return false;}
        fdjtState.getParam=getParam;

        function getQuery(name,multiple,matchcase,verbatim){
            if (!(location.search))
                if (multiple) return [];
            else return false;
            var from=location.search;
            if (from[0]==="?") from=from.slice(1);
            return getParam(from,name,multiple,matchcase,verbatim);}
        fdjtState.getQuery=getQuery;
        
        function getHash(name,multiple,matchcase,verbatim){
            if (!(location.hash))
                if (multiple) return [];
            else return false;
            var from=location.hash;
            if (from[0]==="#") from=from.slice(1);
            return getParam(location.hash,name,multiple,matchcase,verbatim);}
        fdjtState.getHash=getHash;

        function querydecode(string){
            if (decodeURIComponent)
                return decodeURIComponent(string);
            else return string.replace
            (/%3A/gi,":").replace
            (/%2F/gi,"/").replace
            (/%3F/gi,"?").replace
            (/%3D/gi,"=").replace
            (/%20/gi," ").replace
            (/%40/gi,"@").replace
            (/%23/gi,"#");}

        function test_opt(pos,neg){
            var pospat=((pos)&&(new RegExp("\\b"+pos+"\\b")));
            var negpat=((neg)&&negative_opt_pat(neg));
            var i=2; while (i<arguments.length) {
                var arg=arguments[i++];
                if (!(arg)) continue;
                else if (typeof arg === 'string')
                    if ((pospat)&&(arg.search(pospat)>=0)) return true;
                else if ((negpat)&&(arg.search(negpat)>=0)) return false;
                else continue;
                else if (arg.length) {
                    var j=0; var len=arg.length;
                    while (j<len)
                        if ((pos)&&(arg[j]===pos)) return true;
                    else if ((neg)&&(arg[j]===neg)) return false;
                    else j++;
                    return false;}
                else continue;}
            return false;}
        fdjtState.testOption=test_opt;

        function negative_opt_pat(neg){
            if (!(neg)) return neg;
            else if (typeof neg === 'string')
                return (new RegExp("\\b"+neg+"\\b","gi"));
            else if (neg.length) {
                var rule="\\b(";
                var i=0; while (i<neg.length) {
                    var name=neg[i];
                    if (i>0) rule=rule+"|";
                    rule=rule+"("+name+")";
                    i++;}
                rule=rule+")\\b";
                return new RegExp(rule,"gi");}
            else return false;}

        fdjtState.argVec=function(argobj,start){
            var i=start||0;
            var result=new Array(argobj.length-i);
            while (i<argobj.length) {
                result[i-start]=argobj[i]; i++;}
            return result;};

        var zeros="000000000000000000000000000000000000000000000000000000000000000";
        function zeropad(string,len){
            if (string.length===len) return string;
            else if (string.length>len) return string.slice(0,len);
            else return zeros.slice(0,len-string.length)+string;}
        
        // This is a random nodeid used to generate UUIDs
        //  We use it because we can't access the MAC address
        var nodeid=
            zeropad(((Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)|0x01)).toString(16),
                    12);
        
        var clockid=Math.floor(Math.random()*16384); var msid=1;
        var last_time=new Date().getTime();
        
        fdjtState.getNodeID=function(){return nodeid;};
        fdjtState.setNodeID=function(arg){
            if (typeof arg==='number')
                nodeid=zeropad(arg.toString(16),12);
            else if (typeof arg === 'string')
                if (arg.search(/[^0123456789abcdefABCDEF]/)<0)
                    nodeid=zeropad(arg,12);
            else throw {error: 'invalid node id',value: arg};
            else throw {error: 'invalid node id',value: arg};};

        function getUUID(node){
            var now=new Date().getTime();
            if (now<last_time) {now=now*10000; clockid++;}
            else if (now===last_time)   now=now*10000+(msid++);
            else {now=now*10000; msid=1;}
            now=now+122192928000000000;
            if (!(node)) node=nodeid;
            var timestamp=now.toString(16); var tlen=timestamp.length;
            if (tlen<15) timestamp=zeros.slice(0,15-tlen)+timestamp;
            return timestamp.slice(7)+"-"+timestamp.slice(3,7)+
                "-1"+timestamp.slice(0,3)+
                "-"+(32768+(clockid%16384)).toString(16)+
                "-"+((node)?
                     ((typeof node === 'number')?
                      (zeropad(node.toString(16),12)):
                      (zeropad(node,12))):
                     (nodeid));}
        fdjtState.getUUID=getUUID;
        
        // Getting version information
        function versionInfo(){
            var s=navigator.userAgent; var result={};
            var start;
            while ((start=s.search(/\w+\/\d/g))>=0) {
                var slash=s.indexOf('/',start);
                var afterslash=s.slice(slash+1);
                var num_end=afterslash.search(/\W/);
                var numstring=afterslash.slice(0,num_end);
                try {
                    result[s.slice(start,slash)]=parseInt(numstring,10);}
                catch (ex) {
                    result[s.slice(start,slash)]=numstring;}
                s=afterslash.slice(num_end);}
            if (result['Chrome']) result.browser='Chrome';
            else if (result['Opera']) result.browser='Opera';
            else if (result['Safari']) result.browser='Safari';
            else if ((result['Safari'])&&(result['Mobile']))
                result.browser='MobileSafari';
            else if (result['Firefox']) result.browser='Firefox';
            else if ((result['Explorer'])||(result['IE'])||
                     (result['InternetExplorer'])||(result['MSIE']))
                result.browser='IE';
            else if (result['Mozilla']) result.browser='Mozilla';
            else result.browser='Browser';
            result.platform=navigator.platform||"Turing";
            return result;}
        fdjtState.versionInfo=versionInfo;

        function getStyleTag() {
            // This is a trick for making a tag value visible to Javascript from CSS
            // From: http://tech.particulate.me/javascript/2013/10/10/how-to-conveniently-check-for-responsive-breakpoints-in-javascript/
            var tag = window.getComputedStyle(document.body,':after').getPropertyValue('content');
            tag = tag.replace(/"/g,'');   // Firefox bugfix
            return tag;}
        // To use it, define:
        //    body:after { content: 'styletag'; }
        // in your CSS.  This is typically done inside the @media rules which define
        // adaptive design breakpoints
        fdjtState.getStyleTag=getStyleTag;

        function getURL(keepquery,keephash){
            var url=window.location.href;
            var hashpos=url.indexOf('#'), qpos=url.indexOf('?');
            var hash=((keephash)&&(hashpos>=0)&&(url.slice(hashpos+1)));
            var query=((keepquery)&&(qpos>=0)&&
                       ((hashpos>=0)?(url.slice(qpos+1,hashpos)):
                        (url.slice(qpos+1))));
            url=((qpos>=0)?(url.slice(0,qpos)):
                 (hashpos>=0)?(url.slice(0,hashpos)):
                 (url));
            return url+((query)?("?"+query):(""))+((hash)?("#"+hash):(""));}
        fdjtState.getURL=getURL;

        return fdjtState;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/dom.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));
var _fdjt_init;

fdjt.DOM=
    (function(){
        "use strict";
        var usenative=true;
        var fdjtString=fdjt.String;
        var fdjtLog=fdjt.Log;

        var css_selector_regex=/((^|[.#])[^.#\[\s]+)|(\[[^ \]=]+=[^\]]+\])|(\[[^ \]=]+\])/ig;

        function fdjtDOM(spec){
            var node;
            if (spec.nodeType) node=spec;
            else if ((typeof spec==='string')&&(spec[0]==='<'))  {
                var container=document.createDocumentFragment();
                // We could do template expansion here
                container.innerHTML=spec;
                var children=container.childNodes;
                if (children.length===1) return children[0];
                else return container;}
            else if ((typeof spec==='string')&&(spec[0]==='#')&&
                     (node=document.getElementById(spec.slice(1)))) {}
            else if (typeof spec==='string') {
                var elts=spec.match(css_selector_regex);
                if (!(elts)) {
                    fdjtLog.warn("bad CSS spec");
                    return false;}
                var classname=false;
                node=document.createElement(elts[0]);
                var i=1; var len=elts.length;
                while (i<len) {
                    var sel=elts[i++];
                    if (sel[0]==='#') node.id=sel.slice(1);
                    else if (sel[0]==='.')
                        if (classname) classname=classname+" "+sel.slice(1);
                    else classname=sel.slice(1);
                    else if (sel[0]==='[') {
                        var eqpos=sel.indexOf('=');
                        if (eqpos<0) {
                            node.setAttribute(
                                sel.slice(1,sel.length-1),
                                sel.slice(1,sel.length-1));}
                        else {
                            var val=sel.slice(eqpos+1,sel.length-1);
                            if (((val[0]==="'")&&(val[val.length-1]==="'"))||
                                ((val[0]==='"')&&(val[val.length-1]==='"')))
                                val=val.slice(1,val.length-1);
                            node.setAttribute(sel.slice(1,eqpos),val);}}
                    else {}}
                if (classname) node.className=classname;}
            else {
                node=document.createElement(spec.tagName||"span");
                for (var attrib in spec) {
                    if (attrib==="tagName") continue;
                    else node.setAttribute(attrib,spec[attrib]);}}
            domappend(node,arguments,1);
            return node;}

        fdjtDOM.useNative=function(flag) {
            if (typeof flag === 'undefined') return usenative;
            else usenative=flag;};
        
        fdjtDOM.clone=function(node){
            return node.cloneNode(true);};

        function getIE(){
            if (navigator.appName === 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent;
                var re  = new RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})");
                var rv;
                if (re.exec(ua) !== null)
                    rv = parseFloat( re.$1 );
                else rv=1;
                // Fails for non-whole numbers
                if (rv<=0) rv=1;
                return rv;}
            else return 0;}

        fdjtDOM.ie=getIE();
        fdjtDOM.iem=Math.floor(fdjtDOM.ie);

        function fdjtID(id) {
            return ((id)&&
                    ((document.getElementById(id))||
                     ((id[0]==='#')&&
                      (document.getElementById(id.slice(1))))));}
        fdjt.ID=fdjtID;

        function domappend(node,content,i) {
            if (content.nodeType) node.appendChild(content);
            else if (typeof content === 'string') 
                node.appendChild(document.createTextNode(content));
            else if (content.toDOM)
                return domappend(node,content.toDOM());
            else if (content.toHTML)
                return domappend(node,content.toHTML());
            else if ((content.length)&&((!(i))||(i<content.length))) {
                var frag=(((window.DocumentFragment)&&
                           (node instanceof window.DocumentFragment))?
                          (node):(document.createDocumentFragment()));
                // We copy node lists because they're prone to change
                // underneath us as we're moving DOM nodes around.
                var elts=((window.NodeList)&&(content instanceof window.NodeList))?
                    (TOA(content)):(content);
                var len=elts.length; 
                if (typeof i === 'undefined') i=0;
                while (i<len) {
                    var elt=elts[i++];
                    if (!(elt)) {}
                    else if (typeof elt === 'string')
                        frag.appendChild(document.createTextNode(elt));
                    else if (elt.nodeType) frag.appendChild(elt);
                    else if (elt.length)
                        domappend(frag,elt,0);
                    else if (elt.toDOM)
                        domappend(frag,elt.toDOM());
                    else if (elt.toHTML)
                        domappend(frag,elt.toHTML());
                    else if (elt.toString)
                        frag.appendChild(document.createTextNode(
                            elt.toString()));
                    else frag.appendChild(document.createTextNode(""+elt));}
                if (node!==frag) node.appendChild(frag);}
            else if (content.length) {}
            else node.appendChild(document.createTextNode(""+content));
            return node;}
        function dominsert(before,content,i) {
            var node=before.parentNode;
            if ((content.nodeType)&&(content===before))
                return;
            else if (content.nodeType)
                node.insertBefore(content,before);
            else if (typeof content === 'string') 
                node.insertBefore(document.createTextNode(content),before);
            else if (content.toDOM)
                return dominsert(before,content.toDOM());
            else if (content.toHTML)
                return dominsert(before,node,content.toHTML());
            else if (content.length-i>1) {
                var frag=(((window.documentFragment)&&(node instanceof window.DocumentFragment))?
                          (node):(document.createDocumentFragment()));
                domappend(frag,content,i);
                node.insertBefore(frag,before);
                return before;}
            else if (content.length) {
                var c=content[i];
                if (c===before) return;
                else node.insertBefore(c,before);}
            else node.insertBefore(document.createTextNode(""+content),before);
            return node;}
        fdjtDOM.appendArray=domappend;
        
        function toArray(arg) {
            return Array.prototype.slice.call(arg);}
        fdjtDOM.toArray=toArray;
        function extendArray(result,arg) {
            var i=0; var lim=arg.length;
            while (i<lim) {result.push(arg[i]); i++;}
            return result;}
        function TOA(arg,start) {
            if ((arg.constructor === Array)||
                (arg instanceof Array)) {
                if (start) return arg.slice(start);
                else return arg;}
            else if (start)
                return Array.prototype.slice.call(arg,start||0);
            else return Array.prototype.slice.call(arg,start||0);}
        fdjtDOM.Array=TOA;
        fdjtDOM.slice=TOA;

        /* Wrapping children */
        function wrapChildren(node,spec){
            if (!(spec)) spec="div.fdjtwrapper";
            var wrapper=getFirstChild(node,spec);
            if ((wrapper)&&(wrapper.nodeType)&&
                (wrapper.parentNode===node))
                return wrapper;
            else wrapper=fdjtDOM(spec,toArray(node.childNodes));
            node.appendChild(wrapper);
            return wrapper;}
        fdjtDOM.wrapChildren=wrapChildren;
        function unwrapChildren(nodes,cxt){
            if (typeof nodes === "string") 
                nodes=((cxt)?(fdjt.DOM.getChildren(cxt,nodes)):
                       (fdjt.DOM.$(nodes)));
            else if (nodes.nodeType)
                nodes=[nodes];
            else {}
            var i=0, lim=nodes.length; while (i<lim) {
                var node=nodes[i++];
                var frag=document.createDocumentFragment();
                domappend(frag,toArray(node.childNodes));
                node.parentNode.replaceChild(frag,node);}}
        fdjtDOM.unwrapChildren=unwrapChildren;

        /* Utility patterns and functions */

        function parsePX(arg,dflt){
            if (typeof dflt === 'undefined') dflt=0;
            if (arg===0) return 0;
            else if (!(arg)) return dflt;
            else if (arg==="none") return dflt;
            else if (arg==="auto") return dflt;
            else if (typeof arg === 'number') return arg;
            else if (typeof arg === 'string') {
                var len=arg.length; var num=false;
                if ((len>2)&&(arg[len-1]==='x')&&(arg[len-2]==='p'))
                    num=parseInt(arg.slice(0,-2),10);
                else num=parseInt(arg,10);
                if (num===0) return 0;
                else if (isNaN(num)) return dflt;
                else if (typeof num === 'number') return num;
                else return dflt;}
            else return false;}
        fdjtDOM.parsePX=parsePX;

        function getLineHeight(node,style){
            if (!(style)) style=getStyle(node);
            var lh=style.lineHeight, fs=style.fontSize;
            if (lh==="normal") return parsePX(fs);
            else if (lh.search(/px$/)>0) return parsePX(lh);
            else if (lh.search(/%$/)>0) 
                return (parseFloat(lh.slice(0,-1))/100)*(parsePX(fs));
            else return parsePX(fs);}
        fdjtDOM.getLineHeight=getLineHeight;

        var whitespace_pat=/(\s)+/;
        var trimspace_pat=/^(\s)+|(\s)+$/;
        var classpats={};
        function classPat(name){
            var rx=new RegExp("\\b"+name+"\\b","g");
            classpats[name]=rx;
            return rx;}

        function string_trim(string){
            var start=string.search(/\S/); var end=string.search(/\s+$/g);
            if ((start===0) && (end<0)) return string;
            else return string.slice(start,end);}

        function nodeString(node){
            if (node.nodeType===3) 
                return "<'"+node.value+"'>";
            else if (node.nodeType===1) {
                var output="<"+node.tagName;
                if (node.id) output=output+"#"+node.id;
                if (node.tagName==='input') {
                    output=output+"[type="+node.type+"]";
                    output=output+"[name="+node.name+"]";}
                else if (node.tagName==='textarea')
                    output=output+"[name="+node.name+"]";
                else if (node.tagName==='img') {
                    if (node.alt) output=output+"[alt="+node.alt+"]";
                    else if (node.src) output=output+"[src="+node.src+"]";}
                else {}
                if (typeof node.className === "string")
                    output=output+"."+node.className.replace(/\s+/g,'.');
                return output+">";}
            else return node.toString();}
        fdjtDOM.nodeString=nodeString;
        
        /* Another way of making DOM elements which uses templates */

        function make(spec,content,data,init){
            var dom=fdjtDOM(spec);
            if (!(init)) init=data;
            if (data) content=fdjt.Template(content,data);
            if ((init.id)&&(!(dom.id))) dom.id=init.id;
            if ((init.title)&&(!(dom.title))) dom.title=init.title;
            if ((init.name)&&(!(dom.name))) dom.name=init.name;
            if ((init.href)&&(!(dom.href))) dom.href=init.href;
            if ((init.value)&&(!(dom.value))) dom.value=init.value;
            if ((init.src)&&(!(dom.src))) dom.src=init.src;
            if ((init.alt)&&(!(dom.alt))) dom.alt=init.alt;
            addListeners(dom,init);
            return dom;}
        fdjtDOM.make=make;

        /* Getting "values" of elements */
        function getElementValues(elt,spec,parse,multiple){
            var candidates=[];
            if (spec.search(/(\.|#|\[|,)/g)>=0) 
                candidates=getChildren(elt,spec);
            else if (elt.getElementsByClassName)
                candidates=elt.getElementsByClassName(spec);
            else candidates=getChildren();
            if (candidates.length===0) {
                if (multiple) return [];
                else return false;}
            else if (multiple) {
                var values=[];
                var i=0, lim=multiple.length;
                while (i<lim) {
                    var txt=candidates[i++].innerText;
                    if (parse) values.push(JSON.parse(txt));
                    else values.push(txt);}
                return values;}
            else if (parse)
                return JSON.parse(candidates[0].innerText);
            else return candidates[0].innerText;}
        fdjtDOM.getElementValues=getElementValues;
        function getElementValue(elt,spec,parse){
            return getElementValues(elt,spec,parse,false);}
        fdjtDOM.getElementValue=getElementValue;

        /* Simple class/attrib manipulation functions */

        function hasClass(elt,classname,attrib){
            if (!(elt)) return;
            else if (typeof elt === 'string') {
                if (!(elt=document.getElementById(elt)))
                    return;}
            var classinfo=((attrib) ? (elt.getAttribute(attrib)||"") :
                           (elt.className));
            if ((typeof classinfo !== "string")||(classinfo==="")) return false;
            else if (classname===true) return true;
            else if (classinfo===classname) return true;
            else if (typeof classname === 'string')
                if (classinfo.indexOf(' ')<0) return false;
            else classname=classpats[classname]||classPat(classname);
            else {}
            if (classinfo.search(classname)>=0) return true;
            else return false;}
        fdjtDOM.hasClass=hasClass;

        function addClass(elt,classname,attrib){
            if (!(elt)) return;
            else if (!(classname))
                return;
            else if (typeof elt === 'string') {
                if (!(elt=document.getElementById(elt)))
                    return;}
            else if ((window.NodeList)&&(elt instanceof window.NodeList))
                return addClass(TOA(elt),classname,attrib);
            else if ((elt.length)&&(!(elt.nodeType))) { // (assume array)
                var elts=TOA(elt);
                var i=0; var lim=elts.length;
                while (i<lim) addClass(elts[i++],classname,attrib||false);
                return;}
            else if ((!(attrib))&&(elt.classList)&&
                     (typeof classname ==="string")) {
                elt.classList.add(classname);
                return;}
            var classinfo=
                (((attrib) ? (elt.getAttribute(attrib)||"") :(elt.className))||null);
            if ((classinfo)&&(typeof classinfo !== "string")) {
                fdjtLog.warn("Non string classname for %o",elt);
                return false;}
            else if (!(classinfo)) {
                elt.className=classname; return true;}
            var class_regex=classpats[classname]||classPat(classname);
            var newinfo=classinfo;
            if (classinfo===classname) return false;
            else if (classinfo.search(class_regex)>=0) return false;
            else newinfo=classname+" "+classinfo;
            if (attrib) {
                elt.setAttribute(attrib,newinfo);
                // This sometimes trigger a CSS update that doesn't happen otherwise
                elt.className=elt.className;}
            else elt.className=newinfo;
            return true;}
        fdjtDOM.addClass=addClass;
        fdjtDOM.aC=addClass;

        fdjtDOM.classAdder=function(elt,classname){
            return function() {
                if (elt) addClass(elt,classname);};};

        function dropClass(elt,classname,attrib,keep){
            if (!(elt)) return;
            else if (typeof elt === 'string') {
                if (!(elt=document.getElementById(elt)))
                    return;}
            else if ((window.NodeList)&&(elt instanceof window.NodeList))
                return dropClass(TOA(elt),classname,attrib);
            else if ((elt.length)&&(!(elt.nodeType))) {
                var elts=TOA(elt);
                var i=0; var lim=elts.length;
                while (i<lim) dropClass(elts[i++],classname,attrib||false);
                return;}
            else if ((!(attrib))&&(elt.classList)&&
                     (typeof classname ==="string")) {
                elt.classList.remove(classname);
                return;}
            var classinfo=
                (((attrib) ? (elt.getAttribute(attrib)||"") :(elt.className))||null);
            if ((typeof classinfo !== "string")||(classinfo===""))
                return false;
            var class_regex=
                ((typeof classname === 'string')?
                 (classpats[classname]||classPat(classname)):
                 classname);
            var newinfo=classinfo;
            if (classinfo===classname) 
                newinfo="";
            else if (classinfo.search(class_regex)>=0) 
                newinfo=classinfo.replace(class_regex,"");
            else return false;
            if (newinfo)
                newinfo=newinfo.
                replace(whitespace_pat," ").
                replace(trimspace_pat,"");
            if (attrib) {
                if (newinfo) {
                    elt.setAttribute(attrib,newinfo);
                    elt.className=elt.className;}
                else if (!(keep)) {
                    elt.removeAttribute(attrib);
                    elt.className=elt.className;}
                else {}}
            else if (newinfo)
                elt.className=newinfo;
            else if (!(keep))
                elt.className="";
            else elt.className="";
            return true;}
        fdjtDOM.dropClass=dropClass;
        fdjtDOM.dC=dropClass;

        fdjtDOM.classDropper=function(elt,classname){
            return function() {
                if (elt) dropClass(elt,classname);};};

        function swapClass(elt,drop,add,attrib) {
            dropClass(elt,drop,attrib); addClass(elt,add,attrib);}
        fdjtDOM.swapClass=swapClass;

        function setClass(elt,classname,add){
            if (typeof elt === 'string') elt=document.getElementById(elt);
            if (add) addClass(elt,classname);
            else dropClass(elt,classname);}
        fdjtDOM.setClass=setClass;

        function toggleClass(elt,classname,attrib,keep){
            if (typeof elt === 'string') elt=document.getElementById(elt);
            else if ((window.NodeList)&&(elt instanceof window.NodeList))
                return toggleClass(TOA(elt),classname,attrib);
            else if ((elt.length)&&(!(elt.nodeType))) {
                var elts=TOA(elt);
                var i=0; var lim=elts.length;
                while (i<lim) toggleClass(elts[i++],classname,attrib||false);
                return;}
            else if ((!(attrib))&&(elt.classList)&&
                     (typeof classname ==="string")) {
                elt.classList.toggle(classname);
                return;}
            var classinfo=
                (((attrib) ? (elt.getAttribute(attrib)||"") :
                  (elt.className))||null);
            if ((typeof classinfo !== "string")||(classinfo==="")) {
                if (attrib) elt.setAttribute(attrib,classname);
                else elt.className=classname;
                return true;}
            var class_regex=
                ((typeof classname === 'string')?
                 (classpats[classname]||classPat(classname)):
                 classname);
            var newinfo=classinfo;
            if (classinfo===classname) 
                newinfo="";
            else if (classinfo.search(class_regex)>=0) 
                newinfo=classinfo.replace(class_regex,"");
            else {
                if (attrib)
                    elt.setAttribute(attrib,classinfo+' '+classname);
                else elt.className=classinfo+' '+classname;
                return true;}
            if (newinfo)
                newinfo=newinfo.replace(whitespace_pat," ").replace(
                    trimspace_pat,"");
            if (attrib) {
                if (newinfo) {
                    elt.setAttribute(attrib,newinfo);
                    elt.className=elt.className;}
                else if (!(keep)) {
                    elt.removeAttribute(attrib);
                    elt.className=elt.className;}
                else {}}
            else elt.className=newinfo;
            return false;}
        fdjtDOM.toggleClass=toggleClass;
        fdjtDOM.tC=toggleClass;
        
        function toggleParent(node,spec,classname,attrib,keep){
            var parent=getParent(node,spec);
            if (parent) toggleClass(parent,classname,attrib,keep);}
        fdjtDOM.toggleParent=toggleParent;
        fdjtDOM.tP=toggleParent;

        function isTextInput(target){
            return (((target.tagName==='INPUT')&&
                     (target.type.search(/text|url|email|search|password/i)===0))||
                    (target.tagName==='TEXTAREA'));}
        fdjtDOM.isTextInput=isTextInput;
        
        /* Simple CSS selectors */

        var selectors={};

        function Selector(spec,tagcs) {
            var i, lim;
            if (!(spec)) return this; // just cons with type
            else if (selectors[spec]) return selectors[spec]; // check cache
            else if (!(this instanceof Selector))
                // handle case of the forgotten 'new'
                return Selector.call(new Selector(),spec);
            if ((Array.isArray(spec))||
                ((typeof spec === "string")&&(spec.indexOf(',')>0))) {
                // create compound selectors
                var compound=[], specs=[];
                if (typeof spec === "string")
                    specs=spec.split(',');
                else {
                    var j=0, jlim=spec.length; while (j<jlim) {
                        if (typeof spec[j] !== "string") j++;
                        else if (spec[j].indexOf(',')>=0)
                            specs=specs.concat(spec[j++].split(','));
                        else specs.push(spec[j++]);}}
                i=0; lim=specs.length;
                while (i<lim) {
                    var sub=string_trim(specs[i++]);
                    var sel=new Selector(sub);
                    if (sel) compound.push(sel);}
                this.compound=compound;
                selectors[spec]=this;
                if (typeof spec === "string") this.spec=spec;
                else this.spec=specs.join(",");
                return this;}
            // Otherwise, parse and set up this
            var elts=spec.match(css_selector_regex);
            var classes=[]; var classnames=[]; var attribs=false;
            if (!(elts))
                fdjtLog.warn("Couldn't parse spec %s",spec);
            if (elts) {
                i=0; lim=elts.length;
                if (!((elts[0][0]==='.')||(elts[0][0]==='#')||
                      (elts[0][0]==='['))) {
                    this.tag=((tagcs)?(elts[0]):(elts[0].toUpperCase()));
                    i=1;}
                while (i<lim)
                    if (elts[i][0]==='#') this.id=elts[i++].slice(1);
                else if (elts[i][0]==='.') {
                    classnames.push(elts[i].slice(1));
                    classes.push(classPat(elts[i++].slice(1)));}
                else if (elts[i][0]==='[') {
                    var aelts=elts[i++]; var eltsend=aelts.length-1;
                    if (!(attribs)) attribs={};
                    var eqpos=aelts.indexOf('=');
                    if (eqpos<0)
                        attribs[aelts.slice(1,eltsend)]=true;
                    else if (aelts[eqpos+1]==='~') 
                        attribs[aelts.slice(1,eqpos)]=
                        classPat(aelts.slice(eqpos+2,eltsend));
                    else attribs[aelts.slice(1,eqpos)]=
                        aelts.slice(eqpos+1,eltsend);}
                else fdjtLog.uhoh("weird elts %o",elts[i++]);}
            if (classes.length) {
                this.classes=classes; this.classnames=classnames;}
            if (attribs) this.attribs=attribs;
            this.rank=[0,((this.id)?(1):(0)),
                       classnames.length+attribs.length,1];
            selectors[spec]=this;
            this.spec=spec;
            return this;}
        Selector.prototype.match=function(elt){
            if (elt.matches) 
                return elt.matches(this.spec);
            else if (elt.matchesSelector)
                return elt.matchesSelector(this.spec);
            var i, lim;
            if (this.compound) {
                var compound=this.compound; i=0; lim=compound.length;
                while (i<lim) if (compound[i++].match(elt)) return true;
                return false;} 
            if ((this.tag)&&(this.tag!==elt.tagName)) return false;
            else if ((this.id)&&(this.id!==elt.id)) return false;
            if (this.classes)
                if (typeof elt.className === "string") {
                    var classname=elt.className; var classes=this.classes;
                    i=0; lim=classes.length;
                    while (i<lim)
                        if (classname.search(classes[i++])<0)
                            return false;}
            else return false;
            if (this.attribs) {
                var attribs=this.attribs;
                for (var name in attribs)
                    if (attribs.hasOwnProperty(name)) {
                        var val=elt.getAttribute(name);
                        if (!(val)) return false;
                        var need=this[name];
                        if (need===true) {}
                        else if (typeof need === 'string') {
                            if (need!==val) return false;}
                        else if (val.search(need)<0) return false;}}
            return true;};
        Selector.prototype.find=function(elt,results){
            var probe, i, lim;
            if (!(results)) results=[];
            if (this.compound) {
                var compound=this.compound;
                i=0; lim=compound.length;
                while (i<lim) compound[i++].find(elt,results);
                return results;}
            if (this.id) {
                probe=document.getElementById(this.id);
                if (!(probe)) return results;
                else if (this.match(probe)) {
                    results.push(probe); return results;}
                else return results;}
            var candidates=[];
            var classnames=this.classnames; var attribs=this.attribs;
            if (this.classes) 
                if (elt.getElementsByClassName)
                    candidates=elt.getElementsByClassName(classnames[0]);
            else gatherByClass(elt,this.classes[0],candidates);
            else if ((this.tag)&&(elt.getElementsByTagName))
                candidates=elt.getElementsByTagName(this.tag);
            else if (this.attribs) {
                attribs=this.attribs;
                for (var name in attribs)
                    if (attribs.hasOwnProperty(name)) {
                        gatherByAttrib(elt,name,attribs[name],candidates);
                        break;}}
            else if (this.tag) {
                gatherByTag(elt,this.tag,candidates);}
            else {}
            if (candidates.length===0) return candidates;
            if (((this.tag)&&(!(this.classes))&&(!(this.attribs)))||
                ((!(this.tag))&&(this.classes)&&(this.classes.length===1)&&
                 (!(this.attribs))))
                // When there's only one test, don't bother filtering
                if (results.length) return extendArray(results,candidates);
            else if (candidates instanceof Array)
                return candidates;
            else return toArray(candidates);
            i=0; lim=candidates.length;
            while (i<lim) {
                var candidate=candidates[i++];
                if (this.match(candidate)) results.push(candidate);}
            return results;};
        fdjtDOM.Selector=Selector;
        fdjtDOM.sel=function(spec){
            if (!(spec)) return false;
            else if (spec instanceof Selector) return spec;
            else if (spec instanceof Array) {
                if (spec.length)
                    return new Selector(spec.join(","));
                else return false;}
            else if (typeof spec === 'string')
                return new Selector(spec);
            else {
                fdjtLog.warn("Non selector spec: %o",spec);
                return false;}};

        function gatherByClass(node,pat,results){
            if (node.nodeType===1) {
                var classname=node.className;
                if ((typeof classname === "string")&&(classname.search(pat)>=0))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim) gatherByClass(children[i++],pat,results);}}}
        function gatherByTag(node,tag,results){
            if (node.nodeType===1) {
                if ((typeof tag === "string")?
                    (node.tagName.toLowerString()===tag):
                    ((tag instanceof RegExp)&&(tag.match(node.tagName))))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim) gatherByTag(children[i++],tag,results);}}}
        function gatherByAttrib(node,attrib,val,results){
            if (node.nodeType===1) {
                if ((node.getAttribute(attrib))&&
                    ((typeof val === 'string')?
                     (node.getAttribute(attrib)===val):
                     (node.getAttribute(attrib).search(val)>=0)))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim) gatherByAttrib(children[i++],attrib,val,results);}}}
        
        function gather_children(node,pat,attrib,results){
            if (!(attrib)) gatherByClass(node,pat,results);
            else if (attrib==='class') gatherByClass(node,pat,results);
            else if (attrib==='tagName') gatherByTag(node,pat,results);
            else gatherByAttrib(node,attrib,pat,results);}

        /* Real simple DOM search */

        function getParent(elt,parent){
            if (typeof elt === 'string') {
                if (elt[0]==='#')
                    elt=document.getElementById(elt.slice(1));
                else elt=document.getElementById(elt);}
            if (!(elt)) return false;
            else if (!(parent)) return false;
            else if (parent.nodeType) {
                while (elt) {
                    if (elt===parent) return parent;
                    else elt=elt.parentNode;}
                return false;}
            else if (typeof parent === 'function') {
                while (elt) {
                    if (parent(elt)) return elt;
                    else elt=elt.parentNode;}
                return false;}
            else if (parent instanceof Selector) {
                while (elt) {
                    if (elt.nodeType!==1) elt=elt.parentNode;
                    else if (parent.match(elt)) return elt;
                    else elt=elt.parentNode;}
                return false;}
            else if (parent instanceof RegExp) {
                while (elt) {
                    if (elt.nodeType!==1) elt=elt.parentNode;
                    else if ((elt.className)&&(parent.test(elt.className)))
                        return elt;
                    else elt=elt.parentNode;}
                return false;}
            else if (typeof parent === 'string')
                return getParent(elt,new Selector(parent));
            else throw { error: 'invalid parent spec'};}
        fdjtDOM.getParent=getParent;
        fdjtDOM.hasParent=getParent;
        fdjtDOM.$P=getParent;
        fdjtDOM.inherits=function(node,spec) {
            var sel=new Selector(spec);
            return ((sel.match(node))?(node):(getParent(node,sel)));};

        function getChildNodes(node){
            if (node.nodeType!==1) return [];
            else if (!(node.childNodes)) return [];
            else return toArray(node.childNodes);}
        fdjtDOM.getChildNodes=getChildNodes;

        function getChildren(node,classname,attrib,results){
            if (typeof node === "string") node=fdjtID(node);
            if (!(node)) return [];
            if (!(results)) results=[]; 
            if (!(attrib)) {
                if (typeof classname === 'function')
                    filter_children(node,classname,results);
                else if (classname instanceof RegExp)
                    regexp_filter_children(node,classname,results);
                else if (classname instanceof Selector)
                    return classname.find(node,results);
                else if (typeof classname === 'string') {
                    if ((usenative) && (node.querySelectorAll))
                        return node.querySelectorAll(classname);
                    else return getChildren(
                        node,new Selector(classname),false,results);}
                else if (classname.length) {
                    var i=0, lim=classname.length;
                    while (i<lim)
                        getChildren(node,classname[i++],attrib,results);}
                else {}}
            else if (typeof attrib !== 'string')
                throw { error: 'bad selector arg', selector: classname};
            else gather_children(node,classname,attrib||false,results);
            return results;}
        fdjtDOM.getChildren=getChildren;
        fdjt.$=fdjtDOM.$=function(spec,root){
            return toArray(getChildren(root||document,spec));};
        function getFirstChild(elt,spec){
            var children=getChildren(elt,spec);
            if (children.length) return children[0]; else return false;}
        fdjt.$1=fdjtDOM.$1=fdjtDOM.getChild=fdjtDOM.getFirstChild=getFirstChild;

        function filter_children(node,filter,results){
            if (node.nodeType===1) {
                if (filter(node)) results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim) filter_children(children[i++],filter,results);}}}

        function regexp_filter_children(node,rx,results){
            if (node.nodeType===1) {
                var classname=node.className;
                if ((typeof classname === "string")&&(classname.search(rx)>=0))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim)
                        regexp_filter_children(children[i++],rx,results);}}}

        fdjtDOM.getAttrib=function(elt,attrib,ns){
            var probe;
            if ((ns)&&(elt.getAttributeByNS))
                probe=elt.getAttributeNS(attrib,ns);
            if (probe) return probe;
            else return elt.getAttribute(attrib)||
                elt.getAttribute("data-"+attrib);};

        fdjtDOM.findAttrib=function(scan,attrib,ns){
            var dattrib="data-"+attrib;
            while (scan) {
                if ((ns)&&(scan.getAttributeNS)&&
                    (scan.getAttributeNS(attrib,ns)))
                    return scan.getAttributeNS(attrib,ns);
                else if (scan.getAttribute) {
                    if (scan.getAttribute(attrib))
                        return scan.getAttribute(attrib);
                    else if (scan.getAttribute(dattrib))
                        return scan.getAttribute(dattrib);
                    else scan=scan.parentNode;}
                else scan=scan.parentNode;}
            return false;};
        
        /* First and last elements */
        function getFirstElement(node){
            if (node.firstElementChild) return node.firstElementChild;
            else if ((node.children)&&(node.children.length))
                return node.children[0];
            else return false;}
        fdjtDOM.getFirstElement=getFirstElement;
        function getLastElement(node){
            if (node.lastElementChild) return node.lastElementChild;
            else if ((node.children)&&(node.children.length))
                return node.children[node.children.length-1];
            else return false;}
        fdjtDOM.getLastElement=getLastElement;
        
        /* Manipulating the DOM */

        fdjtDOM.replace=function(existing,replacement,leaveids){
            var cur=existing;
            if (typeof existing === 'string')
                if (existing[0]==='#')
                    cur=document.getElementById(existing.slice(1));
            else cur=document.getElementById(existing);
            if (cur) {
                cur.parentNode.replaceChild(replacement,cur);
                if (!(leaveids)) {
                    if ((cur.id)&&(!(replacement.id)))
                        replacement.id=cur.id;}}
            else fdjtLog.uhoh("Can't find %o to replace it with %o",
                              existing,replacement);};
        function remove_node(node){
            if (node instanceof Array) {
                var i=0; var lim=node.length;
                while (i<lim) remove_node(node[i++]);
                return;}
            var cur=node;
            if (typeof node === 'string') {
                if (node[0]==='#') cur=document.getElementById(node.slice(1));
                else cur=document.getElementById(node);}
            if ((cur)&&(cur.parentNode))
                cur.parentNode.removeChild(cur);
            else if (cur)
                fdjtLog.uhoh("Looks like %o has already been removed (no parent)",cur);
            else fdjtLog.uhoh("Can't find %o to remove it",node);}
        fdjtDOM.remove=remove_node;
        
        function removeChildren(node){
            var children=node.childNodes, n=children.length-1;
            while (n>=0) node.removeChild(children[n--]);}
        fdjtDOM.removeChildren=removeChildren;

        fdjtDOM.append=function (node) {
            if (typeof node === 'string') node=document.getElementById(node);
            domappend(node,arguments,1);};
        fdjtDOM.prepend=function (node) {
            if (typeof node === 'string') node=document.getElementById(node);
            if (node.firstChild)
                dominsert(node.firstChild,arguments,1);
            else domappend(node,arguments,1);};

        fdjtDOM.insertBefore=function (before) {
            if (typeof before === 'string')
                before=document.getElementById(before);
            dominsert(before,arguments,1);};
        fdjtDOM.insertAfter=function (after) {
            if (typeof after === 'string')
                after=document.getElementById(after);
            if (after.nextSibling)
                dominsert(after.nextSibling,arguments,1);
            else domappend(after.parentNode,arguments,1);};
        
        /* DOM construction shortcuts */

        function tag_spec(spec,tag){
            if (!(spec)) return tag;
            else if (typeof spec === 'string') {
                var wordstart=spec.search(/\w/g);
                var puncstart=spec.search(/\W/g);
                if (puncstart<0) return tag+"."+spec;
                else if (wordstart!==0) return tag+spec;
                return spec;}
            else if (spec.tagName) return spec;
            else {
                spec.tagName=tag;
                return spec;}}

        fdjtDOM.Input=function(spec,name,value,title){
            if (spec.search(/\w/)!==0) spec='INPUT'+spec;
            var node=fdjtDOM(spec);
            node.name=name;
            if (value) node.value=value;
            if (title) node.title=title;
            return node;};
        fdjtDOM.Checkbox=function(name,value,checked){
            var node=fdjtDOM("INPUT");
            node.type="checkbox";
            node.name=name;
            if (value) node.value=value;
            if (checked) node.checked=true;
            else node.checked=false;
            return node;};
        fdjtDOM.Anchor=function(href,spec){
            spec=tag_spec(spec,"A");
            var node=fdjtDOM(spec); node.href=href;
            domappend(node,arguments,2);
            return node;};
        fdjtDOM.Image=function(src,spec,alt,title){
            spec=tag_spec(spec,"IMG");
            var node=fdjtDOM(spec); node.src=src;
            if (alt) node.alt=alt;
            if (title) node.title=title;
            domappend(node,arguments,4);
            return node;};

        function getInputs(root,name,type){
            var results=[];
            if (typeof root === 'string') {
                var root_elt=document.getElementById(root);
                if (!(root_elt)) fdjtLog.warn("Couldn't resolve %s to an object",root);
                root=root_elt;}
            if (!(root)) return results;
            var inputs=root.getElementsByTagName('input');
            var i=0; var lim=inputs.length;
            while (i<lim) {
                if (((!(name))||(inputs[i].name===name))&&
                    ((!(type))||(inputs[i].type===type)))
                    results.push(inputs[i++]); 
                else i++;}
            if ((!type)||(type==='textarea')||(type==='text')) {
                inputs=root.getElementsByTagName('textarea');
                i=0; lim=inputs.length;
                while (i<lim) {
                    if (((!(name))||(inputs[i].name===name))&&
                        ((!(type))||(inputs[i].type===type)))
                        results.push(inputs[i++]); 
                    else i++;}}
            if ((!type)||(type==='button')||(type==='submit')) {
                inputs=root.getElementsByTagName('button');
                i=0; lim=inputs.length;
                while (i<lim) {
                    if (((!(name))||(inputs[i].name===name))&&
                        ((!(type))||(inputs[i].type===type)))
                        results.push(inputs[i++]); 
                    else i++;}}
            if ((!type)||(type==='select')) {
                inputs=root.getElementsByTagName('select');
                i=0; lim=inputs.length;
                while (i<lim) {
                    if ((!(name))||(inputs[i].name===name))
                        results.push(inputs[i++]); 
                    else i++;}}
            return results;}

        fdjtDOM.getInputs=getInputs;
        fdjtDOM.getInput=function(root,name,type){
            var results=getInputs(root,name||false,type||false);
            if ((results)&&(results.length===1))
                return results[0];
            else if ((results)&&(results.length)) {
                fdjtLog.warn(
                    "Ambiguous input reference name=%o type=%o under %o",
                    name,type,root);
                return results[0];}
            else return false;};
        
        function getInputValues(root,name){
            var results=[];
            var inputs=root.getElementsByTagName('input');
            var i=0; var lim=inputs.length;
            while (i<lim) {
                var input=inputs[i++];
                if (input.name!==name) continue;
                if ((input.type==='checkbox')||(input.type==='radio')) {
                    if (!(input.checked)) continue;}
                results.push(input.value);}
            return results;}
        fdjtDOM.getInputValues=getInputValues;
        function getInputValue(root,name,n){
            var r=0;
            var inputs=root.getElementsByTagName('input');
            var i=0; var lim=inputs.length;
            while (i<lim) {
                var input=inputs[i++];
                if (input.disabled) continue;
                else if (input.name!==name) continue;
                else if ((input.type==='checkbox')||(input.type==='radio')) {
                    if (!(input.checked)) continue;}
                if (!(n)) return input.value;
                else if (r===n) return input.value;
                else r++;}
            return false;}
        fdjtDOM.getInputValue=getInputValue;

        function getInputsFor(root,name,value){
            if (typeof root === 'string')
                root=document.getElementById(root);
            if (!(root)) return [];
            var results=[];
            var inputs=root.getElementsByTagName('input');
            var i=0; var lim=inputs.length;
            while (i<lim) {
                var input=inputs[i++];
                if (input.name!==name) continue;
                else if (input.value!==value) continue;
                else results.push(input);}
            return results;}
        fdjtDOM.getInputsFor=getInputsFor;
        fdjtDOM.getInputFor=function(root,name,value){
            var results=getInputsFor(root,name||false,value||false);
            if ((results)&&(results.length===1))
                return results[0];
            else if ((results)&&(results.length)) {
                fdjtLog.warn(
                    "Ambiguous input reference name=%o name=%o under %o",
                    name,name,root);
                return results[0];}
            else return false;};


        function setInputs(selector,value){
            if (!(value)) return;
            var inputs=fdjtDOM.$(selector);
            var i=0, lim=inputs.length; while (i<lim) {
                inputs[i++].value=value;}}
        fdjtDOM.setInputs=setInputs;

        /* Getting style information generally */

        function getStyle(elt,prop){
            if (typeof elt === 'string') elt=document.getElementById(elt);
            if (!(elt)) return elt;
            if (elt.nodeType!==1) throw "Not an element";
            try {
                var style=
                    ((window.getComputedStyle)&&
                     (window.getComputedStyle(elt,null)))||
                    (elt.currentStyle);
                if (!(style)) return false;
                else if (prop) return style[prop];
                else return style;}
            catch (ex) {
                fdjtLog("Unexpected style error %o",ex);
                return false;}}
        fdjtDOM.getStyle=getStyle;

        function styleString(elt){
            var style=elt.style; var result;
            if (!(style)) return false;
            var i=0; var lim=style.length;
            if (lim===0) return false;
            while (i<lim) {
                var p=style[i];
                var v=style[p];
                if (i===0) result=p+": "+v;
                else result=result+"; "+p+": "+v;
                i++;}
            return result;}
        fdjtDOM.styleString=styleString;

        /* Getting display style */

        var display_styles={
            "DIV": "block","P": "block","BLOCKQUOTE":"block",
            "H1": "block","H2": "block","H3": "block","H4": "block",
            "H5": "block","H6": "block","H7": "block","H8": "block",
            "UL": "block","LI": "list-item",
            "DL": "block","DT": "list-item","DD": "list-item",
            "SPAN": "inline","EM": "inline","STRONG": "inline",
            "TT": "inline","DEFN": "inline","A": "inline",
            "TD": "table-cell","TR": "table-row",
            "TABLE": "table", "PRE": "preformatted"};

        function getDisplayStyle(elt){
            if ((!(elt))||(!(elt.nodeType))||(elt.nodeType!==1))
                return false;
            return (((window.getComputedStyle)&&
                     (window.getComputedStyle(elt,null))&&
                     (window.getComputedStyle(elt,null).display))||
                    (display_styles[elt.tagName])||
                    "inline");}
        fdjtDOM.getDisplay=getDisplayStyle;

        /* Generating text from the DOM */

        function flatten(string){return string.replace(/\s+/," ");}

        function textify(arg,flat,depth,domarkup){
            if (typeof depth !== 'number') depth=0;
            if (arg.nodeType) {
                if (arg.nodeType===3) {
                    if (flat) return flatten(arg.nodeValue);
                    else return arg.nodeValue;}
                else if (arg.nodeType===1) {
                    var children=arg.childNodes;
                    var style=getStyle(arg);
                    var display_type=style.display;
                    var position_type=style.position;
                    var whitespace=style.whiteSpace;
                    var classname=arg.className;
                    var string=""; var suffix="";
                    if (whitespace!=="normal") flat=false;
                    if (display_type==='none') return "";
                    else if (!((position_type==="static")||
                               (position_type==="")))
                        return "";
                    else if ((typeof classname === "string")&&
                             ((classname==='fdjtskiptext')||
                              (classname.search(/\bfdjtskiptext\b/)>=0)))
                        return "";
                    else if ((!(children))||(children.length===0)) {
                        if (!(domarkup)) return "";
                        else if (arg.alt) return "["+arg.alt+"]";
                        else return "[?]";}
                    // Figure out what suffix and prefix to use for this element
                    else if (!(display_type)) {}
                    else if (display_type==="inline") {}
                    else if (flat) suffix=" ";
                    else if ((display_type==="block") ||
                             (display_type==="table") ||
                             (display_type==="preformatted")) {
                        string="\n"; suffix="\n";}
                    else if (display_type==="table-row") suffix="\n";
                    else if (display_type==="table-cell") string="\t";
                    else {}
                    var i=0; while (i<children.length) {
                        var child=children[i++];
                        if (!(child.nodeType)) continue;
                        if (child.nodeType===3) {
                            if (flat) string=string+flatten(child.nodeValue);
                            else string=string+child.nodeValue;}
                        else if (child.nodeType===1) {
                            var stringval=textify(child,flat,true,domarkup);
                            if (stringval) string=string+stringval;}
                        else continue;}
                    return string+suffix;}
                else {}}
            else if (arg.toString)
                return arg.toString();
            else return arg.toString();}
        fdjtDOM.textify=textify;

        /* Geometry functions */

        function getGeometry(elt,root,extra,withstack){
            if (!(withstack)) withstack=false;
            if (typeof elt === 'string')
                elt=document.getElementById(elt);
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var width=elt.offsetWidth;
            var height=elt.offsetHeight;
            var rootp=((root)&&(root.offsetParent));
            var style=((extra)&&(getStyle(elt)));
            if (withstack) withstack=[]; else withstack=false;
            
            if (elt===root) 
                return {left: 0,top: 0,width:width,height: height,
                        bottom: height,right: width};
            elt=elt.offsetParent;
            while (elt) {
                if ((root)&&((elt===root)||(elt===rootp))) break;
                if (withstack) withstack.push(elt);
                top += elt.offsetTop;
                left += elt.offsetLeft;
                elt=elt.offsetParent;}
            
            if (style) {
                var t_margin=parsePX(style.marginTop);
                var r_margin=parsePX(style.marginRight);
                var b_margin=parsePX(style.marginBottom);
                var l_margin=parsePX(style.marginLeft);
                var t_padding=parsePX(style.paddingTop);
                var r_padding=parsePX(style.paddingRight);
                var b_padding=parsePX(style.paddingBottom);
                var l_padding=parsePX(style.paddingLeft);
                var t_border=parsePX(style.borderTopWidth);
                var r_border=parsePX(style.borderRightWidth);
                var b_border=parsePX(style.borderBottomWidth);
                var l_border=parsePX(style.borderLeftWidth);
                var outer_width=width+l_margin+r_margin;
                var outer_height=height+t_margin+b_margin;
                var inner_width=width-(l_border+l_padding+r_border+r_padding);
                var inner_height=height-(t_border+t_padding+b_border+b_padding);
                var lh=style.lineHeight, fs=style.fontSize, lhpx=false;
                if (lh==="normal") lhpx=parsePX(fs);
                else if (lh.search(/px$/)>0) lhpx=parsePX(lh);
                else if (lh.search(/%$/)>0) 
                    lhpx=(parseFloat(lh.slice(0,-1))/100)*(parsePX(fs));
                else lhpx=parsePX(fs);
                return {left: left, top: top, width: width,height: height,
                        right:left+width,bottom:top+height,
                        top_margin: t_margin, bottom_margin: b_margin,
                        left_margin: l_margin, right_margin: r_margin,
                        top_border: t_border, bottom_border: b_border,
                        left_border: l_border, right_border: r_border,
                        top_padding: t_padding, bottom_padding: b_padding,
                        left_padding: l_padding, right_padding: r_padding,
                        outer_height: outer_height,outer_width: outer_width,
                        inner_height: inner_height,inner_width: inner_width,
                        line_height: lhpx,stack:withstack};}
            else return {left: left, top: top, width: width,height: height,
                         right:left+width,bottom:top+height,
                         stack:withstack};}
        fdjtDOM.getGeometry=getGeometry;

        function geomString(geom){
            return +((typeof geom.width === 'number')?(geom.width):"?")+
                "x"+((typeof geom.height === 'number')?(geom.height):"?")+
                "@l:"+((typeof geom.left === 'number')?(geom.left):"?")+
                ",t:"+((typeof geom.top === 'number')?(geom.top):"?")+
                "/r:"+((typeof geom.right === 'number')?(geom.right):"?")+
                ",b:"+((typeof geom.bottom === 'number')?(geom.bottom):"?");}
        fdjtDOM.geomString=geomString;

        function isVisible(elt,partial){
            if (!(partial)) partial=false;
            if ((elt.offsetParent)&&(elt.offsetParent!==document.body)) {
                var container=elt.offsetParent;
                var offtop=elt.offsetTop, offbot=offtop+elt.offsetHeight;
                var offleft=elt.offsetLeft;
                var offright=offleft+elt.offsetWidth;
                var l=container.scrollLeft, r=l+container.clientWidth;
                var t=container.scrollTop, b=t+container.clientHeight;
                if (partial)
                    return ((((offleft>=l)&&(offleft<=r))||
                             ((offright>=l)&&(offright<=r))||
                             ((offleft<l)&&(offright>r)))&&
                            (((offtop>=t)&&(offtop<=b))||
                             ((offbot>=t)&&(offbot<=b))||
                             ((offtop<=t)&&(offbot>=b))));
                else return ((((offleft>=l)&&(offleft<=r))&&
                              ((offright>=l)&&(offright<=r)))&&
                             (((offtop>=t)&&(offtop<=b))&&
                              ((offbot>=t)&&(offbot<=b))));}
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var width = elt.offsetWidth;
            var height = elt.offsetHeight;
            var winx=(window.pageXOffset||document.documentElement.scrollLeft||0);
            var winy=(window.pageYOffset||document.documentElement.scrollTop||0);
            var winxedge=winx+(document.documentElement.clientWidth);
            var winyedge=winy+(document.documentElement.clientHeight);
            
            while(elt.offsetParent) {
                if (elt===window) break;
                elt = elt.offsetParent;
                top += elt.offsetTop;
                left += elt.offsetLeft;}

            if ((elt)&&(!((elt===window)||(elt===document.body)))) {
                // fdjtLog("%o l=%o t=%o",elt,elt.scrollLeft,elt.scrollTop);
                if ((elt.scrollTop)||(elt.scrollLeft)) {
                    fdjtLog("Adjusting for inner DIV");
                    winx=elt.scrollLeft; winy=elt.scrollTop;
                    winxedge=winx+elt.scrollWidth;
                    winyedge=winy+elt.scrollHeight;}}

            /*
              fdjtLog("fdjtIsVisible%s %o top=%o left=%o height=%o width=%o",
              ((partial)?("(partial)"):""),start,
              top,left,height,width);
              fdjtLog("fdjtIsVisible %o winx=%o winy=%o winxedge=%o winyedge=%o",
              elt,winx,winy,winxedge,winyedge);
            */
            
            if (partial)
                // There are three cases we check for:
                return (
                    // top of element in window
                    ((top > winy) && (top < winyedge) &&
                     (left > winx) && (left < winxedge)) ||
                        // bottom of element in window
                        ((top+height > winy) && (top+height < winyedge) &&
                         (left+width > winx) && (left+width < winxedge)) ||
                        // top above/left of window, bottom below/right of window
                        (((top < winy) || (left < winx)) &&
                         ((top+height > winyedge) && (left+width > winxedge))));
            else return ((top > winy) && (left > winx) &&
                         (top + height) <= (winyedge) &&
                         (left + width) <= (winxedge));}
        fdjtDOM.isVisible=isVisible;

        function isAtTop(elt,delta){
            if (!(delta)) delta=50;
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var winy=(window.pageYOffset||document.documentElement.scrollTop||0);
            var winyedge=winy+(document.documentElement.clientHeight);
            
            while(elt.offsetParent) {
                elt = elt.offsetParent;
                top += elt.offsetTop;
                left += elt.offsetLeft;}

            return ((top>winy) && (top<winyedge) && (top<winy+delta));}
        fdjtDOM.isAtTop=isAtTop;

        function textwidth(node){
            if (node.nodeType===3) return node.nodeValue.length;
            else if (node.nodeType!==1) return 0;
            else {
                var style=getStyle(node);
                var display=style.display, position=style.position;
                if (display==="none") return 0;
                else if (!((position==="")||(position==="static")))
                    return 0;
                else if (typeof node.className!=="string") return 0;
                else if ((node.className==="fdjtskiptext")||
                         ((typeof node.className === "string")&&
                          (node.className.search(/\bfdjtskiptext/)>=0)))
                    return 0;
                else if (node.childNodes) {
                    var children=node.childNodes;
                    var i=0; var lim=children.length; var width=0;
                    while (i<lim) {
                        var child=children[i++];
                        if (child.nodeType===3)
                            width=width+child.nodeValue.length;
                        else if (child.nodeType===1)
                            width=width+textwidth(child);
                        else {}}
                    return width;}
                else if (node.alt) return node.alt.length+2;
                else return 3;}}
        fdjtDOM.textWidth=textwidth;

        function countBreaks(arg){
            if (typeof arg === 'string') {
                return arg.match(/\W*\s+\W*/g).length;}
            else if (!(arg.nodeType)) return 0;
            else if (arg.nodeType===1) {}
            else if (arg.nodeType===3)
                return arg.nodeValue.match(/\W*\s+\W*/g).length;
            else return 0;}
        fdjtDOM.countBreaks=countBreaks;
        
        var nontext_content=/(img|object|svg|hr)/i;

        function hasContent(node,recur,test,limit){
            if (node===limit) return false;
            else if (node.nodeType===3)
                return (child.nodeValue.search(/\w/g)>=0);
            else if (node.nodeType!==1) return false;
            else if ((test)&&(test.match)&&(test.match(node)))
                return true;
            else if (node.tagName.search(nontext_content)===0)
                return true;
            else if ((typeof node.className === "string")&&
                     (node.className.search(/\bfdjtskiptext\b/g)>=0))
                return false;
            else if ((node.childNodes)&&(node.childNodes.length)) {
                var children=node.childNodes;
                var i=0; while (i<children.length) {
                    var child=children[i++];
                    if (child===limit) return false;
                    else if (child.nodeType===3) {
                        if (child.nodeValue.search(/\w/g)>=0) return true;
                        else continue;}
                    else if (child.nodeType!==1) continue;
                    else if (recur) {
                        if (hasContent(child,recur,test,limit)) return true;
                        else continue;}
                    else continue;}
                return false;}
            else return false;}
        fdjtDOM.hasContent=hasContent;

        function hasText(node){
            if (node.childNodes) {
                var children=node.childNodes;
                var i=0; while (i<children.length) {
                    var child=children[i++];
                    if (child.nodeType===3)
                        if (child.nodeValue.search(/\w/g)>=0) return true;
                    else {}}
                return false;}
            else return false;}
        fdjtDOM.hasText=hasText;

        /* A 'refresh method' does a className eigenop to force IE redisplay */

        fdjtDOM.refresh=function(elt){
            elt.className=elt.className;};
        fdjtDOM.setAttrib=function(elt,attrib,val){
            if ((typeof elt === 'string')&&(fdjtID(elt)))
                elt=fdjtID(elt);
            elt.setAttribute(attrib,val);
            elt.className=elt.className;};
        fdjtDOM.dropAttrib=function(elt,attrib){
            if ((typeof elt === 'string')&&(fdjtID(elt)))
                elt=fdjtID(elt);
            elt.removeAttribute(attrib);
            elt.className=elt.className;};

        /* Determining if something has overflowed */
        fdjtDOM.overflowing=function(node){
            return (node.scrollHeight>node.clientHeight);};
        fdjtDOM.voverflow=function(node){
            return (node.scrollHeight/node.clientHeight);};
        fdjtDOM.hoverflow=function(node){
            return (node.scrollWidth/node.clientWidth);};

        /* Sizing to fit */

        var default_trace_adjust=false;

        function getInsideBounds(container){
            var left=false; var top=false;
            var right=false; var bottom=false;
            var children=container.childNodes;
            var i=0; var lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (typeof child.offsetLeft !== 'number') continue;
                var style=getStyle(child);
                if (style.position!=='static') continue;
                var child_left=child.offsetLeft-parsePX(style.marginLeft);
                var child_top=child.offsetTop-parsePX(style.marginTop);
                var child_right=child.offsetLeft+child.offsetWidth+parsePX(style.marginRight);
                var child_bottom=child.offsetTop+child.offsetHeight+parsePX(style.marginBottom);
                if (left===false) {
                    left=child_left; right=child_right;
                    top=child_top; bottom=child_bottom;}
                else {
                    if (child_left<left) left=child_left;
                    if (child_top<top) top=child_top;
                    if (child_right>right) right=child_right;
                    if (child_bottom>bottom) bottom=child_bottom;}}
            return {left: left,right: right,top: top, bottom: bottom,
                    width: right-left,height:bottom-top};}
        fdjtDOM.getInsideBounds=getInsideBounds;
        function applyScale(container,scale){
            var images=fdjtDOM.getChildren(container,"IMG");
            var ilim=images.length;
            if (scale) {
                container.scale=scale;
                container.style.fontSize=scale+'%';
                var rounded=10*Math.round(scale/10);
                fdjtDOM.addClass(container,"fdjtscaled");
                fdjtDOM.swapClass(
                    container,/\bfdjtscale\d+\b/,"fdjtscale"+rounded);}
            else if (!(container.scale)) return;
            else {
                delete container.scale;
                container.style.fontSize="";
                fdjtDOM.dropClass(container,"fdjtscaled");
                fdjtDOM.dropClass(container,/\bfdjtscale\d+\b/);}
            var iscan=0; while (iscan<ilim) {
                var image=images[iscan++];
                if ((fdjtDOM.hasClass(image,"nofdjtscale"))||
                    (fdjtDOM.hasClass(image,"noautoscale")))
                    continue;
                // Reset dimensions to get real info
                image.style.maxWidth=image.style.width=
                    image.style.maxHeight=image.style.height='';
                if (scale) {
                    var width=image.offsetWidth;
                    var height=image.offsetHeight;
                    image.style.maxWidth=image.style.width=
                        Math.round(width*(scale/100))+'px';
                    image.style.maxHeight=image.style.height=
                        Math.round(height*(scale/100))+'px';}}}
        
        function adjustInside(elt,container,step,min,pad){
            var trace_adjust=(elt.traceadjust)||
                (container.traceadjust)||fdjtDOM.trace_adjust||
                ((typeof elt.className === "string")&&
                 (elt.className.search(/\btraceadjust\b/)>=0))||
                ((typeof container.className === "string")&&
                 (container.className.search(/\btraceadjust\b/)>=0))||
                default_trace_adjust;
            if (!(step)) step=5;
            if (!(min)) min=50;
            if (!(pad)) pad=1;
            var scale=100;
            function adjust(){
                var outside=getGeometry(container);
                var inside=getGeometry(elt,container);
                var style=getStyle(container);
                var maxwidth=
                    outside.width-
                    (parsePX(style.paddingLeft,0)+
                     parsePX(style.borderLeft,0)+
                     parsePX(style.paddingRight,0)+
                     parsePX(style.borderRight,0));
                var maxheight=
                    outside.height-
                    (parsePX(style.paddingTop,0)+
                     parsePX(style.borderTop,0)+
                     parsePX(style.paddingBottom,0)+
                     parsePX(style.borderBottom,0));
                if (trace_adjust)
                    fdjtLog("adjustInside scale=%o step=%o min=%o pad=%o [l%o,t%o,r%o,b%o] << %ox%o < %ox%o",
                            scale,step,min,pad,
                            inside.left,inside.top,inside.right,inside.bottom,
                            maxwidth*pad,maxheight*pad,
                            maxwidth,maxheight);
                if ((inside.top>=0)&&(inside.bottom<=(pad*maxheight))&&
                    (inside.left>=0)&&(inside.right<=(pad*maxwidth)))
                    return;
                else if (scale<=min) return;
                else {
                    scale=scale-step;
                    applyScale(elt,scale,trace_adjust);
                    setTimeout(adjust,10);}}
            setTimeout(adjust,10);}
        function adjustToFit(container,threshold,padding){
            var trace_adjust=(container.traceadjust)||
                fdjtDOM.trace_adjust||
                ((typeof container.className === "string")&&
                 (container.className.search(/\btraceadjust\b/)>=0))||
                default_trace_adjust;
            var style=getStyle(container);
            var geom=getGeometry(container);
            var maxheight=((style.maxHeight)&&(parsePX(style.maxHeight)))||
                (geom.height);
            var maxwidth=((style.maxWidth)&&(parsePX(style.maxWidth)))||
                (geom.width);
            var goodenough=threshold||0.1;
            var scale=(container.scale)||100.0;
            var bounds=getInsideBounds(container);
            var hpadding=
                (fdjtDOM.parsePX(style.paddingLeft)||0)+
                (fdjtDOM.parsePX(style.paddingRight)||0)+
                (fdjtDOM.parsePX(style.borderLeftWidth)||0)+
                (fdjtDOM.parsePX(style.borderRightWidth)||0)+
                padding;
            var vpadding=
                (fdjtDOM.parsePX(style.paddingTop)||0)+
                (fdjtDOM.parsePX(style.paddingBottom)||0)+
                (fdjtDOM.parsePX(style.borderTopWidth)||0)+
                (fdjtDOM.parsePX(style.borderBottomWidth)||0)+
                padding;
            maxwidth=maxwidth-hpadding; maxheight=maxheight-vpadding; 
            var itfits=
                ((bounds.height/maxheight)<=1)&&((bounds.width/maxwidth)<=1);
            if (trace_adjust) 
                fdjtLog("Adjust (%o) %s cur=%o%s, best=%o~%o, limit=%ox%o=%o, box=%ox%o=%o, style=%s",
                        goodenough,fdjtDOM.nodeString(container),
                        scale,((itfits)?" (fits)":""),
                        container.bestscale||-1,container.bestfit||-1,
                        maxwidth,maxheight,maxwidth*maxheight,
                        bounds.width,bounds.height,bounds.width*bounds.height,
                        styleString(container));
            if (itfits) {
                /* Figure out how well it fits */
                var fit=Math.max((1-(bounds.width/maxwidth)),
                                 (1-(bounds.height/maxheight)));
                var bestfit=container.bestfit||1.5;
                if (!(trace_adjust)) {}
                else if (container.bestscale) 
                    fdjtLog("%s %o~%o vs. %o~%o",
                            ((fit<goodenough)?"Good enough!":
                             ((fit<bestfit)?"Better!":"Worse!")),
                            scale,fit,container.bestscale,container.bestfit);
                else fdjtLog("First fit %o~%o",scale,fit);
                if (fit<bestfit) {
                    container.bestscale=scale; container.bestfit=fit;}
                // If it's good enough, just return
                if (fit<goodenough) {
                    container.goodscale=scale; return;}}
            // Figure out the next scale factor to try
            var rh=maxheight/bounds.height; var rw=maxwidth/bounds.width;
            var newscale=
                ((itfits)?
                 (scale*Math.sqrt
                  ((maxwidth*maxheight)/(bounds.width*bounds.height))):
                 (rh<rw)?(scale*rh):(scale*rw));
            if (trace_adjust)
                fdjtLog("[%fs] Trying newscale=%o, rw=%o rh=%o",
                        fdjt.ET(),newscale,rw,rh);
            applyScale(container,newscale,trace_adjust);}
        fdjtDOM.applyScale=applyScale;
        fdjtDOM.adjustToFit=adjustToFit;
        fdjtDOM.adjustInside=adjustInside;
        fdjtDOM.insideBounds=getInsideBounds;
        fdjtDOM.finishScale=function(container){
            var traced=(container.traceadjust)||
                fdjtDOM.trace_adjust||default_trace_adjust;
            if (!(container.bestscale)) {
                applyScale(container,false,traced);
                fdjtLog("No good scaling for %o style=%s",
                        fdjtDOM.nodeString(container),
                        fdjtDOM.styleString(container));
                return;}
            else if (container.scale===container.bestscale) {}
            else applyScale(container,container.bestscale,traced);
            if (traced)
                fdjtLog("Final scale %o~%o for %o style=%s",
                        container.bestscale,container.bestfit,
                        fdjtDOM.nodeString(container),
                        fdjtDOM.styleString(container));
            delete container.bestscale;
            delete container.bestfit;
            delete container.goodscale;};
        
        /* Getting various kinds of metadata */

        function getHTML(){
            var children=document.childNodes;
            var i=0; var lim=children.length;
            while (i<lim)
                if (children[i].tagName==='HTML') return children[i];
            else i++;
            return false;}
        fdjtDOM.getHTML=getHTML;

        function getHEAD(){
            var children=document.childNodes;
            var i=0; var lim=children.length;
            while (i<lim)
                if (children[i].tagName==='HTML') {
                    var grandchildren=children[i].childNodes;
                    i=0; lim=grandchildren.length;
                    while (i<lim)
                        if (grandchildren[i].tagName==='HEAD')
                            return grandchildren[i];
                    else i++;
                    return false;}
            else i++;
            return false;}
        fdjtDOM.getHEAD=getHEAD;

        var schema2tag={}, tag2schema={};
        function getMetaSchemas(){
            var links=
                ((document.getElementsByTagName)&&
                 (document.getElementsByTagName('link')))||
                ((document.head.getElementsByTagName)&&
                 (document.head.getElementsByTagName('link')))||
                (getChildren(document,'link'));
            var i=0, lim=links.length;
            while (i<lim) {
                var link=links[i++];
                if (!(link.rel)) continue;
                else if (!(link.href)) continue;
                else if (link.rel.search("schema.")===0) {
                    var tag=link.rel.slice(7);
                    var href=link.href;
                    // We let there be multiple references
                    if (tag2schema[tag])
                        fdjtLog.warn("Conflicting schemas for %s",tag);
                    else {
                        if (schema2tag[href])
                            schema2tag[href].push(tag);
                        else schema2tag[href]=[tag];
                        tag2schema[tag]=href;}}
                else continue;}}
        var app_schemas={};
        fdjtDOM.addAppSchema=function(name,spec){
            app_schemas[name]=spec;};
        
        var escapeRX=fdjtString.escapeRX;

        function getNameRX(name,foldcase){
            var prefix, schema, prefixes=[];
            if ((typeof name ==='string')&&
                (typeof foldcase==='undefined')) {
                if (name[0]==='^') {
                    foldcase=false; name=name.slice(1);}
                else if (name[0]==='~') {
                    foldcase=true; name=name.slice(1);}
                else {}}
            if (typeof foldcase === 'undefined') foldcase=true;
            if (typeof name !== 'string') return name;
            else if (name[0]==='{') {
                schema=false;
                var schema_end=name.indexOf('}');
                if (schema_end>2) schema=name.slice(1,schema_end);
                prefixes=((schema)&&(schema2tag[schema]))||[];
                return new RegExp("\\b("+escapeRX(schema)+"|"+
                                  prefixes.join("|")+")[.]"+
                                  name.slice(schema_end+1)+"\\b",
                                  ((foldcase)?("i"):("")));}
            else if (name[0]==='=') {
                // This overrides any schema expansion
                return new RegExp("\\b"+escapeRX(name=name.slice(1))+"\\b",
                                  ((foldcase)?("i"):("")));}
            else if ((name[0]==='*')&&(name[1]==='.')) {
                // This overrides any schema expansion
                return new RegExp("\\b([^.]\\.)?"+name.slice(2)+"\\b",
                                  ((foldcase)?("i"):("")));}
            else if (name.indexOf('.')>0) {
                var dot=name.indexOf('.');
                prefix=name.slice(0,dot);
                schema=app_schemas[prefix];
                if (!(schema))
                    return new RegExp("\\b"+escapeRX(name)+"\\b",
                                      ((foldcase)?("i"):("")));
                else if ((schema)&&(schema2tag[schema]))
                    prefixes=schema2tag[schema];
                else prefixes=[prefix];
                return new RegExp("\\b("+escapeRX(schema)+"|"+
                                  prefixes.join("|")+")\\."+
                                  name.slice(dot+1)+"\\b",
                                  ((foldcase)?("i"):("")));}
            else return new RegExp("\\b"+name+"\\b",((foldcase)?("i"):("")));}
            

        function getMeta(name,multiple,foldcase,dom){
            var results=[];
            var elts=((document.getElementsByTagName)?
                      (document.getElementsByTagName("META")):
                      (getChildren(document,"META")));
            var rx=getNameRX(name,foldcase);
            var i=0; while (i<elts.length) {
                var elt=elts[i++];
                if (!(elt)) continue;
                else if (!(elt.name)) continue;
                else if (elt.name.search(rx)>=0) {
                    if (multiple) {
                        if (dom) results.push(elt);
                        else results.push(elt.content);}
                    else if (dom) return elt;
                    else return elt.content;}
                else {}}
            if (multiple) return results;
            else return false;}
        fdjtDOM.getMeta=getMeta;
        fdjtDOM.getMetaElts=function(name){
            var matchcase;
            return getMeta(name,true,matchcase,true);};

        // This gets a LINK href field
        function getLink(name,multiple,foldcase,dom,attrib){
            var results=[];
            var elts=((document.getElementsByTagName)?
                      (document.getElementsByTagName("LINK")):
                      ((document.body)&&(document.body.getElementsByTagName))?
                      (document.body.getElementsByTagName("LINK")):
                      (getChildren(document,"LINK")));
            var rx=getNameRX(name,foldcase);
            var i=0; while (i<elts.length) {
                var elt=elts[i++];
                if (!(elt)) continue;
                else if (!(elt.rel)) continue;
                else if (elt.rel.search(rx)>=0) {
                    if (multiple) {
                        if (dom) results.push(elt);
                        else if (attrib)
                            results.push(elt.getAttribute("href"));
                        else results.push(elt.href);}
                    else if (dom) return elt;
                    else if (attrib)
                        return elt.getAttribute("href");
                    else return elt.href;}
                else {}}
            if (multiple) return results;
            else return false;}
        fdjtDOM.getLink=getLink;
        fdjtDOM.getLinks=function(name){return getLink(name,true);};
        fdjtDOM.getLinkElts=function(name){
            var matchcase;
            return getLink(name,true,matchcase,true);};

        /* Going forward */

        /* If there's a children property (childNodes which are elements),
           we assume that all the element-specific fields exist. */
        var havechildren=((document)&&
                          (document.body)&&
                          (document.body.childNodes)&&
                          (document.body.children));

        // NEXT goes to the next sibling or the parent's next sibling
        function next_node(node){
            while (node) {
                if (node.nextSibling)
                    return node.nextSibling;
                else node=node.parentNode;}
            return false;}
        function next_element(node){
            if (node.nextElementSibling)
                return node.nextElementSibling;
            else {
                var scan=node;
                while ((scan=scan.nextSibling)) {
                    if (!(scan)) return null;
                    else if (scan.nodeType===1) break;
                    else {}}
                return scan;}}
        function scan_next(node,test,justelts){
            if (!(test))
                if (justelts) {
                    if (havechildren) return node.nextElementSibling;
                    else return next_element(node);}
            else return next_node(node);
            var scan=((justelts)?
                      ((havechildren)?
                       (node.nextElementSibling):(next_element(node))):
                      ((node.nextSibling)||(next_node(node))));
            while (scan)
                if (test(scan)) return scan;
            else if (justelts)
                scan=((scan.nextElementSibling)||(next_element(scan)));
            else scan=((scan.nextSibling)||(next_node(scan)));
            return false;}

        // FORWARD goes to the first deepest child
        function forward_node(node){
            if ((node.childNodes)&&((node.childNodes.length)>0))
                return node.childNodes[0];
            else while (node) {
                if (node.nextSibling)
                    return node.nextSibling;
                else node=node.parentNode;}
            return false;}
        function forward_element(node,n){
            var scan, i, lim;
            if (n) {
                i=0; scan=node;
                while (i<n) {scan=forward_element(scan); i++;}
                return scan;}
            if (havechildren) {
                if ((node.children)&&(node.children.length>0)) {
                    return node.children[0];}
                if ((scan=node.nextElementSibling)) return scan;
                while ((node=node.parentNode))
                    if ((scan=node.nextElementSibling)) return scan;
                return false;}
            else {
                if (node.childNodes) {
                    var children=node.childNodes; i=0; lim=children.length;
                    while (i<lim)
                        if (((scan=children[i++]))&&((scan.nodeType===1))) return scan;}
                while ((scan=node.nextSibling)) if (scan.nodeType===1) return scan;
                while ((node=node.parentNode))
                    if ((scan=next_element(node))) return scan;
                return false;}}
        function scan_forward(node,test,justelts){
            if (!(test)) {
                if (justelts) return forward_element(node);
                else return forward_node(node);}
            var scan=((justelts)?(forward_element(node)):(forward_node(node)));
            while (scan) {
                if (test(scan)) return scan;
                else if (justelts) scan=next_element(scan);
                else scan=next_node(scan);}
            return false;}

        fdjtDOM.nextElt=next_element;
        fdjtDOM.forwardElt=forward_element;
        fdjtDOM.forward=scan_forward;
        fdjtDOM.next=scan_next;

        /* Skimming backwards */

        // PREV goes the parent if there's no previous sibling
        function prev_node(node){
            while (node) {
                if (node.previousSibling)
                    return node.previousSibling;
                else node=node.parentNode;}
            return false;}
        function previous_element(node){
            if (havechildren)
                return node.previousElementSibling;
            else {
                var scan=node;
                while ((scan=scan.previousSibling))
                    if (!(scan)) return null;
                else if (scan.nodeType===1) break;
                else {}
                if (scan) return scan;
                else return scan.parentNode;}}
        function scan_previous(node,test,justelts){
            if (!(test))
                if (justelts) {
                    if (havechildren) return node.previousElementSibling;
                    else return previous_element(node);}
            else return prev_node(node);
            var scan=((justelts)?
                      ((havechildren)?(node.previousElementSibling):
                       (previous_element(node))):
                      (prev_node(node)));
            while (scan)
                if (test(scan)) return scan;
            else if (justelts)
                scan=((havechildren)?(scan.previousElementSibling):(previous_element(scan)));
            else scan=prev_node(scan);
            return false;}

        // BACKWARD goes to the final (deepest last) child
        //  of the previous sibling
        function backward_node(node){
            if (node.previousSibling) {
                var scan=node.previousSibling;
                // If it's not an element, just return it
                if (scan.nodeType!==1) return scan;
                // Otherwise, return the last and deepest child
                while (scan) {
                    var children=scan.childNodes;
                    if (!(children)) return scan;
                    else if (children.length===0) return scan;
                    else scan=children[children.length-1];}
                return scan;}
            else return node.parentNode;}

        function backward_element(node){
            if (havechildren)
                return ((node.previousElementSibling)?
                        (get_final_child((node.previousElementSibling))):
                        (node.parentNode));
            else if ((node.previousElementSibling)||(node.previousSibling)) {
                var start=(node.previousElementSibling)||(node.previousSibling);
                if (start.nodeType===1) 
                    return get_final_child(start);
                else return start;}
            else return node.parentNode;}
        // We use a helper function because 
        function get_final_child(node){
            if (node.nodeType===1) {
                if (node.childNodes) {
                    var children=node.childNodes;
                    if (!(children.length)) return node;
                    var scan=children.length-1;
                    while (scan>=0) {
                        var child=get_final_child(children[scan--]);
                        if (child) return child;}
                    return node;}
                else return node;}
            else return false;}
        
        function scan_backward(node,test,justelts){
            if (!(test)) {
                if (justelts) return backward_element(node);
                else return backward_node(node);}
            var scan=((justelts)?
                      (backward_element(node)):
                      (backward_node(node)));
            while (scan) {
                if (test(scan)) return scan;
                else if (justelts) scan=next_element(scan);
                else scan=next_node(scan);}
            return false;}
        
        fdjtDOM.prevElt=previous_element;
        fdjtDOM.backwardElt=backward_element;
        fdjtDOM.backward=scan_backward;
        fdjtDOM.prev=scan_previous;

        /* Viewport/window functions */

        fdjtDOM.viewTop=function viewTop(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if ((!(win))||(win===window)||
                ((window.Window)&&(win instanceof window.Window))) {
                win=win||window;
                return (win.pageYOffset||win.scrollY||
                        win.document.documentElement.scrollTop||0);}
            else return win.scrollTop;};
        
        fdjtDOM.viewLeft=function viewLeft(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if ((!(win))||(win===window)||
                ((window.Window)&&(win instanceof window.Window))) {
                win=win||window;
                return (win.pageXOffset||win.scrollX||
                        win.document.documentElement.scrollLeft||0);}
            else return win.scrollLeft;};

        function viewHeight(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if (!(win)) win=window;
            if (win.hasOwnProperty('innerHeight')) return win.innerHeight;
            else if ((win.document)&&(window.document.documentElement)&&
                     (window.document.documentElement.clientHeight))
                return window.document.documentElement.clientHeight;
            else return win.offsetHeight;}
        fdjtDOM.viewHeight=viewHeight;
        function viewWidth(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if (!(win)) win=window;
            if (win.hasOwnProperty('innerWidth')) return win.innerWidth;
            else if ((win.document)&&(window.document.documentElement)&&
                     (window.document.documentElement.clientWidth))
                return window.document.documentElement.clientWidth;
            else return win.offsetWidth;}
        fdjtDOM.viewWidth=viewWidth;

        function getOrientation(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if (!(win)) win=window;
            if (win.hasOwnProperty('orientation')) {
                if ((win.orientation===90)||(win.orientation===-90))
                    return 'landscape';
                else return 'portrait';}
            else {
                var w=viewWidth(win), h=viewHeight(win);
                if (w>h) return 'landscape';
                else return 'portrait';}}
        fdjtDOM.getOrientation=getOrientation;

        /* Generating element IDs */

        var id_count=0; var unique=Math.floor(Math.random()*100000);
        function getNodeID(elt){
            var id=elt.id; var nelt;
            if (id) return id;
            else {
                id="TMPID_"+unique+"_"+(id_count++);
                while ((!(nelt=document.getElementById(id)))||
                       (nelt===elt)) {
                    id="TMPID_"+unique+"_"+(id_count++);
                    if ((!(nelt=document.getElementById(id)))||
                        (nelt===elt))
                        unique=Math.floor(Math.random()*100000);
                    id="TMPID_"+unique+"_"+(id_count++);}
                elt.id=id;
                return id;}}
        fdjtDOM.getNodeID=getNodeID;
        
        /* Removing IDs */

        function stripIDs(node,nametoo,moveto){
            if (!(nametoo)) nametoo=false;
            if (!(moveto)) moveto=false;
            if (node.id) {
                if (moveto) node.setAttribute(moveto,node.id);
                node.id="";
                node.removeAttribute("id");}
            if ((nametoo)&&(node.name)) node.name=null;
            if ((node.childNodes)&&(node.childNodes.length)) {
                var children=node.childNodes, i=0, lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===1)
                        stripIDs(child,nametoo,moveto);}}}
        fdjtDOM.stripIDs=stripIDs;

        /* Stylesheet manipulation */

        // Adapted from 
        // http://www.hunlock.com/blogs/Totally_Pwn_CSS_with_Javascript

        // Return requested style object
        function getCSSRule(ruleName, deleteFlag) {
            ruleName=ruleName.toLowerCase();
            // If browser can play with stylesheets
            if (document.styleSheets) {
                // For each stylesheet
                for (var i=0; i<document.styleSheets.length; i++) {
                    var styleSheet=document.styleSheets[i];
                    var cssRules=styleSheet.cssRules||styleSheet.rules;
                    var n_rules=((cssRules)&&(cssRules.length));
                    var ii=0; while (ii<n_rules) {
                        if (cssRules[ii])  {
                            var cssRule=cssRules[ii];
                            if (cssRule.selectorText.toLowerCase()===ruleName) {
                                if (deleteFlag==='delete') {
                                    if (styleSheet.cssRules) {
                                        styleSheet.deleteRule(ii);}
                                    // Delete rule IE style.
                                    return true;}
                                // found and not deleting.
                                else {return cssRule;}
                                // end found cssRule
                            }}   
                        ii++;}
                    /* end for stylesheets */ }
                return false;}
            return false;}
        fdjtDOM.getCSSRule=getCSSRule;

        function dropCSSRule(ruleName) {// Delete a CSS rule   
            return getCSSRule(ruleName,'delete');}
        fdjtDOM.dropCSSRule=dropCSSRule;

        function addCSSRule(selector,style,sheet) {// Create a new css rule
            if (!(sheet)) {
                var styles=fdjtID("FDJTSTYLES");
                if (!(styles)) {
                    var head=document.getElementsByTagName("HEAD");
                    if (head.length===0) return; else head=head[0];
                    styles=fdjtDOM("style#FDJTSTYLES");
                    head.appendChild(styles);}
                sheet=styles.sheet;}
            if (!(sheet)) return false;
            else if ((sheet.insertRule)||(sheet.addRule)) {
                var rules=sheet.cssRules||sheet.rules;
                var at=rules.length;
                if (sheet.insertRule)
                    sheet.insertRule(selector+' {'+style+'}',at);
                else sheet.addRule(selector,style,at);
                return rules[at];}
            else return false;}
        fdjtDOM.addCSSRule=addCSSRule;

        /* Listeners (should be in UI?) */

        function addListener(node,evtype,handler){
            if (!(node)) node=document;
            if (typeof node === 'string') {
                var elt=fdjtID(node);
                if (!(node)) {
                    fdjtLog.warn("Can't find #%s",node);
                    return;}
                node=elt;}
            else if (((Array.isArray)&&(Array.isArray(node)))||
                     ((window.NodeList)&&(node instanceof window.NodeList))) {
                var i=0; var lim=node.length;
                while (i<lim) addListener(node[i++],evtype,handler);
                return;}
            else if ((node!==window)&&(!(node.nodeType))) {
                fdjtLog.warn("Bad target(s) arg to addListener(%s) %o",evtype,node);
                return;}
            // OK, actually do it
            if (evtype==='title') { 
                // Not really a listener, but helpful
                if (typeof handler === 'string') 
                    if (node.title)
                        node.title='('+handler+') '+node.title;
                else node.title=handler;}
            else if (evtype[0]==='=')
                node[evtype.slice(1)]=handler;
            else if (node.addEventListener)  {
                // fdjtLog("Adding listener %o for %o to %o",handler,evtype,node);
                return node.addEventListener(evtype,handler,false);}
            else if (node.attachEvent)
                return node.attachEvent('on'+evtype,handler);
            else fdjtLog.warn('This node never listens: %o',node);}
        fdjtDOM.addListener=addListener;

        function defListeners(handlers,defs){
            if ((handlers)&&(defs))
                for (var domspec in defs) {
                    if (defs.hasOwnProperty(domspec)) {
                        var evtable=defs[domspec];
                        var addto=handlers[domspec];
                        if ((!(addto))||
                            (!(handlers.hasOwnProperty(domspec))))
                            handlers[domspec]=addto={};
                        for (var evtype in evtable) {
                            if (evtable.hasOwnProperty(evtype))
                                addto[evtype]=evtable[evtype];}}}}
        fdjtDOM.defListeners=defListeners;

        var events_pat=/^([^:]+)$/;
        var spec_events_pat=/^([^: ]+):([^: ]+)$/;

        function addListeners(node,handlers){
            if (handlers) {
                for (var evtype in handlers) {
                    if (handlers.hasOwnProperty(evtype)) {
                        var match=false, val=handlers[evtype];
                        if (!(val.call)) {}
                        else if (events_pat.exec(evtype))
                            addListener(node,evtype,handlers[evtype]);
                        else if ((match=spec_events_pat.exec(evtype))) {
                            var ev=match[2];
                            var handler=handlers[evtype];
                            var elts=node.querySelectorAll(match[1]);
                            addListener(elts,ev,handler);}}}}}
        fdjtDOM.addListeners=addListeners;
        
        function removeListener(node,evtype,handler){
            if (!(node)) node=document;
            if (typeof node === 'string') {
                var elt=fdjtID(node);
                if (!(node)) {
                    fdjtLog("Can't find #%s",node);
                    return;}
                node=elt;}
            else if (((Array.isArray)&&(Array.isArray(node)))||
                     ((window.NodeList)&&(node instanceof window.NodeList))) {
                var i=0; var lim=node.length;
                while (i<lim) removeListener(node[i++],evtype,handler);
                return;}
            else if ((node!==window)&&(!(node.nodeType))) {
                fdjtLog.warn("Bad target(s) arg to removeListener(%s) %o",evtype,node);
                return;}
            // OK, actually do it
            if (node.removeEventListener)  {
                return node.removeEventListener(evtype,handler,false);}
            else if (node.detachEvent)
                return node.detachEvent('on'+evtype,handler);
            else fdjtLog.warn('This node never listens: %o',node);}
        fdjtDOM.removeListener=removeListener;

        fdjtDOM.T=function(evt) {
            evt=evt||window.event; return (evt.target)||(evt.srcElement);};

        fdjtDOM.cancel=function(evt){
            evt=evt||window.event;
            if (evt.preventDefault) evt.preventDefault();
            else evt.returnValue=false;
            evt.cancelBubble=true;};

        function triggerClick(elt){
            if (document.createEvent) { // in chrome
                var e = document.createEvent('MouseEvents');
                e.initEvent( 'click', true, true );
                elt.dispatchEvent(e);
                return;}
            else {
                fdjtLog.warn("Couldn't trigger click");
                return;}}
        fdjtDOM.triggerClick=triggerClick;

        /* Scaling to fit using CSS transforms */

        function scale_node(node,fudge,origin,shrink){
            if (!(origin)) origin=node.getAttribute("data-origin");
            if (!(shrink)) shrink=node.getAttribute("data-shrink");
            if (!(fudge)) fudge=node.getAttribute("data-fudge");

            // Clear any existing adjustments
            var first=node.firstChild, wrapper=
                ((first.className==="fdjtadjusted")?(first):
                 (getFirstChild(node,"fdjtadjusted")));
            if (wrapper) wrapper.setAttribute("style","");

            var geom=getGeometry(node,false,true), inside=getInsideBounds(node);
            var avail_width=((fudge)?(fudge*geom.inner_width):
                             (geom.inner_width));
            var avail_height=((fudge)?(fudge*geom.inner_height):
                              (geom.inner_height));

            if ((inside.height<=avail_height)&&(inside.width<=avail_width)) {
                // Everything is inside
                if (!(shrink)) return;
                // If you fit closely in any dimension, don't try scaling
                if (((inside.height<avail_height)&&
                     (inside.height>=(avail_height*0.9)))||
                    ((inside.width<geom.inner_width)&&
                     (inside.width>=(avail_height*0.9))))
                    return;}
            if (!(wrapper)) {
                var nodes=[], children=node.childNodes;
                var i=0, lim=children.length;
                while (i<lim) nodes.push(children[i++]);
                wrapper=fdjtDOM("div.fdjtadjusted");
                i=0; lim=nodes.length; while (i<lim)
                    wrapper.appendChild(nodes[i++]);
                node.appendChild(wrapper);}
            var w_scale=avail_width/inside.width;
            var h_scale=avail_height/inside.height;
            var scale=((w_scale<h_scale)?(w_scale):(h_scale));
            wrapper.style[fdjtDOM.transform]="scale("+scale+","+scale+")";
            wrapper.style[fdjtDOM.transformOrigin]=origin||"50% 0%";}

        function scaleAll(){
            var all=fdjtDOM.$(".fdjtadjustfit");
            var i=0, lim=all.length; while (i<lim)
                scale_node(all[i++]);}
        
        function scaleToFit(node,fudge,origin){
            fdjtDOM.addClass(node,"fdjtadjustfit");
            if ((fudge)&&(typeof fudge !== "number")) fudge=0.9;
            if (fudge) node.setAttribute("data-fudge",fudge);
            if (origin) node.setAttribute("data-origin",origin);
            scale_node(node,fudge,origin);
            return node;}
        fdjtDOM.scaleToFit=scaleToFit;
        fdjtDOM.scaleToFit.scaleNode=fdjtDOM.scaleToFit.adjust=scale_node;
        
        function scale_revert(node,wrapper){
            if (!(wrapper)) {
                if (hasClass(node,"fdjtadjusted")) {
                    wrapper=node; node=wrapper.parentNode;}
                else wrapper=
                    ((node.firstChild.className==="fdjtadjusted")?
                     (node.firstChild):(getFirstChild(node,"fdjtadjusted")));}
            if ((node)&&(wrapper)) {
                var nodes=[], children=wrapper.childNodes;
                var i=0, lim=children.length;
                while (i<lim) nodes.push(children[i++]);
                var frag=document.createDocumentFragment();
                i=0; lim=nodes.length; while (i<lim) {
                    frag.appendChild(nodes[i++]);}
                node.replaceChild(frag,wrapper);
                return node;}
            else return false;}
        fdjtDOM.scaleToFit.revert=scale_revert;

        function revertAll(){
            var all=fdjtDOM.$(".fdjtadjusted");
            var i=0, lim=all.length; while (i<lim) {
                var wrapper=all[i++];
                scale_revert(wrapper.parentNode,wrapper);}}
        fdjtDOM.scaleToFit.revertAll=revertAll;

        fdjt.addInit(scaleAll);
        fdjtDOM.addListener(window,"resize",scaleAll);

        /* Check for SVG */
        var nosvg;

        function checkSVG(){
            var root=document.documentElement||document.body;
            if (typeof nosvg === "undefined") {
                if ((document.implementation)&&
                    (document.implementation.hasFeature))
                    nosvg=(!(document.implementation.hasFeature(
                        "http://www.w3.org/TR/SVG11/feature#Image",
                        "1.1")));
                else if (navigator.appName==="Microsoft Internet Explorer")
                    // SVG (or at least SVGZ) images don't seem to
                    // obey CSS scaling in IE.
                    nosvg=true;
                else if (navigator.mimeTypes["image/svg+xml"])
                    nosvg=false;
                else nosvg=true;}
            if (nosvg) {
                addClass(root,"_NOSVG");
                dropClass(root,"_USESVG");}
            else {
                dropClass(root,"_NOSVG");
                addClass(root,"_USESVG");}
            return (!(nosvg));}
        
        function checkChildren(){
            havechildren=((document)&&
                          (document.body)&&
                          (document.body.childNodes)&&
                          (document.body.children));}

        function useBMP(){
            var hasSuffix=fdjtString.hasSuffix;
            var images=fdjt.$("IMG");
            var i=0, lim=images.length;
            while (i<lim) {
                var image=images[i++]; var src=image.src;
                if (!(src)) continue;
                if ((hasSuffix(src,".svg"))||(hasSuffix(src,".svgz"))) {
                    var bmp=image.getAttribute('bmp');
                    if (bmp) {
                        image.setAttribute('svg',image.src);
                        image.src=bmp;}}}}
        function useSVG(){
            var hasSuffix=fdjtString.hasSuffix;
            var images=fdjt.$("IMG");
            var i=0, lim=images.length;
            while (i<lim) {
                var image=images[i++]; var src=image.src;
                if (!(src)) continue;
                if ((!((hasSuffix(src,".svg"))||(hasSuffix(src,".svgz"))))&&
                    (image.getAttribute('svg'))) {
                    var svg=image.getAttribute('svg');
                    image.setAttribute('bmp',image.src);
                    image.src=svg;}}}
        fdjtDOM.useSVG=useSVG;
        fdjtDOM.useBMP=useBMP;

        function prefSVG(){
            if (!(nosvg)) useSVG();}
        fdjtDOM.prefSVG=prefSVG;
        fdjtDOM.checkSVG=checkSVG;

        fdjtDOM.init=fdjt.Init;
        fdjtDOM.addInit=fdjt.addInit;
        fdjt.addInit(checkChildren,"checkChildren");
        fdjt.addInit(checkSVG,"checkSVG");

        if (navigator.userAgent.search("WebKit")>=0) {
            if (!(fdjtDOM.transition)) fdjtDOM.transition='-webkit-transition';
            if (!(fdjtDOM.transitionProperty))
                fdjtDOM.transitionProperty='-webkit-transition-property';
            if (!(fdjtDOM.transitionDuration))
                fdjtDOM.transitionDuration='-webkit-transition-duration';
            if (!(fdjtDOM.transitionDelay))
                fdjtDOM.transitionDelay='-webkit-transition-delay';
            if (!(fdjtDOM.transitionTiming))
                fdjtDOM.transitionTiming='-webkit-transition-timing-function';
            if (!(fdjtDOM.transform)) fdjtDOM.transform='-webkit-transform';
            if (!(fdjtDOM.transformOrigin))
                fdjtDOM.transformOrigin='-webkit-transform-origin';
            if (!(fdjtDOM.columnWidth)) fdjtDOM.columnWidth='-webkit-column-width';
            if (!(fdjtDOM.columnGap)) fdjtDOM.columnGap='-webkit-column-gap';}
        else if (navigator.userAgent.search("Mozilla")>=0) {
            if (!(fdjtDOM.transition)) fdjtDOM.transition='-moz-transition';
            if (!(fdjtDOM.transitionProperty))
                fdjtDOM.transitionProperty='-moz-transition-property';
            if (!(fdjtDOM.transitionDuration))
                fdjtDOM.transitionDuration='-moz-transition-duration';
            if (!(fdjtDOM.transitionDelay))
                fdjtDOM.transitionDelay='-moz-transition-delay';
            if (!(fdjtDOM.transitionTiming))
                fdjtDOM.transitionTiming='-moz-transition-timing-function';
            if (!(fdjtDOM.transform)) fdjtDOM.transform='-moz-transform';
            if (!(fdjtDOM.transformOrigin))
                fdjtDOM.transformOrigin='-moz-transform-origin';
            if (!(fdjtDOM.columnWidth)) fdjtDOM.columnWidth='MozColumnWidth';
            if (!(fdjtDOM.columnGap)) fdjtDOM.columnGap='MozColumnGap';}
        else {
            if (!(fdjtDOM.transition)) fdjtDOM.transition='transition';
            if (!(fdjtDOM.transitionProperty))
                fdjtDOM.transitionProperty='transition-property';
            if (!(fdjtDOM.transitionDuration))
                fdjtDOM.transitionDuration='transition-duration';
            if (!(fdjtDOM.transitionDelay))
                fdjtDOM.transitionDelay='transition-delay';
            if (!(fdjtDOM.transitionTiming))
                fdjtDOM.transitionTiming='transition-timing-function';
            if (!(fdjtDOM.transform)) fdjtDOM.transform='transform';
            if (!(fdjtDOM.transformOrigin))
                fdjtDOM.transformOrigin='-moz-transform-origin';}
        
        if (typeof document.hidden !== "undefined") {
            fdjtDOM.isHidden="hidden";
            fdjtDOM.vischange="visibilitychange";}
        else if (typeof document.webkitHidden !== "undefined") {
            fdjtDOM.isHidden="webkitHidden";
            fdjtDOM.vischange="webkitvisibilitychange";}
        else if (typeof document.mozHidden !== "undefined") {
            fdjtDOM.isHidden="mozHidden";
            fdjtDOM.vischange="mozvisibilitychange";}
        else if (typeof document.msHidden !== "undefined") {
            fdjtDOM.isHidden="msHidden";
            fdjtDOM.vischange="msvisibilitychange";}
        else {
            fdjtDOM.isHidden=false; fdjtDOM.vischange=false;}

        /* Selection-y functions */

        fdjtDOM.getSelectedRange=function(sel){
            if (sel) {}
            else if (window.getSelection)
                sel=window.getSelection();
            else if (document.selection)
                sel=document.selection.createRange();
            else return false;
            if (!(sel)) return false;
            if (sel.getRangeAt) {
                if (sel.rangeCount)
                    return sel.getRangeAt(0);
                else return false;}
            else if (document.createRange) {
                var range=document.createRange();
                range.setStart(sel.anchorNode,sel.anchorOffset);
                range.setEnd(sel.focusNode,sel.focusOffset);
                return range;}
            else return false;};

        fdjtDOM.rangeIsEmpty=function(range){
            if (range) {
                if ((range.startContainer===range.endContainer)&&
                    (range.startOffset===range.endOffset))
                    return true;
                else return false;}
            else return true;};

        fdjtDOM.clearSelection=function(sel){
            if (!(sel))
                sel=document.selection||window.getSelection();
            if (sel.removeAllRanges) {
                sel.removeAllRanges();}
            else if (sel.empty) {
                sel.empty();}
            else {}};

        function node2text(node,accum){
            var i, lim;
            if (!(accum)) accum="";
            if ((!(node.nodeType))&&(node.length)) {
                i=0; lim=node.length;
                while (i<lim) accum=node2text(node[i++],accum);
                return accum;}
            else if (node.nodeType===3) {
                var stringval=node.nodeValue;
                if (stringval)
                    accum=accum+stringval;
                return accum;}
            else if (node.nodeType===1) {
                var style=getStyle(node);
                var children=node.childNodes;
                if ((typeof node.className === "string")&&
                    (node.className.search(/\bfdjtskiptext\b/)>=0))
                    return accum;
                else if ((style.display==='none')||
                    (style.visibility==='hidden')||
                    (!((style.position==='static')||
                       (style.position===''))))
                    return accum;
                else {}
                i=0; lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===3) {
                        var s=child.nodeValue;
                        if (s) accum=accum+s;}
                    else accum=node2text(child,accum);}
                return accum;}
            else return accum;}
        fdjtDOM.node2text=node2text;
        
        function get_text_pos(node,pos,cur,starting){
            var i, lim;
            if (cur>pos) return false;
            else if ((!(node.nodeType))&&(node.length)) {
                i=0; lim=node.length;
                while (i<lim) {
                    cur=get_text_pos(node[i++],pos,cur,starting);
                    if (typeof cur !== "number") return cur;}
                return cur;}
            else if (node.nodeType===3) {
                var stringval=node.nodeValue;
                if (pos<(cur+stringval.length))
                    return { node: node, off: pos-cur};
                else if (pos===(cur+stringval.length))
                    return { node: node, off: pos-cur,atend: true};
                else return cur+stringval.length;}
            else if (node.nodeType===1) {
                var style=getStyle(node);
                var children=node.childNodes;
                if ((typeof node.className === "string")&&
                    (node.className.search(/\bfdjtskiptext\b/)>=0))
                    return cur;
                else if ((style.display==='none')||
                    (style.visibility==='hidden')||
                    (!((style.position==='static')||
                       (style.position===''))))
                    return cur;
                else {}
                i=0; lim=children.length;
                while (i<lim) {
                    cur=get_text_pos(children[i++],pos,cur,starting);
                    if (typeof cur !== 'number') {
                        if ((starting)&&(cur.atend)) {
                            cur=pos; while (i<lim) {
                                var next=get_text_pos(
                                    children[i++],cur,pos,starting);
                                if ((next)&&(typeof next!=="number"))
                                    return next;}
                            return cur;}
                        else return cur;}}
                return cur;}
            else return cur;}

        function textPos(node,pos,sofar){
            var result=get_text_pos(node,pos,sofar||0);
            if (typeof result !== 'number') return result;
            else return {node: node,off: pos};}
        fdjtDOM.textPos=textPos;

        fdjtDOM.refineRange=function(range){
            if ((range.startContainer.nodeType===3)&&
                (range.endContainer.nodeType===3))
                return range;
            var start_info=textPos(range.startContainer,range.startOffset);
            var end_info=textPos(range.endContainer,range.endOffset);
            var newrange=document.createRange();
            newrange.setStart(start_info.node,start_info.off);
            newrange.setEnd(end_info.node,end_info.off);
            return newrange;};
        
        function get_text_off(scan,upto,sofar){
            if (!(sofar)) sofar=0;
            if (scan===upto) return [sofar];
            else if (scan.nodeType===3)
                return sofar+scan.nodeValue.length;
            else if (scan.nodeType===1) {
                var children=scan.childNodes;
                var i=0, lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    sofar=get_text_off(child,upto,sofar);
                    if (typeof sofar !== 'number') return sofar;}
                return sofar;}
            else return sofar;}
        function textOff(node,pos){
            var off=get_text_off(node,pos,0);
            if (off) return off[0]; else return false;}
        fdjtDOM.textOff=textOff;
        
        function getIDParent(scan) {
            while (scan) {
                if (scan.id) break;
                else scan=scan.parentNode;}
            return scan;}

        fdjtDOM.getRangeInfo=function(range,within){
            var start=range.startContainer;
            if (!(within)) within=getIDParent(start);
            var start_edge=textOff(within,start,0);
            var end=range.endContainer;
            var ends_in=((start===end)?(within):
                         (getParent(end,within))?(within):
                         (getIDParent(end)));
            var end_edge=((start===end)?(start_edge):
                          textOff(ends_in,end,0));
            return {start: start_edge+range.startOffset,
                    starts_in: within.id,ends_in: ends_in.id,
                    end: end_edge+range.endOffset};};

        function getRegexString(needle,shyphens,before,after){
            if (shyphens) {
                needle=needle.replace("­","");
                return ((before||"")+
                        (needle.replace(/\S/g,"$&­?").
                         replace(/([()\[\]\.\?\+\*])­\?/gm,"[$1]").
                         replace("­? "," ").replace(/\s+/g,"(\\s+)"))+
                        (after||""));}
            else return (((before)||(""))+
                         (needle.replace(/[()\[\]\.\?\+\*]/gm,"[$&]").replace(
                                 /\s+/g,"(\\s+)"))+
                         ((after)||("")));}
        fdjtDOM.getRegexString=getRegexString;

        function textRegExp(needle,foldcase,shyphens,before,after){
            if (typeof shyphens==="undefined") shyphens=true;
            return new RegExp(getRegexString(needle,shyphens,before,after),
                              ((foldcase)?("igm"):("gm")));}
        fdjtDOM.textRegExp=textRegExp;
        function wordRegExp(needle,foldcase,shyphens){
            if (typeof shyphens==="undefined") shyphens=true;
            return new RegExp(getRegexString(needle,shyphens,"\\b","\\b"),
                              ((foldcase)?("igm"):("gm")));}
        fdjtDOM.wordRegExp=wordRegExp;

        function findString(node,needle,off,count){
            if (typeof off === 'undefined') off=0;
            if (typeof count === 'undefined') count=1;
            needle=needle.replace(/­/mg,"");
            var match=false;
            var fulltext=node2text(node);
            var sub=((off===0)?(fulltext):(fulltext.slice(off)));
            var scan=sub.replace(/­/mg,"");
            var pat=((typeof needle === 'string')?
                     (textRegExp(needle,false,false)):
                     (needle));
            while ((match=pat.exec(scan))) {
                if (count===1) {
                    var loc=match.index;
                    if (scan!==sub) {
                        // If the text contains soft hyphens, we need
                        // to adjust *loc* (which is an offset into
                        // the string without those hyphens into an
                        // offset in the actual string in the DOM.
                        var i=0; while (i<loc) {
                            if (sub[i]==="­") loc++;
                            i++;}}
                    var absloc=loc+off;
                    var start=get_text_pos(node,absloc,0,true);
                    var end=get_text_pos(node,absloc+(match[0].length),0);
                    if ((!start)||(!end)) return false;
                    var range=document.createRange();
                    if (start.atend) {
                        var txt=firstText(start.node.nextSibling);
                        if (txt) range.setStart(txt,0);
                        else range.setStart(start.node,start.off);}
                    else range.setStart(start.node,start.off);
                    range.setEnd(end.node,end.off);
                    return range;}
                else {count--;
                      off=match.index+match[0].length;
                      scan=scan.slice(off);}}
            return false;}
        fdjtDOM.findString=findString;

        function findMatches(node,needle,off,count){
            if (typeof off === 'undefined') off=0;
            if (typeof count === 'undefined') count=-1;
            var match=false; var results=[];
            var fulltext=node2text(node);
            var scan=((off===0)?(fulltext):(fulltext.slice(off)));
            var pat=((typeof needle === 'string')?(textRegExp(needle)):
                     (needle));
            while ((count!==0)&&(match=pat.exec(scan))) {
                var loc=match.index+off;
                // var absloc=loc+off;
                var start=get_text_pos(node,loc,0);
                var end=get_text_pos(node,loc+match[0].length,0);
                if ((!start)||(!end)) return false;
                var range=document.createRange();
                if (typeof start === "number") range.setStart(node,start);
                else if (start.atend) {
                    var txt=firstText(start.node.nextSibling);
                    if (txt) range.setStart(txt,0);
                    else range.setStart(start.node,start.off);}
                else range.setStart(start.node,start.off);
                if (typeof end === "number") range.setEnd(node,end);
                else range.setEnd(end.node,end.off);
                results.push(range);
                // off=match.index+match[0].length; scan=scan.slice(off);
                count--;} 
            return results;}
        fdjtDOM.findMatches=findMatches;

        function firstText(node){
            if (!(node)) return false;
            else if (node.nodeType===3) return node;
            else if (node.nodeType===1)
                return firstText(node.firstChild);
            else return false;}

        /* Paragraph hashes */

        // fdjtDOM.getParaHash=function(node){return paraHash(textify(node,true,false,false));};

        /* Getting transition event names */

        var transition_events=[
            'transitionend','webkitTransitionEnd',
            'mozTransitionEnd','oTransitionEnd',
            'msTransitionEnd'];

        function checkTransitionEvents(){
            var div = document.createElement('div');
            if (!(div.removeEventListener)) return;
            var handler = function(e) {
                fdjtDOM.transitionEnd = e.type;
                var i=0, lim=transition_events.length;
                while (i<lim) {
                    if ((div)&&(div.removeEventListener))
                        div.removeEventListener(
                            transition_events[i++],handler);
                    else i++;}};
            div.setAttribute("style","position:absolute;top:0px;transition:top 1ms ease;-webkit-transition:top 1ms ease;-moz-transition:top 1ms ease;-o-transition:top 1ms ease;-ms-transition:top 1ms ease;");
            var i=0, lim=transition_events.length;
            while (i<lim) div.addEventListener(
                transition_events[i++], handler, false);
            document.documentElement.appendChild(div);
            setTimeout(function() {
                div.style.top = '100px';
                setTimeout(function() {
                    div.parentNode.removeChild(div);
                    div = handler = null;},
                           2000);},
                       0);}
        fdjt.addInit(checkTransitionEvents,"checkTransitionEvents");

        /* Custom input types (number, date, email, url, etc) */

        var custom_input_types=
            ["email","number","range","tel","url",
             "datetime","datetime-local","date","time","week","month"];

        function setupCustomInputs(dom){
            if (!(dom)) dom=document.body;
            var input_elt=document.createElement("input");
            var i=0, ntypes=custom_input_types.length;
            while (i<ntypes) {
                var typename=custom_input_types[i++];
                try {input_elt.type=typename;} catch (err) {}
                if (input_elt.type===typename) {
                    var inputs=getChildren(
                        document.body,".fdjt"+typename+"input");
                    var j=0, lim=inputs.length;
                    while (j<lim) {
                        var input=inputs[j++];
                        if (input.tagName!=="INPUT") continue;
                        input.type=typename;}}}}
        fdjtDOM.setupCustomInputs=setupCustomInputs;
        fdjt.addInit(setupCustomInputs,"CustomInputs");
        fdjtDOM.text_types=
            /\b(text|email|number|range|tel|url|datetime|datetime-local|date|time|week|month)\b/i;

        /* Checking media types */
        function checkMedia(){
            var media="media";
            if (window.matchMedia) {
                var mm=window.matchMedia("handheld");
                if (mm.match) media=media+" handheld";
                mm=window.matchMedia("(max-width:500px)");
                if (mm.match) media=media+" narrow";
                mm=window.matchMedia("(min-width:1000px)");
                if (mm.match) media=media+" wide";
                mm=window.matchMedia("(-webkit-min-device-pixel-ratio:1.5),(-min-resolution:15dp)");
                if (mm.match) media=media+" hires";}
            fdjt.media=media;}
        fdjt.addInit(checkMedia,"matchMedia");

        function getMediaState(){
            return window.getComputedStyle(
                document.body,':before').content;}
        fdjt.getMediaState=getMediaState;

        /* Inserting text in an text field or textarea */
        function insertText(target,text,off){
            var pos=target.selectionStart;
            var current=target.value;
            if ((current)&&(typeof pos === "number")&&(pos>=0))
                target.value=current.slice(0,pos)+text+current.slice(pos);
            else target.value=text;
            if (typeof off === "number")
                target.selectionEnd=target.selectionStart=pos+off;}
        fdjtDOM.insertText=insertText;

        /* Meta schemas */

        fdjt.addInit(getMetaSchemas,"MetaSchemas");

        /* Run inits on load */
        if ((!(fdjt.noinit))||
            ((typeof _fdjt_init === 'undefined')||(!(_fdjt_init))))
            fdjtDOM.addListener(window,"load",fdjtDOM.init);
        
        /* Playing audio */

        function playAudio(id){
            var elt=document.getElementById(id);
            if ((elt)&&(elt.play)) {
                if (!(elt.paused)) {
                    elt.pause(); elt.currentTime=0.0;}
                elt.play();}}
        fdjtDOM.playAudio=playAudio;

        /* Tweaking images */

        function tweakImage(elt,tw,th) {
            var style=elt.style;
            style.maxHeight=style.minHeight="inherit";
            style.maxWidth=style.minWidth="inherit";
            // Get width and height again, with the constraints off
            //  This means that pagescaling trumps CSS constraints,
            //  but we'll accept that for now
            var w=elt.offsetWidth, h=elt.offsetHeight, sw=tw/w, sh=th/h;
            if (sw<sh) {
                style.width=Math.round(w*sw)+"px";
                style.height="auto";}
            else {
                style.height=Math.round(h*sh)+"px";
                style.width="auto";}}
        fdjtDOM.tweakImage=tweakImage;

        /* Blob/URL functions */

        function makeBlob(string,type){
            if ((typeof string === "string")&&
                (string.search("data:")===0)) {
                if (!(type)) {
                    var typeinfo=/data:([^;]+);/.exec(string);
                    if (typeinfo) type=(typeinfo[1]);}
                var elts=string.split(',');
                var byteString = atob(elts[1]);
                if (elts[0].indexOf('base64') >= 0)
                    byteString = atob(elts[1]);
                else
                    byteString = window.unescape(elts[1]);
                var ab = new ArrayBuffer(byteString.length);
                var ia = new Uint8Array(ab);
                for (var i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);}
                return new Blob([ab], { type: type||'application' });}
            else return false;}
        fdjtString.makeBlob=makeBlob;

        function data2URL(datauri){
            if ((URL)&&(URL.createObjectURL)) 
                return URL.createObjectURL(makeBlob(datauri));
            else return datauri;}
        fdjtDOM.data2URL=data2URL;

        /* Tweaking fonts */

        function adjustWrapperFont(wrapper,delta,done,size,min,max,w,h,fudge,dolog){
            var rect=wrapper.getBoundingClientRect();
            var ow=rect.width, oh=rect.height, nw, nh, newsize;
            var wstyle=wrapper.style;
            if (typeof fudge!== "number") fudge=1;

            // These are cases where one dimension is on the edge but
            // the other dimension is inside the edge
            if ((ow<=w)&&(oh<=h)&&(oh>=(h-fudge))) return size;
            // We actually skip this case because increasing the font size
            //  might not increase the width if it forces a new line break
            // else if ((sh<=h)&&(sw<=w)&&(sw>=(w-fudge))) return size;

            // Figure out if we need to grow or shrink 
            if ((ow>w)||(oh>h)) delta=-delta;

            if (delta>0) wstyle.maxWidth=Math.floor(w)+"px";

            if (!(size)) {size=100; wstyle.fontSize=size+"%";}
            if (!(min)) min=20;
            if (!(max)) max=150;
            newsize=size+delta;
            wstyle.fontSize=newsize+"%";
            rect=wrapper.getBoundingClientRect(); nw=rect.width, nh=rect.height;
            while ((size>=min)&&(size<=max)&&
                   ((delta>0)?((nw<w)&&(nh<h)):((nw>w)||(nh>h)))) {
                size=newsize; newsize=newsize+delta;
                wstyle.fontSize=newsize+"%";
                if (dolog)
                    fdjtLog(
                        "Adjust %o to %dx%d %o: size=%d=%d+(%d), %dx%d => %dx%d",
                        wrapper.parentNode,w,h,wrapper,newsize,size,delta,
                        ow,oh,nw,nh);
                rect=wrapper.getBoundingClientRect();
                nw=rect.width, nh=rect.height;}
            wstyle.maxWidth='';
            if (delta>0) {
                wstyle.fontSize=size+"%";
                return size;}
            else return newsize;}
                
        function adjustFontSize(node,min_font,max_font,fudge){
            var h=node.offsetHeight, w=node.offsetWidth;
            var dolog=hasClass(node,"_fdjtlog");
            var node_display='';
            if ((h===0)||(w===0)) {
                // Do a little to make the element visible if it's not.
                node_display=node.style.display;
                node.style.display='initial';
                h=node.offsetHeight; w=node.offsetWidth;
                if ((h===0)||(w===0)) {
                    node.style.display=node_display;
                    return;}}
            else {}
            if ((h===0)||(w===0)) {
                node.style.display=node_display;
                return;}
            var wrapper=wrapChildren(node,"div.fdjtfontwrapper");
            var wstyle=wrapper.style, size=100;
            wstyle.boxSizing='border-box';
            wstyle.padding=wstyle.margin="0px";
            wstyle.fontSize=size+"%";
            wstyle.transitionProperty='none';
            wstyle.transitionDuration='0s';
            wstyle[fdjtDOM.transitionProperty]='none';
            wstyle[fdjtDOM.transitionDuration]='0s';
            wstyle.visibility='visible';
            wstyle.overflow='visible';
            if ((h===0)||(w===0)) {
                node.removeChild(wrapper);
                fdjtDOM.append(node,toArray(wrapper.childNodes));
                node.style.display=node_display;
                return;}
            var min=((min_font)||(node.getAttribute("data-minfont"))||(20));
            var max=((max_font)||(node.getAttribute("data-maxfont"))||(200));
            if (typeof fudge!=="number") fudge=node.getAttribute("data-fudge");
            if (typeof min === "string") min=parseFloat(min,10);
            if (typeof max === "string") max=parseFloat(max,10);
            if (typeof fudge === "string") fudge=parseInt(fudge,10);
            if (typeof fudge !== "number") fudge=2;
            wstyle.width=wstyle.height="100%";
            w=wrapper.offsetWidth; h=wrapper.offsetHeight;
            wstyle.width=wstyle.height="";
            size=adjustWrapperFont(
                wrapper,10,false,size,min,max,w,h,fudge,dolog);
            size=adjustWrapperFont(
                wrapper,5,false,size,min,max,w,h,fudge,dolog);
            size=adjustWrapperFont(
                wrapper,1,false,size,min,max,w,h,fudge,dolog);
            node.style.display=node_display;
            if (size===100) {
                if (dolog)
                    fdjtLog("No need to resize %o towards %dx%d",node,w,h);
                node.removeChild(wrapper);
                fdjtDOM.append(node,toArray(wrapper.childNodes));}
            else {
                wstyle.overflow=''; wstyle.width=''; wstyle.height='';
                if (dolog)
                    fdjtLog("Adjusted (%s) %o towards %dx%d, wrapper @ %d,%d",
                            wstyle.fontSize,node,w,h,
                            wrapper.scrollWidth,wrapper.scrollHeight);
                // We reset all of these
                wstyle.transitionProperty='';
                wstyle.transitionDuration='';
                wstyle[fdjtDOM.transitionProperty]='';
                wstyle[fdjtDOM.transitionDuration]='';
                var cwstyle=getStyle(wrapper);
                if (cwstyle[fdjtDOM.transitionProperty]) { 
                    wstyle.fontSize=''; wstyle.visibility='';
                    wstyle.fontSize=size+"%";}
                else wstyle.visibility='';}
            return size;}
        fdjtDOM.adjustFontSize=fdjtDOM.tweakFontSize=adjustFontSize;
        
        function resetFontSize(node){
            var wrapper=getFirstChild(node,".fdjtfontwrapper");
            if (wrapper) wrapper.style.fontSize="100%";}
        fdjtDOM.resetFontSize=resetFontSize;

        fdjtDOM.autofont=".fdjtadjustfont,.adjustfont";
        function adjustFonts(arg,top){
            var all=[];
            if (!(arg)) all=fdjtDOM.$(fdjtDOM.autofont);
            else if (typeof arg === "string") {
                if (document.getElementByID(arg)) 
                    all=[document.getElementByID(arg)];
                else {
                    fdjtDOM.autofont=fdjtDOM.autofont+","+arg;
                    all=fdjtDOM.$(arg);}}
            else if (arg.nodeType===1) {
                var sel=new Selector(fdjtDOM.autofont);
                if (sel.match(arg))
                    all=[arg];
                else all=fdjtDOM.getChildren(arg,fdjtDOM.autofont);}
            else all=fdjtDOM.$(fdjtDOM.autofont);
            var i=0, lim=all.length;
            if (lim) while (i<lim) adjustFontSize(all[i++]);
            else if (top) adjustFontSize(top);}
        fdjtDOM.tweakFont=fdjtDOM.tweakFonts=
            fdjtDOM.adjustFont=fdjtDOM.adjustFonts=adjustFonts;
        
        function adjustPositionedChildren(node){
            if ((!(node))||(node.nodeType!==1)) return;
            var style=getStyle(node);
            if ((node.childNodes)&&(node.childNodes.length)) {
                var children=node.childNodes; var i=0, lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===1)
                        adjustPositionedChildren(child);}}
            if (((style.display==='block')||(style.display==='inline-block'))&&
                ((style.position==='absolute')||(style.position==='fixed')))
                adjustFontSize(node);}
        function adjustLayoutFonts(node){
            var marked=fdjtDOM.getChildren(node,fdjtDOM.autofont);
            var i=0, lim=marked.length;
            if (lim===0) adjustPositionedChildren(node);
            else while (i<lim) adjustFontSize(marked[i++]);}
        fdjtDOM.adjustLayoutFonts=adjustLayoutFonts;

        function autoAdjustFonts(){
            if (fdjtDOM.noautofontadjust) return;
            adjustFonts();
            fdjtDOM.addListener(window,"resize",adjustFonts);}

        fdjt.addInit(autoAdjustFonts,"adjustFonts");
        
        function addUXClasses(){
            var device=fdjt.device;
            var prefix=fdjt.cxprefix||"_";
            var html=document.documentElement;
            if (device.ios) addClass(html,prefix+"IOS");
            if (device.touch) addClass(html,prefix+"TOUCH");
            if (device.mouse) addClass(html,prefix+"MOUSE");
            if (device.android) addClass(html,prefix+"Android");}
        fdjtDOM.addUXClasses=addUXClasses;
        fdjtDOM.addUSClasses=addUXClasses;
        fdjtDOM.addCXClasses=addUXClasses;
        fdjt.addInit(addUXClasses,"AddUXClasses");

        function windowFocus(evt){
            evt=evt||window.event; addClass(document.body,"_FOCUS");}
        function windowBlur(evt){
            evt=evt||window.event; dropClass(document.body,"_FOCUS");}
        function trackPageFocus(){
            windowFocus(); // Could be iffy...
            addListener(window,"focus",windowFocus);
            addListener(window,"blur",windowBlur);}
        fdjt.addInit(trackPageFocus);

        fdjtDOM.trace_adjust=false;

        return fdjtDOM;
    })();

/* requestAnimationFrame polyfill */
(function() {
    "use strict";
    var lastTime = 0;
    var rAF=window.requestAnimationFrame;
    var cAF=window.cancelAnimationFrame;
    var vendors = ['webkit', 'moz','ms','o'];

    function fakeAnimationFrame(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(
            function() { callback(currTime + timeToCall); },
            timeToCall);
        lastTime = currTime + timeToCall;
        return id;}
    function cancelFakeAnimationFrame(id){clearTimeout(id);}

    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        rAF=rAF||window[vendors[x]+'RequestAnimationFrame'];
        cAF=cAF||window[vendors[x]+'CancelAnimationFrame']||
            window[vendors[x]+'CancelRequestAnimationFrame'];}

    if (!(rAF)) {
        rAF=fakeAnimationFrame;
        cAF=cancelFakeAnimationFrame;}

    fdjt.DOM.rAF=fdjt.DOM.requestAnimationFrame=rAF;
    fdjt.DOM.cAF=fdjt.DOM.cancelAnimationFrame=cAF;
}());

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/*
    http://www.JSON.org/json2.js
    2009-06-29

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html

    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the object holding the key.

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/
/* jslint evil: true */
/* jshint unused: false */
/* global window: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if ((typeof window !== "undefined")&&(!(window.JSON))) window.JSON={};

(function () {

     "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {
            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

if (!(fdjt.JSON)) fdjt.JSON=JSON;

/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/refdb.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.
   
   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.
   
   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).
   
   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html
   
*/

/* global setTimeout, clearTimeout, Promise, window, idbModules */

fdjt.RefDB=(function(){
    "use strict";
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtAsync=fdjt.Async;
    var fdjtDOM=fdjt.DOM;
    var JSON=fdjt.JSON;
    var fdjtLog=fdjt.Log;
    var warn=fdjtLog.warn;

    var indexedDB=window.indexedDB||idbModules.indexedDB;
    
    var refdbs={}, all_refdbs=[], changed_dbs=[], aliases={};

    function RefDB(name,init){
        var db=this;
        if (refdbs[name]) {
            db=refdbs[name];
            if ((init)&&(db.init)) {
                if (db.xinits) db.xinits.push(init);
                else db.xinits=[init];}
            else if (init) db.init=init;
            else init={};}
        else if ((init)&&(init.aliases)&&(checkAliases(init.aliases))) {
            db=checkAliases(init.aliases);
            if (db.aliases.indexOf(db.name)>=0) db.name=name;
            if ((init)&&(db.init)) {
                if (db.xinits) db.xinits.push(init);
                else db.xinits=[init];}
            else if (init) db.init=init;
            else init={};}
        else {
            if (!(init)) init={};
            db.name=name; refdbs[name]=db; all_refdbs.push(db);
            db.aliases=[];
            db.complete=false; // Whether all valid refs are loaded
            db.refs={}; // Mapping _ids to refs (unique within the DB)
            db.altrefs={}; // Alternate unique IDs
            // An array of all references to this DB
            db.allrefs=[];
            // All loaded refs. This is used when declaring an onLoad
            //  method after some references have already been loaded
            db.loaded=[];
            // An array of changed references, together with the
            //  timestamp of the earliest change
            db.changes=[]; db.changed=false; 
            // Where to persist the data from this database
            db.storage=init.storage||false;
            // Whether _id fields for this database are globally unique
            db.absrefs=init.absrefs||false;
            // Whether _id fields for this database are OIDs (e.g. @xxx/xxx)
            db.oidrefs=init.oidrefs||false;
            // Handlers for loading refs from memory or network
            db.onload=[]; db.onloadnames={};
            // Rules to run when adding or dropping fields of references
            //  This doesn't happen on import, though.
            db.onadd={}; db.ondrop={}; 
            // This maps from field names to tables which map from
            //  keys to reference ids.
            db.indices={};}
        if (init.hasOwnProperty("absrefs")) db.absrefs=init.absrefs;
        if (init.aliases) {
            var aliases=init.aliases;
            var i=0, lim=aliases.length; while (i<lim) {
                var alias=aliases[i++];
                if (aliases[alias]) {
                    if (aliases[alias]!==db)
                        warn("Alias %s for %o already associated with %o",
                             alias,db,aliases[alias]);}
                else {
                    aliases[alias]=db;
                    db.aliases.push(alias);}}}
        if (init.onload) {
            var onload=init.onload;
            for (var methname in onload) {
                if (onload.hasOwnProperty(methname)) 
                    db.onLoad(onload[methname],methname);}}
        if (init.indices) {
            var index_specs=init.indices;
            var j=0, jlim=index_specs.length; while (j<jlim) {
                var ix=index_specs[j++];
                if (typeof ix !== "string") 
                    warn("Complex indices not yet handled!");
                else {
                    var index=this.indices[ix]=new ObjectMap();
                    index.fordb=db;}}}
        
        return db;}

    var REFINDEX=RefDB.REFINDEX=2;
    var REFLOAD=RefDB.REFLOAD=4;
    var REFSTRINGS=RefDB.REFSTRINGS=8;
    var default_flags=((REFINDEX)|(REFSTRINGS));

    function checkAliases(aliases){
        var i=0, lim=aliases.length;
        while (i<lim) {
            var alias=aliases[i++];
            var db=refdbs[alias];
            if (db) return db;}
        return false;}

    RefDB.open=function RefDBOpen(name,DBClass){
        if (!(DBClass)) DBClass=RefDB;
        return ((refdbs.hasOwnProperty(name))&&(refdbs[name]))||
            ((aliases.hasOwnProperty(name))&&(aliases[name]))||
            (new DBClass(name));};
    function refDBProbe(name){
        return ((refdbs.hasOwnProperty(name))&&(refdbs[name]))||
            ((aliases.hasOwnProperty(name))&&(aliases[name]))||
            false;}
    RefDB.probe=refDBProbe;
    RefDB.prototype.addAlias=function DBaddAlias(alias){
        if (aliases[alias]) {
            if (aliases[alias]!==this) 
                warn("Alias %s for %o already associated with %o",
                     alias,this,aliases[alias]);}
        else {
            aliases[alias]=this;
            this.aliases.push(alias);}};

    RefDB.prototype.toString=function (){
        return "RefDB("+this.name+")";};

    RefDB.prototype.ref=function DBref(id){
        if (typeof id !== "string") {
            if (id instanceof Ref) return id;
            else throw new Error("Not a reference");}
        else if ((id[0]===":")&&(id[1]==="@")) id=id.slice(1);
        var refs=this.refs;
        return ((refs.hasOwnProperty(id))&&(refs[id]))||
            ((this.refclass)&&(new (this.refclass)(id,this)))||
            (new Ref(id,this));};
    RefDB.prototype.probe=function DBprobe(id){
        if (typeof id !== "string") {
            if (id instanceof Ref) return id;
            else return false;}
        else if ((id[0]===":")&&(id[1]==="@")) id=id.slice(1);
        var refs=this.refs;
        return ((refs.hasOwnProperty(id))&&(refs[id]));};
    RefDB.prototype.drop=function DBdrop(refset){
        var count=0;
        var refs=this.refs; var altrefs=this.altrefs;
        if (!(id instanceof Array)) refset=[refset];
        var i=0, nrefs=refset.length; while (i<nrefs) {
            var ref=refset[i++]; var id;
            if (ref instanceof Ref) id=ref._id;
            else {id=ref; ref=this.probe(id);}
            if (!(ref)) continue; else count++;
            var aliases=ref.aliases;
            var pos=this.allrefs.indexOf(ref);
            if (pos>=0) this.allrefs.splice(pos,1);
            pos=this.changes.indexOf(ref);
            if (pos>=0) this.changes.splice(pos,1);
            pos=this.loaded.indexOf(ref);
            if (pos>=0) this.loaded.splice(pos,1);
            delete refs[id];
            if (this.storage instanceof Storage) {
                var storage=this.storage;
                var key="allids("+this.name+")";
                var allidsval=storage[key];
                var allids=((allidsval)&&(JSON.parse(allidsval)));
                var idpos=allids.indexOf(id);
                if (idpos>=0) {
                    allids.splice(idpos,1);
                    storage.setItem(key,JSON.stringify(allids));
                    storage.removeItem(id);}}
            if (aliases) {
                var j=0, jlim=aliases.length;
                while (j<jlim) {delete altrefs[aliases[j++]];}}}
        return count;};
    RefDB.prototype.clearOffline=function refDBclear(callback){
        if (!(this.storage)) return false;
        else if ((Storage)&&(this.storage instanceof Storage)) {
            var storage=this.storage;
            var key="allids("+this.name+")";
            var allids=this.storage[key];
            if (allids) allids=JSON.parse(allids);
            if (allids) {
                var i=0, lim=allids.length;
                while (i<lim) delete storage[allids[i++]];}
            delete storage[key];
            if (callback) setTimeout(callback,5);}
        else if (this.storage instanceof indexedDB) {
            // Not yet implemented
            return;}
        else return false;};

    RefDB.prototype.onLoad=function(method,name,noupdate){
        if ((name)&&(this.onloadnames[name])) {
            var cur=this.onloadnames[name];
            if (cur===method) return;
            var pos=this.onload.indexOf(cur);
            if (cur<0) {
                warn("Couldn't replace named onload method %s for <RefDB %s>",
                     name,this.name);
                return;}
            else {
                this.onload[pos]=method;}}
        else this.onload.push(method);
        if (name) this.onloadnames[name]=method;
        if (!(noupdate)) {
            var loaded=[].concat(this.loaded);
            fdjtAsync.slowmap(method,loaded);}};

    RefDB.prototype.onAdd=function(name,method){
        this.onadd[name]=method;};

    RefDB.prototype.onDrop=function(name,method){
        this.ondrop[name]=method;};
    
    var refpat=/^(((:|)@(([0-9a-fA-F]+\/[0-9a-fA-F]+)|(\/\w+\/.*)|(@\d+\/.*)))|((U|#U|:#U|)[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12})|((U|#U|:#U|)[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}t[0-9a-zA-Z]+)|([^@]+@.+))$/;
    
    var getLocal=fdjtState.getLocal;

    function resolveRef(arg,db,DBType,force){
        if (typeof DBType !== "function") DBType=RefDB;
        if (!(arg)) return arg;
        else if (arg instanceof Ref) return arg;
        else if ((typeof arg === "object")&&(arg.id))
            return object2ref(arg,db);
        else if ((db)&&(db.refs.hasOwnProperty(arg)))
            return db.refs[arg];
        // The case above catches direct references inline; the
        // case below does a function call (probe) and catches
        // aliases
        else if ((db)&&(db.probe(arg))) return db.probe(arg);
        else if ((typeof arg === "string")&&(refpat.exec(arg))) {
            var at=arg.indexOf('@');
            if ((at===1)&&(arg[0]===':')) {arg=arg.slice(1); at=0;}
            if (at>0) {
                // this is the term@domain form
                var usedb=false, dbname=arg.slice(at+1), origin;
                if ((usedb=refDBProbe(dbname))) {}
                else if (refpat.exec(dbname)) {
                    origin=resolveRef(dbname);
                    if (origin) force=true;
                    else dbname=arg.slice(at+1);}
                else dbname=arg.slice(at+1);
                if ((db)&&(db.name===dbname)) usedb=db;
                else usedb=refDBProbe(dbname);
                arg=arg.slice(0,at);
                if (usedb) db=usedb;
                else if (force) {
                    warn("Creating forced RefDB domain %s for reference %s",dbname,arg);
                    db=RefDB.open(dbname,DBType);}
                else db=refDBProbe(dbname);
                if ((db)&&(origin)) {
                    db.origin=origin;
                    if (origin.name) db.fullname=origin.name;}
                arg=arg.slice(0,at);}
            else if (at<0) {
                var uuid;
                if (arg.search(":#U")===0) uuid=arg.slice(3);
                else if (arg.search("#U")===0) uuid=arg.slice(2);
                else if (arg.search("U")===0) uuid=arg.slice(1);
                else uuid=arg;
                var type=uuid.indexOf('t'), tail=arg.length-2;
                if (type>0) type="UUID"+uuid.slice(type); else type=false;
                if (tail>0) tail="-UUIDTYPE="+uuid.slice(tail);
                else tail=false;
                var known_db=((type)&&(refdbs[type]||aliases[type]))||
                    ((tail)&&(refdbs[tail]||aliases[tail]));
                if (known_db) db=known_db;
                else if ((force)&&(type)&&(DBType)) {
                    warn("Creating forced RefDB domain %s for reference %s",type,arg);
                    db=new DBType(type);
                    if (type) db.addAlias(type);}
                else {}}
            else if (arg[1]==='@') {
                // This is for local references
                var idstart=arg.indexOf('/');
                var atid=arg.slice(0,idstart);
                var atdb=aliases[atid];
                if (atdb) db=atdb;
                else {
                    var domain=getLocal(arg.slice(0,idstart),true);
                    if (domain) {
                        db=new RefDB(domain,{aliases: [atid]});}
                    else {
                        warn("Can't find domain for atid %s when resolving %s",atid,arg);
                        db=false;}}}
            else {
                var atprefix, slash;
                // Find the slash before the ID
                if (arg[1]==='/') {
                    slash=arg.slice(2).indexOf('/');
                    if (slash>0) slash=slash+2;}
                else slash=arg.indexOf('/');
                atprefix=arg.slice(at,slash+1);
                db=refdbs[atprefix]||aliases[atprefix]||
                    ((DBType)&&(new DBType(atprefix)));}}
        else {}
        if (!(db)) return false;
        if (db.refs.hasOwnProperty(arg)) return (db.refs[arg]);
        else if (force) return db.ref(arg);
        else return false;}
    RefDB.resolve=resolveRef;
    RefDB.ref=resolveRef;

    function Ref(id,db,instance){
        // Just called for the prototype
        if (arguments.length===0) return this;
        var at=id.indexOf('@');
        if ((at>1)&&(id[at-1]!=='\\')) {
            var domain=id.slice(at+1);
            if ((domain!==db.name)&&
                (db.aliases.indexOf(domain)<0))
                warn("Reference to %s being handled by %s",id,db);
            id=id.slice(0,at);}
        if (db.refs.hasOwnProperty(id)) return db.refs[id];
        else if (instance) {
            instance._id=id; instance._db=db;
            if (!(db.absrefs)) instance._domain=db.name;
            db.refs[id]=instance;
            db.allrefs.push(instance);
            return instance;}
        else if ((db.refclass)&&(!(this instanceof db.refclass)))
            return new (db.refclass)(id,db);
        else {
            this._id=id; this._db=db;
            if (!(db.absrefs)) this._domain=db.name;
            db.refs[id]=this;
            db.allrefs.push(this);
            return this;}}
    fdjt.Ref=RefDB.Ref=Ref;

    Ref.prototype.toString=function(){
        if (this._qid) return this._qid;
        else if (this._domain)
            return this._id+"@"+this._domain;
        else if (this._db.absrefs) return this._id;
        else return this._id+"@"+this._db.name;};
    Ref.prototype.getQID=function getQID(){
        var qid;
        if (this._qid) return this._qid;
        else if (this._domain) 
            qid=this._qid=(this._id+"@"+this._domain);
        else if (this._db.absrefs) 
            qid=this._qid=this._id;
        else {
            qid=this._qid=(this._id+"@"+this._db.name);}
        return qid;};

    Ref.prototype.addAlias=function addRefAlias(term){
        var refs=this._db.refs;
        if (refs.hasOwnProperty(term)) {
            if (refs[term]===this) return false;
            else throw {error: "Ref alias conflict"};}
        else if (this._db.altrefs.hasOwnProperty(term)) {
            if (this._db.altrefs[term]===this) return false;
            else throw {error: "Ref alias conflict"};}
        else {
            this._db.altrefs[term]=this;
            return true;}};

    function object2ref(value,db,dbtype) {
        var ref, dbref=false; 
        if (value._domain)
            dbref=RefDB.probe(value._domain)||(new RefDB(value._domain));
        if (dbref) ref=dbref.ref(value._id);
        else ref=RefDB.resolve(value._id,db,(dbtype||RefDB),true);
        return ref;}

    Ref.prototype.Import=function refImport(data,rules,flags){
        var db=this._db; var live=this._live;
        var indices=db.indices; var onload=db.onload;
        var onadd=((live)&&(db.onadd)), ondrop=((live)&&(db.ondrop));
        var aliases=data.aliases;
        if (typeof flags === "undefined") flags=default_flags;
        if (typeof rules === "undefined")
            rules=this.import_rules||db.import_rules;
        var indexing=(((flags)&(REFINDEX))!==0);
        var loading=(((flags)&(REFLOAD))!==0);
        var refstrings=(((flags)&(REFSTRINGS))!==0);
        if (aliases) {
            var ai=0, alim=aliases.length; while (ai<alim) {
                var alias=aliases[ai++];
                var cur=((db.refs.hasOwnProperty(alias))&&
                         (db.refs[alias]))||
                    ((db.altrefs.hasOwnProperty(alias))&&
                     (db.altrefs[alias]));
                if ((cur)&&(cur!==this))
                    warn("Ambiguous ref %s in %s refers to both %o and %o",
                         alias,db,cur.name,this.name);
                else aliases[alias]=this;}}
        var now=fdjtTime();
        if ((loading)&&(!(this._live))) this._live=now;
        for (var key in data) {
            if ((key==="aliases")||(key==="_id")) {}
            else if (data.hasOwnProperty(key)) {
                var value=data[key]; var rule=((rules)&&(rules[key]));
                if (typeof value !== "undefined") {
                    if (rule) value=(rule)(this,key,value,data,indexing);
                    value=importValue(value,db,refstrings);}
                var oldval=((live)&&(this[key]));
                this[key]=value;
                if (oldval) {
                    var drops=difference(oldval,value||[]);
                    var adds=((value)?(difference(value,oldval)):([]));
                    if ((indexing)&&(indices[key])) { 
                        if (adds.length)
                            this.indexRef(key,adds,indices[key],db);
                        if (drops.length)
                            this.dropIndexRef(key,drops,indices[key],db);}
                    if ((adds.length)&&(onadd[key])) {
                        var addfn=onadd[key];
                        var addi=0, addlen=adds.length;
                        while (addi<addlen) {
                            addfn(adds[addi++]);}}
                    if ((drops.length)&&(ondrop[key])) {
                        var dropfn=ondrop[key];
                        var dropi=0, droplen=drops.length;
                        while (dropi<droplen) {
                            dropfn(drops[dropi++]);}}}
                else if ((value)&&(indexing)&&(indices[key])) 
                    this.indexRef(key,value,indices[key],db);}}
        // These are run-once inits loaded on initial import
        if (loading) {
            // Run the db-specific inits for each reference
            if (onload) {
                var i=0, lim=onload.length; while (i<lim) {
                    var loadfn=onload[i++];
                    loadfn(this,now);}}
            // Run per-instance delayed inits
            if (this._onload) {
                var onloads=this._onload, inits=onloads.fns;
                var j=0, jlim=inits.length; while (j<jlim) {
                    inits[j++](this,now);}
                delete this._onload;}}
        // Record a change if we're not loading and not already changed.
        if ((!(loading))&&(!(this._changed))) {
            this._changed=now;
            db.changes.push(this);
            if (!(db.changed)) {
                db.changed=now; db.changes.push(db);}}};
    function importValue(value,db,refstrings){
        if ((typeof value === "undefined")||
            (typeof value === "number")||
            (value=== null))
            return value;
        else if (value instanceof Ref) return value;
        else if (value instanceof Array) {
            var i=0, lim=value.length; var copied=false;
            while (i<lim) {
                var v=value[i++], nv=v;
                if (v===null) nv=undefined;
                else if (v instanceof Ref) nv=v;
                else if ((typeof v === "object")&&(v._id)) {
                    var ref=object2ref(v,db);
                    if (ref) {
                        for (var slot in v) {
                            if ((v.hasOwnProperty(slot))&&
                                (slot!=="_id")&&(slot!=="_db"))
                                ref[slot]=importValue(v[slot],db,refstrings);}
                        nv=ref;}}
                else if ((refstrings)&&(typeof v === "string")&&
                         (refpat.exec(v))) {
                    nv=resolveRef(v,db)||v;}
                if (typeof nv === "undefined") {
                    if (!(copied)) copied=value.slice(0,i-1);}
                else if (copied) copied.push(nv);
                else if (nv!==v) {
                    copied=value.slice(0,i-1);
                    copied.push(nv);}
                else {}}
            if (copied) return copied; else return value;}
        else if ((typeof value === "object")&&(value._id)) {
            var refv=object2ref(value,db);
            for (var vslot in value) {
                if ((value.hasOwnProperty(vslot))&&
                    (vslot!=="_id")&&(vslot!=="_db"))
                    refv[vslot]=importValue(value[vslot],db,refstrings);}
            return refv;}
        else if ((refstrings)&&(typeof value === "string")&&
                 (refpat.exec(value)))
            return resolveRef(value,db)||value;
        else return value;}
    Ref.prototype.importValue=function(value,refstrings){
        return importValue(this._db,value,refstrings);};
    RefDB.prototype.importValue=function(val,refstrings){
        return importValue(val,this,refstrings);};
    function defImport(item,refs,db,rules,flags){
        var ref=resolveRef(item._id,item._domain||db,
                           db.constructor,true);
        if (!(ref)) warn("Couldn't resolve database for %o",item._id);
        else {
            refs.push(ref);
            ref.Import(item,rules||false,flags);}}

    RefDB.prototype.Import=function refDBImport(data,rules,flags,callback){
        var refs=[]; var db=this;
        if (!(data instanceof Array)) {
            defImport(data,refs,db,rules,flags);
            if (callback) {
                if (callback.call) 
                    setTimeout(function(){callback(refs[0]);});
                return refs[0];}
            else return refs[0];}
        if ((!(callback))||(data.length<=7)) {
            var i=0, lim=data.length; while (i<lim) {
                defImport(data[i++],refs,db,rules,flags);}
            if ((callback)&&(callback.call)) 
                setTimeout(function(){callback(refs);},10);
            return refs;}
        else if (!(callback.call))
            fdjtAsync.slowmap(function(item){
                defImport(item,refs,db,rules,flags);},data);
        else fdjtAsync.slowmap(function(item){
            defImport(item,refs,db,rules,flags);},
                               data,
                               {done: function(){callback(refs);}});};

    Ref.prototype.onLoad=function(fn,name){
        if (this._live) fn(this);
        else if (this._onload) {
            if (this._onload[name]) return;
            if (name) this._onload[name]=fn;
            this._onload.fns.push(fn);}
        else {
            this._onload={fns:[fn]};
            if (name) this._onload[name]=fn;}};
    
    Ref.Export=Ref.prototype.Export=function refExport(xforms){
        var db=this._id;
        var exported={_id: this._id};
        if (!(xforms)) xforms=this.export_rules||db.export_rules;
        if (!(db.absrefs)) this._domain=db.name;
        for (var key in this) {
            if (key[0]==="_") continue;
            else if (this.hasOwnProperty(key)) {
                var value=this[key];
                var xform=((xforms)&&(xforms[key]));
                if (xform) value=xform(value,key,exported);
                if (typeof value === "undefined") {}
                else if ((typeof value === "number")||
                         (typeof value === "string"))
                    exported[key]=value;
                else if (value instanceof Ref) {
                    if (value._db.absrefs)
                        exported[key]={_id: value._id};
                    else exported[key]={
                        _id: value._id,
                        _domain: value._domain||value._db.name};}
                else exported[key]=exportValue(value,this._db);}}
        return exported;};

    function exportValue(value,db){
        if (value instanceof Ref) {
            if (value._db===db) return {_id: value._id};
            else if (value._db.absrefs) return {_id: value._id};
            else return {
                _id: value._id,
                _domain: value._domain||value._db.name};}
        else if (value instanceof Array) {
            var i=0, lim=value.length; var exports=false;
            while (i<lim) {
                var elt=value[i++];
                var exported=exportValue(elt,db);
                if (elt!==exported) {
                    if (exports) exports.push(exported);
                    else {
                        exports=value.slice(0,i-1);
                        exports.push(exported);}}
                else if (exports) exports.push(elt);
                else {}}
            return exports||value;}
        else if (typeof value === "object") {
            var copied=false, fields=[];
            for (var field in value) {
                if (value.hasOwnProperty(field)) {
                    var fieldval=value[field];
                    var exportval=exportValue(fieldval,db);
                    if (fieldval!==exportval) {
                        if (!(copied)) {
                            copied={};
                            if (fields.length) {
                                var j=0, jlim=fields.length;
                                while (j<jlim) {
                                    var f=fields[j++];
                                    copied[f]=value[f];}}}
                        copied[field]=exportval;}
                    else if (copied) copied[field]=fieldval;
                    else fields.push(field);}}
            return copied||value;}
        else return value;}
    Ref.exportValue=exportValue;
    RefDB.prototype.exportValue=function(val){
        return exportValue(val,this);};
    
    RefDB.prototype.load=function loadRefs(refs,callback,args){
        function docallback(){
            if (callback) {
                if (args) callback.apply(null,args);
                else callback();}}
        function load_ref(arg,loaded,storage){
            var ref=arg, content;
            if (typeof ref === "string")
                ref=db.ref(ref,false,true);
            if (!(ref)) {
                warn("Couldn't resolve ref to %s",arg);
                return;}
            else if (ref._live) return;
            loaded.push(ref);
            if (absrefs) content=storage[ref._id];
            else if (atid)
                content=storage[atid+"("+ref._id+")"];
            else {
                if (db.atid) atid=db.atid;
                else atid=db.atid=getatid(storage,db);
                content=storage[atid+"("+ref._id+")"];}
            if (!(content))
                warn("No item stored for %s",ref._id);
            else ref.Import(
                JSON.parse(content),false,REFLOAD|REFINDEX);}
        if (!(this.storage)) return;
        else if (this.storage instanceof Storage) {
            if (!(refs)) refs=[].concat(this.allrefs);
            else if (refs===true) {
                var all=this.storage["allids("+this.name+")"];
                if (all) refs=JSON.parse(all).concat(this.allrefs);
                else refs=[].concat(this.allrefs);}
            else if (refs instanceof Ref) refs=[refs];
            else if (typeof refs === "string") refs=[refs];
            else if (typeof refs.length === "undefined") refs=[refs];
            else {}
            var storage=this.storage; var loaded=this.loaded;
            var db=this, absrefs=this.absrefs, refmap=this.refs;
            var atid=false; var needrefs=[];
            var i=0, lim=refs.length; while (i<lim) {
                var refid=refs[i++], ref=refid;
                if (typeof refid === "string") ref=refmap[refid];
                if (!((ref instanceof Ref)&&(ref._live)))
                    needrefs.push(refid);}
            if (needrefs.length) {
                var opts=((!(callback))?(false):
                          (args)?{done: docallback}:{done: callback});
                return fdjtAsync.slowmap(
                    function(arg){load_ref(arg,loaded,storage);},
                    needrefs,opts);}
            else {
                docallback();
                return new Promise(function(resolve){
                    resolve(refs);});}}
        else if (this.storage instanceof indexedDB) {
            // Not yet implemented
            return;}
        else {}};
    RefDB.prototype.load=function loadRefs(refs){
        if (this.storage instanceof Storage) 
            return this.loadFromStorage(refs);
        else return false;};
    RefDB.prototype.loadFromStorage=function loadFromStorage(refs){
        var db=this, storage=this.storage, loaded=this.loaded;
        var atid=(db.atid)||(db.atid=getatid(storage,db));
        var needrefs=[], refmap=db.refs, absrefs=db.absrefs;
        function storage_loader(arg,loaded){
            var ref=arg, content;
            if (typeof ref === "string") ref=db.ref(ref,false,true);
            if (!(ref)) {warn("Couldn't resolve ref to %s",arg); return;}
            else if (ref._live) return;
            else {}
            if (absrefs) content=storage[ref._id];
            else if (atid) content=storage[atid+"("+ref._id+")"];
            else content=storage[atid+"("+ref._id+")"];
            if (content) {
                loaded.push(ref);
                ref.Import(JSON.parse(content),false,REFLOAD|REFINDEX);}}
        if (!(refs)) refs=[].concat(db.allrefs);
        else if (refs===true) {
            var all=storage["allids("+db.name+")"]||"[]";
            refs=JSON.parse(all).concat(db.allrefs);}
        else if (!(Array.isArray(refs))) refs=[refs];
        else {}
        var i=0, lim=refs.length; while (i<lim) {
            var refid=refs[i++], ref=refid;
            if (typeof refid === "string") ref=refmap[refid];
            if (!((ref instanceof Ref)&&(ref._live)))
                needrefs.push(refid);}
        if (needrefs.length)
            return fdjtAsync.slowmap(
                function(arg){storage_loader(arg,loaded,storage);},
                needrefs);
        else return new Promise(function(resolve){
            var resolved=[]; var i=0, lim=refs.length;
            while (i<lim) {
                var refid=refs[i++];
                if (typeof ref==="string")
                    ref=refmap[refid]; else ref=refid;
                resolved.push(ref);}
            return resolve(resolved);});};

    RefDB.prototype.loadref=function loadRef(ref){
        if (typeof ref === "string") ref=this.ref(ref);
        return ref.load();};
    Ref.prototype.load=function loadRef() {
        var ref=this, db=this._db;
        function loadref(resolve){
            if (ref._live) return resolve(ref);
            else db.load(ref).then(function(){resolve(ref);});}
        return new Promise(loadref);};

    // This does a resolve and load for various refs
    RefDB.load=function RefDBload(spec,dbtype,callback,args){
        if (typeof spec === "string") {
            var ref=RefDB.resolve(spec,false,(dbtype||RefDB),true);
            if (ref) return ref.load(callback,args);
            else throw {error: "Couldn't resolve "+spec};}
        else if (spec instanceof Ref)
            return spec.load(callback,args);
        else if (spec instanceof Array) {
            var loads={}, dbs=[]; var i=0, lim=spec.length;
            while (i<lim) {
                var s=spec[i++]; var r=false;
                if (typeof s === "string")
                    r=RefDB.resolve(s,false,dbtype||RefDB,true);
                else if (s instanceof Ref) r=s;
                if (!(r)||(r._live)) continue;
                var db=r._db, name=db.name;
                if (loads[name]) loads[name].push(r);
                else {
                    loads[name]=[r];
                    dbs.push(db);}}
            i=0; lim=dbs.length; while (i<lim) {
                var loadfrom=dbs[i++];
                loadfrom.load(loads[loadfrom.name],args);}
            return loads;}
        else return false;};
    
    RefDB.prototype.saveToStorage=function(refs,updatechanges){
        var db=this, storage=this.storage;
        var atid=this.atid; var ids=[];
        function savingLocally(resolve){
            var i=0, lim=refs.length; while (i<lim) {
                var ref=refs[i++];
                if (typeof ref === "string") ref=db.ref(ref);
                if (!(ref._live)) continue;
                if ((ref._saved)&&(!(ref._changed))) continue;
                var exported=ref.Export();
                exported._saved=fdjtTime.tick();
                if (db.absrefs) {
                    ids.push(ref._id);
                    storage.setItem(ref._id,JSON.stringify(exported));}
                else {
                    if (atid) {}
                    else if (ref.atid) atid=ref.atid;
                    else atid=ref.atid=getatid(storage,ref);
                    var id=atid+"("+ref._id+")"; ids.push(id);
                    storage.setItem(id,JSON.stringify(exported));}
                ref._changed=false;}
            if (updatechanges) {
                var changes=db.changes, new_changes=[];
                var j=0, n_changed=changes.length;
                while (j<n_changed) {
                    var c=changes[j++];
                    if (c._changed) new_changes.push(c);}
                db.changes=new_changes;
                if (new_changes.length===0) {
                    db.changed=false;
                    var pos=changed_dbs.indexOf(db);
                    if (pos>=0) changed_dbs.splice(pos,1);}}
            var allids=storage["allids("+db.name+")"];
            if (allids) allids=JSON.parse(allids); else allids=[];
            var n=allids.length;
            allids=merge(allids,ids);
            if (allids.length!==n) 
                storage.setItem("allids("+db.name+")",
                                JSON.stringify(allids));
            if (resolve) fdjt.ASync(resolve);}
        return new Promise(savingLocally);};
    
    RefDB.prototype.save=function saveRefs(refs,updatechanges){
        var db=this, storage=this.storage;
        if (refs===true) refs=this.allrefs;
        else if (!(refs)) refs=this.changes;
        else {}
        function saving(resolve){
            if (db.storage instanceof Storage)
                db.saveToStorage(refs,updatechanges).then(function(){
                    db.changed=false;
                    db.changes=[];
                    var pos=changed_dbs.indexOf(db);
                    if (pos>=0) changed_dbs.splice(pos,1);
                    if (resolve) resolve();});
            else if (db.storage instanceof indexedDB) {}
            else return resolve();}
        if (!(storage)) return false;
        else return new Promise(saving);};
    Ref.prototype.save=function(){
        var ref=this, db=this._db;
        function saveref(resolve){
            if (!(ref._changed)) return resolve(ref);
            else return db.save([ref]).then(function(){
                resolve(ref);});}
        return new Promise(saveref);};

    function getatid(storage,db){
        if (db.atid) return db.atid;
        var atid=storage["atid("+db.name+")"];
        if (atid) {
            db.atid=atid;
            return atid;}
        else {
            var count=storage["atid.count"];
            if (!(count)) {
                atid=count=1; storage["atid.count"]="2";}
            else {
                count=parseInt(count,10);
                atid=db.atid="@@"+count;
                storage["atid("+db.name+")"]=atid;
                storage["atid.count"]=count+1;}
            return atid;}}
    
    function getKeyString(val,db){
        if (val instanceof Ref) {
            if (val._db===db) return "@"+val._id;
            else if (val._domain) return "@"+val._id+"@"+val._domain;
            else return "@"+val._id;}
        else if (typeof val === "number") 
            return "#"+val;
        else if (typeof val === "string")
            return "\""+val;
        else if (val.toJSON)
            return "{"+val.toJSON();
        else return "&"+val.toString();}
    RefDB.getKeyString=getKeyString;
    
    Ref.prototype.indexRef=function indexRef(key,val,index,db){
        var keystrings=[]; var rdb=this._db;
        var refstring=
            (((!(db))||(rdb===db)||(rdb.absrefs))?(this._id):
             ((this._qid)||((this.getQID)&&(this.getQID()))));
        if (!(db)) db=rdb;
        var indices=db.indices;
        if (!(index))
            index=((indices.hasOwnProperty(key))&&(indices[key]));
        if (!(index)) {
            warn("No index on %s for %o in %o",key,this,db);
            return false;}
        if (val instanceof Ref) {
            if (rdb===val._db) keystrings=["@"+val._id];
            else keystrings=["@"+(val._qid||val.getQID())];}
        else if (val instanceof Array) {
            db=this._db;
            var i=0, lim=val.length; while (i<lim) {
                var elt=val[i++];
                if (elt instanceof Ref)
                    keystrings.push("@"+(elt._qid||elt.getQID()));
                else if (typeof elt === "number") 
                    keystrings=["#"+elt];
                else if (typeof elt === "string")
                    keystrings=["\""+elt];
                else if (elt._qid)
                    keystrings.push("@"+(elt._qid||elt.getQID()));
                else if (elt.getQID)
                    keystrings.push("@"+(elt.getQID()));
                else {}}}
        else if (typeof val === "number") 
            keystrings=["#"+val];
        else if (typeof val === "string")
            keystrings=["\""+val];
        else keystrings=["?"+val.toString()];
        if (keystrings.length) {
            var j=0, jlim=keystrings.length; while (j<jlim) {
                var keystring=keystrings[j++];
                var refs=index[keystring];
                if (refs) refs.push(refstring);
                else index[keystring]=[refstring];}
            return keystrings.length;}
        else return false;};
    Ref.prototype.dropIndexRef=function dropIndexRef(key,val,index,db){
        if (!(db)) db=this._db;
        if (!(index)) index=db.indices[key];
        if (!(index)) return false;
        var keystrings=[];
        if (val instanceof Ref) {
            if (this._db===val._db) keystrings=["@"+val._id];
            else keystrings=["@"+(val._qid||val.getQID())];}
        else if (val instanceof Array) {
            var i=0, lim=val.length; while (i<lim) {
                var elt=val[i++];
                if (elt instanceof Ref) 
                    keystrings.push("@"+(elt._qid||elt.getQID()));
                else if (typeof elt === "number") 
                    keystrings=["#"+val];
                else if (typeof elt === "string")
                    keystrings=["\""+val];
                else if (elt._qid)
                    keystrings.push("@"+(elt._qid||elt.getQID()));
                else if (elt.getQID)
                    keystrings.push("@"+(elt.getQID()));
                else {}}}
        else if (typeof val === "number") 
            keystrings=["#"+val];
        else if (typeof val === "string")
            keystrings=["\""+val];
        else {}
        if (keystrings.length) {
            var deleted=0;
            var j=0, jlim=keystrings.length; while (j<jlim) {
                var keystring=keystrings[j++]; var refs=index[keystring];
                if (!(refs)) continue;
                var pos=refs.indexOf(this._id);
                if (pos<0) continue;
                else refs.splice(pos,1);
                if (refs.length===0) delete index[keystring];
                deleted++;}
            return deleted;}
        else return false;};

    RefDB.prototype.find=function findIDs(key,value){
        var index=this.indices[key];
        if (index) {
            var items=index.getItem(value,this);
            if (items) return setify(items);
            else return [];}
        else return [];};
    RefDB.prototype.findRefs=function findRefs(key,value){
        var index=this.indices[key];
        if (index) {
            var items=index.getItem(value,this), results=[];
            if (items) {
                var i=0, lim=items.length;
                while (i<lim) {
                    var item=items[i++];
                    if (!(item)) {}
                    else if (typeof item === "string") {
                        var ref=this.probe(item);
                        if (ref) results.push(ref);}
                    else results.push(item);}}
            return fdjtSet(results);}
        else return [];};
    RefDB.prototype.count=function countRefs(key,value){
        var index=this.indices[key];
        if (index) {
            var vals=index.getItem(value,this);
            return ((vals)?(vals.length||0):(0));}
        else return 0;};
    RefDB.prototype.addIndex=function addIndex(key,Constructor){
        if (!(Constructor)) Constructor=ObjectMap;
        if (!(this.indices.hasOwnProperty(key))) {
            var index=this.indices[key]=new Constructor();
            index.fordb=this;
            return index;}
        else return this.indices[key];};
    
    // Array utility functions
    function arr_contains(arr,val,start){
        return (arr.indexOf(val,start||0)>=0);}
    function arr_position(arr,val,start){
        return arr.indexOf(val,start||0);}

    var id_counter=1;

    /* Fast sets */
    function set_sortfn(a,b) {
        if (a===b) return 0;
        else if (typeof a === typeof b) {
            if (typeof a === "number")
                return a-b;
            else if (typeof a === "string") {
                if (a<b) return -1;
                else return 1;}
            else if (a._qid) {
                if (b._qid) {
                    if (a._qid<b._qid) return -1;
                    else return 1;}
                else return -1;}
            else if (b._qid) return 1;
            else if ((a._fdjtid)&&(b._fdjtid)) {
                if ((a._fdjtid)<(b._fdjtid)) return -1;
                else return 1;}
            else return 0;}
        else if (typeof a < typeof b) return -1;
        else return 1;}
    RefDB.compare=set_sortfn;

    function intersection(set1,set2){
        if (typeof set1 === 'string') set1=[set1];
        if (typeof set2 === 'string') set2=[set2];
        if ((!(set1))||(set1.length===0)) return [];
        if ((!(set2))||(set2.length===0)) return [];
        if (set1._sortlen!==set1.length) set1=fdjtSet(set1);
        if (set2._sortlen!==set2.length) set2=fdjtSet(set2);
        var results=[];
        var i=0; var j=0; var len1=set1.length; var len2=set2.length;
        var allstrings=set1._allstrings&&set2._allstrings;
        var new_allstrings=true;
        while ((i<len1) && (j<len2))
            if (set1[i]===set2[j]) {
                if ((new_allstrings)&&(typeof set1[i] !== 'string'))
                    new_allstrings=false;
                results.push(set1[i]);
                i++; j++;}
        else if ((allstrings)?
                 (set1[i]<set2[j]):
                 (set_sortfn(set1[i],set2[j])<0)) i++;
        else j++;
        results._allstrings=new_allstrings;
        results._sortlen=results.length;
        return results;}
    RefDB.intersection=intersection;

    function difference(set1,set2){
        if (typeof set1 === 'string') set1=[set1];
        if (typeof set2 === 'string') set2=[set2];
        if ((!(set1))||(set1.length===0)) return [];
        if ((!(set2))||(set2.length===0)) return set1;
        if (set1._sortlen!==set1.length) set1=fdjtSet(set1);
        if (set2._sortlen!==set2.length) set2=fdjtSet(set2);
        var results=[];
        var i=0; var j=0; var len1=set1.length; var len2=set2.length;
        var allstrings=set1._allstrings&&set2._allstrings;
        var new_allstrings=true;
        while ((i<len1) && (j<len2)) {
            if (set1[i]===set2[j]) {
                i++; j++;}
            else if ((allstrings)?
                     (set1[i]<set2[j]):
                     (set_sortfn(set1[i],set2[j])<0)) {
                if ((new_allstrings)&&(typeof set1[i] !== 'string'))
                    new_allstrings=false;
                results.push(set1[i]);
                i++;}
            else j++;}
        if ((!(new_allstrings))||(set1._allstrings)) 
            results=results.concat(set1.slice(i));
        else while (i<len1) {
            var elt=set1[i++];
            if ((new_allstrings)&&(typeof elt !== "string"))
                new_allstrings=false;
            results.push(elt);}
        results._allstrings=new_allstrings;
        results._sortlen=results.length;
        return results;}
    RefDB.difference=difference;
    
    function union(set1,set2){
        if (typeof set1 === 'string') set1=[set1];
        if (typeof set2 === 'string') set2=[set2];
        if ((!(set1))||(set1.length===0)) return set2;
        if ((!(set2))||(set2.length===0)) return set1;
        if (set1._sortlen!==set1.length) set1=fdjtSet(set1);
        if (set2._sortlen!==set2.length) set2=fdjtSet(set2);
        var results=[];
        var i=0; var j=0; var len1=set1.length; var len2=set2.length;
        var allstrings=set1._allstrings&&set2._allstrings;
        while ((i<len1) && (j<len2))
            if (set1[i]===set2[j]) {
                results.push(set1[i]); i++; j++;}
        else if ((allstrings)?
                 (set1[i]<set2[j]):
                 (set_sortfn(set1[i],set2[j])<0))
            results.push(set1[i++]);
        else results.push(set2[j++]);
        while (i<len1) results.push(set1[i++]);
        while (j<len2) results.push(set2[j++]);
        results._allstrings=allstrings;
        results._sortlen=results.length;
        return results;}
    RefDB.union=union;

    function merge(set1,set2){
        var merged=[]; merged._sortlen=0;
        if (!(set1 instanceof Array)) set1=[set1];
        if (!(set2 instanceof Array)) set2=[set2];
        if ((!(set1))||(set1.length===0)) {
            if ((!(set2))||(set2.length===0)) return merged;
            merged=merged.concat(set2);
            if (set2._sortlen) {
                merged._sortlen=set2._sortlen;
                merged._allstrings=set2._allstrings;
                return merged;}
            else return setify(merged);}
        else if ((!(set2))||(set2.length===0))
            return merge(set2,set1);
        if (set1._sortlen!==set1.length) set1=setify(set1);
        if (set2._sortlen!==set2.length) set2=setify(set2);
        var i=0; var j=0; var len1=set1.length; var len2=set2.length;
        var allstrings=set1._allstrings&&set2._allstrings;
        while ((i<len1) && (j<len2))
            if (set1[i]===set2[j]) {
                merged.push(set1[i]); i++; j++;}
        else if ((allstrings)?
                 (set1[i]<set2[j]):
                 (set_sortfn(set1[i],set2[j])<0))
            merged.push(set1[i++]);
        else merged.push(set2[j++]);
        while (i<len1) merged.push(set1[i++]);
        while (j<len2) merged.push(set2[j++]);
        merged._allstrings=allstrings;
        merged._sortlen=merged.length;
        return merged;}
    RefDB.merge=merge;

    function overlaps(set1,set2){
        if (typeof set1 === 'string') set1=[set1];
        if (typeof set2 === 'string') set2=[set2];
        if ((!(set1))||(set1.length===0)) return false;
        if ((!(set2))||(set2.length===0)) return false;
        if (set1._sortlen!==set1.length) set1=fdjtSet(set1);
        if (set2._sortlen!==set2.length) set2=fdjtSet(set2);
        var i=0; var j=0; var len1=set1.length; var len2=set2.length;
        var allstrings=set1._allstrings&&set2._allstrings;
        while ((i<len1) && (j<len2))
            if (set1[i]===set2[j]) return true;
        else if ((allstrings)?
                 (set1[i]<set2[j]):
                 (set_sortfn(set1[i],set2[j])<0)) i++;
        else j++;
        return false;}
    RefDB.overlaps=overlaps;

    /* Sets */
    /* sets are really arrays that are sorted to simplify
       set operations.  the ._sortlen property tells how
       much of the array is sorted */
    function fdjtSet(arg){
        var result=[]; result._sortlen=0;
        if (arguments.length===0) return result;
        else if (arguments.length===1) {
            if (!(arg)) return result;
            else if (arg instanceof Array) {
                if ((!(arg.length))||(arg._sortlen===arg.length))
                    return arg;
                else if (typeof arg._sortlen === "number")
                    return setify(arg);
                else return setify([].concat(arg));}
            else {
                result=[arg]; 
                if (typeof arg === 'string') result._allstrings=true;
                result._sortlen=1;
                return result;}}
        else {
            result=[];
            for (arg in arguments)
                if (!(arg)) {}
            else if (arg instanceof Array)
                result=result.concat(arg);
            else result.push(arg);
            return setify(result);}}
    RefDB.Set=fdjtSet;
    fdjt.Set=fdjtSet;
    RefDB.toSet=fdjtSet;

    function setify(array) {
        var len;
        if (array._sortlen===(len=array.length)) return array;
        // else if ((array._sortlen)&&(array._sortlen>1))
        else if (len===0) {
            array._sortlen=0;
            return array;}
        else if (len===1) {
            var elt1=array[0];
            array._sortlen=1;
            array._allstrings=(typeof elt1 === 'string');
            if (typeof elt === "object") {
                if ((elt1._qid)||(elt1._fdjtid)) {}
                else if (elt1.getQID) elt1._qid=elt1.getQID();
                else elt1._fdjtid=++id_counter;}
            return array;}
        else {
            var allstrings=true;
            var i=0, lim=array.length;
            while (i<lim) {
                var elt=array[i++];
                if ((allstrings)&&(typeof elt !== 'string')) {
                    allstrings=false;
                    if (typeof elt === "object") {
                        if ((elt._qid)||(elt._fdjtid)) {}
                        else if (elt.getQID) elt._qid=elt.getQID();
                        else elt._fdjtid=++id_counter;}}}
            array._allstrings=allstrings;
            if (lim===1) return array;
            if (allstrings) array.sort();
            else array.sort(set_sortfn);
            // Now remove duplicates
            var read=1; var write=1; var readlim=array.length;
            var cur=array[0];
            while (read<readlim) {
                if (array[read]!==cur) {
                    array[write++]=cur=array[read++];}
                else read++;}
            array._sortlen=array.length=write;
            return array;}}
    
    function set_add(set,val) {
        if (val instanceof Array) {
            var changed=false;
            for (var elt in val) 
                if (set_add(set,elt)) changed=true;
            return changed;}
        else if (set.indexOf) {
            var pos=set.indexOf(val);
            if (pos>=0) return false;
            else set.push(val);
            return true;}
        else {
            var i=0; var lim=set.length;
            while (i<lim)
                if (set[i]===val) return false; else i++;
            if (typeof val !== 'string') set._allstrings=false;
            set.push(val);
            return true;}}
    
    function set_drop(set,val) {
        if (val instanceof Array) {
            var changed=false;
            for (var elt in val)
                if (set_drop(set,elt)) changed=true;
            return changed;}
        else if (set.indexOf) {
            var pos=set.indexOf(val);
            if (pos<0) return false;
            else set.splice(pos,1);
            return true;}
        else {
            var i=0; var lim=set.length;
            while (i<lim)
                if (set[i]===val) {
                    set.splice(i,1);
                    return true;}
            else i++;
            return false;}}
    
    /* Refs */

    Ref.prototype.get=function refGet(prop){
        if (this.hasOwnProperty(prop)) return this[prop];
        else if (this._live) return false;
        else return undefined;};
    Ref.prototype.getSet=function refGetSet(prop){
        if (this.hasOwnProperty(prop)) {
            var val=this[prop];
            if (val instanceof Array) {
                if (val._sortlen===val.length) return val;
                else return setify(val);}
            else return setify([val]);}
        else if (this._live) return [];
        else return undefined;};
    Ref.prototype.getArray=function refGetArray(prop){
        if (this.hasOwnProperty(prop)) {
            var val=this[prop];
            if (val instanceof Array) return val;
            else return [val];}
        else if (this._live) return [];
        else return undefined;};
    Ref.prototype.getValue=function refGet(prop){
        var ref=this; function getting(resolve,reject){
            if (ref.hasOwnProperty(prop))
                return resolve(ref[prop]);
            else if (ref._live) return resolve(undefined);
            else if (ref._db.storage)
                return ref.load().then(function(r){
                    return resolve(r[prop]);})
                .catch(reject);
            else return resolve(undefined);}
        return new Promise(getting);};
    function setCall(fn,val){
        if (Array.isArray(val)) {
            if ((val._sortlen)&&(val._sortlen===val.length))
                return fn(val);
            else return fn(setify(val));}
        else return fn([val]);}
    Ref.prototype.getValues=function refGet(prop){
        var ref=this;
        function getting(resolve,reject){
            ref.getValue(prop).then(function(val){
                return setCall(resolve,val);})
                .catch(reject);}
        return new Promise(getting);};

    Ref.prototype.add=function refAdd(prop,val,index){
        var ref=this, db=this._db;
        function handle_add(resolved){
            if ((val instanceof Array)&&
                (typeof val._sortlen === "number")) {
                var i=0, lim=val.length; while (i<lim) {
                    ref.add(prop,val[i++],index);}}
            else if (prop==="aliases") {
                if ((db.refs[val]===ref)||
                    (db.altrefs[val]===ref))
                    return ((resolved)&&(resolved(false)));
                else {
                    db.altrefs[val]=ref;
                    if (ref.aliases) ref.aliases.push(val);
                    else ref.aliases=[val];
                    return (resolved)&&(resolved(true));}}
            else if (ref.hasOwnProperty(prop)) {
                var cur=ref[prop];
                if (cur===val)
                    return (resolved)&&(resolved(false));
                else if (cur instanceof Array) {
                    if (!(set_add(cur,val)))
                        return (resolved)&&(resolved(false));
                    else {}}
                else ref[prop]=fdjtSet([cur,val]);}
            else if ((val instanceof Array)&&
                     (typeof val._sortlen !== "number"))
                ref[prop]=fdjtSet([val]);
            else ref[prop]=val;
            // If we've gotten through to here, we've made a change,
            //  so we update the change structures, run any add methods
            //  and index if appropriate
            if (!(ref._changed)) {
                var now=fdjtTime();
                if (!(db.changed)) changed_dbs.push(db);
                db.changed=now;
                ref._changed=now;
                db.changes.push(ref);}
            if (db.onadd.hasOwnProperty(prop))
                (db.onadd[prop])(ref,prop,val);
            if ((index)&&(db.indices[prop]))
                ref.indexRef(prop,ref[prop],db.indices[prop]);
            if (resolved) resolved(true);}
        function add_onload(){handle_add(false);}
        if (typeof index === "undefined") {
            if (db.indices.hasOwnProperty(prop)) index=true;
            else index=false;}
        else if ((index)&&(!(db.indices.hasOwnProperty(prop)))) {
            // fdjtLog("Creating index on %s for %o",prop,db);
            db.addIndex(prop);}
        else {}
        if ((val instanceof Array)&&(val._sortlen===0))
            return new Promise(function(resolve){return resolve(false);});
        else if ((!(this._live))&&(this._db.storage)) {
            if (this._onload) this._onload.push(add_onload);
            else this._onload=[add_onload];
            return this.load();}
        else return new Promise(handle_add);};
    Ref.prototype.drop=function refDrop(prop,val,dropindex){
        var ref=this, db=this._db;
        function handle_drop(resolved){
            if (ref.hasOwnProperty(prop)) {
                var cur=ref[prop];
                if (cur===val) delete ref[prop];
                else if (cur instanceof Array) {
                    if (!(set_drop(cur,val)))
                        return (resolved)&&(resolved(false));
                    if (cur.length===0) delete ref[prop];}
                else return (resolved)&&(resolved(false));}
            else return (resolved)&&(resolved(false));
            if (db.ondrop.hasOwnProperty(prop)) 
                (db.ondrop[prop])(ref,prop,val);
            if (!(ref._changed)) {
                var now=fdjtTime();
                if (db.changed) {db.changed=now; changed_dbs.push(db);}
                ref._changed=now;
                db.changes.push(ref);}
            if ((dropindex)&&(db.indices[prop])) 
                ref.indexRefDrop(prop,db.indices[prop]);
            return (resolved)&&(resolved(true));}
        function drop_onload(){handle_drop(false);}
        if (typeof dropindex === "undefined") dropindex=true;
        if (prop==='_id')
            return new Promise(function(resolved){resolved(false);});
        else if ((!(this._live))&&(this._db.storage)) {
            if (this._onload) this._onload.push(drop_onload);
            else this._onload=[drop_onload];
            return this.load();}
        else return new Promise(handle_drop);};
    Ref.prototype.test=function(prop,val){
        if (this.hasOwnProperty(prop)) {
            if (typeof val === 'undefined') return true;
            var cur=this[prop];
            if (cur===val) return true;
            else if (cur instanceof Array) {
                if (arr_contains(cur,val)) return true;
                else if (this._live) return false;
                else return undefined;}
            else if (this._live) return false;
            else return undefined;}
        else if (this._live) return false;
        else return undefined;};
    Ref.prototype.store=function(prop,val){
        var toadd=[], todrop=[];
        if (this.hasOwnProperty(prop)) {
            var cur=this[prop];
            if (cur===val) return false;
            else {
                toadd=difference(val,cur);
                todrop=difference(cur,val);}}
        else if (val instanceof Array)
            toadd=val;
        else toadd=[val];
        var i=0, lim=todrop.length;
        while (i<lim) this.drop(prop,todrop[i++]);
        i=0; lim=toadd.length; while (i<lim) this.add(prop,toadd[i++]);
        return true;};

    Ref.prototype.toHTML=function(){
        var dom=false;
        return ((this._db.forHTML)&&(this._db.forHTML(this)))||
            ((this._db.forDOM)&&(dom=this._db.forDOM(this))&&
             (dom.outerHTML))||
            this._id||this.oid||this.uuid;};
    Ref.prototype.toDOM=function(){
        return ((this._db.forDOM)&&(this._db.forDOM(this)))||
            ((this._db.forHTML)&&(fdjtDOM(this._db.forHTML(this))))||
            (fdjtDOM("span.fdjtref",this._id||this.oid||this.uuid));};

    /* Maps */

    function ObjectMap() {return this;}
    ObjectMap.prototype.get=function ObjectMapGet(key) {
        var keystring=getKeyString(key,this.fordb);
        if (this.hasOwnProperty(keystring))
            return this[keystring];
        else if (typeof key === "string")
            // This is helpful for debugging
            return this[key]||this["@"+key];
        else return undefined;};
    ObjectMap.prototype.getItem=ObjectMap.prototype.get;
    ObjectMap.prototype.set=function(key,val) {
        var keystring=getKeyString(key,this.fordb);
        if (val instanceof Array)
            this[keystring]=[val];
        else this[keystring]=val;};
    ObjectMap.prototype.setItem=ObjectMap.prototype.set;
    ObjectMap.prototype.increment=function(key,delta) {
        var keystring=getKeyString(key,this.fordb);
        var cur=this[keystring], next;
        if (cur) this[keystring]=next=cur+delta;
        else this[keystring]=next=delta;
        return next;};
    ObjectMap.prototype.add=function(key,val) {
        var keystring=getKeyString(key,this.fordb);
        if (this.hasOwnProperty(keystring)) {
            var cur=this[keystring];
            if (cur===val) return false;
            else if (cur instanceof Array) {
                if (arr_contains(cur,val)) return false;
                else {cur.push(val); return true;}}
            else if (val instanceof Array) {
                this[keystring]=setify([cur,val]);
                return true;}
            else {
                this[keystring]=setify([cur,val]);
                return true;}}
        else if (val instanceof Array) 
            this[keystring]=setify([val]);
        else this[keystring]=val;};
    ObjectMap.prototype.drop=function(key,val) {
        var keystring=getKeyString(key,this.fordb);
        if (this.hasOwnProperty(keystring)) {
            var cur=this[keystring];
            if (cur===val) {
                delete this[keystring];
                return true;}
            else if (cur instanceof Array) {
                var pos=cur.indexOf(val);
                if (pos<0) return false;
                cur.splice(pos,1); if (cur._sortlen) cur._sortlen--;
                if (cur.length===1) {
                    if (!(cur[0] instanceof Array))
                        this[keystring]=cur[0];}
                return true;}
            else return false;}
        else return false;};
    fdjt.Map=ObjectMap;
    RefDB.ObjectMap=ObjectMap;
    RefDB.fdjtMap=ObjectMap;

    function StringMap() {return this;}
    StringMap.prototype.get=function StringMapGet(keystring) {
        if (typeof keystring !== "string") return undefined;
        if (this.hasOwnProperty(keystring))
            return this[keystring];
        else return undefined;};
    StringMap.prototype.getItem=StringMap.prototype.get;
    StringMap.prototype.set=function(keystring,val) {
        if (typeof keystring !== "string") return;
        if (val instanceof Array)
            this[keystring]=[val];
        else this[keystring]=val;};
    StringMap.prototype.setItem=StringMap.prototype.set;
    StringMap.prototype.increment=function(keystring,delta) {
        if (typeof keystring !== "string") return;
        var cur=this[keystring], next;
        if (cur) this[keystring]=next=cur+delta;
        else this[keystring]=next=delta;
        return next;};
    StringMap.prototype.add=function(keystring,val) {
        if (typeof keystring !== "string") return;
        if (this.hasOwnProperty(keystring)) {
            var cur=this[keystring];
            if (cur===val) return false;
            else if (cur instanceof Array) {
                if (arr_contains(cur,val)) return false;
                else {cur.push(val); return true;}}
            else if (val instanceof Array) {
                this[keystring]=setify([cur,val]);
                return true;}
            else {
                this[keystring]=setify([cur,val]);
                return true;}}
        else if (val instanceof Array) 
            this[keystring]=setify([val]);
        else this[keystring]=val;};
    StringMap.prototype.drop=function(keystring,val) {
        if (typeof keystring !== "string") return;
        if (this.hasOwnProperty(keystring)) {
            var cur=this[keystring];
            if (cur===val) {
                delete this[keystring];
                return true;}
            else if (cur instanceof Array) {
                var pos=cur.indexOf(val);
                if (pos<0) return false;
                cur.splice(pos,1); if (cur._sortlen) cur._sortlen--;
                if (cur.length===1) {
                    if (!(cur[0] instanceof Array))
                        this[keystring]=cur[0];}
                return true;}
            else return false;}
        else return false;};
    fdjt.StringMap=StringMap;
    RefDB.StringMap=StringMap;

    function RefMap(db) {this._db=db; return this;}
    RefMap.prototype.get=function(key){
        if (typeof key === "string") {
            if (this.hasOwnProperty(key)) return this[key];
            else return undefined;}
        else if (key instanceof Ref) {
            var id=((this.uniqueids)&&key._id)||key._qid||key.getQID();
            return this[id];}
        else return undefined;};
    RefMap.prototype.set=function(key,val){
        if (typeof key === "string") this[key]=val;
        else if (key instanceof Ref) {
            var id=key._qid||((this.uniqueid)&&key._id)||key.getQID();
            this[id]=val;}
        else return false;};
    RefMap.prototype.increment=function(key,delta){
        if (typeof key === "string") {
            if (this.hasOwnProperty(key))
                this[key]=this[key]+delta;
            else this[key]=delta;}
        else if (key instanceof Ref) {
            var id=key._qid||((this.uniqueids)&&key._id)||key.getQID();
            this[id]=(this[id]||0)+delta;}
        else return false;};
    fdjt.RefMap=RefDB.RefMap=RefMap;
    
    /* Miscellaneous array and table functions */

    RefDB.add=function(obj,field,val,nodup){
        if (arguments.length===2)
            return set_add(obj,field);
        else if (obj instanceof Ref)
            return obj.add.apply(obj,arguments);
        else if (nodup) 
            if (obj.hasOwnProperty(field)) {
                var vals=obj[field];
                if (!(arr_contains(vals,val))) obj[field].push(val);
                else {}}
        else obj[field]=new Array(val);
        else if (obj.hasOwnProperty(field))
            obj[field].push(val);
        else obj[field]=new Array(val);
        if ((obj._all) && (!(arr_contains(obj._all,field))))
            obj._all.push(field);};

    RefDB.drop=function(obj,field,val){
        if (arguments.length===2)
            return set_drop(obj,field);
        else if (obj instanceof Ref)
            return obj.drop.apply(obj,arguments);
        else if (!(val))
            /* Drop all vals */
            obj[field]=[];
        else if (obj.hasOwnProperty(field)) {
            var vals=obj[field];
            var pos=arr_position(vals,val);
            if (pos<0) return;
            else vals.splice(pos,1);}
        else {}};

    RefDB.test=function(obj,field,val){
        if (arguments.length===2)
            return arr_contains(obj,field);
        else if (obj instanceof Ref)
            return obj.test.apply(obj,arguments);
        else if (typeof val === "undefined")
            return (((obj.hasOwnProperty) ?
                     (obj.hasOwnProperty(field)) : (obj[field])) &&
                    ((obj[field].length)>0));
        else if (obj.hasOwnProperty(field)) { 
            if (arr_position(obj[field],val)<0)
                return false;
            else return true;}
        else return false;};

    RefDB.insert=function(array,value){
        if (arr_position(array,value)<0) array.push(value);};

    RefDB.remove=function(array,value,count){
        var pos=arr_position(array,value);
        if (pos<0) return array;
        array.splice(pos,1);
        if (count) {
            count--;
            while ((count>0) &&
                   ((pos=arr_position(array,value,pos))>=0)) {
                array.splice(pos,1); count--;}}
        return array;};

    RefDB.indexOf=function(array,elt,pos){
        if (pos) return array.indexOf(elt,pos);
        else return array.indexOf(elt);};

    RefDB.contains=arr_contains;
    RefDB.position=arr_position;

    function countKeys(obj){
        var count=0; for (var key in obj) {
            if (obj.hasOwnProperty(key)) count++;}
        return count;}
    RefDB.countKeys=countKeys;
    function localKeys(obj){
        var keys=[]; for (var key in obj) {
            if (obj.hasOwnProperty(key)) keys.push(key);}
        return keys;}
    RefDB.localKeys=localKeys;

    function Query(dbs,clauses,weights){
        if (arguments.length===0) return this;
        if (dbs) this.dbs=dbs;
        if (clauses) {
            if (clauses instanceof Array)
                this.clauses=clauses;
            else this.clauses=[clauses];}
        if (weights) this.weights=weights;
        // Figure out if references can be unique IDs
        var i=0, n_dbs=dbs.length;
        if (n_dbs>1) while (i<n_dbs) {
            if (!(dbs[i].absrefs)) return this;
            else i++;}
        this.uniqueids=true;
        return this;}
    RefDB.Query=Query;
    Query.prototype.uniqueids=false;
    
    function sortbyweight(f1,f2){return f2.weight-f1.weight;}

    Query.prototype.execute=function executeQuery(){
        if (this.scores) return this;
        var dbs=this.dbs;
        var clauses=this.clauses;
        if (!((dbs)&&(dbs.length))) {
            var empty_result=this.results=fdjtSet();
            warn("No dbs for query %o!",this);
            return empty_result;}
        else if (!((clauses)&&(clauses.length))) {
            var full_result=fdjtSet();
            var i=0, lim=dbs.length;
            while (i<lim) full_result=
                merge(full_result,setify(dbs[i++].allrefs));
            this.results=full_result;
            return full_result;}
        var query_weights=this._weights||this.weights;
        var uniqueids=((dbs.length===1)||(this.uniqueids));
        var scores=new RefMap();
        var counts=new RefMap();
        var matches=fdjtSet();
        var match_seen={};
        // This makes these go faster because they don't bother
        // disambiguting _id fields.
        counts.uniqueids=scores.uniqueids=uniqueids;
        var i_clause=0, n_clauses=clauses.length;
        while (i_clause<n_clauses) {
            var clause=clauses[i_clause++];
            var fields=clause.fields;
            var values=clause.values;
            var clause_weights=clause.weights;
            var findings=[];
            if (!(fields instanceof Array)) fields=[fields];
            if (!(values instanceof Array)) values=[values];
            var i_field=0; var n_fields=fields.length;
            while (i_field<n_fields) {
                var field=fields[i_field++];
                var weight=((clause_weights)&&(clause_weights[field]))||
                    ((query_weights)&&(query_weights[field]))||
                    (this.default_weight)||1;
                var i_value=0, n_values=values.length;
                while (i_value<n_values) {
                    var value=values[i_value++];
                    var i_db=0, n_dbs=dbs.length;
                    while (i_db<n_dbs) {
                        var db=dbs[i_db++];
                        var hits=db.find(field,value);
                        if ((hits)&&(hits.length)) {
                            findings.push({
                                field: field, hits: setify(hits),
                                weight: weight, value: value,
                                db: db});}}}}
            // Sort so the highest scoring findings go first
            findings.sort(sortbyweight);
            var finding_i=0, n_findings=findings.length; var seen={};
            while (finding_i<n_findings) {
                var finding=findings[finding_i++];
                var hit_ids=finding.hits, fdb=finding.db, abs=fdb.absrefs;
                var i_hit=0, n_hits=hit_ids.length, hit_id, ref;
                if ((uniqueids)||(abs)) while (i_hit<n_hits) {
                    hit_id=hit_ids[i_hit++];
                    if (seen[hit_id]) continue;
                    else seen[hit_id]=hit_id;
                    if (!(match_seen[hit_id])) {
                        matches.push(fdb.ref(hit_id));
                        match_seen[hit_id]=hit_id;}
                    counts[hit_id]=(counts[hit_id]||0)+1;
                    scores[hit_id]=(scores[hit_id]||0)+finding.weight;}
                else {
                    hit_id=hit_ids[i_hit++]; ref=fdb.ref(hit_id);
                    var fullid=ref._qid||((abs)&&(ref._id))||ref.getQID();
                    if (seen[fullid]) continue;
                    else seen[fullid]=fullid;
                    if (!(match_seen[fullid])) {
                        matches.push(ref);
                        match_seen[fullid]=fullid;}
                    counts[fullid]=(counts[fullid]||0)+1;
                    scores[fullid]=(scores[fullid]||0)+finding.weight;}}}
        if (n_clauses>1) {
            var results=this.results=[];
            var new_scores=new RefMap(), new_counts=new RefMap();
            var i_matches=0, n_matches=matches.length;
            while (i_matches<n_matches) {
                var match=matches[i_matches++];
                var count=counts.get(match);
                // If there are just two clauses, score their
                // intersection; If there are more than two
                // clauses (count>=2), score the union of their
                // pairwise intersections.
                if (count>=2) { /* ((n_clauses===2)||(count>=2)) */
                    var score=scores.get(match);
                    new_scores.set(match,score);
                    new_counts.set(match,count);
                    results.push(match);}}
            results._allstrings=false;
            results._sortlen=results.length;
            this.results=results;
            this.scores=new_scores;
            this.counts=new_counts;}
        else {
            this.results=setify(matches);
            this.scores=scores;
            this.counts=counts;}
        
        return this;};

    /* Indexed DB utilities */
    
    function useIndexedDB(dbname,version,init,opts){
        if ((version)&&(!opts)&&
            (typeof version !== "number")&&(version.version)) {
            opts=version; version=opts.version;}
        else if (!(opts)) opts={};
        if (!(init)) init=opts.init||false;
        if (!(version)) version=1;
        var trace=opts.trace;
        var vname=dbname+":"+version;
        function usingIndexedDB(resolve,reject){
            if ((typeof indexedDB === "undefined")||
                (!(indexedDB.open))) {
                fdjtLog.warn(
                    "No indexedDB implementation for opening %:",vname);
                if (reject)
                    reject(new Error("No indexedDB implementation"));
                else throw new Error("No indexedDB implementation");}
            var req=indexedDB.open(dbname,version), fail=false;
            var init_timeout=setTimeout(function(){
                fail=true;
                fdjtLog.warn("Init timeout for indexedDB %s",vname);
                reject(new Error("Init timeout"));},
                                        opts.timeout||15000);
            req.onerror=function(event){
                fail=true;
                warn("Error initializing indexedDB layout cache: %o",
                     event.errorCode);
                if (init_timeout) clearTimeout(init_timeout);
                if (reject) return reject(event);
                else return event;};
            req.onsuccess=function(evt) {
                if (fail) {
                    fdjtLog("Discarding indexedDB %s after failure!",
                            vname);
                    return;}
                var db=evt.target.result;
                if (init_timeout) clearTimeout(init_timeout);
                if (trace)
                    fdjtLog("Got existing IndexedDB %s %o",
                            vname,db);
                if (resolve)
                    return resolve(db);
                else return db;};
            req.onupgradeneeded=function(evt) {
                var db=evt.target.result;
                if (!(init)) return resolve(db);
                else {
                    req.onsuccess=function(){
                        if (resolve) return resolve(db);
                        else return db;};
                    req.onerror=function(evt){
                        fdjtLog("Error upgrading %s %o",vname,evt);
                        if (reject) reject(evt);
                        else throw new Error(
                            "Error upgrading %s",vname);};
                    if (init.call) {
                        try {init(db);
                             if (resolve) return resolve(db);
                             else return db;}
                        catch (ex) {
                            fdjtLog("Error upgrading %s:%d: %o",
                                    dbname,version,ex);
                            if (reject) reject(ex);}}
                    else if (reject) reject(
                        new Error("Bad indexDB init: %o",init));
                    else throw new Error("Bad indexDB init: %o",init);}
                return db;};
            return req;}
        return new Promise(usingIndexedDB);}
    RefDB.useIndexedDB=useIndexedDB;

    return RefDB;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/ajax.js ###################### */

/* Copyright (C) 2007-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides an abstraction layer for Ajax calls

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use, modification, and redistribution of this program is permitted
    under either the GNU General Public License (GPL) Version 2 (or
    any later version) or under the GNU Lesser General Public License
    (version 3 or later).

    These licenses may be found at www.gnu.org, particularly:
      http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
      http://www.gnu.org/licenses/lgpl-3.0-standalone.html
*/
/* jshint browser: true  */
/* globals Promise */

// var fdjt=((window.fdjt)||{});

fdjt.Ajax=
    (function(){
        "use strict";
        var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log;
        var $ID=fdjt.ID;

        function compose_uri(base_uri,args){
            var uri=base_uri; var need_amp=false;
            if (base_uri[-1]==='&') need_amp=false;
            else if (base_uri.indexOf('?')>=0) need_amp=true;
            else uri=base_uri+"?";
            if (typeof args === 'string')
                uri=uri+((need_amp) ? ("&") : (""))+args;
            else if (args.length) {
                var i=0; while (i<args.length) {
                    if (!(args[i])) {i=i+2; continue;}
                    uri=uri+((need_amp) ? ("&") : (""))+
                        encodeURIComponent(args[i])+
                        "="+encodeURIComponent(args[i+1]);
                    need_amp=true;
                    i=i+2;}}
            else {
                for (var key in args) {
                    if (args.hasOwnProperty(key)) {
                        uri=uri+((need_amp) ? ("&") : (""))+
                            encodeURIComponent(key)+
                            "="+encodeURIComponent(args[key]);
                        need_amp=true;}}}
            return uri;}

        var trace_ajax=false;
        
        function statusOK(req,test){
            var status=req.status;
            if (!(test))
                return ((status>=200)&&(status<300))||(status===304);
            else if (test.call)
                return test(req);
            else if (Array.isArray(test)) 
                return test.indexOf(status)>=0;
            else return ((status>=200)&&(status<300))||(status===304);}

        function fdjtAjax(success_callback,base_uri,args,other_callback,
                          headers,opts){
            var timeout=((typeof opts==="number")?(opts):
                         ((opts)&&(opts.timeout)));
            if (typeof opts === "number") opts={};
            else if (!(opts)) opts={};
            var req=new XMLHttpRequest(), success=opts.success;
            var uri=((args)?(compose_uri(base_uri,args)):(base_uri));
            req.onreadystatechange=function () {
                if (req.readyState === 4) {
                    if (statusOK(req,success)) {
                        success_callback(req);}
                    else if (other_callback) other_callback(req);}
                else {}};
            if (timeout) {
                req.timeout=timeout;
                if (other_callback) {
                    req.ontimeout=function(evt){
                        evt=evt||window.event;
                        other_callback(req);};}}
            req.open("GET",uri);
            if (opts.hasOwnProperty("credentials"))
                req.withCredentials=opts.credentials;
            else req.withCredentials=true;
            if (headers) {
                for (var key in headers)
                    if (headers.hasOwnProperty(key))
                        req.setRequestHeader(key,headers[key]);}
            req.send(null);
            return req;}

        fdjtAjax.textCall=function(callback,base_uri){
            return fdjtAjax(function(req) {callback(req.responseText);},
                            base_uri,fdjtDOM.Array(arguments,2));};

        fdjtAjax.jsonCall=function(callback,base_uri){
            return fdjtAjax(function(req) {
                callback(JSON.parse(req.responseText));},
              base_uri,fdjtDOM.Array(arguments,2));};

        fdjtAjax.xmlCall=function(callback,base_uri){
            return fdjtAjax(function(req) {callback(req.responseXML);},
                            base_uri,fdjtDOM.Array(arguments,2));};
        
        fdjtAjax.fetch=function(baseuri,args,headers,opts){
            function fetching(resolved,rejected){
                fdjtAjax(function(req) {resolved(req);},
                         baseuri,args,
                         function(req) {rejected(req);},
                         headers,opts);}
            return new Promise(fetching);};
        fdjtAjax.fetchText=function(baseuri,args,headers,opts){
            function fetching(resolved,rejected){
                fdjtAjax(function(req) {resolved(req.responseText);},
                         baseuri,args,
                         function(req) {rejected(req);},
                         headers,opts);}
            return new Promise(fetching);};
        fdjtAjax.fetchJSON=function(baseuri,args,headers,opts){
            function fetching(resolved,rejected){
                fdjtAjax(function(req) {resolved(JSON.parse(req.responseText));},
                         baseuri,args,
                         function(req) {rejected(req);},
                         headers,opts);}
            return new Promise(fetching);};
        fdjtAjax.fetchXML=function(baseuri,args,headers,opts){
            function fetching(resolved,rejected){
                fdjtAjax(function(req) {resolved(JSON.parse(req.responseXML));},
                         baseuri,args,
                         function(req) {rejected(req);},
                         headers,opts);}
            return new Promise(fetching);};

        function jsonpCall(uri,id,cleanup){
            if ((id)&&($ID(id))) return false;
            var script_elt=fdjt.DOM("SCRIPT");
            if (id) script_elt.id=id;
            if (cleanup) script_elt.oncleanup=cleanup;
            script_elt.language='javascript';
            script_elt.src=uri;
            document.body.appendChild(script_elt);}
        fdjtAjax.jsonpCall=jsonpCall;

        function jsonpFinish(id){
            var script_elt=$ID(id);
            if (!(script_elt)) return;
            if (script_elt.oncleanup) script_elt.oncleanup();
            fdjtDOM.remove(script_elt);}
        fdjtAjax.jsonpFinish=jsonpFinish;

        function add_query_param(parameters,name,value){
            return ((parameters)?(parameters+"&"):(""))+
                name+"="+encodeURIComponent(value);}

        function formParams(form) {
            fdjt.UI.AutoPrompt.cleanup(form);
            var parameters=false;
            var inputs=fdjtDOM.getChildren(form,"INPUT");
            var i=0; while (i<inputs.length) {
                var input=inputs[i++];
                if ((!(input.disabled))&&
                    (((/(radio)|(checkbox)/i).exec(input.type))?
                     (input.checked):(true)))
                    parameters=add_query_param(
                        parameters,input.name,input.value);}
            var textareas=fdjtDOM.getChildren(form,"TEXTAREA");
            i=0; while (i<textareas.length) {
                var textarea=textareas[i++];
                if (!(textarea.disabled)) {
                    parameters=add_query_param(
                        parameters,textarea.name,textarea.value);}}
            var selectboxes=fdjtDOM.getChildren(form,"SELECT");
            i=0; while (i<selectboxes.length) {
                var selectbox=selectboxes[i++]; var name=selectbox.name;
                var options=fdjtDOM.getChildren(selectbox,"OPTION");
                var j=0; while (j<options.length) {
                    var option=options[j++];
                    if (option.selected)
                        parameters=add_query_param(
                            parameters,name,option.value);}}
            return parameters;}
        fdjtAjax.formParams=formParams;

        function add_field(result,name,value,downcase) {
            if (downcase) name=name.toLowerCase();
            if (result.hasOwnProperty(name)) {
                var cur=result[name];
                if (cur.push) cur.push(value);
                else result[name]=[cur,value];}
            else result[name]=value;}

        function formJSON(form,downcase) {
            fdjt.UI.AutoPrompt.cleanup(form);
            var result={};
            var inputs=fdjtDOM.getChildren(form,"INPUT");
            var i=0; while (i<inputs.length) {
                var input=inputs[i++];
                if ((!(input.disabled)) &&
                    (((input.type==="radio") || (input.type==="checkbox")) ?
                     (input.checked) : (true)))
                    add_field(result,input.name,input.value,downcase||false);}
            var textareas=fdjtDOM.getChildren(form,"TEXTAREA");
            i=0; while (i<textareas.length) {
                var textarea=textareas[i++];
                if (!(textarea.disabled)) 
                    add_field(result,textarea.name,textarea.value,downcase||false);}
            var selectboxes=fdjtDOM.getChildren(form,"SELECT");
            i=0; while (i<selectboxes.length) {
                var selectbox=selectboxes[i++]; var name=selectbox.name;
                var options=fdjtDOM.getChildren(selectbox,"OPTION");
                var j=0; while (j<options.length) {
                    var option=options[j++];
                    if (option.selected)
                        add_field(result,name,option.value,downcase||false);}}
            return result;}
        fdjtAjax.formJSON=formJSON;

        function ajaxSubmit(form,callback,opts){
            var ajax_uri=form.getAttribute("ajaxaction")||form.action;
            if (!(ajax_uri)) return false;
            // Whether to do AJAX synchronously or not.
            var syncp=form.getAttribute("synchronous");
            if (trace_ajax)
                fdjtLog("Direct %s AJAX submit to %s for %o with callback %o",
                        ((syncp)?("synchronous"):("asynchronous")),
                        ajax_uri,form,callback);
            // Firefox doesn't run the callback on synchronous calls
            var success=false; var callback_run=false;
            var req=new XMLHttpRequest();
            var params=formParams(form);
            fdjtDOM.addClass(form,"submitting");
            if (syncp) {
                if (form.method==="GET")
                    req.open('GET',ajax_uri+"?"+params,false);
                else if (form.method==="PUT")
                    req.open('PUT',ajax_uri,false);
                else req.open('POST',ajax_uri,false);}
            else {
                if (form.method==="GET")
                    req.open('GET',ajax_uri+"?"+params);
                else if (form.method==="PUT")
                    req.open('PUT',ajax_uri);
                else req.open('POST',ajax_uri);}
            req.onreadystatechange=function () {
                if (trace_ajax)
                    fdjtLog("Ajax (%d,%d) %o for %o, callback=%o",
                            req.readyState,
                            ((req.readyState===4)&&(req.status)),
                            req,ajax_uri,callback);
                if ((req.readyState === 4) && (req.status>=200) &&
                    (req.status<300)) {
                    if ((callback)&&(trace_ajax))
                        fdjtLog("Got callback (%d,%d) %o for %o, calling %o",
                                req.readyState,req.status,req,ajax_uri,callback);
                    fdjtDOM.dropClass(form,"submitting");
                    success=true; 
                    if (callback) callback(req,form);
                    callback_run=true;}
                else if (req.readyState === 4) {
                    fdjtLog("Failed callback (%d,%d) %o for %o, not calling %o",
                            req.readyState,((req.readyState===4)&&(req.status)),
                            req,ajax_uri,callback);
                    fdjtDOM.dropClass(form,"submitting");
                    if (callback) callback(req,form);
                    callback_run=true;}
                else {}};
            if ((opts)&&(opts.accept)) req.setRequestHeader("Accept",opts.accepts);
            if ((opts)&&(opts.hasOwnProperty('creds')))
                req.withCredentials=opts.creds;
            else req.withCredentials=true;
            try {
                if (form.method==="GET") req.send();
                else {
                    req.setRequestHeader(
                        "Content-type", "application/x-www-form-urlencoded");
                    req.send(params);}
                success=true;}
            catch (ex) {}
            if ((syncp) && (!(callback_run))) {
                if (trace_ajax)
                    fdjtLog("Running callback (rs=%d,status=%d) %o for %o, calling %o",
                            req.readyState,((req.readyState===4)&&(req.status)),
                            req,ajax_uri,callback);
                if ((req.readyState === 4) && (req.status>=200) &&
                    (req.status<300)) {
                    fdjtDOM.dropClass(form,"submitting");
                    success=true;
                    if (callback) callback(req,form);}}
            return success;}
        fdjtAjax.formSubmit=ajaxSubmit;

        function jsonpSubmit(form){
            var jsonp_uri=form.getAttribute("jsonpuri");
            if (!(jsonp_uri)) return false;
            var jsonid=((form.id)?("JSONP"+form.id):("FORMJSONP"));
            var params=formParams(form);
            fdjtDOM.addClass(form,"submitting");
            try {
                jsonpCall(jsonp_uri+"?"+params,jsonid,
                          function(){fdjt.DOM.dropClass(form,"submitting");});}
            catch (ex) {
                jsonpFinish(jsonid);
                fdjtLog.warn("Attempted JSONP call signalled %o",ex);
                return false;}
            return true;}

        function form_submit(evt,callback){
            evt=evt||window.event||null;
            var form=((evt.nodeType)?(evt):(fdjt.UI.T(evt)));
            fdjt.UI.AutoPrompt.cleanup(form);
            if (fdjtDOM.hasClass(form,"submitting")) {
                fdjtDOM.dropClass(form,"submitting");
                form.fdjtsubmit=false;
                return false;}
            // if (form.fdjtlaunchfailed) return;
            form.fdjtsubmit=true;
            fdjtDOM.addClass(form,"submitting");
            if (ajaxSubmit(form,callback)) {
                // fdjtLog("Ajax commit worked");
                fdjt.UI.cancel(evt);
                return true;}
            else if (jsonpSubmit(form)) {
                // fdjtLog("Json commit worked");
                fdjt.UI.cancel(evt);
                return true;}
            else return false;}

        function copy_args(args,i){
            var lim=args.length; if (!(i)) i=0;
            var copy=new Array(lim-i);
            while (i<lim) {copy[i]=args[i]; i++;}
            return copy;}

        /* Synchronous calls */
        function sync_get(callback,base_uri,args){
            var req=new XMLHttpRequest();
            var uri=compose_uri(base_uri,args);
            req.open("GET",uri,false);
            req.send(null);
            if (callback) return callback(req);
            else return req;}
        fdjtAjax.get=function(base_uri){
            return sync_get(false,base_uri,copy_args(arguments,1));};
        fdjtAjax.getText=function(base_uri) {
            return sync_get(function (req) { return req.responseText; },
                            base_uri,copy_args(arguments,1));};
        fdjtAjax.getJSON=function(base_uri) {
            return sync_get(function (req) {
                return JSON.parse(req.responseText); },
                            base_uri,fdjtDOM.Array(arguments,1));};
        fdjtAjax.getXML=function(base_uri) {
            return sync_get(function (req) {return req.responseXML; },
                            base_uri,fdjtDOM.Array(arguments,1));};
        
        fdjtAjax.onsubmit=form_submit;

        return fdjtAjax;})();

/* Emacs local variables
;;;  Local variables: ***
;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
;;;  indent-tabs-mode: nil ***
;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ######################### fdjt/wsn.js ###################### */

/* Copyright (C) 2011-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   It implements a method for breaking narrative HTML content
   across multiple pages, attempting to honor page break constraints,
   etc.

   Check out the 'mini manual' at the bottom of the file or read the
   code itself.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or any
   later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

   Use and redistribution (especially embedding in other CC licensed
   content) is also permitted under the terms of the Creative Commons
   "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

var WSN=(function(){
    "use strict";
    var fdjtHash=fdjt.Hash;
    var fdjtString=fdjt.String;

    /*
    function get_punct_regex(){
        try { return (/(\pM)/g);}
        catch (ex1) {
            try { return (/(\pP)/g); }
            catch (ex2) {return (/[.,?!-_@&%$#\\\/\^()]/);}}}
    */
    
    var punct_regex=/(\pM)/g;
    var decodeEntities=fdjtString.decodeEntities;
    
    function WSN(arg,sortfn,wordfn,keepdup){
        if (arg==="") return arg;
        else if ((!(arg))&&(this instanceof WSN)) {
            // Assume we're being used as a constructor.
            if (sortfn) this.sortfn=sortfn;
            if (wordfn) this.wordfn=wordfn;
            if (keepdup) this.keepdup=keepdup;
            return this;}
        else if (!(arg)) return arg;
        if (typeof sortfn === 'undefined') sortfn=WSN.sortfn||false;
        if (typeof wordfn === 'undefined') wordfn=WSN.wordfn||false;
        if (typeof keepdup === 'undefined') keepdup=WSN.keepdup||false;
        if (typeof arg === 'string') {
            var norm=
                decodeEntities(arg).toLowerCase().replace(punct_regex,"");
            // Trim spaces
            if (norm.trim) norm=norm.trim();
            else {
                if (norm.search(/\S/)>0)
                    norm=norm.slice(norm.search(/\S/));
                if (norm.search(/\s+$/)>0)
                    norm=norm.slice(0,norm.search(/\s+$/));}
            if (norm==="") return "";
            var words=norm.split(/\W*\s+\W*/g), word;
            var xwords=[], xword;
            var nwords=words.length;
            var i, lim;
            if (nwords===0) return "";
            else words[0]=words[0].replace(/^\W+/,"");
            if (nwords>1)
                words[nwords-1]=words[nwords-1].replace(/\W+$/,"");
            if (wordfn) {
                if (typeof wordfn === 'number') {
                    i=0; lim=words.length;
                    while (i<lim) {
                        xword=words[i++];
                        if (word.length>wordfn) xwords.push(xword);}
                    if (xwords.length) words=xwords;}
                else if (wordfn.call) {
                    i=0; lim=words.length;
                    while (i<lim) {
                        xword=wordfn(words[i++]);
                        if (xword) xwords.push(xword);
                        i++;}
                    if (xwords.length) words=xwords;}
                else  {
                    i=0; lim=words.length;
                    while (i<lim) {
                        word=words[i++];
                        xword=wordfn[word];
                        if (xword==="") {}
                        else if ((!(xword))||(typeof xword !== 'string'))
                            xwords.push(word);
                        else xwords.push(xword);}
                    if (xwords.length) words=xwords;}}
            var sorter=sortfn;
            // By default, use lensort
            // But if you're passed nativesort, just
            //  pass false to sort()
            if (sortfn===true) sorter=lensort;
            else if (sortfn===nativesort) sorter=false;
            else {}
            if ((sortfn)&&(keepdup))
                return words.sort(sorter).join(" ");
            else if (sortfn)
                return dedupfn(words.sort(sorter)).join(" ");
            else return words.join(" ");}
        else if (!(arg.nodeType))
            throw new Error("bad arg to WSN");
        else if (arg.nodeType===3)
            return WSN(arg.nodeValue);
        else if (arg.nodeType===1)
            return WSN(textify(arg));
        else throw new Error("bad arg to WSN");}
    
    function dedupfn(arr){
        var i=0; var lim=arr.length; var last=false;
        if (lim<2) return arr;
        else while (i<lim) {
            if ((last)&&(arr[i]===last)) return dodedup(arr);
            else last=arr[i++];}
        return arr;}
    function dodedup(arr){
        var last=arr[0]; var result=[last];
        var i=1; var lim=arr.length;
        while (i<lim) 
            if (arr[i]===last) i++;
        else result.push(last=arr[i++]);
        return result;}
    
    function lensort(x,y){
        var xl=x.length, yl=y.length;
        if (xl===yl) {
            if (x>y) return -1;
            else if (x<y) return 1;
            else return 0;}
        else if (xl>yl) return -1;
        else return 1;}
    WSN.lensort=lensort;
    function nativesort(x,y){
        if (x>y) return -1;
        else if (x<y) return 1;
        else return 0;}
    WSN.nativesort=nativesort;

    function textify(arg,text){
        /* global window: false */
        if (!(arg.nodeType)) return text||"";
        else if (arg.nodeType===3)
            if (text) return text+arg.nodeValue; else return arg.nodeValue;
        else if (arg.nodeType===1) {
            var children=arg.childNodes;
            var style=((window.getComputedStyle)?
                       (window.getComputedStyle(arg)):
                       {position: 'static',display: 'block'});
            if (style.position!=='static') return text||"";
            if (style.display!=='inline')
                text="\n"+(text||"");
            else if (!(text)) text="";
            var i=0; var lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (child.nodeType===3) text=text+child.nodeValue;
                else if (child.nodeType===1) text=textify(child,text);
                else {}}
            return text;}
        else if (text) return text;
        else return "";}
    WSN.prototype.textify=WSN.textify=textify;

    function fuddle(arg,sortfn){return WSN(arg,sortfn||lensort);}
    WSN.fuddle=fuddle;

    function md5ID(){
        var wsn=WSN.apply(null,arguments);
        if (!(wsn)) return wsn;
        else if (WSN.md5) return WSN.md5(wsn);
        else if ((fdjtHash)&&(fdjtHash.hex_md5))
            return fdjtHash.hex_md5(wsn);
        else throw new Error("No MD5 implementation");}
    WSN.md5ID=md5ID;
    
    function sha1ID(){
        var wsn=WSN.apply(null,arguments);
                if (!(wsn)) return wsn;
        else if (WSN.sha1) return WSN.md5(wsn);
        else if ((fdjtHash)&&(fdjtHash.hex_sha1))
            return fdjtHash.hex_sha1(wsn);
        else throw new Error("No SHA1 implementation");}
    WSN.sha1ID=sha1ID;

    function hash(arg,hashfn,sortfn,wordfn,keepdups){
        if (typeof hashfn === 'undefined') hashfn=WSN.hashfn||false;
        if (typeof sortfn === 'undefined') sortfn=WSN.sortfn||false;
        if (typeof wordfn === 'undefined') wordfn=WSN.wordfn||false;
        if (typeof keepdups === 'undefined') keepdups=WSN.keepdup||false;
        var wsn=WSN(arg,sortfn,wordfn,keepdups);
        if (!(wsn)) return wsn;
        else return ((hashfn)?(hashfn(wsn)):(wsn));}
    WSN.hash=hash;
    WSN.prototype.Hash=function(arg){
        return hash(arg,this.hashfn||WSN.hashfn||false,
                    this.sortfn||WSN.sortfn||false,
                    this.wordfn||WSN.wordfn||false,
                    this.keepdup||WSN.keepdup||false);};

    function maphash(nodes,hashfn,sortfn,wordfn,keepdups){
        if (typeof hashfn === 'undefined') hashfn=WSN.hashfn||false;
        if (typeof sortfn === 'undefined') sortfn=WSN.sortfn||false;
        if (typeof wordfn === 'undefined') wordfn=WSN.wordfn||false;
        if (typeof keepdups === 'undefined') keepdups=WSN.keepdup||false;
        var map={};
        var i=0; var lim=nodes.length;
        while (i<lim) {
            var node=nodes[i++];
            var wsn=WSN(node,sortfn,wordfn,keepdups);
            var id=((hashfn)?(hashfn(wsn)):(wsn));
            map[id]=node;}
        return map;}
    WSN.maphash=maphash;
    WSN.prototype.maphash=function(arg){
        return maphash(arg,this.hashfn||WSN.hashfn||false,
                       this.sortfn||WSN.sortfn||false,
                       this.wordfn||WSN.wordfn||false,
                       this.keepdup||WSN.keepdup||false);};
    
    function mapMD5(nodes,sortfn,wordfn,keepdups){
        var hashfn=WSN.md5||((fdjtHash)&&(fdjtHash.hex_md5));
        return maphash(nodes,hashfn,sortfn,wordfn,keepdups);}
    function mapSHA1(nodes,sortfn,wordfn,keepdups){
        var hashfn=WSN.sha1||((fdjtHash)&&(fdjtHash.hex_sha1));
        return maphash(nodes,hashfn,sortfn,wordfn,keepdups);}
    WSN.mapMD5=mapMD5;
    WSN.mapSHA1=mapSHA1;

    WSN.md5=((fdjtHash)&&(fdjtHash.hex_md5));
    WSN.sha1=((fdjtHash)&&(fdjtHash.hex_sha1));

    return WSN;})();

fdjt.WSN=WSN;

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/textindex.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.TextIndex=(function(){
    "use strict";
    var fdjtString=fdjt.String;
    var fdjtDOM=fdjt.DOM;
    var stdspace=fdjtString.stdspace;
    var textify=fdjtDOM.textify;
    
    var default_stopwords_init=[
        "a","i","--","am","an","as","at","be","by","d'",
        "de","di","do","ex","he","if","in","is","it",
        "me","my","no","o'","of","on","or","so","t'",
        "to","up","us","we","ya","ye","any","are","but","can",
        "cum","des","did","ere","fer","few","for","had",
        "has","her","him","his","hoo","how","i'd","i'm",
        "its","lot","may","nor","not","off","our",
        "qua","s/p","she","ten","the",
        "via","was","who","why","yet","you","'tis",
        "amid","atop","been","both","does","doth",
        "down","d’","each","even","from","haec","hast",
        "hath","have","he'd","he's","here","hers","i'll",
        "i're","i've","into","it'd","it's","last","less",
        "like","many","mine","miss","more","most","must",
        "near","nigh","none","o'er","once","only",
        "onto","ours","over","o’","past","port","reg.",
        "sans","says","some","such","thae","than","that",
        "thee","them","then","they","thir","this","thou",
        "thro","thru","thus","till","unto","upon","upto",
        "we'd","were","what","when","whom","will","wilt",
        "with","your","yous","zero","abaft","aboon",
        "about","above","adown","afore","after","ain't","along",
        "among","anear","anent","aught","baith","being","below",
        "can't","circa","could","didst","doest","doeth","don't",
        "every","fewer","fifty","forty","gonna",
        "he'll","he're","he've","her'n","his'n","isn't","it'll",
        "maybe","might","neath","never","noone","one's","other",
        "our'n","round","shall","shalt","she'd","she's","since",
        "their","there","these","those","thro'","today",
        "under","until","we'll","we're","we've","where","which",
        "while","who'd","who's","whose","whoso","won't","would",
        "you'd","yours","youse","aboard","across",
        "allyou","amidst","anyone","aren't","around","before",
        "behind","beside","beyond","cannot","contra","couple",
        "didn't","during","either","eleven","except",
        "google","hadn't","hasn't","having","inside","itself",
        "myriad","myself","no-one","nobody","o’er",
        "quibus","she'll","she're","she've","should","sundry",
        "that'd","that's","theirs","they'd","thirty","this'd",
        "thwart","tother","toward","twelve","twenty","unless",
        "unlike","versus","wasn't","what's","whence","whilst",
        "withal","within","you'll","you're","you've","your'n",
        "against","ain’t","amongst","another","anybody",
        "astride","athwart","because","beneath","besides","between",
        "betwixt","can’t","despite","doesn't","don’t",
        "haven't","herself","himself","hisself",
        "however","hundred","isn’t","neither","nothing",
        "oneself","ourself","outside","outwith","pending","perhaps",
        "several","someone","that'll","there's",
        "they'll","they're","they've","this'll","through","thro’",
        "thyself","towards","weren't","whereby","wherein","whereof",
        "whereon","whereto","whether","whoever","without","won’t",
        "you-all","aren’t","didn’t","hadn’t","hasn’t","wasn’t",
        "doesn’t","haven’t","weren’t"];
    var default_stopwords={}; 
    var is=0, islim=default_stopwords_init.length;
    while (is<islim) {
        var stop_word=default_stopwords_init[is++];
        default_stopwords[stop_word]=stop_word;}

    function TextIndex(opts){
        if (!(opts)) opts={};
        var stopfns=opts.stopfns||false, stopwords={};
        var rootfns=opts.rootfns||false, rootmap={};
        var termindex={}, idterms={}, allterms=[], allids=[];
        var i, lim;
        
        function _indexer(string,id){
            var stdtext=stdspace(string).replace(/­/g,"");
            var words=stdtext.split(/\b/g), termlist=[];
            var i=0, lim=words.length;
            while (i<lim) {
                var term=words[i++], iscap=/[A-Z][^A-Z]/.exec(term);
                if (term.length<2) continue;
                else if (term.search(/\w/)<0) continue;
                else if (stopwords.hasOwnProperty(term)) continue;
                else if ((iscap)&&(stopwords.hasOwnProperty(term.toLowerCase())))
                    continue;
                else if (stopfns) {
                    var fn=0, fns=stopfns.length;
                    while (fn<fns) {
                        if ((stopfns[fn++])(term)) continue;}}
                else {
                    termlist.push(term);
                    if (rootmap.hasOwnProperty(term)) {
                        var roots=rootmap[term];
                        if (typeof roots === "string")
                            termlist.push(roots);
                        else termlist=termlist.concat(roots);}
                    if (rootfns) {
                        var rootfn=0, nrootfns=rootfns.length;
                        while (rootfn<nrootfns) {
                            var r=rootfns[rootfn++](term);
                            if (typeof r === "string")
                                termlist.push(r);
                            else termlist=termlist.concat(r);}}}}
            var ti=0, tlim=termlist.length;
            if (idterms.hasOwnProperty(id)) {
                idterms[id]=idterms[id].concat(termlist);}
            else {
                idterms[id]=termlist;
                allids.push(id);}
            while (ti<tlim) {
                var t=termlist[ti++];
                if (termindex.hasOwnProperty(t))
                    termindex[t].push(id);
                else {
                    allterms.push(t);
                    termindex[t]=[id];}}}

        function stopWord(s){
            if (stopwords.hasOwnProperty(s)) return true;
            if (stopfns) {
                var i=0, lim=stopfns.length;
                while (i<lim) {
                    if ((stopfns[i++])(s)) return true;}
                return false;}
            else return false;}
        
        function getRoots(s){
            var roots=rootmap[s]||[];
            var i=0, lim=rootfns.length; while (i<lim) {
                var r=rootfns[i++](s);
                if (!(r)) {}
                else if (typeof r === "string")
                    roots.push(r);
                else roots=roots.concat(r);}
            return roots;}
        
        function mergeTerms(){
            var i=0, lim=allterms.length;
            while (i<lim) {
                var term=allterms[i++];
                if (term.search(/[A-Z][a-z]/)===0) {
                    var lterm=term.toLowerCase();
                    if (termindex.hasOwnProperty(lterm))
                        termindex[lterm]=(
                            termindex[lterm].concat(termindex[term]));}}}
        
        function finishIndex(index){
            var newterms=[], newindex={};
            var i=0, lim=allterms.length, moved=[];
            var capwords=index.capwords;
            while (i<lim) {
                var term=allterms[i++];
                if (term.search(/[A-Z][a-z]/)===0) {
                    var lterm=term.toLowerCase();
                    if (!(termindex.hasOwnProperty(lterm))) {
                        newindex[term]=termindex[term];
                        newterms.push(term);}
                    else if (capwords.hasOwnProperty(term)) {
                        newindex[term]=termindex[term];
                        newterms.push(term);}
                    else moved.push(term);}
                else {
                    newindex[term]=termindex[term];
                    newterms.push(term);}}
            i=0; lim=moved.length; while (i<lim) {
                var move=moved[i++], l=move.toLowerCase();
                newindex[l]=newindex[l].concat(termindex[move]);}
            index.termindex=termindex=newindex;
            index.allterms=allterms=newterms;}
        
        if (!(this instanceof TextIndex))
            return new TextIndex(opts);
        else {
            this._indexer=_indexer;

            if (opts.stopwords) {
                var istops=opts.stopwords;
                i=0; lim=istops.length; while (i<lim) {
                    var stop=istops[i++];
                    stopwords[stop]=stop;}}
            
            if (opts.stdstops) {
                var is=0, islim=default_stopwords_init.length;
                while (is<islim) {
                    var stop_word=default_stopwords_init[is++];
                    stopwords[stop_word]=stop_word;}}

            this.capwords=opts.capwords||{};
            this.termindex=termindex;
            this.idterms=idterms;
            this.allterms=allterms;
            this.allids=allids;
            this.opts=opts;
            this.stopWord=stopWord;
            this.getRoots=getRoots;
            this.mergeTerms=mergeTerms;
            this.finishIndex=function(){finishIndex(this);};

            return this;}}

    TextIndex.default_stops=default_stopwords;
            
    TextIndex.prototype.indexText=function(arg,id){
        var indexer=this._indexer;
        if (typeof arg === "string") {
            if (id) indexer(arg,id);}
        else if (arg.nodeType) {
            if (!(id)) id=arg.id;
            if (id) indexer(textify(arg),id);}
        else if (arg.length) {
            var i=0, lim=arg.length; while (i<lim) {
                var node=arg[i++]; 
                if ((node.nodeType===1)&&(node.id))
                    indexer(textify(node),node.id);}}
        else {}};

    TextIndex.prototype.prefixTree=function(){
        if (this.prefixtree) return this.prefixtree;
        else {
            var ptree=this.prefixtree={strings: []};
            var prefixAdd=fdjtString.prefixAdd;
            var allterms=this.allterms;
            var i=0, lim=allterms.length;
            while (i<lim) {
                var term=allterms[i++];
                prefixAdd(ptree,term,0);}
            return ptree;}};

    return TextIndex;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/ui.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));
if (!(fdjt.UI)) fdjt.UI={};
if (!(fdjt.UI.CoHi)) fdjt.UI.CoHi={classname: "cohi"};
if (!(fdjt.UI.AutoPrompt)) fdjt.UI.AutoPrompt={};
if (!(fdjt.UI.InputHelp)) fdjt.UI.InputHelp={};
if (!(fdjt.UI.Ellipsis)) fdjt.UI.Ellipsis={};
if (!(fdjt.UI.Expansion)) fdjt.UI.Expansion={};
if (!(fdjt.UI.Collapsible)) fdjt.UI.Collapsible={};
if (!(fdjt.UI.Tabs)) fdjt.UI.Tabs={};
if (!(fdjt.UI.MultiText)) fdjt.UI.MultiText={};
if (!(fdjt.UI.Reticle)) fdjt.UI.Reticle={};
if (!(fdjt.UI.FocusBox)) fdjt.UI.FocusBox={};

/* Co-highlighting */

/* When the mouse moves over a named element, the 'cohi' class is added to
   all elements with the same name. */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var highlights={};
    function highlight(namearg,classname_arg){
        var classname=((classname_arg) || (fdjtUI.CoHi.classname));
        var newname=(namearg.name)||(namearg);
        var cur=highlights[classname];
        var i, n;
        if (cur===newname) return;
        if (cur) {
            var drop=document.getElementsByName(cur);
            i=0; n=drop.length;
            while (i<n) fdjtDOM.dropClass(drop[i++],classname);}
        highlights[classname]=newname||false;
        if (newname) {
            var elts=document.getElementsByName(newname);
            n=elts.length; i=0;
            while (i<n) fdjtDOM.addClass(elts[i++],classname);}}
    fdjtUI.CoHi.highlight=highlight;
    
    fdjtUI.CoHi.onmouseover=function cohi_onmouseover(evt,classname_arg){
        var target=fdjtDOM.T(evt);
        while (target) {
            if (target.nodeType===3) target=target.parentNode;
            else if (target.nodeType!==1) {target=false; break;}
            if ((target.tagName==='INPUT') || (target.tagName==='TEXTAREA') ||
                ((target.tagName==='A') && (target.href)))
                return;
            else if ((target.name)||(target.getAttribute("name")))
                break;  
            else target=target.parentNode;}
        if (!(target)) return;
        highlight(target.name||target.getAttribute("name"),classname_arg);};
    fdjtUI.CoHi.onmouseout=function cohi_onmouseout(evt,classname_arg){
        highlight(false,((classname_arg) || (fdjtUI.CoHi.classname)));};
})();


/* Text highlighting */

fdjt.UI.Highlight=(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;

    var highlight_class="fdjthighlight";
    var hasClass=fdjtDOM.hasClass;
    var hasParent=fdjtDOM.getParent;
    var getStyle=fdjtDOM.getStyle;

    function textnode(s){
        return document.createTextNode(s);}

    function gatherHighlights(node,classpat,into){
        if (node.nodeType!==1) return;
        if (node.childNodes) {
            var children=node.childNodes;
            var i=0, lim=children.length;
            while (i<lim) gatherHighlights(children[i++],classpat,into);}
        if ((node.className)&&(node.className.search)&&
            (node.className.search(classpat)>=0)) {
            into.push(node);}}

    function unwrap_hnode(hnode){
        var ch=hnode.childNodes;
        if (ch) {
            var frag=document.createDocumentFragment();
            var tomove=[], j=0, n=((ch)&&(ch.length));
            while (j<n) tomove.push(ch[j++]);
            j=0; n=tomove.length;
            while (j<n) frag.appendChild(tomove[j++]);
            fdjtDOM.replace(hnode,frag);}
        else fdjtDOM.remove(hnode);}
    
    function clear_highlights(node,hclass){
        var h=[];
        if ((node===hclass)||(hasClass(node,hclass))) h=[node];
        else gatherHighlights(node,new RegExp("\\b"+hclass+"\\b","g"),h);
        var i=0 , lim=h.length;
        while (i<lim) unwrap_hnode(h[i++]);}

    function highlight_node(node,hclass,htitle,hattribs){
        if (!(hclass)) hclass=highlight_class;
        var hispan=false;
        if (node.nodeType===3) {
            var text=node.nodeValue;
            if (text.search(/\S/g)>=0)
                hispan=fdjtDOM("span."+hclass);
            else {
                var parent=node.parentNode, style=getStyle(parent);
                var next=node.nextSibling, prev=node.prevSibling;
                var nstyle=next&&(next.nodeType===1)&&getStyle(next);
                var pstyle=prev&&(prev.nodeType===1)&&getStyle(prev);
                var ndisplay=nstyle&&nstyle.display;
                var pdisplay=pstyle&&pstyle.display;
                if (style.whiteSpace!=='normal')
                    hispan=fdjtDOM("span."+hclass);
                else if (!((next)||(prev)))
                    hispan=fdjtDOM("span."+hclass);
                else if ((!((ndisplay==='inline')||(ndisplay==='table-cell')))&&
                         (!((pdisplay==='inline')||(pdisplay==='table-cell'))))
                    hispan=false;
                else hispan=fdjtDOM("span."+hclass);}}
        else if ((node.nodeType!==1)||(hasClass(node,hclass)))
            return node;
        else if (hasClass(node,"fdjtskiptext")) {}
        else {
            var nodestyle=getStyle(node);
            var display=nodestyle.display;
            var position=nodestyle.position;
            if ((position!=="static")&&(position!=="")) {}
            else if (display==="block")
                hispan=(fdjtDOM("div."+hclass));
            else if (display==="inline")
                hispan=fdjtDOM("span."+hclass);
            else {}}
        if (!(hispan)) return node;
        if (htitle) hispan.title=htitle;
        if (hattribs) {
            for (var attrib in hattribs) {
                if (hattribs.hasOwnProperty(attrib))
                    hispan.setAttribute(attrib,hattribs[attrib]);}}
        fdjtDOM.replace(node,hispan);
        hispan.appendChild(node);
        return hispan;}
    function highlight_text(text,hclass,htitle,hattribs){
        var tnode=fdjtDOM("span."+(hclass||highlight_class),text);
        if (htitle) tnode.title=htitle;
        if (hattribs) {
            for (var attrib in hattribs) {
                if (hattribs.hasOwnProperty(attrib))
                    tnode.setAttribute(attrib,hattribs[attrib]);}}
        return tnode;}
    function highlight_node_range(node,start,end,hclass,htitle,hattribs){
        var stringval=node.nodeValue;
        var parent=node.parentNode;
        if ((end===false)||(typeof end === 'undefined'))
            end=stringval.length;
        if (start===end) return;
        var beginning=((start>0)&&(textnode(stringval.slice(0,start))));
        var middle=highlight_text(
            stringval.slice(start,end),hclass,htitle,hattribs);
        var ending=((end<stringval.length)&&
                    (textnode(stringval.slice(end))));
        if ((beginning)&&(ending)) {
            parent.replaceChild(ending,node);
            parent.insertBefore(middle,ending);
            parent.insertBefore(beginning,middle);}
        else if (beginning) {
            parent.replaceChild(middle,node);
            parent.insertBefore(beginning,middle);}
        else if (ending) {
            parent.replaceChild(ending,node);
            parent.insertBefore(middle,ending);}
        else parent.replaceChild(middle,node);
        return middle;}
    function highlight_range(range,hclass,htitle,hattribs){
        range=fdjtDOM.refineRange(range);
        var starts_in=range.startContainer;
        var ends_in=range.endContainer;
        if (starts_in===ends_in)
            return [highlight_node_range(
                starts_in,range.startOffset,range.endOffset,
                hclass,htitle,hattribs)];
        else {
            var highlights=[];
            var scan=starts_in;
            while ((scan)&&(!(scan.nextSibling)))
                scan=scan.parentNode;
            scan=scan.nextSibling;
            while (scan) {
                if (scan===ends_in) break;
                else if (hasParent(ends_in,scan))
                    scan=scan.firstChild;
                else {
                    var next=scan;
                    while ((next)&&(!(next.nextSibling)))
                        next=next.parentNode;
                    next=next.nextSibling;
                    highlights.push(
                        highlight_node(scan,hclass,htitle,hattribs));
                    scan=next;}}
            // Do the ends
            highlights.push(
                highlight_node_range(
                    starts_in,range.startOffset,false,hclass,htitle,hattribs));
            highlights.push(
                highlight_node_range(
                    ends_in,0,range.endOffset,hclass,htitle,hattribs));
            return highlights;}}

    highlight_range.clear=clear_highlights;
    highlight_range.remove=unwrap_hnode;
    highlight_range.highlight=highlight_range;
    return highlight_range;})();



/* CheckSpans:
   Text regions which include a checkbox where clicking toggles the checkbox. */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var getParent=fdjtDOM.getParent;
    var getChildren=fdjtDOM.getChildren;

    function CheckSpan(spec,varname,val,checked){
        var input=fdjtDOM.Input('input[type=checkbox]',varname,val);
        var span=fdjtDOM(spec||"span.checkspan",input);
        if (checked) {
            input.checked=true;
            fdjtDOM.addClass(span,"ischecked");}
        else input.checked=false;
        if (arguments.length>4) 
            fdjtDOM.appendArray(span,arguments,4);
        return span;}
    fdjtUI.CheckSpan=CheckSpan;

    function checkable(elt){
        return (elt.nodeType===1)&&
            (elt.tagName==='INPUT')&&
            ((elt.type==='checkbox')||(elt.type==='radio'));}
    function getcheckable(elt){
        if (checkable(elt)) return elt;
        var cb=getParent(elt,checkable);
        if (cb) return cb;
        cb=getChildren(elt,'input');
        if (cb.length) {
            var i=0; var lim=cb.length;
            while (i<lim)
                if (checkable(cb[i])) return cb[i]; else i++;
            return false;}
        else return false;}

    function checkspan_set(target,checked) {
        var i, lim;
        if (typeof target === 'string') target=fdjtID(target);
        else if (target.length) {
            i=0; lim=target.length;
            while (i<lim) checkspan_set(target[i++],checked);
            return;}
        if ((!(target))||(!(target.nodeType))) return;
        var checkspan=((hasClass(target,"checkspan"))?(target):
                       (getParent(target,".checkspan")));
        if (!(checkspan)) return false;
        var checkbox=((checkable(target))&&(target))||
            (getcheckable(target))||
            (getcheckable(checkspan));
        if (!(checkbox)) return false;
        if (hasClass(checkspan,"isdisabled")) {
            if (checkbox.disabled) return false;
            else dropClass(checkspan,"isdisabled");}
        else if (checkbox.disabled) {
            addClass(checkspan,"isdisabled");
            return false;}
        var ischecked=hasClass(checkspan,"ischecked");
        var changed=false; var unchecked=[];
        if (typeof checked === 'undefined') checked=ischecked;
        if (checkbox.checked!==checked) {
            checkbox.checked=checked; changed=true;}
        // If the checkspan is inconsistent, the checkbox was probably
        // just changed
        else if (ischecked!==checkbox.checked) changed=true;
        else {}
        // We change this anyway, just in case there's been a glitch
        if (checked) addClass(checkspan,"ischecked");
        else dropClass(checkspan,"ischecked");
        if ((changed)&&(checkbox.type==='radio')) {
            var form=checkbox.form;
            if (!(form)) form=getParent(checkbox,".fdjtinputs");
            if (!(form)) form=checkspan.parentNode;
            var name=checkbox.name;
            var tosync=getChildren(form,'input');
            i=0; lim=tosync.length;
            while (i<lim) {
                var input=tosync[i++];
                if (input===checkbox) continue;
                else if ((input.type==='radio')&&
                         (input.name===name)) {
                    var cspan=getParent(input,".checkspan");
                    if (cspan===checkspan) continue;
                    else if (hasClass(cspan,"ischecked"))
                        if (!(input.checked)) unchecked.push(input);}
                else {}}}
        var evt;
        if (changed) {
            evt=document.createEvent("HTMLEvents");
            evt.initEvent("change",false,true);
            checkbox.dispatchEvent(evt);}
        if (unchecked.length) {
            i=0; lim=unchecked.length;
            while (i<lim) {
                var uncheck=unchecked[i++];
                var altspan=getParent(uncheck,".checkspan");
                dropClass(altspan,"ischecked");
                evt=document.createEvent("HTMLEvents");
                evt.initEvent("change",false,true);
                uncheck.dispatchEvent(evt);}}}
    fdjtUI.CheckSpan.set=checkspan_set;

    function checkspan_onclick(evt) {
        evt=evt||window.event;
        var target=evt.target||evt.srcTarget;
        if ((target.tagName==='TEXTAREA')||
            (target.tagName==='SELECT')||
            (target.tagName==='OPTION')||
            ((target.tagName==='INPUT')&&
             (!((target.type==='checkbox')||
                (target.type==='radio')))))
            return;
        var anchor=((target.tagName==='A')?(target):
                    (getParent(target,'A')));
        if ((anchor)&&(anchor.href)) return;
        var checkspan=getParent(target,".checkspan");
        if (!(checkspan)) return;
        var checked=hasClass(checkspan,"ischecked");
        checkspan_set(target,(!(checked)));
        return false;}
    fdjtUI.CheckSpan.onclick=checkspan_onclick;    

    function changed(evt) {
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        if ((target.type==='radio')||(target.type==='checkbox')) {
            var checkspan=getParent(target,'.checkspan');
            if (checkspan)
                ((target.checked)?(addClass):(dropClass))(
                    checkspan,"ischecked");}
        if (target.type==='radio') {
            var form=target.form;
            var others=document.getElementsByName(target.name);
            var i=0, lim=others.length;
            while (i<lim) {
                var other=others[i++];
                if (other===target) continue;
                else if (other.form!==form) continue;
                else if (other.type !== 'radio') continue;
                var ocs=fdjtDOM.getParent(other,'.checkspan');
                dropClass(ocs,"ischecked");}}}
    fdjtUI.CheckSpan.changed=changed;

    function initCheckspans(){
        var checkspans=fdjt.$(".checkspan");
        var i=0, lim=checkspans.length;
        while (i<lim) {
            var checkspan=checkspans[i++];
            var inputs=fdjtDOM.getInputs(checkspan);
            var j=0, jlim=inputs.length;
            while (j<jlim) {
                var input=inputs[j++];
                if ((input.type==='radio')||(input.type==='checkspan')) {
                    if (input.checked) addClass(checkspan,"ischecked");
                    if (input.disabled) addClass(checkspan,"isdisabled");
                    break;}}}}
    fdjtUI.CheckSpan.initCheckspans=initCheckspans;

    fdjt.addInit(initCheckspans,"CheckSpans",false);

})();


/* Progress boxes */

fdjt.UI.ProgressBar=(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    function ProgressBar(arg){
        if (typeof arg==='undefined')
            arg=fdjtDOM("div.fdjtprogress",
                        fdjtDOM("div.indicator"),fdjtDOM("div.message"));
        else if (typeof arg==='string')
            arg=fdjtDOM("div.fdjtprogress",
                        fdjtDOM("HR"),fdjtDOM("div.message",arg));
        this.dom=arg;
        return this;}

    function setProgress(pb,progress,total){
        if (typeof pb==='string')
            pb=document.getElementById(pb);
        if (typeof total==='number')
            progress=100*(progress/total);
        if (!(pb)) return;
        var dom=((pb.dom)||(pb));
        if (!(dom.nodeType)) return;
        var rule=fdjtDOM.getChildren(dom,"div.indicator")[0];
        rule.style.width=progress+"%";}
    function setMessage(pb){
        if (typeof pb==='string')
            pb=document.getElementById(pb);
        if (!(pb)) return;
        var dom=((pb.dom)||(pb));
        if (!(dom.nodeType)) return;
        var oldmsg=fdjtDOM.getChildren(dom,".message")[0];
        var newmsg=fdjtDOM("div.message");
        fdjtDOM.appendArray(newmsg,fdjtDOM.Array(arguments,1));
        dom.replaceChild(newmsg,oldmsg);}
    
    ProgressBar.setProgress=setProgress;
    ProgressBar.setMessage=setMessage;
    ProgressBar.prototype.setProgress=function(progress,total){
        setProgress(this.dom,progress,total);};
    ProgressBar.prototype.setMessage=function(){
        var dom=this.dom;
        var oldmsg=fdjtDOM.getChildren(dom,".message")[0];
        var newmsg=fdjtDOM("div.message");
        fdjtDOM.appendArray(newmsg,fdjtDOM.Array(arguments));
        dom.replaceChild(newmsg,oldmsg);};

    return ProgressBar;})();


/* Automatic help display on focus */

(function(){
    "use strict";

    var fdjtString=fdjt.String;
    var fdjtDOM=fdjt.DOM;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;

    function show_help_onfocus(evt){
        var target=fdjtDOM.T(evt);
        while (target)
            if ((target.nodeType===1) &&
                ((target.tagName === 'INPUT') ||
                 (target.tagName === 'TEXTAREA')) &&
                (target.getAttribute('helptext'))) {
                var helptext=fdjtID(target.getAttribute('helptext'));
                if (helptext) fdjtDOM.addClass(helptext,"showhelp");
                return;}
        else target=target.parentNode;}
    function autoprompt_onfocus(evt){
        evt=evt||window.event||null;
        var elt=fdjtDOM.T(evt);
        if ((elt) && (hasClass(elt,'isempty'))) {
            elt.value=''; dropClass(elt,'isempty');}
        show_help_onfocus(evt);}

    function hide_help_onblur(evt){
        var target=fdjtDOM.T(evt);
        while (target)
            if ((target.nodeType===1) &&
                ((target.tagName === 'INPUT') || (target.tagName === 'TEXTAREA')) &&
                (target.getAttribute('HELPTEXT'))) {
                var helptext=fdjtID(target.getAttribute('HELPTEXT'));
                if (helptext) dropClass(helptext,"showhelp");
                return;}
        else target=target.parentNode;}
    function autoprompt_onblur(evt){
        var elt=fdjtDOM.T(evt);
        if (elt.value==='') {
            addClass(elt,'isempty');
            var prompt=(elt.prompt)||(elt.getAttribute('prompt'))||(elt.title);
            if (prompt) elt.value=prompt;}
        else dropClass(elt,'isempty');
        hide_help_onblur(evt);}
    
    // Removes autoprompt text from empty fields
    function autoprompt_cleanup(form) {
        var elements=fdjtDOM.getChildren(form,".isempty");
        if (elements) {
            var i=0; var lim=elements.length;
            while (i<lim) elements[i++].value="";}}
    function autoprompt_onsubmit(evt) {
        var form=fdjtDOM.T(evt);
        autoprompt_cleanup(form);}

    var isEmpty=fdjtString.isEmpty;
    // Adds autoprompt handlers to autoprompt classes
    function autoprompt_setup(arg,nohandlers) {
        var forms=
            ((arg.tagName==="FORM")?[arg]:
             (fdjtDOM.getChildren(arg||document.body,"FORM")));
        var i=0; var lim=forms.length;
        while (i<lim) {
            var form=forms[i++];
            var inputs=fdjtDOM.getChildren
            (form,"INPUT.autoprompt,TEXTAREA.autoprompt");
            if (inputs.length) {
                var j=0; var jlim=inputs.length;
                while (j<jlim) {
                    var input=inputs[j++];
                    input.blur();
                    if (isEmpty(input.value)) {
                        addClass(input,"isempty");
                        var prompt=(input.prompt)||
                            (input.getAttribute('prompt'))||(input.title);
                        if (prompt) input.value=prompt;}
                    if (!(nohandlers)) {
                        fdjtDOM.addListener(input,"focus",autoprompt_onfocus);
                        fdjtDOM.addListener(input,"blur",autoprompt_onblur);}}
                if (!(nohandlers))
                    fdjtDOM.addListener(form,"submit",autoprompt_onsubmit);}}}
    
    fdjt.UI.AutoPrompt.setup=autoprompt_setup;
    fdjt.UI.AutoPrompt.onfocus=autoprompt_onfocus;
    fdjt.UI.AutoPrompt.onblur=autoprompt_onblur;
    fdjt.UI.AutoPrompt.onsubmit=autoprompt_onsubmit;
    fdjt.UI.AutoPrompt.cleanup=autoprompt_cleanup;
    fdjt.UI.InputHelp.onfocus=show_help_onfocus;
    fdjt.UI.InputHelp.onblur=hide_help_onblur;})();

/* Automatic classes for focused children */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtUI=fdjt.UI;
    var addListener=fdjtDOM.addListener;
    function fdjt_focusin(evt){
        var scan=fdjtUI.T(evt), add=[]; 
        if ((scan.tagName==='TEXTAREA')||
            ((scan.tagName==='INPUT')&&
             (/text|email/i.exec(scan.type)))) {
            while (scan) {
                var classname=scan.className;
                if ((classname)&&(typeof classname === "string")&&
                    (classname.search(/\bfdjtfoci\b/)>=0)&&
                    (classname.search(/\bfdjtfocus\b/)<0))
                    add.push(scan);
                scan=scan.parentNode;}
            if (add.length) 
                setTimeout(function(){
                    var i=0; while (i<add.length) {
                        var elt=add[i++], classname=elt.className;
                        elt.className=classname+" fdjtfocus";}},
                           300);}}
    fdjtUI.focusin=fdjt_focusin;
    addListener(window,"focusin",fdjt_focusin);
    function fdjt_focusout(evt){
        var scan=fdjtUI.T(evt), drop=[];
        if ((scan.tagName==='TEXTAREA')||
            ((scan.tagName==='INPUT')&&
             (/text|email/i.exec(scan.type)))) {
            while (scan) {
                var classname=scan.className;
                if ((classname)&&(typeof classname === "string")&&
                    (classname.search(/\bfdjtfocus\b/)>=0))
                    drop.push(scan);
                scan=scan.parentNode;}
            if (drop.length) 
                setTimeout(function(){
                    var i=0; while (i<drop.length) {
                        var elt=drop[i++], classname=elt.className;
                        elt.className=classname.replace(/ fdjtfocus\b/,"");}},
                           300);}}
    fdjtUI.focusout=fdjt_focusout;
    addListener(window,"focusout",fdjt_focusout);})();

/* Text input boxes which create checkspans on enter. */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtString=fdjt.String;
    var isEmpty=fdjtString.isEmpty;
    var hasClass=fdjtDOM.hasClass;

    function multitext_keypress(evt,sepchars,sepexp,fn){
        // sepchars are characters which function just like 'Return'
        // sepexp is a regular expression which is used to split an
        //   input string into multiple values
        evt=(evt)||(event);
        var chcode=evt.charCode, ch=String.fromCharCode(chcode);
        var target=fdjtUI.T(evt);
        if  (sepchars instanceof RegExp) {
            sepexp=sepchars; sepchars=false;}
        else if ((sepchars)&&(sepchars.call)) {
            fn=sepchars; sepchars=false;}
        else {}
        if ((!sepchars)&&(target.getAttribute("data-sepchars")))
            sepchars=target.getAttribute("data-sepchars");
        if ((chcode===13)&&(isEmpty(target.value))&&
            (hasClass(target,"fdjtentersubmit"))) {
            fdjt.UI.cancel(evt);
            target.form.submit();
            return;}
        if ((chcode===13)||
            ((sepchars)&&((sepchars.indexOf(ch))>=0))) {
            if ((!(sepexp))&&(target.getAttribute("data-separator")))
                sepexp=new RegExp(target.getAttribute("data-separator"),"g");
            var checkspec=
                target.getAttribute("data-checkspec")||"div.checkspan";
            var values=((sepexp)?(target.value.split(sepexp)):[target.value]);
            var i=0, lim=values.length; while (i<lim) {
                var value=values[i++];
                if (fn)
                    fdjtDOM(target.parentNode,"\n",fn(target.name,value));
                else {
                    var checkbox=
                        fdjtDOM.Input("[type='checkbox']",target.name,value);
                    var checkelt=fdjtDOM(checkspec,checkbox,value);
                    checkbox.checked=true;
                    fdjtDOM.addClass(checkelt,"ischecked");
                    fdjtDOM(target.parentNode,"\n",checkelt);}}
            fdjtUI.cancel(evt);
            target.value='';}}
    fdjtUI.MultiText.keypress=multitext_keypress;})();


/* Tabs */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtLog=fdjt.Log;
    var fdjtState=fdjt.State;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    
    function tab_onclick(evt,shownclass){
        var elt=fdjtUI.T(evt);
        if (!(shownclass)) {
            shownclass=
                fdjtDOM.findAttrib(elt,"shownclass","http://fdjt.org/")||
                "fdjtshown";}
        if (elt) {
            var content_id=false;
            while (elt.parentNode) {
                if ((content_id=fdjtDOM.getAttrib(elt,"contentid"))) break;
                else elt=elt.parentNode;}
            if (!(content_id)) return;
            var content=document.getElementById(content_id);
            var parent=fdjtDOM.getParent(elt,".tabs")||elt.parentNode;
            var sibs=fdjtDOM.getChildren(parent,".tab")||parent.childNodes;
            if (content===null) {
                fdjtLog("No content for "+content_id);
                return;}
            var i=0; while (i<sibs.length) {
                var node=sibs[i++]; var cid;
                if ((node.nodeType===1) &&
                    (cid=fdjtDOM.getAttrib(node,"contentid"))) {
                    if (!(cid)) continue;
                    var cdoc=document.getElementById(cid);
                    if (node===elt) {}
                    else if (hasClass(node,shownclass)) {
                        dropClass(node,shownclass);
                        if (cdoc) dropClass(cdoc,shownclass);}}}
            if (hasClass(elt,shownclass)) {
                dropClass(elt,shownclass);
                dropClass(content,shownclass);}
            else {
                addClass(elt,shownclass);
                addClass(content,shownclass);}
            var tabstate=fdjtDOM.findAttrib(elt,'tabstate');
            if (!(tabstate)) {}
            else if (tabstate==='#') {
                var scrollstate={};
                fdjtUI.scrollSave(scrollstate);
                document.location.hash=tabstate+content_id;
                fdjtUI.scrollRestore(scrollstate);}
            else fdjtState.setCookie(tabstate,content_id);
            // This lets forms pass tab information along
            return false;}}
    fdjtUI.Tabs.click=tab_onclick;
    
    function select_tab(tabbar,contentid,shownclass){
        if (!(shownclass)) {
            shownclass=
                fdjtDOM.findAttrib(tabbar,"shownclass","http://fdjt.org/")||
                "fdjtshown";}
        var tabseen=false;
        var tabs=fdjtDOM.getChildren(tabbar,".tab");
        var i=0; while (i<tabs.length) {
            var tab=tabs[i++];
            if ((tab.getAttribute("contentid"))===contentid) {
                addClass(tab,shownclass); tabseen=true;}
            else if (hasClass(tab,shownclass)) {
                dropClass(tab,shownclass);
                var cid=fdjtDOM.getAttrib(tab,"contentid");
                var content=(cid)&&fdjtID(cid);
                if (!(content))
                    fdjtLog.warn("No reference for tab content %o",cid);
                else dropClass(content,shownclass);}
            else dropClass(tab,shownclass);}
        if (fdjtID(contentid)) {
            if (tabseen) addClass(contentid,shownclass);
            else fdjtLog.warn("a tab for %s was not found in %o",
                              contentid,tabbar);}
        else fdjtLog.warn("No reference for tab content %o",contentid);}
    fdjtUI.Tabs.selectTab=select_tab;
    
    function setupTabs(elt){
        if (!(elt)) elt=fdjtDOM.$(".tabs[tabstate]");
        else if (typeof elt === 'string') elt=fdjtID(elt);
        if ((!(elt))||(!(elt.getAttribute("tabstate")))) return;
        var tabstate=elt.getAttribute("tabstate");
        var content_id=false;
        if (tabstate==='#') {
            content_id=document.location.hash;
            if (content_id[0]==='#') content_id=content_id.slice(1);
            var content=((content_id)&&(fdjtID(content_id)));
            if (!(content)) return;
            var ss={}; fdjtUI.scrollSave(ss);
            window.scrollTo(0,0);
            if (!(fdjtDOM.isVisible(content)))
                fdjtUI.scrollRestore(ss);}
        else content_id=fdjtState.getQuery(tabstate)||
            fdjtState.getCookie(tabstate);
        if (!(content_id)) return;
        if (content_id[0]==='#') content_id=content_id.slice(1);
        if (content_id) select_tab(elt,content_id);}
    fdjtUI.Tabs.setup=setupTabs;
    
    function selected_tab(tabbar){
        var tabs=fdjtDOM.getChildren(tabbar,".tab");
        var i=0; while (i<tabs.length) {
            var tab=tabs[i++];
            if (hasClass(tab,"shown"))
                return tab.getAttribute("contentid");}
        return false;}
    fdjtUI.Tabs.getSelected=selected_tab;}());



/* Collapse/Expand */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

   fdjtUI.Expansion.toggle=function(evt,spec,exspec){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var wrapper=fdjtDOM.getParent(target,spec||".fdjtexpands");
        if (wrapper) fdjtDOM.toggleClass(wrapper,exspec||"fdjtexpanded");};
    fdjtUI.Expansion.onclick=fdjtUI.Expansion.toggle;

    fdjtUI.Collapsible.click=function(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        if (fdjtUI.isDefaultClickable(target)) return;
        var wrapper=fdjtDOM.getParent(target,".collapsible");
        if (wrapper) {
            fdjtUI.cancel(evt);
            fdjtDOM.toggleClass(wrapper,"expanded");}};

    fdjtUI.Collapsible.focus=function(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var wrapper=fdjtDOM.getParent(target,".collapsible");
        if (wrapper) {
            fdjtDOM.toggleClass(wrapper,"expanded");}};
    
    fdjtUI.toggleParent=function toggleParent(evt,spec,classname){
        var target=fdjtUI.T(evt);
        var parent=fdjtDOM.getParent(target,spec);
        if (parent) fdjtDOM.toggleClass(parent,classname);};})();


/* Temporary Scrolling */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var saved_scroll=false;
    var use_native_scroll=false;
    var preview_elt=false;

    function scroll_discard(ss){
        if (ss) {
            ss.scrollX=false; ss.scrollY=false;}
        else saved_scroll=false;}

    function scroll_save(ss){
        if (ss) {
            ss.scrollX=window.scrollX; ss.scrollY=window.scrollY;}
        else {
            if (!(saved_scroll)) saved_scroll={};
            saved_scroll.scrollX=window.scrollX;
            saved_scroll.scrollY=window.scrollY;}}

    function scroll_into_view(elt,topedge){
        if ((topedge!==0) && (!topedge) && (fdjtDOM.isVisible(elt)))
            return;
        else if ((use_native_scroll) && (elt.scrollIntoView)) {
            elt.scrollIntoView(topedge);
            if ((topedge!==0) && (!topedge) && (fdjtDOM.isVisible(elt,true)))
                return;}
        else {
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var height = elt.offsetHeight;
            
            while(elt.offsetParent) {
                elt = elt.offsetParent;
                top += elt.offsetTop;
                left += elt.offsetLeft;}
            
            var vh=fdjtDOM.viewHeight();
            var x=0; var y;
            var y_target=top+(height/3);
            if ((2*(height/3))<((vh/2)-50))
                y=y_target-vh/2;
            else if ((height)<(vh-100))
                y=top-(50+(height/2));
            else y=top-50;

            window.scrollTo(x,y);}}

    fdjtUI.scrollTo=function(target,id,context,discard,topedge){
        scroll_discard(discard);
        if (id) document.location.hash=id;
        if (context) {
            setTimeout(function() {
                scroll_into_view(context,topedge);
                if (!(fdjtDOM.isVisible(target))) {
                    scroll_into_view(target,topedge);}},
                       100);}
        else setTimeout(function() {scroll_into_view(target,topedge);},100);};

    function scroll_preview(target,context,delta){
        /* Stop the current preview */
        if (!(target)) {
            stop_preview(); return;}
        /* Already previewing */
        if (target===preview_elt) return;
        if (!(saved_scroll)) scroll_save();
        if (typeof target === 'number')
            window.scrollTo(((typeof context === 'number')&&(context))||0,target);
        else scroll_into_view(target,delta);
        preview_elt=target;}

    function scroll_restore(ss){
        if (preview_elt) {
            preview_elt=false;}
        if ((ss) && (typeof ss.scrollX === "number")) {
            // fdjtLog("Restoring scroll to %d,%d",ss.scrollX,ss.scrollY);    
            window.scrollTo(ss.scrollX,ss.scrollY);
            return true;}
        else if ((saved_scroll) &&
                 ((typeof saved_scroll.scrollY === "number") ||
                  (typeof saved_scroll.scrollX === "number"))) {
            // fdjtLog("Restoring scroll to %o",_fdjt_saved_scroll);
            window.scrollTo(saved_scroll.scrollX,saved_scroll.scrollY);
            saved_scroll=false;
            return true;}
        else return false;}

    function stop_preview(){
        fdjtDOM.dropClass(document.body,"preview");
        if ((preview_elt) && (preview_elt.className))
            fdjtDOM.dropClass(preview_elt,"previewing");
        preview_elt=false;}

    fdjtUI.scrollSave=scroll_save;
    fdjtUI.scrollRestore=scroll_restore;
    fdjtUI.scrollIntoView=scroll_into_view;
    fdjtUI.scrollPreview=scroll_preview;
    fdjtUI.scrollRestore=scroll_restore;}());


/* Smart (DOM-aware) scrolling */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;

    var getGeometry=fdjtDOM.getGeometry;
    var getStyle=fdjtDOM.getStyle;

    function smartScroll(win,off,content){
        if (typeof content==='undefined') content=win;
        if (off<=0) {win.scrollTop=0; return;}
        else {
            var block=findBreak(content,off,content);
            if (!(block)) {win.scrollTop=off; return;}
            var geom=getGeometry(block,content||win);
            if ((geom-top-off)<(win.offsetTop/4))
                win.scrollTop=geom.top;
            else win.scrollTop=off;}}
    function findBreak(node,off,container){
        var style=getStyle(node);
        var display=style.display;
        if ((display==='block')||(display==='table-row')||
            (display==='list-item')||(display==='preformatted')) {
            var geom=getGeometry(node,container);
            if (geom.top>off) return node;
            else if (geom.bottom>off) {
                if (style.pageBreakInside==='avoid')
                    return node;
                var children=node.childNodes;
                var i=0, lim=children.length;
                while (i<lim)  {
                    var child=children[i++];
                    var bk=((child.nodeType===1)&&
                            (findBreak(child,off,container)));
                    if (bk) return bk;}
                return node;}
            else return false;}
        else return false;}

    fdjt.UI.smartScroll=smartScroll;})();


/* Delays */

(function(){
    "use strict";

    fdjt.UI.Delay=function(interval,name,fcn){
        setTimeout(fcn,interval);};
    fdjt.UI.Delayed=function(fcn,interval){
        if (!(interval)) interval=25;
        setTimeout(fcn,interval);};})();

/* Triggering submit events */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    function dosubmit(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var form=fdjtDOM.getParent(target,"FORM");
        var submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent('submit',false,true);
        form.dispatchEvent(submit_event);
        form.submit();}
    fdjtUI.dosubmit=dosubmit;

    function forceSubmit(form){
        var submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent('submit',false,true);
        form.dispatchEvent(submit_event);}
    fdjtUI.forceSubmit=forceSubmit;

    function submitOnEnter(evt){
        evt=evt||window.event;
        var kc=evt.keyCode||evt.charCode;
        if (kc===13) {
            var target=fdjtUI.T(evt);
            var form=fdjtDOM.getParent(target,'FORM');
            fdjtUI.cancel(evt);
            form.submit();}}
    fdjtUI.submitOnEnter=submitOnEnter;

    function checkFileInputs(evt){
        evt=evt||window.event;
        var form=fdjtUI.T(evt);
        var file_inputs=fdjtDOM.getInputs(form,false,"file");
        var i=0, lim=file_inputs.length; while (i<lim) {
            var input=file_inputs[i++];
            if ((!(input.value))||(input.value==="")) {
                fdjtUI.cancel(evt);
                (fdjt.UI.alert||window.alert)("You need to specify a file!");}}}
    fdjtUI.checkFileInputs=checkFileInputs;

}());

/* Looking for vertical box overflow */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var getGeometry=fdjtDOM.getGeometry;
    var getInsideBounds=fdjtDOM.getInsideBounds;
    function checkOverflow(node){
        var geom=getGeometry(node);
        var inside=getInsideBounds(node);
        if (inside.bottom>geom.bottom) addClass(node,"overflow");
        else dropClass(node,"overflow");}
    fdjtUI.Overflow=checkOverflow;}());


/* Reticle based functions */

(function() {
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var vreticle=false;
    var hreticle=false;
    function setXY(x,y){
        if  (vreticle) (vreticle).style.left=x+'px';
        if  (hreticle) (hreticle).style.top=y+'px';}
    function setupReticle(){
        if (!(vreticle)) {
            vreticle=fdjtDOM("div.reticle.vertical#VRETICLE"," ");
            fdjtDOM.prepend(document.body,vreticle);}
        if (!(hreticle)) {
            hreticle=fdjtDOM("div.reticle.horizontal#HRETICLE"," ");
            fdjtDOM.prepend(document.body,hreticle);}
        fdjtDOM.addListener(document,"mousemove",mousemove);
        fdjtDOM.addListener(document,"click",doflash);
        fdjtUI.Reticle.live=true;}
    
    function doflash(){flash();}

    function mousemove(evt,x,y){
        setXY(x||evt.clientX,y||evt.clientY);}
    
    var highlighted=false;
    
    function highlight(flag){
        if (typeof flag === 'undefined') flag=(!(highlighted));
        if (flag) {
            if (vreticle) fdjtDOM.addClass(vreticle,"highlight");
            if (hreticle) fdjtDOM.addClass(hreticle,"highlight");
            highlighted=true;}
        else {
            if (vreticle) fdjtDOM.dropClass(vreticle,"highlight");
            if (hreticle) fdjtDOM.dropClass(hreticle,"highlight");
            highlighted=false;}}
    
    function flash(howlong){
        if (typeof howlong === 'undefined') howlong=1500;
        if (highlighted) return;
        else {
            highlight(true);
            setTimeout(function(){highlight(false);},howlong);}}

    fdjtUI.Reticle.setup=setupReticle;
    fdjtUI.Reticle.highlight=highlight;
    fdjtUI.Reticle.flash=flash;
    fdjtUI.Reticle.onmousemove=mousemove;
    fdjtUI.Reticle.setXY=setXY;
    fdjtUI.Reticle.live=false;})();


/* File uploader affirmation handling */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    fdjtUI.uploadSpecified=function(evt){
        evt=evt||window.event;
        var parent=fdjtDOM.getParent(fdjtUI.T(evt),'.fileuploader');
        if (parent) fdjtDOM.addClass(parent,'inuse');};})();


/* Image swapping */

(function(){
    "use strict";
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;
    /* global setInterval: false */

    function ImageSwap(img,interval){
        if (typeof img==='string') img=fdjtID(img);
        if (!(img)) return false;
        if (!(interval))
            interval=((img.getAttribute('data-interval'))?
                      (parseInt((img.getAttribute('data-interval')),10)):
                      (ImageSwap.interval));
        if (!(img.getAttribute("data-images"))) {
            img.setAttribute("data-images",img.src);}
        if (!(img.defaultsrc)) img.defaultsrc=img.src;
        var images=(img.getAttribute('data-images')).split('|');
        if (images.length===0) return false;
        var counter=0;
        return setInterval(function(){
            if (img.src===images[counter]) counter++;
            else img.src=images[counter++];
            if (counter>=images.length) counter=0;},
                           interval);}
            
    ImageSwap.reset=function(img){
        if (img.defaultsrc) img.src=img.defaultsrc;};
    ImageSwap.interval=1000;

    fdjtUI.ImageSwap=ImageSwap;})();


/* Miscellaneous event-related functions */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    
    fdjtUI.T=function(evt) {
        evt=evt||window.event; return (evt.target)||(evt.srcElement);};

    fdjtUI.noDefault=function(evt){
        evt=evt||window.event;
        if (evt.preventDefault) evt.preventDefault();
        else evt.returnValue=false;
        return false;};

    fdjtUI.noBubble=function(evt){
        evt=evt||window.event;
        evt.cancelBubble=true;};

    fdjtUI.cancel=function(evt){
        evt=evt||window.event;
        if (evt.preventDefault) evt.preventDefault();
        else evt.returnValue=false;
        evt.cancelBubble=true;
        return false;};

    fdjtUI.isClickable=function(target){
        if ((window.Event)&&(target instanceof window.Event))
            target=fdjtUI.T(target);
        while (target) {
            if (((target.tagName==='A')&&(target.href))||
                (target.tagName==="INPUT") ||
                (target.tagName==="BUTTON") ||
                (target.tagName==="TEXTAREA") ||
                (target.tagName==="SELECT") ||
                (target.tagName==="OPTION") ||
                (hasClass(target,"checkspan"))||
                (hasClass(target,"clickable"))||
                (hasClass(target,"isclickable")))
                return true;
            else if (target.onclick)
              return true;
            else target=target.parentNode;}
        return false;};

    fdjtUI.isDefaultClickable=function(target){
        if ((window.Event)&&(target instanceof window.Event))
            target=fdjtUI.T(target);
        while (target) {
            if (((target.tagName==='A')&&(target.href))||
                (target.tagName==="INPUT") ||
                (target.tagName==="TEXTAREA") ||
                (target.tagName==="SELECT") ||
                (target.tagName==="OPTION") ||
                (hasClass(target,"isclickable")))
                return true;
            else target=target.parentNode;}
        return false;};

    function submitEvent(arg){
        var form=((arg.nodeType)?(arg):(fdjtUI.T(arg)));
        while (form) {
            if (form.tagName==='FORM') break;
            else form=form.parentNode;}
        if (!(form)) return;
        var submit_evt = document.createEvent("HTMLEvents");
        submit_evt.initEvent("submit", true, true);
        form.dispatchEvent(submit_evt);
        return;}
    fdjtUI.submitEvent=submitEvent;

    function focusEvent(arg){
        var elt=((arg.nodeType)?(arg):(fdjtUI.T(arg)));
        var focus_evt = document.createEvent("HTMLEvents");
        focus_evt.initEvent("focus", true, true);
        elt.dispatchEvent(focus_evt);
        return;}
    fdjtUI.focusEvent=focusEvent;

    function disableForm(form){
        if (typeof form === 'string') form=fdjtID(form);
        if (!(form)) return;
        var elements=fdjtDOM.getChildren(
            form,"button,input,optgroup,option,select,textarea");
        var i=0; var lim=elements.length;
        while (i<lim) elements[i++].disabled=true;}
    fdjtUI.disableForm=disableForm;
    
}());

/* Ellipsis */

(function(){
    "use strict";
    var fdjtString=fdjt.String;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;


    var ellipsize=fdjtString.ellipsize;
    var getParent=fdjtDOM.getParent;
    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;

    function Ellipsis(spec,string,lim,thresh,handler){
        var content=ellipsize(string,lim,thresh||0.2);
        var split=(typeof content !== "string");
        var len=string.length;
        if (!(handler)) handler=toggle;
        if ((typeof content === "string")&&(content.length===len)) {
            // No elision, just return the string
            if (spec) return fdjtDOM(spec,string);
            else return document.createTextNode(string);}
        var before=((split)?(content[0]):(content));
        var after=((split)?(content[1]):(""));
        var clen=before.length+after.length;
        var pct=Math.round((100*(clen))/len);
        if (spec) addClass(elt,"ellipsis");
        var remaining=((split)?
                       (string.slice(before.length,len-after.length)):
                       (string.slice(before.length)));
        var elided=fdjtDOM("span.elided",remaining);
        var elision=fdjtDOM(
            "span.elision",fdjtString(" …←%d%% more→…",100-pct));
        var delision=fdjtDOM(
            "span.delision",fdjtString(" →…hide %d%%…← ",100-pct));
        elision.title="show elided text";
        delision.title="hide elided text";
        elision.onclick=handler; delision.onclick=handler;
        var elt=fdjtDOM(spec||"span.ellipsis",
                        before," ",elision,delision,elided," ",after);
        if (spec) addClass(elt,"ellipsis");
        elt.title=fdjtString.stdspace(string);
        return elt;}
    fdjtUI.Ellipsis=Ellipsis;

    function expand(node){
        if (typeof node === 'string') node=fdjtID(node);
        var ellipsis=getParent(node,".ellipsis");
        addClass(ellipsis,"expanded");
        dropClass(ellipsis,"compact");}
    Ellipsis.expand=expand;

    function contract(node){
        if (typeof node === 'string') node=fdjtID(node);
        var ellipsis=getParent(node,".ellipsis");
        addClass(ellipsis,"compact");
        dropClass(ellipsis,"expanded");}
    Ellipsis.contract=contract;
    
    function toggle(arg){
        var evt=false;
        if (!(arg)) {
            evt=window.event||false;
            if (evt) arg=fdjtUI.T(evt);
            else return;}
        else if (typeof arg === 'string') arg=fdjtID(arg);
        else if (arg.nodeType) {}
        else {
            evt=arg;
            arg=fdjtUI.T(arg);}
        var ellipsis=getParent(arg,".ellipsis");
        if (!(ellipsis)) return;
        if (evt) fdjtUI.cancel(evt);
        if (hasClass(ellipsis,"expanded")) {
            addClass(ellipsis,"compact");
            dropClass(ellipsis,"expanded");}
        else {
            addClass(ellipsis,"expanded");
            dropClass(ellipsis,"compact");}}
    Ellipsis.toggle=toggle;
    
})();

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    function selectSubmit(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        if (target.value==="") return;
        else {
            var form=fdjtDOM.getParent(target,"FORM");
            if (form) form.submit();}}
    function setupSelectSubmit(){
        var setup=fdjtDOM.$(".fdjtselectsubmit");
        var i=0, lim=setup.length;
        while (i<lim)
            fdjtDOM.addListener(setup[i++],"change",selectSubmit);}
    fdjt.addInit(setupSelectSubmit,"selectsubmit");})();

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var getParent=fdjtDOM.getParent;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    
    function updatePasswordVisibility(evt,input,visible){
        evt=evt||window.event;
        if (typeof input === "string")
            input=document.getElementById(input);
        if (!(input)) return;
        var target=fdjtUI.T(evt);
        if (visible) {
            if (target.checked) input.type="PASSWORD";
            else input.type="TEXT";}
        else {
            if (target.checked) input.type="TEXT";
            else input.type="PASSWORD";}}

    fdjtUI.updatePasswordVisibility=updatePasswordVisibility;

    function uploadSelected(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var tbody=fdjtDOM.getParent(target,".upload");
        if (tbody) fdjtDOM.addClass(tbody,"uploading");}
    fdjtUI.uploadSelected=uploadSelected;

    function focusBox_onfocus(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var box=getParent(target,'.focusbox');
        if (box) addClass(box,"focused");}
    fdjtUI.FocusBox.focus=focusBox_onfocus;
    function focusBox_onblur(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var box=getParent(target,'.focusbox');
        if (box)
            setTimeout(function(){dropClass(box,"focused");},
                       200);}
    fdjtUI.FocusBox.blur=focusBox_onblur;

})();

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var hasClass=fdjtDOM.hasClass;
    
    function fixTimeElement(elt){
        var tstring=elt.getAttribute('datetime')||
            elt.getAttribute('data-datetime')||
            elt.getAttribute('data-time');
        var parsed=((tstring)&&(new Date(tstring)));
        var good=((parsed)&&(((parsed.getYear())||"nogood")!=="nogood"));
        if (!(tstring)) {
            tstring=elt.innerText;
            parsed=new Date(tstring);
            good=((parsed)&&(((parsed.getYear())||"nogood")!=="nogood"));
            if (good) {
                if (elt.tagName==='TIME')
                    elt.setAttribute('datetime',tstring);
                else elt.setAttribute('data-datetime',tstring);}}
        if (!(good)) return;
        if (!(elt.title)) elt.title=parsed.toGMTString();
        if (hasClass(elt,"fdjtkeeptext")) {}
        else if (hasClass(elt,"fdjtisotime")) {
            if (parsed.toISOString) elt.innerHTML=parsed.toISOString();}
        else if (hasClass(elt,"fdjtutctime")) {
            if (parsed.toUTCString) elt.innerHTML=parsed.toUTCString();}
        else if (hasClass(elt,"fdjtdate")) {
            if (parsed.toDateString) elt.innerHTML=parsed.toDateString();}
        else if (hasClass(elt,"fdjtdateortime")) {
            if ((parsed.toDateString)&&(parsed.toTimeString)) {
                if ((parsed.toDateString())===((new Date()).toDateString))
                    elt.innerHTML=parsed.toTimeString();
                else elt.innerHTML=parsed.toDateString();}}
        else if (hasClass(elt,"fdjtlocaletime")) {
            if (parsed.toLocaleString) elt.innerHTML=parsed.toLocaleString();}
        else if (hasClass(elt,"fdjtlocaledate")) {
            if (parsed.toLocaleDate) elt.innerHTML=parsed.toLocaleDate();}
        else if (hasClass(elt,"fdjtlocaledateortime")) {
            if ((parsed.toLocaleDateString)&&(parsed.toTimeString)) {
                if ((parsed.toDateString())===((new Date()).toDateString))
                    elt.innerHTML=parsed.toLocaleTimeString();
                else elt.innerHTML=parsed.toLocaleDateString();}
            if (parsed.toLocaleDate) elt.innerHTML=parsed.toLocaleDate();}
        else if (hasClass(elt,"fdjthumantime")) {
            if ((parsed.toDateString)&&(parsed.toLocaleTimeString)) 
                elt.innerHTML=parsed.toDateString()+" ("+parsed.toLocaleTimeString()+")";
            else if (parsed.toLocaleString)
                elt.innerHTML=parsed.toLocaleString();
            else elt.innerHTML=parsed.toString();}
        else {
            if ((parsed.toDateString)&&(parsed.toLocaleTimeString)) 
                elt.innerHTML=parsed.toDateString()+" ("+parsed.toLocaleTimeString()+")";
            else if (parsed.toLocaleString)
                elt.innerHTML=parsed.toLocaleString();
            else elt.innerHTML=parsed.toString();}}

    function initTimeElements(node){
        var elts=((node)?
                  ((fdjt.keeptime)?
                   (fdjtDOM.getChildren(node,".fdjtime")):
                   (fdjtDOM.getChildren(node,"time,.fdjtime"))):
                  ((fdjt.keeptime)?
                   (fdjtDOM.$(".fdjtime")):
                   (fdjtDOM.$("time,.fdjtime"))));
        var i=0, lim=elts.length;
        while (i<lim) fixTimeElement(elts[i++]);}
    fdjt.initTimeElements=initTimeElements;

    fdjt.autoInitTimeElements=function(){
        fdjtDOM.addListener(document.body,"DOMNodeInserted",
                            function(evt){
                                evt=evt||window.event;
                                initTimeElements(fdjtUI.T(evt));});};
    fdjt.addInit(initTimeElements,"TimeElements",false);})();

(function(){
    "use strict";
    var vibrate=navigator.vibrate||navigator.webkitVibrate||
        navigator.mozVibrate||navigator.msVibrate;
    fdjt.UI.vibrate=function(args){
        if (!(vibrate)) return false;
        vibrate(args);
        return true;};})();

fdjt.disenableInputs=fdjt.UI.disenableInputs=
    (function(){
        "use strict";
        var fdjtDOM=fdjt.DOM;
        var getStyle=fdjtDOM.getStyle;
        var hasClass=fdjtDOM.hasClass;
        var $=fdjtDOM.$;
        
        function disenableInputs(under){
            var inputs=$("input,select,button,textarea",under);
            var i=0, lim=inputs.length;
            while (i<lim) {
                var input=inputs[i++];
                if (hasClass(input,"fdjtignore")) continue;
                var scan=input, disable=false;
                while ((scan)&&(scan!==under)) {
                    var style=getStyle(scan);
                    if (style.display==='none') {
                        disable=true; break;}
                    scan=scan.parentNode;}
                input.disabled=disable;}}
        return disenableInputs;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ######################### fdjt/showpage.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   It provides for simple and fast paginated display

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or any
   later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

   Use and redistribution (especially embedding in other CC licensed
   content) is also permitted under the terms of the Creative Commons
   "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

fdjt.showPage=fdjt.UI.showPage=(function(){
  "use strict";
  var fdjtDOM=fdjt.DOM;
  var fdjtLog=fdjt.Log;
  var fdjtString=fdjt.String;
  var getStyle=fdjtDOM.getStyle;
  var getChild=fdjtDOM.getChild;
  var getChildren=fdjtDOM.getChildren;
  var dropClass=fdjtDOM.dropClass;
  var addClass=fdjtDOM.addClass;
  var hasClass=fdjtDOM.hasClass;
  var toArray=fdjtDOM.toArray;
  
  var adjustFonts=fdjtDOM.adjustFonts;

  function getContainer(arg){
    var container;
    if (typeof arg === "string")
      container=document.getElementById(arg);
    else if (arg.nodeType)
      container=arg;
    else container=false;
    if (!(container)) fdjtLog.warn("Bad showPage container arg %s",arg);
    return container;}
    
  function istootall(container){
    return container.scrollHeight>container.offsetHeight;}
  function isOversize(elt,w,h){
    if (typeof w === "undefined") w=true;
    if (typeof h === "undefined") h=true;
    return ((h)&&(elt.scrollHeight>elt.offsetHeight))||
      ((w)&&(elt.scrollWidth>elt.offsetWidth));}
  
  function showPage(container,start,dir){
    if (!(container=getContainer(container))) return;
    var shown=toArray(getChildren(container,".fdjtshow"));
    var curstart=getChild(container,".fdjtstartofpage");
    var curend=getChild(container,".fdjtendofpage");
    var info=getChild(container,".fdjtpageinfo");
    var children=getNodes(container), lim=children.length, startpos;
    var caboose=(dir<0)?("fdjtstartofpage"):("fdjtendofpage");
    if (children.length===0) return;
    if (typeof dir !== "number") dir=1; else if (dir<0) dir=-1; else dir=1;
    if (!(start)) {
      startpos=0; start=children[0];}
    else if ((typeof start === "number")&&(start>0)&&(start<1)) {
      startpos=Math.round(start*children.length);
      start=children[startpos];}
    else if (typeof start === "number") {
      startpos=start-1; start=children[startpos];}
    else if (start.nodeType) {
      start=getPageElt(container,start);
      startpos=children.indexOf(start);}
    if ((!(start))||(startpos<0)||(startpos>=lim)||
        ((startpos===0)&&(dir<0)))
      return;
    addClass(container,"fdjtpage"); addClass(container,"formatting");
    if (!(info)) info=getProgressIndicator(container,startpos,lim);
    // Clear old page
    if (shown.length) {
      dropClass(shown,"fdjtshow");
      dropClass(shown,"fdjtoversize");}
    if (curstart) dropClass(curstart,"fdjtstartofpage");
    if (curend) dropClass(curend,"fdjtendofpage");
    addClass(start,"fdjtshow");
    addClass(start,((dir<0)?("fdjtendofpage"):("fdjtstartofpage")));
    checkOversize(start);
    if (((dir<0)&&(hasClass(start,/fdjtpagebreak(auto)?/)))||
        (istootall(container))) {
      dropClass(container,"formatting");
      return startpos;}
    var endpos=showchildren(container,children,startpos,dir);
    var end=children[endpos];
    if ((dir>0)&&(hasClass(end,"fdjtpagehead"))) {
      while ((endpos>startpos)&&(hasClass(end,"fdjtpagehead"))) {
        dropClass(end,"fdjtshow"); dropClass(end,caboose);
        endpos--; end=children[endpos];
        addClass(end,caboose);}}
    if ((dir>0)&&(hasClass(end,"fdjtpagekeep"))) {
      while ((endpos<startpos)&&(hasClass(end,"fdjtpagekeep"))) {
        dropClass(end,"fdjtshow"); dropClass(end,caboose);
        endpos++; end=children[endpos];
        addClass(end,caboose);}}
    if (startpos===0) addClass(container,"fdjtfirstpage");
    else dropClass(container,"fdjtfirstpage");
    if (endpos>=(lim-1)) addClass(container,"fdjtlastpage");
    else dropClass(container,"fdjtlastpage");
    var minpos=((startpos<=endpos)?(startpos):(endpos));
    var maxpos=((startpos>endpos)?(startpos):(endpos));
    info.innerHTML=Math.floor((minpos/lim)*100)+"%"+
      "<span class='count'>("+lim+")</span>";
    info.title=fdjtString("Items %d through %d of %d",minpos,maxpos,lim);
    addClass(container,"newpage"); setTimeout(
      function(){dropClass(container,"newpage");},1000);
    dropClass(container,"formatting");
    return endpos;}

  function getProgressIndicator(container,startpos,lim){
    // This could include an input element for typing in a %
    var info=fdjtDOM("div.fdjtpageinfo",(startpos+1),"/",lim);
    container.appendChild(info);
    return info;}

  function getPageElt(container,node){
    var scan=node, parent=scan.parentNode;
    while ((parent)&&(parent!==container)) {
      scan=parent; parent=scan.parentNode;}
    if (parent===container) return scan;
    else return false;}

  function getNodes(container){
    var children=[], nodes=container.childNodes;
    addClass(container,"getvisible");
    var i=0, lim=nodes.length, prev=false;
    while (i<lim) {
      var node=nodes[i++];
      if (node.nodeType===1) {
        var style=getStyle(node);
        if (style.display==='none') continue;
        else if ((style.position)&&(style.position!=='static'))
          continue;
        if (style.pageBreakBefore==="force")
          addClass(node,"fdjtpagebreakauto");
        else dropClass(node,"fdjtpagebreakauto");
        // We don't currently make these stylable
        if ((prev)&&(hasClass(prev,"fdjtpagekeep"))) 
          addClass(node,"fdjtpagekeep");
        if ((prev)&&(hasClass(node,"fdjtpagekeep")))
          addClass(prev,"fdjtpagehead");
        children.push(node);}}
    dropClass(container,"getvisible");
    return children;}

  function showchildren(container,children,i,dir){
    var lim=children.length, scan=children[i+dir], last=children[i]; 
    var caboose=(dir<0)?("fdjtstartofpage"):("fdjtendofpage");
    i=i+dir; addClass(last,caboose); while ((i>=0)&&(i<lim)) {
      if ((dir>0)&&(hasClass(scan,/fdjtpagebreak(auto)?/)))
        return i-dir;
      dropClass(last,caboose);
      addClass(scan,"fdjtshow");
      addClass(scan,caboose);
      checkOversize(scan);
      if (istootall(container)) {
        addClass(last,caboose);
        dropClass(scan,"fdjtshow");
        scan.style.display='';
        dropClass(scan,caboose);
        return i-dir;}
      if ((dir<0)&&(hasClass(scan,/fdjtpagebreak(auto)?/))) return i;
      i=i+dir; last=scan; scan=children[i];}
    return i-dir;}

  function checkOversize(scan){
    var saved=scan.style.overflow||'';
    scan.style.overflow='auto';
    if (isOversize(scan)) {
      addClass(scan,"fdjtoversize");
      if (isOversize(scan)) {
        adjustFonts(scan);}}
    scan.style.overflow=saved;}
  showPage.isOversize=isOversize;

  function forwardPage(container){
    if (!(container=getContainer(container))) return;
    var foot=getChild(container,".fdjtendofpage");
    if (!(foot)) return showPage(container);
    if (hasClass(container,"fdjtlastpage")) return false;
    else if (foot.nextSibling) 
      return showPage(container,foot.nextSibling);
    else return false;}
  showPage.forward=forwardPage;

  function fastForwardPage(container){
    if (!(container=getContainer(container))) return;
    var foot=getChild(container,".fdjtendofpage");
    if (!(foot)) return showPage(container);
    if (hasClass(container,"fdjtlastpage")) return false;
    else if (foot.nextSibling) {
      var children=getNodes(container);
      var off=children.indexOf(foot), len=children.length;
      var next_off=Math.floor(off+(len-off)/2);
      return showPage(container,children[next_off],1);}
    else return false;}
  showPage.fastForward=fastForwardPage;

  function backwardPage(container){
    if (!(container=getContainer(container))) return;
    var head=getChild(container,".fdjtstartofpage");
    if (!(head)) return showPage(container);
    if (hasClass(container,"fdjtfirstpage")) return false;
    else if (head.previousSibling) {
      return showPage(container,head.previousSibling,-1);}
    else return false;}
  showPage.backward=backwardPage;

  function fastBackwardPage(container){
    if (!(container=getContainer(container))) return;
    var head=getChild(container,".fdjtstartofpage");
    if (!(head)) return showPage(container);
    if (hasClass(container,"fdjtfirstpage")) return false;
    else if (head.previousSibling) {
      var children=getNodes(container);
      var off=children.indexOf(head);
      var next_off=Math.floor(off/2);
      return showPage(container,children[next_off],-1);}
    else return false;}
  showPage.fastBackward=fastBackwardPage;

  function updatePage(container){
    if (!(container=getContainer(container))) return;
    var head=getChild(container,".fdjtstartofpage");
    if (!(head.hidden)) showPage(container,head);
    else {
      var scan=head;
      while (scan) {
        if (scan.nodeType!==1) scan=scan.nextSibling;
        else if (!(scan.hidden)) return showPage(container,scan);
        else scan=scan.nextSibling;}
      showPage(container);}}
  showPage.update=updatePage;

  function checkPage(container){
    if (!(container=getContainer(container))) return;
    if (!(hasClass(container,"fdjtpage"))) {
      if (container.offsetHeight) showPage(container);}
    else if ((container.offsetHeight)&&(!(hasClass(container,"needsresize")))) {
      dropClass(container,"needsresize");
      updatePage(container);}
    else return;}
  showPage.check=checkPage;

  function showNode(container,node){
    if (!(container=getContainer(container))) return;
    if (!(hasClass(container,"fdjtpage"))) {
      if (container.offsetHeight) showPage(container);
      else return false;}
    var parent=node.parentNode;
    while ((parent)&&(parent!==container)) {
      node=parent; parent=node.parentNode;}
    if (!(parent)) return;
    else if (hasClass(node,"fdjtshown")) return false;
    else return showPage(container,node);}
  showPage.showNode=showNode;

  return showPage;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  js-indent-level: 2 ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ################# fdjt/dialog.js ###################### */

/* Copyright (C) 2012-2015 beingmeta, inc.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

/* Non-blocking alerts and messages */

fdjt.Dialog=(function(){
    
    "use strict";
    var fdjtDOM=fdjt.DOM;
    var fdjtLog=fdjt.Log;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;
    var Template=fdjt.Template;
    var template=fdjt.Template;
    var Templates=fdjt.Templates;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var addListener=fdjtDOM.addListener;
    var removeListener=fdjtDOM.removeListener;

    var countdown_serial=1; var countdown_tickers={};

    var redx_png="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyEAYAAAE5qGRkAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAASAAAAEgARslrPgAAEXpJREFUeNrdXGl4VEW6fqv3bCT0SQjhVADpCggMuywiUTbZAoRNFlkER8SZwUdnrtuMy+idcUZFwHEYERdAkR1kcxRkXwVBWYSw5DSE5DQQyOmsnd677o9Ah5vcvt2ns3Cf+/7Jw6n63u99vzpL1anTALeh5NH2rNPGKQgBe6f0NhmW+D8HDygLxRKmG3JQUShljHPlEjWzjmszgwGt6Xi2Mfb5YLuTprM2xU2rGS20NWudNSPYIV+0sfYrtwX/XUgtLK304VCKoNhpf7ZoohIMUGgy6+QvqdlPEwy4JE5kIwwzwCHhg7VmuOCHt3IjABOcmkQlIJayQZ+uqc7wmliZodO/FMxQSpuyLg570EJb0cnaTj4bbK+k/ZjlozHVBCW0NUt33heyqhm0M5s1fR2iBbmT+s4BQZBlSSIkqKBGe8iGmqhJhJqBoQhUZ1DtIXrU1K6coxms5dq+Ecd/Tw+xdxNoqBoETzXSE4/xE1m7gpHN4YRh4uFgYDEdwB5buS9IvE7cw9bGvRwk7IHJ+LSsIBgfByCmeGmtItdSuI9qWVr2RHRCGuI2rw1ryQ0/tKUJQgv5unQxqaJmsyZUHPk1/4ov3fFJxLUvBkX++t2hmquv0s30T2ypccGdUvAfyYvkWWdisKcfgLdiU/D0aY9byJi88K5SX4f4VK+7Lspx7LGP+9QqXa3TygsvnI7rQnO5ULLFtwhnyN6eWlj6tKf5IbhhXLHkzvFaV47SXcxkC0yeiEsVAsp+ms7EL14JOrE/Rxey38VM4m9gPnZUBm9cIa/dUMQ1K2FCIZKWyiTqm0Qo4hqI+m4U8b1FraJwqCkkauuRljLsINZ1jBrfQYONQYOdRQ19HWjg5meQMC5JLXHYfn744Sv1Visppc0YHWeLtvZBnmtUYOnloYUpbUW3ZWPMu7UeuaU0kbH14R9M9QTlFn2Z2ROSaumwiXb2q+WtavYnxUnp/dhU4/aAlefhmGtopIlIKlqhybonzT75sPTzpGV1FW5/QpTZo3F/5gtIH1ypeDPiQC8CSF72QHBo7DqabKkcfoQXwkQ6f/ugaiU6JCF9tSwkymelvY+nhxX+Cn3QsjbuU/4iCsirFU+pzueFBw57QGgu35SuC9qQ55id0Cw2O+sEL8Jp7P2mh+pEJ1CB/JVDhKFyieSZtlOZKPZik2Pfw2JyDSccL6rm8yMOvOSk0Ey+KFmbdq/ZHPnz+JxYxjQj3WhOOqDNNoNqIWqhgw6a0m5CopwnXUo6Fa57xEZqGZMos+RnT0JTuMjAzWui5QlCCx08ZR8ISXKelJ/4e7XhGrUBwQr8k8fh4R11ntIFkQc3+Mb2UeuJtKN9NBUsM01JfBliyCFncRS53Lf/GiMSxtAB2s+mmIvl76WLs8OOeOhH6As03rLKmIY/Iom84bqmWrYHDjgrDglpcrFkS8hUXDSWJTxWCQfMSF0Xo5aOiEhD/CfHzC75uHRqTp9a7UHhs8T5ll+M/fE+WUjGuvaqFk7ghc+RKZjlQikv/lC47koubcs0kz+DGZVos/rXqtM1hxEtF6ebvbJV2vNbmSgBmsj0oy6iGAlotbVtxEw+EAQqVwupcoF0Oe5x1cZrGjsmVlicU4aDkftJp1XfRhzohgvashu1Ti27nvZjxrFX+Q3kIf3rlnc1VYBXrhcEuUSyxk2sq/Cwxs6JlZaC6WY0J23JgC+VYIMWfpCyDUKSfF3KTXwsPNFZamDp32YrT9IKy1/19Xd3UmuomGayfvu2FS1JT2Vm7dnIA/OpkTXZtq/mZM3+gVjIsoz3N5oBP23DHtxTPWksoiJjvMw+TJzHSnQna/avfnlxlqaz9ltLEIcUNBv5SM2OfDrpgYuuc8okOs1y1nClwQyU0p5M3J2KEnhwa0D1bZ6AAEjgq8g/0NPbXHlafN+yQHfXKwU97cS6bJ3Fb6AYjlFLI8wXINuQiymGs+aZcoz0F2+XOhsopqlswC6GAPQoGJQbNoAAILjFd6EQTt1TGp6HEngHd1aZV8NHIQOrPZ2VvmI3yzDd36I2cI22Yxm7ScQG7oAD4EjRrATh53vs1AiiXCDlxP4eWujgrjyjWsk2cotYvS/a19KW7Gl9XqRh9kTagXXe2QxGOMAHBlTnLebf8w/7fG7eInusCT86g9eIkCTnSQVxXWBADAKVR1WRcuj4YHDs9TS3d6GnLJ8b0kKOgI1msAe2/5tfRhkqBxeq1U/m4iHM6btMYLYO1hHHguuY0FOUCtqSdXBmwY0APKZvVJji4KjkbszjX+r1yaL8uPUhn0G5KLrZwO1bkUwsyB86SrWBf0CD9L7Pmv9Tzpf2/rCoVns4AqWStmAZrmw4oQE3blaZ3wcXbuLajn/BhGZoMfQ51QY6Ygw/+WCh+Ya8yJpwtHnIfpESKvk0hbV0jkccjDCYNqgVpBpOCLje7zWByqclx+G3wxpWy69cpxaW7uwEA9wwmtTfHMIJSuX56Jc53+yzaaTlh16IOC7ahEohbc/SXDHQoRxxxso6O4jDRBQ+vEowyQuk8oNTVRegrvmVIprOMnglCDg41K8z2oFC0/8Jc5F8VLq0/8todUS91FUCopdptr4RrYE74BchI7DvoyIvPWiZpmJSWLMgqg2U0kQmbvbBhwTEZGujTVzbEQiAHNIaE3gr/QxzhbzQutv3U70bURTahrHNBIAHyFb/JI5cEQFwiozFy6jQlZv3y3OlG/6Hw4eFM1BERZaxSQYBAR8jqhamBaD1OuEH4NerOQU5gIKAggS+Vdsvpa18wdohkB+qc8hrRLlCzUzY9ETUBq7xDXzXoHZCkixLFw2x0MAPv6dIBQMBkK4RUEFG+88Xj0nvn0E0IU+1WkaUG5SxzhtGogli0XTMctUGfuGn+f5HM4VOtj7W1nsu3TksNJWvS1eMKVVvED3DVLLGBj7nVm7xe+zvpP+c8bP2vf/JdZWBC5Qx8/plSIEL5gkzVRvI5+f5yiGPCt1sCdbeO3eF664U03TW2pOKADh0+hsR56lSvAk+tMcx3fNCM3mnJPjzieKnqazH+hMogR6lE9S/rNbwFWj56LtCU9sAac+uVyINu73ppLGX0RYsw7sVPmjAdVmqchP8wPPJ25q+GosGpdDBNWqPagMBaKAb2k2tgaCGqsoGzE3ka1KufhT80MHvtasi4XhQ0y3QM3DroV537wKKjDlzARDAxEIKuI8fR96wcnOZLU3y7WiiugChNFWNkN5eRluyDM9M+BAA14f+suIAjDznkSbCWNlqNRwor15YCbJNkmIyoIUGenft23I+v4KYEdn1bSBYoKqMXnMTOV/KNayAHxx+b611ELkfduj6f3fHQFhixU5bsDbuJfZYGmspHN67voWHw+0RMiiltAVr55ulHBZzLe5H/qPOxEqWuM2SHdNDuUqTWNI3e2ttUp6nSSxlw0dKX3ED0xm2Nrbxxoa9Ge3FlsavV/xUZJ32dr/r/RtljDsVq1jKWi3Pt38tGtjjulcj5Q05Qyly0YEsNmYRuYpfkLJuPpJhhH7k5YgVO8DRct1xbIAdy6b3FP4gO6VWnjqvGu4VFCudxwYmDEQLfIHA5g6oRAnkgf8MG8jBAdih5QVgy+JwCB3Jiae/EUbZzucW+SbU7F69OX2A7mErTJd5L8zF4nUmOFCGm6PSwiaMDAFcRTKwrgOZgz8iZvp483F5kvSLJ+rXeg0NZR59yzIufi1mYjfZu2UWNLgMYaCjzsRV70evIwAnYpaW4gG+ma+Y01nIs2Vau/i8RHHRrsy8djUcKIJ54uRG8svRBCa0WjeevM1nkwtT3zC/aXs51+br1kj5a0Fx089Yq9jRcOFN+Lbq4AMQM2hjoyQnKEM5NCj/sEv19KRYPMpaDfsRnIyA9utnwBELTUzEy8w6guMS9Ehccw2P8I04M+M5wWPrLnm9DVYQew79OEMb14vH4RPedcsVxOMmSgfdbCS/VV/Eeoqfwg3+C982bLbQ3ZZs7fJjn9CfoTShyZb8EWO4DIH0WT8NXjgQGzu+EaQSEHgQgzS0X92bvISH8NbMMvMieaHUzRP5M6wGlNz0zmxI3HtoyhOR9/UKEFxBYEi9v1sMCSMI4ounws838/dGXBUSbT2sQ44erm0+Qtg70ydY5xG7+CHshmPDFngBkJgPG8EKAYEbF3CTn1k5E1MwDG/N6irky1us73hDroCUt0UTK49ri6kkBVkbX0ACOK4Nnd0IequQAB90JSnkBbREnxHLzB/KP0rLfwi7/xD1rMeeQnuzzKyZ/CpsKNx4DU4AAeOOBjdaNWtx4iA0KF+5lN8ibnhn/otYeQ9+Td8V07GdtNv8M9IgQj/kQoPruQM/YuErPUpa4LfQDEs1++TnpctH26ilqbdpqFJITYxkWeFDIlpt2AAT9NCZXmq0gjQ2tDBAX/odLuBB/smIdUIfeaU188jyutI22LpA+VosYv1GX0Rv0ha2tYNgQiy0poK6M98jGEDAS0rhB/ipUR2EJLnAmnBI/VdfYdBoCzXlNBUtzux3kAo9saypgB4+xJr+0lj5VYPDiECpFev5OXQceVX4jc0kbTs0qKHT3rOVs3KFTrV4sx9BDI6R7uuSoIcLTsPme6UHOmjgLH+eNMdD/HTWEbNTXm1NPni8sWVEvW9YV5Cdgfn85PZxiIcV5p2NN/sJBRuKkbJxBucYzHceabz1SM26NFYi+0DxRcsrpoP8W/IBWbw2Bw6kImX00/fKeBjcwAU0hWbpFvIGfIHtc54z75bPX27jc9ed+n9Hwz3UC2gM6206BAMEONachA6AK3tuQxuqd1RtlJ+GCW1Q+tkm8lfM40t+87n5HbmXdZxPru909Tft9dBVLMY4Gm78DYlrUuFBCeLHRP6b1/rDndtNswZhJ+AAzpEWcCD1s0Vwk3gMfuaAmRfI0lv+nLrTRwllmbiJ7TMMxxAyBS+sc8OEZJRk746WTzXccMHjeB05PAf2UT+RoaQb7hd685sAilcxAAREr/qroihRiTIkwPvpV9oZOI7Jz7yUdFCOl94NlKolivzTkzzahWUas6HHTUirJsAELeLGTWskw4AfZSivmA4X/4pvGLNWaGkbbc3c7Q3V3W4Uyy0lE228kGSQ7isWwA8dNIb3G0ntJSShIyxL3OQK6U6Sf/eqmRX8PXelf1u4wNDflL5H/826GOdhIl5F4leDkYAiXJvQtZEMAQEE4K44jjOo4CfHPS0MksusyTtPRUtnN9OHWedJhTwHeXB8+Tr0CIAYlkTLpwIEBLuQgPvAPj5GWuEosuaeM1+XPdJc/+rane8IXiXmsIcMa3gv0gu2lQKaIgm6CYMbQXAVNHDB6yhGCT+M1mPThfts7aT9O+u+IVQDd74TKU6lTZlhSn9+CXFo88Vr8APw6Qc0uM+qin+LJkhB18Wz8Hd8QqbMfV94Xe6ZOz4wgyiXaDv2q5VzIMAB1+OL/1tYQ8IFDfzOM0jhhxGbPVAw2NKlczuVuhOrw+0BIvYfRCvTTy5DRzIArb/qX/W5iPZEI8mwIYAHoFswuHqDKoca2JgxfdEMAnLWcBBoETAeqbeUfnD4KkXSjBeAjGtnhk0jXdmh/od0DYzgFURodxY/tTkvgR3isoXwwwe/vv5+RuZBJVA2DN/wlfCNrBRm24ZLeQcPhn6GVNLxzDx2KVz4CUmrOoDDB40p8s9onAhA63BgNd/OD0yYLbxo62xN3b464vj/I7g9QCa7m2otFdNdKEUa6fL5M9ABIPrFkRPBDWepA6eQyn8YPV8YLJ+1tjzw55rdIt+gEmhbNmHsJZ4LJ06vvlL1gxDjkGAHLfTwOkcilm/FzfHjBYOtk+T87sl7XdD6xu0BMtpt4hXLkWlOGElfMmXZYGighV5XPe2vhBeB8q44z3NgH7VBGGITpJL9GQ0mTLlFm7DYcX+yC/QPlpzhYf8LhP+v4IEe3Xt0h95uoZls2rRnlSPiQcupR6Iu/H8B7AjpZA9bJIMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMTItMzFUMTI6NDQ6NTYtMDU6MDBEL5TZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTEyLTMxVDEyOjQ0OjU2LTA1OjAwNXIsZQAAADh0RVh0c3ZnOmJhc2UtdXJpAGZpbGU6Ly8vc3JjL2dyYXBoaWNzL3RhcmdldHMvZmRqdC9yZWR4LnN2Z3qXB16JAAAAAElFTkSuQmCC";

    function Dialog(spec){
        if (!(spec)) spec={};
        else if (typeof spec === "string") spec={spec: spec};
        var box=fdjtDOM((spec.spec)||("div.fdjtdialog"));
        if (spec.classes) {
            box.className=(box.className||"")+
                ((box.className)?(" "):(""))+
                spec.classes;}
        if (spec.style) box.setAttribute("style",spec.style);
        if (!((spec.modal)||(spec.keep)||
              (hasClass(box,"fdjtmodal"))||
              (hasClass(box,"fdjtkeep")))) {
            var countdown=fdjtDOM("div.countdown","Closing…");
            countdown.id="FDJTCOUNTDOWN"+(countdown_serial++);
            box.appendChild(countdown);}
        if (!((spec.modal)||(spec.noclose)||(hasClass(box,"fdjtmodal")))) {
            var close_button=fdjtDOM.Image(redx_png,"closebutton","Close");
            addListener(close_button,"click",close_dialog_handler);
            addListener(close_button,"touchend",close_dialog_handler);
            addListener(close_button,"touchstart",fdjtUI.cancel);
            close_button.title="click to close";
            box.appendChild(close_button);}
        if (spec.title) {
            if (spec.title.nodeType) elts.push(spec.title);
            else {
                var title_text=template(spec.title,spec,spec.data);
                box.title=title_text;
                box.appendChild(fdjtDOM("div.title",title_text));}}
        var elts=[]; var i=1, lim=arguments.length, wrap=true, content;
        while (i<lim) {
            var e=arguments[i++];
            if (e.nodeType) {wrap=false; break;}
            else if ((typeof e === "string")&&(e.indexOf('<')>=0)) {
                wrap=false; break;}}
        if (wrap) {
            content=fdjtDOM("P");
            box.appendChild(content);}
        else content=box;
        i=1; while (i<lim) {
            var arg=arguments[i++];
            if (!(arg)) {}
            else if (arg.nodeType) content.appendChild(arg);
            else if (typeof arg === "string") {
                arg=Templates[arg]||arg;
                var ishtml=(arg.indexOf('<')>=0);
                var istemplate=(arg.search("{{")>=0);
                if ((ishtml)&&(istemplate))
                    content.appendChild(Template.toDOM(arg,spec));
                else if (ishtml)
                    fdjtDOM.append(content,arg);
                else if (istemplate)
                    content.appendChild(document.createTextNode(template(arg,spec)));
                else content.appendChild(document.createTextNode(arg));}
            else content.appendChild(document.createTextNode(arg.toString));}
        if ((spec.id)&&(!(box.id))) box.id=spec.id;
        fdjtDOM.addListeners(box,spec);
        return box;}
    var makeDialog=Dialog;

    function remove_dialog(evt){
        evt=evt||window.event;
        var target=((evt)?((evt.nodeType)?(evt):(fdjtUI.T(evt))):
                    ((fdjtID("FDJTALERT"))||(fdjtID("FDJTDIALOG"))));
        var box=fdjtDOM.getParent(target,".fdjtdialog");
        if (box) {
            var countdown=fdjtDOM.getChild(box,".countdown");
            if ((countdown)&&(countdown.id)) {
                var ticker=countdown_tickers[countdown.id];
                if (ticker) clearInterval(ticker);
                delete countdown_tickers[countdown.id];}
            clear_countdown(box);
            fdjtDOM.remove(box);}}
    
    function close_dialog(evt,fast){
        evt=evt||window.event;
        var target=((evt)?((evt.nodeType)?(evt):(fdjtUI.T(evt))):
                    ((fdjtID("FDJTALERT"))||(fdjtID("FDJTDIALOG"))));
        if ((evt)&&(!(evt.nodeType))) fdjtUI.cancel(evt);
        var box=fdjtDOM.getParent(target,".fdjtdialog");
        if (box) {
            clear_countdown(box);
            if (fast) fdjtDOM.remove(box);
            else {
                if ((fdjtDOM.transitionEnd)&&
                    (!(fdjtDOM.hasClass(box,"closing")))) {
                    fdjtDOM.addListener(box,fdjtDOM.transitionEnd,function(){
                        fdjtDOM.remove(box);});
                    fdjtDOM.addClass(box,"closing");}
                else fdjtDOM.remove(box);}}}
    Dialog.close=close_dialog;
    
    function clear_countdown(box){
        var countdown=fdjtDOM.getChild(box,".countdown");
        if (countdown) {
            var ticker=countdown_tickers[countdown.id];
            delete countdown_tickers[countdown.id];
            if (ticker) clearInterval(ticker);
            fdjtDOM.remove(countdown);}}

    function close_dialog_handler(evt){
        evt=evt||window.event;
        fdjtUI.cancel(evt);
        close_dialog(evt);}

    function stop_countdown_onclick(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var box=fdjtDOM.getParent(target,".fdjtdialog");
        clear_countdown(box);
        box.style[fdjtDOM.transitionDelay]="";
        box.style[fdjtDOM.transitionDuration]="";
        fdjtDOM.dropClass(box,"countdown");
        fdjtDOM.dropClass(box,"closing");
        fdjtUI.cancel(evt);}

    function alertBox(){
        var args=fdjtDOM.toArray(arguments);
        var box=Dialog.apply(null,[{}].concat(args));
        addClass(box,"fdjtalert");}
    Dialog.alertBox=alertBox;
    fdjtUI.alertBox=alertBox;

    function alertfn(){
        var curbox=fdjtID("FDJTALERT");
        if (curbox) {
            curbox.id="";
            fdjtDOM.dropClass(curbox,"closing");
            remove_dialog(curbox);}
        var args=fdjtDOM.toArray(arguments);
        var box=Dialog.apply(null,[{}].concat(args));
        box.id="FDJTALERT"; fdjtDOM.prepend(document.body,box);
        return box;}
    Dialog.alert=alertfn;
    fdjtUI.alert=alertfn;
    fdjt.alert=alertfn;

    function setCountdown(box,timeout,whendone){
        var countdown=fdjtDOM.getChild(box,".countdown");
        countdown.innerHTML="…"+timeout+"…";
        var n=timeout;
        box.style[fdjtDOM.transitionDelay]=(n/2)+"s";
        box.style[fdjtDOM.transitionDuration]=(n/2)+"s";
        var ticker=setInterval(function(){
            if (n<=0) {
                clearInterval(ticker); ticker=false;
                delete countdown_tickers[countdown.id];
                if (whendone) whendone();
                fdjtDOM.remove(box);}
            else countdown.innerHTML="…"+(n--)+"…";},
                               1000);
        countdown_tickers[countdown.id]=ticker;
        countdown.onclick=stop_countdown_onclick;
        addListener(countdown,"touchend",stop_countdown_onclick);
        addListener(countdown,"touchstart",fdjtUI.cancel);
        setTimeout(function(){fdjtDOM.addClass(box,"closing");},10);
        return box;}
    Dialog.setCountdown=setCountdown;
    fdjtUI.setCountdown=setCountdown;

    function alertFor(timeout){
        var curbox=fdjtID("FDJTALERT");
        if (curbox) {
            curbox.id="";
            fdjtDOM.dropClass(curbox,"closing");
            remove_dialog(curbox);}
        var args=[{timeout: timeout}].concat(fdjtDOM.slice(arguments,1));
        var box=Dialog.apply(null,args);
        box.id="FDJTALERT"; fdjtDOM.prepend(document.body,box);
        setCountdown(box,timeout);
        return box;}
    Dialog.alertFor=alertFor;
    fdjtUI.alertFor=alertFor;

    function message(spec){
        var curbox=fdjtID("FDJTMESSAGE");
        if (curbox) {
            curbox.id="";
            fdjtDOM.dropClass(curbox,"closing");
            remove_dialog(curbox);}
        var args=fdjtDOM.toArray(arguments);
        var box=Dialog.apply(null,args);
        if (spec.timeout) setCountdown(box,spec.timeout);
        box.id="FDJTMESSAGE"; fdjtDOM.prepend(document.body,box);
        return box;}
    Dialog.message=message;
    fdjt.message=message;

    function makeChoice(spec,close_choice,i){
        var dom=spec.dom||
            ((spec.label)&&(fdjtDOM("button",spec.label)))||
            fdjtDOM("button","Choice "+i);
        dom.onmousedown=fdjtUI.cancel;
        dom.onmouseup=fdjtUI.cancel;
        dom.tabIndex=i;
        if (spec.title) dom.title=spec.title;
        if (spec.classname) addClass(dom,spec.classname);
        dom.onclick=function(evt){
            evt=evt||window.event;
            var target=fdjtUI.T(evt);
            var choices=fdjtDOM.getParent(target,".choices");
            var cursel=fdjtDOM.getChild(choices,".selected");
            if (cursel===dom) {}
            else {
                if (cursel) {
                    fdjtDOM.dropClass(cursel,"selected");
                    cursel.blur();}
                fdjtDOM.addClass(dom,"selected");
                dom.focus();}
            if (spec.handler) spec.handler();
            fdjtUI.cancel(evt);
            close_choice();};
        addListener(dom,"touchstart",fdjtUI.cancel);
        addListener(dom,"touchend",dom.onclick);
        return dom;}

    function choose(spec){
        var box=false; var selection=-1, buttons=[], choices;
        var close_button=false, onchoose=false;
        function close_choice(){
            var i=0, lim=buttons.length;
            while (i<lim) {
                var button=buttons[i++];
                if (button.onclick)
                    removeListener(button,"touchend",button.onclick);
                removeListener(button,"touchstart",fdjtUI.cancel);
                button.onclick=null;
                button.onmousedown=null;
                button.onmouseup=null;}
            if (close_button) {
                removeListener(close_button,"touchend",close_button.onclick);
                removeListener(close_button,"touchstart",fdjtUI.cancel);
                close_button.onclick=null;}
            if (box) box.onclick=null;
            if (box) box.onkeydown=null;
            if (box) {
                var timeout=setTimeout(function(){
                    if (spec.onclose) spec.onclose(box);
                    remove_dialog(box);
                    clearTimeout(timeout);
                    timeout=false;},
                                       500);}}
        if (typeof spec === "function") 
            choices=[{label: "Cancel"},
                     {label: "OK",handler: spec,isdefault: true}];
        else if (spec.constructor === Array) choices=spec;
        else if (spec.choices) choices=spec.choices;
        else if ((spec.label)&&(spec.handler)) 
            choices=[{label: "Cancel"},spec];
        else if (spec.handler) 
            choices=[{label: "Cancel"},
                     {label: "OK",
                      handler: spec.handler,
                      isdefault: spec.isdefault}];
        else if (choices.length) choices=spec;
        else {
            fdjtLog.warn("Bad spec %o to fdjtUI.choose");
            return;}
        if (spec.onchoose) onchoose=spec.onchoose;
        var i=0, lim=choices.length;
        while (i<lim) {
            var choice=choices[i];
            var button=makeChoice(choice,close_choice,i);
            buttons.push(button);
            if ((selection<0)&&(choice.isdefault)) {
                button.setAttribute("autofocus","autofocus");
                fdjtDOM.addClass(button,"selected");
                selection=i;}
            i++;}
        if ((selection<0)&&(!(spec.nodefault))) {
            fdjtDOM.addClass(buttons[i],"selected");
            selection=0;}
        box=makeDialog(
            spec,fdjtDOM("div.message",fdjtDOM.slice(arguments,1)),
            fdjtDOM("div.choices",buttons));
        close_button=fdjtDOM.getChild(box,".closebutton");
        if (spec.cancel) {
            removeListener(close_button,"touchend",close_button.onclick);
            close_button.onclick=close_choice;
            addListener(close_button,"touchend",close_button.onclick);}
        else fdjtDOM.remove(close_button);
        
        var cancel=(spec.cancel)||false;
        
        // For accessibility, handle tab/enter
        box.onkeydown=function(evt){
            evt=evt||window.event;
            var kc=evt.keyCode;
            if (kc===9) {
                if (evt.shiftKey) selection--; else selection++;
                if (selection<0) selection=buttons.length-1;
                else if (selection>=buttons.length) selection=0;
                if (selection>=0) buttons[selection].focus();
                fdjtUI.cancel(evt);}
            else if (kc===13) {
                if ((selection>=0)&&(choices[selection])&&
                    (choices[selection].handler)) {
                    (choices[selection].handler)();}
                if ((onchoose)&&(selection>=0)&&(choices[selection]))
                    onchoose(choices[selection],box);
                close_choice();
                fdjtUI.cancel(evt);}
            else if ((cancel)&&(kc===27)) {
                close_choice();
                fdjtUI.cancel(evt);}};
        fdjtDOM.addClass(box,"fdjtconfirm"); box.id="FDJTDIALOG";
        fdjtDOM.prepend(document.body,box);
        if (spec.timeout)
            setCountdown(box,spec.timeout,function(){
                if (spec.noauto) {
                    close_choice();
                    return;}
                if ((selection>=0)&&(choices[selection])&&
                    (choices[selection].handler)) {
                    (choices[selection].handler)();}
                if ((onchoose)&&(selection>=0)&&(choices[selection]))
                    onchoose(choices[selection],box);});
        if (selection>=0) buttons[selection].focus();
        return box;}
    Dialog.Choice=choose;
    Dialog.choose=choose;
    fdjtUI.choose=choose;
    fdjt.Choice=choose;

    fdjt.UI.Dialog=Dialog;
    return Dialog;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/

/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/completions.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));
if (!(fdjt.UI)) fdjt.UI={};

(function(){
    "use strict";
    var fdjtString=fdjt.String;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var RefDB=fdjt.RefDB, fdjtID=fdjt.ID;

    var rAF=fdjtDOM.requestAnimationFrame;
    var async=fdjt.async;

    var serial=0;

    /* Constants */
    // Always set to distinguish no options from false
    var FDJT_COMPLETE_OPTIONS=1;
    // Whether the completion element is a cloud (made of spans)
    var FDJT_COMPLETE_CLOUD=2;
    // Whether to require that completion match an initial segment
    var FDJT_COMPLETE_ANYWORD=4;
    // Whether to match case in keys to completions
    var FDJT_COMPLETE_MATCHCASE=8;
    // Whether to an enter character always picks a completion
    var FDJT_COMPLETE_EAGER=16;
    // Default options
    var default_options=
        ((FDJT_COMPLETE_OPTIONS)|
         (FDJT_COMPLETE_CLOUD)|
         (FDJT_COMPLETE_ANYWORD));
    // Milliseconds to wait for auto complete
    var complete_delay=100;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var getChildren=fdjtDOM.getChildren;
    var getParent=fdjtDOM.getParent;
    var getStyle=fdjtDOM.getStyle;
    var position=RefDB.position;

    var isEmpty=fdjtString.isEmpty;
    var hasPrefix=fdjtString.hasPrefix;
    var prefixAdd=fdjtString.prefixAdd;
    var prefixFind=fdjtString.prefixFind;
    var commonPrefix=fdjtString.commonPrefix;

    fdjtUI.FDJT_COMPLETE_OPTIONS=FDJT_COMPLETE_OPTIONS;
    fdjtUI.FDJT_COMPLETE_CLOUD=FDJT_COMPLETE_CLOUD;
    fdjtUI.FDJT_COMPLETE_ANYWORD=FDJT_COMPLETE_ANYWORD;
    fdjtUI.FDJT_COMPLETE_MATCHCASE=FDJT_COMPLETE_MATCHCASE;
    fdjtUI.FDJT_COMPLETE_EAGER=FDJT_COMPLETE_EAGER;

    var ValueMap=fdjt.Map||RefDB.Map;

    function Completions(dom,input,options) {
        this.dom=dom||false; this.input=input||false;
        this.options=options||default_options;
        this.nodes=[]; this.values=[]; this.serial=++serial;
        this.cues=[]; this.displayed=[]; this.known={};
        this.prefixtree={strings: []}; this.bykey={};
        this.byvalue=new ValueMap();
        this.selected=false; this.selclass=false;
        if (!((options)&(FDJT_COMPLETE_MATCHCASE))) this.stringmap={};
        this.initialized=false;
        return this;}

    // A completion is a DOM node with a 'key' string for matching
    //  and a 'value' for using.  A completion can include *variations*
    //  (with CSS class variation) which have different key values.
    
    // The key is either stored as a DOM property, attribute, 
    function getKey(node){
        return node.key||(node.getAttribute("data-key"))||(node.getAttribute("key"))||
            ((hasClass(node,"variation"))&&(fdjtDOM.textify(node)))||
            ((hasClass(node,"completion"))&&(completionText(node,"")));}
    Completions.getKey=getKey;
    // This gets the text of a completion node, excluding variations
    // and any fdjtdecoration(s).
    function completionText(node,sofar){
        if (node.nodeType===3) return sofar+node.nodeValue;
        else if (hasClass(node,"variation")) return sofar;
        else if (hasClass(node,"fdjtskiptext")) return sofar;
        else if ((node.nodeType===1)&&(node.childNodes)) {
            var children=node.childNodes;
            var i=0; var lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (child.nodeType===3) sofar=sofar+child.nodeValue;
                else if (child.nodeType===1)
                    sofar=completionText(child,sofar);
                else {}}
            return sofar;}
        else return sofar;}

    /* You can add a node to a completions lookup table.  We update
     * bykey and the prefix table. */
    function addNodeKey(node,keystring,ptree,bykey,anywhere){
        var keys=((anywhere)?(keystring.split(/\W/g)):[]).concat(keystring);
        var i=0; var lim=keys.length;
        while (i<lim) {
            var key=keys[i++];
            prefixAdd(ptree,key,0);
            if ((bykey[key])&&(bykey.hasOwnProperty(key)))
                bykey[key].push(node);
            else bykey[key]=new Array(node);
            bykey._count++;}}

    /* Get nodes for a completion */
    function getNodes(string,ptree,bykey,matchcase){
        var result=[]; var direct=[]; var variations=[];
        var keystring=stdspace(string);
        if (isEmpty(keystring)) return [];
        if (!(matchcase)) keystring=string.toLowerCase();
        var strings=prefixFind(ptree,keystring,0);
        var prefix=false;
        var exact=[]; var exactheads=[]; var keys=[];
        var i=0; var lim=strings.length;
        while (i<lim) {
            var s=strings[i++];
            var isexact=(s===keystring);
            if (prefix) prefix=commonPrefix(prefix,s,false,(!(matchcase)));
            else prefix=s;
            var completions=bykey[s];
            if (completions) {
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,"hidden")) {}
                    // Skip redundant completions
                    else if (result.indexOf(c)>=0) {}
                    else if (hasClass(c,"completion")) {
                        if (isexact) {exactheads.push(c); exact.push(c);}
                        result.push(c); keys.push(s); direct.push(c);}
                    else {
                        var head=getParent(c,".completion");
                        if ((head)&&(hasClass(head,"hidden"))) {}
                        else if (head) {
                            if (isexact) exact.push(head);
                            result.push(head); keys.push(s);
                            variations.push(c);}}}}}
        if (exact.length) result.exact=exact;
        if (exactheads.length) result.exactheads=exactheads;
        result.prefix=prefix;
        result.strings=strings;
        result.matches=direct.concat(variations);
        return result;}

    function addCompletion(c,completion,key,value) {
        if (typeof key === "undefined")
            key=completion.key||getKey(completion);
        if (!(value))
            value=(completion.value)||(completion.getAttribute('value'))||key;
        if (!(completion._seen)) {
            c.nodes.push(completion);
            completion._seen=true;
            if (value) {
                c.values.push(value);
                c.byvalue.add(value,completion);}}
        else return;
        c.curstring=c.maxstring=false;
        if (key) addCompletionKeys(c,completion,key);}

    function addCompletionKeys(c,completion,key) {
        if (!(key)) key=completion.key||getKey(completion);
        var opts=c.options;
        var container=c.dom;
        var ptree=c.prefixtree;
        var bykey=c.bykey;
        var smap=c.stringmap;
        var stdkey=stdspace(key), lower;
        var matchcase=((opts)&(FDJT_COMPLETE_MATCHCASE));
        var anyword=((opts)&(FDJT_COMPLETE_ANYWORD));
        if (!(matchcase)) {
            lower=stdkey.toLowerCase();
            smap[lower]=stdkey;
            stdkey=lower;}
        if (!(getParent(completion,container)))
            fdjtDOM.append(container,completion," ");
        addNodeKey(completion,stdkey,ptree,bykey,anyword);
        if (hasClass(completion,"cue")) c.cues.push(completion);
        var variations=getChildren(completion,".variation");
        var i=0; var lim=variations.length;
        while (i<lim) {
            var variation=variations[i++];
            var vkey=stdspace(variation.key||getKey(variation));
            if (!(matchcase)) {
                lower=vkey.toLowerCase();
                smap[lower]=vkey;
                vkey=lower;}
            addNodeKey(variation,vkey,ptree,bykey,anyword);}}

    function initCompletions(c){
        var completions=getChildren(c.dom,".completion");
        var i=0; var lim=completions.length;
        while (i<lim) addCompletion(c,completions[i++]);
        c.initialized=true;}

    Completions.prototype.addCompletion=function(completion,key,value) {
        if (!(this.initialized)) initCompletions(this);
        addCompletion(this,completion,key,value);
        if (this.visible) this.visible=false;};
    Completions.prototype.addKeys=function(completion,key) {
        if (!(this.initialized)) {
            initCompletions(this);
            addCompletion(this,completion,key);}
        else addCompletionKeys(this,completion,key);
        if (this.visible) this.visible=false;};

    function updateDisplay(c,todisplay){
        var displayed=c.displayed;
        var i, lim;
        if (displayed) {
            i=0; lim=displayed.length;
            while (i<lim) dropClass(displayed[i++],"displayed");
            c.displayed=displayed=[];}
        else c.displayed=displayed=[];
        if (todisplay) {
            i=0; lim=todisplay.length;
            while (i<lim) {
                var node=todisplay[i++];
                if (hasClass(node,"completion")) {
                    addClass(node,"displayed");
                    displayed.push(node);}
                else {
                    var head=getParent(node,".completion");
                    if ((head)&&(!(hasClass(head,"displayed")))) {
                        displayed.push(node); displayed.push(head);
                        addClass(head,"displayed");
                        addClass(node,"displayed");}}}}
        // Clear the visible ordered elements cache
        c.visible=false;
        // Move the selection if neccessary
        if ((c.selection)&&(!(hasClass(c.selection,"displayed"))))
            if (!(c.selectNext()))
                if (!(c.selectPrevious()))
                    c.clearSelection();
        if (c.updated) c.updated.call(c);}
    
    Completions.prototype.getCompletions=function(string) {
        if ((string===this.curstring)||(string===this.maxstring)||
            ((this.curstring)&&(this.maxstring)&&
             (hasPrefix(string,this.curstring))&&
             (hasPrefix(this.maxstring,string))))
            return this.result;
        else {
            var result, that=this;
            if (!(this.initialized)) initCompletions(this);
            if (isEmpty(string)) {
                result=[]; result.prefix=""; result.matches=[];
                if (this.dom) addClass(this.dom,"noinput");}
            else {
                result=getNodes(string,this.prefixtree,this.bykey,
                                ((this.options)&(FDJT_COMPLETE_MATCHCASE)));
                if (this.dom) dropClass(this.dom,"noinput");
                rAF(function(){updateDisplay(that,result.matches);});}
            if ((this.stringmap)&&(this.strings)) {
                var stringmap=this.stringmap;
                var strings=this.strings;
                var i=0; var lim=strings.length;
                while (i<lim) {
                    var s=strings[i]; var m=stringmap[s];
                    if (m) strings[i++]=m;
                    else i++;}}
            this.curstring=string;
            this.maxstring=result.prefix||string;
            this.result=result;
            return result;}};

    Completions.prototype.getValue=function(completion) {
        if (completion.value) return completion.value;
        else if (completion.getAttribute("data-value"))
            return completion.getAttribute("data-value");
        else if (completion.getAttribute("value"))
            return completion.getAttribute("value");
        var pos=position(this.nodes,completion);
        if (pos<0) return false;
        else return this.values[pos];};
    Completions.prototype.getKey=function(completion) {
        if (completion.key) return completion.key;
        else if (completion.getAttribute("data-key"))
            return completion.getAttribute("data-key");
        else if (completion.getAttribute("key"))
            return completion.getAttribute("key");
        else return getKey(completion);};

    Completions.prototype.complete=function(string,callback){
        var that=this;
        if (!(this.initialized)) initCompletions(this);
        // fdjtLog("Completing on %o",string);
        if ((!(string))&&(string!==""))
            string=((this.getText)?(this.getText(this.input)):
                    (hasClass(this.input,"isempty"))?(""):
                    (this.input.value));
        if (isEmpty(string)) {
            rAF(function(){
                if (that.displayed) updateDisplay(that,false);
                addClass(that.dom,"noinput");
                dropClass(that.dom,"nomatches");
                if (callback) async(function(){callback([]);});});
            return [];}
        var result=this.getCompletions(string);
        if ((!(result))||(result.length===0)) {
            rAF(function(){
                updateDisplay(that,false);
                dropClass(that.dom,"noinput");
                addClass(that.dom,"nomatches");
                if (callback) async(function(){callback(result);});});
            return [];}
        else {
            rAF(function(){
                updateDisplay(that,result.matches);
                dropClass(that.dom,"noinput");
                dropClass(that.dom,"nomatches");
                if (callback) async(function(){callback(result);});});
            return result;}};

    Completions.prototype.getByValue=function(values,spec){
        if (!(this.initialized)) initCompletions(this);
        var result=[];
        var byvalue=this.byvalue;
        if (spec) spec=new fdjtDOM.Selector(spec);
        if (!(values instanceof Array)) values=[values];
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                if (!(completions instanceof Array))
                    completions=[completions];
                if (spec) {
                    var j=0; var jlim=completions.length;
                    while (j<jlim) {
                        if (spec.match(completions[j]))
                            result.push(completions[j++]);
                        else j++;}}
                else result=result.concat(completions);}}
        return result;};
    Completions.prototype.getByKey=function(keys,spec){
        if (!(this.initialized)) initCompletions(this);
        var result=[];
        var bykey=this.bykey;
        if (spec) spec=new fdjtDOM.Selector(spec);
        if (!(keys instanceof Array)) keys=[keys];
        var i=0; var lim=keys.length;
        while (i<lim) {
            var key=keys[i++];
            var completions=bykey.get(key);
            if (completions) {
                if (!(completions instanceof Array))
                    completions=[completions];
                if (spec) {
                    var j=0; var jlim=completions.length;
                    while (j<jlim) {
                        if (spec.match(completions[j]))
                            result.push(completions[j++]);
                        else j++;}}
                else result=result.concat(completions);}}
        return result;};

    Completions.prototype.setCues=function(values,cueclass){
        if (!(this.initialized)) initCompletions(this);
        if (!(cueclass)) cueclass="cue";
        var cues=[];
        var byvalue=this.byvalue;
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                if (!(completions instanceof Array))
                    completions=[completions];
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,cueclass)) continue;
                    addClass(c,cueclass);
                    cues.push(c);}}}
        return cues;};

    Completions.prototype.setClass=function(values,classname){
        if (!(this.initialized)) initCompletions(this);
        var drop=fdjtDOM.getChildren(this.dom,".completion."+classname);
        if ((drop)&&(drop.length))
            dropClass(fdjtDOM.Array(drop),"hidden");
        var changed=[];
        var byvalue=this.byvalue;
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                if (!(completions instanceof Array))
                    completions=[completions];
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,classname)) continue;
                    addClass(c,classname);
                    changed.push(c);}}}
        return changed;};
    Completions.prototype.extendClass=function(values,classname){
        if (!(this.initialized)) initCompletions(this);
        var changed=[];
        var byvalue=this.byvalue;
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                if (!(completions instanceof Array))
                    completions=[completions];
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,classname)) continue;
                    addClass(c,classname);
                    changed.push(c);}}}
        return changed;};
    
    Completions.prototype.dropClass=function(classname){
        var drop=fdjtDOM.getChildren(this.dom,".completion."+classname);
        if ((drop)&&(drop.length))
            dropClass(fdjtDOM.Array(drop),classname);};

    Completions.prototype.docomplete=function(input,callback){
        if (!(this.initialized)) initCompletions(this);
        if (!(input)) input=this.input;
        var delay=this.complete_delay||complete_delay;
        var that=this;
        if (this.timer) {
            clearTimeout(that.timer);
            that.timer=false;}
        this.timer=setTimeout(
            function(){
                if (!(input)) input=that.input;
                var completions=that.complete(input.value);
                if (callback) callback(completions);},
            delay);};

    function stdspace(string){
        return string.replace(/\s+/," ").replace(/(^\s)|(\s$)/,"");}

    fdjtUI.Completions=Completions;

    /* Selection from list/cloud */

    var Selector=fdjtDOM.Selector;

    function gatherVisible(root){
        var scan=root.firstChild; var displayed=[];
        while (scan!==root) {
            if (scan.nodeType===1) {
                var iscompletion=hasClass(scan,"completion");
                if ((iscompletion)&&(getStyle(scan).display!=="none")) 
                    displayed.push(scan);
                if ((scan.firstChild)&&(!(iscompletion))) {
                    scan=scan.firstChild; continue;}}
            while ((scan!==root)&&(!(scan.nextSibling)))
                scan=scan.parentNode;
            if (scan!==root) scan=scan.nextSibling;}
        return displayed;}

    // This gets visible nodes in their order of appearance, for which
    // we can't use .nodes or .displayed
    Completions.prototype.getVisible=function getVisible(){
        if (this.visible) return this.visible;
        else {
            var visible=this.visible=gatherVisible(this.dom);
            return visible;}};

    Completions.prototype.select=function select(completion){
        var pref=false; var displayed=this.getVisible();
        if (completion instanceof Selector) {
            pref=completion; 
            completion=false;}
        if ((!(completion))&&(pref)) {
            var nodes=displayed;
            var i=0; var lim=nodes.length; while (i<lim) {
                var node=nodes[i++];
                if (hasClass(node,pref)) {completion=node; break;}
                else continue;}}
        if ((!(completion))&&(displayed.length))
            completion=displayed[0];
        if (this.selection) dropClass(this.selection,"selected");
        addClass(completion,"selected");
        this.selection=completion;
        return completion;};
    
    Completions.prototype.selectNext=function(selection){
        if (!(selection)) {
            if (this.selection) selection=this.selection;
            else selection=false;}
        var nodes=this.getVisible(), dflt=false, found=false;
        var i=0, lim=nodes.length; while (i<lim) {
            var node=nodes[i++];
            if (!(dflt)) dflt=node;
            if (!(selection)) {
                selection=node; break;}
            else if (node===selection) {
                selection=false; found=true;}
            else continue;}
        if (this.selection) dropClass(this.selection,"selected");
        if (!(found)) selection=dflt;
        addClass(selection,"selected");
        this.selection=selection;
        return selection;};

    Completions.prototype.selectPrevious=function(selection){
        if (!(selection)) {
            if (this.selection) selection=this.selection;
            else selection=false;}
        var nodes=this.getVisible(), dflt=false, found=false;
        var i=nodes.length-1; while (i>=0) {
            var node=nodes[i--];
            if (!(dflt)) dflt=node;
            if (!(selection)) {
                selection=node; break;}
            else if (node===selection) {
                selection=false; found=true;}
            else continue;}
        if (this.selection) dropClass(this.selection,"selected");
        if (!(found)) selection=dflt;
        if (selection) addClass(selection,"selected");
        this.selection=selection;
        return selection;};

    Completions.prototype.clearSelection=function(selection){
        if ((selection)&&(this.selection)&&(selection!==this.selection))
            return false;
        if (!(this.selection)) return;
        dropClass(this.selection,"selected");
        this.selection=false;
        return true;};

    /* Options, handlers, etc */

    var cached_completions={};

    function onkey(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var name=target.name;
        var completions=cached_completions[name];
        var compid=fdjtDOM.getAttrib(target,"completions");
        var dom=((compid)&&(fdjtID(compid)));
        if (!(dom)) return;
        if (!((completions)&&(completions.dom===dom))) {
            completions=new Completions(dom,target,default_options);
            cached_completions[name]=completions;}
        if (!(completions)) return;
        completions.docomplete(target);}
    fdjtUI.Completions.onkey=onkey;
    
    function update(evt){
        evt=evt||window.event;
        if (typeof evt==='string') evt=fdjtID(evt);
        if (!(evt)) return;
        var target=((evt.nodeType)?(evt):(fdjtUI.T(evt)));
        var name=target.name;
        var completions=cached_completions[name];
        var compid=fdjtDOM.getAttrib(target,"completions");
        var dom=((compid)&&(fdjtID(compid)));
        if (!(dom)) return;
        if (!((completions)&&(completions.dom===dom))) {
            completions=new Completions(dom,target,default_options);
            cached_completions[name]=completions;}
        if (!(completions)) return;
        completions.docomplete(target);}
    fdjtUI.Completions.update=update;

}());

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/taphold.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));
    if (!(fdjt.UI)) fdjt.UI={};

fdjt.TapHold=fdjt.UI.TapHold=(function(){
    "use strict";
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtET=fdjt.ET;

    var traceall=0;
    var window_setup=false;
    var default_opts={};
    
    var getChildren=fdjtDOM.getChildren;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var hasClass=fdjtDOM.hasClass;
    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var reticle=fdjtUI.Reticle;

    var noBubble=fdjtUI.noBubble;
    var noDefault=fdjtUI.noDefault;
    // var cancel=fdjtUI.cancel;
    var eTarget=fdjtUI.T;

    var cleared=0;
    var serial_count=1;

    var keynums={
        shift: 16, alt: 18, control: 17, meta: 224,
        os: 91, altgr: 225, fn: -1,
        numlock: 144, capslock: 20, scrolllock: 145};
    var keynames={};
    for (var akeyname in keynums)
        if (keynums.hasOwnProperty(akeyname)) {
            var akeynum=keynums[akeyname];
            if ((typeof akeynum === 'number')&&(akeynum>0))
                keynames[akeynum]=akeyname;}
    
    var sqrt=Math.sqrt;
    function xyd(x0,y0,x1,y1){
        if ((typeof x0==="number")&&(typeof y0==="number")&&
            (typeof x1==="number")&&(typeof y1==="number"))
            return sqrt((x0-x1)*(x0-x1)+(y0-y1)*(y0-y1));
        else return false;}

    function getClientX(evt,x,y){
        if (typeof evt.clientX === "number") return evt.clientX;
        var touches=((evt.changedTouches)&&(evt.changedTouches.length)&&
                     (evt.changedTouches))||
            ((evt.touches)&&(evt.touches.length)&&(evt.touches));
        var winxoff=window.pageXOffset, winyoff=window.pageYOffset;
        if ((touches)&&(touches.length)) {
            if ((touches.length===1)||
                (typeof x !== "number")||
                (typeof y !== "number"))
                return (touches[0].pageX-winxoff);
            else {
                var i=1, lim=touches.length, tch=touches[0];
                var d=xyd(Math.abs(tch.pageX-winxoff),
                          Math.abs(tch.pageY-winyoff),
                          x,y);
                var d_min=d, touch=tch;
                while (i<lim) {
                    tch=touches[i++];
                    d=xyd(Math.abs(tch.pageX-winxoff),
                          Math.abs(tch.pageY-winyoff),
                          x,y);
                    if (d<d_min) {touch=tch; d_min=d;}}
                return touch.pageX-winxoff;}}
        else return false;}
    function getClientY(evt,x,y){
        if (typeof evt.clientY === "number") return evt.clientY;
        var touches=((evt.changedTouches)&&(evt.changedTouches.length)&&
                     (evt.changedTouches))||
            ((evt.touches)&&(evt.touches.length)&&(evt.touches));
        var winxoff=window.pageXOffset, winyoff=window.pageYOffset;
        if ((touches)&&(touches.length)) {
            if ((touches.length===1)||
                (typeof x !== "number")||
                (typeof y !== "number"))
                return (touches[0].pageY-winyoff);
            else {
                var i=1, lim=touches.length, tch=touches[0];
                var d=(Math.abs(Math.abs(tch.pageX-winxoff)-x)+
                       (Math.abs(Math.abs(tch.pageY-winyoff)-y)));
                var d_min=d, touch=tch;
                while (i<lim) {
                    tch=touches[i++];
                    d=(Math.abs(Math.abs(tch.pageX-winxoff)-x)+
                       (Math.abs(Math.abs(tch.pageY-winyoff)-y)));
                    if (d<d_min) {touch=tch; d_min=d;}}
                return touch.pageY-winyoff;}}
        else return false;}
    
    function synthesizeEvent(target,etype,th,orig,tx,ty,tn,also){
        var thid=th.id||(typeof th), trace=th.traced, handlers=th.handlers;
        var orig_target=(orig)&&(eTarget(orig));
        if (!(target)) target=orig_target;
        var evt = document.createEvent("UIEvent");
        var event_arg=
            (((orig)&&(orig.touches)&&(orig.touches.length))||
             ((orig)&&(orig.button))||
             0);
        evt.initUIEvent(etype, true, true,window,event_arg);
        evt.clientX=tx; evt.clientY=ty; evt.ntouches=tn||1;
        if (also) {
            for (var prop in also) {
                if (also.hasOwnProperty(prop)) {
                    evt[prop]=also[prop];}}}
        if ((trace)||(traceall)) {
            if ((also)&&(typeof also.startX === "number"))
                fdjtLog("TapHold/%s(%s) on %o @%d,%d/%d,%d from %o given %j",
                        etype,thid,target,tx,ty,also.startX,also.startY,
                        orig||"scratch",also);
            else if (also)
                fdjtLog("TapHold/%s(%s) on %o @%d,%d from %o given %j",
                        etype,thid,target,tx,ty,orig||"scratch",also);
            else fdjtLog("TapHold/%s(%s) on %o @%d,%d from %j",
                         etype,thid,target,tx,ty,orig||"scratch");}
        if ((!target)||(!(hasParent(target,document.body))))
            target=document.elementFromPoint(tx,ty);
        if (orig_target!==target)
            evt.relatedTarget=orig_target;
        if ((handlers)&&(handlers.hasOwnProperty(etype))) {
            evt.target=target;
            handlers[etype](evt,target);}
        else target.dispatchEvent(evt);}
    
    /* This gets the target based on geometry. */
    function getRealTarget(holder,touchable,x,y){
        var children=getChildren(holder,touchable);
        var i=0, lim=children.length;
        while (i<lim) {
            var child=children[i++];
            var left=child.offsetLeft, top=child.offsetTop;
            var right=child.offsetRight, bot=child.offsetBottom;
            if (typeof left !== "number") continue;
            else if ((((right-left)<=1)?
                      ((x>=left)&&(y<=right)):
                      ((x>=left)&&(y<right)))&&
                     (((bot-top)<=1)?
                      ((y>=top)&&(y<=bot)):
                      ((x>=top)&&(y<bot)))) {
                // fdjtLog("Got %o at %d,%d ltrb=%d,%d,%d,%d",child,x,y,left,top,right,bot);
                return child;}}
        return false;}

    var mouse_down=false;
    function global_mouseup(evt){
        evt=evt||window.event;
        if (traceall) fdjtLog("TapHold/global/mouseup %o",evt);
        if (evt.button===1) mouse_down=false;}
    function global_mousedown(evt){
        evt=evt||window.event;
        if (traceall) fdjtLog("TapHold/global/mousedown %o",evt);
        if (evt.button===1) mouse_down=true;}
    function global_mouseout(evt){
        evt=evt||window.event;
        var target=eTarget(evt), rel=evt.relatedTarget||evt.toElement;
        if (traceall>2)
            fdjtLog("TapHold/global/mouseout %o %o==>%o",
                    evt,target,rel);
        if (target===document.documentElement)
            mouse_down=false;}

    function traceValue(classname){
        var parsed=/\bfdjtlog(\d*)/.exec(classname);
        if ((parsed)&&(parsed.length)) {
            var level=
                ((typeof parsed[1] === "string")&&
                 (parseInt(parsed[1],10)));
            if ((level)&&(!(isNaN(level))))
                return level;
            else return 1;}
        else return 0;}

    function TapHold(elt,opts){
        if (!(elt)) {
            fdjtLog.warn("TapHold with no argument!");
            return;}
        
        if (!(this instanceof TapHold))
            return new TapHold(elt,opts);
        
        var th=this;
        var holdclass="tapholding";
        var touchclass="tapholdtarget";
        // Touched is set when the gesture is started, pressed is set
        // when it becomes a hold (with pressed_at as the time)
        var touched=false, pressed=false, pressed_at=false;
        // The timer which turns a touch into a hold
        var th_timer=false, tt_timer=false;
        // The current touch target, and a history of touch targets,
        // to handle slips.
        var th_target=false, th_targets=[];
        var tap_target=false, th_target_t=false, th_last=false;
        // Whether we're in a touch environment.
        var fortouch=false;
        // Whether motion causes a 'hold' to slip among targets,
        // triggering 'slip' events and new 'hold' events.
        var noslip=false;
        // Whether created events bubble;
        var bubble=false;
        // Whether to override (cancel) the default handlers on the
        // container
        var override=false;
        // Don't capture events with more than this number of touches
        var maxtouches=1;

        // If this is true, second touches in the container during a
        //  live touch are turned into touchtoo events; otherwise,
        //  they abort the current press/touch and start a new tap or
        //  hold
        var touchtoo=false;
        
        // How long it takes a touch to become a press
        var holdmsecs=false;
        // How long (and whether) to recognize double taps
        var taptapmsecs=false;
        // Abort a press when the touch moves move than this many pixels
        var movethresh=false;
        // How long to wait before aborting a press after the touch wanders
        //  away from the touch container
        var wanderthresh=false;
        // Minimum distance before recognizing a swipe
        var min_swipe=30;
        
        var scrolling=false, scroll_x=0, scroll_y=0;
        // These indicate where/when the current gesture started, is
        // currently, and the last point at which the touch target
        // changed.
        var start_x=false, start_y=false, start_t=false;
        var touch_x=false, touch_y=false, touch_t=0, touch_n=false;
        var target_x=false, target_y=false, target_t=false;
        // This is when (and whether) a swipe event has been generated
        //  for the current gesture.
        var swipe_t=false;
        // This controls the maximum velocity (in pixels/second) for touches
        //  to change targets
        var minmove=2;
        // This is how far the touch 'hotspot' is from the actual x, y
        // (This may not be entirely consistent with touchstart
        // targets, which is a potential problem.).
        var hot_xoff=0, hot_yoff=0;
        // The level of tracing to use for this TapHold handler
        var trace=0;
        
        var serial=serial_count++;
        var thid=(((opts)&&(opts.id))?(opts.id+":"+serial):
                  (elt.id)?("#"+elt.id+":"+serial):
                  (""+serial));
        th.id=thid;

        var touchable=elt.getAttribute("data-touchable");
        if ((opts)&&(opts.hasOwnProperty("touchable"))) {
            // Opts override attributes
            if (typeof opts.touchable === "string")
                touchable=fdjtDOM.Selector(opts.touchable);
            else touchable=opts.touchable;}
        else if (touchable) touchable=fdjtDOM.Selector(touchable);
        else touchable=function(e){return hasParent(e,elt);};

        var isClickable=fdjtUI.isClickable, untouchable;
        if ((opts)&&(opts.hasOwnProperty("untouchable"))) {
            // Opts override attributes
            if (typeof opts.untouchable === "string") {
                var notouch=fdjtDOM.Selector(opts.untouchable);
                untouchable=function(e){
                    if (e.nodeType) return notouch.match(e);
                    else return notouch.match(eTarget(e));};}
            else untouchable=opts.untouchable;}
        else untouchable=function(e){return isClickable(e);};
        
        if ((opts)&&(opts.noslip)) noslip=opts.noslip;
        if ((opts)&&(opts.touch_xoff)) hot_xoff=opts.touch_xoff;
        if ((opts)&&(opts.touch_yoff)) hot_yoff=opts.touch_yoff;

        if ((opts)&&(opts.hasOwnProperty("trace"))) {
            var opt_val=opts.trace;
            if (typeof opt_val==="number") trace=opt_val;
            else if (opt_val) trace=2;
            else trace=0;}
        else if (hasClass(elt,/\bfdjtlog\d*/g))
            trace=traceValue(elt.className);
        else trace=0;
        
        var wander_timer=false;

        function cleartouch(all){
            if (th_timer) {clearTimeout(th_timer); th_timer=false;}
            if ((all)&&(tt_timer)) {
                clearTimeout(tt_timer); tt_timer=false;}
            if ((th_target)&&(touchclass))
                dropClass(th_target,touchclass);
            th_target=th_target_t=false; th_targets=[];
            swipe_t=start_x=start_y=start_t=
                touch_x=touch_y=touch_t=touch_n=
                target_x=target_y=target_t=false;
            touched=pressed=pressed_at=false;}

        function synthEvent(target,etype,th,orig,tx,ty,also){
            return synthesizeEvent(target,etype,th,orig,tx,ty,touch_n,also);}

        function setTarget(t){
            if (((trace>2)||(traceall>2))||
                ((t!==th_target)&&((trace)||(traceall))))
                fdjtLog("TapHold/setTarget(%s) %o cur=%o",thid,t,th_target);
            if ((th_target)&&(th_target!==t)&&(touchclass))
                dropClass(th_target,"tapholdtarget");
            if ((t)&&(touchclass)) addClass(t,"tapholdtarget");
            if ((t)&&(th_target)&&(t!==th_target)) {
                target_x=touch_x; target_y=touch_y; target_t=touch_t;}
            th_last=th_target;
            th_target=t; th_target_t=fdjtET();}

        function tapped(target,evt,x,y){
            if (typeof x === "undefined") x=touch_x;
            if (typeof y === "undefined") y=touch_y;
            return synthEvent(target,"tap",th,evt,x,y,false);}
        function held(target,evt,x,y){
            if (typeof x === "undefined") x=touch_x;
            if (typeof y === "undefined") y=touch_y;
            if (holdclass)
                setTimeout(function(){addClass(elt,holdclass);},20);
            return synthEvent(target,"hold",th,evt,x,y,false);}
        function released(target,evt,x,y){
            var target_time=
                ((th_target_t)&&(th_last)&&(fdjtET()-th_target_t));
            if (typeof x === "undefined") x=touch_x;
            if (typeof y === "undefined") y=touch_y;
            if (holdclass)
                setTimeout(function(){
                    if (!(th_target)) dropClass(elt,holdclass);},
                           50);
            if ((target_time)&&(target_time<200)) {
                if (trace)
                    fdjtLog("TapHold(%s) %d=i<200ms, target=%o not %o",
                            thid,target_time,th_last,target);
                target=th_last;}
            return synthEvent(target,"release",th,evt,x,y,
                              {startX: start_x,startY: start_y});}
        function slipped(target,evt,also){
            if (also) {
                also.startX=start_x; also.startY=start_y;}
            else also={startX: start_x,startY: start_y};
            if (evt) {
                var rel=evt.relatedTarget||eTarget(evt);
                if (rel!==target) also.relatedTarget=rel;}
            if (holdclass)
                setTimeout(function(){
                    if (!(th_target)) dropClass(elt,holdclass);},
                           50);
            return synthEvent(target,"slip",th,evt,touch_x,touch_y,also);}
        function taptapped(target,evt){
            return synthEvent(target,"taptap",th,evt,
                              touch_x,touch_y,false,trace);}
        function swiped(target,evt,sx,sy,cx,cy){
            var dx=cx-sx, dy=cy-sy; swipe_t=fdjtET();
            return synthEvent(target,"swipe",th,evt,cx,cy,
                              {startX: sx,startY: sy,endX: cx,endY: cy,
                               deltaX: dx,deltaY: dy});}
        
        function startpress(evt,to){
            if (!(to)) to=holdmsecs||TapHold.interval||100;
            evt=evt||window.event;
            if ((trace>1)||(traceall>1))
                fdjtLog("TapHold/startpress(%s) %o tht=%o timer=%o tt=%o touched=%o pressed=%o@%o timeout=%oms",
                        thid,evt,th_target,th_timer,tap_target,touched,
                        pressed,pressed_at,to);
            if ((tap_target)&&(th_timer)) {
                clearTimeout(th_timer); th_timer=false;}
            if ((tap_target)&&(tt_timer)) {
                clearTimeout(tt_timer); tt_timer=false;
                taptapped(tap_target,evt);
                cleartouch(true);
                return;}
            if ((touched)||(pressed)||(th_timer)) return;
            else if (!(th_target)) {
                swipe_t=false; return;}
            else {touched=th_target; pressed=false; swipe_t=false;}
            if (reticle.live) reticle.highlight(true);
            pressed_at=fdjtET(); 
            if (th_timer) clearTimeout(th_timer);
            th_timer=setTimeout((function(){
                if ((trace>1)||(traceall>1))
                    fdjtLog("TapHold/startpress/timeout(%s) (%dms) %o",
                            thid,to,evt);
                if (th_targets.length>0) {
                    var targets=th_targets;
                    var i=0, lim=targets.length;
                    while (i<lim) {
                        var elt=targets[i++];
                        if ((i===lim)&&(elt===th_target)) break;
                        held(elt);
                        if (noslip) {}
                        else if (i<lim)
                            slipped(elt,evt,{relatedTarget: targets[i]});
                        else slipped(elt,evt);}}
                pressed=th_target; th_targets=[];
                if (th_target) pressed_at=fdjtET(); else pressed_at=false;
                held(th_target,evt);
                if (th_timer) clearTimeout(th_timer);
                th_timer=false;
                touched=false;}),
                                to);}
        function endpress(evt){
            if ((trace>1)||(traceall>1))
                fdjtLog("TapHold/endpress(%s) %o t=%o p=%o tch=%o tm=%o ttt=%o/%o, start=%d,%d,%d/%d",
                        thid,evt,th_target,pressed,touched,th_timer,
                        tap_target,taptapmsecs,
                        start_x,start_y,start_t,fdjtET());
            if ((!(pressed))&&(!(touched))&&(!(th_timer))) {
                cleartouch(true);
                return;}
            var x=touch_x, y=touch_y;
            if (th_timer) {
                clearTimeout(th_timer); th_timer=false;
                if (reticle.live) 
                    setTimeout(function(){reticle.highlight(false);},1500);
                if ((th_target===touched)||
                    ((fdjtET()-start_t)<(holdmsecs/1000))) {
                    tap_target=th_target;
                    if ((taptapmsecs)&&(taptapmsecs>0)) {
                        tt_timer=setTimeout(function(){
                            tt_timer=false; tapped(tap_target,evt,x,y);},
                                            taptapmsecs);}
                    else tapped(th_target,evt,x,y);}
                else if (noslip) {}
                else slipped(th_target,evt);}
            else if (pressed) {
                var geom=fdjtDOM.getGeometry(elt);
                if ((x>=geom.left)&&(x<=geom.right)&&
                    (y>=geom.top)&&(y<=geom.bottom))
                    released(pressed,evt,x,y);
                else if (noslip)
                    released(pressed,evt,x,y);
                else slipped(th_target,evt,{touch_x: x,touch_y: y});}
            else {}
            if (reticle.live) reticle.highlight(false);
            cleartouch();
            setTarget(false);
            if (holdclass)
                setTimeout(function(){dropClass(elt,holdclass);},20);
            th_targets=[];}
        function abortpress(evt,why){
            if ((trace)||(traceall))
                fdjtLog("TapHold/abort%s(%s) %o: th=%o t=%o p=%o",
                        ((why)?("("+why+")"):("")),thid,
                        evt,th_target,touched,pressed);
            if (th_timer) {
                clearTimeout(th_timer); th_timer=false;}
            else if (noslip) {}
            else if (pressed) {slipped(pressed,evt);}
            if (reticle.live) reticle.highlight(false);
            pressed_at=touched=pressed=tap_target=false;
            if (holdclass)
                setTimeout(function(){dropClass(elt,holdclass);},20);
            th_targets=[];
            setTarget(false);}

        function taphold_mouseout(evt){
            evt=evt||window.event;
            var to=evt.toElement||evt.relatedTarget;
            if (wander_timer) return;
            if (!(th_target)) return;
            if ((pressed)&&(!(hasParent(to,elt)))) {
                wander_timer=setTimeout(function(){
                    if (!(noslip))
                        slipped(pressed,evt,{relatedTarget: to});
                    abortpress(evt,"taphold_mouseout");},
                                        wanderthresh);}}

        function taphold_mouseover(evt){
            evt=evt||window.event;
            if (wander_timer) {
                clearTimeout(wander_timer);
                wander_timer=false;}}

        function taphold_move(evt){
            evt=evt||window.event;
            var target, n_touches=((evt.touches)&&(evt.touches.length))||1;
            if ((!(bubble))) noBubble(evt);
            if (override) noDefault(evt);
            if ((scrolling)&&(evt.touches)&&(evt.touches.length<=maxtouches)) {
                if (scroll_x>=0) 
                    scrolling.scrollLeft=
                    scroll_x-(evt.touches[0].pageX-window.pageXOffset);
                if (scroll_y>=0)
                    scrolling.scrollTop=
                    scroll_y-(evt.touches[0].pageY-window.pageYOffset);}
            if ((pressed)&&(cleared>start_t)) {
                abortpress(evt,"move/cleared");
                return;}
            if (((touched)||(pressed))&&(!(mouse_down))) {
                abortpress(evt,"move/up");
                return;}
            
            // if (target!==th_target) fdjtLog("New target %o",target);
            var x=evt.clientX||getClientX(evt,touch_x,touch_y);
            var y=evt.clientY||getClientY(evt,touch_x,touch_y);
            var distance=((pressed)?
                          (xyd(x,y,target_x,target_y)):
                          (xyd(x,y,start_x,start_y)));
            if ((evt.touches)||(hot_xoff)||(hot_yoff)) {
                x=x+hot_xoff; y=y+hot_yoff;
                target=document.elementFromPoint(x,y);}
            else target=eTarget(evt);
            var delta=(Math.abs(x-touch_x))+(Math.abs(y-touch_y));
            var dt=fdjtET()-touch_t;
            if ((trace>2)||(traceall>2))
                fdjtLog("TapHold/move(%s) s=%d,%d tt=%d,%d t=%d,%d c=%d,%d d=%d thresh=%o, dt=%o md=%o, pressed=%o, touched=%o, event=%o target=%o",
                        thid,start_x,start_y,
                        target_x,target_y,touch_x,touch_y,x,y,
                        distance,movethresh,dt,mouse_down,
                        pressed,touched,evt,target);
            if (!(target)) {
                touch_x=x; touch_y=y; touch_t=fdjtET();
                if (!(touch_n)) touch_n=n_touches; else
                    if (n_touches>touch_n) touch_n=n_touches;
                return;}
            var holder=getParent(target,".tapholder");
            // fdjtLog("taphold_move %o %d,%d %o %o",evt,x,y,target,holder);
            if (holder!==elt) {
                if ((trace>2)||(traceall>2)) {
                    trace_ignore_move(evt,thid,elt,holder,th_target,target,
                                      start_x,start_y,target_x,target_y,
                                      touch_x,touch_y);}
                if (th_target) {
                    if ((trace)||(traceall))
                        fdjtLog("setWanderTimeout(%s): h=%o!=elt=%o",
                                thid,holder,elt);
                    wander_timer=setTimeout(function(){
                        abortpress(evt,"taphold_wander_timeout");},
                                            wanderthresh);
                    if (pressed) {
                        if (!(noslip))
                            slipped(pressed,evt,{relatedTarget: target});
                        setTarget(false);}}
                return;}
            else if (wander_timer) {
                clearTimeout(wander_timer); wander_timer=false;
                if ((trace>2)||(traceall>2))
                    fdjtLog("Wander return(%s) %o pressed=%o, target=%o",
                            thid,evt,pressed,th_target);
                if ((pressed)&&(!(th_target))) {
                    setTarget(pressed);
                    held(pressed,evt);}}
            else {}

            // If touched is false, the tap/hold was aborted somehow
            if ((!((touched)||(pressed)))) {
                // Just tracking, to detect swipes
                if ((!(swipe_t))&&(min_swipe>0)&&(xyd(start_x,start_y,x,y)>min_swipe))
                    swiped(target,evt,start_x,start_y,x,y);
                touch_x=x; touch_y=y; touch_t=fdjtET();
                if (!(touch_n)) touch_n=n_touches; else
                    if (n_touches>touch_n) touch_n=n_touches;
                return;}
            
            if ((movethresh)&&(th_timer)&&
                (distance>movethresh)) {
                if ((trace>1)||(traceall>1))
                    fdjtLog("TapHold/move/cancel(%s) s=%d,%d tt=%d,%d t=%d,%d c=%d,%d d=%d thresh=%o, dt=%o md=%o, event=%o",
                            thid,start_x,start_y,
                            target_x,target_y,touch_x,touch_y,x,y,
                            distance,movethresh,dt,mouse_down,evt);
                abortpress(evt,"movefar");
                if (th_timer) clearTimeout(th_timer);
                pressed_at=touched=th_timer=pressed=false; th_targets=[];
                if ((!(swipe_t))&&(min_swipe>0)&&(xyd(start_x,start_y,x,y)>min_swipe))
                    swiped(target,evt,start_x,start_y,x,y);
                setTarget(false);
                touch_x=x; touch_y=y; touch_t=fdjtET();
                if (!(touch_n)) touch_n=n_touches; else
                    if (n_touches>touch_n) touch_n=n_touches;
                return;}
            else if ((delta<(minmove*10))&&(dt>0)&&((delta/dt)<minmove)) {
                if ((trace>2)||(traceall>2))
                    fdjtLog("TapHold/move/ignore(%s) s=%d,%d t=%d,%d c=%d,%d dt=%o total=%d/%o, local=%d/%o/%o, thresh=%o md=%o",
                            thid,start_x,start_y,touch_x,touch_y,x,y,
                            dt,distance,movethresh,
                            delta,delta/dt,minmove,
                            mouse_down);
                touch_x=x; touch_y=y; touch_t=fdjtET();
                if (!(touch_n)) touch_n=n_touches; else
                    if (n_touches>touch_n) touch_n=n_touches;
                return;}
            else {
                if ((trace>2)||(traceall>2))
                    fdjtLog("TapHold/move(%s) s=%d,%d t=%d,%d c=%d,%d dt=%o total=%d/%o, local=%d/%o/%o, md=%o",
                            thid,start_x,start_y,touch_x,touch_y,x,y,
                            dt,distance,movethresh,delta,minmove,delta/dt,
                            mouse_down);
                touch_x=x; touch_y=y; touch_t=fdjtET();
                if (!(touch_n)) touch_n=n_touches; else
                    if (n_touches>touch_n) touch_n=n_touches;
                target=getParent(target,touchable);}
            if ((evt.touches)&&(evt.touches.length)&&
                (evt.touches.length>maxtouches))
                return;
            else {
                if (reticle.live) reticle.onmousemove(evt,touch_x,touch_y);}
            if (!(target)) target=getRealTarget(elt,touchable,touch_x,touch_y);
            if (!(target)) return;
            if ((hasParent(target,".tapholder"))&&(!(noslip)))
                setTarget(target);
            if ((evt.touches)&&(touched)&&(!(pressed))&&
                (th_targets[th_targets.length-1]!==th_target))
                th_targets.push(th_target);
            if (!(mouse_down)) {
                if (!(noslip))
                    slipped(pressed,evt,{relatedTarget: target});
                pressed_at=pressed=false;}
            else if ((pressed)&&(th_target!==pressed)&&
                     (!((hasParent(th_target,pressed))||
                        (hasParent(pressed,th_target))))&&
                     (noslip)) {      
                if ((trace>1)||(traceall>1))
                    fdjtLog("TapHold/move(%s) endpress pressed=%o tt=%o %o",
                            thid,pressed,th_target,evt);
                endpress(evt);}
            else if ((pressed)&&(th_target!==pressed)) {
                if (!(noslip))
                    slipped(pressed,evt,{relatedTarget: target});
                pressed=th_target;
                if (pressed) pressed_at=fdjtET(); else pressed_at=false;
                held(pressed);}
            else {}}
        function trace_ignore_move(evt,thid,elt,holder,th_target,target,
                                   start_x,start_y,target_x,target_y,
                                   touch_x,touch_y) {
            fdjtLog(
                "TapHold/move%s/farout(%s) %o %o -> %o s=%d,%d tt=%d,%d t=%d,%d",
                ((mouse_down)?("/md"):("")),thid,
                evt,th_target,target,start_x,start_y,
                target_x,target_y,touch_x,touch_y);
            fdjtLog("TapHold/move/farout(%s) target in %o, elt is %o",
                    thid,holder,elt);}

        function taphold_down(evt,holdmsecs){
            evt=evt||window.event;
            if ((evt.ctrlKey)||
                (evt.altKey)||(evt.metaKey)||
                (evt.button)||
                ((evt.which)&&(evt.which>1)))
                return;
            var n_touches=((evt.touches)&&(evt.touches.length))||1;
            mouse_down=true; cleared=0;
            touch_x=(evt.clientX||getClientX(evt)||touch_x)+hot_xoff;
            touch_y=(evt.clientY||getClientY(evt)||touch_y)+hot_yoff;
            start_x=target_x=touch_x; start_y=target_y=touch_y;
            target_t=touch_t=fdjtET();
            var target=(((hot_xoff)||(hot_yoff))?
                        (document.elementFromPoint(touch_x,touch_y)):
                        (eTarget(evt)));
            if (!(touch_n)) touch_n=n_touches; else
                if (n_touches>touch_n) touch_n=n_touches;
            if ((!(bubble))) noBubble(evt);
            if (override) noDefault(evt);
            var new_event=false;
            var holder=getParent(target,".tapholder");
            if ((trace>1)||(traceall>1))
                fdjtLog("TapHold/down(%s) %o tht=%o target=%o holder=%o elt=%o",
                        thid,evt,th_target,target,holder,elt);
            if (holder!==elt) {
                if ((trace>1)||(traceall>1))
                    fdjtLog("TapHold/ignore(%s) %o tht=%o t=%o h=%o elt=%o",
                            thid,evt,th_target,target,holder,elt);
                return;}

            if (target) target=getParent(target,touchable);
            if ((scrolling)&&(evt.touches)&&(evt.touches.length<=maxtouches)) {
                if (scroll_x>=0)
                    scroll_x=scrolling.scrollLeft+(
                        evt.touches[0].pageX-window.pageXOffset);
                if (scroll_y>=0)
                    scroll_y=scrolling.scrollLeft+(
                        evt.touches[0].pageY-window.pageYOffset);}
            if (evt.touches) {
                target=document.elementFromPoint(touch_x,touch_y);}
            if ((trace>1)||(traceall>1))
                fdjtLog(
                    "TapHold/down2(%s) %o tht=%o trg=%o s=%o,%o,%o t=%o,%o m=%o tch=%o prs=%o ttt=%o",
                    thid,evt,th_target,target,
                    start_x,start_y,start_t,touch_x,touch_y,mouse_down,
                    touched,pressed,taptapmsecs||false);
            
            if ((evt.touches)&&(th_target)) {
                // Handle additional touches while holding/pressing
                var cur_holder=getParent(elt,".tapholder");
                var touch=evt.changedTouches[0];
                if ((trace>1)||(traceall>1))
                    fdjtLog("TapHold(%s) second touch on %o (in %o) after %o (in %o)",
                            thid,target,holder,th_target,cur_holder,
                            (cur_holder===holder));
                if ((touchtoo)&&(cur_holder===holder)) {
                    if ((trace>1)||(traceall>1))
                        fdjtLog("TapHold(%s) touchtoo with touchtoo on %o after %o: %o",
                                thid,target,th_target,evt);
                    if (touchtoo.call) {
                        touchtoo.call(th,evt);
                        return;}
                    new_event=document.createEvent('UIEvent');
                    new_event.initUIEvent(
                        "touchtoo",true,true,window,0);
                    new_event.screenX=touch.screenX;
                    new_event.screenY=touch.screenY;
                    new_event.clientX=touch.clientX;
                    new_event.clientY=touch.clientY;
                    new_event.ctrlKey=evt.ctrlKey;
                    new_event.altKey=evt.altKey;
                    new_event.shiftKey=evt.shiftKey;
                    new_event.metaKey=evt.metaKey;
                    new_event.touches=document.createTouchList(touch);
                    new_event.targetTouches=document.createTouchList(touch);
                    new_event.changedTouches=document.createTouchList(touch);
                    target.dispatchEvent(new_event);
                    return;}
                else if ((cur_holder)&&(holder)&&
                         (cur_holder!==holder)) {
                    if ((trace>1)||(traceall>1))
                        fdjtLog("TapHold(%s) Clearing on %o, moving %o to %o",
                                thid,th_target,evt,target);
                    new_event=document.createEvent('TouchEvent');
                    new_event.initTouchEvent(
                        evt.type,true,true,window,null,
                        touch.screenX,touch.screenY,
                        touch.clientX,touch.clientY,
                        evt.ctrlKey,evt.altKey,evt.shiftKey,evt.metaKey,
                        document.createTouchList(touch),
                        document.createTouchList(touch),
                        document.createTouchList(touch));}
                else {}}
            if (new_event) {
                abortpress(evt,"down/touch2");
                target.dispatchEvent(new_event);
                return;}
            else {setTarget(target); th_targets=[];}
            start_t=fdjtET();
            if ((trace>1)||(traceall>1))
                fdjtLog("TapHold/down3(%s) %o t=%o x=%o y=%o t=%o touched=%o",
                        thid,evt,th_target,start_x,start_y,start_t,touched);
            if ((untouchable)&&(untouchable(evt))) return;
            if (!(touched)) startpress(evt,holdmsecs);}

        function taphold_up(evt){
            evt=evt||window.event;
            mouse_down=false;
            if (cleared>start_t) {
                abortpress(evt,"up");
                return;}
            var target=eTarget(evt);
            if ((!(bubble))) noBubble(evt);
            if (override) noDefault(evt);
            var holder=getParent(target,".tapholder");
            if (holder!==elt) {
                if ((trace>1)||(traceall>1))
                    fdjtLog("TapHold/up/ignore(%s) %o tht=%o target=%o holder=%o elt=%o",
                            thid,evt,th_target,target,holder,elt);
                return;}
            if (target) target=getParent(target,touchable);
            touch_x=(evt.clientX||getClientX(evt)||touch_x)+hot_xoff;
            touch_y=(evt.clientY||getClientY(evt)||touch_y)+hot_yoff;
            touch_t=fdjtET();
            if ((!(target))||(hot_xoff)||(hot_yoff))
                target=getRealTarget(elt,touchable,touch_x,touch_y);
            if ((trace>1)||(traceall>1))
                fdjtLog("TapHold/up(%s) %o tht=%o d=%o s=%o,%o,%o t=%o,%o m=%o touched=%o pressed=%o ttt=%o swipe_t=%o",
                        thid,evt,th_target,
                        xyd(start_x,start_y,touch_x,touch_y),
                        start_x,start_y,start_t,touch_x,touch_y,mouse_down,
                        touched,pressed,taptapmsecs,swipe_t);
            if ((evt.changedTouches)&&(evt.changedTouches.length)&&
                (evt.changedTouches.length>maxtouches))
                return;
            var swipe_len=(swipe_t)?(0):xyd(start_x,start_y,touch_x,touch_y);
            if ((touched)||(pressed)) {
                if ((untouchable)&&(untouchable(evt))) return;
                endpress(evt);}
            else if ((min_swipe>0)&&(swipe_len>min_swipe)&&
                     (((!touched)||(touched!==elt))&&
                      ((!pressed)||(pressed!==elt))))
                swiped(target,evt,start_x,start_y,touch_x,touch_y);
            else if ((touched)||(pressed)) {
                if (!((untouchable)&&(untouchable(evt)))) endpress(evt);}
            else {}
            cleartouch();}

        function taphold_cancel(evt){
            if ((trace)||(traceall))
                fdjtLog("TapHold/cancel(%s) %o: th=%o t=%o p=%o",
                        thid,evt,th_target,touched,pressed);
            if (th_timer) {
                clearTimeout(th_timer); th_timer=false;}
            else if (pressed) {released(pressed,evt);}
            if (reticle.live) reticle.highlight(false);
            pressed_at=touched=pressed=tap_target=false;
            if (holdclass)
                setTimeout(function(){dropClass(elt,holdclass);},20);
            th_targets=[];
            setTarget(false);}

        if (!(opts)) opts={};
        else if (!(opts.hasOwnProperty)) opts={touch: true};
        else {}

        fortouch=((opts.hasOwnProperty('fortouch'))?(opts.fortouch):
                  (default_opts.hasOwnProperty('fortouch'))?
                  (default_opts.fortouch):(false));
        holdmsecs=((opts.hasOwnProperty('holdmsecs'))?(opts.holdmsecs):
                    (default_opts.hasOwnProperty('holdmsecs'))?
                    (default_opts.holdmsecs):(150));
        movethresh=((opts.hasOwnProperty('movethresh'))?(opts.movethresh):
                    (default_opts.hasOwnProperty('movethresh'))?
                    (default_opts.movethresh):(20));
        taptapmsecs=((opts.hasOwnProperty('taptapmsecs'))&&
                      (opts.taptapmsecs));
        wanderthresh=((opts.hasOwnProperty('wanderthresh'))?(opts.wanderthresh):
                      (default_opts.hasOwnProperty('wanderthresh'))?
                      (default_opts.wanderthresh):(2000));
        override=((opts.hasOwnProperty('override'))?(opts.override):
                  (default_opts.hasOwnProperty('override'))?
                  (default_opts.override):(false));
        touchtoo=((opts.hasOwnProperty('touchtoo'))?(opts.touchtoo):
                  (default_opts.hasOwnProperty('touchtoo'))?
                  (default_opts.touchtoo):(false));
        min_swipe=((opts.hasOwnProperty('minswipe'))?(opts.minswipe):
                   (default_opts.hasOwnProperty('minswipe'))?
                   (default_opts.minswipe):(30));
        bubble=((opts.hasOwnProperty('bubble'))?(opts.bubble):
                (default_opts.hasOwnProperty('bubble'))?
                (default_opts.bubble):(false));
        maxtouches=((opts.hasOwnProperty('maxtouches'))?(opts.maxtouches):
                    (default_opts.hasOwnProperty('maxtouches'))?
                    (default_opts.maxtouches):(1));
        if ((taptapmsecs)&&(typeof taptapmsecs !== "number"))
            taptapmsecs=default_opts.taptapmsecs||200;
        scrolling=((opts.hasOwnProperty('scrolling'))?(opts.touch):(false));
        if (scrolling) {
            if (!(scrolling.nodeType)) scrolling=elt;
            if ((opts.hasOwProperty('scrollx'))?(opts.scrollx):(false))
                scroll_x=0; else scroll_x=-1;
            if ((opts.hasOwProperty('scrolly'))?(opts.scrolly):(true))
                scroll_y=0; else scroll_y=-1;}

        if (opts.hasOwnProperty('holdclass')) holdclass=opts.holdclass;
        else if (default_opts.hasOwnProperty('holdclass'))
            holdclass=default_opts.holdclass;
        else {}

        if (opts.hasOwnProperty('touchclass')) touchclass=opts.touchclass;
        else if (default_opts.hasOwnProperty('touchclass'))
            touchclass=default_opts.touchclass;
        else {}

        if (opts.hasOwnProperty('minmove')) minmove=opts.minmove;
        else if (default_opts.hasOwnProperty('minmove'))
            minmove=default_opts.minmove;
        else if (fortouch) minmove=2;
        else minmove=0;

        if (opts.hasOwnProperty('handlers'))
            this.handlers=opts.handlers;
        
        addClass(elt,"tapholder");
        
        if (!(fortouch)) fdjtDOM.addListener(elt,"mousemove",taphold_move);
        fdjtDOM.addListener(elt,"touchmove",taphold_move);
        if (!(fortouch)) fdjtDOM.addListener(elt,"mousedown",taphold_down);
        if (!(fortouch)) fdjtDOM.addListener(elt,"mouseout",taphold_mouseout);
        if (!(fortouch)) fdjtDOM.addListener(elt,"mouseover",taphold_mouseover);
        fdjtDOM.addListener(elt,"touchstart",taphold_down);
        if (!(fortouch)) fdjtDOM.addListener(elt,"mouseup",taphold_up);
        // fdjtDOM.addListener(elt,"click",taphold_click);
        fdjtDOM.addListener(elt,"touchend",taphold_up);
        fdjtDOM.addListener(elt,"touchcancel",taphold_cancel);        
        if (!(window_setup)) {
            if (!(default_opts.fortouch)) {
                fdjtDOM.addListener(window,"mousedown",global_mousedown);
                fdjtDOM.addListener(window,"mouseup",global_mouseup);
                fdjtDOM.addListener(window,"mouseout",global_mouseout);}
            // fdjtDOM.addListener(document,"keydown",taphold_keydown);
            // fdjtDOM.addListener(document,"keyup",taphold_keyup);
            window_setup=window;}

        this.elt=elt;
        this.serial=serial;
        this.opts={bubble: bubble,
                   override: override,
                   movethresh: movethresh,
                   holdmsecs: holdmsecs,
                   taptapmsecs: taptapmsecs};
        this.istouched=function(){return (touched);};
        this.ispressed=function(){return (pressed);};
        this.clear=function(){
            if ((trace)||(traceall))
                fdjtLog("TapHold/clear(%s) th=%o t=%o p=%o",
                        thid,th_target,touched,pressed);
            if ((pressed)&&(!(noslip))) slipped(pressed);
            pressed_at=touched=pressed=tap_target=false;
            cleartouch(true);
            setTarget(false);
            th_targets=[];};
        this.fakePress=function fakePress(evt,holdmsecs){
            start_x=target_x=touch_x=evt.clientX||getClientX(evt);
            start_y=target_y=touch_y=evt.clientY||getClientY(evt);
            touch_t=start_t=fdjtET();
            var target=document.elementFromPoint(start_x,start_y);
            if (!(target))
                fdjtLog("TapHold(%s): No target from %o,%o",
                        thid,start_x,start_y);
            setTarget(target); th_targets=[target];
            if ((trace)||(traceall))
                fdjtLog("TapHold/fakePress(%s) t=%o x=%o y=%o t=%o",
                        thid,th_target,start_x,start_y,start_t);
            startpress(evt,holdmsecs);};
        this.abort=abortpress;

        this.getState=function(){
            return {thid: thid,elt: elt,
                    pressed: pressed,touched: touched,
                    th_target: th_target,th_last: th_last,
                    start_x: start_x,start_y: start_y,start_t: start_t,
                    touch_x: touch_x,touch_y: touch_y,touch_t: touch_t,
                    target_x: target_x,target_y: target_y,th_target_t: th_target_t,
                    trace: trace};};

        this.trace=function(flag){
            var cur=trace;
            if (typeof flag === "undefined")
                trace=1;
            else if (typeof flag==="number")
                trace=flag;
            else if (flag)
                trace=2;
            else trace=0;
            return cur;};

        this.debug=function(){
            // jshint debug:true
            debugger;};
        
        if ((trace)||(traceall))
            fdjtLog("New TapHold(%s) for %o: %o opts %j, trace=%o/%o",
                    thid,elt,th,opts||false,trace,traceall);
        
        return this;}

    TapHold.clear=function(){
        if (traceall) fdjtLog("TapHold.clear()");
        cleared=fdjtET();};

    function traceTapHold(flag){
        if (typeof flag === "undefined")
            return traceall;
        else {
            var cur=traceall;
            if (typeof flag==="number")
                traceall=flag;
            else if (flag)
                traceall=default_opts.traceall||2;
            else {}
            return cur;}}
    TapHold.trace=traceTapHold;

    TapHold.default_opts=default_opts;

    return TapHold;})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/selecting.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* jshint browser: true */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));
if (!(fdjt.UI)) fdjt.UI={};

fdjt.TextSelect=fdjt.UI.Selecting=fdjt.UI.TextSelect=
    (function(){
        "use strict";
        var fdjtDOM=fdjt.DOM;
        var fdjtLog=fdjt.Log;
        var fdjtUI=fdjt.UI;
        var hasParent=fdjtDOM.hasParent;
        var stripIDs=fdjtDOM.stripIDs;        
        var getStyle=fdjtDOM.getStyle;
        var textify=fdjtDOM.textify;
        var hasClass=fdjtDOM.hasClass;
        var swapClass=fdjtDOM.swapClass;
        var dropClass=fdjtDOM.dropClass;

        var rAF=fdjtDOM.requestAnimationFrame;

        function position(elt,arr){
            if (arr.indexOf) return arr.indexOf(elt);
            else {
                var i=0, lim=arr.length;
                while (i<lim) {
                    if (arr[i]===elt) return i;
                    else i++;}
                return -1;}}

        var selectors={}; // Maps DOM ids to instances
        var alltapholds={}; // Maps DOM ids to taphold objects
        var serialnum=0;  // Tracks instances
        var traceall=0;

        function TextSelect(nodes,opts){
            if (!(this instanceof TextSelect))
                return new TextSelect(nodes,opts);
            else this.serial=++serialnum;
            if (typeof nodes==='string') {
                var elt=document.getElementById(nodes);
                if (!(elt)) return false;
                else this.nodes=nodes=[elt];}
            else if (nodes.nodeType) this.nodes=nodes=[nodes];
            else if (!(nodes.length)) return false;
            else this.nodes=nodes;
            var sel=this, trace=0;
            var orig=this.orig=[], wrapped=this.wrapped=[];
            var words=this.words=[], wrappers=this.wrappers=[];
            var tapholds=this.tapholds=[];
            if ((opts)&&(opts.hasOwnProperty("trace"))) {
                var trace_val=opts.trace;
                if (typeof trace_val === "number") trace=trace_val;
                else if (trace_val) trace=1;
                else trace=0;}
            this.traced=trace;
            var prefix=this.prefix="fdjtSel0"+this.serial;
            this.loupe=fdjtDOM("span.fdjtselectloupe");
            this.adjust=false; /* This will be 'start' or 'end' */
            selectors[prefix]=sel;
            var stripid=prefix.length+1;
            var k=0, n=nodes.length;
            while (k<n) {
                var node=nodes[k++];
                var style=getStyle(node);
                var wrapper=
                    ((style.display==='inline')?
                     (fdjtDOM("span.fdjtselecting")):
                     (fdjtDOM("div.fdjtselecting")));
                // Initialize the wrapper
                wrapper.id=prefix+"w"+k;
                wrapper.title=((opts)&&(opts.title))||
                    "Tap or hold/drag to move the ends of the text range";
                selectors[wrapper.id]=sel;
                wrappers.push(wrapper);
                var th=addHandlers(wrapper,sel,opts);
                alltapholds[wrapper.id]=th;
                tapholds.push(th);
                if ((trace)||(traceall))
                    fdjtLog("Created TapHold handler (#%d) for wrapper %s around %o",
                            th.serial,wrapper.id,node);
                // Replace the node with the wrapper and then update
                // the node (replacing words with spans) while it's
                // outside of the DOM for performance.
                node.parentNode.replaceChild(wrapper,node);
                orig.push(node); wrapped.push(wrapper);
                // Actually wrap the words in spans
                wrapText(node,orig,wrapped,words,prefix);
                // And put the node back into the DOM
                wrapper.appendChild(node);}
            // These track the state of the current selection
            //  for this instance
            this.start=false; this.end=false;
            this.min=-1; this.max=-1; this.n_words=0;
            this.onchange=((opts)&&(opts.onchange))||false;
            // This gets the word offset for a particular target
            this.wordnum=function wordnum(target){
                var id=false;
                while ((target)&&(target.nodeType!==1))
                    target=target.parentNode;
                if ((target)&&((id=target.id))&&
                    (target.tagName==="SPAN")&&
                    (id.search(prefix)===0))
                    return parseInt(id.slice(stripid),10);
                else return false;};
            
            this.startEvent=function startEvent(evt,holdmsecs){
                var target=fdjtUI.T(evt);
                if (traceall)
                    fdjtLog("startEvent %o, target=%o, wrappers=%o",
                            evt,target,wrappers);
                var j=0, n_wrappers=wrappers.length; while (j<n_wrappers) {
                    var wrapper=wrappers[j++];
                    if ((hasParent(wrapper,target))||
                        (hasParent(target,wrapper))) {
                        var taphold=alltapholds[wrapper.id];
                        if ((trace)||(traceall))
                            fdjtLog("Using TapHold handler @%d for wrapper %s (#%d)",
                                    j-1,wrapper.id,taphold.serial);
                        taphold.fakePress(evt,holdmsecs);
                        return;}}};

            return this;}

        TextSelect.prototype.toString=function(){
            var wrappers=this.wrappers; 
            var output="TextSelect(["+
                (this.min)+((this.adjust==="start")?("*"):(""))+","+
                (this.max)+((this.adjust==="end")?("*"):(""))+"],";
            
            var i=0, lim=wrappers.length;
            while (i<lim) {
                var id=wrappers[i].id;
                if (id) output=output+((i>0)?(","):(""))+
                    "'"+wrappers[i].id+"'";
                i++;}
            output=output+")";
            return output;};

        function wrapText(node,orig,wrapped,words,prefix){
            var i, lim;
            if (node.nodeType===3) {
                var text=node.nodeValue, span;
                /*
                // Skip wrapping non-inline whitespace
                if (((text.length===0)||(text.search(/\S/g)<0))) {
                    var parent=node.parentNode, pstyle=getStyle(parent);
                    var prev=node.prevSibling, next=node.nextSibling;
                    if (((prev)||(next))&& // ((pstyle.whiteSpace||wsprop)==='normal')
                        (pstyle.display!=='inline')&&(pstyle.display!=='table-cell')) {
                        var pdisplay=((prev)&&(getStyle(prev).display));
                        var ndisplay=((next)&&(getStyle(next).display));
                        if ((pdisplay!=='inline')&&(ndisplay!=='inline'))
                            return node;}}
                */
                var sliced=mergeSoftHyphens(text.split(/\b/)), wordspans=[];
                i=0; lim=sliced.length;
                while (i<lim) {
                    var word=sliced[i++];
                    if (word.length===0) continue;
                    else if ((word.search(/\S/)>=0)&&
                             (word.search(/\s/)>=0)) {
                        var scan=word;
                        while (scan.length) {
                            var space=scan.search(/\s/);
                            var notspace=scan.search(/\S/);
                            var split=((space<=0)?(notspace):
                                       (notspace<=0)?(space):
                                       (space<notspace)?(space):
                                       (notspace));
                            if (split<=0) split=scan.length;
                            if (split>0) {
                                var txt=scan.slice(0,split);
                                span=fdjtDOM("span.fdjtword",txt);
                                span.id=prefix+"_"+(words.length);
                                words.push(span);
                                wordspans.push(span);}
                            scan=scan.slice(split);}}
                    else {
                        span=fdjtDOM("span.fdjtword",word);
                        span.id=prefix+"_"+(words.length);
                        words.push(span);
                        wordspans.push(span);}}
                return fdjtDOM("span.fdjtselectwrap",wordspans);}
            else if (node.nodeType!==1) return node;
            else {
                var classname=node.className;
                if ((classname)&&(typeof classname === "string")&&
                    ((classname==='fdjtselectwrap')||
                     (node.className==="fdjtskiptext")||
                     (node.className.search(/\bfdjtskiptext\b/)>=0)))
                    return node;
                var style=getStyle(node);
                if ((style.position!=='')&&
                    (style.position!=='static'))
                    return node;
                var children=node.childNodes;
                if (!(children)) return node;
                else if (children.length===0) return node;
                else if (node.className==='fdjtselectwrap') return node;
                else {
                    i=0; lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        var wrap=wrapText(child,orig,wrapped,words,prefix);
                        if (child!==wrap) {
                            orig.push(child);
                            wrapped.push(wrap);
                            node.replaceChild(wrap,child);}}
                    return node;}}}

        function mergeSoftHyphens(vec){
            var i=0, lim=vec.length; var out=[], word=false;
            while (i<lim) {
                var wd=vec[i++];
                if (wd==='­') {
                    if (word) {
                        var nxt=vec[i];
                        if (nxt) {word=word+wd+nxt; i++;}
                        else word=word+wd;}
                    else word=wd;}
                else {
                    if (word) out.push(word);
                    word=wd;}}
            if (word) out.push(word);
            return out;}

        /* Selecting ranges */

        function selectWords(words,start,end){
            var i=start; while (i<=end)
                words[i++].className="fdjtselected";}
        function deselectWords(words,start,end){
            var i=start; while (i<=end)
                words[i++].className="fdjtword";}

        TextSelect.prototype.setRange=function(start,end){
            var trace=this.trace;
            if ((trace)||(traceall))
                fdjtLog("TextSelect.setRange %o %o for %o",start,end,this);
            if (!(start)) {
                if ((this.start)&&(this.end)) {
                    deselectWords(this.words,this.min,this.max);}
                this.start=this.end=false;
                this.min=this.max=-1;
                this.n_words=0;
                if (this.onchange) this.onchange();
                return;}
            var words=this.words;
            var min=this.wordnum(start), max=this.wordnum(end);
            if (max<min) {
                var tmp=start; start=end; end=tmp;
                tmp=min; min=max; max=tmp;}
            if (!(this.start)) {
                // First selection
                selectWords(words,min,max);
                words[max].className='fdjtselectend';
                words[min].className='fdjtselectstart';}
            else if ((this.start===start)&&(this.end===end)) return;
            else {
                // Minimize the effort for a change in selection
                var cur_min=this.wordnum(this.start);
                var cur_max=this.wordnum(this.end);
                if ((min>cur_max)||(max<cur_min)) {
                    deselectWords(words,cur_min,cur_max);
                    selectWords(words,min,max);}
                else {
                    // Overlapping, just do the difference
                    if (min<cur_min) selectWords(words,min,cur_min);
                    else if (min>cur_min) deselectWords(words,cur_min,min);
                    else {}
                    if (max>cur_max) selectWords(words,cur_max,max);
                    else if (max<cur_max) deselectWords(words,max,cur_max);
                    else {}}
                words[max].className="fdjtselectend";
                words[min].className="fdjtselectstart";}
            this.min=min; this.max=max;
            this.start=start; this.end=end;
            this.n_words=(max-min)+1;
            if (this.onchange) this.onchange();};

        /* Handler support */
        
        function overWord(word,tapped,sel){
            var id=false;
            while ((word)&&(word.nodeType!==1)) word=word.parentNode;
            if (hasParent(word,".fdjtselectloupe"))
                return;
            if ((!(sel))&&(word)&&((id=word.id))&&
                (word.tagName==='SPAN')&&
                (id.search("fdjtSel")===0)) {
                var split=id.indexOf("_");
                if (split) sel=selectors[id.slice(0,split)];}
            if (!(sel)) {
                var container=word; while (container) {
                    if ((container.className)&&(container.id)&&
                        (typeof container.className === "string")&&
                        (container.className.search(/\bfdjtselecting\b/)>=0))
                        break;
                    else container=container.parentNode;}
                if (!(container)) return false;
                else sel=selectors[container.id];}
            if (!(sel)) return false;
            if ((traceall)||(sel.traced))
                fdjtLog("overWord %o, sel=%o, tapped=%o, adjust=%o, anchor=%o",
                        word,sel,tapped,sel.adjust,sel.anchor);
            if (tapped) useWord(word,sel,true);
            else if (sel.word) useWord(word,sel);
            else if ((hasClass(word,"fdjtselectstart"))||
                     (hasClass(word,"fdjtselectend"))) {
                if (sel.timeout) {
                    clearTimeout(sel.timeout); sel.timeout=false;}
                sel.pending=false; sel.word=word; useWord(word,sel);}
            else if (sel.pending===word) return true;
            else if (!(word.offsetParent)) return false;
            else {
                if (sel.timeout) clearTimeout(sel.timeout);
                updateLoupe(word,sel,false);
                sel.word=false; sel.pending=word;
                sel.timeout=setTimeout(function(){
                    if (sel.pending!==word) return;
                    if (sel.timeout) clearTimeout(sel.timeout);
                    sel.word=word; sel.pending=false;
                    useWord(word,sel);},
                                                         100);}
            return true;}

        function useWord(word,sel,tapped){
            var start=sel.start, end=sel.end;
            if (!(word.offsetParent)) return;
            if (!(sel.start)) {
                var initial=initSelect(word);
                start=initial.start; end=initial.end;}
            else if (sel.anchor) {
                start=sel.anchor; end=word;}
            else if (sel.start===sel.end) {
                // Just one word is selected, so use the touched word
                // as the 'end' and let setRange sort out the correct
                // order
                start=sel.start; end=word;}
            else {
                var off=sel.wordnum(word);
                // Check that you're consistent with the end you're moving
                if ((sel.adjust==='start')&&(off>sel.max)) return;
                if ((sel.adjust==='end')&&(off<sel.min)) return;
                // Figure out whether you're moving the beginning or end
                if (sel.adjust==='start') start=word;
                else if (sel.adjust==='end') end=word;
                else if (start===word) sel.setAdjust('start');
                else if (end===word) sel.setAdjust('end');
                else if (off<=sel.min) {
                    start=word; sel.setAdjust('start');}
                else if (off>=sel.max) {
                    end=word; sel.setAdjust('end');}
                else if ((off-sel.min)<6) {
                    start=word; sel.setAdjust('start');}
                else if ((sel.max-off)<6) {
                    end=word; sel.setAdjust('end');}
                else if (tapped) return;
                else if ((off-sel.min)>((sel.max-sel.min)/2)) {
                    end=word; sel.setAdjust('end');}
                else {
                    start=word; sel.setAdjust('start');}}
            rAF(function(){
                sel.setRange(start,end);
                if (sel.loupe) updateLoupe(word,sel,tapped);});}

        function nodeSearch(node,pat){
            if (node.nodeType===3) {
                return (node.nodeValue.search(pat)>=0);}
            else if (node.nodeType===1) {
                var children=node.childNodes;
                var i=0, lim=((children)?(children.length):(0));
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===3) {
                        if (child.nodeValue.search(pat)>=0) 
                            return child;}
                    else if (child.nodeType===1) {
                        if (nodeSearch(child,pat)) return child;}
                    else {}}
                return false;}
            else return false;}

        function initSelect(word){
            var begin=word, end=word, scan, last;
            if (!(nodeSearch(word,/"\(\[\{/))) {
                last=begin; scan=begin.previousSibling;
                while (scan) {
                    if ((scan.nodeType!==1)||
                        (!(hasClass(scan,"fdjtword")))) {
                        scan=scan.previousSibling; continue;}
                    if (nodeSearch(scan,/["\(\[\{]/)) {
                        begin=scan; break;}
                    else if (nodeSearch(scan,/[.;!?]/)) {
                        begin=last; break;}
                    else {last=scan; scan=scan.previousSibling;}}
                if (!(scan)) begin=last;}
            if (nodeSearch(word,/[.;!?]/)) end=word;
            else {
                last=end; scan=end.nextSibling;
                while (scan) {
                    if ((scan.nodeType!==1)||
                        (!(hasClass(scan,"fdjtword")))) {
                        scan=scan.nextSibling; continue;}
                    if (nodeSearch(scan,/[".;!?]/)) {
                        end=scan; break;}
                    else {
                        last=scan; scan=scan.nextSibling;}}
                if (!(scan)) end=last;}
            return {start: begin,end: end};}
        
        function updateLoupe(word,sel,tapped){
            var parent=word.parentNode, loupe=sel.loupe;
            if (sel.loupe_timeout) {
                    clearTimeout(sel.loupe_timeout);
                    sel.loupe_timeout=false;}
                if (!(word.offsetParent)) return;
                var block=word.parentNode; while (block) {
                    if (getStyle(block).display!=='inline') break;
                    else block=block.parentNode;}
                if ((traceall)||(sel.traced))
                    fdjtLog("updateLoupe(%d) over %o for %o%s",
                            sel.serial,word,sel,
                            ((tapped)?(" (tapped)"):("")));
                var context=gatherContext(word,5,5,block);
                var geom=fdjtDOM.getGeometry(word,word.offsetParent);
                var cwidth=word.offsetParent.offsetWidth;
                loupe.innerHTML=""; loupe.style.display="none";
                fdjtDOM.append(loupe,context.words);
                parent.insertBefore(loupe,word);
                if (geom.left<(cwidth/2)) {
                    loupe.style.float="left";
                    loupe.style.left=(geom.left-(1.5*context.wordstart))+"px";
                    loupe.style.right="";}
                else {
                    loupe.style.float="right";
                    loupe.style.right=(cwidth-geom.right)-
                        (1.5*(context.width-context.wordend))+"px";
                    loupe.style.left="";}
                loupe.style.display="";
                if (tapped) setTimeout(1000,function(){
                    sel.loupe.display='none';});}

            var getGeometry=fdjtDOM.getGeometry;

            function gatherContext(node,back,forward,parent){
                var id=node.id, parsed=(id)&&/(fdjtSel\d+_)(\d+)/.exec(id);
                if ((!(parsed))||(parsed.length!==3)) return;
                var prefix=parsed[1], count=parseInt(parsed[2],10);
                var start=count-back, end=count+forward; if (start<0) start=0;
                var context=[], width=0, wordstart, wordend;
                var start_geom=getGeometry(node);
                var i=start; while (i<end) {
                    var elt=document.getElementById(prefix+i);
                    if ((!(elt))||((parent)&&(!(hasParent(elt,parent))))) {
                        i++; continue;}
                    else if (elt.nodeType===1) {
                        var geom=getGeometry(elt);
                        if ((geom.bottom<start_geom.top)||
                            (geom.top>=start_geom.bottom)) {
                            i++; continue;}
                        var clone=elt.cloneNode(true); stripIDs(clone);
                        if (i<count) width=width+elt.offsetWidth;
                        else if (i===count) {
                            wordstart=width;
                            width=wordend=width+elt.offsetWidth;}
                        else width=width+elt.offsetWidth;
                        if (elt===node) fdjtDOM.addClass(clone,"fdjtselected");
                        context.push(clone);}
                    else context.push(elt.cloneNode(true));
                    i++;}
                return {words: context, width: width,
                        wordstart: wordstart, wordend: wordend};}

            function getSelector(word){
                var id=false;
                if ((word)&&((id=word.id))&&
                    (word.tagName==='SPAN')&&
                    (id.search("fdjtSel")===0)) {
                    var split=id.indexOf("_");
                    if (split)
                        return selectors[id.slice(0,split)]||false;
                    else return false;}
                else return false;}
            TextSelect.getSelector=getSelector;

            // Getting the selection text
            // This tries to be consistent with textify functions in fdjtDOM
            TextSelect.prototype.setString=function(string){
                var wrappers=this.wrappers;
                var whole=((wrappers.length===1)&&(wrappers[0]));
                if (!(whole)) {
                    whole=fdjtDOM("div"); 
                    var i=0, lim=wrappers.length;
                    while (i<lim) {
                        var wrapper=wrappers[i++];
                        whole.appendChild(wrapper.cloneNode(true));}}
                var found=fdjtDOM.findMatches(whole,string,0,1);
                if ((!(found))||(found.length===0)) return;
                else found=found[0];
                var start=found.startContainer, end=found.endContainer;
                while ((start)&&(start.nodeType!==1)) start=start.parentNode;
                while ((end)&&(end.nodeType!==1)) end=end.parentNode;
                if ((start)&&(end)&&(start.id)&&(end.id)&&
                    (start.id.search(this.prefix)===0)&&
                    (end.id.search(this.prefix)===0)) {
                    start=document.getElementById(start.id);
                    end=document.getElementById(end.id);}
                else return;
                if ((start)&&(end)) this.setRange(start,end);};

            TextSelect.prototype.getString=function(start,end,rawtext){
                if (!(start)) start=this.start; if (!(end)) end=this.end;
                var wrappers=this.wrappers; 
                var combine=[]; var prefix=this.prefix; var wpos=-1;
                var scan=start; while (scan) {
                    if (rawtext) {}
                    else if (scan.nodeType===1) {
                        var style=getStyle(scan);
                        if ((style.position==='static')&&
                            (style.display!=='inline')&&
                            (style.display!=='none'))
                            combine.push("\n");}
                    if ((scan.nodeType===1)&&(scan.tagName==='SPAN')&&
                        (scan.id)&&(scan.id.search(prefix)===0)) {
                        var txt=scan.innerText||textify(scan);
                        combine.push(txt.replace("­",""));
                        if (scan===end) break;}
                    if ((scan.firstChild)&&
                        (scan.className!=="fdjtselectloupe")&&
                        (scan.firstChild.nodeType!==3))
                        scan=scan.firstChild;
                    else if (scan.nextSibling) scan=scan.nextSibling;
                    else {
                        while (scan) {
                            if ((wpos=position(scan,wrappers))>=0) break;
                            else if (scan.nextSibling) {
                                scan=scan.nextSibling; break;}
                            else scan=scan.parentNode;}
                        if (wpos>=0) {
                            if ((wpos+1)<wrappers.length)
                                scan=wrappers[wpos+1];}}
                    if (!(scan)) break;}
                return combine.join("");};

            TextSelect.prototype.getOffset=function(under){
                if (!(this.start)) return false;
                var first_word=this.words[0]; 
                if (under) {
                    var words=this.words; var i=0, lim=words.length;
                    if (!((hasParent(this.start,under))&&
                          (hasParent(this.end,under))))
                        return false;
                    while ((i<lim)&&(!(hasParent(first_word,under))))
                        first_word=words[i++];}
                var selected=this.getString(false,false,true);
                var preselected=this.getString(first_word,this.end,true);
                return preselected.length-selected.length;};
            
            TextSelect.prototype.getInfo=function(under){
                var trace=this.traced;
                if (!(this.start)) return false;
                var selected=this.getString();
                var first_word=this.words[0]; 
                if (under) {
                    var words=this.words; var i=0, lim=words.length;
                    if (!((hasParent(this.start,under))&&
                          (hasParent(this.end,under))))
                        return false;
                    while ((i<lim)&&(!(hasParent(first_word,under))))
                        first_word=words[i++];}
                var rawselect=this.getString(false,false,true);
                var preselected=this.getString(first_word,this.end,true);
                if ((trace)||(traceall)) 
                    fdjtLog("GetInfo %o: start=%o, end=%o, off=%o, string=%o",
                            this,this.start,this.end,
                            preselected.length-rawselect.length,
                            selected);
                return { start: this.start, end: this.end,
                         off: preselected.length-rawselect.length,
                         string: selected};};
            
            TextSelect.prototype.setAdjust=function(val){
                var trace=this.traced;
                if ((traceall)||(trace))
                    fdjtLog("TextSelect.setAdjust %o for %o",val,this);
                if (val) {
                    this.adjust=val;
                    swapClass(this.nodes,/\b(fdjtadjuststart|fdjtadjustend)\b/,
                              "fdjtadjust"+val);}
                else {
                    this.adjust=false;
                    dropClass(this.nodes,/\b(fdjtadjuststart|fdjtadjustend)\b/);}};


            // Life span functions

            TextSelect.prototype.clear=function(){
                var wrappers=this.wrappers;
                var orig=this.orig, wrapped=this.wrapped;
                if (!(orig)) return; // already cleared
                var i=orig.length-1;
                while (i>=0) {
                    var o=orig[i], w=wrapped[i]; i--;
                    w.parentNode.replaceChild(o,w);}
                var j=0, lim=wrappers.length;
                while (j<lim) {
                    var wrapper=wrappers[j++];
                    delete alltapholds[wrapper.id];
                    delete selectors[wrapper.id];}
                if (this.onclear) {
                    var onclear=this.onclear; this.onclear=false;
                    if (!(Array.isArray(onclear))) onclear=[onclear];
                    i=0; lim=onclear.length; while (i<lim) {
                        onclear[i++]();}}
                delete selectors[this.prefix];
                delete this.wrapped; delete this.orig;
                delete this.wrappers; delete this.nodes;
                delete this.words; delete this.wrappers;
                delete this.start; delete this.end;};
            
            // Handlers

            function hold_handler(evt){
                evt=evt||window.event;
                var target=fdjtUI.T(evt);
                while ((target)&&(target.nodeType!==1))
                    target=target.parentNode;
                while (target) {
                    if ((target)&&(target.id)&&(target.tagName==='SPAN')&&
                        (target.id.search("fdjtSel")===0)) {
                        var sel=getSelector(target);
                        if ((sel)&&(!(sel.anchor))&&(!(sel.start)))
                            sel.anchor=target;
                        if ((traceall)||((sel)&&(sel.traced)))
                            fdjtLog("TextSelect/hold %o t=%o sel=%o",
                                    evt,target,sel);
                        overWord(target,false,sel);
                        fdjtUI.cancel(evt);
                        break;}
                    else if (target.nodeType===1) target=target.parentNode;
                    else break;}}
            TextSelect.hold_handler=hold_handler;
            TextSelect.handler=hold_handler;
            function tap_handler(evt){
                evt=evt||window.event;
                var target=fdjtUI.T(evt);
                while ((target)&&(target.nodeType!==1))
                    target=target.parentNode;
                while (target) {
                    if ((target)&&(target.id)&&(target.tagName==='SPAN')&&
                        (target.id.search("fdjtSel")===0)) {
                        var sel=getSelector(target);
                        if ((traceall)||((sel)&&(sel.traced)))
                            fdjtLog("TextSelect/tap %o t=%o sel=%o",evt,target,sel);
                        // Tapping on a single word selection clears it
                        if (sel.n_words===1) sel.setRange(false);
                        else if ((target.className==="fdjtselectstart")||
                                 (target.className==="fdjtselectend")) {
                            // Tapping on a start or end selects just that word
                            fdjtUI.cancel(evt);
                            sel.setRange(target,target);}
                        // Otherwise, call overWord, which makes the word the
                        //  beginning or end of the selection
                        else if (overWord(target,true,sel)) {
                            if (target.className==="fdjtselectstart")
                                sel.adjust="start";
                            else if (target.className==="fdjtselectend")
                                sel.adjust="end";
                            else sel.adjust=false;
                            fdjtUI.cancel(evt);}
                        else if (sel) sel.adjust=false;
                        break;}
                    else if (target.nodeType===1) target=target.parentNode;
                    else break;}}
            TextSelect.tap_handler=tap_handler;
            function release_handler(evt,sel){
                evt=evt||window.event;
                var target=fdjtUI.T(evt);
                if ((traceall)||((sel)&&(sel.traced)))
                    fdjtLog("TextSelect/release %o t=%o sel=%o",evt,target,sel);
                if (sel) {
                    sel.anchor=false; sel.word=false; sel.pending=false;
                    if (sel.timeout) {
                        clearTimeout(sel.timeout); sel.timeout=false;}
                    sel.setAdjust(false);
                    if (sel.loupe) sel.loupe.style.display='none';}}
            function slip_handler(evt,sel){
                evt=evt||window.event;
                var target=fdjtUI.T(evt);
                if ((traceall)||((sel)&&(sel.traced)))
                    fdjtLog("TextSelect/slip %o t=%o sel=%o",evt,target,sel);
                if (sel) {
                    if (sel.loupe) sel.loupe_timeout=
                        setTimeout(function(){
                            sel.loupe_timeout=false;
                            sel.loupe.style.display='none';},2000);}}
            TextSelect.release_handler=release_handler;
            function get_release_handler(sel,also){
                return function(evt){
                    release_handler(evt,sel);
                    if (also) also(evt,sel);};}
            function get_slip_handler(sel,also){
                return function(evt){
                    slip_handler(evt,sel);
                    if (also) also(evt,sel);};}
            
            function addHandlers(container,sel,opts){
                // We always override the default action when selecting
                if (!(opts)) opts={};
                opts.override=true;
                opts.touchable=
                    ".fdjtword,.fdjtselected,.fdjtselectstart,.fdjtselectend";
                var taphold=new fdjtUI.TapHold(container,opts);
                fdjtDOM.addListener(container,"tap",
                                    ((opts)&&(opts.ontap))||
                                    tap_handler);
                fdjtDOM.addListener(container,"hold",
                                    ((opts)&&(opts.onhold))||
                                    hold_handler);
                fdjtDOM.addListener(
                    container,"release",
                    get_release_handler(sel,opts.onrelease||false));
                fdjtDOM.addListener(
                    container,"slip",
                    get_slip_handler(sel,opts.onslip||false));
                return taphold;}

            TextSelect.trace=function(flag,thtoo){
                if (typeof flag === "undefined") return traceall;
                else if (typeof flag === "number")
                    traceall=flag;
                else if (flag) traceall=1;
                else traceall=0;
                if (thtoo) fdjt.TapHold.trace(thtoo);};
            
            // Return the constructor
            return TextSelect;})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file was created from several component files and is
   part of the FDJT web toolkit (www.fdjt.org)

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   The copyright notice of the individual files are all prefixed by
   a copyright notice of the form "Copyright (C) ...".

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/
/* globals window, global */

(function(){
    "use strict";
    fdjt.useGlobals=fdjt.dbg=function(cxt){
        var names=["fdjtDOM","fdjtUI","fdjtTime","fdjtString","fdjtState",
                   "fdjtLog","fdjtHash","fdjtAjax","fdjtAsync","fdjtInit",
                   "fdjtDialog","fdjtTemplate","fdjtID","fdjtRef",
                   "fdjtTapHold","fdjtSelecting","fdjtTextIndex","fdjtRefDB",
                   "TextIndex","RefDB","CodexLayout","pageShow"];
        if (!(cxt)) cxt=window;
        if (!(cxt)) {
            fdjt.Log("Nowhere to put globals");
            return;}
        var i=0, n=names.length; while (i<n) {
            var name=names[i++];
            var fname=((name.search("fdjt")===0)?(name.slice(4)):(name));
            if ((fdjt[fname])&&(!(cxt[name]))) {
                fdjt.Log("%s = fdjt.%s",name,fname);
                cxt[name]=fdjt[fname];}}
        return n;};
    /*
    window.addEventListener("load",function(){
        var root=(typeof global !== "undefined")?(global):
            (typeof window !== "undefined")?(window):
            (false);
        fdjt.useGlobals(root);});
    */
})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ##################### knodules/knodules.js ####################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file provides a Javascript/ECMAScript of KNODULES, 
   a lightweight knowledge representation facility.

   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library is built on the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification and redistribution of this program is permitted
   under the GNU General Public License (GPL) Version 2:

   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@biz.beingmeta.com

   Enjoy!

*/

//var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

var Knodule=(function(){
    "use strict";
    var fdjtString=fdjt.String;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var RefDB=fdjt.RefDB;
    var Ref=fdjt.Ref;
    var warn=fdjtLog.warn;

    var ObjectMap=RefDB.ObjectMap;

    var trace_parsing=0;

    var lang_pat=/^(([A-Za-z]{2,3}\$)|([A-Za-z]{2,3}_[A-Za-z]{2,3}\$))/;

    function Knodule(id,inits) {
        // Using as a prototype
        if (arguments.length===0) return this;
        if (!(inits)) inits={};
        if (inits.indices)
            inits.indices=inits.indices.concat(
                ["terms","hooks","genls","specls","allgenls"]);
        else inits.indices=["terms","hooks","genls","specls","allgenls"];
        var lang=inits.language;
        var knodule=RefDB.call(this,id,inits);
        if ((lang)&&(knodule.language!==lang))
            throw { error: "language mismatch" };
        // The default language for this knodule
        if ((inits.language)&&(knodule.language)&&
            (inits.language!==knodule.language))
            throw { error: "language mismatch" };
        else if (inits.language)
            knodule.language=inits.language;
        else knodule.language='EN';
        // Mapping dterms (univocal references) to KNode objects
        // (many-to-one).  This redundantly combines refs and altrefs
        // from the underlying ref objects.
        knodule.dterms={};
        // A vector of all dterms local to this knodule
        knodule.alldterms=[];
        // Prime (important) dterms
        knodule.prime=[]; knodule.primescores={};
        // Whether to validate asserted relations
        knodule.validate=true;
        // Whether the knodule is 'strict'
        // (requiring dterm definitions for all references)
        knodule.strict=false;
        // Whether the knodule is 'finished' (all references declared)
        knodule.finished=false;
        // Terms which are assumed unique.  This is used in non-strict
        // knodules to catch terms that become ambiguous.
        knodule.assumed_dterms=[];
        // Mapping external dterms to their knodes
        knodule.xdterms={};
        // A vector of all foreign knode references
        knodule.allxdterms=[];
        // Inverted index for genls in particular (useful for
        // faster search, inferences, etc)
        knodule.allwaysIndex=new ObjectMap();
        // This maps external OIDs to knodes
        knodule.oidmap={};
        // DRULES (disambiguation rules)
        knodule.drules={};
        return knodule;}
    Knodule.prototype=new RefDB();

    Knodule.prototype.toString=function(){
        return "Knodule("+this.name+")";};

    var stdcap=fdjtString.stdcap;

    function KNode(string,knodule,lang){
        if (arguments.length===0) return this;
        var weak=false; var prime=
            ((string[0]==='*')&&(string.search(/[^*]/)));
        var newprime=false, knode=this, notword=false;
        if (string[0]==='~') {weak=true; string=string.slice(1);}
        else if (prime) {
            string=string.slice(prime);
            if (!(knodule.primescores[string])) {
                if (prime>(knodule.primescores[string]))
                    knodule.primescores[string]=prime;
                newprime=true;}}
        var atpos=string.indexOf('@');
        if ((atpos===0)||((atpos===1)&&(string[0]===':'))) notword=true;
        else if ((atpos>2)&&(string[atpos-1]!=='\\')) {
            var domain=string.slice(atpos+1);
            if ((domain!==knodule.name)&&
                (knodule.aliases.indexOf(domain)<0))
                warn("Reference %s in %s is being handled by %s",
                     string,domain,knodule);
            string=string.slice(0,atpos);}
        if (notword) {}
        else if (string.search(lang_pat)===0) {
            var dollar=string.indexOf('$');
            lang=string.slice(0,dollar).toUpperCase();
            string=string.slice(dollar+1);}
        else if (lang) lang=lang.toUpperCase();
        else lang=knodule.language||"EN";
        // Normalize capitalization
        string=stdcap(string);
        var refterm=(lang===knodule.language)?(string):lang+"$"+string;
        knode=Ref.call(this,refterm,knodule);
        if (knode===this) {
            if (!(knode.dterm)) knode.dterm=refterm;
            knode.add('dterms',refterm);
            if (!(knodule.dterms.hasOwnProperty(refterm))) {
                knodule.dterms[refterm]=knode;
                knodule.alldterms.push(refterm);}
            knode.allways=fdjt.Set();
            if (lang) knode.add(lang,string);
            knode._live=fdjtTime();}
        if (weak) knode.weak=true;
        if (prime) knode.prime=prime;
        if ((prime)&&(newprime)) knodule.prime.push(knode);
        if ((lang)&&(lang!==knodule.language)) knode.language=lang;
        return knode;}
    KNode.prototype=new RefDB.Ref();
    Knodule.refclass=Knodule.prototype.refclass=KNode;

    Knodule.KNode=KNode;
    Knodule.Knode=KNode;
    Knodule.prototype.KNode=Knodule.prototype.Knode=function(arg,inits) {
        if (arg instanceof KNode) {
            if (arg._db===this)
                // Should this do some kind of import?
                return arg;
            else return arg;}
        else return new KNode(arg,this,inits);};
    Knodule.prototype.cons=function(string,lang) {
        return new KNode(string,this,lang);};
    Knodule.prototype.probe=function(string,langid) {
        var refs=this.refs, aliases=this.aliases;
        // Normalize string for knodules
        string=stdcap(string);
        if ((this.language===langid)||(!(langid)))
            return ((refs.hasOwnProperty(string))&&(refs[string]))||
            ((aliases.hasOwnProperty(string))&&(aliases[string]))||
            false;
        else string=langid.toUpperCase()+"$"+string;
        return this.dterms[langid+"$"+string]||false;};
    
    KNode.prototype.add=function(prop,val){
        var ai=this._db.allwaysIndex;
        if ((Ref.prototype.add.call(this,prop,val))&&
            (prop==='genls')) {
            this.allways.push(val);
            this.allways=RefDB.merge(this.allways,val.allways);
            var allways=this.allways, i=0, lim=allways.length;
            while (i<lim) ai.add(allways[i++],this);
            var examples=ai.get(this);
            if (examples) {
                var e=0, n_examples=examples.length;
                while (e<n_examples) {
                    var example=examples[e++];
                    example.allways=RefDB.merge(example.allways,this.allways);
                    var j=0, jlim=allways.length;
                    while (j<jlim) ai.add(allways[j++],example);}}
            return true;}
        else return false;};
    KNode.prototype.addTerm=function(val,field,inlang){
        if ((typeof val === 'string')&&(val.search(lang_pat)===0)) {
            var dollar=val.indexOf('$');
            var langspec=val.slice(0,dollar).toUpperCase();
            var term=val.slice(dollar+1);
            if (langspec===this._db.language) {
                if (field) this.add(field,term);
                else {
                    this.add(langspec,term);
                    this.add('terms',term);}}
            else if (field)
                this.add(field,langspec+"$"+term);
            else {
                this.add(langspec,term);
                this.add('terms',val);}}
        else if (inlang) {
            inlang=inlang.toUpperCase();
            if (inlang===this._db.language) {
                if (field) this.add(field,val);
                else this.add('terms',val);}
            else if (field) 
                this.add(field,inlang+"$"+val);
            else this.add('terms',inlang+"$"+val);}
        else if (field)
            this.add(field,val);
        else {
            this.add(this._db.language,val);
            this.add('terms',val);}};
    KNode.prototype.tagString=function(kno) {
        if (this.oid) return this.oid;
        else if (this.uuid) return this.uuid;
        else if (this._qid) return this._qid;
        if (!(kno)) kno=Knodule.current||false;
        if (kno===this._db) return this._id;
        else if (this._db.absrefs) return this._id;
        else if (this._domain)
            return this._id+"@"+this._domain;
        else return this._id+"@"+this._db.name;};
    
    KNode.prototype.toPlaintext=function() {
        var result="";
        var variants=this[this._db.language||'EN']; var n=0;
        if (typeof variants==="string") variants=[variants];
        var i=0; while (i<variants.length) {
            result=result+((n>0)?"|":"")+variants[i++]; n++;}
        var genls=this.genls;
        if (typeof genls==="string") genls=[genls];
        if ((genls)&&(genls.length)) {
            i=0; while (i<genls.length) {
                result=result+((n>0)?"|^":"^")+genls[i++].dterm; n++;}}
        var specls=this.specls;
        if (typeof specls==="string") specls=[specls];
        if ((specls)&&(specls.length)) {
            i=0; while (i<specls.length) {
                result=result+((n>0)?"|_":"_")+specls[i++].dterm; n++;}}
        return result;};

    function findBreak(string,brk,start) {
        var pos=string.indexOf(brk,start||0);
        while (pos>0)
            if (string[pos-1]!=="\\")
                return pos;
        else pos=string.indexOf(brk,pos+1);
        return pos;}

    var segment=fdjtString.segment;

    /* Processing the PLAINTEXT microformat */
    Knodule.prototype.handleClause=function handleClause(clause,subject) {
        var object=false, role=false, value=false;
        if (clause.indexOf('\\')>=0) clause=fdjtString.unEscape(clause);
        if (trace_parsing>2)
            fdjtLog("Handling clause '%s' for %o",clause,subject);
        if ((clause.length===0)||(clause.search(/[^\n\t ]/g)<0))
            return;
        switch (clause[0]) {
        case '^':
            if (clause[1]==='~') 
                subject.add('sometimes',this.KNode(clause.slice(2)));
            else if (clause[2]==='*') 
                subject.add('commonly',this.KNode(clause.slice(2)));
            else {
                var pstart=findBreak(clause,"(");
                if (pstart>0) {
                    var pend=findBreak(clause,")",pstart);
                    if (pend<0) {
                        fdjtLog.warn(
                            "Invalid Knodule clause '%s' for %o (%s)",
                            clause,subject,subject.dterm);}
                    else {
                        role=this.KNode(clause.slice(1,pstart));
                        object=this.KNode(clause.slice(pstart+1,pend));
                        object.add(role.dterm,subject);
                        subject.add('genls',role);}}
                else subject.add('genls',this.KNode(clause.slice(1)));}
            break;
        case '_': {
            object=this.KNode(clause.slice(1));
            subject.add('examples',object);
            object.add('genls',subject);}
            break;
        case '-':
            subject.add('never',this.KNode(clause.slice(1)));
            break;
        case '&': {
            value=clause.slice((clause[1]==="-") ? (2) : (1));
            var assoc=this.KNode(value);
            if (clause[1]==="-")
                subject.add('antiassocs',assoc);
            else subject.add('assocs',assoc);}
            break;
        case '@': 
            if (clause[1]==="#") 
                subject.add('tags',clause.slice(2));
            else subject.add('uri',clause.slice(1));
            break;
        case '=':
            if (clause[1]==='@')
                subject.oid=clause.slice(1);
            else if (clause[1]==='*')
                subject.add('equiv',this.KNode(clause.slice(2)));
            else if (clause[1]==='~')
                subject.add('kinda',this.KNode(clause.slice(2)));
            else if (clause[1]==='=')
                subject.add('identical',this.KNode(clause.slice(1)));
            else {
                var term=clause.slice(1), db=subject._db;
                if (!(db.dterms.hasOwnProperty(term))) {
                    subject.add('dterms',term);
                    db.alldterms.push(term);
                    db.dterms[term]=subject;}}
            break;
        case '+': {
            if (clause[1]==="*") {
                subject.gloss=clause.slice(2);
                subject.addTerm(subject.gloss,'glosses');}
            else if (clause[1]==="~") {
                subject.gloss=clause.slice(2);
                subject.addTerm(subject.gloss,'glosses');}
            else {
                subject.gloss=clause.slice(1);
                subject.addTerm(subject.gloss,"glosses");}}
            break;
        case '%': {
            var mirror=this.KNode(clause.slice(1)), omirror;
            if (subject.mirror===mirror) break;
            else {
                omirror=subject.mirror;
                fdjtLog.warn("Inconsistent mirrors for %s: +%s and -%s",
                             subject,mirror,omirror);
                omirror.mirror=false;}
            if (mirror.mirror) {
                var oinvmirror=mirror.mirror;
                fdjtLog.warn("Inconsistent mirrors for %s: +%s and -%s",
                             mirror,subject,oinvmirror);
                omirror.mirror=false;}
            subject.mirror=mirror; mirror.mirror=subject;}
            break;
        case '.': {
            var brk=findBreak(clause,'=');
            if (!(brk))
                throw {name: 'InvalidClause', irritant: clause};
            role=this.KNode(clause.slice(1,brk));
            object=this.KNode(clause.slice(brk+1));
            subject.add(role.dterm,object);
            object.add('genls',role);}
            break;
        case '~': {
            var hook=clause.slice(1);
            subject.addTerm(hook,'hooks');}
            break;
        case ':': {
            var equals=findBreak(clause,'=');
            if (equals>0) {
                var field=clause.slice(1,equals);
                var multi=(clause[equals+1]==='+');
                value=((multi)?(clause.slice(equals+2)):
                       (clause.slice(equals+1)));
                if (value[0]==='\\') value=value.slice(1);
                else if (/\d/.exec(value[0])) {
                    var number=parseFloat(value);
                    if ((typeof number === "number")&&((number)||(number===0)))
                        value=number;}
                else {}
                if (multi) subject.add(field,value);
                else subject.store(field,value);}
            subject.add('flags',clause.slice(1));}
            break;
        default: {
            var eqbrk=findBreak(clause,'=');
            if (eqbrk>0) {
                role=this.KNode(clause.slice(0,eqbrk));
                object=this.KNode(clause.slice(eqbrk+1));
                subject.add(role.dterm,object);
                object.add('genls',role);}
            else subject.addTerm(clause);}}
        return subject;};

    function getSubject(knodule,clauses){
        var ref=stdcap(clauses[0]);
        var probe=knodule.probe(ref);
        if (probe) return probe;
        else {
            var i=1, lim=clauses.length; while (i<lim) {
                var clause=clauses[i++];
                if (clause[0]==='=') {
                    probe=knodule.probe(stdcap(clause.slice(1)));
                    if (probe) return probe;}}
            return knodule.KNode(clauses[0]);}}

    Knodule.prototype.handleSubjectEntry=function handleSubjectEntry(entry){
        var clauses=segment(entry,/[|]/g);
        var subject=getSubject(this,clauses);
        if (this.trace_parsing>2)
            fdjtLog("Processing subject entry %s %o %o",
                    entry,subject,clauses);
        var i=1; while (i<clauses.length)
            this.handleClause(clauses[i++],subject);
        if (this.trace_parsing>2)
            fdjtLog("Processed subject entry %o",subject);
        return subject;};

    Knodule.prototype.handleEntry=function handleEntry(entry){
        entry=entry.trim();
        if (entry.length===0) return false;
        var starpower=entry.search(/[^*]/);
        if (starpower>0) entry=entry.slice(starpower);
        var bar=fdjtString.findSplit(entry,'|');
        var atsign=fdjtString.findSplit(entry,'@');
        var subject;
        if ((atsign>0) && ((bar<0)||(atsign<bar))) {
            // This is a foreign dterm reference (+def), e.g.
            //  dog@beingmeta.com|doggy|^mammal
            var term=entry.slice(0,atsign);
            var knostring=((bar<0) ? (entry.slice(atsign+1)) :
                           (entry.slice(atsign+1,bar)));
            var knodule=new Knodule(knostring);
            if (knodule instanceof Knodule)
                subject=((bar<0)?(knodule.KNode(term)):
                         (knodule.handleEntry(term+entry.slice(bar))));
            else {
                warn("Resolved %s to non-knodule %o",entry,knodule);
                subject=knodule.ref(term);}}
        else subject=this.handleSubjectEntry(entry);
        if (starpower) {
            var id=subject._id;
            var prime=this.prime; var scores=this.primescores;
            var score=scores[id];
            if (score) {
                if (starpower>score) {
                    scores[id]=starpower;
                    subject.prime=starpower;}}
            else {
                prime.push(id);
                scores[id]=starpower;
                subject.prime=starpower;}}
        return subject;};

    function stripComments(string) {
        return string.replace(/^\s*#.*$/g,"").
            replace(/^\s*\/\/.*$/g,"");}
    
    Knodule.prototype.handleEntries=function handleEntries(block){
        if (typeof block === "string") {
            var nocomment=stripComments(block);
            var segmented=segment(nocomment,/(?:\s*[\n;]\s*)+/g);
            if (this.trace_parsing>1)
                fdjtLog("Handling %d entries",segmented.length);
            return this.handleEntries(segmented);}
        else if (block instanceof Array) {
            var results=[];
            var i=0; while (i<block.length) {
                var entry=block[i++]; var len=entry.length;
                if (entry[len-1]===';') entry=entry.slice(0,len-1);
                results[i]=this.handleEntry(entry);}
            return results;}
        else throw {name: 'TypeError', irritant: block};};

    Knodule.prototype.def=Knodule.prototype.handleSubjectEntry;

    Knodule.def=function(string,kno){
        if (!(kno)) kno=Knodule.knodule;
        return kno.def(string);};
    Knodule.ref=RefDB.ref;

    Knodule.prototype.trace_parsing=0;

    return Knodule;})();

var KNode=Knodule.KNode;
var Knode=KNode;
// Suppress never-used warning
if (KNode!==Knode) fdjt.Log("Weird stuff");

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ##################### knodules/knodules.js ####################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file provides a Javascript/ECMAScript of KNODULES, 
   a lightweight knowledge representation facility.

   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library is built on the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification and redistribution of this program is permitted
   under the GNU General Public License (GPL) Version 2:

   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@biz.beingmeta.com

   Enjoy!

*/
/* global Knodule: false */

//var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));
//var Knodule=window.Knodule;

(function(){
    "use strict";

    var RefDB=fdjt.RefDB;
    var Ref=fdjt.Ref;
    var Query=RefDB.Query;
    var KNode=Knodule.KNode;
    var fdjtLog=fdjt.Log;
    var warn=fdjtLog.warn;

    var fdjtSet=fdjt.Set;

    var slotpat_weights=
        {"~%": 1,"~%*": 1,"%": 4,"%*": 4,"^%": 2,"^%*": 2,
         "*%": 8, "*%*": 6,"**%": 12, "**%*": 8};

    Knodule.addTags=function addTags(refs,tags,refdb,tagdb,base_slot,tagscores){
        if (!(base_slot)) base_slot="tags";
        if (typeof tags === "string") tags=[tags];
        else if (tags instanceof Ref) tags=[tags];
        else if (!(tags.length)) tags=[tags];
        else if (tags instanceof Array) {}
        else tags=[].concat(tags);
        if (typeof refs === "string") refs=[refs];
        else if (refs instanceof Ref) refs=[refs];
        else if (refs instanceof Array) {}
        else if (!(refs.length)) refs=[refs];
        else refs=[].concat(refs);
        var slots=new Array(tags.length);
        var i=0, ntags=tags.length, tag, slot, ref;
        while (i<ntags) {
            tag=tags[i]; slot=base_slot; var weak=false;
            if (typeof tag === "string") {
                if (tag[0]==="*") {
                    var tagstart=tag.search(/[^*]/);
                    slot=tag.slice(0,tagstart)+base_slot;
                    tag=tag.slice(tagstart);}
                else if (tag[0]==="~") {
                    slot="~"+base_slot;
                    tag=tag.slice(1);
                    weak=true;}
                else {}
                if (tag.indexOf('|')>0) {
                    if (tagdb) tag=tagdb.handleEntry(tag);
                    else if (Knodule.current)
                        tag=Knodule.current.handleEntry(tag);
                    else {}}
                else if ((weak)&&(tagdb))
                    tag=tagdb.probe(tag)||tag;
                else if (weak) {}
                else if (tagdb) tag=tagdb.ref(tag);
                else {}}
            slots[i]=slot; tags[i]=tag; i++;}
        var j=0, nrefs=refs.length;
        while (j<nrefs) {
            var refstring=refs[j]; ref=false;
            if ((refdb)&&(typeof refstring === "string"))
                ref=refdb.ref(refstring);
            else ref=RefDB.resolve(refstring,false,Knodule,true);
            if (!(ref)) {
                warn("Couldn't resolve %s to a reference",refstring);
                j++; continue;}
            refs[j++]=ref;}
        i=0; while (i<ntags) {
            tag=tags[i]; slot=slots[i];
            if (tagscores) {
                var slotpat=slot.replace(base_slot,"%");
                var slotweight=slotpat_weights[slotpat];
                if (!(slotweight)) slotweight=3;
                tagscores.increment(tag,nrefs*slotweight);}
            j=0; while (j<nrefs) {
                ref=refs[j++];
                if (!(ref)) continue;
                ref.add(slot,tag,true);
                if (ref.alltags) ref.alltags.push(tag);
                else ref.alltags=[tag];
                if (tag instanceof KNode) {
                    ref.add('knodes',tag);
                    ref.add(slot+"*",tag,true);}
                if ((tag instanceof KNode)&&(tag.allways)) 
                    ref.add(slot+"*",tag.allways,true);}
            i++;}};

    function exportTagSlot(tags,slotid,exported){
        if (!(tags instanceof Array)) tags=[tags];
        var extags=((exported.tags)||(exported.tags=[]));
        var start=slotid.search(/[^*~]+/);
        var end=slotid.search(/[*]*$/);
        var prefix=((start)&&(slotid.slice(0,start)));
        if (end) slotid=slotid.slice(start,end);
        else if (start) slotid=slotid.slice(start);
        var i=0, lim=tags.length; while (i<lim) {
            var tag=tags[i++];
            if (!(tag)) continue;
            var tagstring=((typeof tag === "string")?(tag):(tag._qid||tag.getQID()));
            if (start) extags.push(prefix+tagstring);
            else extags.push(tagstring);}
        return undefined;}
    Knodule.exportTagSlot=exportTagSlot;
            
    function importTagSlot(ref,slotid,tags,data,indexing){
        var keep=[]; var alltags=[], tagref;
        var knodule=ref.tag_knodule||ref._db.tag_knodule||
            Knodule.tag_knodule||Knodule.current;
        if (!(tags instanceof Array)) tags=[tags];
        var i=0, lim=tags.length; while (i<lim) {
            var tag=tags[i++];
            if (!(tag)) continue;
            else if (tag instanceof Ref) keep.push(tag);
            else if ((typeof tag === "object")&&(tag._id)) {
                tagref=ref.resolve(tag,knodule,Knodule,true)||tag._id;
                keep.push(tagref);}
            else if (typeof tag === "string") {
                var tag_start=tag.search(/[^*~]/);
                var tagstring=tag, slot=slotid, tagterm=tag;
                if (tag_start>0) {
                    slot=tag.slice(0,tag_start)+slotid;
                    tagstring=tag.slice(tag_start);}
                var bar=tagstring.indexOf('|');
                if (bar>0) tagterm=tagstring.slice(0,bar);
                else tagterm=tagstring;
                tagref=RefDB.resolve(tagterm,knodule,Knodule,true)||
                    ((knodule)&&(knodule.ref(tagterm)))||
                    tagterm;
                if (bar>0) {
                    if (tagref instanceof KNode) 
                        tagref._db.handleEntry(tagstring);
                    else warn("No knodule for %s",tagstring);}
                alltags.push(tagref);
                if (tagref instanceof KNode) ref.add('knodes',tagref,indexing);
                if (slot!==slotid) ref.add(slot,tagref,indexing);
                else keep.push(tagref);}
            else keep.push(tag);}
        ref["all"+slotid]=fdjtSet(alltags.concat(keep));
        if (keep.length) return keep;
        else return undefined;}
    Knodule.importTagSlot=importTagSlot;

    // Knodule.addTags=function addTags(){};

    function TagQuery(tags,dbs,weights){
        if (arguments.length===0) return this;
        var clauses=[], slots=this.slots=[];
        if (!(dbs)) dbs=TagQuery.default_dbs||false;
        if (!(weights)) weights=this.weights||{"tags": 1};
        if (!(tags instanceof Array)) tags=[tags];
        for (var sl in weights) {
            if (weights.hasOwnProperty(sl)) slots.push(sl);}
        var i_tag=0, n_tags=tags.length;
        while (i_tag<n_tags) {
            var tagval=tags[i_tag++];
            if (typeof tagval === "string")
                clauses.push({fields: 'strings',values: [tagval]});
            else if ((tagval._db)&&(tagval._db.slots)) 
                clauses.push({fields: tagval._db.slots,values: [tagval]});
            else clauses.push({fields: slots,values: [tagval]});}
        
        this.tags=tags;

        return Query.call(this,dbs,clauses,weights);}

    TagQuery.prototype=new Query();
    
    var TagMap=fdjt.Map;
    
    TagQuery.prototype.getCoTags=function getCoTags(results){
        if (this.cotags) return this.cotags;
        else if (this.execute()) {
            if (!(results)) results=this.results;
            var scores=this.scores;
            var slots=this.slots, n_slots=slots.length;
            var alltags=this.cotags=[];
            var tagscores=this.tagscores=new TagMap();
            var tagfreqs=this.tagfreqs=new TagMap();
            var weights=this._weights||this.weights;
            var max_score=0, max_freq=0;
            var r=0, n_results=results.length;
            while (r<n_results) {
                var result=results[r++], seen={};
                var score=((scores)&&(scores[result._id]))||1;
                var s=0; while (s<n_slots) {
                    var slot=slots[s];
                    if (result.hasOwnProperty(slot)) {
                        var tags=result[slot];
                        var weight=weights[slot]||1;
                        if (!(tags)) tags=[];
                        else if (!(tags instanceof Array)) tags=[tags];
                        else {}
                        var v=0, n_tags=tags.length;
                        while (v<n_tags) {
                            var tag=tags[v++];
                            if (!(tagscores.get(tag)))
                                alltags.push(tag);
                            if (!(seen[tag])) {
                                var new_freq=tagfreqs.increment(tag,1);
                                if (new_freq>max_freq) max_freq=new_freq;
                                seen[tag]=true;}
                            var new_score=
                                tagscores.increment(tag,weight*score);
                            if (new_score>max_score)
                                max_score=new_score;}}
                    s++;}}
            this.max_tagfreq=max_freq;
            this.max_tagscore=max_score;
            return alltags;}
        else return false;};
    TagQuery.prototype.getString=function TagQueryString(){
        var tags=fdjt.Set(this.tags); var qstring="";
        var i=0, lim=tags.length;
        while (i<lim) {
            if (i>0) qstring=qstring+";";
            var tag=tags[i++];
            if (typeof tag === "string")
                qstring=qstring+tag;
            else qstring=qstring+((tag._qid)||(tag.getQID()));}
        return qstring;};
    
    Knodule.TagQuery=TagQuery;

})();
         

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ##################### knodules/html.js ####################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file provides for HTML documents using KNODULES, including
   the extraction and processing of embedded KNODULE definitions
   or references and interaction with interactive parts of the
   FDJT library.

   For more information on knodules, visit www.knodules.net
   This library is built on the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification and redistribution of this program is permitted
   under the GNU General Public License (GPL) Version 2:

   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@biz.beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global Knodule: false */

//var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));
//var Knodule=window.Knodule;

(function(){
    "use strict";

    var fdjtString=fdjt.String;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtAjax=fdjt.Ajax;
    
    var addClass=fdjtDOM.addClass;

    /* Getting knowdes into HTML */

    var KNode=Knodule.KNode;
    Knodule.KNode.prototype.toDOM=
        Knodule.KNode.prototype.toHTML=function(){
            var spec=((this.prime)?("span.dterm.prime"):
                      (this.weak)?("span.dterm.weak"):
                      "span.dterm");
            var span=fdjtDOM(spec,this.dterm);
            if (this.gloss) 
                span.title=fdjtString.strip_markup(this.gloss);
            span.dterm=this.dterm;
            return span;};
    
    /* Making DTERM descriptions */

    function KNode2HTML(arg,knodule,varname,cloud,lang){
        if (cloud===true) {
            if (typeof lang !== "string") lang=(Knodule.language)||"EN";
            cloud=false;}
        else if ((cloud)&&(typeof lang !== "string"))
            lang=(Knodule.language)||"EN";
        else {}
        
        var valstring=((typeof arg === "string")&&(arg))||(arg._qid)||
            ((arg.getQID)&&(arg.getQID()))||(arg.toString());
        var checkbox=((varname)&&
                      (fdjtDOM({tagName: "INPUT",type: "CHECKBOX",
                                name: varname,value: valstring})));
        var text=((typeof arg === "string")&&(arg))||
            fdjtDOM("span.term",valstring);
        var variations=((arg instanceof KNode)&&(fdjtDOM("span.variations")));
        var israw=(typeof arg === "string");
        var span=fdjtDOM(((israw)?("span.rawterm"):("span.dterm")),
                         checkbox," ",variations,
                         ((israw)?
                          (fdjtDOM("span.text","\u201c"+text+"\u201d")):
                          (text)));
        if ((lang)||(cloud)) {
            addClass(span,"completion");
            span.setAttribute("data-value",valstring);}
        function init(){
            if (arg instanceof KNode) {
                var knode=arg, dterm=knode.dterm;
                text.innerHTML=dterm;
                span.setAttribute("data-key",dterm);
                span.setAttribute("data-dterm",knode);
                if ((lang)||(cloud)) {
                    var synonyms=knode[lang];
                    if ((synonyms)&&(typeof synonyms === 'string'))
                        synonyms=[synonyms];
                    if (synonyms) {
                        var i=0; while (i<synonyms.length) {
                            var synonym=synonyms[i++];
                            if (synonym===dterm) continue;
                            var variation=fdjtDOM("span.variation",synonym,"=");
                            variation.setAttribute("data-key",synonym);
                            variations.appendChild(variation);}}
                    if (knode.about) span.title=knode.about;
                    // This should try to get a dterm in the right language
                    span.setAttribute("data-key",knode.dterm);}
                else span.setAttribute("data-key",knode.dterm);}
            else {
                if (arg.name) {
                    span.setAttribute("data-key",arg.name);
                    span.innerHTML=arg.name;}}
            if (cloud) cloud.addCompletion(span);}
        if (typeof arg === "string") {
            span.setAttribute("data-key",arg);
            if (cloud) cloud.addCompletion(span);
            return span;}
        else if (arg._live) {init(); return span;}
        else {arg.onLoad(init); return span;}}

    Knodule.HTML=KNode2HTML;
    Knodule.KNode2HTML=KNode2HTML;
    Knodule.Knode2HTML=KNode2HTML;
    Knodule.knode2HTML=KNode2HTML;

    /* Adding Kodes to datalists */
    function knodeToOption(arg){
        var option;
        if (typeof arg === "string") {
            option=fdjtDOM("OPTION",arg);
            option.setAttribute("value",arg);
            return option;}
        var dterm=arg.dterm;
        var valstring=((typeof arg === "string")&&(arg))||(arg._qid)||
            ((arg.getQID)&&(arg.getQID()))||(arg.toString());
        var options=document.createDocumentFragment();
        option=fdjtDOM("option",dterm);
        option.setAttribute("value",valstring);
        options.appendChild(option);
        return options;}
    Knodule.knodeToOption=knodeToOption;

    /* Getting Knodules out of HTML */

    function knoduleLoad(elt,knodule){
        var src=((typeof elt === 'string')?(elt):(elt.src));
        var text=fdjtAjax.getText(src);
        var knowdes=knodule.handleEntries(text);
        if ((knodule.trace_load)||(Knodule.trace_load))
            fdjtLog("Parsed %d entries from %s",knowdes.length,elt.src);}

    function knoduleSetupHTML(knodule){
        if (!(knodule)) knodule=new Knodule(document.location.href);
        var start=new Date();
        var elts=fdjtDOM.getLinks("{http://knodules.org/}knodule",true,true);
        var i=0, lim, elt;
        if (!((elts)&&(elts.length)))
            elts=fdjtDOM.getLinks("knodule",true,true);
        if (!((elts)&&(elts.length)))
            elts=fdjtDOM.getLinks("*.knodule",true,true);
        i=0; lim=elts.length; while (i<lim) knoduleLoad(elts[i++],knodule);
        elts=fdjtDOM.getMeta("knodef");
        i=0; lim=elts.length; while (i<elts.length) {
            knodule.handleEntry(elts[i++].content);}
        elts=document.getElementsByTagName("META");
        i=0; lim=elts.length; while (i<lim) {
            elt=elts[i++];
            if (elt.name==="KNODEF") knodule.handleEntry(elt.content);}
        elts=document.getElementsByTagName("SCRIPT");
        i=0; lim=elts.length; while (i<lim) {
            elt=elts[i++];
            var lang=elt.getAttribute("language");
            var type=elt.type;
            if ((type==="text/knodule")||(type==="application/knodule")||
                ((lang) &&
                 ((lang==="knodule") ||(lang==="KNODULE")||
                  (lang==="knowlet"||(lang==="KNOWLET"))))) {
                if (elt.src) knoduleLoad(elt,knodule);
                else if (elt.text) {
                    var txt=elt.text;
                    var cdata=txt.search("<!\\[CDATA\\[");
                    if (cdata>=0) {
                        var cdend=txt.search("]]>");
                        txt=txt.slice(cdata+9,cdend);}
                    var dterms=knodule.handleEntries(txt);
                    if ((knodule.trace_load)||(Knodule.trace_load))
                        fdjtLog("Parsed %d inline knodule entries",
                                dterms.length);}
                else {}}}
        var finished=new Date();
        if ((knodule.trace_load)||(Knodule.trace_load))
            fdjtLog("Processed knodules in %fs",
                    ((finished.getTime()-start.getTime())/1000));}
    Knodule.HTML.Setup=knoduleSetupHTML;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ######################### fdjt/codexlayout.js ###################### */ 

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   It implements a method for breaking narrative HTML content
   across multiple pages, attempting to honor page break constraints,
   etc.

   Check out the 'mini manual' at the bottom of the file or read the
   code itself.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or any
   later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

   Use and redistribution (especially embedding in other CC licensed
   content) is also permitted under the terms of the Creative Commons
   "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global idbModules */

// var fdjt=((window)?((window.fdjt)||(window.fdjt={})):({}));

fdjt.CodexLayout=
    (function(){
        "use strict";
        /* globals Promise: false */

        var fdjtDOM=fdjt.DOM;
        var fdjtLog=fdjt.Log;
        var fdjtAsync=fdjt.Async;
        var fdjtTime=fdjt.Time;
        var fdjtState=fdjt.State;
        var RefDB=fdjt.RefDB;
        var fdjtID=fdjt.ID;

        var hasContent=fdjtDOM.hasContent;
        var hasParent=fdjtDOM.hasParent;
        var getParent=fdjtDOM.getParent;
        var getStyle=fdjtDOM.getStyle;
        var parsePX=fdjtDOM.parsePX;
        var getLineHeight=fdjtDOM.getLineHeight;
        var hasClass=fdjtDOM.hasClass;
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var toArray=fdjtDOM.toArray;
        var getElementValue=fdjtDOM.getElementValue;
        
        var setLocal=fdjtState.setLocal, pushLocal=fdjtState.pushLocal;
        var dropLocal=fdjtState.dropLocal, removeLocal=fdjtState.removeLocal;

        var floor=Math.floor;

        var root_namespace;
        if (document.body)
            root_namespace=document.body.namespaceURI;
        else fdjtDOM.addListener(window,"load",function(){
            root_namespace=document.body.namespaceURI;});
        
        var indexedDB=window.indexedDB||idbModules.indexedDB;

        var layoutDB;

        function appendChildren(node,children,start,end){
            var lim=end||children.length; var i=(start)||0;
            var frag=document.createDocumentFragment();
            while (i<lim) {
                var child=children[i++];
                if (!(child)) i++;
                else if ((child.nodeType===3)&&
                         (child.nodeValue.length===0)) {}
                else frag.appendChild(child);}
            node.appendChild(frag);}

        function getGeom(elt,root,extra){
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var width=elt.offsetWidth;
            var height=elt.offsetHeight;
            var rootp=((root)&&(root.offsetParent));
            var style=((extra)&&(getStyle(elt)));

            if (elt===root) 
                return {left: 0,top: 0,width:width,height: height};
            elt=elt.offsetParent;
            while (elt) {
                if ((root)&&((elt===root)||(elt===rootp))) break;
                top += elt.offsetTop;
                left += elt.offsetLeft;
                elt=elt.offsetParent;}
            
            if (extra) {
                var t_margin=parsePX(style.marginTop);
                var r_margin=parsePX(style.marginRight);
                var b_margin=parsePX(style.marginBottom);
                var l_margin=parsePX(style.marginLeft);
                var t_padding=parsePX(style.paddingTop);
                var r_padding=parsePX(style.paddingRight);
                var b_padding=parsePX(style.paddingBottom);
                var l_padding=parsePX(style.paddingLeft);
                var t_border=parsePX(style.borderTopWidth);
                var r_border=parsePX(style.borderRightWidth);
                var b_border=parsePX(style.borderBottomWidth);
                var l_border=parsePX(style.borderLeftWidth);
                var outer_width=width+l_margin+r_margin;
                var outer_height=height+t_margin+b_margin;
                var inner_width=width-(l_border+l_padding+r_border+r_padding);
                var inner_height=height-(t_border+t_padding+b_border+b_padding);
                var lh=style.lineHeight, fs=style.fontSize, lhpx=false;
                if (lh==="normal") lhpx=parsePX(fs);
                else if (lh.search(/px$/)>0) lhpx=parsePX(lh);
                else if (lh.search(/%$/)>0) 
                    lhpx=(parseFloat(lh.slice(0,-1))/100)*(parsePX(fs));
                else lhpx=parsePX(fs);
                return {left: left, top: top, width: width,height: height,
                        right:left+width,bottom:top+height,
                        top_margin: t_margin, bottom_margin: b_margin,
                        left_margin: l_margin, right_margin: r_margin,
                        outer_height: outer_height,outer_width: outer_width,
                        inner_height: inner_height,inner_width: inner_width,
                        line_height: lhpx};}
            else return {left: left, top: top, width: width,height: height,
                         right:left+width,bottom:top+height};}

        var getChildren=fdjtDOM.getChildren;
        var getChild=fdjtDOM.getChild;

        /* Node testing */

        var notspace=/[^ \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff]/g;
     
        function isEmpty(string){
            if (typeof string === "string")  {
                var pt;
                if (string.length===0) return true;
                else pt=string.search(notspace);
                if (pt<0) return true;
                else if (string[pt]!=='&') return false;
                else {
                    string=string.replace(/&nbsp;/g,"\u00a0");
                    pt=string.search(notspace);
                    return (pt<0);}}
            else return false;}

        function inFlow(node){
            var style=getStyle(node);
            if ((style.display!=='none')&&
                ((style.position==='static')||
                 (style.position==='')))
                return node;
            else return false;}
        
        function optimizeLayoutRule(rule){
            if (!(rule)) return rule;
            else if (typeof rule === "string") {
                if ((rule[0]===".")&&
                    (rule.slice(1).search(/\.|#|\[/)<0)) 
                    return new RegExp("\\b"+rule.slice(1)+"\\b");
                else return new fdjtDOM.Selector(rule);}
            else if (rule instanceof RegExp) return rule;
            else if (rule.match) return rule;
            else if (rule.length) {
                var newrules=[]; var firstrules=[];
                var classes=[]; var selectors=[];
                var i=0, lim=rule.length;
                while (i<lim) {
                    var r=rule[i++];
                    if (typeof r !== "string") newrules.push(r);
                    else if (r[0]===".") {
                        if (r.slice(1).search(/\.|#|\[/)>=0)
                            // complex selector (not just a classname)
                            selectors.push(r);
                        else classes.push(r.slice(1));}
                    else if ((r[0]==="#")||(r[0]==="["))
                        selectors.push(r);
                    else classes.push(r);}
                if (classes.length)
                    firstrules.push(new RegExp("\\b("+classes.join("|")+")\\b"));
                if (selectors.length)
                    firstrules.push(new fdjtDOM.Selector(selectors.join(", ")));
                return firstrules.concat(newrules);}
            else return rule;}

        function testNode(node,test) {
            var tests;
            if (!(test)) return true;
            if (typeof test === 'string') tests=[test];
            else if (test instanceof Array) tests=test;
            else tests=[test];
            var i=0; var lim=tests.length;
            while (i<lim) {
                var atest=tests[i++];
                if (node===test) return true;
                else if (atest instanceof RegExp) {
                    if (!(node.className)) continue;
                    if (!(node.className.search)) continue;
                    // Handle inadvertant use of selector syntax
                    if (node.className.search(atest)>=0) return true;}
                else if (typeof atest === 'string') {
                    if (!(node.className)) continue;
                    if (!(node.className.search)) continue;
                    // Handle inadvertant use of selector syntax
                    if (atest[0]==='.') atest=atest.slice(1);
                    var classrx=new RegExp("\\b"+atest+"\\b");
                    if (node.className.search(classrx)>=0) return true;}
                else if ((atest.match)&&(atest.match(node)))
                    // This should get most versions of CSS selectors
                    return true;
                else {}}
            return false;}

        /* Scaling elements and nodes */

        var adjustFontSize=fdjt.DOM.adjustFontSize;
        var adjustFonts=fdjt.DOM.adjustFonts;
        var tweakImage=fdjt.DOM.tweakImage;

        function scaleToPage(elt,width,height,leavefont){
            if (typeof elt === "string") elt=fdjtID(elt);
            if ((!(elt))||(elt.length===0)) return;
            else if (elt.nodeType) {
                if (elt.nodeType!==1) return;
                if ((hasClass(elt,"_pagescaled"))||(elt.getAttribute("style")))
                    return;
                var ps=elt.getAttribute("data-pagescale")||
                    elt.getAttribute("pagescale")||
                    getElementValue(elt,"xdatapagescale");
                var psw=1, psh=1;
                var style=elt.style;
                var cstyle=getStyle(elt);
                // If it has an individual transform, don't mess it up
                if ((style[fdjtDOM.transform])&&
                    (style[fdjtDOM.transform]!=="none")&&
                    (style[fdjtDOM.transform]!==""))
                    return;
                if (ps) {
                    var psv=ps.split(/ |,|x/g);
                    if (psv.length===2) {
                        psw=parseScale(psv[0]);
                        psh=parseScale(psv[1]);}
                    else psh=psw=parseScale(psv[0]);}
                // Target width and height
                var tw=width*psw, th=height*psh;
                var w=elt.offsetWidth, h=elt.offsetHeight;
                // Scale factors for width and height
                var sw=tw/w, sh=th/h;
                if (elt.tagName==="IMG") {
                    style.maxHeight=style.minHeight="inherit";
                    style.maxWidth=style.minWidth="inherit";
                    // Get width and height again, with the constraints off
                    //  This means that pagescaling trumps CSS constraints,
                    //  but we'll accept that for now
                    w=elt.offsetWidth; h=elt.offsetHeight; sw=tw/w; sh=th/h;
                    if (sw<sh) {
                        style.width=Math.round(w*sw)+"px";
                        style.height="auto";}
                    else {
                        style.height=Math.round(h*sh)+"px";
                        style.width="auto";}}
                else if (leavefont) {
                    var wrapper=((cstyle.display==="inline")?
                                 (fdjtDOM("span.codexscalewrapper")):
                                 (fdjtDOM("div.codexscalewrapper")));
                    if (cstyle.display==="inline") {
                        style.display="inline-block";
                        wrapper.display="inline-block";}
                    wrapper.style.width=tw+"px"; wrapper.style.height=th+"px";
                    elt.style[fdjtDOM.transform]="scale("+sw+","+sh+")";
                    elt.style[fdjtDOM.transformOrigin]=
                        ((cstyle.textAlign==="left")?("top left"):
                         (cstyle.textAlign==="right")?("top right"):
                         ("top center"));
                     elt.parentNode.replaceChild(wrapper,elt);}
                else {
                    adjustFontSize(elt);
                    if (cstyle.display==="inline")
                        style.display="inline-block";
                    style.width=tw+"px"; style.height=th+"px";}
                addClass(elt,"_pagescaled");}
            else if (elt.length) {
                var i=0, lim=elt.length;
                while (i<lim) scaleToPage(
                    elt[i++],width,height,leavefont||false);}
            else {}}

        function parseScale(s){
            if (s.search(/%$/g)>0) {
                var pct=parseFloat(s.slice(0,s.length-1));
                return pct/100;}
            else return parseFloat(s);}

        function atPageTop(node,page,body){
            if (!(body)) body=document.body;
            var scan=node; while (scan) {
                if (scan===page) return true;
                else if (scan===body) return false;
                else if (!(scan.previousSibling)) scan=scan.parentNode;
                else if ((scan.previousSibling.nodeType===3)&&
                         (isEmpty(scan.previousSibling.nodeValue)))
                    scan=scan.previousSibling;
                else if ((scan.previousSibling.nodeType===1)&&
                         (!(inFlow(scan.previousSibling))))
                    scan=scan.previousSibling;
                else break;}
            return ((scan.nodeType===1)&&
                    (scan.className)&&(scan.className.search)&&
                    (scan.className.search(/\bcodexpage\b/g)>=0));}

        /* Duplicating nodes */

        var tmpid_count=1;
        var dupstate=/\bcodexdup(start|end)?\b/g;
        var codexstate=/\bcodex(dupstart|dup|dupend|relocated)\b/g;
        function dupClass(classname,dupclass,pat){
            if (!(pat)) pat=dupstate;
            if (classname) {
                if (classname.search(dupstate)<0)
                    return classname+" "+dupclass;
                else return classname.replace(dupstate,"")+" "+dupclass;}
            else return dupclass;}

        // This recreates a node and it's DOM context (containers) on
        //  a new page, calling itself recursively as needed
        function dupContext(node,page,dups,crumbs){
            if ((node===document.body)||(node.id==="CODEXCONTENT")||
                (hasClass(node,"codexroot"))||(hasClass(node,"codexpage")))
                return false;
            else if (hasParent(node,page)) return node;
            else if ((node.className)&&(node.className.search)&&
                     (node.className.search(/\bcodexwraptext\b/)>=0))
                // We don't bother duplicating text wrapping convenience
                //  classes
                return dupContext(node.parentNode,page,dups,crumbs);
            // Now we actually duplicate it.  
            var id=node.id, baseid=node.getAttribute("data-baseid");
            if (!(id)) id=baseid;
            var duplist=dups[id];
            var last_dup=((duplist)&&(duplist.length)&&
                          (duplist[duplist.length-1]));
            // If it doesn't have an ID, we give it one, because we'll want
            //  to refer to it later while wanting to avoid DOM cycles
            if (!(id)) id=node.id="CODEXTMPID"+(tmpid_count++);
            else if (duplist) {
                // See if it's already been duplicated
                var d=duplist.length-1;
                while (d>=0) {
                    if (hasParent(duplist[d],page)) return duplist[d];
                    else d--;}}
            // Duplicate it's parent
            var copy=node.cloneNode(false);
            var parent=dupContext(node.parentNode,page,dups,crumbs);
            var nodeclass=((node.className)&&(node.className.search)&&
                           (node.className))||"";
            var lastclass=((last_dup)&&(last_dup.className)&&
                           (last_dup.className.search)&&
                           (last_dup.className));
            if (baseid) copy.codexbaseid=baseid;
            // Jigger the class name
            if (!(duplist)) {
                node.className=dupClass(nodeclass,"codexdupstart",codexstate);
                stripBottomStyles(node,true);
                stripTopStyles(copy,true);
                copy.className=dupClass(nodeclass,"codexdupend");}
            else copy.className=dupClass(nodeclass,"codexdupend");
            if (nodeclass.search(/\bcodexdupend\b/g)>=0) {
                node.className=dupClass(nodeclass,"codexdup");
                stripBottomStyles(node,true);}
            if ((lastclass)&&(lastclass.search(/\bcodexdupend\b/g)>=0)) {
                last_dup.className=lastclass.replace(
                        /\bcodexdupend\b/g,"codexdup");
                stripBottomStyles(last_dup,true);}
            // if (copy.getAttribute("style")) 
            // If the original had an ID, save it in various ways
            if (id) {
                copy.codexbaseid=id;
                copy.setAttribute("data-baseid",id);
                copy.removeAttribute("id");}
            // Record the copy you've made (to avoid recreation)
            if (duplist) duplist.push(copy);
            else dups[id]=[copy];
            // If it's got a copied context, append it to the context;
            //   otherwise, just append it to the page
            if (parent) parent.appendChild(copy);
            else page.appendChild(copy);
            return copy;}

        function stripBottomStyles(node,keep){
            var style=node.style;
            if ((keep)&&(!(node.hasAttribute("data-savedstyle")))) 
                node.setAttribute("data-savedstyle",style.cssText);
            style.paddingBottom="0px";
            style.borderBottomWidth="0px";
            style.marginBottom="0px";}
        function stripTopStyles(node,keep){
            var style=node.style;
            if ((keep)&&(!(node.hasAttribute("data-savedstyle"))))
                node.setAttribute("data-savedstyle",style.cssText);
            style.textIndent="0px";
            style.paddingTop="0px";
            style.borderTopWidth="0px";
            style.marginTop="0px";}

        /* Moving nodes */

        function getFirstContent(node){
            var child=node.firstChild;
            while (child) {
                if (((child.nodeType===3)&&(!(isEmpty(child.nodeValue))))||
                    ((child.nodeType===1)&&(inFlow(child))))
                    return child;
                else child=child.nextSibling;}
            return false;}
        
        // This moves a node into another container, leaving
        // a back pointer for restoration
        function moveNode(arg,into,blockp,crumbs){
            var baseclass; var node=arg, weird=false;
            if (hasParent(node,into)) return node;
            if (node.nodeType===1) {
                baseclass=node.className;
                if ((baseclass)&&(typeof baseclass !== "string"))
                    weird=true;}
            else if (node.nodeType===3) {
                if (node.nodeValue.search(/\w/g)>=0) {
                    // Wrap non-empty text nodes in elements before
                    // moving
                    var wrapnode=fdjtDOM(
                        ((blockp)?"div.codexwraptext":"span.codexwraptext"));
                    if (node.parentNode)
                        node.parentNode.replaceChild(wrapnode,node);
                    wrapnode.appendChild(node);
                    baseclass="codexwraptext";
                    node=wrapnode;}
                else node=node.cloneNode(true);}
            else {}
            if (weird) {}
            else if ((node.nodeType===1)&&(hasClass(node,"codextextsplit"))) {}
            else if ((node.parentNode)&&((!(node.id))||(!(crumbs[node.id])))) {
                // If the node has a parent and hasn't been moved before,
                //  we leave a "crumb" (a placeholder) in the original
                //  location.
                if (!(node.id)) node.id="CODEXTMPID"+(tmpid_count++);
                // Record origin information; we'll use this to revert
                //  the layout if we need to (for example, before
                //  laying out again under different constraints)
                var crumb=document.createTextNode("");
                crumbs[node.id]=crumb;
                if (baseclass) node.className=baseclass+" codexrelocated";
                else node.className="codexrelocated";
                node.parentNode.replaceChild(crumb,node);}
            if (into) {
                var dragged=[], scan=node.nextSibling;
                while (scan) {
                    if ((scan.nodeType===1)&&
                        (typeof scan.className === "string")&&
                        (scan.className.search(/\bcodexblock\b/g)>=0))
                        break;
                    dragged.push(scan);
                    scan=scan.nextSibling;}
                into.appendChild(node);
                if (dragged.length) {
                    var d=0, ndrags=dragged.length;
                    while (d<ndrags) into.appendChild(dragged[d++]);}}
            return node;}
        
        function markPageTop(node,force){
            if ((!force)&&(hasClass(node,"codexpagetop"))) return;
            if ((node.namespaceURI)&&
                (node.namespaceURI!==root_namespace))
                return;
            var nodestyle=node.getAttribute("style")||"";
            var newstyle=nodestyle+((nodestyle)?("; "):(""))+
                "margin-top: 0px !important;";
            if (!(node.hasAttribute("data-savedstyle")))
                node.setAttribute("data-savedstyle",nodestyle);
            node.setAttribute("style",newstyle);
            addClass(node,"codexpagetop");
            if (node.childNodes) {
                var children=node.childNodes, i=0, lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===1) {
                        var style=getStyle(child);
                        if ((style.position!=='static')&&(style.position!=='')) {}
                        else if ((child.classname)&&(child.classname.search)&&
                                 (child.className.search(/\bfdjtskiptext\b/g)>=0)) {}
                        else return markPageTop(child);}
                    else if (child.nodeType===3) {
                        if (!(isEmpty(child.nodeValue))) return;}
                    else {}}}}

        // This moves a node onto a page, recreating (as far as
        // possible) its original DOM context on the new page.
        function moveNodeToPage(node,page,dups,crumbs){
            if (hasParent(node,page)) {
                if ((node.nodeType===1)&&(!(hasContent(page,true,false,node))))
                    markPageTop(node);
                return node;}
            else {
                var move=node, parent=move.parentNode;
                // If we're moving a first child, we might as well
                // move the parent
                while ((parent)&&
                       (parent!==document.body)&&
                       (parent.id!=="CODEXCONTENT")&&
                       (!(hasClass(parent,"codexroot")))&&
                       (!(hasClass(parent,"codexpage")))&&
                       (move===getFirstContent(parent))) {
                    move=parent; parent=move.parentNode;}
                if ((!(parent))||(parent===document.body)||
                    (parent.id==="CODEXCONTENT")||
                    (hasClass(parent,"codexroot"))||
                    (hasClass(parent,"codexpage"))) {
                    // If the node isn't on a page or is at top level of a
                    // page, the parent doesn't need to be duplicated to
                    // move the child.  However, the motion might modify
                    // the moved node (for example, cloning it).
                    if (move===node)
                        node=move=moveNode(node,page,false,crumbs);
                    else move=moveNode(move,page,false,crumbs);}
                else {
                    // Otherwise duplicate the parent and move the child
                    var dup_parent=dupContext(parent,page,dups,crumbs);
                    if (move===node)                    
                        node=move=moveNode(node,dup_parent||page,false,crumbs);
                    else move=moveNode(move,dup_parent||page,false,crumbs);}
                if ((node)&&(node.nodeType===1)&&
                    (!hasContent(page,true,false,move)))
                    markPageTop(move);
                return node;}}

        // Reverting layout

        function restoreNode(node,info,crumbs){
            var id=node.id;
            if (!(id)) return;
            var origin=crumbs[id];
            if (origin) {
                var parent=origin.parentNode;
                if (hasClass(node,/\bcodexwraptext\b/g)) 
                    parent.replaceChild(node.childNodes[0],origin);
                else origin.parentNode.replaceChild(node,origin);}
            dropClass(node,"codexrelocated");}
        
        function revertLayout(layout) {
            var crumbs=layout.crumbs; var now=fdjtTime(), i=0, lim;
            if ((layout.reverting)&&((now-layout.reverting)<10000)) return;
            else layout.reverting=now;
            var textsplits=layout.textsplits;
            var node;
            var pagescaled=toArray(
                layout.container.getElementsByClassName("_pagescaled"));
            i=0; lim=pagescaled.length; while (i<lim) {
                var elt=pagescaled[i++];
                var wrapper=getParent(elt,".codexscalewrapper");
                var saved=elt.getAttribute("data-savedstyle");
                dropClass(elt,"_pagescaled");
                if (saved) elt.setAttribute("style",saved);
                else elt.setAttribute("style","");
                if (wrapper) wrapper.parentNode.replaceChild(elt,wrapper);}
            var cantsplit=toArray(
                layout.container.getElementsByClassName("codexcantsplit"));
            dropClass(cantsplit,"codexcantsplit");
            var split=toArray(
                layout.container.getElementsByClassName("codexsplitstart"));
            i=0; lim=split.length; while (i<lim) {
                node=split[i++];
                var nodeid=node.id;
                var text=textsplits[nodeid];
                node.parentNode.replaceChild(text,node);}
            var shards=toArray(
                layout.container.getElementsByClassName("codextextsplit"));
            i=0; lim=shards.length; while (i<lim) {
                node=shards[i++];
                node.parentNode.removeChild(node);}
            var ragged=toArray(
                layout.container.getElementsByClassName("codexraggedsplit"));
            dropClass(ragged,"codexraggedsplit");
            var leading=toArray(
                layout.container.getElementsByClassName("codexdupleading"));
            if ((leading)&&(leading.length)) fdjtDOM.remove(leading);
            var moved=toArray(
                layout.container.getElementsByClassName("codexrelocated"));
            var dupstarts=toArray(layout.container.getElementsByClassName(
                "codexdupstart"));
            var dupends=toArray(layout.container.getElementsByClassName(
                "codexdupend"));
            var dupmiddle=toArray(layout.container.getElementsByClassName(
                "codexdup"));
            var pagetops=toArray(layout.container.getElementsByClassName(
                "codexpagetop"));
            dropClass(dupstarts,"codexdupstart");
            dropClass(dupends,"codexdupend");
            dropClass(dupmiddle,"codexdup");
            dropClass(pagetops,"codexpagetop");
            if ((moved)&&(moved.length)) {
                layout.logfn(
                    "Reverting layout of %d nodes and %d split texts",
                    moved.length,RefDB.countKeys(textsplits));
                i=0; lim=moved.length;
                while (i<lim) {
                    restoreNode(moved[i++],layout,crumbs);}}
            var restyled=fdjtDOM.$("[data-savedstyle]");
            i=0; lim=restyled.length;
            while (i<lim) {
                var rs=restyled[i++];
                if (rs.hasAttribute("data-savedstyle")) {
                    var os=rs.getAttribute("data-savedstyle");
                    if (os) rs.setAttribute("style",os);
                    else rs.removeAttribute("style");
                    rs.removeAttribute("data-savedstyle");}}
            fdjtDOM.unwrapChildren("div.fdjtfontwrapper",layout.container);
            layout.textsplits={}; layout.crumbs={};}
        
        /* Codex trace levels */
        /* 0=notrace
           1=trace tracked nodes
           2=trace addition of top level chunks
           3=trace insertion of page breaks
           4=trace every node consideration
        */

        function CodexLayout(init){
            if (!(init)) init={};

            var layout=this;

            this.init=init;
            this.thenfns=[];

            // Layout rules
            var fullpages=this.fullpages=
                optimizeLayoutRule(init.fullpages||false);
            var singlepages=this.singlepages=
                optimizeLayoutRule(init.singlepages||false);
            var floatpages=this.floatpages=
                optimizeLayoutRule(init.floatpages||false);
            var floatblocks=this.floatblocks=
                optimizeLayoutRule(init.floatblocks||false);

            var pageprefix=this.pageprefix=init.pageprefix||"CODEXPAGE";

            // Layout Dimensions
            var page_height=this.height=init.page_height||fdjtDOM.viewHeight();
            var page_width=this.width=init.page_width||fdjtDOM.viewWidth();
            // Set the orientation when provided
            var orientation=(init.orientation)||
                ((page_width>page_height)?('landscape'):('portrait'));
            this.orientation=orientation;
            
            var pagefn=(init.pagefn)||false;

            var serialize=false; // Stop timeslicing
            this.serialize=function(val){
                if (typeof val === "undefined") serialize=true;
                else serialize=val;};

            // What constitutes a short page
            var short_page_height=
                ((init.hasOwnProperty("short_page_height"))&&
                 ((init.short_page_height)&&
                  ((init.short_page_height<=1)?(page_height*init.short_page_height):
                   (init.short_page_height))));

            // Break 'paragraphs' (anything with just text and inline nodes)
            var break_blocks=this.break_blocks=
                ((typeof init.break_blocks === 'undefined')?(true):
                 (init.break_blocks));

            // Atomic nodes can't be broken.  Specifying this can
            // speed up page layout in some cases.
            var atomic=init.atomic||false;
            if (typeof atomic === "string") atomic=fdjtDOM.selector(atomic);
            else if ((atomic.length)&&(atomic.join))
                // Arrays of selector strings
                atomic=fdjtDOM.selector(atomic.join(","));
            else {}
            this.atomic=atomic;

            this.dontsave=init.dontsave||false;

            var use_scaling=
                ((typeof init.use_scaling === 'undefined')?(true):
                 (init.use_scaling));

            // Scale pages (use CSS to shrink pages to fit)
            var scale_pages=this.scale_pages=
                ((use_scaling)&&
                 ((typeof init.scale_pages === 'undefined')?(true):
                  (init.scale_pages)));
            
            // This is the node DOM container where we place new pages
            var container=this.container=
                init.container||fdjtDOM("div.codexpages");
            
            var origin=this.origin=init.origin||false;

            function noop(){}
            var logfn=this.logfn=
                init.logfn||CodexLayout.logfn||
                ((typeof fdjtLog !== 'undefined')?(fdjtLog):(noop));

            // STATE variables

            var pagenum=this.pagenum=0; // Tracks current page number
            var pages=this.pages=[]; // Array of all pages generated, in order
            var dups=this.dups={}; // Tracks nodes/contexts already duplicated
            // Maps IDs to text nodes left behind as placeholders when
            //  the original nodes were moved.
            var crumbs=this.crumbs={}; 
            var cur_root=this.root=false; // The root currently being added

            // Tracks text nodes which have been split, keyed by the
            // temporary IDs assigned to them
            var textsplits=this.textsplits={};
            // Tracks split blocks
            var splits=this.splits={};

            var page=this.page=init.page; // Contains the currently open page

            var prev=this.prev=false; // The last terminal block we processed
            var prevstyle=this.prevstyle=false;
            var previnfo=this.previnfo=false;

            // this.drag[] contains nodes which will go on the next
            // page when we get there.  The nodes in this.drag[] have
            // already been placed on pages, but we keep track of them
            // in case we need to move them to a new page to honor
            // nobreak constraints.
            var drag=this.drag=[];

            // this.floating contains fully-assembled page nodes to
            // placed in pages after this one; it is intended for
            // out-of-flow or 'too bit to fit' content
            var floating=this.floating=[];

            if (init.layout_id) this.layout_id=init.layout_id;

            // Startup

            this.started=false; // When we started
            var trace=this.tracelevel=  // How much to trace
            init.tracelevel||CodexLayout.tracelevel||
                (fdjtState.getLocal("codexlayout.trace",true))||0;
            var track=init.track||CodexLayout.track||
                (fdjtState.getLocal("codexlayout.track"))||false;
            var debug=init.debug||CodexLayout.debug||
                fdjtState.getLocal("codexlayout.debug")||false;
            if (track) {
                this.track=track=fdjtDOM.Selector(track);
                if (!(trace)) trace=this.tracelevel=1;}
            if (debug) {
                this.debug=debug=fdjtDOM.Selector(debug);
                if (!(trace)) trace=this.tracelevel=1;}
            else this.debug=false;
            if (trace) addClass(document.body,"debugcodexlayout");
            this.roots=init.roots||[]; // Where all roots can be tracked
            this.root_count=0; // Number of root nodes added
            this.block_count=0;
            this.lastid=false;
            this.timeslice=
                ((init.hasOwnProperty('timeslice'))?(init.timeslice):
                 (CodexLayout.timeslice));
            this.timeskip=
                ((init.hasOwnProperty('timeskip'))?(init.timeskip):
                 (CodexLayout.timeskip));
            
            var pagerule=this.pagerule=init.pagerule||false;
            
            function moveUp(node){
                if (trace) {
                    if ((trace>3)||((track)&&(track.match(node))))
                        logfn("Moving node %o to page %o",node,page);}
                // if (lastmove!==node) {allmoves.push(node); lastmove=node;}
                return moveNodeToPage(node,page,dups,crumbs);}

            function moveChildren(into,children,start,end){
                var tomove=[];
                if (!(start)) start=0;
                if (!(end)) end=children.length;
                while (start<end) tomove.push(children[start++]);
                start=0; end=tomove.length; while (start<end)
                    moveNode(tomove[start++],into,false,crumbs);}
            
            //  addContent calls loop() exactly once to set up the
            //   actual loop to be timesliced with repeated calls
            //   setTimeout and a final call to doneFn.  The real
            //   inner function is step(), which relies on state
            //   stored in its closure.
            function addContent(root,timeslice,timeskip,
                                trace,progressfn,donefn) {
                
                var newpage=false, newpages=((page)?([page]):([]));
                var start=fdjtTime();
                if (!(page)) {newPage(); newpage=true;}

                if ((timeslice)&&(typeof timeslice !== "number")) 
                    timeslice=layout.timeslice;
                if ((timeskip)&&(typeof timeskip !== "number"))
                    timeskip=layout.timeskip;

                if (typeof trace === 'undefined') trace=layout.tracelevel;
                if (typeof progressfn === 'undefined')
                    progressfn=layout.progressfn||false;
                if (!(layout.started)) layout.started=start;
                // If it's already been added to a page, don't do it again.
                if (getParent(root,".codexpage")) {
                    pagesDone(newpages); newpages=[];
                    if (donefn) donefn(layout);
                    return false;}
                layout.roots.push(root);
                layout.root_count++;

                var fullpage=hasClass(root,"codexfullpage")||
                    ((fullpages)&&(testNode(root,fullpages)));
                var singlepage=
                    (fullpage)||
                    (hasClass(root,"codexsinglepage"))||
                    (checkSinglePage(root));
                if ((fullpage)||(singlepage)) {
                    if (!(avoidBreakInside(root)))
                        fullpage=singlepage=false;}
                    
                if (newpage) root=moveUp(root);
                else if (singlepage) newPage(root);
                else if ((mustBreakBefore(root))||
                         ((prev)&&(mustBreakAfter(prev)))) {
                    root=newPage(root);}
                else root=moveUp(root);
                var scale_elts=getChildren(root,"[data-pagescale],[pagescale]");
                scaleToPage(scale_elts,page_width,page_height);
                if ((root.tagName==="IMG")&&
                    ((fullpage)||(singlepage)))
                    tweakImage(root,page_width,page_height);
                else {}
                if (singlepage) {
                    var pw=page.scrollWidth, ph=page.scrollHeight;
                    if ((pw>page_width)||(ph>page_height))
                        addClass(page,"codexoversize");
                    else if ((fullpage)&&
                             ((pw<(0.9*page_width))&&(ph<(0.9*page_height))))
                        addClass(page,"codexundersize");
                    else {}
                    // Start a new page and update the loop state
                    newPage(); prev=layout.prev=root;
                    prevstyle=layout.prevstyle=getStyle(root);
                    previnfo=layout.previnfo=getBlockInfo(root,prevstyle);
                    pagesDone(newpages); newpages=[];
                    drag=[];
                    if (donefn) donefn(layout);
                    return;}
                else {
                    var geom=getGeom(root,page); var done=false;
                    if (mustBreakInside(root)) {}
                    else if (geom.bottom<=page_height) {
                        if (cantBreakBefore(root)) drag.push(root);
                        else if (cantBreakAfter(root)) drag=[root];
                        else drag=[];
                        done=true;}
                    else if (((atomic)&&(atomic.match(root)))||
                             (avoidBreakInside(root))) {
                        if (!(newpage)) {
                            newPage(root); geom=getGeom(root,page);}
                        if (geom.bottom<=page_height) {
                            if (cantBreakAfter(root)) drag=[root];
                            else drag=[];
                            done=true;}}
                    else {}
                    if (done) {
                        prev=layout.prev=root; 
                        prevstyle=layout.prevstyle=getStyle(root);
                        previnfo=layout.previnfo=getBlockInfo(root,prevstyle);
                        pagesDone(newpages); newpages=[];
                        if (donefn) donefn(layout);
                        return;}}

                var blocks=[], blockinfo=[], styles=[];
                // gather all of the block-level elements
                // (recursively) in the node, noting which ones are
                // terminals.  This should be pretty fast, so we do it
                // synchronously
                gatherBlocks(root,root,blocks,blockinfo,styles);
                layout.block_count=layout.block_count+blocks.length;
                if (trace>1)
                    logfn("Laying out %d blocks from %o; page=%o",
                          blocks.length,root,page);

                // If there aren't any blocks, we try adding the
                //  content to the current page and, if it goes over,
                //  create a new page for it and call the donefn.  At
                //  the top level, we only split blocks.
                if (blocks.length===0) {
                    if (!(newpage)) newPage(root);
                    layout.root=cur_root=false;
                    pagesDone(newpages); newpages=[];
                    if (donefn) donefn(layout);
                    return;}
                
                layout.root=cur_root=root;

                var block_i=0, n_blocks=blocks.length; 
                
                function step(){
                    var block=blocks[block_i], style=styles[block_i];
                    var info=blockinfo[block_i], terminal=info.terminal||false;
                    var next=blocks[block_i+1], nextinfo=blockinfo[block_i+1];
                    var tracing=false;
                    if (block.id) layout.lastid=block.id;
                    
                    if ((trace)&&(block)&&
                        ((trace>3)||((track)&&(track.match(block))))) {
                        logfn("Considering block %o (#%d from %o); page=%o",
                              block,block_i,root,page);
                        tracing=true;}
                    
                    if ((trace)&&(block)&&(debug)&&(debug.match(block))) {
                        // jshint debug:true
                        debugger;}

                    // FIRST, HANDLE DRAGGING
                    handle_dragging(block,terminal,info,style);
                    
                    if (block) block=handle_standalone(block,info,style);
                    // If a block is false, continue
                    if (!(block)) {block_i++; return;}
                    
                    // Finally, we check if everything fits.  We're
                    // walking through the blocks[] but only advance
                    // when an element fits or can't be split or
                    // tweaked Note that we may process an element [i]
                    // more than once if we split the node and part of
                    // the split landed back in [i].
                    var geom=getGeom(block,page), lh=getLineHeight(block,style);
                    var padding_bottom=parsePX(style.paddingBottom);
                    if ((trace)&&((trace>3)||((track)&&(track.match(block)))))
                        logfn("Layout/geom %o %j",block,geom);
                    if (((geom.bottom-padding_bottom)>page_height)||
                        // Even if we're above the bottom of the page,
                        // check if the next block goes over the edge
                        // and whether that would be a bad thing.  If
                        // it's big enough and far down enough, we
                        // split the current block, making a slightly
                        // short page.
                        ((next)&&(geom.height>3*lh)&&
                         (((page_height-geom.bottom)/page_height)>0.9)&&
                         ((geom.bottom+(getGeom(next).height))>page_height)&&
                         (!(info.avoidbreakinside))&&
                         (nextinfo.avoidbreakinside)&&
                         (nextinfo.avoidbreakinside))) {
                        var use_height=page_height;
                        if ((geom.bottom-padding_bottom)<=page_height)
                            // This is the case where the block fits
                            // but the next block is really the
                            // problem.  We force a split on the
                            // current block by tweaking the height
                            // used for splitting to be 2 lines above
                            // the block's bottom.
                            use_height=geom.bottom-padding_bottom-2*lh;
                        if (!(terminal)) {
                            if (tracing)
                                logfn("Oversize non-terminal %o, continuing",
                                      block);
                            block_i++;}
                        // If we get here, we're a terminal node
                        // which extends below the bottom of the page
                        else if (((short_page_height)?
                                  (geom.top>short_page_height):
                                  (geom.top>(use_height-lh*1.2)))&&
                                 (drag.length===0)&&
                                 (!(info.avoidbreakbefore))) {
                            // Our top is also over the bottom of the page,
                            // and we can break here, so we just push off 
                            block=newPage(block,info);}
                        else if (info.floating) {
                            // If the block can float, let it
                            floating.push(block); block_i++;}
                        else if (((!(break_blocks))||
                                  (info.atomic)||(info.avoidbreakinside)||
                                  (hasClass(block,"codexcantsplit")))) {
                            var broken=handle_unbreakable(
                                block,info,style,geom,tracing);
                            if (!(broken)) block_i++;
                            else block=broken;}
                        else {
                            // Now we try to split the block, we store
                            // the 'split block' back in the blocks
                            // variable because we might need to split
                            // it again.
                            if (tracing)
                                logfn("Splitting block %o @ %o",block,page);
                            var split=splitBlock(block,info,style,use_height);
                            if ((split)&&(split!==block)) {
                                layout.prev=prev=block;
                                layout.prevstyle=prevstyle=style;
                                layout.previnfo=previnfo=info;
                                blocks[block_i]=split;
                                styles[block_i]=style=getStyle(split);
                                blockinfo[block_i]=getBlockInfo(split,style);
                                blockinfo[block_i].terminal=terminal;
                                return;}
                            else {
                                geom=getGeom(block,page);
                                if (geom.bottom>page_height) {
                                    addClass(page,"codexoversize");
                                    layout.drag=drag=[];
                                    newPage();}
                                block_i++;}
                            layout.drag=drag=[];}}
                    // We fit on the page, so we check if we might
                    // need to be dragged to the next page by the next
                    // block
                    else if ((info.avoidbreakafter)&&
                             (!(atPageTop(block,page)))) {
                        if ((drag.length===0)||(drag.indexOf(block)<0)) {
                            if (tracing) logfn("Possibly dragging %o",block);
                            drag.push(block);}
                        block_i++;}
                    else {
                        layout.drag=drag=[]; block_i++;}
                        
                    // Update the prev pointer for terminals if we advanced
                    if (terminal) {
                        layout.prev=prev=block;
                        layout.prevstyle=prevstyle=style;
                        layout.previnfo=previnfo=info;}}

                // Gather all the block-level elements inside a node,
                // recording which ones are terminals (don't have any
                // blocks within them)
                function gatherBlocks(root,node,blocks,info,styles,style){
                    var nodeinfo=false;
                    if (node.nodeType!==1) return;
                    if (node.codexui) return;
                    if (!(style)) style=getStyle(node); 
                    if ((!((style.position==='static')||(style.position==='')))||
                        ((style.float)&&(style.float!=='none')))
                        return;
                    if (((atomic)&&(atomic.match(node)))||
                        (style.display==='table-row')||
                        ((node.tagName!=='BR')&&(node.tagName!=='HR')&&
                         (avoidBreakInside(node,style)))) {
                        if (node.offsetWidth>page_width) {
                            var w=node.offsetWidth, sw=w/page_width;
                            scaleToPage(node,page_width,sw*node.offsetHeight,true);}
                        if ((node.offsetHeight===0)||
                            ((node.offsetHeight)&&
                             (node.offsetHeight<(page_height*1.5)))) {
                            nodeinfo=getBlockInfo(node,style);
                            addClass(node,"codexblock");
                            info.push(nodeinfo);
                            blocks.push(node); styles.push(style);
                            nodeinfo.terminal=node;
                            moveUp(node);
                            checkTerminal(node,root,info);
                            return;}
                        else {
                            // If the node is really tall, ignore the
                            // avoid page break constraint
                            if ((node.childNodes)&&(node.childNodes.length)) {
                                fdjtLog.warn(
                                    "Allowing split of huge (%d) block %o",
                                    node.offsetHeight,node);
                                node.style.pageBreakInside="auto";
                                style=getStyle(node);}}}
                    var disp=style.display;
                    if ((node.tagName!=="BR")&&
                        (disp!=='inline')&&
                        (disp!=='table-row')&&
                        (disp!=='table-cell')) {
                        addClass(node,"codexblock");
                        nodeinfo=getBlockInfo(node,style);
                        blocks.push(node);
                        styles.push(style);
                        info.push(nodeinfo);
                        if ((disp==='block')||(disp==='table')||
                            (disp==='table-row-group')) {
                            var children=node.childNodes;
                            var total_blocks=blocks.length;
                            var i=0; var len=children.length;
                            while (i<len) {
                                var ch=children[i++];
                                if (ch.nodeType===1)
                                    gatherBlocks(root,ch,blocks,info,styles);}
                            if (blocks.length===total_blocks)
                                nodeinfo.terminal=node;}
                        else nodeinfo.terminal=node;
                        if (nodeinfo.terminal) checkTerminal(node,root,info);
                        moveUp(node);}
                    else if ((style.position==='static')&&
                             (node.tagName==='A')) {
                        var anchor_elts=node.childNodes;
                        var j=0; var n_elts=anchor_elts.length;
                        while (j<n_elts) {
                            var child=anchor_elts[j++];
                            if (child.nodeType!==1) continue;
                            var cstyle=getStyle(child);
                            if (cstyle.display!=='inline')
                                gatherBlocks(root,child,blocks,styles,info,cstyle);}
                        moveUp(node);}
                    else {}}

                function getBlockInfo(node,style){
                    return {
                        avoidbreakinside: avoidBreakInside(node,style),
                        forcebreakbefore: forcedBreakBefore(node,style),
                        forcebreakafter: forcedBreakAfter(node,style),
                        avoidbreakbefore: avoidBreakBefore(node,style),
                        avoidbreakafter: avoidBreakAfter(node,style),
                        fullpage: ((hasClass(node,/\bcodexfullpage\b/))||
                                   ((fullpages)&&(testNode(node,fullpages)))),
                        singlepage: checkSinglePage(node,style),
                        atomic: ((atomic)&&(atomic.match(node))),
                        floatpage: ((hasClass(node,/\bcodexfloatpage\b/))||
                                    ((floatpages)&&(testNode(node,floatpages)))),
                        floating: ((hasClass(node,"codexfloat"))||
                                   ((floatblocks)&&(floatblocks.match(node))))};}

                function handle_dragging(block,terminal,info,style,tracing){
                    // If this block is terminal and we don't want to
                    // break before this block or after the preceding
                    // block, drag along the previous block to the new
                    // page.
                    
                    // NOTE that dragged blocks have already been
                    // placed, so the previous page will end up short.
                    // Them's the breaks (so to speak).
                    if (!(block)) {}
                    else if ((prev)&&(drag.indexOf(prev)<0)) {}
                    else if ((prev)&&(atPageTop(prev))) {
                        if (drag.length) layout.drag=drag=[];}
                    else if ((prev)&&(terminal)&&(info.avoidbreakbefore)) {
                        if (tracing) logfn("Possibly dragging %o",prev);
                        if (drag.indexOf(prev)<0) 
                            drag.push(prev);}
                    else if ((prev)&&(info.avoidbreakafter)) {
                        if (tracing) logfn("Possibly dragging %o",prev);
                        if (drag.indexOf(prev)<0) 
                            drag.push(prev);}
                    else if (drag.length) layout.drag=drag=[];
                    else {}}

                function handle_standalone(block,info,style,tracing){
                    if ((info.floatpage)||((info.floating)&&(info.singlepage))) {
                        // Float pages just get pushed (until newPage below)
                        if (tracing) logfn("Pushing float page %o",block);
                        floating.push(block);
                        return false;}
                    else if (info.singlepage) {
                        // Single pages automatically get their own page
                        if (tracing) logfn("Full single page for %o",block);
                        block=newPage(block,info); newPage();
                        return false;}
                    else if ((page.childNodes.length)&&
                             ((info.forcebreakbefore)||
                              ((previnfo)&&(previnfo.forcebreakafter))||
                              ((previnfo)&&((previnfo.fullpage)||(previnfo.fullpage))))) {
                        // This is the easy case.  Note that we don't
                        // force a page break if the current page is
                        // empty.
                        if (tracing) logfn("Forced new page for %o",block);
                        // We clear the drags because we're following a force rule
                        layout.drag=drag=[];
                        return newPage(block,info)||block;}
                    else return moveUp(block);}

                function handle_unbreakable(block,info,style,geom,tracing) {
                    // We can't break this block (for various reasons)
                    var curpage=page; tracing=false; // ignored
                    var newblock=false;
                    if ((drag.length)&&(atPageTop(drag[0],page))) {
                        // A new page won't make a difference
                        //  because we're dragging the rest of
                        //  the current page anyway, so we
                        //  need to make some choices (we're
                        //  in an impossible situation)
                        var oversize_limit=0.2;
                        if ((!(info.avoidbreakafter))&&
                            (((geom.bottom-page_height)/page_height)>1.0)&&
                            (((geom.bottom-page_height)/page_height)<oversize_limit)) {
                            // We leave the block where it is and create an oversize page
                            // We do this if:
                            //   a break after the block is okay AND
                            //    the page would be less than 20% oversize
                            addClass(page,"codexoversize"); // probably redundant
                            layout.drag=drag=[]; newPage();
                            return false;}
                        else {
                            // We need to leave the dragged elements behind
                            layout.drag=drag=[];
                            newblock=newPage(block,info);
                            if (page===curpage)
                                return false; // probably "codexoversize"
                            else if (block!==newblock) info=getBlockInfo(newblock);
                            if (((!(break_blocks))||
                                 (info.atomic)||(info.avoidbreakinside)||
                                 (hasClass(newblock,"codexcantsplit")))) {
                                // layout.drag=drag=[];
                                return false;}
                            else return newblock;}}
                    else {
                        // We just make a new page for the block
                        newblock=newPage(block,info);
                        if (block!==newblock) info=getBlockInfo(newblock);
                        if (page===curpage)
                            return false; // probably "codexoversize"
                        else if (block!==newblock) info=getBlockInfo(newblock);
                        if (((!(break_blocks))||
                             (info.atomic)||(info.avoidbreakinside)||
                             (hasClass(newblock,"codexcantsplit")))) {
                            // layout.drag=drag=[];
                            return false;}
                        else return newblock;}}

                function isLastChild(node){
                    var scan=node.nextSibling;
                    while (scan) {
                        if ((scan.nodeType===3)&&(!(isEmpty(scan.nodeValue)))) return false;
                        else if ((scan.nodeType===1)&&(inFlow(scan))) return false;
                        else scan=scan.nextSibling;}
                    return true;}
                function isFirstChild(node){
                    var scan=node.previousSibling;
                    while (scan) {
                        if ((scan.nodeType===3)||(!(isEmpty(scan.nodeValue)))) return false;
                        else if ((scan.nodeType===1)&&(inFlow(scan))) return false;
                        else scan=scan.previousSibling;}
                    return true;}

                function getFrontEdge(node,root){
                    var body=document.body;
                    var edge=[node], parent=node.parentNode;
                    while ((parent)&&(parent!==body)&&
                           (node!==root)&&(isLastChild(node))) {
                        edge.push(parent);
                        node=parent;
                        parent=node.parentNode;}
                    return edge;}
                function getBackEdge(node,root){
                    var body=document.body;
                    var edge=[node], parent=node.parentNode;
                    while ((parent)&&(parent!==body)&&
                           (node!==root)&&(isFirstChild(node))) {
                        edge.push(parent);
                        node=parent;
                        parent=node.parentNode;}
                    return edge;}

                function findInfo(node,info){
                    var i=info.length-1; while (i>=0) {
                        var nodeinfo=info[i--];
                        if (nodeinfo.node===node) return info;}
                    return false;}

                function checkTerminal(node,root,info){
                    if (hasClass(node,"codexterminal")) return;
                    var front_edge=getFrontEdge(node,root);
                    var back_edge=getBackEdge(node,root);
                    var avoid_before=false, force_before=false;
                    var avoid_after=false, force_after=false;
                    var front_info=(front_edge)&&(findInfo(front_edge,info));
                    var back_info=(back_edge)&&(findInfo(back_edge,info));
                    var i=0, lim=front_edge.length; if (lim>1) {
                        while (i<lim) {
                            if (avoidBreakAfter(front_edge[i]))
                                avoid_after=true;
                            if (forcedBreakAfter(front_edge[i]))
                                force_after=true;
                            i++;}}
                    i=0; lim=back_edge.length; if (lim>1) {
                        while (i<lim) {
                            if (avoidBreakBefore(back_edge[i]))
                                avoid_before=true;
                            if (forcedBreakBefore(back_edge[i]))
                                force_before=true;
                            i++;}}
                    if ((avoid_after)&&(force_after)) {
                        /* Avoid brain exploding */}
                    else if (avoid_after) {
                        if (front_info) front_info.avoidbreakafter=true;
                        addClass(front_edge,"AVOIDBREAKAFTER");}
                    else if (force_after) {
                        if (front_info) front_info.forcebreakafter=true;
                        addClass(front_edge,"FORCEBREAKAFTER");}
                    else {}
                    if ((avoid_before)&&(force_before)) {
                        /* Avoid brain exploding */}
                    else if (avoid_before) {
                        if (back_info) back_info.avoidbreakbefore=true;
                        addClass(back_edge,"AVOIDBREAKBEFORE");}
                    else if (force_before) {
                        if (back_info) back_info.forcebreakbefore=true;
                        addClass(back_edge,"FORCEBREAKBEFORE");}
                    else {}
                    addClass(node,"codexterminal");}
                
                function emptyNode(node){
                    if (node.nodeType===3)
                        return (node.nodeValue.search(/\S/)<0);
                    else if (node.nodeType===1) {
                        if ((!(node.childNodes))||
                            (node.childNodes.length===0)) {
                            if (node.offsetHeight) return false;
                            else return true;}
                        else {
                            var children=node.childNodes;
                            var i=0, lim=children.length;
                            while (i<lim) {
                                if (!(emptyNode(children[i++])))
                                    return false;}
                            return true;}}
                    else return false;}

                function firstGChild(ancestor,descendant){
                    var scan=descendant;
                    while (scan) {
                        if (scan===ancestor) return true;
                        else if (!(scan.previousSibling))
                            scan=scan.parentNode;
                        else {
                            var prev=scan.previousSibling;
                            while (prev) {
                                if ((emptyNode(prev))||
                                    ((prev.nodeType===1)&&(!(inFlow(prev))))) {
                                    scan=prev;
                                    prev=scan.previousSibling;}
                                else return false;}
                            scan=scan.parentNode;}}
                    return false;}

                // Whether we need to create a new page to have 'node'
                //  at the page top We don't need a new page if the
                //  current page has no content or no content up until
                //  the node in question
                function needNewPage(node){
                    if (!(page)) return true;
                    else if ((!(node))||(!(hasParent(node,page))))
                        return hasContent(page,true);
                    else if ((page.firstChild===node)||(firstGChild(page,node)))
                        return false;
                    else if ((node.nodeType===1)&&
                             (getGeom(node,page).top===0)&&
                             (node.tagName!=="BR"))
                        return false;
                    else return true;}

                /*** Create a new page. ***/
                // If node is passed, it is intended to be the first
                // element on the new page.
                function newPage(node,info,forcepage){
                    var i, lim;
                    if ((drag)&&(drag.length)&&(drag.length)&&
                        (atPageTop(drag[0]))) {
                        logfn("Ignored call for new page @%d due to excessive drag",
                              pagenum);
                        if (node) node=moveUp(node);
                        return false;}
                    if ((!(node))&&(!(forcepage))&&(page)&&
                        (page.childNodes.length===0)) {
                        if (node)
                            logfn("Ignored call for new page for %o on empty page %d",
                                  node,pagenum);
                        else logfn("Ignored call for new page on empty page %d",
                                   node,pagenum);
                        return false;}

                    if ((node)&&(node.nodeType===3)) {
                        var parent=node.parentNode;
                        if ((parent)&&(parent.childNodes.length===1)&&
                            (parent!==document.body)&&
                            (parent!==root)&&
                            (!(hasClass(parent,"codexpage"))))
                            node=parent;}

                    if ((node)&&(!(forcepage))&&(!(needNewPage(node)))) {
                        return moveUp(node);}

                    if ((floating)&&(floating.length)) {
                        // First add any floating pages that may have
                        // accumulated
                        var floaters=floating; floating=[];
                        var closed_page=page;
                        i=0; lim=floaters.length;
                        while (i<lim) {
                            var floater=floaters[i++], fg=false;
                            if (checkSinglePage(floater)) {
                                newPage(floater);
                                closed_page=page;
                                forcepage=true;}
                            else if (closed_page===page) {
                                newPage(floater); fg=getGeom(floater,page);
                                if (fg.bottom>page_height) {
                                    addClass(page,"codexoversize");
                                    closed_page=page;}}
                            else {                                
                                moveNodeToPage(floater,page);
                                fg=getGeom(floater,newpage);
                                if (fg.bottom>=page_height) newPage(floater);}}}

                    if ((!(node))||(forcepage)||(needNewPage(node))) {
                        // If we really need to create a new page, do so,
                        if (page) {
                            if (pagefn) pagefn.call(layout,page,layout);
                            page.style.height="";
                            dropClass(page,"codexworkpage");}
                        layout.page=page=fdjtDOM("div.codexpage.codexworkpage");
                        newpages.push(page);
                        if (!(pagerule)) {
                            page.style.height=page_height+'px';
                            page.style.width=page_width+'px';}
                        page.style.height="inherit";
                        pagenum++; layout.pagenum=pagenum;
                        page.id=pageprefix+(pagenum);
                        page.setAttribute("data-pagenum",pagenum);
                        fdjtDOM(container,page);
                        layout.prev=prev=false;
                        pages.push(page);}
                    
                    if (trace) {
                        if ((trace>2)||
                            ((track)&&(node)&&(track.match(node)))) {
                            if (node) logfn("Layout/%s %o at %o",
                                            newpage,page,node);
                            else logfn("Layout/%s %o",newpage,page);}}
                    
                    // If there are things we are dragging along, move
                    // them to the new page
                    if ((drag)&&(drag.length)) {
                        i=0; lim=drag.length;
                        while (i<lim) moveUp(drag[i++]);
                        if (node) {
                            var block=node;
                            var terminal=(info)&&(info.terminal);
                            if ((block)&&(drag.length)&&(terminal)) {
                                if ((drag.length===1)||
                                    (avoidBreakBefore(block))||
                                    (avoidBreakAfter(drag[drag.length-1]))) {
                                    if (drag.indexOf(block)<0)
                                        drag.push(block);}
                                else layout.drag=drag=[];}}
                        else {
                            layout.prev=prev=drag[drag.length-1];
                            layout.drag=drag=[];}}
                    if (node) return moveUp(node);
                    else return false;}

                // This gets a little complicated
                function splitBlock(node,info,style,use_height){
                    if (!(use_height)) use_height=page_height;
                    if (!(style)) style=getStyle(node);
                    if ((!(break_blocks))||(info.avoidbreakinside)||
                        (!(node.childNodes))||(node.childNodes.length===0)) {
                        // Simplest case, if we can't split, we just
                        // make a new page starting with the node.
                        addClass(node,"codexcantsplit");
                        newPage(node);
                        return node;}
                    if ((node.id)&&(node.id.search("CODEXTMP")!==0)) {
                        if (!(splits[node.id]))
                            splits[node.id]=node.cloneNode(true);}
                    // Otherwise, we remove all of the node's children
                    // and then add back just enough to reach the
                    // edge, potentially splitting some children to
                    // make this work.
                    var init_geom=getGeom(node,page,true);
                    var line_height=init_geom.line_height||12;
                    if ((use_height===page_height)&&
                        ((init_geom.top+init_geom.top_margin+
                          (line_height*1.2))>page_height)) {
                        // If the top is too close to the bottom of
                        // the page, try to just push onto a new page.
                        // This might fail if we're dragging too many
                        // nodes or if we're already the top of the page;
                        var cpage=page, newblock=newPage(node);
                        // If the page break succeeded, return the new block,
                        //  otherwise, keep trying to split
                        if (cpage!==page) return newblock;
                        // If we're near the bottom and the page break
                        // failed, we're in a tight place, so we bump
                        // up the height to let us go a little over
                        // (we'll adjust afterwards).
                        else use_height=page_height+floor(line_height*1.2);}
                    // Copy all the children into an array
                    var children=nodeChildren(node);
                    // and remove all of them at once
                    node.innerHTML="";
                    var geom=getGeom(node,page);
                    if (geom.bottom>use_height) {
                        // If the version without any children is
                        // already over the edge, just start a new
                        // page on the node (after restoring all the
                        // children to the node).
                        appendChildren(node,children);
                        addClass(node,"codexcantsplit");
                        newPage(node);
                        return node;}
                    // If the block is just a little bit over the
                    // bottom, tweak the page height to avoid leaving
                    // a single line on the other side, except if the
                    // overall height is small.
                    if ((use_height===page_height)&&
                        ((init_geom.bottom-page_height)<(line_height*1.2))&&
                        ((init_geom.height)>(line_height*3))) {
                        use_height=page_height-floor(line_height);}
                    // When splitChildren called, <node> is already
                    // empty and it's children are all in <children>
                    var push=splitChildren(node,children,init_geom,use_height);
                    if (!(push)) {
                        /* Doesn't need to be split after all.
                           Not sure when this will happen, if ever. */
                        fdjtLog("Tried to break %o which didn't need breaking",
                                node);
                        appendChildren(node,children);
                        return node;}
                    else if (push===node) {
                        // This is the case where we can't split at
                        //  all, so we add the class 'codexcantsplit'
                        //  to avoid trying again and we make a new
                        //  page
                        appendChildren(node,children);
                        addClass(node,"codexcantsplit");
                        newPage(node);
                        return node;}
                    else { 
                        var page_break=push[0];
                        // Since we left something behind on this page, we
                        //  can clear anything we're dragging
                        layout.drag=drag=[];
                        // Finally, we create a new page
                        page_break=newPage(page_break);
                        var dup=page_break.parentNode;
                        // This (dup) is the copied parent of the page
                        // break.  We append all the remaining
                        // children to this duplicated parent on the
                        // new page.  We want to keep backpointers
                        // (crumbs), so we only appendChildren if the
                        // node is already a dup; otherwise we
                        // moveChildren to leave crumbs.
                        if ((hasClass(node,"codexdup"))||
                            (hasClass(node,"codexdupend")))
                            appendChildren(dup,push,1);
                        else moveChildren(dup,push,1);
                        if (trace>1)
                            logfn("Layout/splitBlock %o @ %o into %o on %o",
                                  node,page_break,dup,page);
                        return dup;}}

                /*
                function nodeChildren(node){
                    var children=node.childNodes, results=[];
                    var last=false, next=children[0];
                    if (children.length<2) return toArray(children);
                    else {
                        var i=0, lim=children.length; while (i<lim) {
                            var child=children[i++]; next=children[i];
                            if (child.nodeType!==3) results.push(child);
                            else {
                                // We separate out leading and
                                // trailing punctuation because those
                                // may be attached with preceding or
                                // succeeding elements and text
                                // splitting normally operations on
                                // text runs as a whole.
                                var text=child.nodeValue;
                                var head_match=/^[,.!?;%$#@“”‘’`”‼‡…’‛⁇„⹂"']+/.exec(text);
                                if ((head_match)&&(last)&&(last.nodeType!==3)) {
                                    results.push(document.createTextNode(head_match[0]));
                                    text=text.slice(head_match[0].length);}
                                var foot_loc=text.search(/[,.!?;%$#@“”‘’`”‼‡…’‛⁇„⹂"']+$/);
                                if ((foot_loc>=0)&&(next)&&(next.nodeType!==3)) {
                                    results.push(document.createTextNode(
                                        text.slice(0,foot_loc)));
                                    results.push(document.createTextNode(
                                        text.slice(foot_loc)));}
                                else results.push(document.createTextNode(text));}
                            last=child;}
                        return results;}}
                */
                function nodeChildren(node){return toArray(node.childNodes);}

                function splitChildren(node,children,init_geom,use_page_height){
                    /* node is an emptied node and children are its
                       lost children.  We return an array of children
                       which should go onto the next page, possibly
                       synthesizing a new child by splitting some
                       text.  Returning false means that the node
                       should be left on its page; returning the node
                       itself indicates that it should be forced onto
                       a new page. */
                    var page_break=false, breaktype=false, breakpos=-1; 
                    var textsplit=false, text_parent=false;
                    if (!(use_page_height)) use_page_height=page_height;
                    // This is always called from splitBlock or the
                    //  break point in splitChildren, so we know that
                    //  node by itself is on the page while node with
                    //  it's children is over the page.
                    var geom=init_geom||getGeom(node,page);
                    if (children.length===1) {
                        page_break=children[0]; breakpos=0;
                        breaktype=page_break.nodeType;
                        node.appendChild(page_break);}
                    else {
                        // We add children back until we go over the edge
                        // and then figure out if there's a way to split
                        // the child that broke the page.
                        var i=0, n=children.length;
                        while (i<n) {
                            var child=children[i++];
                            // node.innerHTML="";
                            //appendChildren(node,children,0,i);
                            node.appendChild(child);
                            // Add the child back and get the geometry
                            geom=getGeom(node,page);
                            if (geom.bottom>use_page_height) {
                                page_break=child; breaktype=child.nodeType;
                                breakpos=i-1;
                                break;}
                            else continue;}}
                    if (breakpos<0)  // Never went over the edge
                        return false;
                    // If we get here, this child pushed the node over the edge
                    else if (breaktype===3) {
                        textsplit=page_break; text_parent=node;}
                    else if (breaktype!==1) {
                        //  It's a weird node, so we punt on handling it.
                        //  If it's the first child, push the whole node,
                        //  otherwise, just split it at the break
                        if (breakpos===0) return node;
                        else return children.slice(breakpos);}
                    // If the page break has a single textual child,
                    // we just split it's text.
                    else if ((page_break.childNodes.length===1)&&
                             (page_break.childNodes[0].nodeType===3)) {
                        textsplit=page_break.childNodes[0];
                        text_parent=page_break;}
                    // If we're breaking on the first node or there
                    // isn't any real content before the break, we
                    // admit defeat
                    else if ((breakpos===0)||
                             (!(hasContent(node,true,false,page_break)))) {
                        appendChildren(node,children,breakpos+1);
                        return node;}
                    // If the break is childless, we just split on it
                    else if ((!(page_break.childNodes))||
                             (page_break.childNodes.length===0))
                        return children.slice(breakpos);
                    else return children.slice(breakpos);
                    // If it's text, split it into words, then try to
                    // find the length at which one more word pushes
                    // it over the edge.
                    var probenode=textsplit, text=textsplit.nodeValue;
                    var original=textsplit;
                    // Now, break the text up at possible page breaks
                    // (we are not treating soft-hyphens as page
                    // breaks, though we might)
                    var words=attachWhitespace(text.split(/(\s+)/mg));
                    // If there aren't many words, don't bother splitting
                    if (words.length<2) {
                        // If the break is at the head, push the whole
                        // node to the next page, otherwise, 
                        if (breakpos===0) return node;
                        else return children.slice(breakpos);}
                    else {
                        // Check if just the first word pushes us over
                        // the edge, a relatively common case.  If so,
                        // we push the whole node over
                        var wprobe=document.createTextNode(words[0]);
                        text_parent.replaceChild(wprobe,probenode);
                        probenode=wprobe; geom=getGeom(node,page);
                        if (geom.bottom>use_page_height) {
                            text_parent.replaceChild(original,probenode);
                            if (breakpos===0) return node;
                            else if ((words[0].search(/^[.,;~?!:"'”’)\]-]/))===0) {
                                // If the first word is some sort of
                                // closing punctuation, we really want
                                // to break at the preceding child.
                                // If that's the first child
                                // (breakpos==1), we push the whole
                                // node, otherwise, we remove the
                                // probe and return the remainder of
                                // the children including the previous
                                // child.
                                if (breakpos===1) return node;
                                else {
                                    text_parent.removeChild(original);
                                    return children.slice(breakpos-1);}}
                            else {
                                // We don't bother splitting this
                                // text if the first word pushes us
                                // over the edge.
                                return children.slice(breakpos);}}
                        else {
                            // Now we go ahead and use splitWords to
                            // split the text.
                            text_parent.replaceChild(textsplit,wprobe);
                            probenode=textsplit;}}
                    var foundbreak=splitWords(
                        text_parent,probenode,words,node,use_page_height);
                    // We're done searching for the word break
                    if ((foundbreak===0)||(foundbreak===(words.length-1))) {
                        // Revert (don't actually do any text splitting)
                        text_parent.replaceChild(textsplit,probenode);
                        if (breakpos===0) return node;
                        else return children.slice(breakpos);}
                    else { // Split the text at foundbreak
                        var keeptext=words.slice(0,foundbreak).join("");
                        var pushtext=words.slice(foundbreak).join("");
                        // We record the ID so that we can restore the
                        // original text node
                        var keepnode, pushnode, id=false;
                        if (breaktype===3) {
                            // We replace the text with an element so
                            //  that we can look it up by ID to replace
                            //  when reverting the layout.
                            keepnode=fdjtDOM(
                                "span.codexsplitstart.codexraggedsplit");
                            id=keepnode.id="CODEXTMPID"+(tmpid_count++);
                            pushnode=fdjtDOM("span.codextextsplit");}
                        else if (hasClass(page_break,"codextextsplit")) {
                            // This is the case where we are splitting
                            // a text node again.  There's no need to
                            // save anything and we don't want nested
                            // codextextsplits, so we'll treat the
                            // page_break as a probenode (to be
                            // replaced).
                            probenode=keepnode=page_break;
                            keepnode.innerHTML="";
                            text_parent=node; probenode=keepnode;
                            pushnode=page_break.cloneNode(true);
                            addClass(page_break,"codexraggedsplit");
                            pushnode.id="";}
                        else {
                            keepnode=fdjtDOM("span.codexsplitstart");
                            pushnode=page_break.cloneNode(true);
                            if (!(keepnode.id))
                                id=keepnode.id="CODEXTMPID"+(tmpid_count++);
                            else pushnode.id="";}
                        keepnode.appendChild(document.createTextNode(keeptext));
                        pushnode.innerHTML="";
                        pushnode.appendChild(document.createTextNode(pushtext));
                        if (keepnode!==probenode)
                            text_parent.replaceChild(keepnode,probenode);
                        // Gather the children to be pushed, replacing
                        // the first one with the duplicated page_break
                        var push_children=children.slice(breakpos);
                        push_children[0]=pushnode;
                        // Put the children back into context for copying
                        appendChildren(node,push_children);
                        // Save the textsplit for reverting the layout
                        if (id) textsplits[id]=original;
                        // Return the children to be pushed to the new page
                        return push_children;}}

                function splitWords(
                    text_parent,probestart,words,node,use_page_height){
                    // Now we do a binary search to find the word
                    //  which pushes the node below the page bottom.
                    //  That's where we'll break.
                    var wlen=words.length, wtop=wlen, wbot=0, foundbreak=false;
                    var probenode=probestart, geom=false;
                    while (wbot<wtop) {
                        var wmid=wbot+floor((wtop-wbot)/2);
                        var newprobe=document.createTextNode(
                            words.slice(0,wmid).join(""));
                        // Add all the words up to foundbreak
                        text_parent.replaceChild(newprobe,probenode);
                        probenode=newprobe; geom=getGeom(node,page);
                        if (geom.bottom>use_page_height)
                            wtop=wmid-1;
                        else {
                            /* This is the actual test condition: add
                               the word at foundbreak to see if we
                               break the page.*/
                            var nextw=document.createTextNode(words[wmid]);
                            text_parent.appendChild(nextw);
                            var ngeom=getGeom(node,page);
                            text_parent.removeChild(nextw);
                            if (ngeom.bottom>use_page_height) {
                                foundbreak=wmid; break;}
                            else wbot=wmid+1;}}
                    if (foundbreak===false) foundbreak=wbot;
                    if (probestart!==probenode)
                        text_parent.replaceChild(probestart,probenode);
                    return foundbreak;}

                // This attaches trailing whitespace to words as
                // returned by .split()
                function attachWhitespace(breaks){
                    var words=[], word=false;
                    var bi=0, blen=breaks.length;
                    while (bi<blen) {
                        var s=breaks[bi++]; var ws;
                        if ((ws=s.search(/\s/))>=0) { /* Includes whitespace */
                            if (ws===0) { /* s is a break (it starts with whitespace) */
                                if (bi>=blen) word=s;
                                else if ((word)&&(/ +/.exec(s)))
                                    word=word+s+breaks[bi++];
                                else if (word) {words.push(word); word=s;}
                                else word=s;}
                            else {
                                if (word) words.push(word+s);
                                else words.push(s);
                                word=false;}}
                        else if (word) word=word+s;
                        else word=s;}
                    if (word) words.push(word);
                    return words;}

                function loop(){
                    var loop_start=fdjtTime();
                    while ((block_i<n_blocks)&&
                           ((!(timeslice))||(serialize)||
                            ((fdjtTime()-loop_start)<timeslice)))
                        step();
                    if (progressfn) progressfn(layout);
                    if (block_i<n_blocks) {
                        if (timeslice)
                            layout.timer=setTimeout(loop,timeskip||timeslice);
                        else loop();}
                    else {
                        var last_block=blocks[n_blocks-1];
                        if ((forcedBreakAfter(last_block))||
                            (hasClass(last_block,/\bcodexfullpage\b/))||
                            ((fullpages)&&(testNode(last_block,fullpages))))
                            newPage();
                        if (layout.timer) clearTimeout(layout.timer);
                        layout.timer=false;
                        layout.root=cur_root=false;
                        pagesDone(newpages); newpages=[];
                        if (donefn) {
                            if (timeslice) 
                                setTimeout(function(){donefn(layout);},10);
                            else donefn(layout);}}}

                // This is the inner loop
                if (!(timeslice)) {
                    while (block_i<n_blocks) step();
                    pagesDone(newpages);
                    if (donefn) donefn(layout);}
                else loop();
                
                return layout;}
            this.addContent=addContent;

            function pagesDone(pages){
                var i=0, lim=pages.length; while (i<lim) {
                    var page=pages[i++], ph=page.style.height;
                    if ((ph)&&(ph!=="")&&(ph!=="inherit")&&
                        (ph!=="initial")&&(ph!=="auto"))
                        continue;
                    if (hasClass(page,"codexoversize")) continue;
                    page.style.height="auto"; page.style.display="block";
                    var content_height=page.scrollHeight;
                    if (content_height<page_height) {}
                    else {
                        var pagestyle=getStyle(page);
                        var use_height=page_height+
                            parsePX(pagestyle.paddingTop)+
                            parsePX(pagestyle.paddingBottom);
                        if (content_height>use_height)
                            addClass(page,"codexoversize");}
                    page.style.height=""; page.style.display="";
                    var ragged=getChild(page,".codexraggedsplit");
                    if (ragged) 
                        ragged.appendChild(fdjtDOM(
                            "span.codexdupleading.fdjtskiptext","leading"));
                    var blocks=getChildren(page,".codexblock");
                    var j=0, n_blocks=blocks.length; while (j<n_blocks) {
                        var block=blocks[j++];
                        dropClass(block,"codexblock");
                        dropClass(block,"codexterminal");}}}

            function gatherLayoutInfo(
                node,ids,dups,dupids,dupstarts,restoremap){
                if (node.nodeType!==1) return;
                var classname=node.className;
                if (typeof classname === "string") {
                    if (classname.search(/\bcodexdupstart\b/)>=0) {
                        if (!(dupstarts[node.id])) {
                            dupstarts[node.id]=node;
                            dupids.push(node.id);
                            ids.push(node.id);}}
                    else if (classname.search(/\b(codexdup|codexdupend)\b/)>=0) {
                        var baseid=node.getAttribute("data-baseid");
                        if (baseid) {
                            node.codexbaseid=baseid;
                            if (dups[baseid]) dups[baseid].push(node);
                            else dups[baseid]=[node];}}
                    else if ((node.id)&&
                             (classname.search(/\bcodexrestore\b/)>=0)) {
                        if (!(restoremap[node.id])) {
                            ids.push(node.id);
                            restoremap[node.id]=node;}}}
                // Weird node
                else return;
                if ((node.childNodes)&&(node.childNodes.length)) {
                    var children=node.childNodes;
                    var i=0, lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        if (child.nodeType===1) gatherLayoutInfo(
                            child,ids,dups,dupids,dupstarts,restoremap);}}}

            var replaceNode=fdjtDOM.replace;

            /* Setting content (when there's a saved version) Mostly
               this sets up the external data and functions which would
               have been generated if we'd gone through the layout,
               especially the dups for split nodes and the saved_ids
               for restoring unique IDs.
            */
            function setSimpleLayout(content){
                function setting_layout(resolve,reject){
                    try {
                        var frag=document.createElement("div");
                        var all_ids=[], saved_ids={};
                        var dupids=[], dupstarts={}, restoremap={};
                        var curnodes=[], newdups={}, pagescales=[];
                        if (trace)
                            fdjtLog("Setting layout to %d characters of HTML",
                                    content.length);
                        frag.innerHTML=content;
                        var newpages=frag.childNodes, addpages=[];
                        if (trace) fdjtLog("Gathering layout info");
                        var i=0, lim=newpages.length; while (i<lim) {
                            var page=newpages[i++];
                            addpages.push(page);
                            if (page.nodeType===1) {
                                if ((page.className)&&(page.className.search)&&
                                    (page.className.search(/\bcurpage\b/)>=0))
                                    dropClass(page,"curpage");
                                gatherLayoutInfo(page,all_ids,newdups,
                                                 dupids,dupstarts,restoremap);}}
                        var idmap={};
                        if (trace) fdjtLog("Getting originals by ID");
                        i=0; lim=all_ids.length; while (i<lim) {
                            var idkey=all_ids[i++];
                            idmap[idkey]=document.getElementById(idkey);}
                        var bcrumb=false, ccrumb=false;
                        if (trace)
                            fdjtLog("Moving body and container out of document");
                        if ((origin)&&(origin.parentNode)) {
                            bcrumb=document.createTextNode("");
                            origin.parentNode.replaceChild(bcrumb,origin);}
                        if (container.parentNode) {
                            ccrumb=document.createTextNode("");
                            container.parentNode.replaceChild(ccrumb,container);}
                        if (trace) fdjtLog("Moving originals into layout");
                        i=0; lim=all_ids.length; while (i<lim) {
                            var id=all_ids[i++];
                            var original=idmap[id];
                            var restore=restoremap[id];
                            // The restoremap contains content references
                            //  which are unmodified from the original
                            //  content, making them a lot smaller and easier
                            //  to keep around.
                            if ((restore)&&(original)) {
                                var classname=restore.className;
                                var style=restore.getAttribute("style");
                                var ostyle=original.getAttribute("style");
                                var oclass=original.className;
                                var crumb=document.createTextNode("");
                                classname=classname.replace(/\bcodexrestore\b/,"");
                                replaceNode(original,crumb);
                                crumbs[id]=crumb;
                                replaceNode(restore,original);
                                if ((classname)&&(classname!==oclass)) {
                                    if ((oclass)&&(typeof oclass === "string"))
                                        original.setAttribute("data-savedclass",oclass);
                                    original.className=classname;}
                                if (style!==ostyle) {
                                    if (ostyle) original.setAttribute(
                                        "data-savedstyle",ostyle);
                                    original.setAttribute("style",style);}
                                if ((classname.search)&&(classname.search(/\bcodexpagetop\b/)>=0)) {
                                    markPageTop(original,true);}}
                            else if (original) {
                                saved_ids[id]=original;
                                if (original.id) original.removeAttribute("id");}}
                        if (trace) fdjtLog("Gathering lostids");
                        var lostids=layout.lostids={};
                        var really_lost=lostids._all_ids=[];
                        i=0; lim=dupids.length; while (i<lim) {
                            var dupid=dupids[i++];
                            var orig=idmap[dupid];
                            if (orig) {
                                lostids[dupid]=orig;
                                really_lost.push(dupid);
                                if (orig.id) orig.removeAttribute("id");}}
                        if (trace) fdjtLog("Moving nodes around");
                        var cur=container.childNodes;
                        i=0; lim=cur.length; while (i<lim) curnodes.push(cur[i++]);
                        i=0; while (i<lim) container.removeChild(curnodes[i++]);
                        i=0; lim=addpages.length;
                        while (i<lim) {
                            var addpage=addpages[i++];
                            var scale_elts=
                                getChildren(addpage,"[pagescale],[data-pagescale]");
                            if (scale_elts.length) 
                                pagescales.push({page: addpage, toscale: scale_elts});
                            container.appendChild(addpage);}
                        layout.pages=addpages;
                        dups=layout.dups=newdups;
                        saved_ids._all_ids=all_ids;
                        layout.saved_ids=saved_ids;
                        layout.page=addpages[0];
                        layout.pagenum=parseInt(
                            layout.page.getAttribute("data-pagenum"),10);
                        if (trace)
                            fdjtLog("Moving origin/container back to document");
                        if (ccrumb)
                            ccrumb.parentNode.replaceChild(container,ccrumb);
                        if (bcrumb)
                            bcrumb.parentNode.replaceChild(origin,bcrumb);
                        var splits=getChildren(container,".codexsplitstart");
                        var s=0, n_splits=splits.length; while (s<n_splits) {
                            var split=splits[s++], splitid=split.id;
                            var text=split.getAttribute("data-textsplit");
                            if ((splitid)&&(text)) {
                                textsplits[splitid]=document.createTextNode(text);
                                split.removeAttribute("data-textsplit");}}
                        i=0; lim=pagescales.length; while (i<lim) {
                            var ps=pagescales[i++]; var pg=ps.page;
                            pg.style.opacity=0; pg.style.display='block';
                            scaleToPage(ps.toscale,page_width,page_height);
                            pg.style.display=''; pg.style.opacity='';}}
                    catch (ex) {
                        if (reject) reject(ex); return;}
                    if (trace) fdjtLog("Done restoring layout");
                    if (resolve) return resolve(layout);
                    else return layout;}
                return new Promise(setting_layout);}

            function setLayout(content){
                if (typeof content === "string") 
                    return setSimpleLayout(content);
                else if (!(content.hasOwnProperty('npages'))) 
                    return setSimpleLayout(content.layout);
                else {
                    // Page-by-page layout
                    // !!! This hasn't been tested
                    container.innerHTML=content.layout;
                    var pagenodes=container.childNodes;
                    return fdjtAsync.slowmap(
                        function(pagenode){
                            restorePage(pagenode,content);},
                        pagenodes,
                        {slice: layout.timeslice,
                         space: layout.timeskip});}}
            layout.setLayout=setLayout;

            function restorePage(pagenode,content){
                fetchLayout(content.layout_id,pagenode.id).
                    then(function(pagedata){
                        pagenode.innerHTML=pagedata.content;},
                         pagenode.id);}

            function dropSelected(node,dropsel){
                if (!(dropsel)) return;
                else if (node.nodeType!==1) return;
                else {
                    var children=node.childNodes; var todrop=[];
                    if (!(children)) return;
                    var i=0, lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        if (child.nodeType!==1) continue;
                        if (dropsel.match(child)) todrop.push(child);}
                    i=0; lim=todrop.length; while (i<lim) {
                        node.removeChild(todrop[i++]);}}}

            function prepForRestore(node,dropsel){
                if (node.nodeType!==1) return;
                if (node.id) {
                    var classname=node.className;
                    if ((!((classname)&&
                           (typeof classname === "string")&&
                           (classname.search(/\bcodexdup/g)>=0)))&&
                        (node.id)&&(node.id.search("CODEXTMP")!==0)) {
                        var justref=document.createElement(node.tagName);
                        if (node.id) justref.id=node.id;
                        if (typeof node.className === "string")
                            justref.className=node.className+" codexrestore";
                        else justref.className="codexrestore";
                        if (node.getAttribute("style"))
                            justref.setAttribute(
                                "style",node.getAttribute("style"));
                        node.parentNode.replaceChild(justref,node);
                        if (dropsel) return dropSelected(node,dropsel);
                        else return;}}
                var children=node.childNodes; var todrop=[];
                var i=0, n=children.length;
                while (i<n) {
                    var child=children[i++];
                    if (child.nodeType!==1) continue;
                    else if ((dropsel)&&(dropsel.match(child)))
                        todrop.push(child);
                    else prepForRestore(child,dropsel);}
                i=0; n=todrop.length; while (i<n) {
                    node.removeChild(todrop[i++]);}}
            
            function saveLayout(callback,layout_id){
                var href=window.location.href;
                var qpos=href.indexOf("?"), hashpos=href.indexOf("#");
                var endpos=((qpos>=hashpos)?(qpos):(hashpos));
                if (endpos>0) href=href.slice(0,endpos);
                if (!(layout_id)) layout_id=layout.layout_id||
                    (layout.layout_id=
                     layout.width+"x"+layout.height+"("+href+")");
                if (!(CodexLayout.cache)) return;
                // These will be used for per-page saved layouts
                var copy=container.cloneNode(true);
                var pages=copy.childNodes, i=0, npages=pages.length;
                while (i<npages) {
                    var page=pages[i++];
                    if (page.nodeType===1) {
                        var content=page.childNodes;
                        var j=0, n=content.length;
                        while (j<n) {
                            var node=content[j++];
                            if (node.nodeType===1) {
                                prepForRestore(node,layout.dontsave||false);}}}}
                var splits=getChildren(copy,".codexsplitstart");
                var s=0, n_splits=splits.length; while (s<n_splits) {
                    var split=splits[s++], splitid=split.id;
                    var text=(splitid)&&(textsplits[splitid]);
                    if (text)
                        split.setAttribute("data-textsplit",text.nodeValue);}
                var html=copy.innerHTML;
                try {
                    cacheLayout(layout_id,html,false,false,
                                function(){cachedLayout(layout_id);});
                    callback(layout);}
                catch (ex) {
                    fdjtLog.warn("Couldn't save layout %s: %s",layout_id,ex);
                    return false;}
                return layout_id;}
            this.saveLayout=saveLayout;
            function restoreLayout(arg,donefn,failfn){
                function whendone(){
                    layout.done=fdjtTime();
                    if (donefn) donefn(layout);
                    if ((layout.thenfns)&&(layout.thenfns.length)) {
                        var thenfns=layout.thenfns;
                        var f=0, nfns=thenfns.length; while (f<nfns) {
                            thenfns[f++](layout);}}
                    return layout;}
                var setting=false;
                if (!(arg)) {
                    fdjtLog.warn("Falsy arg %s to restoreLayout",arg);
                    failfn(new Error("Falsy arg to restoreLayout"));
                    return layout;}
                else if (arg.hasOwnProperty('npages')) 
                    setting=layout.setLayout(arg);
                else if (arg.hasOwnProperty('layout'))
                    setting=layout.setLayout(arg.layout);
                else if (arg.indexOf("<")>=0) 
                    setting=layout.setLayout(arg);
                else {
                    var saved_layout=fdjtState.getLocal(arg);
                    if (layout) {
                        return layout.setLayout(saved_layout,whendone);}
                    else return false;}
                return setting.then(whendone).catch(failfn);}
            this.restoreLayout=function(arg){
                function restoring_layout(resolve,reject){
                    restoreLayout(arg,resolve,reject);}
                return new Promise(restoring_layout);};

            /*
              layout.savePages=function(){
              // This is a version which could be used if restore
              // the entire layout takes too long, which doesn't
              // seem to be the case.
              var pages=this.pages; var i=0, npages=pages.length;
              while (i<npages) {
              var page=pages[i++].cloneNode(true);
              var content=page.childNodes;
              var j=0, lim=content.length;
              while (j<lim) {
              var node=content[j++];
              if (node.nodeType===1) prepForRestore(node);}
              fdjtState.setLocal(layout_key+"#"+page.id,page.outerHTML);}};
            */


            // This is for setting individual page content, assuming
            // the page node already exists
            /*
              function setPageContent(content){
              var frag=document.createElement("div");
              frag.innerHTML=content;
              var newpage=frag.firstChild;
              var saved_ids=this.saved_ids||(this.saved_ids={});
              var all_ids=(saved_ids._all_ids)||(saved_ids._all_ids=[]);
              gatherLayoutInfo(newpage,all_ids,dups);
              var i=0, lim=all_ids.length; while (i<lim) {
              var id=all_ids[i++];
              var original=document.getElementById(id);
              if (original) {
              saved_ids[id]=original;
              original.id=null;}}
              var pagenum=parseInt(newpage.getAttribute("data-pagenum"),10);
              var curpage=document.getElementById(newpage.id);
              fdjtDOM.replace(curpage,newpage);
              if (this.page===curpage) this.page=newpage;
              pages[pagenum-1]=newpage;}
            */

            /* Finishing the page */

            var adjust_node=fdjtDOM.scaleToFit.adjust;
            function finishPage(completed) {
                completed.style.display="block";
                var undersize=hasClass(completed,"codexundersize");
                var oversize=hasClass(completed,"codexoversize");
                if (((oversize)||(undersize))) {
                    adjustFonts(completed);
                    if (scale_pages) {
                        var iw=completed.scrollWidth, ih=completed.scrollHeight;
                        var ow=completed.offsetWidth, oh=completed.offsetHeight;
                        var noscale=((oversize)?
                                     ((ih<=oh)&&(iw<=ow)):
                                     ((oh<=ih)&&(ow<=iw)&&
                                      (oh>(0.9*ih))||(ow>(0.9*iw))));
                        if (!(noscale)) {
                            completed.style.height="";
                            adjust_node(completed);}}}
                if (layout.pagedone) layout.pagedone(completed);
                dropClass(completed,"codexworkpage");
                completed.style.display=""; 
                completed.style.height="";}
            this.finishPage=finishPage;

            /* Finishing the overall layout */

            function Finish(){
                for (var dupid in dups)
                    if (dups.hasOwnProperty(dupid)) {
                        var alldups=dups[dupid];
                        var lastdup=alldups[alldups.length-1];
                        var dupstart=document.getElementById(dupid);
                        if (dupstart.tagName==="OL")
                            fixOrderedList([dupstart].concat(alldups));
                        if (dupstart.tagName==="LI") {
                            var dupi=0, ndups=alldups.length;
                            while (dupi<ndups) {
                                var dup=alldups[dupi++];
                                if (!(dup.hasAttribute(dup,"data-savedstyle"))) 
                                    dup.setAttribute(
                                        "data-savedstyle",
                                        dup.getAttribute("style")||"");
                                dup.style.listStyleType="none";}}
                        lastdup.className=lastdup.className.replace(
                                /\bcodexdup\b/,"codexdupend");}
                var middle_dups=getChildren(page,".codexdup");
                if ((middle_dups)&&(middle_dups.length)) {
                    var j=0, dl=middle_dups.length; while (j<dl) {
                        var mdup=middle_dups[j++];
                        stripBottomStyles(mdup);}}
                if (page) {
                    if (pagefn) pagefn.call(layout,page,layout);
                    page.style.height="";
                    dropClass(page,"codexworkpage");}
                var i=0; var lim= pages.length;
                while (i<lim) {
                    var p=pages[i++];
                    this.finishPage(p);}
                layout.done=fdjtTime();
                if ((layout.thenfns)&&(layout.thenfns.length)) {
                    var thenfns=layout.thenfns;
                    var f=0, nfns=thenfns.length; while (f<nfns) {
                        thenfns[f++](layout);}}}
            this.Finish=Finish;

            function fixOrderedList(ol){
                if (ol.length<2) return;
                var olpage=[]; var i=0, lim=ol.length, ntotal=0;
                while (i<lim) {
                    var dup=ol[i++];
                    var page=getParent(dup,".codexpage");
                    var pageno=(page)&&(
                        parseInt(page.getAttribute("data-pagenum"),10));
                    olpage.push({list: dup,pageno:pageno});}
                olpage.sort(function(x,y){
                    if (x.pageno>y.pageno) return 1;
                    else if (x.pageno<y.pageno) return -1;
                    else return 0;});
                i=0; lim=olpage.length; while (i<lim) {
                    var olist=olpage[i++].list;
                    var new_items=countListItems(olist);
                    if (ntotal) addEmptyItems(olist,ntotal);
                    ntotal=ntotal+new_items;}}

            function addEmptyItems(root,count){
                var frag=document.createDocumentFragment();
                while (count>0) {
                    var item=fdjtDOM("LI","empty");
                    item.setAttribute(
                        "style",
                        "visibility: hidden !important; width: 0px !important; height: 0px !important; pointer-events: none;");
                    frag.appendChild(item);
                    count--;}
                if (root.firstChild) root.insertBefore(frag,root.firstChild);
                else root.appendChild(frag);}
            function countListItems(root,count){
                if (!(count)) count=0;
                var children=root.childNodes;
                var i=0, lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===1) {
                        if ((child.tagName==="OL")||
                            (child.tagName==="UL")) return count;
                        else if (child.tagName==="LI") count++;
                        else count=countListItems(child,count);}}
                return count;}

            /* page break predicates */
            
            function forcedBreakBefore(elt,style){
                if ((!(elt))||(elt.nodeType!==1)) return false;
                if (!(style)) style=getStyle(elt);
                return (style.pageBreakBefore==='always');}
            this.forcedBreakBefore=forcedBreakBefore;
            function mustBreakBefore(elt){
                if (forcedBreakBefore(elt)) return true;
                else if ((elt.childNodes)&&(elt.childNodes.length)) {
                    var children=elt.childNodes;
                    var i=0, lim=children.length; while (i<lim) {
                        var child=children[i];
                        if (child.nodeType===3) {
                            if (!(isEmpty(child.nodeValue))) return false;
                            else i++;}
                        else if (child.nodeType===1) 
                            return mustBreakBefore(child);
                        else i++;}
                    return false;}}
            this.mustBreakBefore=mustBreakBefore;
            
            function forcedBreakAfter(elt,style){ 
                if ((!(elt))||(elt.nodeType!==1)) return false;
                if (!(style)) style=getStyle(elt);
                return (style.pageBreakAfter==='always');}
            this.forcedBreakAfter=forcedBreakAfter;
            function mustBreakAfter(elt){
                if (forcedBreakAfter(elt)) return true;
                else if ((elt.childNodes)&&(elt.childNodes.length)) {
                    var children=elt.childNodes;
                    var i=children.length-1; while (i>=0) {
                        var child=children[i];
                        if (child.nodeType===3) {
                            if (!(isEmpty(child.nodeValue))) return false;
                            else i--;}
                        else if (child.nodeType===1) 
                            return mustBreakAfter(child);
                        else i--;}
                    return false;}}
            this.mustBreakAfter=mustBreakAfter;

            function avoidBreakInside(elt,style){
                var lh=getLineHeight(elt,style);
                if ((!(elt))||(elt.nodeType!==1)) return false;
                if (elt.tagName==='IMG') return true;
                if (!(style)) style=getStyle(elt);
                return (style.pageBreakInside==='avoid')||
                    (style.display==='table-row')||
                    ((style.display==="block")&&
                     (elt.childNodes)&&(elt.childNodes.length)&&
                     ((lh)&&((lh*2.5)>elt.offsetHeight)));}
            this.avoidBreakInside=avoidBreakInside;
            function mustBreakInside(elt){
                if (avoidBreakInside(elt)) return false;
                else if ((elt.childNodes)&&(elt.childNodes.length)) {
                    var children=elt.childNodes;
                    var i=0, lim=children.length; while (i<lim) {
                        var child=children[i];
                        if (child.nodeType!==1) i++;
                        else if (forcedBreakBefore(child)) return true;
                        else if (forcedBreakAfter(child)) return true;
                        else if (mustBreakInside(child)) return true;
                        else i++;}
                    return false;}
                else return false;}
            this.mustBreakInside=mustBreakInside;
            
            function avoidBreakBefore(elt,style){
                if ((!(elt))||(elt.nodeType!==1)) return false;
                if (!(style)) style=getStyle(elt);
                return (style.pageBreakBefore==='avoid');}
            this.avoidBreakBefore=avoidBreakBefore;
            function cantBreakBefore(elt){
                if (avoidBreakBefore(elt)) return true;
                else if ((elt.childNodes)&&(elt.childNodes.length)) {
                    var children=elt.childNodes;
                    var i=0, lim=children.length; while (i<lim) {
                        var child=children[i];
                        if (child.nodeType===3) {
                            if (!(isEmpty(child.nodeValue))) return false;
                            else i++;}
                        else if (child.nodeType===1) 
                            return cantBreakBefore(child);
                        else i++;}
                    return false;}}
            this.cantBreakBefore=cantBreakBefore;

            function avoidBreakAfter(elt,style){
                if ((!(elt))||(elt.nodeType!==1)) return false;
                // Avoid breaks after headings
                if (/H\d/.exec(elt.tagName)) return true;
                if (!(style)) style=getStyle(elt);
                // Use the style information
                if (style.pageBreakAfter==='avoid') return true;
                else if ((style.pageBreakAfter)&&
                         (style.pageBreakAfter!=="auto"))
                    return false;
                else return false;}
            this.avoidBreakAfter=avoidBreakAfter;
            function cantBreakAfter(elt){
                if (avoidBreakAfter(elt)) return true;
                else if ((elt.childNodes)&&(elt.childNodes.length)) {
                    var children=elt.childNodes;
                    var i=children.length-1; while (i>=0) {
                        var child=children[i];
                        if (child.nodeType===3) {
                            if (!(isEmpty(child.nodeValue))) return false;
                            else i--;}
                        else if (child.nodeType===1) 
                            return cantBreakAfter(child);
                        else i--;}
                    return false;}}
            this.cantBreakAfter=cantBreakAfter;
            
            function checkSinglePage(elt,style){
                if ((!(elt))||(elt.nodeType!==1)) return false;
                if ((hasClass("codexsinglepage"))||(hasClass("codexfullpage")))
                    return true;
                else if ((singlepages)&&(singlepages.match(elt)))
                    return true;
                else {
                    if (!(style)) style=getStyle(elt);
                    return ((style.pageBreakBefore==='always')&&
                            (style.pageBreakAfter==='always')&&
                            (style.pageBreakInside==='avoid'));}}
            this.checkSinglePage=checkSinglePage;

            function getPage(spec) {
                if (!(spec)) return false;
                else if (typeof spec === 'number')
                    return fdjtID(pageprefix+spec);
                else if (spec.nodeType) {
                    if (hasClass(spec,"codexpage")) return spec;
                    else return getParent(spec,".codexpage");}
                else if (typeof spec === "string")
                    return getPage(fdjtID(spec));
                else {
                    logfn("Can't determine page from %o",spec);
                    return false;}}
            this.getPage=getPage;

            function getDup(node,page){
                if (typeof node === 'string')
                    node=document.getElementById(node);
                if (!(node)) return false;
                if (hasParent(node,page)) return node;
                var nodeid=node.id;
                var duptable=layout.dups;
                var dups=duptable[nodeid];
                var i=0; var lim=dups.length;
                while (i<lim) {
                    if (hasParent(dups[i],page)) return dups[i];
                    else i++;}
                return false;}
            this.getDup=getDup;

            function gotoPage(spec) {
                var newpage=false;
                if (!(spec)) return false;
                else if (typeof spec === 'number')
                    newpage=document.getElementById(pageprefix+spec);
                else if (spec.nodeType) {
                    if (hasClass(spec,"codexpage")) newpage=spec;
                    else newpage=getParent(spec,".codexpage");}
                else if (typeof spec === "string")
                    newpage=getPage(document.getElementById(spec));
                else {
                    logfn("Can't determine page from %o",spec);
                    return false;}
                if (!(newpage)) return;
                var curpages=container.getElementsByClassName('curpage');
                if (curpages.length) dropClass(toArray(curpages),"curpage");
                addClass(newpage,"curpage");}
            this.gotoPage=gotoPage;

            this.Revert=function(){
                var i, lim;
                if (this.saved_ids) {
                    // This means that the content was explicitly set,
                    //  so we just need to restore the saved ids and clear
                    //  out the container to revert.
                    var saved=this.saved_ids, allids=saved._all_ids;
                    var crumbs=this.crumbs;
                    i=0; lim=allids.length; while (i<lim) {
                        var id=allids[i++], original;
                        if (crumbs[id]) {
                            original=document.getElementById(id);
                            var oclass=original.getAttribute("data-savedclass");
                            var ostyle=original.getAttribute("data-savedstyle");
                            var crumb=crumbs[id];
                            if (oclass) {
                                original.className=oclass;
                                original.removeAttribute("data-savedclass");}
                            if (ostyle) {
                                original.setAttribute("style",ostyle);
                                original.removeAttribute("data-savedstyle");}
                            crumb.parentNode.replaceChild(original,crumb);}
                        else if (saved[id]) {
                            original=saved[id]; if (id) original.id=id;}
                        else {}}
                    var lost=this.lostids, lostids=lost._all_ids;
                    i=0; lim=lostids.length; while (i<lim) {
                        var lostid=lostids[i++];
                        if (lostid) lost[lostid].id=lostid;}
                    this.saved_ids={}; this.dups={}; this.lostids={};
                    return;}
                // Remove any scaleboxes (save the children)
                fdjtDOM.scaleToFit.revertAll();
                revertLayout(this);};

            /* Finally return the layout */
            return this;}

        CodexLayout.timeslice=80;
        CodexLayout.timeskip=10;

        CodexLayout.tracelevel=0;
        CodexLayout.prototype.getDups=function getDups4ID(id){
            if (!(id)) return [];
            else if (id.nodeType) id=id.id;
            var base=fdjtID(id);
            var dups=this.dups[id];
            if (dups) return [base].concat(dups);
            else return false;};
        
        CodexLayout.prototype.getLayoutInfo=function getLayoutInfo(){
            var allblocks=this.allmoves;
            var npages=this.pages.length;
            var pages=new Array(npages+1);
            var pn=0; while (pn<=npages) pages[pn++]=[];
            var bn=0, blim=allblocks.length; while (bn<blim) {
                var block=allblocks[bn++];
                var page=getParent(block,".codexpage");
                if (page) {
                    var num=parseInt(page.getAttribute("data-pagenum"),10);
                    if (!(pages[num]))
                        fdjtLog.warn("weird page number: %o",num);
                    else {
                        var info={block: block};
                        if (block.id) info.id=block.id;
                        if (block.className) info.className=block.className;
                        if (block.getAttribute("data-baseid"))
                            info.baseid=block.getAttribute("data-baseid");
                        pages[num].push(info);}}
                else fdjtLog.warn("Can't find page for %o",block);}
            return pages;};

        CodexLayout.prototype.getLayoutBlocks=function getLayoutBlocks(){
            var allblocks=this.allblocks;
            var blockinfo=[];
            var i=0, lim=allblocks.length;
            while (i<lim) {
                var block=allblocks[i++];
                var page=getParent(block,".codexpage");
                var num=parseInt(page.getAttribute("data-pagenum"),10);
                var info={pagenum: num};
                var classname=block.className;
                if (block.id) info.id=block.id;
                if (typeof classname !== "string") {}
                else if (classname.search(/\bcodexdup/g)>=0) 
                    info.html=block.outerHTML;
                else {
                    if (block.id) info.id=block.id;
                    if (classname.search(/\bcodexpagetop\b/)>=0)
                        info.pagetop=true;
                    if (classname.search(/\bcodexcantsplit\b/)>=0)
                        info.cantsplit=true;}
                blockinfo.push(info);}
            return {blocks: blockinfo, npages: this.pages.length,
                    height: this.height, width: this.width,
                    break_blocks: this.break_blocks};};

        /*
        CodexLayout.prototype.then=function(callback){
            if (this.done) return callback(this);
            else this.thenfns.push(callback);}; */

        CodexLayout.cache=2;

        var ondbinit=false;

        function useIndexedDB(dbname){
            if (!(dbname)) {
                var doinit=ondbinit; ondbinit=false;
                fdjtLog("Not using indexedDB for layouts");
                CodexLayout.layoutDB=layoutDB=window.localStorage;
                if (doinit) doinit();
                return;}
            CodexLayout.dbname=dbname;
            RefDB.useIndexedDB(dbname,1,function(db){
                db.createObjectStore("layouts",{keyPath: "layout_id"});})
                .then(function(db){
                    var doinit=ondbinit; ondbinit=false;
                    CodexLayout.layoutDB=layoutDB=db;
                    CodexLayout.cache=7;
                    if (doinit) doinit();})
                .catch(function(trouble){
                    var doinit=ondbinit; ondbinit=false;
                    fdjtLog("indexedDB failed: %o",trouble);
                    // Fall back to local storage 
                    CodexLayout.layoutDB=layoutDB=window.localStorage;
                    if (doinit) doinit();});}
        CodexLayout.useIndexedDB=useIndexedDB;
        
        if (indexedDB) {
            fdjt.addInit(function(){
                if (!(CodexLayout.dbname)) {
                    CodexLayout.dbname="codexlayout";
                    useIndexedDB("codexlayout");}},
                         "CodexLayoutCache");}
        else {
            var doinit=ondbinit; ondbinit=false;
            if (window.localStorage) {
                CodexLayout.layoutDB=layoutDB=window.localStorage;
                if (doinit) doinit();}
            else {
                CodexLayout.layoutDB=layoutDB=false;
                if (doinit) doinit();}}
     
        function cacheLayout(layout_id,content,pages,ondone){
            if (typeof layoutDB === "undefined") 
                ondbinit=function(){cacheLayout(layout_id,content);};
            else if (!(layoutDB)) return;
            else if ((window.Storage)&&(layoutDB instanceof window.Storage)) {
                setLocal(layout_id,content);
                if (ondone) ondone();}
            else if (window.indexedDB) {
                var txn=layoutDB.transaction(["layouts"],"readwrite");
                var storage=txn.objectStore("layouts"), req;
                req=storage.put({layout_id: layout_id,layout: content});
                req.onerror=function(event){
                    fdjtLog("Error saving layout %s: %o",
                            layout_id,event.target.errorCode);};
                req.onsuccess=function(event){
                    event=false; // ignored
                    if (ondone) ondone();
                    fdjtLog("Layout %s cached",layout_id);};}
            else CodexLayout.layoutDB=layoutDB=window.localStorage||false;}
        CodexLayout.cacheLayout=cacheLayout;
        function dropLayout(layout_id){
            var layout=false;
            if (!(layoutDB)) {}
            else if ((window.Storage)&&
                     (layoutDB instanceof window.Storage)) {
                var dropLocal=fdjtState.dropLocal;
                dropLocal(layout_id);
                droppedLayout(layout_id);}
            else {
                var txn=layoutDB.transaction(["layouts"],"readwrite");
                var storage=txn.objectStore("layouts");
                var req=storage.get(layout_id);
                var allDone=function allDone(event){
                    event=false; // ignored
                    droppedLayout(layout_id);};
                var whoops=function whoops(event) {
                    event=false; // ignored
                    fdjtLog("Error removing laytout %s",layout_id);};
                var dropRoot=function dropRoot(){
                    req=storage['delete'](layout_id);
                    req.onerror=whoops; req.onsuccess=allDone;};
                req.onerror=whoops;
                req.onsuccess=function(evt){
                    layout=((evt.target)&&(evt.target.result));
                    dropRoot();};}}
        CodexLayout.dropLayout=dropLayout;
        function fetchLayout(layout_id,callback,onerr){
            var getLocal=fdjtState.getLocal;
            var content=false, layout_key=layout_id;
            if (typeof layoutDB === "undefined") 
                ondbinit=function(){fetchLayout(layout_id,callback,onerr);};
            else if (!(layoutDB)) { 
                if (onerr) return onerr("No layout DB");
                else if (callback) return callback(false);
                else return false;}
            else if ((window.Storage)&&(layoutDB instanceof window.Storage)) {
                content=getLocal(layout_id)||false;
                if (content) cachedLayout(layout_id);
                setTimeout(function(){callback(content);},1);}
            else if (layoutDB) {
                var txn=layoutDB.transaction(["layouts"]);
                var storage=txn.objectStore("layouts");
                var req=(storage)&&(storage.get(layout_key));
                if (!(req)) onerr("DB error");
                req.onsuccess=function(evt){
                    var target=evt.target;
                    var result=((target)&&(target.result));
                    if (!(target)) onerr(false);
                    if (result) cachedLayout(layout_id);
                    if (!(result)) callback(false);
                    else callback(result.layout);};
                req.onerror=function(event){onerr(event);};}
            else if (window.localStorage) {
                content=fdjtState.getLocal(layout_key)||false;
                if (content) cachedLayout(layout_id);
                setTimeout(function(){callback(content);},0);}
            else if (onerr)
                return onerr(false);
            else if (callback)
                return callback(false);
            else return false;}
        CodexLayout.fetchLayout=function(layout_id){
            function fetching_layout(resolve,reject){
                return fetchLayout(layout_id,resolve,reject);}
            return new Promise(fetching_layout);};
        
        CodexLayout.clearLayouts=function(){
            var layouts=fdjtState.getLocal("fdjtCodex.layouts",true);
            var i=0, lim=((layouts)&&(layouts.length)); 
            if (layouts) {
                while (i<lim) dropLayout(layouts[i++]);
                fdjtState.dropLocal("fdjtCodex.layouts");}};

        function fetchAll(callback){
            if (!(layoutDB)) return false;
            else {
                var txn=layoutDB.transaction(["layouts"],"read");
                var storage=txn.objectStore("layouts");
                var layout_ids=[];
                storage.openCursor().onsuccess=function(evt){
                    var cursor = evt.target.result;
                    if (cursor) {
                        layout_ids.push(cursor.key);
                        cursor['continue']();}
                    else callback(layout_ids);};}}
        CodexLayout.fetchAll=fetchAll;
        CodexLayout.clearAll=function(spec){
            fetchAll(function(layout_ids){
                var todrop=[]; var i=0, lim=layout_ids.length;
                if (!(lim)) {fdjtLog.warn("No layouts"); return;}
                else if (!(spec)) todrop=layout_ids;
                else while (i<lim) {
                    var id=layout_ids[i++];
                    if (id.search(spec)>=0) todrop.push(id);}
                if (todrop.length===0) {
                    fdjtLog.warn("No layouts match %s",spec);
                    return;}
                else if (spec)
                    fdjtLog.warn("Dropping %d layouts matching %s",
                                 todrop.length,spec);
                else fdjtLog.warn("Dropping %d layouts",todrop.length);
                i=0; lim=todrop.length; while (i<lim) {
                    fdjtLog.warn("Dropping layout %s",todrop[i]);
                    dropLayout(todrop[i++]);}});};
        function cachedLayout(layout_id){
            setLocal("fdjtCodex.layout("+layout_id+")",layout_id);
            pushLocal("fdjtCodex.layouts",layout_id);}
        function droppedLayout(layout_id){
            dropLocal("fdjtCodex.layout("+layout_id+")",layout_id);
            removeLocal("fdjtCodex.layouts",layout_id);
            if (CodexLayout.trace) fdjtLog("Layout %s removed",layout_id);}
        
        CodexLayout.dbname="codexlayout";

        return CodexLayout;})();


/* Mini Manual */
/*
  var layout=new CodexLayout();
  layout.addContent(node);
  layout.Finish();
  layout.Revert();

  var layout=new CodexLayout({
  page_width: 500, page_height: 500, // Dimensions
  // Where to add new pages; by default this creates a
  //  new div#CODEXPAGES.codexpages at the bottom of the BODY
  container: document.getElementByID("MYPAGES"),
  // Prefix for page element IDs, e.g. page 42 would have id MYCODEXPAGE42
  pageprefix: "MYCODEXPAGE",
  logfn: console.log, // how to log notable events
  // Layout rules:
  // Always put H1 elements on a new page
  forcebreakbefore: "H1",
  // Always follow div.signature with a page break
  forcebreakafter: "div.signature",
  // Avoid breaking inside
  avoidbreakinside: "div.code",
  // Avoid breaking before these elements
  avoidbreakbefore: "div.signature,div.attribution",
  // Avoid breaking after these elements
  avoidbreakafter: "h1,h2,h3,h4,h5,h6,h7",
  // Put this element on a page by itself
  codexfullpage: "div.titlepage",
  // Put this element on a page by itself, but don't interrupt the
  // narrative flow
  codexfloatpage: "div.illustration"});
*/

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
var Markdown;

if (typeof exports === "object" && typeof require === "function") // we're in a CommonJS (e.g. Node.js) module
    Markdown = exports;
else
    Markdown = {};
    
// The following text is included for historical reasons, but should
// be taken with a pinch of salt; it's not all true anymore.

//
// Wherever possible, Showdown is a straight, line-by-line port
// of the Perl version of Markdown.
//
// This is not a normal parser design; it's basically just a
// series of string substitutions.  It's hard to read and
// maintain this way,  but keeping Showdown close to the original
// design makes it easier to port new features.
//
// More importantly, Showdown behaves like markdown.pl in most
// edge cases.  So web applications can do client-side preview
// in Javascript, and then build identical HTML on the server.
//
// This port needs the new RegExp functionality of ECMA 262,
// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers
// should do fine.  Even with the new regular expression features,
// We do a lot of work to emulate Perl's regex functionality.
// The tricky changes in this file mostly have the "attacklab:"
// label.  Major or self-explanatory changes don't.
//
// Smart diff tools like Araxis Merge will be able to match up
// this file with markdown.pl in a useful way.  A little tweaking
// helps: in a copy of markdown.pl, replace "#" with "//" and
// replace "$text" with "text".  Be sure to ignore whitespace
// and line endings.
//


//
// Usage:
//
//   var text = "Markdown *rocks*.";
//
//   var converter = new Markdown.Converter();
//   var html = converter.makeHtml(text);
//
//   alert(html);
//
// Note: move the sample code to the bottom of this
// file before uncommenting it.
//

(function () {

    function identity(x) { return x; }
    function returnFalse(x) { return false; }

    function HookCollection() { }

    HookCollection.prototype = {

        chain: function (hookname, func) {
            var original = this[hookname];
            if (!original)
                throw new Error("unknown hook " + hookname);

            if (original === identity)
                this[hookname] = func;
            else
                this[hookname] = function (text) {
                    var args = Array.prototype.slice.call(arguments, 0);
                    args[0] = original.apply(null, args);
                    return func.apply(null, args);
                };
        },
        set: function (hookname, func) {
            if (!this[hookname])
                throw new Error("unknown hook " + hookname);
            this[hookname] = func;
        },
        addNoop: function (hookname) {
            this[hookname] = identity;
        },
        addFalse: function (hookname) {
            this[hookname] = returnFalse;
        }
    };

    Markdown.HookCollection = HookCollection;

    // g_urls and g_titles allow arbitrary user-entered strings as keys. This
    // caused an exception (and hence stopped the rendering) when the user entered
    // e.g. [push] or [__proto__]. Adding a prefix to the actual key prevents this
    // (since no builtin property starts with "s_"). See
    // http://meta.stackoverflow.com/questions/64655/strange-wmd-bug
    // (granted, switching from Array() to Object() alone would have left only __proto__
    // to be a problem)
    function SaveHash() { }
    SaveHash.prototype = {
        set: function (key, value) {
            this["s_" + key] = value;
        },
        get: function (key) {
            return this["s_" + key];
        }
    };

    Markdown.Converter = function () {
        var pluginHooks = this.hooks = new HookCollection();
        
        // given a URL that was encountered by itself (without markup), should return the link text that's to be given to this link
        pluginHooks.addNoop("plainLinkText");
        
        // called with the orignal text as given to makeHtml. The result of this plugin hook is the actual markdown source that will be cooked
        pluginHooks.addNoop("preConversion");
        
        // called with the text once all normalizations have been completed (tabs to spaces, line endings, etc.), but before any conversions have
        pluginHooks.addNoop("postNormalization");
        
        // Called with the text before / after creating block elements like code blocks and lists. Note that this is called recursively
        // with inner content, e.g. it's called with the full text, and then only with the content of a blockquote. The inner
        // call will receive outdented text.
        pluginHooks.addNoop("preBlockGamut");
        pluginHooks.addNoop("postBlockGamut");
        
        // called with the text of a single block element before / after the span-level conversions (bold, code spans, etc.) have been made
        pluginHooks.addNoop("preSpanGamut");
        pluginHooks.addNoop("postSpanGamut");
        
        // called with the final cooked HTML code. The result of this plugin hook is the actual output of makeHtml
        pluginHooks.addNoop("postConversion");

        //
        // Private state of the converter instance:
        //

        // Global hashes, used by various utility routines
        var g_urls;
        var g_titles;
        var g_html_blocks;

        // Used to track when we're inside an ordered or unordered list
        // (see _ProcessListItems() for details):
        var g_list_level;

        this.makeHtml = function (text) {

            //
            // Main function. The order in which other subs are called here is
            // essential. Link and image substitutions need to happen before
            // _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>
            // and <img> tags get encoded.
            //

            // This will only happen if makeHtml on the same converter instance is called from a plugin hook.
            // Don't do that.
            if (g_urls)
                throw new Error("Recursive call to converter.makeHtml");
        
            // Create the private state objects.
            g_urls = new SaveHash();
            g_titles = new SaveHash();
            g_html_blocks = [];
            g_list_level = 0;

            text = pluginHooks.preConversion(text);

            // attacklab: Replace ~ with ~T
            // This lets us use tilde as an escape char to avoid md5 hashes
            // The choice of character is arbitray; anything that isn't
            // magic in Markdown will work.
            text = text.replace(/~/g, "~T");

            // attacklab: Replace $ with ~D
            // RegExp interprets $ as a special character
            // when it's in a replacement string
            text = text.replace(/\$/g, "~D");

            // Standardize line endings
            text = text.replace(/\r\n/g, "\n"); // DOS to Unix
            text = text.replace(/\r/g, "\n"); // Mac to Unix

            // Make sure text begins and ends with a couple of newlines:
            text = "\n\n" + text + "\n\n";

            // Convert all tabs to spaces.
            text = _Detab(text);

            // Strip any lines consisting only of spaces and tabs.
            // This makes subsequent regexen easier to write, because we can
            // match consecutive blank lines with /\n+/ instead of something
            // contorted like /[ \t]*\n+/ .
            text = text.replace(/^[ \t]+$/mg, "");
            
            text = pluginHooks.postNormalization(text);

            // Turn block-level HTML blocks into hash entries
            text = _HashHTMLBlocks(text);

            // Strip link definitions, store in hashes.
            text = _StripLinkDefinitions(text);

            text = _RunBlockGamut(text);

            text = _UnescapeSpecialChars(text);

            // attacklab: Restore dollar signs
            text = text.replace(/~D/g, "$$");

            // attacklab: Restore tildes
            text = text.replace(/~T/g, "~");

            text = pluginHooks.postConversion(text);

            g_html_blocks = g_titles = g_urls = null;

            return text;
        };

        function _StripLinkDefinitions(text) {
            //
            // Strips link definitions from text, stores the URLs and titles in
            // hash references.
            //

            // Link defs are in the form: ^[id]: url "optional title"

            /*
            text = text.replace(/
                ^[ ]{0,3}\[(.+)\]:  // id = $1  attacklab: g_tab_width - 1
                [ \t]*
                \n?                 // maybe *one* newline
                [ \t]*
                <?(\S+?)>?          // url = $2
                (?=\s|$)            // lookahead for whitespace instead of the lookbehind removed below
                [ \t]*
                \n?                 // maybe one newline
                [ \t]*
                (                   // (potential) title = $3
                    (\n*)           // any lines skipped = $4 attacklab: lookbehind removed
                    [ \t]+
                    ["(]
                    (.+?)           // title = $5
                    [")]
                    [ \t]*
                )?                  // title is optional
                (?:\n+|$)
            /gm, function(){...});
            */

            text = text.replace(/^[ ]{0,3}\[(.+)\]:[ \t]*\n?[ \t]*<?(\S+?)>?(?=\s|$)[ \t]*\n?[ \t]*((\n*)["(](.+?)[")][ \t]*)?(?:\n+)/gm,
                function (wholeMatch, m1, m2, m3, m4, m5) {
                    m1 = m1.toLowerCase();
                    g_urls.set(m1, _EncodeAmpsAndAngles(m2));  // Link IDs are case-insensitive
                    if (m4) {
                        // Oops, found blank lines, so it's not a title.
                        // Put back the parenthetical statement we stole.
                        return m3;
                    } else if (m5) {
                        g_titles.set(m1, m5.replace(/"/g, "&quot;"));
                    }

                    // Completely remove the definition from the text
                    return "";
                }
            );

            return text;
        }

        function _HashHTMLBlocks(text) {

            // Hashify HTML blocks:
            // We only want to do this for block-level HTML tags, such as headers,
            // lists, and tables. That's because we still want to wrap <p>s around
            // "paragraphs" that are wrapped in non-block-level tags, such as anchors,
            // phrase emphasis, and spans. The list of tags we're looking for is
            // hard-coded:
            var block_tags_a = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del"
            var block_tags_b = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math"

            // First, look for nested blocks, e.g.:
            //   <div>
            //     <div>
            //     tags for inner block must be indented.
            //     </div>
            //   </div>
            //
            // The outermost tags must start at the left margin for this to match, and
            // the inner nested divs must be indented.
            // We need to do this before the next, more liberal match, because the next
            // match will start at the first `<div>` and stop at the first `</div>`.

            // attacklab: This regex can be expensive when it fails.

            /*
            text = text.replace(/
                (                       // save in $1
                    ^                   // start of line  (with /m)
                    <($block_tags_a)    // start tag = $2
                    \b                  // word break
                                        // attacklab: hack around khtml/pcre bug...
                    [^\r]*?\n           // any number of lines, minimally matching
                    </\2>               // the matching end tag
                    [ \t]*              // trailing spaces/tabs
                    (?=\n+)             // followed by a newline
                )                       // attacklab: there are sentinel newlines at end of document
            /gm,function(){...}};
            */
            text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm, hashElement);

            //
            // Now match more liberally, simply from `\n<tag>` to `</tag>\n`
            //

            /*
            text = text.replace(/
                (                       // save in $1
                    ^                   // start of line  (with /m)
                    <($block_tags_b)    // start tag = $2
                    \b                  // word break
                                        // attacklab: hack around khtml/pcre bug...
                    [^\r]*?             // any number of lines, minimally matching
                    .*</\2>             // the matching end tag
                    [ \t]*              // trailing spaces/tabs
                    (?=\n+)             // followed by a newline
                )                       // attacklab: there are sentinel newlines at end of document
            /gm,function(){...}};
            */
            text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\b[^\r]*?.*<\/\2>[ \t]*(?=\n+)\n)/gm, hashElement);

            // Special case just for <hr />. It was easier to make a special case than
            // to make the other regex more complicated.  

            /*
            text = text.replace(/
                \n                  // Starting after a blank line
                [ ]{0,3}
                (                   // save in $1
                    (<(hr)          // start tag = $2
                        \b          // word break
                        ([^<>])*?
                    \/?>)           // the matching end tag
                    [ \t]*
                    (?=\n{2,})      // followed by a blank line
                )
            /g,hashElement);
            */
            text = text.replace(/\n[ ]{0,3}((<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g, hashElement);

            // Special case for standalone HTML comments:

            /*
            text = text.replace(/
                \n\n                                            // Starting after a blank line
                [ ]{0,3}                                        // attacklab: g_tab_width - 1
                (                                               // save in $1
                    <!
                    (--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)   // see http://www.w3.org/TR/html-markup/syntax.html#comments and http://meta.stackoverflow.com/q/95256
                    >
                    [ \t]*
                    (?=\n{2,})                                  // followed by a blank line
                )
            /g,hashElement);
            */
            text = text.replace(/\n\n[ ]{0,3}(<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>[ \t]*(?=\n{2,}))/g, hashElement);

            // PHP and ASP-style processor instructions (<?...?> and <%...%>)

            /*
            text = text.replace(/
                (?:
                    \n\n            // Starting after a blank line
                )
                (                   // save in $1
                    [ ]{0,3}        // attacklab: g_tab_width - 1
                    (?:
                        <([?%])     // $2
                        [^\r]*?
                        \2>
                    )
                    [ \t]*
                    (?=\n{2,})      // followed by a blank line
                )
            /g,hashElement);
            */
            text = text.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g, hashElement);

            return text;
        }

        function hashElement(wholeMatch, m1) {
            var blockText = m1;

            // Undo double lines
            blockText = blockText.replace(/^\n+/, "");

            // strip trailing blank lines
            blockText = blockText.replace(/\n+$/g, "");

            // Replace the element text with a marker ("~KxK" where x is its key)
            blockText = "\n\n~K" + (g_html_blocks.push(blockText) - 1) + "K\n\n";

            return blockText;
        }
        
        var blockGamutHookCallback = function (t) { return _RunBlockGamut(t); }

        function _RunBlockGamut(text, doNotUnhash) {
            //
            // These are all the transformations that form block-level
            // tags like paragraphs, headers, and list items.
            //
            
            text = pluginHooks.preBlockGamut(text, blockGamutHookCallback);
            
            text = _DoHeaders(text);

            // Do Horizontal Rules:
            var replacement = "<hr />\n";
            text = text.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm, replacement);
            text = text.replace(/^[ ]{0,2}([ ]?-[ ]?){3,}[ \t]*$/gm, replacement);
            text = text.replace(/^[ ]{0,2}([ ]?_[ ]?){3,}[ \t]*$/gm, replacement);

            text = _DoLists(text);
            text = _DoCodeBlocks(text);
            text = _DoBlockQuotes(text);
            
            text = pluginHooks.postBlockGamut(text, blockGamutHookCallback);

            // We already ran _HashHTMLBlocks() before, in Markdown(), but that
            // was to escape raw HTML in the original Markdown source. This time,
            // we're escaping the markup we've just created, so that we don't wrap
            // <p> tags around block-level tags.
            text = _HashHTMLBlocks(text);
            text = _FormParagraphs(text, doNotUnhash);

            return text;
        }

        function _RunSpanGamut(text) {
            //
            // These are all the transformations that occur *within* block-level
            // tags like paragraphs, headers, and list items.
            //

            text = pluginHooks.preSpanGamut(text);
            
            text = _DoCodeSpans(text);
            text = _EscapeSpecialCharsWithinTagAttributes(text);
            text = _EncodeBackslashEscapes(text);

            // Process anchor and image tags. Images must come first,
            // because ![foo][f] looks like an anchor.
            text = _DoImages(text);
            text = _DoAnchors(text);

            // Make links out of things like `<http://example.com/>`
            // Must come after _DoAnchors(), because you can use < and >
            // delimiters in inline links like [this](<url>).
            text = _DoAutoLinks(text);
            
            text = text.replace(/~P/g, "://"); // put in place to prevent autolinking; reset now
            
            text = _EncodeAmpsAndAngles(text);
            text = _DoItalicsAndBold(text);

            // Do hard breaks:
            text = text.replace(/  +\n/g, " <br>\n");
            
            text = pluginHooks.postSpanGamut(text);

            return text;
        }

        function _EscapeSpecialCharsWithinTagAttributes(text) {
            //
            // Within tags -- meaning between < and > -- encode [\ ` * _] so they
            // don't conflict with their use in Markdown for code, italics and strong.
            //

            // Build a regex to find HTML tags and comments.  See Friedl's 
            // "Mastering Regular Expressions", 2nd Ed., pp. 200-201.

            // SE: changed the comment part of the regex

            var regex = /(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>)/gi;

            text = text.replace(regex, function (wholeMatch) {
                var tag = wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`");
                tag = escapeCharacters(tag, wholeMatch.charAt(1) == "!" ? "\\`*_/" : "\\`*_"); // also escape slashes in comments to prevent autolinking there -- http://meta.stackoverflow.com/questions/95987
                return tag;
            });

            return text;
        }

        function _DoAnchors(text) {
            //
            // Turn Markdown link shortcuts into XHTML <a> tags.
            //
            //
            // First, handle reference-style links: [link text] [id]
            //

            /*
            text = text.replace(/
                (                           // wrap whole match in $1
                    \[
                    (
                        (?:
                            \[[^\]]*\]      // allow brackets nested one level
                            |
                            [^\[]           // or anything else
                        )*
                    )
                    \]

                    [ ]?                    // one optional space
                    (?:\n[ ]*)?             // one optional newline followed by spaces

                    \[
                    (.*?)                   // id = $3
                    \]
                )
                ()()()()                    // pad remaining backreferences
            /g, writeAnchorTag);
            */
            text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeAnchorTag);

            //
            // Next, inline-style links: [link text](url "optional title")
            //

            /*
            text = text.replace(/
                (                           // wrap whole match in $1
                    \[
                    (
                        (?:
                            \[[^\]]*\]      // allow brackets nested one level
                            |
                            [^\[\]]         // or anything else
                        )*
                    )
                    \]
                    \(                      // literal paren
                    [ \t]*
                    ()                      // no id, so leave $3 empty
                    <?(                     // href = $4
                        (?:
                            \([^)]*\)       // allow one level of (correctly nested) parens (think MSDN)
                            |
                            [^()\s]
                        )*?
                    )>?                
                    [ \t]*
                    (                       // $5
                        (['"])              // quote char = $6
                        (.*?)               // Title = $7
                        \6                  // matching quote
                        [ \t]*              // ignore any spaces/tabs between closing quote and )
                    )?                      // title is optional
                    \)
                )
            /g, writeAnchorTag);
            */

            text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?((?:\([^)]*\)|[^()\s])*?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeAnchorTag);

            //
            // Last, handle reference-style shortcuts: [link text]
            // These must come last in case you've also got [link test][1]
            // or [link test](/foo)
            //

            /*
            text = text.replace(/
                (                   // wrap whole match in $1
                    \[
                    ([^\[\]]+)      // link text = $2; can't contain '[' or ']'
                    \]
                )
                ()()()()()          // pad rest of backreferences
            /g, writeAnchorTag);
            */
            text = text.replace(/(\[([^\[\]]+)\])()()()()()/g, writeAnchorTag);

            return text;
        }

        function writeAnchorTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
            if (m7 == undefined) m7 = "";
            var whole_match = m1;
            var link_text = m2.replace(/:\/\//g, "~P"); // to prevent auto-linking withing the link. will be converted back after the auto-linker runs
            var link_id = m3.toLowerCase();
            var url = m4;
            var title = m7;

            if (url == "") {
                if (link_id == "") {
                    // lower-case and turn embedded newlines into spaces
                    link_id = link_text.toLowerCase().replace(/ ?\n/g, " ");
                }
                url = "#" + link_id;

                if (g_urls.get(link_id) != undefined) {
                    url = g_urls.get(link_id);
                    if (g_titles.get(link_id) != undefined) {
                        title = g_titles.get(link_id);
                    }
                }
                else {
                    if (whole_match.search(/\(\s*\)$/m) > -1) {
                        // Special case for explicit empty url
                        url = "";
                    } else {
                        return whole_match;
                    }
                }
            }
            url = encodeProblemUrlChars(url);
            url = escapeCharacters(url, "*_");
            var result = "<a href=\"" + url + "\"";

            if (title != "") {
                title = attributeEncode(title);
                title = escapeCharacters(title, "*_");
                result += " title=\"" + title + "\"";
            }

            result += ">" + link_text + "</a>";

            return result;
        }

        function _DoImages(text) {
            //
            // Turn Markdown image shortcuts into <img> tags.
            //

            //
            // First, handle reference-style labeled images: ![alt text][id]
            //

            /*
            text = text.replace(/
                (                   // wrap whole match in $1
                    !\[
                    (.*?)           // alt text = $2
                    \]

                    [ ]?            // one optional space
                    (?:\n[ ]*)?     // one optional newline followed by spaces

                    \[
                    (.*?)           // id = $3
                    \]
                )
                ()()()()            // pad rest of backreferences
            /g, writeImageTag);
            */
            text = text.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeImageTag);

            //
            // Next, handle inline images:  ![alt text](url "optional title")
            // Don't forget: encode * and _

            /*
            text = text.replace(/
                (                   // wrap whole match in $1
                    !\[
                    (.*?)           // alt text = $2
                    \]
                    \s?             // One optional whitespace character
                    \(              // literal paren
                    [ \t]*
                    ()              // no id, so leave $3 empty
                    <?(\S+?)>?      // src url = $4
                    [ \t]*
                    (               // $5
                        (['"])      // quote char = $6
                        (.*?)       // title = $7
                        \6          // matching quote
                        [ \t]*
                    )?              // title is optional
                    \)
                )
            /g, writeImageTag);
            */
            text = text.replace(/(!\[(.*?)\]\s?\([ \t]*()<?(\S+?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeImageTag);

            return text;
        }
        
        function attributeEncode(text) {
            // unconditionally replace angle brackets here -- what ends up in an attribute (e.g. alt or title)
            // never makes sense to have verbatim HTML in it (and the sanitizer would totally break it)
            return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
        }

        function writeImageTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
            var whole_match = m1;
            var alt_text = m2;
            var link_id = m3.toLowerCase();
            var url = m4;
            var title = m7;

            if (!title) title = "";

            if (url == "") {
                if (link_id == "") {
                    // lower-case and turn embedded newlines into spaces
                    link_id = alt_text.toLowerCase().replace(/ ?\n/g, " ");
                }
                url = "#" + link_id;

                if (g_urls.get(link_id) != undefined) {
                    url = g_urls.get(link_id);
                    if (g_titles.get(link_id) != undefined) {
                        title = g_titles.get(link_id);
                    }
                }
                else {
                    return whole_match;
                }
            }
            
            alt_text = escapeCharacters(attributeEncode(alt_text), "*_[]()");
            url = escapeCharacters(url, "*_");
            var result = "<img src=\"" + url + "\" alt=\"" + alt_text + "\"";

            // attacklab: Markdown.pl adds empty title attributes to images.
            // Replicate this bug.

            //if (title != "") {
            title = attributeEncode(title);
            title = escapeCharacters(title, "*_");
            result += " title=\"" + title + "\"";
            //}

            result += " />";

            return result;
        }

        function _DoHeaders(text) {

            // Setext-style headers:
            //  Header 1
            //  ========
            //  
            //  Header 2
            //  --------
            //
            text = text.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm,
                function (wholeMatch, m1) { return "<h1>" + _RunSpanGamut(m1) + "</h1>\n\n"; }
            );

            text = text.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm,
                function (matchFound, m1) { return "<h2>" + _RunSpanGamut(m1) + "</h2>\n\n"; }
            );

            // atx-style headers:
            //  # Header 1
            //  ## Header 2
            //  ## Header 2 with closing hashes ##
            //  ...
            //  ###### Header 6
            //

            /*
            text = text.replace(/
                ^(\#{1,6})      // $1 = string of #'s
                [ \t]*
                (.+?)           // $2 = Header text
                [ \t]*
                \#*             // optional closing #'s (not counted)
                \n+
            /gm, function() {...});
            */

            text = text.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm,
                function (wholeMatch, m1, m2) {
                    var h_level = m1.length;
                    return "<h" + h_level + ">" + _RunSpanGamut(m2) + "</h" + h_level + ">\n\n";
                }
            );

            return text;
        }

        function _DoLists(text, isInsideParagraphlessListItem) {
            //
            // Form HTML ordered (numbered) and unordered (bulleted) lists.
            //

            // attacklab: add sentinel to hack around khtml/safari bug:
            // http://bugs.webkit.org/show_bug.cgi?id=11231
            text += "~0";

            // Re-usable pattern to match any entirel ul or ol list:

            /*
            var whole_list = /
                (                                   // $1 = whole list
                    (                               // $2
                        [ ]{0,3}                    // attacklab: g_tab_width - 1
                        ([*+-]|\d+[.])              // $3 = first list item marker
                        [ \t]+
                    )
                    [^\r]+?
                    (                               // $4
                        ~0                          // sentinel for workaround; should be $
                        |
                        \n{2,}
                        (?=\S)
                        (?!                         // Negative lookahead for another list item marker
                            [ \t]*
                            (?:[*+-]|\d+[.])[ \t]+
                        )
                    )
                )
            /g
            */
            var whole_list = /^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;

            if (g_list_level) {
                text = text.replace(whole_list, function (wholeMatch, m1, m2) {
                    var list = m1;
                    var list_type = (m2.search(/[*+-]/g) > -1) ? "ul" : "ol";

                    var result = _ProcessListItems(list, list_type, isInsideParagraphlessListItem);

                    // Trim any trailing whitespace, to put the closing `</$list_type>`
                    // up on the preceding line, to get it past the current stupid
                    // HTML block parser. This is a hack to work around the terrible
                    // hack that is the HTML block parser.
                    result = result.replace(/\s+$/, "");
                    result = "<" + list_type + ">" + result + "</" + list_type + ">\n";
                    return result;
                });
            } else {
                whole_list = /(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/g;
                text = text.replace(whole_list, function (wholeMatch, m1, m2, m3) {
                    var runup = m1;
                    var list = m2;

                    var list_type = (m3.search(/[*+-]/g) > -1) ? "ul" : "ol";
                    var result = _ProcessListItems(list, list_type);
                    result = runup + "<" + list_type + ">\n" + result + "</" + list_type + ">\n";
                    return result;
                });
            }

            // attacklab: strip sentinel
            text = text.replace(/~0/, "");

            return text;
        }

        var _listItemMarkers = { ol: "\\d+[.]", ul: "[*+-]" };

        function _ProcessListItems(list_str, list_type, isInsideParagraphlessListItem) {
            //
            //  Process the contents of a single ordered or unordered list, splitting it
            //  into individual list items.
            //
            //  list_type is either "ul" or "ol".

            // The $g_list_level global keeps track of when we're inside a list.
            // Each time we enter a list, we increment it; when we leave a list,
            // we decrement. If it's zero, we're not in a list anymore.
            //
            // We do this because when we're not inside a list, we want to treat
            // something like this:
            //
            //    I recommend upgrading to version
            //    8. Oops, now this line is treated
            //    as a sub-list.
            //
            // As a single paragraph, despite the fact that the second line starts
            // with a digit-period-space sequence.
            //
            // Whereas when we're inside a list (or sub-list), that line will be
            // treated as the start of a sub-list. What a kludge, huh? This is
            // an aspect of Markdown's syntax that's hard to parse perfectly
            // without resorting to mind-reading. Perhaps the solution is to
            // change the syntax rules such that sub-lists must start with a
            // starting cardinal number; e.g. "1." or "a.".

            g_list_level++;

            // trim trailing blank lines:
            list_str = list_str.replace(/\n{2,}$/, "\n");

            // attacklab: add sentinel to emulate \z
            list_str += "~0";

            // In the original attacklab showdown, list_type was not given to this function, and anything
            // that matched /[*+-]|\d+[.]/ would just create the next <li>, causing this mismatch:
            //
            //  Markdown          rendered by WMD        rendered by MarkdownSharp
            //  ------------------------------------------------------------------
            //  1. first          1. first               1. first
            //  2. second         2. second              2. second
            //  - third           3. third                   * third
            //
            // We changed this to behave identical to MarkdownSharp. This is the constructed RegEx,
            // with {MARKER} being one of \d+[.] or [*+-], depending on list_type:
        
            /*
            list_str = list_str.replace(/
                (^[ \t]*)                       // leading whitespace = $1
                ({MARKER}) [ \t]+               // list marker = $2
                ([^\r]+?                        // list item text   = $3
                    (\n+)
                )
                (?=
                    (~0 | \2 ({MARKER}) [ \t]+)
                )
            /gm, function(){...});
            */

            var marker = _listItemMarkers[list_type];
            var re = new RegExp("(^[ \\t]*)(" + marker + ")[ \\t]+([^\\r]+?(\\n+))(?=(~0|\\1(" + marker + ")[ \\t]+))", "gm");
            var last_item_had_a_double_newline = false;
            list_str = list_str.replace(re,
                function (wholeMatch, m1, m2, m3) {
                    var item = m3;
                    var leading_space = m1;
                    var ends_with_double_newline = /\n\n$/.test(item);
                    var contains_double_newline = ends_with_double_newline || item.search(/\n{2,}/) > -1;

                    if (contains_double_newline || last_item_had_a_double_newline) {
                        item = _RunBlockGamut(_Outdent(item), /* doNotUnhash = */true);
                    }
                    else {
                        // Recursion for sub-lists:
                        item = _DoLists(_Outdent(item), /* isInsideParagraphlessListItem= */ true);
                        item = item.replace(/\n$/, ""); // chomp(item)
                        if (!isInsideParagraphlessListItem) // only the outer-most item should run this, otherwise it's run multiple times for the inner ones
                            item = _RunSpanGamut(item);
                    }
                    last_item_had_a_double_newline = ends_with_double_newline;
                    return "<li>" + item + "</li>\n";
                }
            );

            // attacklab: strip sentinel
            list_str = list_str.replace(/~0/g, "");

            g_list_level--;
            return list_str;
        }

        function _DoCodeBlocks(text) {
            //
            //  Process Markdown `<pre><code>` blocks.
            //  

            /*
            text = text.replace(/
                (?:\n\n|^)
                (                               // $1 = the code block -- one or more lines, starting with a space/tab
                    (?:
                        (?:[ ]{4}|\t)           // Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width
                        .*\n+
                    )+
                )
                (\n*[ ]{0,3}[^ \t\n]|(?=~0))    // attacklab: g_tab_width
            /g ,function(){...});
            */

            // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
            text += "~0";

            text = text.replace(/(?:\n\n|^\n?)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g,
                function (wholeMatch, m1, m2) {
                    var codeblock = m1;
                    var nextChar = m2;

                    codeblock = _EncodeCode(_Outdent(codeblock));
                    codeblock = _Detab(codeblock);
                    codeblock = codeblock.replace(/^\n+/g, ""); // trim leading newlines
                    codeblock = codeblock.replace(/\n+$/g, ""); // trim trailing whitespace

                    codeblock = "<pre><code>" + codeblock + "\n</code></pre>";

                    return "\n\n" + codeblock + "\n\n" + nextChar;
                }
            );

            // attacklab: strip sentinel
            text = text.replace(/~0/, "");

            return text;
        }

        function hashBlock(text) {
            text = text.replace(/(^\n+|\n+$)/g, "");
            return "\n\n~K" + (g_html_blocks.push(text) - 1) + "K\n\n";
        }

        function _DoCodeSpans(text) {
            //
            // * Backtick quotes are used for <code></code> spans.
            // 
            // * You can use multiple backticks as the delimiters if you want to
            //   include literal backticks in the code span. So, this input:
            //     
            //      Just type ``foo `bar` baz`` at the prompt.
            //     
            //   Will translate to:
            //     
            //      <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
            //     
            //   There's no arbitrary limit to the number of backticks you
            //   can use as delimters. If you need three consecutive backticks
            //   in your code, use four for delimiters, etc.
            //
            // * You can use spaces to get literal backticks at the edges:
            //     
            //      ... type `` `bar` `` ...
            //     
            //   Turns to:
            //     
            //      ... type <code>`bar`</code> ...
            //

            /*
            text = text.replace(/
                (^|[^\\])       // Character before opening ` can't be a backslash
                (`+)            // $2 = Opening run of `
                (               // $3 = The code block
                    [^\r]*?
                    [^`]        // attacklab: work around lack of lookbehind
                )
                \2              // Matching closer
                (?!`)
            /gm, function(){...});
            */

            text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
                function (wholeMatch, m1, m2, m3, m4) {
                    var c = m3;
                    c = c.replace(/^([ \t]*)/g, ""); // leading whitespace
                    c = c.replace(/[ \t]*$/g, ""); // trailing whitespace
                    c = _EncodeCode(c);
                    c = c.replace(/:\/\//g, "~P"); // to prevent auto-linking. Not necessary in code *blocks*, but in code spans. Will be converted back after the auto-linker runs.
                    return m1 + "<code>" + c + "</code>";
                }
            );

            return text;
        }

        function _EncodeCode(text) {
            //
            // Encode/escape certain characters inside Markdown code runs.
            // The point is that in code, these characters are literals,
            // and lose their special Markdown meanings.
            //
            // Encode all ampersands; HTML entities are not
            // entities within a Markdown code span.
            text = text.replace(/&/g, "&amp;");

            // Do the angle bracket song and dance:
            text = text.replace(/</g, "&lt;");
            text = text.replace(/>/g, "&gt;");

            // Now, escape characters that are magic in Markdown:
            text = escapeCharacters(text, "\*_{}[]\\", false);

            // jj the line above breaks this:
            //---

            //* Item

            //   1. Subitem

            //            special char: *
            //---

            return text;
        }

        function _DoItalicsAndBold(text) {

            // <strong> must go first:
            text = text.replace(/([\W_]|^)(\*\*|__)(?=\S)([^\r]*?\S[\*_]*)\2([\W_]|$)/g,
            "$1<strong>$3</strong>$4");

            text = text.replace(/([\W_]|^)(\*|_)(?=\S)([^\r\*_]*?\S)\2([\W_]|$)/g,
            "$1<em>$3</em>$4");

            return text;
        }

        function _DoBlockQuotes(text) {

            /*
            text = text.replace(/
                (                           // Wrap whole match in $1
                    (
                        ^[ \t]*>[ \t]?      // '>' at the start of a line
                        .+\n                // rest of the first line
                        (.+\n)*             // subsequent consecutive lines
                        \n*                 // blanks
                    )+
                )
            /gm, function(){...});
            */

            text = text.replace(/((^[ \t]*>[ \t]?.+\n(.+\n)*\n*)+)/gm,
                function (wholeMatch, m1) {
                    var bq = m1;

                    // attacklab: hack around Konqueror 3.5.4 bug:
                    // "----------bug".replace(/^-/g,"") == "bug"

                    bq = bq.replace(/^[ \t]*>[ \t]?/gm, "~0"); // trim one level of quoting

                    // attacklab: clean up hack
                    bq = bq.replace(/~0/g, "");

                    bq = bq.replace(/^[ \t]+$/gm, "");     // trim whitespace-only lines
                    bq = _RunBlockGamut(bq);             // recurse

                    bq = bq.replace(/(^|\n)/g, "$1  ");
                    // These leading spaces screw with <pre> content, so we need to fix that:
                    bq = bq.replace(
                            /(\s*<pre>[^\r]+?<\/pre>)/gm,
                        function (wholeMatch, m1) {
                            var pre = m1;
                            // attacklab: hack around Konqueror 3.5.4 bug:
                            pre = pre.replace(/^  /mg, "~0");
                            pre = pre.replace(/~0/g, "");
                            return pre;
                        });

                    return hashBlock("<blockquote>\n" + bq + "\n</blockquote>");
                }
            );
            return text;
        }

        function _FormParagraphs(text, doNotUnhash) {
            //
            //  Params:
            //    $text - string to process with html <p> tags
            //

            // Strip leading and trailing lines:
            text = text.replace(/^\n+/g, "");
            text = text.replace(/\n+$/g, "");

            var grafs = text.split(/\n{2,}/g);
            var grafsOut = [];
            
            var markerRe = /~K(\d+)K/;

            //
            // Wrap <p> tags.
            //
            var end = grafs.length;
            for (var i = 0; i < end; i++) {
                var str = grafs[i];

                // if this is an HTML marker, copy it
                if (markerRe.test(str)) {
                    grafsOut.push(str);
                }
                else if (/\S/.test(str)) {
                    str = _RunSpanGamut(str);
                    str = str.replace(/^([ \t]*)/g, "<p>");
                    str += "</p>"
                    grafsOut.push(str);
                }

            }
            //
            // Unhashify HTML blocks
            //
            if (!doNotUnhash) {
                end = grafsOut.length;
                for (var i = 0; i < end; i++) {
                    var foundAny = true;
                    while (foundAny) { // we may need several runs, since the data may be nested
                        foundAny = false;
                        grafsOut[i] = grafsOut[i].replace(/~K(\d+)K/g, function (wholeMatch, id) {
                            foundAny = true;
                            return g_html_blocks[id];
                        });
                    }
                }
            }
            return grafsOut.join("\n\n");
        }

        function _EncodeAmpsAndAngles(text) {
            // Smart processing for ampersands and angle brackets that need to be encoded.

            // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
            //   http://bumppo.net/projects/amputator/
            text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;");

            // Encode naked <'s
            text = text.replace(/<(?![a-z\/?!]|~D)/gi, "&lt;");

            return text;
        }

        function _EncodeBackslashEscapes(text) {
            //
            //   Parameter:  String.
            //   Returns:    The string, with after processing the following backslash
            //               escape sequences.
            //

            // attacklab: The polite way to do this is with the new
            // escapeCharacters() function:
            //
            //     text = escapeCharacters(text,"\\",true);
            //     text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
            //
            // ...but we're sidestepping its use of the (slow) RegExp constructor
            // as an optimization for Firefox.  This function gets called a LOT.

            text = text.replace(/\\(\\)/g, escapeCharacters_callback);
            text = text.replace(/\\([`*_{}\[\]()>#+-.!])/g, escapeCharacters_callback);
            return text;
        }

        var charInsideUrl = "[-A-Z0-9+&@#/%?=~_|[\\]()!:,.;]",
            charEndingUrl = "[-A-Z0-9+&@#/%=~_|[\\])]",
            autoLinkRegex = new RegExp("(=\"|<)?\\b(https?|ftp)(://" + charInsideUrl + "*" + charEndingUrl + ")(?=$|\\W)", "gi"),
            endCharRegex = new RegExp(charEndingUrl, "i");

        function handleTrailingParens(wholeMatch, lookbehind, protocol, link) {
            if (lookbehind)
                return wholeMatch;
            if (link.charAt(link.length - 1) !== ")")
                return "<" + protocol + link + ">";
            var parens = link.match(/[()]/g);
            var level = 0;
            for (var i = 0; i < parens.length; i++) {
                if (parens[i] === "(") {
                    if (level <= 0)
                        level = 1;
                    else
                        level++;
                }
                else {
                    level--;
                }
            }
            var tail = "";
            if (level < 0) {
                var re = new RegExp("\\){1," + (-level) + "}$");
                link = link.replace(re, function (trailingParens) {
                    tail = trailingParens;
                    return "";
                });
            }
            if (tail) {
                var lastChar = link.charAt(link.length - 1);
                if (!endCharRegex.test(lastChar)) {
                    tail = lastChar + tail;
                    link = link.substr(0, link.length - 1);
                }
            }
            return "<" + protocol + link + ">" + tail;
        }
        
        function _DoAutoLinks(text) {

            // note that at this point, all other URL in the text are already hyperlinked as <a href=""></a>
            // *except* for the <http://www.foo.com> case

            // automatically add < and > around unadorned raw hyperlinks
            // must be preceded by a non-word character (and not by =" or <) and followed by non-word/EOF character
            // simulating the lookbehind in a consuming way is okay here, since a URL can neither and with a " nor
            // with a <, so there is no risk of overlapping matches.
            text = text.replace(autoLinkRegex, handleTrailingParens);

            //  autolink anything like <http://example.com>
            
            var replacer = function (wholematch, m1) { return "<a href=\"" + m1 + "\">" + pluginHooks.plainLinkText(m1) + "</a>"; }
            text = text.replace(/<((https?|ftp):[^'">\s]+)>/gi, replacer);

            // Email addresses: <address@domain.foo>
            /*
            text = text.replace(/
                <
                (?:mailto:)?
                (
                    [-.\w]+
                    \@
                    [-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+
                )
                >
            /gi, _DoAutoLinks_callback());
            */

            /* disabling email autolinking, since we don't do that on the server, either
            text = text.replace(/<(?:mailto:)?([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,
                function(wholeMatch,m1) {
                    return _EncodeEmailAddress( _UnescapeSpecialChars(m1) );
                }
            );
            */
            return text;
        }

        function _UnescapeSpecialChars(text) {
            //
            // Swap back in all the special characters we've hidden.
            //
            text = text.replace(/~E(\d+)E/g,
                function (wholeMatch, m1) {
                    var charCodeToReplace = parseInt(m1);
                    return String.fromCharCode(charCodeToReplace);
                }
            );
            return text;
        }

        function _Outdent(text) {
            //
            // Remove one level of line-leading tabs or spaces
            //

            // attacklab: hack around Konqueror 3.5.4 bug:
            // "----------bug".replace(/^-/g,"") == "bug"

            text = text.replace(/^(\t|[ ]{1,4})/gm, "~0"); // attacklab: g_tab_width

            // attacklab: clean up hack
            text = text.replace(/~0/g, "")

            return text;
        }

        function _Detab(text) {
            if (!/\t/.test(text))
                return text;

            var spaces = ["    ", "   ", "  ", " "],
            skew = 0,
            v;

            return text.replace(/[\n\t]/g, function (match, offset) {
                if (match === "\n") {
                    skew = offset + 1;
                    return match;
                }
                v = (offset - skew) % 4;
                skew = offset + 1;
                return spaces[v];
            });
        }

        //
        //  attacklab: Utility functions
        //

        var _problemUrlChars = /(?:["'*()[\]:]|~D)/g;

        // hex-encodes some unusual "problem" chars in URLs to avoid URL detection problems 
        function encodeProblemUrlChars(url) {
            if (!url)
                return "";

            var len = url.length;

            return url.replace(_problemUrlChars, function (match, offset) {
                if (match == "~D") // escape for dollar
                    return "%24";
                if (match == ":") {
                    if (offset == len - 1 || /[0-9\/]/.test(url.charAt(offset + 1)))
                        return ":"
                }
                return "%" + match.charCodeAt(0).toString(16);
            });
        }


        function escapeCharacters(text, charsToEscape, afterBackslash) {
            // First we have to escape the escape characters so that
            // we can build a character class out of them
            var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";

            if (afterBackslash) {
                regexString = "\\\\" + regexString;
            }

            var regex = new RegExp(regexString, "g");
            text = text.replace(regex, escapeCharacters_callback);

            return text;
        }


        function escapeCharacters_callback(wholeMatch, m1) {
            var charCodeToEscape = m1.charCodeAt(0);
            return "~E" + charCodeToEscape + "E";
        }

    }; // end of the Markdown.Converter constructor

})();
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/root.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
//var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
//var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));
//var fdjtMap=fdjt.Map;

var metaBook={
    mode: false,hudup: false,scrolling: false,query: false,
    head: false,target: false,glosstarget: false,location: false,
    root: false,start: false,HUD: false,locsync: false,
    useidb: false,noidb: false,
    user: false, loggedin: false, cxthelp: false,
    _setup: false,_user_setup: false,_gloss_setup: false,_social_setup: false,
    // Whether we have a real connection to the server
    connected: false,
    // Keeping track of paginated context
    curpage: false,curoff: false,curinfo: false, curbottom: false,
    // For tracking UI state
    last_mode: false, last_heartmode: "about", demo: false,
    // Various default gesture timing parameters
    taptapmsecs: 200, holdmsecs: 300, edgeclick: 50, pagesize: 250,
    dontanimate: false, nativeselect: false,
    // Ignore swipes shorter than this:
    minswipe: 7,
    // Control audio effects
    uisound: false, readsound: false,
    glossmodes: /(addtag)|(addoutlet)|(editdetail)|(hamburger)|(attach)/,
    // Various device properties which can effect behaviors
    fullheight: false, fullwidth: false, handheld: false,
    updatehash: true,
    // This tracks missing node identifiers
    missing_nodes: [],
    // Whether to cache layouts locally; the value is a threshold
    // (in milliseconds) for when to cache
    cache_layout_thresh: 2500,
    // Ask about updating layouts which took longer than this
    //  many milliseconds to generate
    long_layout_thresh: 5000,
    // How long (msecs) to wait for a resize to be 'real'
    resize_wait: 500,
    // Whether to force new layouts
    forcelayout: false,
    // Whether layout is temporarily frozen, for example during text
    // input (on tablets, there may be extraneous resizes when the
    // on-screen keyboard appears)
    freezelayout: false,
    // Whether to locally store user information for offline availability
    persist: false,
    // Whether to locally save glosses, etc for offline availability,
    cacheglosses: false,
    // Which properties of the metaBook object to save
    saveprops: ["sources","outlets","layers","sync","nodeid","state"],
    // Whether to store glosses, etc for offline access and improved
    // performance.  This is no longer used, replaced by the two values
    // above.
    keepdata: false,
    // Dominant interaction mode
    mouse: true, touch: false, kbd: false,
    // Whether there is a keyboard
    keyboard: true,
    // This is a table for pager objects, by ID and mode
    pagers: {"allglosses": "METABOOKALLGLOSSES",
             "searchresults": "METABOOKSEARCHRESULTS",
             "statictoc": "METABOOKSTATICTOC"},
    // Restrictions on excerpts
    min_excerpt: 3, max_excerpt: false,
    // These are the UUIDs of locally stored glosses which are queued
    //  to be saved when possible (online and connected).
    queued: [],
    // These are weights assigned to search tags
    tagweights: false, tagmaxweight: 0, tagminweight: 200000000,
    // This is the base URI for this document, also known as the REFURI
    // A document (for instance an anthology or collection) may include
    // several refuri's, but this is the default.
    refuri: false,
    // These are the refuris used in this document
    refuris: [],
    // This is the document URI, which is usually the same as the REFURI.
    docuri: false,
    // This is the unique signed DOC+USER identifier used by myCopy
    // social DRM
    mycopyid: false, 
    // This is the time of the last update
    syncstamp: false,
    // Gloss sync settings (in milleseconds)
    update_interval: 30*1000, // Interval between checks
    update_timeout: 30*1000,    // Timeout on requests
    update_pause: 30*60*1000,   // Interval to sleep on error or timeout
    // State sync settings (in milliseconds):
    sync_interval: 180, // Interval between sync checks
    sync_min: 10, // Minimum interval between sync checks
    sync_timeout: 10,    // Timeout on sync requests
    sync_pause: 15*60, // Interval to sleep on error or timeout
    // Various handlers, settings, and status information for the
    // metaBook interface
    UI: {
        // This maps device types into sets of node->event handlers
        handlers: {mouse: {}, touch: {}, kbd: {}, ios: {}}},
    Debug: {},
    /* This is where HTML source strings for UI components are placed */
    HTML: {},
    /* This is where we store pointers into the DOM, CSS, and TapHold objects */
    DOM: {}, CSS: {}, TapHold: {},
    /* XTARGETS are procedures linked to fragment ids */
    xtargets: {},
    // Where various event timestamps are stored
    Timeline: {},
    // Word/phrase indexing structures
    allterms: [], prefixes: {},
    // These are prefixes or Regexps for URLs which should be opened "in the book"
    //  when they're linked in glosses
    openinbook: ["https://www.youtube.com/"],
    // These are elements, indexed by URL, whose content is being
    // loaded to cache locally
    srcloading: {}, glossdata: {},
    // These are functions to be called when everythings has been loaded
    //  to initialize local references to common metaBook functions
    inits: [],
    default_config: {
        layout: 'bypage',
        bodysize: 'normal',bodyfamily: 'serif',
        bodycontrast: 'high', textjustify: false,
        linespacing: 'normal',
        uisize: 'normal',dyslexical: false,
        animatecontent: true,animatehud: true,
        hidesplash: false,keyboardhelp: true,
        holdmsecs: 500,wandermsecs: 1500,taptapmsecs: 200,
        locsync: true, syncinterval: 60, checksync: 15*60,
        glossupdate: 5*60,cacheglosses: true,
        soundeffects: false, buzzeffects: false,
        showconsole: false,devmode: false,
        controlc: false},
    // What to trace, for debugging
    Trace: {
        startup: 0,       // Whether to trace startup
        config: 0,        // Whether to trace config setup/modification/etc
        mode: false,      // Whether to trace mode changes
        nav: false,       // Whether to trace book navigation
        domscan: 0,       // How much to trace initial DOM scanning
        search: 0,        // How much to trace searches
        clouds: 0,        // How much to trace cloud generation
        target: false,    // Whether to trace target changes
        toc: false,       // Whether we're debugging TOC tracking
        storage: 0,       // How much to trace offline persistence
        network: 0,       // How much to trace server interaction
        state: 0,         // Whether to trace state synchronization
        savegloss: 0,     // When glosses are saved to the server
        glosses: 0,       // How much we're tracing gloss processing
        addgloss: 0,      // Note whenever a gloss post completes
        glossdata: 1,     // Whether to trace caching/retrieval of glossdata
        slices: 0,        // How much to trace slice creation and layout
        pagers: 0,        // How much to trace Pager layout
        layout: 0,        // How much to trace document layout
        knodules: 0,      // How much to trace knodule processing
        preview: false,   // Whether to trace preview activity
        flips: false,     // Whether to trace page flips (movement by pages)
        resize: false,    // Whether to trace resizing events/activity
        messages: false,  // Whether to trace inter-window messages
        glossing: false,  // Whether to trace gloss adding or edition
        selection: false, // Whether to trace text selection events
        highlight: 0,     // Whether to trace highlighting
        indexing: 0,      // How much to trace document indexing
        gestures: 0}      // How much to trace gestures
};

if (typeof mB === 'undefined') mB=metaBook;

fdjt.DOM.noautofontadjust=true;


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/core.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* globals Promise, idbModules */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
//var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
//var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));
//var fdjtMap=fdjt.Map;

(function(){
    "use strict";

    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtAsync=fdjt.Async;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var $ID=fdjt.ID;
    var RefDB=fdjt.RefDB, Ref=fdjt.Ref;
    var ObjectMap=fdjt.Map||RefDB.Map;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var hasParent=fdjtDOM.hasParent;

    var getLocal=fdjtState.getLocal;
    var setLocal=fdjtState.setLocal;
    var existsLocal=fdjtState.existsLocal;
    
    var mB=metaBook;
    var Trace=metaBook.Trace;

    var indexedDB=window.indexedDB||idbModules.indexedDB;

    metaBook.tagweights=new ObjectMap();
    metaBook.tagscores=new ObjectMap();

    function hasLocal(key){
        if (mB.persist) return existsLocal(key);
        else return fdjtState.existsSession(key);}
    metaBook.hasLocal=hasLocal;

    function elt_unparser(arg){
        if (typeof arg === "string") return arg;
        else if (arg._qid) return arg._qid;
        else if (arg.getQID)
            return (arg._qid=arg.getQID())||arg.toString();
        else return JSON.stringify(arg);}
    function unparser(arg){
        if (typeof arg === "string") return arg;
        else if (Array.isArray(arg)) {
            var i=0, lim=arg.length; var result=[];
            while (i<lim) {
                var elt=arg[i++];
                result.push(elt_unparser(elt));}
            return JSON.stringify(result);}
        else return elt_unparser(arg);}

    function saveLocal(key,value,unparse){
        if (unparse) value=unparser(value);
        if (mB.persist) setLocal(key,value,false);
        else fdjtState.setSession(key,value,false);}
    metaBook.saveLocal=saveLocal;

    function readLocal(key,parse){
        if (mB.persist) {
            if (existsLocal(key))
                return getLocal(key,parse);
            else if (fdjtState.existsSession(key)) {
                setLocal(key,fdjtState.getSession(key));
                return getLocal(key,parse);}
            else return false;}
        else return fdjtState.getSession(key,parse)||getLocal(key,parse);}
    metaBook.readLocal=readLocal;

    function clearLocal(key){
        fdjtState.dropLocal(key);
        fdjtState.dropSession(key);}
    metaBook.clearLocal=clearLocal;

    metaBook.focusBody=function(){
        // document.body.focus();
    };
    
    /* Initialize the indexedDB database, when used */

    var metaBookDB=false, dbwait=[], dbfail=[];

    function getDB(){
        function gettingdb(resolve,reject){
            if (metaBookDB) resolve(metaBookDB);
            else if ((indexedDB)&&(!(mB.noidb))) {
                dbwait.push(resolve);
                if (reject) dbfail.push(reject);}
            else if (reject) reject(false);
            else return;}
        return new Promise(gettingdb);}
    metaBook.getDB=getDB;

    function gotDB(db){
        metaBook.metaBookDB=metaBookDB=db;
        fdjtAsync(function(){
            fdjt.CodexLayout.useIndexedDB(db.name);});
        var waiting=dbwait; dbwait=[]; dbfail=[];
        var i=0, len=waiting.length; while (i<len)
            waiting[i++](db);}
    function notDB(action,name,ex){
        var waiting=dbfail; dbwait=[]; dbfail=[];
        fdjtLog("Error %s database %s: %o",action,name,ex);
        var i=0, len=waiting.length; while (i<len)
            waiting[i++](ex);}

    
    if ((indexedDB)&&(!(mB.noidb))) {
        var req=window.indexedDB.open("metaBook",1);
        req.onerror=function(event){
            notDB("opening","metaBook",event.errorCode);};
        req.onsuccess=function(event) {
            var db=event.target.result;
            fdjtLog("Using existing metaBook IndexedDB");
            gotDB(db);};
        req.onupgradeneeded=function(event) {
            var db=event.target.result;
            db.onerror=function(event){
                notDB("upgrading","metaBook",event.target.errorCode);
                event=false;};
            db.onsuccess=function(event){
                var db=event.target.result;
                fdjtLog("Initialized metaBook indexedDB");
                gotDB(db);};
            db.createObjectStore("glossdata",{keyPath: "url"});
            db.createObjectStore("layouts",{keyPath: "layout_id"});
            db.createObjectStore("sources",{keyPath: "_id"});
            db.createObjectStore("docs",{keyPath: "_id"});
            db.createObjectStore("glosses",{keyPath: "glossid"});};}
    else fdjt.CodexLayout.useIndexedDB(false);

    /* Initialize the runtime for the core databases */

    function initDB() {
        if (Trace.start>1) fdjtLog("Initializing DB");
        var refuri=(metaBook.refuri||document.location.href);
        if (refuri.indexOf('#')>0) refuri=refuri.slice(0,refuri.indexOf('#'));

        metaBook.setupGlossData();

        var taglist=metaBook.taglist||$ID("METABOOKTAGLIST");
        if (!(taglist)) {
            taglist=metaBook.taglist=fdjt.DOM("datalist#METABOOKTAGLIST");
            document.body.appendChild(taglist);}
        
        metaBook.docdb=new RefDB(
            refuri+"#",{indices: ["frag","head","heads",
                                  "tags","tags*",
                                  "*tags","**tags","~tags",
                                  "*tags","**tags","~tags",
                                  "*tags*","**tags*","~tags*",
                                  "^tags","~^tags","*^tags","**^tags",
                                  "^tags*","~^tags*","*^tags*","**^tags*"]});
        metaBook.docdb.slots=["head","heads"];
        
        var knodeToOption=Knodule.knodeToOption;


        var cachelink=/^https:\/\/glossdata.(sbooks\.net|metabooks\.net|beingmeta\.com|bookhub\.io)\//;
        mB.cachelink=cachelink;
        
        var knodule_name=
            fdjtDOM.getMeta("METABOOK.knodule")||
            fdjtDOM.getMeta("PUBTOOL.knodule")||
            fdjtDOM.getMeta("~KNODULE")||
            refuri;
        metaBook.knodule=new Knodule(knodule_name);
        Knodule.current=metaBook.knodule;
        metaBook.BRICO=new Knodule("BRICO");
        metaBook.BRICO.addAlias(":@1/");
        metaBook.BRICO.addAlias("@1/");
        var glosses_init={
            indices: ["frag","maker","outlets",
                      "tags","*tags","**tags",
                      "tags*","*tags*","**tags*"]};
        var stdspace=fdjtString.stdspace;
        var glossdbname="glosses@"+metaBook.refuri;
        var glossdb=metaBook.glossdb=new RefDB(glossdbname,glosses_init); {
            glossdb.absrefs=true;
            glossdb.dbname="glosses";
            glossdb.addAlias("glossdb");
            glossdb.addAlias("-UUIDTYPE=61");
            glossdb.addAlias(":@31055/");
            glossdb.addAlias("@31055/");
            glossdb.onLoad(function initGloss(item) {
                var info=metaBook.docinfo[item.frag];
                if (!(info)) {
                    fdjtLog("Gloss (onload) refers to nonexistent '%s': %o",
                            item.frag,item);
                    return;}
                if ((info)&&(info.starts_at)) {
                    item.starts_at=info.starts_at+(item.exoff||0);}
                if ((info)&&(info.ends_at)) {
                    if (item.excerpt)
                        item.ends_at=info.ends_at+(item.exoff||0)+
                        (stdspace(item.excerpt).length);
                    else item.ends_at=info.ends_at;}
                if ((!(item.maker))&&(metaBook.user))
                    item.maker=(metaBook.user);
                var addTags=metaBook.addTags;
                var addTag2Cloud=metaBook.addTag2Cloud;
                var empty_cloud=metaBook.empty_cloud;
                var maker=(item.maker)&&(metaBook.sourcedb.ref(item.maker));
                if (item.links) {
                    var links=item.links; for (var link in links) {
                        if (!(links.hasOwnProperty(link))) continue;
                        if (!(links[link])) continue;
                        if (cachelink.exec(link)) {
                            var newlink=link.replace(
                                "//glossdata.sbooks.net/","//glossdata.bookhub.io/");
                            if (link!==newlink) {
                                links[newlink]=links[link];
                                delete links[link];
                                link=newlink;}}
                        if ((links.hasOwnProperty(link))&&
                            (cachelink.exec(link)))
                            metaBook.needGlossData(link);}}
                if (maker) {
                    metaBook.addTag2Cloud(maker,metaBook.empty_cloud);
                    metaBook.UI.addGlossSource(maker,true);}
                var maker_knodule=metaBook.getMakerKnodule(item.maker);
                var make_cue=(maker===metaBook.user);
                var i, lim, sources=item.sources;
                if (sources) {
                    if (typeof sources === 'string') sources=[sources];
                    if ((sources)&&(sources.length)) {
                        i=0; lim=sources.length; while (i<lim) {
                            var source=sources[i++];
                            var ref=metaBook.sourcedb.ref(source);
                            metaBook.UI.addGlossSource(ref,true);}}}
                var alltags=item.alltags;
                if ((alltags)&&(alltags.length)) {
                    i=0; lim=alltags.length; while (i<lim) {
                        var each_tag=alltags[i++], entry;
                        entry=addTag2Cloud(each_tag,empty_cloud);
                        if ((make_cue)&&(entry)) addClass(entry,"cue");
                        entry=addTag2Cloud(each_tag,metaBook.gloss_cloud);
                        if ((make_cue)&&(entry)) addClass(entry,"cue");
                        taglist.appendChild(knodeToOption(each_tag));}
                    var tag_slots=["tags","*tags","**tags"];
                    var s=0, n_slots=tag_slots.length; while (s<n_slots) {
                        var tagslot=tag_slots[s++], tags=item[tagslot];
                        if ((tags)&&(tags.length)) {
                            var fragslot="+"+tagslot;
                            if (item.thread) {
                                addTags(item.thread,tags,fragslot);
                                if (item.replyto!==item.thread)
                                    addTags(item.replyto,tags,fragslot);}
                            if (info) addTags(
                                info,tags,fragslot,maker_knodule);}}}},
                           "initgloss");
            if ((metaBook.user)&&(mB.persist)&&(metaBook.cacheglosses)) {
                if ((mB.useidb)&&(!(mB.noidb)))
                    getDB().then(function(db){glossdb.storage=db;});
                else glossdb.storage=localStorage;}}
        
        function Gloss(){return Ref.apply(this,arguments);}
        Gloss.prototype=new Ref();
        
        var exportTagSlot=Knodule.exportTagSlot;
        var tag_export_rules={
            "*tags": exportTagSlot, "**tags": exportTagSlot,
            "~tags": exportTagSlot, "~~tags": exportTagSlot,
            "tags": exportTagSlot,
            "*tags*": exportTagSlot, "**tags*": exportTagSlot,
            "~tags*": exportTagSlot, "~~tags*": exportTagSlot,
            "tags*": exportTagSlot,
            "*tags**": exportTagSlot, "**tags**": exportTagSlot,
            "~tags**": exportTagSlot, "~~tags**": exportTagSlot,
            "tags**": exportTagSlot};
        metaBook.tag_export_rules=tag_export_rules;
        metaBook.tag_import_rules=tag_export_rules;

        // Use this when generating external summaries.  In particular,
        //  this recovers all of the separate weighted tag slots into
        //  one tags slot which uses prefixed strings to indicate weights.
        Gloss.prototype.ExportExternal=function exportGloss(){
            return Ref.Export.call(this,tag_export_rules);};

        metaBook.glossdb.refclass=Gloss;
        
        var sourcedbname="sources@"+metaBook.refuri;
        var sourcedb=metaBook.sourcedb=new RefDB(sourcedbname);{
            sourcedb.absrefs=true;
            sourcedb.dbname="sources";
            sourcedb.oidrefs=true;
            sourcedb.addAlias("@1961/");
            sourcedb.addAlias(":@1961/");            
            sourcedb.addAlias("@acc/");
            sourcedb.addAlias(":@acc/");            
            sourcedb.onLoad(function initSource(item) {
                if ((item.pic)&&(typeof item.pic === "string")&&
                    (item.pic.search("data:")===0)) {
                    item._pic=fdjtDOM.data2URL(item.pic);}});
            sourcedb.forDOM=function(source){
                var spec="span.source"+((source.kind)?".":"")+
                    ((source.kind)?(source.kind.slice(1).toLowerCase()):"");
                var name=source.name||source.oid||source.uuid||source.uuid;
                var span=fdjtDOM(spec,name);
                if (source.about) span.title=source.about;
                return span;};}

        metaBook.queued=
            ((metaBook.cacheglosses)&&
             (getLocal("mB("+metaBook.docid+").queued",true)))||[];

        function setCacheGlosses(value){
            var saveprops=metaBook.saveprops, docid=mB.docid;
            if (value) {
                if (metaBook.user) {
                    if ((mB.useidb)&&(!(mB.noidb)))
                        getDB().then(function(db){
                            metaBook.sourcedb.storage=db;
                            metaBook.glossdb.storage=db;});
                    else {
                        var storage=((mB.persist)?(window.localStorage):
                                     (window.sessionStorage));
                        if (!(metaBook.sourcedb.storage))
                            metaBook.sourcedb.storage=storage;
                        if (!metaBook.glossdb.storage)
                            metaBook.glossdb.storage=storage;}
                    var props=metaBook.saveprops, i=0, lim=props.length;
                    while (i<lim) {
                        var prop=saveprops[i++];
                        if (metaBook[prop]) saveLocal(
                            "mB"+"("+docid+")."+prop,metaBook[prop],true);}
                    metaBook.glossdb.save(true);
                    metaBook.sourcedb.save(true);
                    if ((metaBook.queued)&&(metaBook.queued.length)) 
                        metaBook.queued=metaBook.queued.concat(
                            getLocal("mB("+docid+").queued",true)||[]);
                    else metaBook.queued=
                        getLocal("mB("+docid+").queued",true)||[];}
                metaBook.cacheglosses=true;}
            else {
                clearOffline(metaBook.docuri);
                if (docid) fdjtState.dropLocal("mB("+docid+").queued");
                metaBook.queued=[];
                metaBook.cacheglosses=false;}}
        metaBook.setCacheGlosses=setCacheGlosses;
        
        function saveProps(props_arg){
            var docid=mB.docid;
            var props=(!(props_arg))?(metaBook.saveprops):
                (Array.isArray(props_arg))?(props_arg):[props];
            var i=0, lim=props.length;
            while (i<lim) {
                var prop=props[i++];
                if (metaBook[prop]) saveLocal(
                    "mB"+"("+docid+")."+prop,metaBook[prop],true);}}
        metaBook.saveProps=saveProps;

        /* Setting persistence */

        function setPersist(){
            metaBook.persist=true;
            var refuri=mB.refuri, docuri=mB.docuri, docid=mB.docid;
            saveLocal("mB("+docid+")",docuri);
            // We also initialize .refuris/.docuris
            var refuris=readLocal("mB.refuris",true);
            var docuris=readLocal("mB.docuris",true);
            var docids=readLocal("mB.docids",true);
            if (!(refuris))
                saveLocal("mB.refuris",[refuri],true);
            else if (refuris.indexOf(refuri)<0) {
                refuris.push(refuri);
                saveLocal("mB.refuris",refuris,true);}
            else {}
            if (!(docuris))
                saveLocal("mB.docuris",[docuri],true);
            else if (docuris.indexOf(docuri)<0) {
                docuris.push(docuri);
                saveLocal("mB.docuris",docuris,true);}
            else {}
            if (!(docids))
                saveLocal("mB.docids",[docid],true);
            else if (docids.indexOf(docid)<0) {
                docids.push(docid);
                saveLocal("mB.docids",docids,true);}
            else {}
            if (mB.sourceid)
                saveLocal("mB("+mB.docid+").sourceid",mB.sourceid);}
        metaBook.setPersist=setPersist;

        /* Clearing offline data */

        function clearOffline(docid){
            var dropLocal=fdjtState.dropLocal;
            if (!(docid)) {
                var books=readLocal("mB.docids",true);
                if (books) {
                    var i=0, lim=books.length;
                    while (i<lim) clearOffline(books[i++]);}
                dropLocal("mB.user");
                dropLocal("mB.docuris");
                dropLocal("mB.docids");
                // We clear layouts, because they might
                //  contain personalized information
                fdjt.CodexLayout.clearLayouts();
                fdjtState.clearLocal();
                fdjtState.clearSession();}
            else {
                if (typeof docid !== "string") docid=metaBook.docid;
                var sourceid=getLocal("mB("+docid+").sourceid");
                if (sourceid) metaBook.clearLayouts(sourceid);
                metaBook.sync=false;
                clearLocal("mB("+docid+").sources");
                clearLocal("mB("+docid+").outlets");
                clearLocal("mB("+docid+").layers");
                clearLocal("mB("+docid+").etc");
                clearLocal("mB("+docid+").sync");
                // We don't currently clear sources when doing book
                // specific clearing because they might be shared
                // between books.  This is a bug.
                metaBook.glossdb.clearOffline(function(){
                    clearLocal("mB("+docid+").sync");});
                metaBook.clearGlossData(docid);}}
        metaBook.clearOffline=clearOffline;
        
        function refreshOffline(){
            var docid=metaBook.docid;
            metaBook.sync=false;
            clearLocal("mB("+docid+").sources");
            clearLocal("mB("+docid+").outlets");
            clearLocal("mB("+docid+").layers");
            clearLocal("mB("+docid+").etc");
            // We don't currently clear sources when doing book
            // specific clearing because they might be shared
            // between books
            metaBook.glossdb.clearOffline(function(){
                clearLocal("mB("+docid+").sync");
                setTimeout(metaBook.updateInfo,25);});}
        metaBook.refreshOffline=refreshOffline;

        Query.prototype.dbs=[metaBook.glossdb,metaBook.docdb];
        Query.prototype.weights={
            "+tags": 8,"tags": 4,"+tags*": 2,"tags*": 2,"^+tags": 2,
            "strings": 1,"head": 2,"heads": 1};
        Query.prototype.uniqueids=true;
        metaBook.query=metaBook.empty_query=new Query([]);

        if (Trace.start>1) fdjtLog("Initialized DB");}
    metaBook.initDB=initDB;

    /* Queries */

    function Query(tags,base_query){
        if (!(this instanceof Query))
            return new Query(tags,base_query);
        else if (arguments.length===0) return this;
        else {
            var query=Knodule.TagQuery.call(this,tags);
            if (Trace.search) query.log={};
            return query;}}
    Query.prototype=new Knodule.TagQuery();
    metaBook.Query=Query;

    function reduce_tags(query){
        var cotags=query.getCoTags();
        var tagfreqs=query.tagfreqs, n=query.results.length;
        var termindex=metaBook.textindex.termindex;
        var global_n=metaBook.textindex.allids.length;
        var i=0, lim=cotags.length, results=[];
        while (i<lim) {
            var t=cotags[i++]; 
            if (typeof t !== "string") results.push(t);
            else {
                var f=tagfreqs.getItem(t);
                if ((f>0.9*n)||(f<3)||((f/n)<0.1)) continue;
                var gl=termindex[t], gf=((gl)?(gl.length):(0));
                if (gf===0) results.push(t);
                if (gf/global_n>0.4) continue;
                if ((f/n)>(5*(gf/global_n))) {
                    results.push(t);}}}
        return results;}
    metaBook.Query.prototype.getRefiners=function getRefiners(){
        if (this._refiners) return this._refiners;
        else {
            var r=reduce_tags(this);
            this._refiners=r;
            return r;}};

    function getMakerKnodule(arg){
        var result;
        if (!(arg)) arg=metaBook.user;
        if (!(arg)) return (metaBook.knodule);
        else if (typeof arg === "string")
            return getMakerKnodule(metaBook.sourcedb.probe(arg));
        else if ((arg.maker)&&(arg.maker instanceof Ref))
            result=new Knodule(arg.maker.getQID());
        else if ((arg.maker)&&(typeof arg.maker === "string"))
            return getMakerKnodule(metaBook.sourcedb.probe(arg.maker));
        else if (arg._qid)
            result=new Knodule(arg._qid);
        else if (arg._id)
            result=new Knodule(arg._i);
        else result=metaBook.knodule;
        result.description=arg.name;
        return result;}
    metaBook.getMakerKnodule=getMakerKnodule;

    var trace1="%s %o in %o: mode%s=%o, target=%o, head=%o skimming=%o";
    var trace2="%s %o: mode%s=%o, target=%o, head=%o skimming=%o";
    function sbook_trace(handler,cxt){
        var target=((cxt.nodeType)?(cxt):(fdjtUI.T(cxt)));
        if (target)
            fdjtLog(trace1,handler,cxt,target,
                    ((metaBook.skimpoint)?("(skimming)"):""),metaBook.mode,
                    metaBook.target,metaBook.head,metaBook.skimpoint);
        else fdjtLog(trace2,handler,cxt,
                     ((metaBook.skimpoint)?("(skimming)"):""),metaBook.mode,
                     metaBook.target,metaBook.head,metaBook.skimpoint);}
    metaBook.trace=sbook_trace;

    var uroot_pat=/https?:\/\/[^\/]+\/([^\/]+\/)*/;
    var mbama=window._metabook_amalgam;

    // This is the hostname for the sbookserver.
    metaBook.server=false;
    // This is an array for looking up sbook servers.
    metaBook.servers=[];
    //metaBook.servers=[];
    // This is the default server
    metaBook.default_server="glosses.bookhub.io";
    // There be icons here!
    metaBook.root=
        ((mbama)&&(uroot_pat.exec(mbama))&&((uroot_pat.exec(mbama))[0]))||
        fdjtDOM.getLink("METABOOK.staticroot")||"http://static.beingmeta.com/";
    if (metaBook.root[metaBook.root.length-1]!=="/")
        metaBook.root=metaBook.root+"/";
    metaBook.withsvg=document.implementation.hasFeature(
        "http://www.w3.org/TR/SVG11/feature#Image", "1.1")||
        navigator.mimeTypes["image/svg+xml"];
    metaBook.svg=fdjt.DOM.checkSVG();
    if (fdjtState.getQuery("nosvg")) metaBook.svg=false;
    else if (fdjtState.getQuery("withsvg")) metaBook.svg=true;
    metaBook.icon=function(base,width,height){
        return metaBook.root+"g/metabook/"+base+
            ((metaBook.svg)?(".svgz"):
             ((((width)&&(height))?(width+"x"+height):
               (width)?(width+"w"):(height)?(height+"h"):"")+
              ".png"));};
    var mbicon=metaBook.icon;

    function getRefURI(target){
        var scan=target;
        while ((scan)&&(scan!==document)) {
            if (scan.getAttribute("data-refuri"))
                return scan.getAttribute("data-refuri");
            else if (scan.getAttribute("refuri"))
                return scan.getAttribute("refuri");
            else scan=scan.parentNode;}
        return metaBook.refuri;}
    metaBook.getRefURI=getRefURI;

    function getDocURI(target){
        var scan=target;
        while ((scan)&&(scan!==document)) {
            if (scan.getAttribute("data-docuri"))
                return scan.getAttribute("data-docuri");
            else if (scan.getAttribute("docuri"))
                return scan.getAttribute("docuri");
            else scan=scan.parentNode;}
        return metaBook.docuri;}
    metaBook.getDocURI=getDocURI;

    metaBook.getRefID=function(target){
        if (target.getAttributeNS)
            return (target.getAttributeNS('bookid'))||
            (target.getAttributeNS('data-bookid'))||
            (target.codexbaseid)||(target.id);
        else return target.id;};

    function getTarget(scan,closest){
        scan=((scan.nodeType)?(scan):(scan.target||scan.srcElement||scan));
        var target=false, id=false, targetids=metaBook.targetids;
        var wsn_target=false;
        if (hasParent(scan,metaBook.HUD)) return false;
        else if (hasParent(scan,".metabookmargin")) return false;
        else while (scan) {
            if (scan.metabookui) return false;
            else if ((scan===metaBook.docroot)||(scan===document.body))
                return target;
            else if ((id=(scan.codexbaseid||scan.id))&&(metaBook.docinfo[id])) {
                if ((!(scan.codexbaseid))&&(id.search("METABOOKTMP")===0)) {}
                else if ((target)&&(id.search("WSN_")===0)) {}
                else if (id.search("WSN_")===0) wsn_target=scan;
                else if ((targetids)&&(id.search(targetids)!==0)) {}
                else if (hasClass(scan,"sbooknofocus")) {}
                else if ((metaBook.nofocus)&&(metaBook.nofocus.match(scan))) {}
                else if (hasClass(scan,"sbookfocus")) return scan;
                else if ((metaBook.focus)&&(metaBook.focus.match(scan)))
                    return scan;
                else if (closest) return scan;
                else if ((target)&&
                         ((scan.tagName==='SECTION')||
                          ((scan.className)&&(scan.className.search)&&
                           (scan.className.search(/\bhtml5section\b/i)>=0))))
                    return target;
                else if ((target)&&(!(fdjt.DOM.isVisible(scan))))
                    return target;
                else if (target) {}
                else target=scan;}
            else {}
            scan=scan.parentNode;}
        return target||wsn_target;}
    metaBook.getTarget=getTarget;

    function getHead(target){
        /* First, find some relevant docinfo */
        var targetid=(target.codexbaseid)||(target.id);
        if ((targetid)&&(metaBook.docinfo[targetid]))
            target=metaBook.docinfo[targetid];
        else if (targetid) {
            while (target)
                if ((target.id)&&(metaBook.docinfo[targetid])) {
                    target=metaBook.docinfo[targetid]; break;}
            else target=target.parentNode;}
        else {
            /* First, try scanning forward to find a non-empty node */
            var scan=target.firstChild; var scanid=false;
            var next=target.nextNode;
            while ((scan)&&(scan!==next)) {
                if ((scan.id)||(scan.codexbaseid)) break;
                if ((scan.nodeType===3)&&
                    (!(fdjtString.isEmpty(scan.nodeValue)))) break;
                scan=fdjtDOM.forward(scan);}
            /* If you found something, use it */
            if ((scan)&&(scan.id)&&(scan!==next))
                target=metaBook.docinfo[scanid];
            else {
                while (target)
                    if ((targetid=((target.codexbaseid)||(target.id)))&&
                        (metaBook.docinfo[targetid])) {
                        target=metaBook.docinfo[targetid]; break;}
                else target=target.parentNode;}}
        if (target) {
            if (target.level)
                return mbID(target.frag);
            else if (target.head)
                return mbID(target.head.frag);
            else return false;}
        else return false;}
    metaBook.getHead=getHead;

    metaBook.getRef=function(target){
        while (target)
            if (target.about) break;
        else if ((target.getAttribute)&&(target.getAttribute("about"))) break;
        else target=target.parentNode;
        if (target) {
            var ref=((target.about)||(target.getAttribute("about")));
            if (!(target.about)) target.about=ref;
            if (ref[0]==='#')
                return mbID(ref.slice(1));
            else return mbID(ref);}
        else return false;};
    metaBook.getRefElt=function(target){
        while (target)
            if ((target.about)||
                ((target.getAttribute)&&(target.getAttribute("about"))))
                break;
        else target=target.parentNode;
        return target||false;};

    metaBook.checkTarget=function(){
        if ((metaBook.target)&&(metaBook.mode==='openglossmark'))
            if (!(fdjtDOM.isVisible(metaBook.target))) {
                metaBook.setMode(false); metaBook.setMode(true);}};

    /* A Kludge For iOS */

    /* This is a kludge to handle the fact that saving an iOS app
       to the home screen loses any authentication information
       (cookies, etc) that the original page might have had.  To
       avoid forcing the user to login again, we store the current
       BOOKHUB:AUTH- token (the encrypted authentication token that
       can travel in the clear) in the .search (query string) of the
       current location.  This IS passed to the homescreen
       standalone app, so we can use it to get a real authentication
       token.*/
    /*
    function iosHomeKludge(){
        if ((!(metaBook.user))||(fdjt.device.standalone)||
            (!(fdjt.device.mobilesafari)))
            return;
        var auth=fdjtState.getCookie("BOOKHUB:AUTH-");
        if (!(auth)) return;
        var eauth=encodeURIComponent(auth);
        var url=location.href, qmark=url.indexOf('?'), hashmark=url.indexOf('#');
        var base=((qmark<0)?((hashmark<0)?(url):(url.slice(0,hashmark))):
                  (url.slice(0,qmark)));
        var query=((qmark<0)?(""):(hashmark<0)?(url.slice(qmark)):
                   (url.slice(qmark+1,hashmark)));
        var hash=((hashmark<0)?(""):(url.slice(hashmark)));
        var old_query=false, new_query="BOOKHUB%3aAUTH-="+eauth;
        if (query.length<=2) query="?"+new_query;
        else if (query.search("BOOKHUB%3aAUTH-=")>=0) {
            var auth_start=query.search("BOOKHUB%3aAUTH-=");
            var before=query.slice(0,auth_start);
            var auth_len=query.slice(auth_start).search('&');
            var after=((auth_len<0)?(""):(query.slice(auth_start+auth_len)));
            old_query=((auth_len<0)?(query.slice(auth_start)):
                       (query.slice(auth_start,auth_start+auth_len)));
            query=before+new_query+after;}
        else query=query+"&"+new_query;
        if ((!(old_query))||(old_query!==new_query))
            history.replaceState(history.state,window.title,
                                 base+query+hash);}

    var ios_kludge_timer=false;
    function updateKludgeTimer(){
        if (document[fdjtDOM.isHidden]) {
            if (ios_kludge_timer) {
                clearInterval(ios_kludge_timer);
                ios_kludge_timer=false;}}
        else if (ios_kludge_timer) {}
        else ios_kludge_timer=
            setInterval(function(){
                if ((metaBook.user)&&(!(fdjt.device.standalone))&&
                    (!(document[fdjtDOM.isHidden]))&&
                    (fdjt.device.mobilesafari))
                    iosHomeKludge();},
                        300000);}
    function setupKludgeTimer(){
        updateKludgeTimer();
        if (fdjtDOM.isHidden)
            fdjtDOM.addListener(document,fdjtDOM.vischange,
                                updateKludgeTimer);
        updateKludgeTimer();}
    if ((!(fdjt.device.standalone))&&(fdjt.device.mobilesafari))
        fdjt.addInit(setupKludgeTimer,"setupKludgeTimer");
    */
    
    /* Utility functions */

    var isEmpty=fdjtString.isEmpty;

    function notEmpty(arg){
        if (typeof arg === 'string') {
            if (isEmpty(arg)) return false;
            else return arg;}
        else return false;}

    var metabook_docinfo=false;
    function mbID(id){
        var info, elts;
        if ((id)&&(typeof id === "string")&&(id[0]==="#"))
            id=id.slice(1);
        if (!(metabook_docinfo)) metabook_docinfo=metaBook.docinfo;
        var elt=((metabook_docinfo)&&(info=metabook_docinfo[id])&&(info.elt));
        if ((elt)&&(elt.id)) return elt;
        else if ((elt=document.getElementById(id))) return elt;
        else {
            elts=document.getElementsByName(id);
            if (elts.length===1)  return elts[0];
            else if (elts.length>1) return false;}
        elts=fdjtDOM.$("[data-tocid='"+id+"']");
        if (elts.length===1) return elts[0];
        else if (elts.length) {
            elts=fdjtDOM.$(".codexdupstart[data-tocid='"+id+"']");
            if (elts.length===1) return elts[0];
            else return false;}
        else return false;}
    metaBook.ID=mbID;

    metaBook.getTitle=function(target,tryhard) {
        var targetid;
        return target.sbooktitle||
            (((targetid=((target.codexbaseid)||(target.id)))&&
              (metaBook.docinfo[targetid]))?
             (notEmpty(metaBook.docinfo[targetid].title)):
             (notEmpty(target.title)))||
            ((tryhard)&&
             (fdjtDOM.textify(target)).
             replace(/\n(\s*\n)+/g,"\n").
             replace(/^\n+/,"").
             replace(/\n+$/,"").
             replace(/\n\n+/g," // ").
             replace(/\n/g," ").
             replace(/^\s*\/\//,""));};

    function getinfo(arg){
        if (arg) {
            if (typeof arg === 'string')
                return (metaBook.docinfo[arg]||
                        metaBook.glossdb.probe(arg)||
                        RefDB.resolve(arg));
            else if (arg._id) return arg;
            else if (arg.codexbaseid)
                return metaBook.docinfo[arg.codexbaseid];
            else if (arg.id) return metaBook.docinfo[arg.id];
            else return false;}
        else return false;}
    metaBook.Info=getinfo;

    /* Getting tagstrings from a gloss */
    var tag_prefixes=["","*","**","~","~~"];
    function getGlossTags(gloss){
        var results=[];
        var i=0, lim=tag_prefixes.length; while (i<lim) {
            var prefix=tag_prefixes[i++];
            var tags=gloss[prefix+"tags"];
            if (!(tags)) continue;
            else if (!(tags instanceof Array)) tags=[tags];
            var j=0, ntags=tags.length;
            while (j<ntags) {
                var tag=tags[j++];
                if (prefix==="") results.push(tag);
                else results.push({prefix: prefix,tag: tag});}}
        return results;}
    metaBook.getGlossTags=getGlossTags;


    /* Tags */

    function parseTag(tag,kno){
        var slot="tags"; var usekno=kno||metaBook.knodule;
        if (tag[0]==="~") {
            slot="~tags"; tag=tag.slice(1);}
        else if ((tag[0]==="*")&&(tag[1]==="*")) {
            slot="**tags"; tag=tag.slice(2);}
        else if (tag[0]==="*") {
            slot="*tags"; tag=tag.slice(1);}
        else {}
        var knode=((tag.indexOf('|')>=0)?
                   (usekno.handleSubjectEntry(tag)):
                   (slot==="~tags")?
                   (((kno)&&(kno.probe(tag)))||(tag)):
                   (usekno.handleSubjectEntry(tag)));
        if (slot!=="tags") return {slot: slot,tag: knode};
        else return knode;}
    metaBook.parseTag=parseTag;
    
    var knoduleAddTags=Knodule.addTags;
    function addTags(nodes,tags,slotid,tagdb){
        if (!(slotid)) slotid="tags";
        if (!(tagdb)) tagdb=metaBook.knodule;
        var docdb=metaBook.docdb;
        if (!(nodes instanceof Array)) nodes=[nodes];
        knoduleAddTags(nodes,tags,docdb,tagdb,slotid,metaBook.tagscores);
        var i=0, lim=nodes.length; while (i<lim) {
            var node=nodes[i++];
            if (!(node.toclevel)) continue;
            var passages=docdb.find('head',node);
            if (passages.length) passages=[].concat(passages);
            if ((passages)&&(passages.length))
                knoduleAddTags(passages,tags,docdb,tagdb,
                               "^"+slotid,metaBook.tagscores);
            var subheads=docdb.find('heads',node);
            if (subheads.length) subheads=[].concat(subheads);
            if ((subheads)&&(subheads.length))
                addTags(subheads,tags,"^"+slotid,tagdb);}}
    metaBook.addTags=addTags;
    
    // Assert whether we're connected and update body classes
    //  to reflect the state. Also, run run any delayed thunks
    //  queued for connection.
    function setConnected(val){
        var root=document.documentElement||document.body;
        if ((val)&&(!(metaBook.connected))) {
            var onconnect=metaBook._onconnect;
            metaBook._onconnect=false;
            if ((onconnect)&&(onconnect.length)) {
                var i=0; var lim=onconnect.length;
                while (i<lim) (onconnect[i++])();}
            if (fdjtState.getLocal("mB("+mB.docid+").queued"))
                metaBook.writeQueuedGlosses();}
        if (((val)&&(!(metaBook.connected)))||
            ((!(val))&&(metaBook.connected)))
            fdjtDOM.swapClass(root,/\b(_|cx)(CONN|DISCONN)\b/,
                              ((val)?("_CONN"):("_DISCONN")));
        metaBook.connected=val;
    } metaBook.setConnected=setConnected;


    function getLevel(elt,rel){
        if (elt.toclevel) {
            if (elt.toclevel==='none') {
                elt.toclevel=false;
                return false;}
            else return elt.toclevel;}
        var attrval=(elt.getAttribute('toclevel'))||
            (elt.getAttribute('data-toclevel'));
        if (attrval) {
            if (attrval==='none') return false;
            else return parseInt(attrval,10);}
        if (elt.className) {
            var cname=elt.className;
            if (cname.search(/\b(sbook|metabook|sb|mb)notoc\b/)>=0) return 0;
            if (cname.search(/\b(sbook|metabook|sb|mb)ignore\b/)>=0) return 0;
            var tocloc=cname.search(/\b(sbook|metabook|sb|mb)\d+(head|sect)\b/);
            if (tocloc>=0)
                return parseInt(cname.slice(tocloc+5),10);
            else if ((typeof rel ==="number")&&
                     (cname.search(/\b(sbook|metabook|sb|mb)subhead\b/)>=0))
                return rel+1;
            else {}}
        if ((metaBook.notoc)&&(metaBook.notoc.match(elt))) return 0;
        if ((metaBook.ignore)&&(metaBook.ignore.match(elt))) return 0;
        if ((typeof metaBook.autotoc !== 'undefined')&&(!(metaBook.autotoc)))
            return false;
        if ((elt.tagName==='HGROUP')||(elt.tagName==='HEADER'))
            return getFirstTocLevel(elt,true);
        if (elt.tagName.search(/H\d/)===0)
            return parseInt(elt.tagName.slice(1,2),10);
        else return false;}

    function getFirstTocLevel(node,notself){
        if (node.nodeType!==1) return false;
        var level=((!(notself))&&(getLevel(node)));
        if (level) return level;
        var children=node.childNodes;
        var i=0; var lim=children.length;
        while (i<lim) {
            var child=children[i++];
            if (child.nodeType!==1) continue;
            level=getFirstTocLevel(child);
            if (level) return level;}
        return false;}

    metaBook.getTOCLevel=getLevel;
    
    function getCoverPage(){
        if (metaBook.coverpage) return metaBook.coverpage;
        var coverpage=$ID("METABOOKCOVERPAGE")||
            $ID("SBOOKCOVERPAGE")||
            $ID("COVERPAGE");
        if (coverpage) metaBook.coverpage=coverpage;
        return coverpage;}
    metaBook.getCoverPage=getCoverPage;

    var fillIn=fdjtString.fillIn;
    var expand=fdjtString.expandEntities;
    function fixStaticRefs(string){
        return fillIn(expand(string).replace(
                /http(s)?:\/\/static.beingmeta.com\//g,metaBook.root),
                      {bmg: metaBook.root+"g/",
                       coverimage: metaBook.coverimage});}
    metaBook.fixStaticRefs=fixStaticRefs;
    
    fdjtString.entities.beingmeta=
        "<span class='beingmeta'>being<span class='bmm'>m<span class='bme'>e<span class='bmt'>t<span class='bma'>a</span></span></span></span></span>";
    fdjtString.entities.sBooks="<span class='sbooks'><em>s</em>Books</span>";
    fdjtString.entities.sBook="<span class='sbooks'><em>s</em>Book</span>";
    fdjtString.entities.metaBooks=
        "<span class='metabook'><span class='bmm'>m<span class='bme'>e<span class='bmt'>t<span class='bma'>a</span></span></span></span>Books</span>";
    fdjtString.entities.metaBook=
        "<span class='metabook'><span class='bmm'>m<span class='bme'>e<span class='bmt'>t<span class='bma'>a</span></span></span></span>Book</span>";

    function urlType(url){
        if (url.search(/\.(jpg|jpeg)$/g)>0) return "image/jpeg";
        else if (url.search(/\.png$/g)>0) return "image/png";
        else if (url.search(/\.gif$/g)>0) return "image/gif";
        else if (url.search(/\.wav$/g)>0) return "audio/wav";
        else if (url.search(/\.ogg$/g)>0) return "audio/ogg";
        else if (url.search(/\.mp3$/g)>0) return "audio/mpeg";
        else if (url.search(/\.mp4$/g)>0) return "video/mp4";
        else return false;}
    metaBook.urlType=urlType;
    function typeIcon(type,w){
        if (!(w)) w=64;
        if (!(type)) return mbicon("diaglink",w,w);
        else if (type==="audio/mpeg") 
            return mbicon("music",w,w);
        else if (type.slice(0,6)==="image/") 
            return mbicon("photo",w,w);
        else if (type.slice(0,6)==="audio/")
            return mbicon("sound",w,w);
        else return mbicon("diaglink",w,w);}
    metaBook.typeIcon=typeIcon;
    function mediaTypeClass(type){
        if (!(type)) return false;
        else if (type==="audio/mpeg")
            return "musiclink";
        else if (type.slice(0,6)==="image/") 
            return "imagelink";
        else if (type.slice(0,6)==="audio/")
            return "audiolink";
        else return false;}
    metaBook.mediaTypeClass=mediaTypeClass;

})();

fdjt.DOM.noautofontadjust=true;


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/config.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

// config.js
(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log, fdjtUI=fdjt.UI;
    var fdjtState=fdjt.State, fdjtTime=fdjt.Time, fdjtString=fdjt.String;

    var getChildren=fdjtDOM.getChildren;

    var getMeta=fdjtDOM.getMeta;

    var isEmpty=fdjtString.isEmpty;

    var getLocal=fdjtState.getLocal;
    var getQuery=fdjtState.getQuery;
    
    var mB=metaBook, Trace=metaBook.Trace;
    var saveLocal=mB.saveLocal;
    
    /* Configuration information */

    var config_handlers={};
    var default_config=metaBook.default_config;
    var current_config={};
    var saved_config={};

    function addConfig(name,handler){
        if (Trace.config>1)
            fdjtLog("Adding config handler for %s: %s",name,handler);
        config_handlers[name]=handler;
        if (current_config.hasOwnProperty(name)) {
            if (Trace.config>1)
                fdjtLog("Applying config handler to current %s=%s",
                        name,current_config[name]);
            handler(name,current_config[name]);}}
    metaBook.addConfig=addConfig;

    function getConfig(name){
        if (!(name)) return current_config;
        else return current_config[name];}
    metaBook.getConfig=getConfig;

    function setConfig(name,value,save,cxt){
        if (cxt) cxt=" ("+cxt+")";
        else cxt="";
        if (arguments.length===1) {
            var config=name;
            metaBook.postconfig=[];
            if (Trace.config)
                fdjtLog("batch setConfig %s: %s",cxt,config);
            for (var setting in config) {
                if (config.hasOwnProperty(setting))
                    setConfig(setting,config[setting]);}
            var dopost=metaBook.postconfig;
            metaBook.postconfig=false;
            if ((Trace.config>1)&&(!((dopost)||(dopost.length===0))))
                fdjtLog("batch setConfig, no post processing %s",
                        config,cxt);
            var post_i=0; var post_lim=dopost.length;
            while (post_i<post_lim) {
                if (Trace.config>1)
                    fdjtLog("batch setConfig%s, post processing %s",
                            dopost[post_i]);
                dopost[post_i++]();}
            return;}
        if (Trace.config) fdjtLog("setConfig%s %o=%o",cxt,name,value);
        if (!((current_config.hasOwnProperty(name))&&
              (current_config[name]===value))) {
            if (config_handlers[name]) {
                if (Trace.config)
                    fdjtLog("setConfig%s (handler=%s) %o=%o",
                            cxt,config_handlers[name],name,value);
                config_handlers[name](name,value);}
            else if (Trace.config)
                fdjtLog("setConfig%s (no handler) %o=%o",cxt,name,value);
            else {}
            current_config[name]=value;}
        else if (Trace.config)
            fdjtLog("Redundant setConfig%s %o=%o",cxt,name,value);
        else {}
        if ((save)&&(saved_config[name]!==value)) {
            saved_config[name]=value;
            saveConfig(saved_config);}}
    metaBook.setConfig=setConfig;
    metaBook.resetConfig=function(){setConfig(saved_config);};

    function saveConfig(config){
        if (Trace.config) {
            fdjtLog("saveConfig %o",config);
            fdjtLog("saved_config=%o",saved_config);}
        if (!(config)) config=saved_config;
        // Save automatically applies (seems only fair)
        else setConfig(config);
        var saved={};
        for (var setting in config) {
            if ((default_config.hasOwnProperty(setting))&&
                (config[setting]!==default_config[setting])&&
                (!(getQuery(setting)))) {
                saved[setting]=config[setting];}}
        if (Trace.config) fdjtLog("Saving config %o",saved);
        saveLocal("mB("+mB.docid+").config",JSON.stringify(saved));
        saved_config=saved;}
    metaBook.saveConfig=saveConfig;

    function initConfig(){
        var setting, value, source, started=fdjtTime(); // changed=false;
        var config=getLocal("mB("+mB.docid+").config",true)||
            fdjtState.getSession("mB("+mB.docid+").config",
                                 true);
        metaBook.postconfig=[];
        if (config) {
            if (Trace.config) fdjtLog("initConfig local=%j",config);
            for (setting in config) {
                if (config.hasOwnProperty(setting)) {
                    // if ((!(default_config.hasOwnProperty(setting)))||
                    //    (config[setting]!==default_config[setting]))
                    //    changed=true;
                    if (getQuery(setting)) {
                        value=getQuery(setting); source="initConfig/QUERY";}
                    else {
                        value=config[setting]; source="initConfig/local";}
                    setConfig(setting,value,false,source);
                    metaBook.updateSettings(setting,value);}}}
        else config={};
        if (Trace.config) fdjtLog("initConfig default=%j",default_config);
        for (setting in default_config) {
            if ((default_config.hasOwnProperty(setting))&&
                (!((config.hasOwnProperty(setting))||(getQuery(setting))))) {
                if (getMeta("METABOOK."+setting)) {
                    value=getMeta("METABOOK."+setting);
                    source="initConfig/HTML";}
                else {
                    value=default_config[setting];
                    source="initConfig/appdefaults";}
                setConfig(setting,value,false,"initConfig/HTML");
                setConfig(setting,value,false,source);
                metaBook.updateSettings(setting,value);}}
        var dopost=metaBook.postconfig;
        metaBook.postconfig=false;
        var i=0; var lim=dopost.length;
        while (i<lim) dopost[i++]();
        
        var devicename=current_config.devicename;
        if ((devicename)&&(!(isEmpty(devicename))))
            metaBook.deviceName=devicename;
        if (Trace.startup>1)
            fdjtLog("initConfig took %dms",fdjtTime()-started);}
    metaBook.initConfig=initConfig;
    
    var getParent=fdjtDOM.getParent;
    var getChild=fdjtDOM.getChild;

    function updateConfig(name,id,save){
        if (typeof save === 'undefined') save=false;
        var elt=((typeof id === 'string')&&(document.getElementById(id)))||
            ((id.nodeType)&&(getParent(id,'input')))||
            ((id.nodeType)&&(getChild(id,'input')))||
            ((id.nodeType)&&(getChild(id,'textarea')))||
            ((id.nodeType)&&(getChild(id,'select')))||
            (id);
        if (Trace.config) fdjtLog("Update config %s",name);
        if ((elt.type==='radio')||(elt.type==='checkbox'))
            setConfig(name,elt.checked||false,save,"updateConfig/checked");
        else setConfig(name,elt.value,save,"updateConfig/input");}
    metaBook.updateConfig=updateConfig;

    function metabookPropConfig(name,value){
        metaBook[name]=value;}
    metaBook.propConfig=metabookPropConfig;

    metaBook.addConfig("keyboardhelp",function(name,value){
        metaBook.keyboardhelp=value;
        fdjtUI.CheckSpan.set(
            document.getElementsByName("METABOOKKEYBOARDHELP"),
            value);});
    metaBook.addConfig("devicename",function(name,value){
        if (isEmpty(value)) metaBook.deviceName=false;
        else metaBook.deviceName=value;});

    metaBook.addConfig("holdmsecs",function(name,value){
        metaBook.holdmsecs=value;
        fdjtUI.TapHold.default_opts.holdmsecs=value;});
    metaBook.addConfig("wandermsecs",function(name,value){
        metaBook.wandermsecs=value;
        fdjtUI.TapHold.default_opts.wanderthresh=value;});
    metaBook.addConfig("taptapmsecs",function(name,value){
        metaBook.taptapmsecs=value;
        fdjtUI.TapHold.default_opts.taptapmsecs=value;});

    metaBook.addConfig("checksync",function(name,value){
        metaBook.sync_interval=value;
        if (metaBook.synctock) {
            clearInterval(metaBook.synctock);
            metaBook.synctock=false;}
        if ((value)&&(metaBook.locsync))
            metaBook.synctock=setInterval(metaBook.syncState,value*1000);});
    metaBook.addConfig("synctimeout",function(name,value){
        metaBook.sync_timeout=value;});
    metaBook.addConfig("syncpause",function(name,value){
        metaBook.sunc_pause=value;});

    metaBook.addConfig("locsync",function(name,value){
        // Start or clear the sync check interval timer
        if ((!(value))&&(metaBook.synctock)) {
            clearInterval(metaBook.synctock);
            metaBook.synctock=false;}
        else if ((value)&&(!(metaBook.synctock))&&
                 (metaBook.sync_interval))
            metaBook.synctock=setInterval(
                metaBook.syncState,(metaBook.sync_interval)*1000);
        else {}
        metaBook.locsync=value;
        fdjt.Async(function(){metaBook.updateSettings(name,value);});});
    
    function configChange(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var setting=target.name, val=target.value;
        var cur=current_config[setting];
        if ((target.checked)&&(cur===val)) return;
        else if (target.checked)
            setConfig(setting,val,true,"configChange");
        else if (target.type==="checkbox")
            setConfig(setting,"",true,"configChange");
        else {}}
    metaBook.configChange=configChange;

    function applyMetaClass(name,metaname){
        if (!(metaname)) metaname=name;
        var meta=getMeta(metaname,true);
        var i=0; var lim=meta.length;
        while (i<lim) fdjtDOM.addClass(fdjtDOM.$(meta[i++]),name);}
    metaBook.applyMetaClass=applyMetaClass;

    function updateSettings(setting,value){
        var forms=fdjtDOM.$(".metabooksettings");
        var i=0, n_forms=forms.length; while (i<n_forms) {
            var form=forms[i++];
            var inputs=getChildren(
                form,"input[type='CHECKBOX'],input[type='RADIO']");
            var toset=[], toclear=[];
            var j=0, n_inputs=inputs.length, input=false;
            while (j<n_inputs) {
                input=inputs[j++];
                if (input.name===setting) {
                    if ((value===true)?
                        (/(yes|on|true)/i.exec(input.value)):
                        (input.value===value))
                        toset.push(input);
                    else toclear.push(input);}}
            j=0; n_inputs=toset.length; while (j<n_inputs) {
                input=toset[j++];
                if (input.checked) continue;
                if (getParent(input,".checkspan")) 
                    fdjt.UI.CheckSpan.set(input,true);
                else input.checked=true;}
            j=0; n_inputs=toclear.length; while (j<n_inputs) {
                input=toclear[j++];
                if ((!(input.checked))&&
                    (typeof input.checked !== "undefined"))
                    continue;
                if (getParent(input,".checkspan"))
                    fdjt.UI.CheckSpan.set(input,false);
                else input.checked=false;}
            j=0; n_inputs=toset.length; while (j<n_inputs) {
                input=toset[j++];
                if (input.checked) continue;
                if (getParent(input,".checkspan")) 
                    fdjt.UI.CheckSpan.set(input,true);
                else input.checked=true;}}}
    metaBook.updateSettings=updateSettings;

    function initSettings(){
        for (var setting in current_config) {
            if (current_config.hasOwnProperty(setting))
                updateSettings(setting,current_config[setting]);}}
    metaBook.initSettings=initSettings;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/nav.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtString=fdjt.String, fdjtState=fdjt.State;
    var fdjtLog=fdjt.Log, fdjtUI=fdjt.UI;
    var dropClass=fdjtDOM.dropClass, addClass=fdjtDOM.addClass;
    var hasClass=fdjtDOM.hasClass, hasParent=fdjtDOM.hasParent;
    var mB=metaBook, mbID=mB.ID, getHead=mB.getHead, getTarget=mB.getTarget;
    var Trace=metaBook.Trace;
    var getDups, saveState, setHistory;

    function init_local(){
        getDups=metaBook.getDups;
        saveState=metaBook.saveState;
        setHistory=metaBook.setHistory;}
    metaBook.inits.push(init_local);

    /* Navigation functions */

    function setHead(arg){
        var head;
        if (!(arg)) return;
        else if (typeof arg === "string") 
            head=getHead(mbID(head))||metaBook.content;
        else head=arg;
        var headid=head.codexbaseid||head.id;
        var headinfo=metaBook.docinfo[headid];
        while ((headinfo)&&(!(headinfo.level))) {
            headinfo=headinfo.head;
            headid=headinfo.frag;
            head=mbID(headid);}
        if ((Trace.nav>1)&&(headinfo))
            fdjtLog("metaBook.setHead #%s %o from %o info=%o:\n%j",
                    (headid||"none"),head,arg,headinfo,headinfo);
        else if (Trace.nav)
            fdjtLog("metaBook.setHead #%s %o from %o",
                    (headid||"none"),head,arg);

        if (head===metaBook.head) {
            if (Trace.target) fdjtLog("Redundant SetHead");
            return;}
        else if (headinfo) {
            if (Trace.target)
                metaBook.trace("metaBook.setHead",head);
            window.title=headinfo.title+" ("+document.title+")";
            if (metaBook.head) dropClass(metaBook.head,"bookhead");
            addClass(head,"bookhead");
            metaBook.setLocation(metaBook.location);
            metaBook.head=mbID(headid);
            metaBook.TOC.setHead(headinfo);}
        else {
            if (Trace.target)
                metaBook.trace("metaBook.setFalseHead",head);
            metaBook.TOC.setHead(headinfo);
            metaBook.head=false;}}
    metaBook.setHead=setHead;

    function setLocation(location,force){
        if ((!(force)) && (metaBook.location===location)) return;
        if (Trace.toc)
            fdjtLog("Setting location to %o",location);
        var info=metaBook.Info(metaBook.head);
        while (info) {
            var tocelt=document.getElementById("MBTOC4"+info.frag);
            var hinfo=info.head, hhlen=((hinfo)&&(hinfo.ends_at-hinfo.starts_at));
            var start=info.starts_at; var end=info.ends_at;
            var progress=((location-start)*100)/hhlen;
            var bar=false, appbar=false;
            if (tocelt) {
                // tocelt.title=Math.round(progress)+"%";
                bar=fdjtDOM.getFirstChild(tocelt,".progressbar");}
            if (Trace.toc)
                fdjtLog("For tocbar %o/%o loc=%o start=%o end=%o progress=%o",
                        bar,appbar,location,start,end,progress);
            if ((progress>=0) && (progress<=100)) {
                if (bar) bar.style.width=(progress)+"%";
                if (appbar) appbar.style.width=(progress)+"%";}
            info=info.head;}
        var spanbars=fdjtDOM.$(".spanbar");
        var i=0; while (i<spanbars.length) {
            var spanbar=spanbars[i++];
            var width=spanbar.ends-spanbar.starts;
            var ratio=(location-spanbar.starts)/width;
            if (Trace.toc)
                fdjtLog("ratio for spanbar %o[%d] is %o [%o,%o,%o]",
                        spanbar,spanbar.childNodes[0].childNodes.length,
                        ratio,spanbar.starts,location,spanbar.ends);
            if ((ratio>=0) && (ratio<=1)) {
                var progressbox=fdjtDOM.$(".progressbox",spanbar);
                if (progressbox.length>0) {
                    progressbox=progressbox[0];
                    progressbox.style.left=((Math.round(ratio*10000))/100)+"%";}}}
        metaBook.location=location;}
    metaBook.setLocation=setLocation;

    function location2pct(location) {
        var max_loc=metaBook.ends_at;
        var pct=(100*location)/max_loc;
        if (pct>100) pct=100;
        // This is (very roughly) intended to be the precision needed
        //  for line level (40 character) accuracy.
        var prec=Math.round(Math.log(max_loc/40)/Math.log(10))-2;
        if (prec<0) prec=0;
        if (Math.floor(pct)===pct)
            return Math.floor(pct)+"%";
        else return fdjtString.precString(pct,prec)+"%";}
    metaBook.location2pct=location2pct;

    function setTarget(target){
        if (Trace.target) metaBook.trace("metaBook.setTarget",target);
        if (target===metaBook.target) return;
        else if ((metaBook.target)&&
                 (metaBook.target.id===target.codexbaseid))
            return;
        if (metaBook.target) {
            var old_target=metaBook.target, oldid=old_target.id;
            var old_targets=getDups(oldid);
            dropClass(old_target,"mbtarget");
            dropClass(old_target,"mbnewtarget");
            dropClass(old_targets,"mbtarget");
            dropClass(old_targets,"mbnewtarget");
            if (!(hasParent(old_target,target)))
                clearHighlights(old_targets);
            metaBook.target=false;}
        if (!(target)) {
            if (metaBook.UI.setTarget) metaBook.UI.setTarget(false);
            return;}
        else if ((inUI(target))||(!(target.id||target.codexbaseid)))
            return;
        else {}
        var targetid=target.codexbaseid||target.id;
        var primary=((targetid)&&(mbID(targetid)))||target;
        var targets=getDups(targetid);
        addClass(target,"mbtarget");
        addClass(target,"mbnewtarget");
        addClass(targets,"mbtarget");
        addClass(targets,"mbnewtarget");
        setTimeout(function(){
            dropClass(target,"mbnewtarget");
            dropClass(targets,"mbnewtarget");},
                   3000);
        fdjtState.setCookie(
            "mbtarget",targetid||target.getAttribute('data-bookid'));
        metaBook.target=primary;
        if (metaBook.UI.setTarget) metaBook.UI.setTarget(primary);
        if (metaBook.empty_cloud)
            metaBook.setCloudCuesFromTarget(metaBook.empty_cloud,primary);}
    metaBook.setTarget=setTarget;

    function clearHighlights(target){
        if (typeof target === "string") target=mbID(target);
        if (!(target)) return;
        else if (target.length) {
            dropClass(target,"mbhighlightpassage");
            var i=0, lim=target.length;
            while (i<lim) {
                var node=target[i++];
                fdjtUI.Highlight.clear(node,"mbhighlightexcerpt");
                fdjtUI.Highlight.clear(node,"mbhighlightsearch");}}
        else {
            dropClass(target,"mbhighlightpassage");
            fdjtUI.Highlight.clear(target,"mbhighlightexcerpt");
            fdjtUI.Highlight.clear(target,"mbhighlightsearch");}}
    metaBook.clearHighlights=clearHighlights;

    function findExcerpt(node,excerpt,off){
        if (typeof node === "string") node=mbID(node);
        if (!(node)) return false;
        if (node.nodeType) node=getDups(node);
        var trimmed=fdjtString.trim(excerpt);
        var before=((trimmed.search(/[.,"']/)===0)?("(^|\\s)"):("\\b"));
        var after=((trimmed.search(/[.,"']$/)>0)?("($|\\s)"):("\\b"));
        var pattern=fdjtDOM.textRegExp(trimmed,false,true,before,after);
        var matches=fdjtDOM.findMatches(node,pattern,off||0,1);
        if ((!(matches))||(matches.length===0)) {
            pattern=fdjtDOM.textRegExp(trimmed,true,true,before,after);
            matches=fdjtDOM.findMatches(node,pattern,off||0,1);}
        if ((matches)&&(matches.length)) return matches[0];
        // We could do this more intelligently
        var result=false, roff=-1;
        matches=fdjtDOM.findMatches(node,pattern,0,1);
        while (matches.length>0) {
            var first=matches[0];
            if (first.start_offset>off) {
                if (roff<0) return result;
                else if ((off-roff)<(result.start_offset-off))
                    return result;
                else return first;}
            else {result=first; roff=first.start_offset;}
            matches=fdjtDOM.findMatches(
                node,pattern,first.endOffset+1,1);}
        if ((matches)&&(matches.length)) return matches[0];
        else return result;}
    metaBook.findExcerpt=findExcerpt;

    /* Navigation */

    var sbookUIclasses=
        /(\bhud\b)|(\bglossmark\b)|(\bleading\b)|(\bmetabookmargin\b)/;

    function inUI(elt){
        if (elt.metabookui) return true;
        else if (hasParent(elt,metaBook.HUD)) return true;
        else while (elt)
            if (elt.metabookui) return true;
        else if (hasClass(elt,sbookUIclasses)) return true;
        else elt=elt.parentNode;
        return false;}
    metaBook.inUI=inUI;

    function setHashID(target){
        var targetid=target.codexbaseid||target.id;
        if ((!(targetid))||(window.location.hash===targetid)||
            ((window.location.hash[0]==='#')&&
             (window.location.hash.slice(1)===targetid)))
            return;
        if ((target===metaBook.body)||(target===document.body)) return;
        if (targetid) window.location.hash=targetid;}
    metaBook.setHashID=setHashID;

    function getLocInfo(elt){
        var eltid=false;
        var counter=0; var lim=200;
        var forward=fdjtDOM.forward;
        while ((elt)&&(counter<lim)) {
            eltid=elt.codexbaseid||elt.id;
            if ((eltid)&&(metaBook.docinfo[eltid])) break;
            else {counter++; elt=forward(elt);}}
        if ((eltid)&&(metaBook.docinfo[eltid])) {
            var info=metaBook.docinfo[eltid];
            return {start: info.starts_at,end: info.ends_at,
                    len: info.ends_at-info.starts_at};}
        else return false;
    } metaBook.getLocInfo=getLocInfo;

    function resolveLocation(loc){
        var allinfo=metaBook.docinfo._allinfo;
        var i=0; var lim=allinfo.length;
        while (i<lim) {
            if (allinfo[i].starts_at<loc) i++;
            else break;}
        while (i<lim)  {
            if (allinfo[i].starts_at>loc) break;
            else i++;}
        return mbID(allinfo[i-1].frag);
    } metaBook.resolveLocation=resolveLocation;

    // This moves within the document in a persistent way
    function metabookGoTo(arg,caller,istarget,savestate,skiphist){
        if (typeof istarget === 'undefined') istarget=true;
        if (typeof savestate === 'undefined') savestate=true;
        var target, location, locinfo;
        if (savestate) metaBook.clearStateDialog();
        if (!(arg)) {
            fdjtLog.warn("falsy arg (%s) to metabookGoTo from %s",arg,caller);
            return;}
        if (typeof arg === 'string') {
            target=mbID(arg);
            locinfo=getLocInfo(target);
            location=locinfo.start;}
        else if (typeof arg === 'number') {
            location=arg;
            target=((istarget)&&
                    (((istarget.nodeType)&&(istarget.id))?(istarget):
                     (resolveLocation(arg))));}
        else if ((arg.target)&&((arg.location)||(arg.offset))) {
            target=getTarget(arg.target);
            if (arg.location) 
                location=arg.location;
            else {
                locinfo=getLocInfo(arg.target);
                location=locinfo.start+arg.offset;}}
        else if (arg.nodeType) {
            target=getTarget(arg);
            locinfo=getLocInfo(arg);
            location=locinfo.start;}
        else {
            fdjtLog.warn("Bad metabookGoTo %o",arg);
            return;}
        if ((istarget)&&(istarget.nodeType)) target=istarget;
        else if ((typeof istarget === "string")&&(mbID(istarget)))
            target=mbID(istarget);
        else {}
        var info=(target)&&
            metaBook.docinfo[target.getAttribute("data-baseid")||target.id];
        if ((location)&&(info.ends_at)&&(info.starts_at)&&
            ((location>(info.ends_at))||(location<(info.starts_at))))
            // Why does this happen???
            location=false;
        var page=((metaBook.bypage)&&(metaBook.layout)&&
                  (metaBook.getPage(target,location)));
        var pageno=(page)&&(parseInt(page.getAttribute("data-pagenum"),10));
        if (mB.Trace.nav)
            fdjtLog("mB.GoTo(%s%s%s%s%s) %o location=%o page=%o pageno=%d arg=%o",
                    caller||"",((caller)?(":"):("")),((istarget)?("t"):("")),
                    ((savestate)?("s"):("")),((!(skiphist))?("h"):("")),
                    target,((location)?(location):("none")),page,pageno,arg);
        if (!(target)) {
            if (metaBook.layout instanceof fdjt.CodexLayout)
                metaBook.GoToPage(arg,caller,savestate);
            else if (arg.nodeType) {
                var scan=arg;
                while (scan) {
                    if (scan.offsetTop) break;
                    else scan=scan.parentNode;}
                if (scan) metaBook.content.style.offsetTop=-(scan.offsetTop);}
            else {}
            if (metaBook.curpage)
                saveState({location: metaBook.location,
                           page: metaBook.curpage,
                           npages: metaBook.pagecount},
                          true);
            else saveState({location: metaBook.location},true);
            return;}
        var targetid=target.codexbaseid||target.id;
        if (Trace.nav)
            fdjtLog("metaBook.GoTo%s() #%o@P%o/L%o %o",
                    ((caller)?("/"+caller):""),targetid,pageno,
                    ((info)&&(info.starts_at)),target);
        if (info) {
            metaBook.point=target;
            if (!((metaBook.hudup)||(metaBook.mode))) metaBook.skimpoint=false;}
        setHead(target);
        setLocation(location);
        if ((istarget)&&(targetid)&&(!(inUI(target)))) setTarget(target);
        if ((savestate)&&(istarget))
            metaBook.saveState({
                target: (target.getAttribute("data-baseid")||target.id),
                location: location,page: pageno,npages: metaBook.pagecount},
                               skiphist);
        else if (savestate)
            metaBook.saveState({location: location,page: pageno,
                                npages: metaBook.pagecount},
                               skiphist);
        else if (skiphist) {}
        else if (istarget)
            setHistory({
                target: (target.getAttribute("data-baseid")||target.id),
                location: location,page: pageno,npages: metaBook.pagecount});
        else setHistory({
            target: (target.getAttribute("data-baseid")||target.id),
            location: location,page: pageno,npages: metaBook.pagecount});
        if (page)
            metaBook.GoToPage(page,caller||"metabookGoTo",false,true);
        else {
            if (metaBook.previewing)
                metaBook.stopPreview(((caller)?("goto/"+caller):("goto")),target);
            var offinfo=fdjtDOM.getGeometry(target,metaBook.content);
            var use_top=offinfo.top-((fdjtDOM.viewHeight()-50)/2);
            if (use_top<0) use_top=0;
            window.scrollTo(0,use_top);}
        if (metaBook.clearGlossmark) metaBook.clearGlossmark();
        metaBook.location=location;
    } metaBook.GoTo=metabookGoTo;

    function anchorFn(evt){
        var target=fdjtUI.T(evt);
        while (target)
            if (target.href) break; else target=target.parentNode;
        if ((target)&&(target.href)&&(target.href[0]==='#')) {
            var elt=mbID(target.href.slice(1));
            if (elt) {metaBook.GoTo(elt,"anchorFn"); fdjtUI.cancel(evt);}}}
    metaBook.anchorFn=anchorFn;

    // This jumps and disables the HUD at the same time
    function metaBookJumpTo(target){
        if (metaBook.hudup) metaBook.setMode(false);
        metaBook.GoTo(target,"JumpTo");}
    metaBook.JumpTo=metaBookJumpTo;

    // This jumps and disables the HUD at the same time
    function metaBookGoTOC(target){
        if (target) metaBook.GoTo(target,"GoTOC");}
    metaBook.GoTOC=metaBookGoTOC;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/domscan.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements extraction of map and metadata from the loaded
   DOM.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
//var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
//var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
//var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

metaBook.DOMScan=(function(){
    "use strict";

    var mB=metaBook;
    var Trace=mB.Trace;
    var fdjtString=fdjt.String;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var RefDB=fdjt.RefDB;
    var Ref=RefDB.Ref;

    var getLevel=metaBook.getTOCLevel;

    function MetaBookDOMScan(root,dbid,docinfo){
        var md5ID=fdjt.WSN.md5ID;
        var stdspace=fdjtString.stdspace;
        var getStyle=fdjtDOM.getStyle;
        var rootns=root.namespaceURI;
        
        var idmap={};
        
        if (typeof root === 'undefined') return this;
        if (!(docinfo)) {
            if (this instanceof MetaBookDOMScan) docinfo=this;
            else docinfo=new MetaBookDOMScan();}
        if (!(root)) root=metaBook.docroot||document.body;
        var start=new Date();
        var allheads=[], allids=[];

        docinfo._root=root;
        docinfo._heads=allheads;
        docinfo._ids=allids;

        if (!(root.id)) root.id="METABOOKROOT";
        if ((Trace.startup>1)||(Trace.domscan)) {
            if (root.id) 
                fdjtLog("Scanning %s#%s for structure and metadata",
                        root.tagName,root.id);
            else fdjtLog("Scanning DOM for structure and metadata: %o",root);}
        var children=root.childNodes;
        var scanstate=
            {curlevel: 0,idserial:0,location: 0,
             nodecount: 0,eltcount: 0,headcount: 0,
             tagstack: [],taggings: [],allinfo: [],
             locinfo: [], idmap: idmap,
             idstate: {prefix: false,count: 0},
             idstack: [{prefix: false,count: 0}],
             pool: metaBook.docdb};

        var docdb=new RefDB(dbid);
        
        function ScanInfo(id,scanstate) {
            if (docinfo[id]) return docinfo[id];
            Ref.call(this,id,docdb);
            var now=fdjtTime();
            this._live=this._changed=now;
            docdb.changes.push(this);
            docdb.changed=now;
            this.frag=id;
            docinfo[id]=this;
            scanstate.allinfo.push(this);
            scanstate.locinfo.push(scanstate.location);
            return this;}
        ScanInfo.prototype=new Ref();
        
        docdb.refclass=ScanInfo;
        docinfo._docdb=docdb;

        function getTitle(head) {
            var title=
                (head.toctitle)||
                (head.getAttribute('toctitle'))||
                (head.getAttribute('data-toctitle'))||
                (head.title);
            if (!(title)) {
                var head1=fdjtDOM.getFirstChild(head,"H1,H2,H3,H4,H5,H6");
                if (head1) title=head1.toctitle||
                    (head1.getAttribute('toctitle'))||
                    (head1.getAttribute('data-toctitle'))||
                    (head1.title);
                if ((!(title))&&(head1)) title=gatherText(head1);
                else title=gatherText(head);}
            if (typeof title === "string") {
                var std=stdspace(title);
                if (std==="") return false;
                else return std;}
            else {
                title=fdjtDOM.textify(title,true);
                return title;}}

        function gatherText(head,s) {
            var root=(typeof s === "undefined");
            if (!(s)) s="";
            if (head.nodeType===3)
                return s+head.nodeValue;
            else if (head.nodeType!==1) return s;
            else {
                var style=getStyle(head), position=style.position;
                if ((root)||(position==="")||(position==="static")) {
                    var children=head.childNodes;
                    var i=0; var len=children.length;
                    while (i<len) {
                        var child=children[i++];
                        if (child.nodeType===3) s=s+child.nodeValue;
                        else if (child.nodeType===1)
                            s=gatherText(child,s);
                        else {}}
                    return s;}
                else return s;}}

        function textWidth(elt){
            if (elt.nodeType===3) return elt.nodeValue.length;
            else if (elt.nodeType!==1) return 0;
            else if (elt.getAttribute("data-loclen"))
                return parseInt(elt.getAttribute("data-loclen"),10);
            else {
                var children=elt.childNodes; var width=0;
                var i=0; var len=children.length;
                while (i<len) {
                    var child=children[i++];
                    if (child.nodeType===3)
                        width=width+child.nodeValue.length;
                    else if (child.nodeType===1)
                        width=width+textWidth(child);
                    else {}}
                return width;}}

        function handleHead(head,headid,docinfo,scanstate,level,
                            curhead,curinfo,curlevel){
            var headinfo=docinfo[headid]||
                (docinfo[headid]=new ScanInfo(headid,scanstate));
            scanstate.headcount++;
            allheads.push(headid);
            if (Trace.domscan>1)
                fdjtLog("Scanning head item %o under %o at level %d w/id=#%s ",
                        head,curhead,level,headid);
            /* Iniitalize the headinfo */
            headinfo.starts_at=scanstate.location;
            headinfo.level=level; headinfo.elt=head; 
            headinfo.sub=[];
            headinfo.frag=headid;
            headinfo.title=getTitle(head);
            headinfo.next=false; headinfo.prev=false;
            if (headinfo.title)
                headinfo.sectag="\u00a7"+stdspace(headinfo.title);
            else headinfo.sectag="\u00a7Anonymous Section";
            if (level>curlevel) {
                /* This is the simple case where we are a subhead
                   of the current head. */
                headinfo.head=curinfo;
                headinfo.indexRef('head',curinfo);
                if (!(curinfo.intro_ends_at))
                    curinfo.intro_ends_at=scanstate.location;
                curinfo.sub.push(headinfo);
                /* There is one special case here, were there is a
                   previous head/section (created by a whole block
                   wrapped in a section/article/etc block. */
                if (scanstate.lastlevel===level) {
                    headinfo.prev=scanstate.lastinfo;
                    scanstate.lastinfo.next=headinfo;
                    delete scanstate.lastlevel;
                    delete scanstate.lasthead;
                    delete scanstate.lastinfo;}}
            else { /* We're not a subhead, so
                      we're popping up at least one level. */
                var scan=curhead;
                var scaninfo=curinfo;
                var scanlevel=curinfo.level;
                /* Climb the stack of headers, closing off entries and
                   setting up prev/next pointers where needed. */
                while (scaninfo) {
                    if (Trace.domscan>2)
                        fdjtLog("Finding head@%d: s=%o, i=%j, sh=%o, cmp=%o",
                                scanlevel,scan||false,scaninfo,
                                (scanlevel<level));
                    if (scanlevel<level) break;
                    if (level===scanlevel) {
                        headinfo.prev=scaninfo;
                        scaninfo.next=headinfo;}
                    scaninfo.ends_at=scanstate.location;
                    scanstate.tagstack=scanstate.tagstack.slice(0,-1);
                    scaninfo=scaninfo.head;
                    scan=scaninfo.elt||document.getElementById(scaninfo.frag);
                    scanlevel=((scaninfo)?(scaninfo.level):(0));}
                if (Trace.domscan>2)
                    fdjtLog("Found parent: up=%o, info=%o, leel=%d, sh=%o",
                            scan||false,scaninfo,scaninfo.level,scaninfo.head);
                /* We've found the enclosing head for this head, so we
                   establish the links. */
                headinfo.head=scaninfo;
                headinfo.indexRef('head',scaninfo);
                scaninfo.sub.push(headinfo);}
            /* If we have a head, we get its tags. */
            var supinfo=headinfo.head;
            
            /* We create an array of all the heads, which lets us
               replace many recursions with iterations. */
            var newheads=[];
            if (supinfo.heads) newheads=newheads.concat(supinfo.heads);
            if (supinfo) newheads.push(supinfo);
            headinfo.heads=newheads;
            headinfo.indexRef('heads',newheads);
            if (Trace.domscan>2)
                fdjtLog("@%d: Found head=%o, headinfo=%o, book_head=%o",
                        scanstate.location,head,headinfo,headinfo.head);
            /* Update the toc state */
            scanstate.curhead=head;
            scanstate.curinfo=headinfo;
            scanstate.curlevel=level;
            if (headinfo)
                headinfo.ends_at=scanstate.location+textWidth(head);
            scanstate.location=scanstate.location+textWidth(head);}

        function scanner(child,scanstate,docinfo){
            var location=scanstate.location;
            var curhead=scanstate.curhead;
            var curinfo=scanstate.curinfo;
            var curlevel=scanstate.curlevel;
            scanstate.nodecount++;
            // Location tracking and TOC building
            if (child.nodeType===3) {
                var stdcontent=stdspace(child.nodeValue);
                var width=stdcontent.length;
                // Need to regularize whitespace
                scanstate.location=scanstate.location+width;
                return 0;}
            else if (child.nodeType!==1) return 0;
            else {}
            var tag=child.tagName, classname=child.className;
            var id=child.id;
            
            if (id) id=child.getAttribute('data-tocid')||id;

            if ((metaBook.ignore)&&(metaBook.ignore.match(child)))
                return;
            
            if ((rootns)&&(child.namespaceURI!==rootns)) return;
            
            if ((classname)&&
                ((typeof classname !== "string")||
                 (classname.search(/\b(metabookignore)\b/)>=0)))
                return;
            
            if ((child.metabookui)||
                ((id)&&(id.search("METABOOK")===0)))
                return;
            
            if (Trace.domscan>3)
                fdjtLog("Scanning %o level=%o, loc=%o, head=%o: %j",
                        child,curlevel,location,curhead,curinfo);

            if ((!(id))&&(!(metaBook.baseid))) {
                // If there isn't a known BASEID, we generate
                //  ids for block level elements using WSN.
                var wsn=false;
                if (((tag.search(/p|h\d|blockquote|li/i)===0)||
                     (getStyle(child).display.search(
                             /block|list-item|table|table-row/)===0))&&
                    ((child.childNodes)&&(child.childNodes.length))&&
                    (wsn=md5ID(child))) {
                    var baseid="WSN_"+wsn, wsnid=baseid, count=1;
                    if (baseid!=="WSN_") {
                        while ((document.getElementById[wsnid])||(idmap[wsnid]))
                            wsnid=baseid+"_"+(count++);
                        if (baseid!==wsnid) {
                            var text=fdjtDOM.textify(child);
                            fdjtLog.warn("Duplicate WSN ID %s: %s",
                                         wsnid,text);}
                        id=child.id=wsnid; idmap[wsnid]=child;}}}
            else if ((id)&&(metaBook.baseid)&&
                     (id.search(metaBook.baseid)!==0))
                id=false;
            else if (!(id)) {}
            else if (!(idmap[id])) idmap[id]=child;
            else if (idmap[id]!==child) {
                var newid=id+"x"+scanstate.location;
                if (idmap[id]) {
                    var u=1; var xid=newid+"x"+u;
                    while (idmap[xid]) {u++; xid=newid+"x"+u;}
                    newid=xid;}
                fdjtLog.warn("Duplicate ID=%o newid=%o",id,newid);
                id=child.id=newid;
                headinfo=docinfo[newid]||
                    (docinfo[newid]=new ScanInfo(newid,scanstate));
                idmap[newid]=child;}
            else idmap[id]=child;

            var i=0, lim;
            // Get the location in the TOC for this out of context node
            //  These get generated, for example, when the content of an
            //  authorial footnote is moved elsewhere in the document.
            var tocloc=(child.metabooktocloc)||
                (child.getAttribute("data-tocloc"));
            if ((tocloc)&&(docinfo[tocloc])) {
                var tocinfo=docinfo[tocloc];
                curlevel=scanstate.curlevel;
                curhead=scanstate.curhead;
                curinfo=scanstate.curinfo;
                var notoc=scanstate.notoc;
                var headinfo=tocinfo.head;
                scanstate.curinfo=headinfo;
                scanstate.curhead=headinfo.elt||
                    document.getElementById(headinfo.frag);
                scanstate.curlevel=headinfo.level;
                scanstate.notoc=true;
                var toc_children=child.childNodes;
                i=0; lim=toc_children.length; while (i<lim) {
                    var toc_child=toc_children[i++];
                    if (toc_child.nodeType===1)
                        scanner(toc_child,scanstate,docinfo);}
                // Put everything back
                scanstate.curlevel=curlevel; scanstate.notoc=notoc;
                scanstate.curhead=curhead; scanstate.curinfo=curinfo;
                return;}
            var toclevel=((id)&&(getLevel(child,curlevel)));
            // The header functionality is handled by its surrounding
            // section (which should have a toclevel of its own)
            if ((scanstate.notoc)||(tag==='header')) {
                scanstate.notoc=true; toclevel=0;}
            scanstate.eltcount++;
            var info=(id&&(docinfo[id]));
            if ((!(info))&&(id)) {
                allids.push(id); info=new ScanInfo(id,scanstate);
                docinfo[id]=info; info.elt=child;}
            if ((info)&&(id)&&(child.id)&&(child.id!==id))
                // Store info under both ID and TOCID if different
                docinfo[child.id]=info;
            if (info) {
                info.starts_at=scanstate.location;
                info.bookhead=
                    curhead.getAttribute('data-tocid')||curhead.id;
                info.headstart=curinfo.starts_at;}
            // Set the first content node
            if ((id)&&(info)&&(!start)) metaBook.start=start=child;
            // And the initial content level
            if ((info)&&(toclevel)&&(!(info.toclevel)))
                info.toclevel=toclevel;
            if ((id)&&(info)) {
                var tags=(child.getAttribute('tags'))||
                    (child.getAttribute('data-tags'));
                if (tags) info.atags=tags.split(',');}
            if (((classname)&&(classname.search)&&
                 (classname.search(/\bsbookignore\b/)>=0))||
                ((metaBook.ignore)&&(metaBook.ignore.match(child))))
                return;
            if ((toclevel)&&(!(info.tocdone)))
                handleHead(child,id,docinfo,scanstate,toclevel,
                           curhead,curinfo,curlevel);
            else if (info) {
                info.head=curinfo; info.indexRef('head',curinfo);}
            else {}

            if (((classname)&&(classname.search)&&
                 (classname.search(/\bsbookterminal\b/)>=0))||
                ((classname)&&(metaBook.terminals)&&
                 (metaBook.terminals.match(child)))) {
                scanstate.location=scanstate.location+textWidth(child);}
            else {
                var grandchildren=child.childNodes;
                i=0; lim=grandchildren.length;
                while (i<lim) {
                    var grandchild=grandchildren[i++];
                    if (grandchild.nodeType===3) {
                        var content=stdspace(grandchild.nodeValue);
                        scanstate.location=scanstate.location+
                            content.length;}
                    else if (grandchild.nodeType===1) {
                        scanner(grandchild,scanstate,docinfo);}}}
            if (info) info.ends_at=scanstate.location;
            
            if (toclevel) {
                scanstate.lasthead=child; scanstate.lastinfo=info;
                scanstate.lastlevel=toclevel;}}

        var rootinfo=(docinfo[root.id])||
            (docinfo[root.id]=new ScanInfo(root.id,scanstate));
        scanstate.curhead=root; scanstate.curinfo=rootinfo;
        rootinfo.title=root.title||document.title;
        rootinfo.starts_at=0;
        rootinfo.level=0; rootinfo.sub=[];
        rootinfo.head=false; rootinfo.heads=[];
        rootinfo.frag=root.id;
        rootinfo.elt=root;
        scanstate.allinfo.push(rootinfo);
        scanstate.allinfo.push(0);
        /* Build the metadata */
        var i=0; while (i<children.length) {
            var child=children[i++];
            if (!((child.sbookskip)||(child.metabookui)))
                scanner(child,scanstate,docinfo);} 
        docinfo._nodecount=scanstate.nodecount;
        docinfo._headcount=scanstate.headcount;
        docinfo._eltcount=scanstate.eltcount;
        docinfo._maxloc=scanstate.location;
        docinfo._allinfo=scanstate.allinfo;
        docinfo._locinfo=scanstate.locinfo;
        var scaninfo=scanstate.curinfo;
        /* Close off all of the open spans in the TOC */
        while (scaninfo) {
            scaninfo.ends_at=scanstate.location;
            scaninfo=scaninfo.head;}
        var done=new Date();
        if ((Trace.startup)||(Trace.domscan))
            fdjtLog('Gathered metadata in %f secs over %d heads, %d nodes',
                    (done.getTime()-start.getTime())/1000,
                    scanstate.headcount,scanstate.eltcount);
        docinfo.addContent=function(node){
            scanner(node,scanstate,docinfo);
            docinfo._nodecount=scanstate.nodecount;
            docinfo._headcount=scanstate.headcount;
            docinfo._eltcount=scanstate.eltcount;
            docinfo._maxloc=scanstate.location;
            docinfo._allinfo=scanstate.allinfo;
            docinfo._locinfo=scanstate.locinfo;
            var scaninfo=scanstate.curinfo;
            /* Close off all of the open spans in the TOC */
            while (scaninfo) {
                scaninfo.ends_at=scanstate.location;
                scaninfo=scaninfo.head;}};
        
        docinfo._rootinfo=docinfo[root.id];

        return docinfo;}

    MetaBookDOMScan.prototype.toJSON=function(){
        var rep={constructor: "metaBook.DOMScan",
                 frag: this.frag,
                 head: this.bookhead,
                 start: this.starts_at,
                 end: this.ends_at};
        if (this.WSNID) rep.WSNID=this.WSNID;
        if (this.headstart) rep.headstart=this.headstart;
        if (this.toclevel) rep.toclevel=this.toclevel;
        if (this.title) rep.title=this.title;
        return JSON.stringify(rep);};
    
    MetaBookDOMScan.getTOCLevel=getLevel;
    return MetaBookDOMScan;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/glossdata.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* globals Promise */

// config.js
(function(){
    "use strict";
    var fdjtLog=fdjt.Log, fdjtState=fdjt.State;
    var setLocal=fdjtState.setLocal, getLocal=fdjtState.getLocal;
    var dropLocal=fdjtState.dropLocal;
    var pushLocal=fdjtState.pushLocal, removeLocal=fdjtState.removeLocal;

    var mB=metaBook, Trace=metaBook.Trace;
    
    /* Noting (and caching) glossdata */

    var glossdata=metaBook.glossdata, glossdata_state={};
    var glossdata_waiting={};
    var createObjectURL=
        ((window.URL)&&(window.URL.createObjectURL))||
        ((window.webkitURL)&&(window.webkitURL.createObjectURL));
    var Blob=window.Blob;

    function setupGlossData(){
        var cached=getLocal("mB("+mB.docid+").glossdata",true);
        var i=0, len=cached.length; while (i<len) 
            glossdata_state[cached[i++]]="cached";}
    metaBook.setupGlossData=setupGlossData;

    function cacheGlossData(uri){
        function caching(resolved){
            if (uri.search(mB.cachelink)!==0) return;
            if (glossdata[uri]) return resolved(glossdata[uri]);
            if (glossdata_state[uri]==="cached") return;
            else if (glossdata_state[uri]) {
                if (glossdata_waiting[uri])
                    glossdata_waiting[uri].push(resolved);
                else glossdata_waiting[uri]=[resolved];
                return;}
            else glossdata_state[uri]="fetching";
            var req=new XMLHttpRequest(), endpoint, rtype;
            if ((!(Blob))||(!(createObjectURL))) {
                // This endpoint returns a datauri as text
                endpoint="https://glossdata.bookhub.io/U/"+
                    uri.slice("https://glossdata.bookhub.io/".length);
                rtype="";}
            else {endpoint=uri; rtype="blob";}
            // We provide credentials in the query string because we
            //  need to have .withCredentials be false to avoid some
            //  CORS-related errors on redirects to sites like S3.
            var mycopyid=mB.mycopyid;
            if (mycopyid) {
                endpoint=endpoint+"?MYCOPYID="+encodeURIComponent(mycopyid)+
                    "&DOC="+encodeURIComponent(mB.docref);}
            if (Trace.glossdata) {
                fdjtLog("Fetching glossdata %s (%s) to cache locally",uri,rtype);}
            req.onreadystatechange=function () {
                if ((req.readyState === 4)&&(req.status === 200)) {
                    try {
                        var local_uri=false, data_uri=false;
                        if (Trace.glossdata)
                            fdjtLog("Glossdata from %s (%s) status %d",
                                    endpoint,rtype||"any",req.status);
                        if (rtype!=="blob")
                            data_uri=local_uri=req.responseText;
                        else if (createObjectURL) 
                            local_uri=createObjectURL(req.response);
                        else local_uri=false;
                        if (local_uri) gotLocalURL(uri,local_uri,resolved);
                        if (data_uri) {
                            glossdata_state[uri]="caching";
                            cacheDataURI(uri,data_uri);}
                        else {
                            // Need to get a data uri
                            var reader=new FileReader(req.response);
                            glossdata_state[uri]="reading";
                            reader.onload=function(){
                                try {
                                    if (!(local_uri))
                                        gotLocalURL(uri,reader.result,resolved);
                                    glossdata_state[uri]="caching";
                                    cacheDataURI(uri,reader.result);}
                                catch (ex) {
                                    fdjtLog.warn("Error encoding %s from %s: %s",
                                                 uri,endpoint,ex);
                                    glossdata_state[uri]=false;}};
                            reader.readAsDataURL(req.response);}}
                    catch (ex) {
                        fdjtLog.warn("Error fetching %s via %s: %s",uri,endpoint,ex);
                        glossdata_state[uri]=false;}}};
            req.open("GET",endpoint);
            req.responseType=rtype;
            // req.withCredentials=true;
            req.send(null);}
        return new Promise(caching);}

    function needGlossData(uri){
        if ((glossdata[uri])||(glossdata_state[uri]==="cached")) return;
        if ((mB.mycopyid)&&(mB.mycopyid_expires<(new Date())))
            return cacheGlossData(uri);
        else {
            var req=mB.getMyCopyId();
            return req.then(function(mycopyid){if (mycopyid) cacheGlossData(uri);});}}
    metaBook.needGlossData=needGlossData;

    function getGlossData(uri){
        function getting(resolved){
            if (glossdata[uri]) resolved(glossdata[uri]);
            else if (glossdata_state[uri]==="cached")  {
                metaBook.getDB().then(function(db){
                    var txn=db.transaction(["glossdata"],"readwrite");
                    var storage=txn.objectStore("glossdata");
                    var req=storage.get(uri);
                    req.onsuccess=function(event){
                        var object=event.target.result;
                        gotLocalURL(uri,object.datauri,resolved);};
                    req.onerror=function(ex){
                        fdjtLog("Error getting %s from glossdata cache: %s",
                                uri,ex);
                        glossdata_state[uri]=false;
                        if ((mB.mycopyid)&&(mB.mycopyid_expires<(new Date())))
                            setTimeout(function(){cacheGlossData(uri);},2000);
                        else mB.getMyCopyId().then(function(mycopyid){
                            if (mycopyid)
                                setTimeout(function(){cacheGlossData(uri);},2000);});};});}
            else if ((mB.mycopyid)&&(mB.mycopyid_expires<(new Date())))
                return cacheGlossData(uri).then(resolved);
            else return mB.getMyCopyId().then(function(mycopyid){
                if (mycopyid) return cacheGlossData(uri).then(resolved);});}
        return new Promise(getting);}
    metaBook.getGlossData=getGlossData;

    function gotLocalURL(uri,local_url,resolved){
        var i, lim;
        var waiting_elts=mB.srcloading[uri], waiting=glossdata_waiting[uri];
        mB.srcloading[uri]=false; glossdata_waiting[uri]=false;
        glossdata[uri]=local_url;
        if (resolved) resolved(local_url);
        if (waiting_elts) {
            i=0; lim=waiting_elts.length;
            if (Trace.glossdata)
                fdjtLog("Setting glossdata src for %d element(s)",lim);
            while (i<lim) waiting_elts[i++].src=local_url;}
        if (waiting) {
            i=0; lim=waiting.length;
            while (i<lim) waiting[i++](local_url);
            mB.srcloading[uri]=false;}}

    function cacheDataURI(url,datauri){
        var key="gD("+url+").glossdata";
        metaBook.getDB().then(function(db){
            var txn=db.transaction(["glossdata"],"readwrite");
            var storage=txn.objectStore("glossdata");
            var req=storage.put({url: url,datauri: datauri});
            var completed=false;
            req.onerror=function(event){
                glossdata_state[url]=false; completed=true;
                fdjtLog("Error saving %s in indexedDB: %o",
                        url,event.target.errorCode);};
            req.onsuccess=function(){
                glossdata_state[url]="cached"; completed=true;
                if (Trace.glossdata)
                    fdjtLog("Saved glossdata for %s in IndexedDB",url);
                glossDataSaved(url);};
            if ((req.status==="done")&&(!(completed))) req.onsuccess();})
            .catch(function(){setLocal(key,datauri);});}

    function glossDataSaved(url){
        if (Trace.glossdata) fdjtLog("GlossData cached for %s",url);
        pushLocal("mB("+mB.docid+").glossdata",url);}

    function clearGlossData(docid){
        var key="mB("+docid+").glossdata", urls=getLocal(key,true);
        if ((urls)&&(urls.length)) {
            clearGlossDataCache(urls,key);}
        else dropLocal(key);}
    metaBook.clearGlossData=clearGlossData;

    function clearGlossDataCache(urls,key){
        function clearing(resolve){
            metaBook.getDB().then(function(db){
                var txn=db.transaction(["glossdata"],"readwrite");
                var storage=txn.objectStore("glossdata");
                storage.openCursor().onsuccess=function(event){
                    var cursor=event.target.result;
                    if (cursor) {
                        if (urls.indexOf(cursor.key)>=0) {
                            var req=cursor['delete']();
                            req.onsuccess=function(){
                                removeLocal(key,cursor.key);
                                cursor['continue']();};
                            req.onerror=function(){cursor['continue']();};}
                        else cursor['continue']();}
                    else resolve();};});}
        return new Promise(clearing);}

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/cover.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log, fdjtString=fdjt.String;
    var fdjtUI=fdjt.UI, fdjtTime=fdjt.Time, $ID=fdjt.ID;
    var dropClass=fdjtDOM.dropClass, addClass=fdjtDOM.addClass;
    var hasClass=fdjtDOM.hasClass, hasParent=fdjtDOM.hasParent;
    var getChildren=fdjtDOM.getChildren;
    
    var mB=metaBook, Trace=mB.Trace;
    var fixStaticRefs=metaBook.fixStaticRefs;

    var hasContent=fdjtDOM.hasContent;
    
    function hasAnyContent(n){return hasContent(n,true);}


    // Console input and evaluation
    // These are used by the input handlers of the console log
    var input_console=false, input_button=false;
    
    /* Console methods */
    function console_eval(){
        /* jshint evil: true */
        fdjtLog("Executing %s",input_console.value);
        var result=eval(input_console.value);
        var string_result=
            ((result.nodeType)?
             (fdjtString("%o",result)):
             (fdjtString("%j",result)));
        fdjtLog("Result is %s",string_result);}
    function consolebutton_click(evt){
        if (Trace.gesture>1) fdjtLog("consolebutton_click %o",evt);
        console_eval();}
    function consoleinput_keypress(evt){
        evt=evt||window.event;
        if (evt.keyCode===13) {
            if (!(evt.ctrlKey)) {
                fdjtUI.cancel(evt);
                console_eval();
                if (evt.shiftKey) input_console.value="";}}}

    function stripExplicitStyles(root){
        if ((root.id)&&(root.id.search("METABOOK")===0))
            root.removeAttribute("style");
        if (root.childNodes) {
            var children=root.childNodes;
            var i=0, lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (child.nodeType===1) stripExplicitStyles(child);}}}

    // Cover setup
    function setupCover(){
        var frame=$ID("METABOOKFRAME"), started=fdjtTime();
        var cover=fdjtDOM("div#METABOOKCOVER.metabookcover");
        var existing_cover=$ID("METABOOKCOVER");
        if (Trace.startup>2) fdjtLog("Setting up cover");
        if (!(frame)) {
            frame=fdjtDOM("div#METABOOKFRAME");
            fdjtDOM.prepend(document.body,frame);}
        metaBook.Frame=frame;
        metaBook.cover=cover;
        cover.innerHTML=fixStaticRefs(metaBook.HTML.cover);
        
        var coverpage=$ID("METABOOKCOVERPAGE");
        if (coverpage) {
            if (!(hasAnyContent(coverpage))) {
                coverpage.removeAttribute("style");
                coverpage=false;}}
        else if (metaBook.coverimage) {
            var coverimage=fdjtDOM.Image(metaBook.coverimage);
            coverimage.id="METABOOKCOVERIMAGE";
            coverpage=fdjtDOM("div.flap#METABOOKCOVERPAGE",coverimage);}
        else coverpage=false;
        if (coverpage) {
            cover.setAttribute("data-defaultclass","coverpage");
            addClass(cover,"coverpage");
            addToCover(cover,coverpage);}
        else {
            var controls=fdjt.DOM.getChild(cover,"#METABOOKCOVERCONTROLS");
            cover.setAttribute("data-defaultclass","titlepage");
            addClass(cover,"titlepage");
            addClass(controls,"nocoverpage");}
        var titlepage=$ID("METABOOKTITLE");
        if ((titlepage)&&(hasAnyContent(titlepage))) {
            titlepage=titlepage.cloneNode(true);
            titlepage.removeAttribute("style");
            titlepage.id="METABOOKTITLE";}
        else {
            titlepage=$ID("METABOOKTITLEPAGE")||
                $ID("PUBTOOLTITLEPAGE")||
                $ID("TITLEPAGE");
            if (titlepage) {
                titlepage=titlepage.cloneNode(true);
                fdjtDOM.dropClass(
                    titlepage,/\b(codex|metabook)[A-Za-z0-9]+\b/);
                fdjtDOM.addClass(titlepage,"sbooktitlepage");
                fdjtDOM.stripIDs(titlepage);
                titlepage.setAttribute("style","");
                titlepage.id="METABOOKTITLE";}
            else {
                var info=metaBook.getBookInfo();
                titlepage=fdjtDOM(
                    "div#METABOOKTITLE.flap",
                    fdjtDOM("DIV.title",info.title),
                    fdjtDOM("DIV.credits",
                            ((info.byline)?(fdjtDOM("DIV.byline",info.byline)):
                             ((info.authors)&&(info.authors.length))?
                             (fdjtDOM("DIV.author",info.authors[0])):
                             (false))),
                    fdjtDOM("DIV.pubinfo",
                            ((info.publisher)&&
                             (fdjtDOM("P",info.publisher)))));}}
        if (titlepage) addToCover(cover,titlepage);

        var creditspage=$ID("METABOOKCREDITS");
        if (creditspage)
            creditspage=creditspage.cloneNode(true);
        else {
            creditspage=$ID("METABOOKCREDITS")||$ID("SBOOKSCREDITSPAGE")||$ID("CREDITSPAGE");
            if (creditspage) {
                creditspage=creditspage.cloneNode(true);
                fdjtDOM.stripIDs(creditspage);
                creditspage.removeAttribute("style");}}
        if ((creditspage)&&(hasAnyContent(creditspage))) {
            var curcredits=cover.getElementById("METABOOKCREDITS");
            if (curcredits)
                curcredits.parentNode.replaceChild(creditspage,curcredits);
            else cover.appendChild(creditspage);}
        else creditspage=false;
        if (creditspage) addToCover(cover,creditspage);
        
        var blurb=$ID("METABOOKBLURB")||$ID("METABOOKABOUTPAGE");
        if ((blurb)&&(hasAnyContent(blurb))) {
            blurb=blurb.cloneNode(true);
            blurb.id="METABOOKBLURB";
            blurb.removeAttribute("style");}
        else {
            var about_book=$ID("METABOOKABOUTPAGE")||
                $ID("METABOOKABOUTBOOK")||
                $ID("PUBTOOLABOUTBOOK");
            var about_author=$ID("METABOOKABOUTAUTHOR")||
                $ID("PUBTOOLABOUTAUTHOR");
            if ((about_book)||(about_author)) {
                blurb=fdjtDOM(
                    "div#METABOOKBLURB.flap.metabookblurb.scrolling",
                    "\n",about_book,"\n",about_author,"\n");}
            else blurb=false;}
        if (blurb) addToCover(cover,blurb);
        
        var settings=fdjtDOM(
            "div#METABOOKSETTINGS.flap.scrolling");
        settings.innerHTML=fixStaticRefs(metaBook.HTML.settings);
        metaBook.DOM.settings=settings;
        if (settings) addToCover(cover,settings);
        
        var cover_help=fdjtDOM(
            "div#METABOOKAPPHELP.flap.metabookhelp.scrolling");
        cover_help.innerHTML=fixStaticRefs(metaBook.HTML.help);
        if (cover_help) addToCover(cover,cover_help);
        
        var console=metaBook.DOM.console=
            fdjtDOM("div#METABOOKCONSOLE.flap.metabookconsole.scrolling");
        if (Trace.startup>2) fdjtLog("Setting up console %o",console);
        console.innerHTML=fixStaticRefs(metaBook.HTML.console);
        metaBook.DOM.input_console=input_console=
            fdjtDOM.getChild(console,"TEXTAREA");
        metaBook.DOM.input_button=input_button=
            fdjtDOM.getChild(console,"span.button");
        input_button.onclick=consolebutton_click;
        input_console.onkeypress=consoleinput_keypress;
        if (console) addToCover(cover,console);
        
        var layers=fdjtDOM("div#METABOOKLAYERS.flap");
        var sbooksapp=fdjtDOM("iframe#BOOKHUBAPP");
        sbooksapp.setAttribute("frameborder",0);
        sbooksapp.setAttribute("scrolling","auto");
        layers.appendChild(sbooksapp);
        metaBook.DOM.sbooksapp=sbooksapp;
        if (layers) addToCover(cover,layers);
        
        var cc=getChildren(cover,"#METABOOKCOVERCONTROLS");
        if (cc) {
            if (!(coverpage)) addClass(cc,"nobookcover");
            if (!(creditspage)) addClass(cc,"nocredits");
            if (!(blurb)) addClass(cc,"noblurb");}
        
        if (metaBook.touch)
            fdjtDOM.addListener(cover,"touchstart",cover_clicked);
        else fdjtDOM.addListener(cover,"click",cover_clicked);
        
        stripExplicitStyles(cover);

        if ((existing_cover)&&(existing_cover.parentNode===frame))
            frame.replaceChild(cover,existing_cover);
        else {
            frame.appendChild(cover); 
            if (existing_cover)
                existing_cover.parentNode.removeChild(existing_cover);}
        
        metaBook.showCover();
        
        // Make the cover hidden by default
        metaBook.CSS.hidecover=fdjtDOM.addCSSRule(
            "#METABOOKCOVER","opacity: 0.0; z-index: -10; pointer-events: none; height: 0px; width: 0px;");
        if (Trace.startup>1)
            fdjtLog("Cover setup done in %dms",fdjtTime()-started);
        return cover;}
    metaBook.setupCover=setupCover;


    var toArray=fdjtDOM.toArray;
    function addToCover(cover,item){
        var children=toArray(cover.childNodes);
        var i=0, lim=children.length; while (i<lim) {
            var child=children[i++];
            if ((child.nodeType===1)&&
                ((child.id===item.id)||(child.id===(item.id+"HOLDER")))) {
                cover.replaceChild(item,child);
                return;}}
        cover.appendChild(item);}

    function resizeCover(cover){
        if (!(cover)) cover=$ID("METABOOKCOVER");
        if (!(cover)) return;
        var frame=$ID("METABOOKFRAME");
        var style=cover.style, framestyle=frame.style;
        var restore=0;
        if (!(cover.offsetHeight)) {
            restore=1; style.zIndex=-500; style.visibility='hidden';
            style.opacity=0; style.display='block';
            style.height='100%'; style.width='100%';
            framestyle.display='block';}
        var controls=$ID("METABOOKCOVERCONTROLS");
        var userbox=$ID("METABOOKUSERBOX");
        fdjtDOM.adjustFontSize(controls);
        fdjtDOM.adjustFontSize(userbox);
        // fdjt.DOM.resetFontSize(controls);
        // fdjt.DOM.resetFontSize(userbox);            
        var covertitle=$ID("METABOOKTITLE");
        if ((covertitle)&&
            (!(hasClass(covertitle,/\b(adjustfont|fdjtadjustfont)\b/))))
            fdjtDOM.adjustFontSize(covertitle);
        if (restore) {
            style.zIndex=''; style.display='';
            style.opacity=''; style.visibility='';
            framestyle.display='';}}
    metaBook.resizeCover=resizeCover;

    var coverids={"coverpage": "METABOOKCOVERPAGE",
                  "titlepage": "METABOOKTITLE",
                  "creditspage": "METABOOKCREDITS",
                  "blurb": "METABOOKBLURB",
                  "help": "METABOOKAPPHELP",
                  "settings": "METABOOKSETTINGS",
                  "layers": "METABOOKLAYERS"};

    function cover_clicked(evt){
        var target=fdjtUI.T(evt);
        var cover=$ID("METABOOKCOVER");
        if (metaBook.statedialog) {
            fdjt.Dialog.close(metaBook.statedialog);
            metaBook.statedialog=false;}
        if (fdjt.UI.isClickable(target)) return;
        if (hasParent(target,$ID("METABOOKCOVERCONTROLS")))
            return controls_clicked(evt,target,cover);
        else if (hasParent(target,".scrolling")) {}
        else {
            metaBook.clearStateDialog();
            metaBook.hideCover();
            fdjtUI.cancel(evt);
            return;}}
        
    function controls_clicked(evt,target,cover){
        var scan=target;
        while (scan) {
            if (scan===document.body) break;
            else if (scan.getAttribute("data-mode")) break;
            else scan=scan.parentNode;}
        var mode=scan.getAttribute("data-mode");
        if ((mode==="layers")&&
            (!($ID("BOOKHUBAPP").src))&&
            (!(metaBook.appinit)))
            metaBook.initIFrameApp();

        var curclass=cover.className;
        var cur=((curclass)&&(coverids[curclass])&&
                 ($ID(coverids[curclass])));
        var nxt=((mode)&&(coverids[mode])&&($ID(coverids[mode])));
        if ((cur)&&(nxt)) {
            cur.style.display='block';
            nxt.style.display='block';
            setTimeout(function(){
                cur.style.display="";
                nxt.style.display="";},
                       3000);}
        setTimeout(function(){
            if (Trace.mode)
                fdjtLog("On %o, switching cover mode to %s from %s",
                        evt,mode,curclass);
            if (mode==="console") fdjtLog.update();
            cover.className=mode;
            metaBook.mode=mode;},
                   20);
        fdjt.UI.cancel(evt);
        return false;}

    metaBook.addConfig("showconsole",function(name,value){
        var root=document.documentElement||document.body;
        if (value) addClass(root,"_SHOWCONSOLE");
        else dropClass(root,"_SHOWCONSOLE");
        var controls=$ID("METABOOKCOVERCONTROLS");
        if (controls) fdjtDOM.adjustFontSize(controls);
        fdjt.Async(function(){metaBook.updateSettings(name,value);});});

}());

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/nav.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

// body.js
(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log, $ID=fdjt.ID;
    var fdjtTime=fdjt.Time, fdjtString=fdjt.String;
    var dropClass=fdjtDOM.dropClass, addClass=fdjtDOM.addClass;
    var getGeometry=fdjtDOM.getGeometry;
    var getChildren=fdjtDOM.getChildren, getChild=fdjtDOM.getChild;
    var toArray=fdjtDOM.toArray;
    var isEmpty=fdjtString.isEmpty;

    var mB=metaBook, Trace=metaBook.Trace;
    var applyMetaClass=mB.applyMetaClass;
    var fixStaticRefs=mB.fixStaticRefs;
    /* Initializing the body and content */
    var note_counter=1;
    
    function getBGColor(arg){
        var color=fdjtDOM.getStyle(arg).backgroundColor;
        if (!(color)) return false;
        else if (color==="transparent") return false;
        else if (color.search(/rgba/)>=0) return false;
        else return color;}

    function initBody(){
        var body=document.body, started=fdjtTime();
        var init_content=$ID("CODEXCONTENT");
        var content=(init_content)||(fdjtDOM("div#CODEXCONTENT"));
        var i, lim;
        if (Trace.startup>2) fdjtLog("Starting initBody");

        addClass(content,"metabookcontent");
        addClass(content,"codexroot");

        body.setAttribute("tabindex",1);
        /* Remove explicit constraints */
        body.style.fontSize=""; body.style.width="";

        // Save those DOM elements in a handy place
        metaBook.content=content;

        // Move all the notes together
        var notesblock=$ID("SBOOKNOTES")||
            fdjtDOM("div.sbookbackmatter#SBOOKNOTES");
        applyMetaClass("htmlbooknote");
        applyMetaClass("htmlbooknote","METABOOK.booknotes");
        addClass(fdjtDOM.$("span[data-type='footnote']"),"htmlbooknote");
        var allnotes=getChildren(content,".htmlbooknote");
        i=0; lim=allnotes.length; while (i<lim) {
            var notable=allnotes[i++]; var counter=note_counter++;
            var noteid="METABOOKNOTE"+counter;
            var refid="METABOOKNOTE"+counter+"_ref";
            var label_text=notable.getAttribute("data-label")||(""+counter);
            var label_node=
                getChild(notable,"label")||
                getChild(notable,"summary")||
                getChild(notable,".html5label")||
                getChild(notable,".html5summary");
            var anchor=fdjtDOM.Anchor(
                "#"+noteid,"A.mbnoteref.htmlnoteref",
                ((label_node)?(label_node.cloneNode(true)):
                 (label_text)));
            var backlink=fdjtDOM.Anchor(
                "#"+refid,"A.htmlackref",
                ((label_node)?(label_node.cloneNode(true)):
                 (label_text)));
            anchor.id=refid;
            fdjtDOM.replace(notable,anchor);
            dropClass(notable,"booknote");
            var noteblock=
                ((notable.tagName==='SPAN')?
                 fdjtDOM("div.booknotebody",
                         backlink,toArray(notable.childNodes)):
                 fdjtDOM("div.booknotebody",backlink,notable));
            noteblock.id=noteid;
            fdjtDOM.append(notesblock,noteblock,"\n");}
        
        if (!(init_content)) {
            var children=[], childnodes=body.childNodes;
            i=0; lim=childnodes.length;
            while (i<lim) children.push(childnodes[i++]);
            i=0; while (i<lim) {
                // Copy all of the content nodes
                var child=children[i++];
                if (child.nodeType!==1) content.appendChild(child);
                else if ((child.id)&&(child.id.search("METABOOK")===0)) {}
                else if (/(META|LINK|SCRIPT)/gi.test(child.tagName)) {}
                else content.appendChild(child);}}

        var wikiref_pat=/^http(s)?:\/\/([a-z]+.)?wikipedia.org\//;
        // Mark all external anchors and set their targets
        var anchors=content.getElementsByTagName("A");
        var ai=0, alimit=anchors.length; while (ai<alimit) {
            // Use a.getAttribute to not automatically get the
            // base URL added
            var a=anchors[ai++], href=a.getAttribute("href");
            if ((href)&&(href[0]!=="#")&&
                (href.search(/^[a-zA-Z][a-zA-Z][a-zA-Z]+:/)===0)) {
                var aclass=a.className, extclass="extref";
                if (href.search(wikiref_pat)===0) {
                    var text=fdjt.DOM.textify(a);
                    if (!(isEmpty(text))) {
                        if (!(a.title)) a.title="From Wikipedia";
                        else if (a.title.search(/wikipedia/i)>=0) {}
                        else a.title="Wikipedia: "+a.title;
                        extclass=extclass+" wikiref";}}
                if (aclass) a.className=aclass+" "+extclass;
                else a.className=extclass;
                a.target="_blank";}}
        
        // Interpet links
        var notelinks=getChildren(
            content,"a[rel='sbooknote'],a[rel='footnote'],a[rel='endnote']");
        i=0; lim=notelinks.length; while (i<lim) {
            var ref=notelinks[i++];
            var nref=ref.href;
            if (!(fdjtDOM.hasText(nref))) nref.innerHTML="Note";
            if ((nref)&&(nref[0]==="#")) {
                addClass($ID(nref.slice(1)),"sbooknote");}}
        
        // Append the notes block to the content
        if (notesblock.childNodes.length)
            fdjtDOM.append(content,"\n",notesblock,"\n");
        
        // Initialize cover and titlepage (if specified)
        metaBook.coverpage=metaBook.getCoverPage();
        metaBook.titlepage=$ID("SBOOKTITLEPAGE");

        var pages=metaBook.pages=$ID("METABOOKPAGES")||
            fdjtDOM("div#METABOOKPAGES");
        var page=metaBook.page=fdjtDOM("div#CODEXPAGE.metabookcontent",pages);
        
        metaBook.body=$ID("METABOOKBODY");
        if (!(metaBook.body)) {
            var cxbody=metaBook.body=
                fdjtDOM("div#METABOOKBODY.metabookbody",content,page);
            if (metaBook.textjustify) addClass(cxbody,"metabookjustify");
            if (metaBook.bodycontrast)
                addClass(cxbody,"metabookcontrast"+metaBook.bodycontrast);
            if (metaBook.bodysize)
                addClass(cxbody,"metabookbodysize"+metaBook.bodysize);
            if (metaBook.bodyfamily)
                addClass(cxbody,"metabookbodyfamily"+metaBook.bodyfamily);
            if (metaBook.bodyspacing)
                addClass(cxbody,"metabookbodyspacing"+metaBook.bodyspacing);
            body.appendChild(cxbody);}
        else metaBook.body.appendChild(page);
        // Initialize the margins
        initMargins();
        if (Trace.startup>1)
            fdjtLog("initBody took %dms",fdjtTime()-started);
        metaBook.Timeline.initBody=fdjtTime();}
    metaBook.initBody=initBody;

    function sizeContent(){
        var started=metaBook.sized=fdjtTime();
        var content=metaBook.content, page=metaBook.page, body=document.body;
        var view_height=fdjtDOM.viewHeight();
        var view_width=fdjtDOM.viewWidth();

        // Clear any explicit left/right settings to get at
        //  whatever the CSS actually specifies
        content.style.left=page.style.left='';
        content.style.right=page.style.right='';
        body.style.overflow='hidden';
        // Get geometry
        metaBook.sizeCodexPage();
        var geom=getGeometry(page,page.offsetParent,true);
        var fakepage=fdjtDOM("DIV.codexpage.curpage");
        page.appendChild(fakepage);
        // There might be a better way to get the .codexpage settings,
        //  but this seems to work.
        var fakepage_geom=getGeometry(fakepage,page,true);
        var inner_width=geom.inner_width;
        var inner_height=geom.inner_height;
        // The (-3) is for the three pixel wide border on the right side of
        //  the glossmark
        var page_margin=view_width-inner_width;
        var glossmark_offset=Math.floor(page_margin/2)+fakepage_geom.right_border;
        fdjtDOM.remove(fakepage);
        if (metaBook.CSS.pagerule) {
            metaBook.CSS.pagerule.style.width=inner_width+"px";
            metaBook.CSS.pagerule.style.height=inner_height+"px";}
        else metaBook.CSS.pagerule=fdjtDOM.addCSSRule(
            "div.codexpage",
            "width: "+inner_width+"px; "+"height: "+inner_height+"px;");
        if (metaBook.CSS.glossmark_rule) {
            metaBook.CSS.glossmark_rule.style.marginRight=
                (-glossmark_offset)+"px";}
        else metaBook.CSS.glossmark_rule=fdjtDOM.addCSSRule(
            "#CODEXPAGE .glossmark","margin-right: "+
                (-glossmark_offset)+"px;");
        
        var shrinkrule=metaBook.CSS.shrinkrule;
        if (!(shrinkrule)) {
            shrinkrule=fdjtDOM.addCSSRule(
                "body.mbSHRINK #CODEXPAGE,body.mbPREVIEW #CODEXPAGE, body.mbSKIMMING #CODEXPAGE", "");
            metaBook.CSS.shrinkrule=shrinkrule;}
        var sh=view_height-150;
        var vs=(sh/geom.height);
        if (vs>1) vs=1;
        shrinkrule.style[fdjtDOM.transform]="scale("+vs+","+vs+")";

        document.body.style.overflow='';
        if (Trace.startup>1)
            fdjtLog("Content sizing took %dms",fdjtTime()-started);}
    metaBook.sizeContent=sizeContent;
    
    /* Margin creation */

    function initMargins(){
        var topleading=fdjtDOM("div#SBOOKTOPLEADING.leading.top"," ");
        var bottomleading=
            fdjtDOM("div#SBOOKBOTTOMLEADING.leading.bottom"," ");
        topleading.metabookui=true; bottomleading.metabookui=true;
        
        var controls=fdjtDOM("div#METABOOKPAGECONTROLS");
        var holder=fdjtDOM("div");
        holder.innerHTML=fixStaticRefs(metaBook.HTML.pageleft);
        var nodes=toArray(holder.childNodes);
        var i=0, lim=nodes.length;
        while (i<lim) controls.appendChild(nodes[i++]);
        holder.innerHTML=fixStaticRefs(metaBook.HTML.pageright);
        nodes=toArray(holder.childNodes); i=0; lim=nodes.length;
        while (i<lim) controls.appendChild(nodes[i++]);

        fdjtDOM.prepend(document.body,controls);

        window.scrollTo(0,0);
        
        // The better way to do this might be to change the stylesheet,
        //  but fdjtDOM doesn't currently handle that 
        var bgcolor=getBGColor(document.body)||"white";
        metaBook.backgroundColor=bgcolor;
        if (bgcolor==='transparent')
            bgcolor=fdjtDOM.getStyle(document.body).backgroundColor;
        if ((bgcolor)&&(bgcolor.search("rgba")>=0)) {
            if (bgcolor.search(/,\s*0\s*\)/)>0) bgcolor='white';
            else {
                bgcolor=bgcolor.replace("rgba","rgb");
                bgcolor=bgcolor.replace(/,\s*((\d+)|(\d+.\d+))\s*\)/,")");}}
        else if (bgcolor==="transparent") bgcolor="white";}
})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/tagindex.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

// tagindex.js
(function (){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log, $ID=fdjt.ID;
    var fdjtTime=fdjt.Time, fdjtString=fdjt.String, fdjtUI=fdjt.UI;
    var fdjtAsync=fdjt.Async;
    var dropClass=fdjtDOM.dropClass, addClass=fdjtDOM.addClass;
    var getLink=fdjtDOM.getLink, isEmpty=fdjtString.isEmpty;

    var mB=metaBook, Trace=mB.Trace;

    /* Indexing tags */
    
    function handlePublisherIndex(pubindex,whendone){
        if (!(pubindex))
            pubindex=metaBook._publisher_index||window._sbook_autoindex;
        if (!(pubindex)) {
            if (whendone) whendone();
            return;}
        if ((Trace.startup>1)||(Trace.indexing)) {
            if (pubindex._nkeys)
                fdjtLog("Processing provided index of %d keys and %d refs",
                        pubindex._nkeys,pubindex._nrefs);
            else fdjtLog("Processing provided index");}
        metaBook.useIndexData(pubindex,metaBook.knodule,false,whendone);}

    function indexingDone(){
        if ((Trace.indexing)||(Trace.startup))
            fdjtLog("Content indexing is completed");
        if (metaBook._setup) setupClouds();
        else metaBook.onsetup=setupClouds;}
    
    var cloud_setup_start=false;
    function setupClouds(){
        var tracelevel=Math.max(Trace.startup,Trace.clouds);
        var addTag2Cloud=metaBook.addTag2Cloud;
        var empty_cloud=metaBook.empty_cloud;
        var gloss_cloud=metaBook.gloss_cloud;
        var taglist=metaBook.taglist||$ID("METABOOKTAGLIST");
        if (!(taglist)) {
            taglist=metaBook.taglist=fdjt.DOM("datalist#METABOOKTAGLIST");
            document.body.appendChild(taglist);}
        var searchlist=metaBook.searchlist||$ID("METABOOKSEARCHLIST");
        if (!(searchlist)) {
            searchlist=metaBook.searchlist=fdjt.DOM("datalist#METABOOKSEARCHLIST");
            document.body.appendChild(searchlist);}
        var knodeToOption=Knodule.knodeToOption;

        cloud_setup_start=fdjtTime();
        metaBook.empty_query.results=
            [].concat(metaBook.glossdb.allrefs).concat(metaBook.docdb.allrefs);
        var searchtags=metaBook.searchtags=metaBook.empty_query.getCoTags();
        var empty_query=metaBook.empty_query;
        var tagfreqs=empty_query.tagfreqs;
        if (tracelevel)
            fdjtLog("Setting up initial tag clouds for %d tags",
                    searchtags.length);
        addClass(document.body,"mbINDEXING");
        fdjtDOM(empty_cloud.dom,
                fdjtDOM("div.cloudprogress","Cloud Shaping in Progress"));
        addClass(empty_cloud.dom,"working");
        fdjtDOM(gloss_cloud.dom,
                fdjtDOM("div.cloudprogress","Cloud Shaping in Progress"));
        addClass(gloss_cloud.dom,"working");
        fdjtAsync.slowmap(function(tag){
            if (!(tag instanceof KNode)) {
                if ((typeof tag === "string")&&(!(isEmpty(tag)))) {
                    var option=fdjtDOM("OPTION",tag); option.value=tag;
                    searchlist.appendChild(option);}
                return;}
            var elt=addTag2Cloud(tag,empty_cloud,metaBook.knodule,
                                 tagfreqs,tagfreqs,false);
            // Ignore section name tags
            if (tag._id[0]==="\u00a7") return;
            taglist.appendChild(knodeToOption(tag));
            searchlist.appendChild(knodeToOption(tag));
            if (!(tag.weak)) {
                addClass(elt,"cue");
                addTag2Cloud(tag,gloss_cloud);}},
                         searchtags,
                         {watchfn: tagindex_progress,
                          slice: 200,space: 20}).
            then(tagindex_done);}
    
    function tagindex_done(searchtags){
        var eq=metaBook.empty_query;
        var knodule=metaBook.knodule;
        var empty_cloud=metaBook.empty_cloud;
        var gloss_cloud=metaBook.gloss_cloud;
        var searchlist=$ID("METABOOKSEARCHLIST");
        var knodeToOption=Knodule.knodeToOption;        
        var tracelevel=Math.max(Trace.startup,Trace.clouds);
        
        /* Take the top dterms and make them into cues, so there's at
         * least *something* */
        metaBook.knodule.alldterms.slice(0,7).map(function(dterm){
            var ref=knodule.ref(dterm), elts=empty_cloud.getByValue(ref);
            elts.map(function(elt){addClass(elt,"cue");});});

        if (tracelevel)
            fdjtLog("Done populating clouds with %d tags",searchtags.length);
        dropClass(document.body,"mbINDEXING");
        eq.cloud=empty_cloud;
        if (!(fdjtDOM.getChild(empty_cloud.dom,".showall")))
            fdjtDOM.prepend(empty_cloud.dom,
                            metaBook.UI.getShowAll(
                                true,empty_cloud.values.length));
        fdjtAsync.slowmap(function(string){
            searchlist.appendChild(knodeToOption(string));},
                         metaBook.textindex.allterms,
                         {slice: 100,space: 20});
        metaBook.sortCloud(empty_cloud);
        metaBook.sortCloud(gloss_cloud);
        metaBook.sizeCloud(empty_cloud,metaBook.tagfreqs,[]);
        metaBook.sizeCloud(gloss_cloud,metaBook.tagfreqs,[]);}

    function tagindex_progress(state,i,lim){
        var tracelevel=Math.max(Trace.startup,Trace.clouds);
        var pct=((i*100)/lim);
        if (state!=='after') return;
        if (tracelevel>1)
            fdjtLog("Added %d (%d%% of %d tags) to clouds",
                    i,Math.floor(pct),lim);
        fdjtUI.ProgressBar.setProgress("METABOOKINDEXMESSAGE",pct);
        fdjtUI.ProgressBar.setMessage(
            "METABOOKINDEXMESSAGE",fdjtString(
                "Added %d tags (%d%% of %d) to clouds",
                i,Math.floor(pct),lim));}
    
    var addTags=metaBook.addTags;
    
    /* Using the autoindex generated during book building */
    function useIndexData(autoindex,knodule,baseweight,whendone){
        var ntags=0, nitems=0, handle_weak=false;
        var allterms=metaBook.allterms, prefixes=metaBook.prefixes;
        var tagweights=metaBook.tagweights;
        var maxweight=metaBook.tagmaxweight, minweight=metaBook.tagminweight;
        var tracelevel=Math.max(Trace.startup,Trace.indexing);
        var alltags=[];
        if (!(autoindex)) {
            if (whendone) whendone();
            return;}
        for (var tag in autoindex) {
            if (tag[0]==="_") continue;
            else if (!(autoindex.hasOwnProperty(tag))) continue;
            else alltags.push(tag);}
        // Number chosen to exclude exhaustive auto tags
        if (alltags.length<1000) handle_weak=true;
        function handleIndexEntry(tag){
            var ids=autoindex[tag]; ntags++;
            var occurrences=[];
            var bar=tag.indexOf('|'), tagstart=tag.search(/[^*~]/);
            var taghead=tag, tagterm=tag, knode=false, weight=false;
            if (bar>0) {
                taghead=tag.slice(0,bar);
                tagterm=tag.slice(tagstart,bar);}
            else tagterm=taghead=tag.slice(tagstart);
            if ((handle_weak)||(tag[0]!=='~'))
                knode=metaBook.knodule.handleSubjectEntry(tag);
            else knode=metaBook.knodule.probe(taghead)||
                metaBook.knodule.probe(tagterm);
            /* Track weights */
            if (knode) {
                weight=knode.weight;
                tagweights.set(knode,weight);}
            else if (bar>0) {
                var body=tag.slice(bar);
                var field_at=body.search("|:weight=");
                if (field_at>=0) {
                    var end=body.indexOf('|',field_at+1);
                    weight=((end>=0)?
                            (parseFloat(body.slice(field_at+9,end))):
                            (parseFloat(body.slice(field_at+9))));
                    tagweights.set(tagterm,weight);}}
            else {}
            if (weight>maxweight) maxweight=weight;
            if (weight<minweight) minweight=weight;
            if (!(knode)) {
                var prefix=((tagterm.length<3)?(tagterm):
                            (tagterm.slice(0,3)));
                allterms.push(tagterm);
                if (prefixes.hasOwnProperty(prefix))
                    prefixes[prefix].push(tagterm);
                else prefixes[prefix]=[tagterm];}
            var i=0; var lim=ids.length; nitems=nitems+lim;
            while (i<lim) {
                var idinfo=ids[i++];
                var frag=((typeof idinfo === 'string')?
                          (idinfo):
                          (idinfo[0]));
                var info=metaBook.docinfo[frag];
                // Pointer to non-existent node.  Warn here?
                if (!(info)) {
                    metaBook.missing_nodes.push(frag);
                    continue;}
                if (typeof idinfo !== 'string') {
                    // When the idinfo is an array, the first
                    // element is the id itself and the remaining
                    // elements are the text strings which are the
                    // basis for the tag (we use this for
                    // highlighting).
                    var knodeterms=info.knodeterms, terms;
                    var tagid=((knode)?(knode._qid||knode.getQID()):(tagterm));
                    // If it's the regular case, we just assume that
                    if (!(info.knodeterms)) {
                        knodeterms=info.knodeterms={};
                        knodeterms[tagid]=terms=[];}
                    else if ((terms=knodeterms[tagid])) {}
                    else knodeterms[tagid]=terms=[];
                    var j=1; var jlim=idinfo.length;
                    while (j<jlim) {terms.push(idinfo[j++]);}}
                occurrences.push(info);}
            addTags(occurrences,knode||taghead);}
        addClass(document.body,"mbINDEXING");
        fdjtAsync.slowmap(
            handleIndexEntry,alltags,
            {watchfn: ((alltags.length>100)&&(tracelevel>1)&&(indexProgress)),
             done:
             function(state){
                fdjtLog("Book index links %d keys to %d refs",ntags,nitems);
                dropClass(document.body,"mbINDEXING");
                metaBook.tagmaxweight=maxweight;
                metaBook.tagminweight=minweight;
                if (whendone) return whendone();
                else return state;},
             slice: 200,space: 10});}
    metaBook.useIndexData=useIndexData;
    function indexProgress(state,i,lim){
        if (state!=='suspend') return;
        // For chunks:
        var pct=(i*100)/lim;
        fdjtLog("Processed %d/%d (%d%%) of provided tags",
                i,lim,Math.floor(pct));}
    
    /* Applying various tagging schemes */

    function applyMultiTagSpans() {
        var tags=fdjtDOM.$(".sbooktags");
        var i=0, lim=tags.length;
        while (i<lim) {
            var elt=tags[i++];
            var target=metaBook.getTarget(elt);
            var info=metaBook.docinfo[target.id];
            var tagtext=fdjtDOM.textify(elt);
            var tagsep=elt.getAttribute("tagsep")||";";
            var tagstrings=tagtext.split(tagsep);
            if (tagstrings.length) {
                var j=0, jlim=tagstrings.length;
                while (j<jlim) addTags(info,tagstrings[j++]);}}}
    function applyTagSpans() {
        var tags=fdjtDOM.$(".sbooktag");
        var i=0; var lim=tags.length;
        while (i<lim) {
            var tagelt=tags[i++];
            var target=metaBook.getTarget(tagelt);
            var info=metaBook.docinfo[target.id];
            var tagtext=fdjtDOM.textify(tagelt);
            addTags(info,tagtext);}}
    
    function applyAnchorTags() {
        var docinfo=metaBook.docinfo;
        var anchors=document.getElementsByTagName("A");
        if (!(anchors)) return;
        var i=0; var len=anchors.length;
        while (i<len) {
            if (anchors[i].rel==='tag') {
                var elt=anchors[i++];
                var cxt=elt;
                while (cxt) if (cxt.id) break; else cxt=cxt.parentNode;
                // Nowhere to store it?
                if (!(cxt)) return;
                var href=elt.href; var name=elt.name; var tag=false;
                if (name) { // DTerm style
                    var def=elt.getAttribute('data-def')||
                        elt.getAttribute('data-def');
                    var title=elt.title;
                    if (def) {
                        if (def[0]==='|') tag=tag+def;
                        else tag=tag+"|"+def;}
                    else if (title) {
                        if (title[0]==='|') tag=name+title;
                        else if (title.indexOf('|')>0) {
                            tag=name+"|"+title;}
                        else tag=name+"|~"+title;}
                    else tag=name;}
                else if (href) {
                    // Technorati style
                    var tagstart=(href.search(/[^\/]+$/));
                    tag=((tagstart<0)?(href):(href.slice(tagstart)));}
                else {}
                if (tag) {
                    var info=docinfo[cxt.id];
                    addTags(info,tag);}}
            else i++;}}
    
    /* Handling tag attributes */
    /* These are collected during the domscan; this is where the logic
       is implemented which applies header tags to section elements. */
    
    function applyTagAttributes(docinfo,whendone){
        var tracelevel=Math.max(Trace.startup,Trace.clouds);
        var tohandle=[]; var tagged=0;
        function index_progress(state,i,lim){
            // For chunks:
            if (!((state==='suspend')||(state==='finishing')))
                return;
            var pct=(i*100)/lim;
            if (tracelevel>1)
                fdjtLog("Processed %d/%d (%d%%) inline tags",
                        i,lim,Math.floor(pct));
            fdjtUI.ProgressBar.setProgress(
                "METABOOKINDEXMESSAGE",pct);
            fdjtUI.ProgressBar.setMessage(
                "METABOOKINDEXMESSAGE",
                fdjtString("Assimilated %d (%d%% of %d) inline tags",
                           i,Math.floor(pct),lim));}
        function index_done(){
            if (((Trace.indexing>1)&&(tohandle.length))||
                (tohandle.length>24))
                fdjtLog("Finished indexing tag attributes for %d nodes",
                        tohandle.length);
            if (whendone) whendone();}
        if ((Trace.startup>1)||(Trace.indexing>1))
            fdjtLog("Applying inline tag attributes from content");
        for (var eltid in docinfo) {
            var info=docinfo[eltid];
            if (info.atags) {tagged++; tohandle.push(info);}}
        if (((Trace.indexing)&&(tohandle.length))||
            (Trace.indexing>1)||(Trace.startup>1))
            fdjtLog("Indexing tag attributes for %d nodes",tohandle.length);
        fdjtAsync.slowmap(
            handle_inline_tags,
            tohandle,
            {watchfn: ((tohandle.length>100)&&(index_progress)),
             done: index_done,slice: 200, space: 5});}
    metaBook.applyTagAttributes=applyTagAttributes;
    
    function handle_inline_tags(info){
        if (info.atags) addTags(info,info.atags);
        if (info.sectag) {
            addTags(info,info.sectag,"tags",metaBook.knodule);
            var knode=metaBook.knodule.ref(info.sectag);
            metaBook.tagweights.set(
                knode,metaBook.docdb.find('head',info).length);}}

    function setupIndex(metadata){
        if ((Trace.startup>1)||(Trace.indexing>1))
            fdjtLog("Finding and applying Technorati-style tags");
        applyAnchorTags();
        if ((Trace.startup>1)||(Trace.indexing>1))
            fdjtLog("Finding and applying tag elements from body");
        applyTagSpans();
        applyMultiTagSpans();
        applyTagAttributes(metadata);
        var pubindex=metaBook._publisher_index||
            window._sbook_autoindex;
        if (pubindex) {
            handlePublisherIndex(pubindex,indexingDone);
            metaBook._publisher_index=false;
            window._sbook_autoindex=false;}
        else if ($ID("SBOOKAUTOINDEX")) {
            var elt=$ID("SBOOKAUTOINDEX");
            fdjtDOM.addListener(elt,"load",function(evt){
                evt=evt||window.event;
                handlePublisherIndex(false,indexingDone);
                metaBook._publisher_index=false;
                window._sbook_autoindex=false;});}
        else {
            var indexref=getLink("SBOOKS.bookindex");
            if (indexref) {
                var script_elt=document.createElement("SCRIPT");
                script_elt.setAttribute("src",indexref);
                script_elt.setAttribute("language","javascript");
                script_elt.setAttribute("async","async");
                fdjtDOM.addListener(script_elt,"load",function(){
                    handlePublisherIndex(false,indexingDone);
                    metaBook._publisher_index=false;
                    window._sbook_autoindex=false;});
                document.body.appendChild(script_elt);}
            else indexingDone();}}
    metaBook.setupIndex=setupIndex;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/syncstate.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtState=fdjt.State;
    var fdjtLog=fdjt.Log, fdjtUI=fdjt.UI, fdjtTime=fdjt.Time;
    var $ID=fdjt.ID;
    var mB=metaBook, mbID=mB.ID;
    var saveLocal=mB.saveLocal, readLocal=mB.readLocal;
    var clearLocal=mB.clearLocal;
    var Trace=metaBook.Trace;
    var loc2pct=metaBook.location2pct;
    var sync_count=0;

    var setTarget, setConnected, setConfig;
    function init_local(){
        setTarget=metaBook.setTarget;
        setConnected=metaBook.setConnected;
        setConfig=metaBook.setConfig;}
    metaBook.inits.push(init_local);

    /* Managing the reader state */

    /* Three aspects of the reading state are saved:

     * the numeric location within the book (in characters from the
     beginning)
     * the most recent target ID
     * the current page (just for messages, since page numbers aren't
     stable
    */

    // We keep track of the current state and the last time that state
    // was changed by a user action.  Restoring a saved state, for
    // example, doesn't bump the change date.

    var syncing=false;
    
    // This initializes the reading state, either from local storage
    //  or the initial hash id from the URL (which was saved in
    //  metaBook.inithash).
    metaBook.initState=function initState() {
        var state=readLocal("mB("+mB.docid+").state",true);
        var hash=metaBook.inithash;
        if (hash) {
            if (hash[0]==="#") hash=hash.slice(1);}
        else hash=false;
        var elt=((hash)&&(mbID(hash)));
        if (elt) {
            // If the hash has changed, we take that as a user action
            //  and update the state.  If it hasn't changed, we assume
            //  that the stored state is still current and dated whenever
            //  it was last changed.
            if ((!(state))||
                ((state.hash)&&(state.hash!==hash))||
                ((!(state.hash))&&(state.target)&&(state.target!==hash))) {
                if (!(state)) state={};
                // Hash changed
                state.refuri=metaBook.refuri;
                state.docuri=metaBook.docuri;
                state.target=hash;
                state.location=false;
                state.changed=fdjtTime.tick();
                saveLocal("mB("+mB.docid+").state",state,true);}}
        if (state) metaBook.state=state;};
    
    // This records the current state of the app, bundled into an
    //  object. It primarily consists a location, a target, and
    //  the time it was last changed.
    // Mechanically, this procedure fills things out and stores the object
    //  in both metaBook.state and local/session storage.  If the changed
    //  date is later than the current metaBook.xstate, it also does
    //  an Ajax call to update the server.
    // Finally, unless skiphist is true, it updates the browser
    //  history to get the browser button to be useful.
    function saveState(state,skiphist,force){
        if ((!force)&&(state)&&
            ((metaBook.state===state)||
             ((metaBook.state)&&
              (metaBook.state.target===state.target)&&
              (metaBook.state.location===state.location)&&
              (metaBook.state.page===state.page))))
            return;
        if (!(state)) state=metaBook.state;
        if (!(state.changed)) state.changed=fdjtTime.tick();
        if (!(state.refuri)) state.refuri=metaBook.refuri;
        if (!(state.docuri)) state.docuri=metaBook.docuri;
        var title=state.title, frag=state.target;
        if ((!(title))&&(frag)&&(metaBook.docinfo[frag])) {
            state.title=title=metaBook.docinfo[frag].title||
                metaBook.docinfo[frag].head.title;}
        if (Trace.state) fdjtLog("Setting state to %j",state);
        if ((state.maxloc)&&(state.maxloc<state.location))
            state.maxloc=state.location;
        else if (!(state.maxloc)) state.maxloc=state.location;
        if ((window)&&(window.location)&&(window.location.hash)) {
            var hash=window.location.hash;
            if (hash[0]==='#') hash=hash.slice(1);
            state.hash=hash;}
        if (Trace.state)
            fdjtLog("saveState skiphist=%o force=%o state=%j",
                    skiphist,force,state);
        metaBook.state=state;
        var statestring=JSON.stringify(state);
        saveLocal("mB("+mB.docid+").state",statestring);
        if ((!(syncing))&&(metaBook.locsync)&&(metaBook.user)&&
            ((!(metaBook.xstate))||(state.changed>metaBook.xstate.changed)))
            syncState(true);
        if ((!(skiphist))&&(frag)&&
            (window.history)&&(window.history.pushState))
            setHistory(state,frag,title);
    } metaBook.saveState=saveState;

    // This sets the browser history from a particular state
    function setHistory(state,hash,title){
        if (Trace.state) {
            if (title)
                fdjtLog("setHistory %s (%s) state=%j",hash,title,state);
            else fdjtLog("setHistory %s state=%j",hash,state);}
        if (!((window.history)&&(window.history.pushState))) return;
        if (!(hash)) hash=state.target;
        if (!(title)) title=state.title;
        var href=fdjtState.getURL();
        if ((!(title))&&(hash)&&(metaBook.docinfo[hash])) {
            state.title=title=metaBook.docinfo[hash].title||
                metaBook.docinfo[hash].head.title;}
        if ((!(hash))&&(state.location)&&
            (typeof state.location === "number"))
            hash="SBOOKLOC"+state.location;
        if (Trace.state)
            fdjtLog("Pushing history %j %s (%s) '%s'",
                    state,href,title);
        if ((!(window.history.state))||
            (window.history.state.target!==state.target)||
            (window.history.state.location!==state.location)) {
            window.history.pushState(state,title,href+"#"+hash);}
    }
    metaBook.setHistory=setHistory;

    function restoreState(state,reason,savehist){
        if (Trace.state) fdjtLog("Restoring (%s) state %j",reason,state);
        if (state.location)
            metaBook.GoTo(state.location,reason||"restoreState",
                          ((state.target)&&(mbID(state.target))),
                          false,(!(savehist)));
        else if ((state.page)&&(metaBook.layout)) {
            metaBook.GoToPage(state.page,reason||"restoreState",
                              false,(!(savehist)));
            if ((state.target)&&(mbID(state.target)))
                setTarget(mbID(state.target));}
        else if (state.target) {
            metaBook.GoTo(state.target,reason||"restoreState",
                          true,false,(!(savehist)));
            if ((state.target)&&(mbID(state.target)))
                setTarget(mbID(state.target));}
        if (!(state.refuri)) state.refuri=metaBook.refuri;
        if (!(state.docuri)) state.docuri=metaBook.docuri;
        saveState(state);
    } metaBook.restoreState=restoreState;

    function clearState(){
        metaBook.state=false;
        clearLocal("mB("+mB.docid+").state");
        metaBook.xstate=false;
    } metaBook.clearState=clearState;

    function resetState(){
        var state=metaBook.state;
        if (state.location) state.maxloc=location;
        state.reset=true;
        var statestring=JSON.stringify(state);
        saveLocal("mB("+mB.docid+").state",statestring);
        syncState(true);}
    metaBook.resetState=resetState;

    var sync_req=false, sync_wait=false, last_sync=false;
    // Post the current state and update synced state from what's
    // returned
    function syncState(force){
        var elapsed=(last_sync)?(fdjtTime.tick()-last_sync):(3600*24*365*10);
        if ((syncing)||((!(force))&&(!(metaBook.locsync)))) return;
        if (!(metaBook.user)) return;
        if (sync_req) {
            fdjtLog("Skipping state sync because one is already in process");
            if (sync_wait) clearTimeout(sync_wait);
            setTimeout(function(){syncState(force);},15000);
            return;}
        if ((!(force))&&(elapsed<metaBook.sync_interval)) {
            if (Trace.state)
                fdjtLog("Skipping state sync because it's too soon");
            return;}
        if ((!(force))&&(metaBook.state)&&
            ((!(fdjtDOM.isHidden))||(document[fdjtDOM.isHidden]))&&
            (elapsed<(5*metaBook.sync_interval))) {
            if (Trace.state)
                fdjtLog("Skipping state sync because page is hidden");
            return;}
        if ((!(force))&&(elapsed<(metaBook.sync_min))) {
            sync_wait=setTimeout(
                function(){syncState(force);},
                1000*metaBook.sync_min);
            return;}
        else if (sync_wait) {clearTimeout(sync_wait); sync_wait=false;} 
        if ((metaBook.locsync)&&(navigator.onLine)) {
            var uri=metaBook.docuri;
            var traced=(Trace.state)||(Trace.network);
            var state=metaBook.state;
            var refuri=
                ((metaBook.target)&&(metaBook.getRefURI(metaBook.target)))||
                (metaBook.refuri);
            var sync_uri="https://sync.bookhub.io/v1/sync"+
                "?REFURI="+encodeURIComponent(refuri)+
                "&DOCURI="+encodeURIComponent(metaBook.docuri)+
                "&NOW="+fdjtTime.tick();
            metaBook.last_sync=last_sync=fdjtTime.tick(); syncing=state;
            if (metaBook.user) sync_uri=sync_uri+
                "&SYNCUSER="+encodeURIComponent(metaBook.user._id);
            if (metaBook.mycopyid) sync_uri=sync_uri+
                "&MYCOPYID="+encodeURIComponent(metaBook.mycopyid);
            if (metaBook.deviceName) sync_uri=sync_uri+
                "&DEVICE="+encodeURIComponent(metaBook.deviceName);
            if (metaBook.ends_at) sync_uri=sync_uri+
                "&LOCLEN="+encodeURIComponent(metaBook.ends_at);
            if (state) {
                if (state.target) sync_uri=sync_uri+
                    "&TARGET="+encodeURIComponent(state.target);
                if ((state.location)||(state.hasOwnProperty('location')))
                    sync_uri=sync_uri+
                    "&LOCATION="+encodeURIComponent(state.location);
                if (state.changed) sync_uri=sync_uri+
                    "&CHANGED="+encodeURIComponent(state.changed);
                if (state.reset) sync_uri=sync_uri+"&RESET=true";}
            var req=new XMLHttpRequest();
            syncing=state;
            req.onreadystatechange=freshState;
            req.ontimeout=syncTimeout;
            req.withCredentials=true;
            req.timeout=metaBook.sync_timeout;
            if (traced) fdjtLog("syncState(call) %s",sync_uri);
            try {
                req.open("GET",sync_uri,true);
                req.send();
                sync_req=req;}
            catch (ex) {
                try {
                    fdjtLog.warn(
                        "Sync request %s returned status %d %j, pausing for %ds",
                        uri,req.status,JSON.parse(req.responseText),
                        metaBook.sync_pause);}
                catch (err) {
                    fdjtLog.warn(
                        "Sync request %s returned status %d, pausing for %ds",
                        uri,req.status,metaBook.sync_pause/1000);}
                metaBook.locsync=false;
                setTimeout(function(){metaBook.locsync=true;},
                           1000*metaBook.sync_pause);}}
    } metaBook.syncState=syncState;

    function syncTimeout(evt){
        evt=evt||window.event;
        fdjtLog.warn("Sync request timed out, pausing for %ds",
                     metaBook.sync_pause/1000);
        metaBook.locsync=false;
        setTimeout(function(){
            metaBook.locsync=true;},
                   1000*metaBook.sync_pause);}

    var prompted=false;

    function freshState(evt){
        var req=fdjtUI.T(evt); sync_req=false;
        var traced=(Trace.state)||(Trace.network)||
            ((Trace.startup)&&(sync_count<1));
        if (req.readyState===4) {
            if ((req.status>=200)&&(req.status<300)) {
                var rtext=req.responseText;
                if (!(rtext)) return;
                var xstate=JSON.parse(rtext);
                var tick=fdjtTime.tick();
                if (xstate.changed) {
                    if (traced)
                        fdjtLog("freshState %o %j\n\t%j",
                                evt,xstate,metaBook.state);
                    if (xstate.changed>(tick+300))
                        fdjtLog.warn(
                            "Beware of oracles (future state date): %j %s",
                            xstate,new Date(xstate.changed*1000));
                    else if (!(metaBook.state)) {
                        metaBook.xstate=xstate;
                        restoreState(xstate);}
                    else if (metaBook.state.changed>xstate.changed)
                        // Our state is later, so we make it the xstate
                        metaBook.xstate=xstate;
                    else if ((prompted)&&(prompted>xstate.changed)) {
                        // We've already bothered the user since this
                        //  change was recorded, so we don't bother them
                        // again
                    }
                    else if (document[fdjtDOM.isHidden])
                        metaBook.freshstate=xstate;
                    else {
                        metaBook.xstate=xstate;
                        prompted=fdjtTime.tick();
                        metaBook.resolveXState(xstate);}}
                sync_count++;}
            else if (traced)
                fdjtLog("syncState(callback/error) %o %d %s",
                        evt,req.status,req.responseText);
            if (navigator.onLine) setConnected(true);
            syncing=false;}}

    var last_hidden=false;
    metaBook.visibilityChange=function visibilityChange(){
        if (!(document[fdjtDOM.isHidden])) {
            if ((last_hidden)&&((fdjtTime.tick()-last_hidden)<300)) {}
            else if (navigator.onLine) {
                last_hidden=false;
                syncState(true);}
            else if (metaBook.freshstate) {
                // Something changed while we were hidden
                var freshstate=metaBook.freshstate;
                last_hidden=false;
                metaBook.freshstate=false;
                metaBook.xstate=freshstate;
                prompted=fdjtTime.tick();
                metaBook.resolveXState(freshstate);}
            else {}}
        else last_hidden=fdjtTime.tick();};

    function forceSync(){
        if (metaBook.connected) metaBook.update();
        else if (metaBook._onconnect)
            metaBook._onconnect.push(function(){metaBook.update();});
        else metaBook._onconnect=[function(){metaBook.update();}];
        if (!(metaBook.syncstart)) metaBook.syncLocation();
        else syncState();
    } metaBook.forceSync=forceSync;

    function getLoc(x){
        var info=metaBook.getLocInfo(x);
        return ((info)&&(info.start));}

    /* This initializes the sbook state to the initial location with the
       document, using the hash value if there is one. */ 
    function initLocation() {
        var state=metaBook.state;
        if (state) {}
        else {
            var target=$ID("METABOOKSTART")||fdjt.$1(".metabookstart")||
                $ID("SBOOKSTART")||fdjt.$1(".sbookstart")||
                $ID("SBOOKTITLEPAGE");
            if (target)
                state={location: getLoc(target),
                       // This is the beginning of the 21st century
                       changed: 978307200};
            else state={location: 1,changed: 978307200};}
        metaBook.saveState(state,true,true);}
    metaBook.initLocation=initLocation;

    function resolveXState(xstate) {
        var state=metaBook.state;
        if (!(metaBook.sync_interval)) return;
        if (metaBook.statedialog) {
            if (Trace.state)
                fdjtLog("resolveXState dialog exists: %o",
                        metaBook.statedialog);
            return;}
        if (Trace.state)
            fdjtLog("resolveXState state=%j, xstate=%j",state,xstate);
        if (!(state)) {
            metaBook.restoreState(xstate);
            return;}
        else if (xstate.maxloc>state.maxloc) {
            state.maxloc=xstate.maxloc;
            var statestring=JSON.stringify(state);
            saveLocal("mB("+mB.docid+").state",statestring);}
        else {}
        if (state.changed>=xstate.changed) {
            // The locally saved state is newer than the server,
            //  so we ignore the xstate (it might get synced
            //  separately)
            return;}
        var now=fdjtTime.tick();
        if ((now-state.changed)<(30)) {
            // If our state changed in the past 30 seconds, don't
            // bother changing the current state.
            return;}
        if (Trace.state) 
            fdjtLog("Resolving local state %j with remote state %j",
                    state,xstate);
        var msg1="Start at";
        var choices=[];
        var latest=xstate.location, farthest=xstate.maxloc;
        if (farthest>state.location)
            choices.push(
                {label: "farthest @"+loc2pct(farthest),
                 title: "your farthest location on any device/app",
                 isdefault: false,
                 handler: function(){
                     metaBook.GoTo(xstate.maxloc,"sync");
                     state=metaBook.state; state.changed=fdjtTime.tick();
                     metaBook.saveState(state,true,true);
                     metaBook.hideCover();}});
        if ((latest!==state.location)&&(latest!==farthest))
            choices.push(
                {label: ("latest @"+loc2pct(latest)),
                 title: "the most recent location on any device/app",
                 isdefault: false,
                 handler: function(){
                     metaBook.restoreState(xstate); state=metaBook.state;
                     state.changed=fdjtTime.tick();
                     metaBook.saveState(state,true,true);
                     metaBook.hideCover();}});
        if ((choices.length)&&(state.location>17))
            choices.push(
                {label: ("current @"+((state.location<42)?("start"):
                                      (loc2pct(state.location)))),
                 title: "the most recent location on this device",
                 isdefault: true,
                 handler: function(){
                     state.changed=fdjtTime.tick();
                     metaBook.saveState(state,true,true);
                     metaBook.hideCover();}});
        if (choices.length)
            choices.push(
                {label: "stop syncing",
                 title: "stop syncing this book on this device",
                 handler: function(){
                     setConfig("locsync",false,true);}});
        if (Trace.state)
            fdjtLog("resolveXState choices=%j",choices);
        if (choices.length)
            metaBook.statedialog=fdjtUI.choose(
                {choices: choices,cancel: true,timeout: 7,
                 nodefault: true,noauto: true,
                 onclose: function(){metaBook.statedialog=false;},
                 spec: "div.fdjtdialog.resolvestate#METABOOKRESOLVESTATE"},
                fdjtDOM("div",msg1));}
    metaBook.resolveXState=resolveXState;

    function clearStateDialog(){
        if (metaBook.statedialog) {
            fdjt.Dialog.close(metaBook.statedialog);
            metaBook.statedialog=false;}}
    metaBook.clearStateDialog=clearStateDialog;
})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/user.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

// user.js
(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log;
    var fdjtTime=fdjt.Time, $ID=fdjt.ID;
    var RefDB=fdjt.RefDB, Ref=fdjt.Ref, fdjtState=fdjt.State;
    
    var mB=metaBook, Trace=mB.Trace;

    var getLocal=fdjtState.getLocal;
    var setLocal=fdjtState.setLocal;
    var saveLocal=mB.saveLocal;

    function sourceref(arg){
        if (arg instanceof Ref) return arg;
        else if (typeof arg === "string")
            return mB.sourcedb.ref(arg);
        else return false;}

    function setUser(userinfo,outlets,layers,sync){
        var started=fdjtTime();
        var root=document.documentElement||document.body;
        fdjtLog("Setting up user %s (%s)",userinfo._id,
                userinfo.name||userinfo.email);
        if (userinfo) {
            fdjtDOM.dropClass(root,"_NOUSER");
            fdjtDOM.addClass(root,"_USER");}
        if (metaBook.user) {
            if (userinfo._id===metaBook.user._id) {}
            else throw { error: "Can't change user"};}
        var cursync=metaBook.sync;
        if ((cursync)&&(cursync>sync)) {
            fdjtLog.warn(
                "Cached user information is newer (%o) than loaded (%o)",
                cursync,sync);}
        if ((navigator.onLine)&&
            (getLocal("mB("+mB.docid+").queued")))
            metaBook.writeQueuedGlosses();
        metaBook.user=metaBook.sourcedb.Import(
            userinfo,false,RefDB.REFLOAD|RefDB.REFSTRINGS|RefDB.REFINDEX);
        if (outlets) metaBook.outlets=outlets.map(sourceref);
        if (layers) metaBook.layers=layers.map(sourceref);
        // No callback needed
        metaBook.user.save();
        saveLocal("mB.user",metaBook.user._id);
        // We also save it locally so we can get it synchronously
        saveLocal(metaBook.user._id,metaBook.user.Export(),true);
        if (metaBook.locsync) metaBook.setConfig("locsync",true);
        metaBook.saveProps();
        
        if (Trace.startup) {
            var now=fdjtTime();
            fdjtLog("setUser %s (%s) done in %dms",
                    userinfo._id,userinfo.name||userinfo.email,
                    now-started);}
        metaBook._user_setup=fdjtTime();
        // This sets up for local storage, now that we have a user 
        if (metaBook.cacheglosses) metaBook.setCacheGlosses(true);
        if (metaBook._ui_setup) setupUI4User();
        return metaBook.user;}
    metaBook.setUser=setUser;
    
    function setNodeID(nodeid){
        if (!(metaBook.nodeid)) {
            metaBook.nodeid=nodeid;
            if ((nodeid)&&(metaBook.persist))
                setLocal("mB("+mB.docid+").nodeid",nodeid,true);}}
    metaBook.setNodeID=setNodeID;

    function setupUI4User(){
        if (metaBook._user_ui_setup) return;
        var i=0, lim;
        var root=document.documentElement||document.body;
        if (Trace.startup>1) fdjtLog("Starting UI setup for user");
        var startui=fdjtTime();
        if (!(metaBook.user)) {
            fdjtDOM.addClass(root,"_NOUSER");
            return;}
        fdjtDOM.addClass(root,"_NOUSER");
        fdjtDOM.dropClass(root,"_NOUSER");
        var username=metaBook.user.name||metaBook.user.handle||metaBook.user.email;
        if (username) {
            if ($ID("METABOOKUSERNAME"))
                $ID("METABOOKUSERNAME").innerHTML=username;
            if ($ID("CODEXUSERNAME"))
                $ID("CODEXUSERNAME").innerHTML=username;
            var names=document.getElementsByName("METABOOKUSERNAME");
            if ((names)&&(names.length)) {
                i=0; lim=names.length; while (i<lim)
                    names[i++].innerHTML=username;}
            names=document.getElementsByName("CODEXUSERNAME");
            if ((names)&&(names.length)) {
                i=0; lim=names.length; while (i<lim)
                    names[i++].innerHTML=username;}
            names=fdjtDOM.$(".metabookusername");
            if ((names)&&(names.length)) {
                i=0; lim=names.length; while (i<lim)
                    names[i++].innerHTML=username;}
            names=fdjtDOM.$(".codexusername");
            if ((names)&&(names.length)) {
                i=0; lim=names.length; while (i<lim)
                    names[i++].innerHTML=username;}}
        if ($ID("SBOOKMARKUSER"))
            $ID("SBOOKMARKUSER").value=metaBook.user._id;
        
        /* Initialize add gloss prototype */
        var ss=metaBook.stylesheet;
        var form=$ID("METABOOKADDGLOSSPROTOTYPE");
        if (metaBook.user.fbid)  
            ss.insertRule(
                "#METABOOKHUD span.facebook_share { display: inline;}",
                ss.cssRules.length);
        if (metaBook.user.twitterid) 
            ss.insertRule(
                "#METABOOKHUD span.twitter_share { display: inline;}",
                ss.cssRules.length);
        if (metaBook.user.linkedinid) 
            ss.insertRule(
                "#METABOOKHUD span.linkedin_share { display: inline;}",
                ss.cssRules.length);
        if (metaBook.user.googleid) 
            ss.insertRule(
                "#METABOOKHUD span.google_share { display: inline;}",
                ss.cssRules.length);
        var maker=fdjtDOM.getInput(form,"MAKER");
        if (maker) maker.value=metaBook.user._id;
        var pic=
            (metaBook.user._pic)||
            (metaBook.user.pic)||
            ((metaBook.user.fbid)&&
             ("https://graph.facebook.com/"+metaBook.user.fbid+
              "/picture?type=square"));
        if (pic) {
            if ($ID("SBOOKMARKIMAGE")) $ID("SBOOKMARKIMAGE").src=pic;
            if ($ID("METABOOKUSERPIC")) $ID("METABOOKUSERPIC").src=pic;
            var byname=document.getElementsByName("METABOOKUSERPIC");
            if (byname) {
                i=0; lim=byname.length; while (i<lim)
                    byname[i++].src=pic;}}
        var idlinks=document.getElementsByName("IDLINK");
        if (idlinks) {
            i=0; lim=idlinks.length; while (i<lim) {
                var idlink=idlinks[i++];
                idlink.target='_blank';
                idlink.title='click to edit your personal information';
                idlink.href='https://my.bookhub.io/profile';}}
        if (metaBook.user.friends) {
            var friends=metaBook.user.friends; var sourcedb=metaBook.sourcedb;
            i=0; lim=friends.length; while (i<lim) {
                var friend=RefDB.resolve(friends[i++],sourcedb);
                metaBook.addTag2Cloud(friend,metaBook.gloss_cloud);
                metaBook.addTag2Cloud(friend,metaBook.share_cloud);}}
        if (metaBook.outlets)
            metaBook.addOutlets2UI(metaBook.outlets);
        if (Trace.startup) {
            var now=fdjtTime();
            fdjtLog("Setup UI for %s (%s) in %dms",
                    metaBook.user._id,metaBook.user.name||metaBook.user.email,
                    now-startui);}
        metaBook._user_ui_setup=true;}
    metaBook.setupUI4User=setupUI4User;

    function loginUser(info){
        metaBook.user=metaBook.sourcedb.Import(
            info,false,RefDB.REFLOAD|RefDB.REFSTRINGS|RefDB.REFINDEX);
        setupUI4User();
        metaBook._user_setup=false;}
    metaBook.loginUser=loginUser;
    
    function userSetup(){
        // Get any local sync information
        var sync=metaBook.sync=
            getLocal("mB("+mB.docid+").sync",true)||0;
        var started=fdjtTime();
        var loadinfo=false, userinfo=false;

        // If the configuration is set to not persist, but there's
        //  a sync timestamp, we should erase what's there.
        if ((metaBook.sync)&&(!(metaBook.persist)))
            metaBook.clearOffline();

        if (metaBook.nologin) {}
        else if ((metaBook.persist)&&(getLocal("mB.user"))) {
            initUserOffline();
            if (Trace.storage) 
                fdjtLog("Local info for %o (%s) from %o",
                        metaBook.user._id,metaBook.user.name,metaBook.sync);
            // Clear any loadinfo read on startup from the
            // application cache but already stored locally.
            if ((metaBook.user)&&(metaBook.sync)&&(metaBook.cacheglosses)&&
                (window._sbook_loadinfo))
                // Clear the loadinfo "left over" from startup,
                //  which should now be in the database
                window._sbook_loadinfo=false;}
        
        if (metaBook.nologin) {}
        else if ((window._sbook_loadinfo)&&
                 (window._sbook_loadinfo.userinfo)) {
            // Get the userinfo from the loadinfo that might have already been loaded
            loadinfo=window._sbook_loadinfo;
            userinfo=loadinfo.userinfo;
            window._sbook_loadinfo=false;
            if (Trace.storage) 
                fdjtLog("Have window._sbook_loadinfo for %o (%s) dated %o: %j",
                        userinfo._id,userinfo.name||userinfo.email,
                        loadinfo.sync,userinfo);
            setUser(userinfo,
                    loadinfo.outlets,loadinfo.layers,
                    loadinfo.sync);
            if (loadinfo.nodeid) setNodeID(loadinfo.nodeid);}
        else if ((metaBook.userinfo)||(window._userinfo)) {
            userinfo=(metaBook.userinfo)||(window._userinfo);
            if ((Trace.storage)||(Trace.startup))
                fdjtLog("Have %s for %o (%s) dated %o: %j",
                        ((metaBook.userinfo)?("metaBook.userinfo"):("window._userinfo")),
                        userinfo._id,userinfo.name||userinfo.email,
                        userinfo.sync||userinfo.modified,userinfo);
            setUser(userinfo,userinfo.outlets,userinfo.layers,
                    userinfo.sync||userinfo.modified);}
        else {}
        if (Trace.startup>1)
            fdjtLog("userSetup done in %dms",fdjtTime()-started);
        if (metaBook.nologin) return;
        else if (!(metaBook.refuri)) return;
        else {}
        if (window.navigator.onLine) {
            if ((metaBook.user)&&(sync))
                fdjtLog("Requesting additional glosses (> %s (%d)) on %s from %s for %s",
                        fdjtTime.timeString(metaBook.sync),metaBook.sync,
                        metaBook.refuri,metaBook.server,metaBook.user._id,metaBook.user.name);
            else if (metaBook.user)
                fdjtLog("Requesting all glosses on %s from %s for %s (%s)",
                        metaBook.refuri,metaBook.server,metaBook.user._id,metaBook.user.name);
            else fdjtLog(
                "No user, requesting user info and glosses from %s",
                metaBook.server);
            metaBook.updateInfo();
            return;}
        else return;}
    metaBook.userSetup=userSetup;

    function initUserOffline(){
        var user=getLocal("mB.user");
        var sync=metaBook.sync;
        var nodeid=getLocal("mB("+mB.docid+").nodeid",true);
        // We store the information for the current user
        //  in both localStorage and in the "real" sourcedb.
        // We fetch the user from local storage because we
        //  can do that synchronously.
        var userinfo=user&&getLocal(user,true);
        if (Trace.storage)
            fdjtLog("initOffline user=%s sync=%s nodeid=%s info=%j",
                    user,sync,nodeid,userinfo);
        if (!(sync)) return;
        if (!(user)) return;
        if (Trace.startup>1)
            fdjtLog("initOffline userinfo=%j",userinfo);
        // Should these really be refs in sourcedb?
        var outlets=metaBook.outlets=
            (getLocal("mB("+mB.docid+").outlets",true)||[]).map(sourceref);
        var layers=metaBook.layers=
            (getLocal("mB("+mB.docid+").layers",true)||[]).map(sourceref);
        if (userinfo) setUser(userinfo,outlets,layers,sync);
        if (nodeid) setNodeID(nodeid);}
    metaBook.initUserOffline=initUserOffline;

    /* Setting up the clouds */
    
    function addOutlets2UI(outlet){
        if (typeof outlet === 'string')
            outlet=metaBook.sourcedb.ref(outlet);
        if (!(outlet)) return;
        if (outlet instanceof Array) {
            var outlets=outlet;
            var i=0; var lim=outlets.length; while (i<lim)
                addOutlets2UI(outlets[i++]);
            return;}
        if (!(outlet instanceof Ref)) return;
        if (outlet._inui) return;
        var completion=fdjtDOM("span.completion.cue.source",outlet._id);
        function init(){
            outlet._inui=completion;
            completion.id="mbOUTLET"+outlet.humid;
            completion.setAttribute("data-value",outlet._id);
            completion.setAttribute("data-key",outlet.name);
            completion.innerHTML=outlet.name;
            if ((outlet.description)&&(outlet.nick))
                completion.title=outlet.name+": "+outlet.description;
            else if (outlet.description)
                completion.title=outlet.description;
            else if (outlet.nick) completion.title=outlet.name;
            fdjtDOM("#METABOOKSHARECLOUD",completion," ");
            metaBook.share_cloud.addCompletion(completion);}
        outlet.onLoad(init,"addoutlet2cloud");}
    metaBook.addOutlets2UI=addOutlets2UI;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/getglosses.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* globals Promise */

// getglosses.js
(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log, fdjtString=fdjt.String;
    var fdjtTime=fdjt.Time, $ID=fdjt.ID, fdjtAsync=fdjt.Async;
    var RefDB=fdjt.RefDB, fdjtState=fdjt.State, fdjtAjax=fdjt.Ajax;

    var dropClass=fdjtDOM.dropClass, addClass=fdjtDOM.addClass;
    
    var mB=metaBook, Trace=mB.Trace;

    var getQuery=fdjtState.getQuery;
    var getHash=fdjtState.getHash;

    var getLocal=fdjtState.getLocal;
    var saveLocal=metaBook.saveLocal;

    /* Loading meta info (user, glosses, etc) */

    function loadInfo(info) {
        if (metaBook.nouser) {
            metaBook.setConnected(false);
            return;}
        if (window._sbook_loadinfo!==info)
            metaBook.setConnected(true);
        if (info.sticky) metaBook.setPersist(true);
        if (info.mycopyid) gotMyCopyId(info.mycopyid);
        if (!(metaBook.user)) {
            if (info.userinfo)
                metaBook.setUser(
                    info.userinfo,info.outlets,info.layers,
                    info.sync);
            else {
                if (getLocal("mB("+mB.docid+").queued"))
                    metaBook.glossdb.load(
                        getLocal("mB("+mB.docid+").queued",true));
                $ID("METABOOKCOVER").className="bookcover";
                addClass(document.documentElement||document.body,
                         "_NOUSER");}
            if (info.nodeid) metaBook.setNodeID(info.nodeid);}
        else if (info.wronguser) {
            metaBook.clearOffline();
            window.location=window.location.href;
            return;}
        else if ((info.userinfo)&&(metaBook.user)) {
            metaBook.user.importValue(info.userinfo);
            metaBook.user.save();
            metaBook.setupUI4User();}
        if (info.mycopyid) {
            if ((metaBook.mycopyid)&&
                (info.mycopid!==metaBook.mycopyid))
                fdjtLog.warn("Mismatched mycopyids");
            else metaBook.mycopyid=info.mycopyid;}
        if (!(metaBook.docinfo)) { /* Scan not done */
            metaBook.scandone=function(){loadInfo(info);};
            return;}
        else if (info.loaded) return;
        if ((window._sbook_loadinfo)&&
            (window._sbook_loadinfo!==info)) {
            // This means that we have more information from the gloss
            // server before the local app has gotten around to
            // processing  the app-cached loadinfo.js
            // In this case, we put it in _sbook_new_loadinfo
            window._sbook_newinfo=info;
            return;}
        if ((metaBook.persist)&&(metaBook.cacheglosses)&&
            (info)&&(info.userinfo)&&(metaBook.user)&&
            (info.userinfo._id!==metaBook.user._id)) {
            metaBook.clearOffline();}
        info.loaded=fdjtTime();
        if ((!(metaBook.localglosses))&&
            ((getLocal("mB("+mB.docid+").sync"))||
             (getLocal("mB("+mB.docid+").queued"))))
            initGlossesOffline();
        if (Trace.glosses) {
            fdjtLog("loadInfo for %d %sglosses and %d refs (sync=%d)",
                    ((info.glosses)?(info.glosses.length):(0)),
                    ((metaBook.sync)?("updated "):("")),
                    ((info.etc)?(info.etc.length):(0)),
                    info.sync);
            fdjtLog("loadInfo got %d sources, %d outlets, and %d layers",
                    ((info.sources)?(info.sources.length):(0)),
                    ((info.outlets)?(info.outlets.length):(0)),
                    ((info.layers)?(info.layers.length):(0)));}
        if ((info.glosses)||(info.etc))
            initGlosses(info.glosses||[],info.etc||[],
                        function(){infoLoaded(info);});}
    metaBook.loadInfo=loadInfo;

    function infoLoaded(info){
        var keepdata=(metaBook.cacheglosses);
        if (info.etc) gotInfo("etc",info.etc,keepdata);
        if (info.sources) gotInfo("sources",info.sources,keepdata);
        if (info.outlets) gotInfo("outlets",info.outlets,keepdata);
        if (info.layers) gotInfo("layers",info.layers,keepdata);
        if (info.mycopyid) gotMyCopyId(info.mycopyid);
        metaBook.addOutlets2UI(info.outlets);
        if ((info.sync)&&((!(metaBook.sync))||(info.sync>=metaBook.sync))) {
            metaBook.setSync(info.sync);}
        metaBook.loaded=info.loaded=fdjtTime();
        if (metaBook.allglosses) metaBook.allglosses.update();
        if (metaBook.whenloaded) {
            var whenloaded=metaBook.whenloaded;
            metaBook.whenloaded=false;
            setTimeout(whenloaded,10);}
        if (keepdata) {
            metaBook.glossdb.save(true);
            metaBook.sourcedb.save(true);}
        if (metaBook.glosshash) {
            if (metaBook.showGloss(metaBook.glosshash))
                metaBook.glosshash=false;}}

    var updating=false;
    var noajax=false;
    function updatedInfo(data,source,start){
        var user=metaBook.user;
        if ((Trace.network)||
            ((Trace.glosses)&&(data.glosses)&&(data.glosses.length))||
            ((Trace.startup)&&
             ((!(user))||
              ((metaBook.update_interval)&&
               (!(metaBook.ticktock))&&
               (Trace.startup))))) {
            if (start)
                fdjtLog("Response (%dms) from %s",
                        fdjtTime()-start,source||metaBook.server);
            else fdjtLog("Response from %s",source||metaBook.server);}
        updating=false; loadInfo(data);
        if ((!(user))&&(metaBook.user)) metaBook.userSetup();
        else if (metaBook._ui_setup) metaBook.setupUI4User();}
    metaBook.updatedInfo=updatedInfo;
    function updateInfo(callback,jsonp){
        var user=metaBook.user; var start=fdjtTime();
        var uri="https://"+metaBook.server+"/v1/loadinfo.js?REFURI="+
            encodeURIComponent(metaBook.refuri);
        var ajax_headers=((metaBook.sync)?({}):(false));
        if (metaBook.sync)
            ajax_headers["If-Modified-Since"]=
            ((new Date(metaBook.sync*1000)).toString());
        function gotInfo(req){
            updating=false;
            var response=JSON.parse(req.responseText);
            if ((response.glosses)&&(response.glosses.length))
                fdjtLog("Received %d glosses from the server",
                        response.glosses.length);
            metaBook.updatedInfo(
                response,
                uri+((user)?("&SYNCUSER="+user._id):("&JUSTUSER=yes")),
                start);
            if (user) {
                // If there was already a user, just startup
                //  regular updates now
                if ((!(metaBook.ticktock))&&(metaBook.update_interval)) 
                    metaBook.ticktock=setInterval(
                        updateInfo,metaBook.update_interval*1000);}
            else if (metaBook.user)
                // This response gave us a user, so we start
                //  another request, which will get glosses.  The
                //  response to this request will start the
                //  interval timer.
                setTimeout(updateInfo,50);
            else {
                // The response back didn't give us any user information
                fdjtLog.warn("Couldn't determine user!");}}
        function ajaxFailed(req){
            if ((req.readyState===4)&&(req.status<500)) {
                fdjtLog.warn(
                    "Ajax to %s callback failed, falling back to JSONP",
                    uri);
                updateInfoJSONP(uri+((user)?(""):("&JUSTUSER=yes")),jsonp);
                noajax=true;}
            else if (req.readyState===4) {
                try {
                    fdjtLog.warn(
                        "Ajax to %s returned %d %j, taking a break",
                        uri,req.status,JSON.parse(req.responseText));}
                catch (ex) {
                    fdjtLog.warn(
                        "Ajax to %s returned %d, taking a break",
                        uri,req.status);}
                if (metaBook.ticktock) {
                    clearInterval(metaBook.ticktock);
                    metaBook.ticktock=false;}
                setTimeout(updateInfo,metaBook.update_pause);}}
        if ((updating)||(!(navigator.onLine))) return; 
        else updating=true;
        // Get any requested glosses and add them to the call
        var i=0, lim, glosses=getQuery("GLOSS",true); {
            i=0; lim=glosses.length; while (i<lim)
                uri=uri+"&GLOSS="+glosses[i++];}
        glosses=getHash("GLOSS"); {
            i=0; lim=glosses.length; while (i<lim) 
                uri=uri+"&GLOSS="+glosses[i++];}
        if (metaBook.mycopyid)
            uri=uri+"&MCOPYID="+encodeURIComponent(metaBook.mycopyid);
        if (metaBook.authkey)
            uri=uri+"&SBOOKS%3aAUTH-="+encodeURIComponent(metaBook.authkey);
        if (metaBook.sync) uri=uri+"&SYNC="+(metaBook.sync+1);
        if (user) uri=uri+"&SYNCUSER="+user._id;
        if ((!(user))&&(Trace.startup))
            fdjtLog("Requesting initial user info with %s using %s",
                    ((noajax)?("JSONP"):("Ajax")),uri);
        if (noajax) {
            updateInfoJSONP(uri+((user)?(""):("&JUSTUSER=yes")),jsonp);
            return;}
        try { fdjtAjax(gotInfo,
                       uri+"&CALLBACK=return"+((user)?(""):("&JUSTUSER=yes")),[],
                       ajaxFailed,
                       ajax_headers,
                       {timeout: metaBook.update_timeout});}
        catch (ex) {
            fdjtLog.warn(
                "Ajax call to %s failed, falling back to JSONP",uri);
            updateInfoJSONP(uri);}}
    metaBook.updateInfo=updateInfo;
    function updatedInfoJSONP(data){
        var elt=$ID("METABOOKUPDATEINFO");
        metaBook.updatedInfo(data,(((elt)&&(elt.src))||"JSON"));}
    metaBook.updatedInfoJSONP=updatedInfoJSONP;
    function updateInfoJSONP(uri,callback){
        if (!(navigator.onLine)) return;
        if (!(callback)) callback="metaBook.updatedInfoJSONP";
        var elt=$ID("METABOOKUPDATEINFO");
        if (uri.indexOf('?')>0) {
            if (uri[uri.length-1]!=='&') uri=uri+"&";}
        else uri=uri+"?";
        uri=uri+"CALLBACK="+callback;
        var update_script=fdjtDOM("script#METABOOKUPDATEINFO");
        update_script.language="javascript";
        update_script.type="text/javascript";
        update_script.setAttribute("charset","utf-8");
        update_script.setAttribute("async","async");
        if (metaBook.mycopyid)
            update_script.setAttribute("crossorigin","anonymous");
        else update_script.setAttribute("crossorigin","use-credentials");
        update_script.src=uri;
        if (elt) fdjtDOM.replace(elt,update_script);
        else document.body.appendChild(update_script);}

    function gotItem(item,qids){
        if (typeof item === 'string') {
            var load_ref=metaBook.sourcedb.ref(item);
            if (metaBook.persist) load_ref.load();
            qids.push(load_ref._id);}
        else {
            var import_ref=metaBook.sourcedb.Import(
                item,false,
                RefDB.REFLOAD|RefDB.REFSTRINGS|RefDB.REFINDEX);
            import_ref.save();
            qids.push(import_ref._id);}}
    function saveItems(qids,name){
        metaBook[name]=qids;
        if (metaBook.cacheglosses)
            saveLocal("mB"+"("+mB.docid+")."+name,qids,true);}
    
    // Processes loaded info asynchronously
    function gotInfo(name,info,persist) {
        if (info) {
            if (info instanceof Array) {
                var qids=[];
                if (info.length<7) {
                    var i=0; var lim=info.length; 
                    while (i<lim) gotItem(info[i++],qids);
                    saveItems(qids,name);}
                else fdjtAsync.slowmap(
                    function(item){gotItem(item,qids);},
                    info,{done: function(){saveItems(qids,name);}});}
            else {
                var ref=metaBook.sourcedb.Import(
                    info,false,
                    RefDB.REFLOAD|RefDB.REFSTRINGS|RefDB.REFINDEX);
                if (persist) ref.save();
                metaBook[name]=ref._id;
                if (persist) saveLocal("mB"+"("+mB.docid+")."+name,ref._id,true);}}}

    function initGlosses(glosses,etc,callback){
        if (typeof callback === "undefined") callback=true;
        if ((glosses.length===0)&&(etc.length===0)) return;
        var msg=$ID("METABOOKNEWGLOSSES");
        var start=fdjtTime();
        if (msg) {
            msg.innerHTML=fdjtString(
                "Assimilating %d new glosses",glosses.length);
            addClass(msg,"running");}
        if (etc) {
            if (glosses.length)
                fdjtLog("Assimilating %d new glosses/%d sources...",
                        glosses.length,etc.length);}
        else if ((glosses.length)&&(Trace.glosses)) 
            fdjtLog("Assimilating %d new glosses...",glosses.length);
        else {}
        metaBook.sourcedb.Import(
            etc,false,RefDB.REFLOAD|RefDB.REFSTRINGS|RefDB.REFINDEX,true);
        metaBook.glossdb.Import(
            glosses,{"tags": Knodule.importTagSlot},
            RefDB.REFLOAD|RefDB.REFSTRINGS|RefDB.REFINDEX,
            callback);
        var i=0; var lim=glosses.length;
        var latest=metaBook.syncstamp||0;
        while (i<lim) {
            var gloss=glosses[i++];
            var tstamp=gloss.syncstamp||gloss.tstamp;
            if (tstamp>latest) latest=tstamp;}
        metaBook.syncstamp=latest;
        if (glosses.length)
            fdjtLog("Assimilated %d new glosses in %dms...",
                    glosses.length,fdjtTime()-start);
        dropClass(msg,"running");}
    metaBook.initGlosses=initGlosses;
    
    function go_online(){return offline_update();}
    function offline_update(){
        metaBook.writeQueuedGlosses(); updateInfo();}
    metaBook.update=offline_update;
    
    fdjtDOM.addListener(window,"online",go_online);

    metaBook.addConfig("glossupdate",function(name,value){
        metaBook.update_interval=value;
        if (metaBook.ticktock) {
            clearInterval(metaBook.ticktock);
            metaBook.ticktock=false;
            if (value) metaBook.ticktock=
                setInterval(updateInfo,value*1000);}});
    metaBook.addConfig("updatetimeout",function(name,value){
        metaBook.update_timeout=value;});
    metaBook.addConfig("updatepause",function(name,value){
        metaBook.update_pause=value;});

    var offline_init=false;

    function initGlossesOffline(){
        if (offline_init) return false;
        else offline_init=true;
        var sync=metaBook.sync;
        if (!(sync)) return;
        if ((Trace.glosses)||(Trace.startup))
            fdjtLog("Starting initializing glosses from local storage");
        metaBook.sourcedb.load(true);
        var loading=metaBook.glossdb.load(true);
        if (loading) 
            loading.then(function(){
                if ((metaBook.glossdb.allrefs.length)||
                    (metaBook.sourcedb.allrefs.length))
                    fdjtLog("Initialized %d glosses (%d sources) from local storage",
                            metaBook.glossdb.allrefs.length,
                            metaBook.sourcedb.allrefs.length);});}
    metaBook.initGlossesOffline=initGlossesOffline;

    var need_mycopyid=[];

    function gotMyCopyId(string){
        function mycopyidupdate(resolve){
            if (!(string)) return resolve(string);
            if (string===mB.mycopyid) return resolve(string);
            var tickmatch=/:x(\d+)/.exec(string);
            var tick=(tickmatch)&&(tickmatch.length>1)&&(parseInt(tickmatch[1]));
            var expires=(tick)&&(new Date(tick*1000));
            if ((Trace.glosses>1)||(Trace.glossdata))
                fdjtLog("gotMyCopyId: %s/%s, cur=%s/%s",
                        string,expires,metaBook.mycopyid,metaBook.mycopyid_expires);
            if (!(expires)) {
                metaBook.umycopyid=string;
                metaBook.saveLocal("umycopyid("+mB.docuri+")",string);}
            if ((!(metaBook.mycopyid))||
                ((!(metaBook.mycopyid_expires))&&(expires))||
                ((metaBook.mycopyid_expires)&&(expires)&&
                 (expires>metaBook.mycopyid_expires))) {
                metaBook.mycopyid=string; metaBook.mycopyid_expires=expires;
                metaBook.saveLocal("mycopyid("+mB.docuri+")",string);}
            else {}
            if ((need_mycopyid)&&(need_mycopyid.length)) {
                var needs=need_mycopyid; need_mycopyid=[];
                return fdjtAsync.slowmap(function(fn){fn(string);},needs).
                    then(function(){resolve(string);});}
            else return resolve(string);}
        return new Promise(mycopyidupdate);}
    metaBook.gotMyCopyId=gotMyCopyId;

    var getting_mycopyid=false;

    function getMyCopyId(){
        function updatemycopyid(resolved){
            var now=new Date();
            if ((mB.mycopyid)&&(mB.mycopyid_expires>now))
                return resolved(mB.mycopyid);
            else if (!(getting_mycopyid)) getFreshMyCopyId();
            need_mycopyid.push(resolved);}
        return new Promise(updatemycopyid);}
    metaBook.getMyCopyId=getMyCopyId;

    function getFreshMyCopyId(){
        if (getting_mycopyid) return;
        getting_mycopyid=fdjtTime();
        fdjtAjax.fetchText("https://auth.bookhub.io/getmycopyid?DOC="+mB.docref).
            then(function(mycopyid){
                gotMyCopyId(mycopyid).then(function(){getting_mycopyid=false;});});}

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/startup.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file specifies the startup of the metaBook web application,
   initializing both internal data structures and the DOM.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false, Markdown: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
//var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
//var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
//var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

metaBook.Startup=
    (function(){
        "use strict";

        var fdjtString=fdjt.String;
        var fdjtDevice=fdjt.device;
        var fdjtState=fdjt.State;
        var fdjtAsync=fdjt.Async;
        var fdjtAjax=fdjt.Ajax;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        var $ID=fdjt.ID;
        var RefDB=fdjt.RefDB;
        var mbID=metaBook.ID;
        
        var CodexLayout=fdjt.CodexLayout;

        var https_root="https://s3.amazonaws.com/beingmeta/static/";

        // Imported functions
        var getLocal=fdjtState.getLocal;
        var getSession=fdjtState.getSession;
        var getQuery=fdjtState.getQuery;
        var getCookie=fdjtState.getCookie;
        var getMeta=fdjtDOM.getMeta;
        var getLink=fdjtDOM.getLink;
        var addClass=fdjtDOM.addClass;
        var swapClass=fdjtDOM.swapClass;
        var dropClass=fdjtDOM.dropClass;

        var mB=metaBook;
        var Trace=metaBook.Trace;

        var readLocal=metaBook.readLocal;
        var saveLocal=metaBook.saveLocal;

        /* Initialization */
        
        function startupMessage(){
            if ((Trace.startup)&&
                (typeof Trace.startup === "number")&&
                (Trace.startup>1))
                fdjtLog.apply(null,arguments);}
        metaBook.startupMessage=startupMessage;

        function dropSplashPage(){
            var splash=$ID("METABOOKSPLASHPAGE");
            if ((splash)&&(splash.parentNode))
                splash.parentNode.removeChild(splash);}
        metaBook.dropSplashPage=dropSplashPage;

        function run_inits(){
            var inits=metaBook.inits;
            var i=0, lim=inits.length;
            while (i<lim) {inits[i++]();}}

        /* Save local */

        function syncStartup(){
            // This is the startup code which is run
            //  synchronously, before the time-sliced processing
            fdjtLog.console="METABOOKCONSOLELOG";
            fdjtLog.consoletoo=true;
            run_inits();
            if (!(metaBook._setup_start)) metaBook._setup_start=new Date();
            metaBook.appsource=getSourceRef();
            fdjtLog("This is metaBook %s, built %s on %s, launched %s, from %s",
                    mB.version,mB.buildtime,mB.buildhost,
                    mB._setup_start.toString(),
                    mB.root||metaBook.appsource||"somewhere");
            if ($ID("METABOOKBODY")) metaBook.body=$ID("METABOOKBODY");

            // Check for any trace settings
            if (getQuery("mbtrace")) useTraceSettings(getQuery("mbtrace",true));
            if (getSession("mbtrace")) useTraceSettings([getSession("mbtrace")]);
            if (getLocal("mbtrace")) useTraceSettings([getLocal("mbtrace")]);
            
            // Get various settings for the sBook from the HTML
            // (META tags, etc), including settings or guidance for
            // skimming, graphics, layout, glosses, etc.
            readBookSettings();
            fdjtLog("Book %s (%s) %s (%s%s)",
                    mB.docref||"@??",mB.bookbuild||"",
                    mB.refuri,mB.sourceid,
                    ((mB.sourcetime)?
                     (": "+mB.sourcetime.toString()):
                     ("")));
            
            // Initialize the databases
            metaBook.initDB();

            // Get config information
            metaBook.initConfig();

            // This sets various aspects of the environment
            readEnvSettings();

            // Use the cached mycopyid if available
            readMycopyid();

            // Figure out if we have a user and whether we can keep
            // user information
            if (getLocal("mB.user")) {
                metaBook.setPersist(true);
                metaBook.userSetup();}

            // Initialize the book state (location, targets, etc)
            metaBook.initState(); metaBook.syncState();

            mB.gotMyCopyId(mB.readLocal("mB("+mB.docid+").mycopyid"));

            // If we have no clue who the user is, ask right away (updateInfo())
            if (!((metaBook.user)||(window._sbook_loadinfo)||
                  (metaBook.userinfo)||(window._userinfo)||
                  (getLocal("mB.user")))) {
                if (Trace.startup)
                    fdjtLog("No local user info, requesting from bookhub server %s",
                            mB.server);
                // When metaBook.user is not defined, this just
                // requests identity information
                metaBook.updateInfo();}

            // Execute any FDJT initializations
            fdjt.Init();

            metaBook.updateSizeClasses();

            setupBook();
            setupDevice();
            setupApp();
            metaBook._ui_setup=fdjtTime();
            showMessage();
            if (metaBook._user_setup) metaBook.setupUI4User();
            setupContent();
            metaBook.setupGestures();

            // Reapply config settings to update the HUD UI
            metaBook.setConfig(metaBook.getConfig());

            if (Trace.startup>1)
                fdjtLog("Initializing markup converter");
            var markdown_converter=new Markdown.Converter();
            metaBook.markdown_converter=markdown_converter;
            metaBook.md2HTML=function(mdstring){
                return markdown_converter.makeHtml(mdstring);};
            function md2DOM(mdstring,inline){
                var div=fdjtDOM("div"), root=div;
                var frag=document.createDocumentFragment();
                div.innerHTML=markdown_converter.makeHtml(mdstring);
                var children=root.childNodes, nodes=[];
                if ((inline)&&(children.length===1)&&
                    (children[0].nodeType===1)&&
                    (children[0].tagName==="P")) {
                    root=children[0]; children=root.childNodes;}
                var i=0, lim=children.length; while (i<lim) {
                    nodes.push(children[i++]);}
                i=0; while (i<lim) frag.appendChild(nodes[i++]);
                return frag;}
            metaBook.md2DOM=md2DOM;

            metaBook.Timeline.sync_startup=new Date();
            if (metaBook.onsyncstartup) {
                var delayed=metaBook.onsyncstartup;
                delete metaBook.onsyncstartup;
                if (Array.isArray(delayed)) {
                    var i=0, lim=delayed.length;
                    while (i<lim) {delayed[i](); i++;}}
                else delayed();}
            if (Trace.startup)
                fdjtLog("Done with sync startup");}

        function getSourceRef(){
            var scripts=fdjtDOM.$("SCRIPT");
            var i=0, len=scripts.length;
            while (i<len) {
                var elt=scripts[i++];
                if ((elt.src)&&(typeof elt.src === "string")&&
                    (elt.src.search(/metabook.js(#|\?|$)/)>=0))
                    return elt.src;}
            return false;}

        function showMessage(){
            var message=fdjt.State.getCookie("APPMESSAGE");
            if (message) fdjt.UI.alertFor(10,message);
            fdjt.State.clearCookie("APPMESSAGE","/","bookhub.io");}

        function readEnvSettings() {

            // Initialize domain and origin for browsers which care
            try {document.domain="bookhub.io";}
            catch (ex) {fdjtLog.warn("Error setting document.domain");}
            try {document.origin="bookhub.io";}
            catch (ex) {fdjtLog.warn("Error setting document.origin");}

            // First, define common schemas
            fdjtDOM.addAppSchema("METABOOK","http://metabook.bookhub.io/");
            fdjtDOM.addAppSchema("BOOKHUB","http://bookhub.io/");
            fdjtDOM.addAppSchema("PUBTOOL","http://pubtool.bookhub.io/");
            fdjtDOM.addAppSchema("DC","http://purl.org/dc/elements/1.1/");
            fdjtDOM.addAppSchema("DCTERMS","http://purl.org/dc/terms/");
            fdjtDOM.addAppSchema("OLIB","http://openlibrary.org/");
            fdjtDOM.addAppSchema("TOC","http://beingmeta.com/TOC/");
            fdjtDOM.addAppSchema("INDEX","http://beingmeta.com/INDEX/");
            fdjtDOM.addAppSchema("BM","http://beingmeta.com/");

            metaBook.devinfo=fdjtState.versionInfo();
            
            /* Where to get your images from, especially to keep
               references inside https */
            if ((metaBook.root==="http://static.beingmeta.com/")&&
                (window.location.protocol==='https:'))
                metaBook.root=https_root;
            // Whether to suppress login, etc
            if ((getLocal("mB.nologin"))||(getQuery("nologin")))
                metaBook.nologin=true;
            var glosshost=getMeta("BOOKHUB.server")||getMeta("GLOSSDB");
            if (glosshost) metaBook.server=glosshost;
            else if (fdjtState.getCookie("METABOOKSERVER"))
                metaBook.server=fdjtState.getCookie("METABOOKSERVER");
            else if (fdjtState.getCookie("GLOSSDB"))
                metaBook.server=fdjtState.getCookie("GLOSSDB");
            else metaBook.server=lookupServer(document.domain);
            if (!(metaBook.server)) metaBook.server=metaBook.default_server;
            updateServerInfo(metaBook.server);

            if (fdjtState.getLocal("mB.devmode")) {
                addClass(document.documentElement,"_DEVMODE");
                metaBook.devmode=true;}

            // Get the settings for scanning the document structure
            getScanSettings();}

        function readMycopyid(){
            var string=readLocal("mB("+mB.docid+").mycopyid");
            if (!(string)) return;
            var tickmatch=/:x(\d+)/.exec(string);
            var tick=(tickmatch)&&(tickmatch.length>1)&&(parseInt(tickmatch[1]));
            var expires=(tick)&&(new Date(tick*1000));
            if (expires>(new Date())) mB.gotMyCopyId(string);}

        function setupApp(){

            var body=document.body;
            var started=fdjtTime();

            if (Trace.startup>2) fdjtLog("Starting app setup");

            // Create a custom stylesheet for the app
            var style=fdjtDOM("STYLE");
            fdjtDOM(document.head,style);
            metaBook.stylesheet=style.sheet;

            // This initializes the book tools
            //  (the HUD/Heads Up Display and the cover)
            metaBook.initHUD();
            metaBook.setupCover();
            setupBookInfo();
            setupZoom();
            setupMedia();

            metaBook.initSettings();

            if (metaBook.refuri) {
                var refuris=document.getElementsByName("REFURI");
                if (refuris) {
                    var j=0; var len=refuris.length;
                    while (j<len) {
                        if (refuris[j].value==='fillin')
                            refuris[j++].value=metaBook.refuri;
                        else j++;}}}

            metaBook.addConfig(
                "cacheglosses",
                function(name,value){
                    metaBook.setCacheGlosses(value);
                    fdjt.Async(function(){
                        metaBook.updateSettings(name,value);});});

            imageSetup();

            // Setup the reticle (if desired)
            if ((typeof (body.style["pointer-events"])!== "undefined")&&
                ((metaBook.demo)||(fdjtState.getLocal("mB.demo"))||
                 (fdjtState.getCookie("crosshair"))||
                 (getQuery("crosshair")))) {
                fdjtUI.Reticle.setup();}

            if (Trace.startup)
                fdjtLog("App setup took %dms",fdjtTime()-started);

            fdjtLog("Body: %s",document.body.className);}
        
        function imageSetup(){
            var i, lim, started=fdjtTime();
            var uri=
                ((typeof metaBook.coverimage === "string")&&
                 (metaBook.coverimage))||
                ((typeof metaBook.bookimage === "string")&&
                 (metaBook.bookimage))||
                ((typeof metaBook.bookcover === "string")&&
                 (metaBook.bookcover))||
                ((typeof metaBook.coverpage === "string")&&
                 (metaBook.coverpage));
            if (uri) {
                var bookimages=fdjtDOM.$("img.metabookbookimage");
                i=0; lim=bookimages.length;
                while (i<lim) {
                    if (bookimages[i].src) i++;
                    else bookimages[i++].src=uri;}}
            var thumb_uri=
                ((typeof metaBook.thumbnail === "string")&&(metaBook.thumbnail));
            if (thumb_uri) {
                var thumbimages=fdjtDOM.$("img.metabookbookthumb");
                i=0; lim=thumbimages.length;
                while (i<lim) {
                    if (thumbimages[i].src) i++;
                    else thumbimages[i++].src=thumb_uri;}}
            var icon_uri=
                ((typeof metaBook.icon === "string")&&(metaBook.icon));
            if (icon_uri) {
                var iconimages=fdjtDOM.$("img.metabookbookicon");
                i=0; lim=iconimages.length;
                while (i<lim) {
                    if (iconimages[i].src) i++;
                    else iconimages[i++].src=icon_uri;}}
            if (Trace.startup>1)
                fdjtLog("Image setup took %dms",fdjtTime()-started);}
        
        function setupContent(){
            var started=fdjtTime();
            // Modifies the DOM in various ways
            metaBook.initBody();
            // Size the content
            metaBook.sizeContent();
            if (Trace.gestures)
                fdjtLog("Content setup in %dms",fdjtTime()-started);}

        metaBook.setSync=function setSync(val){
            if (!(val)) return false;
            var cur=metaBook.sync;
            if ((cur)&&(cur>val)) return cur;
            metaBook.sync=val;
            if (metaBook.persist)
                saveLocal("mB("+mB.docid+").sync",val);
            return val;};

        function useTraceSettings(tracing){
            var i=0; var lim=tracing.length;
            while (i<lim) {
                var trace_spec=tracing[i++];
                var colon=trace_spec.indexOf(":");
                if (colon<0) {
                    if (typeof Trace[trace_spec] === 'number')
                        Trace[trace_spec]=1;
                    else Trace[trace_spec]=true;}
                else {
                    var trace_name=trace_spec.substr(0,colon);
                    var trace_val=trace_spec.substr(colon+1);
                    if (typeof Trace[trace_name] === 'number')
                        Trace[trace_name]=parseInt(trace_val,10);
                    else Trace[trace_name]=trace_val;}}}

        var glosshash_pat=/G[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;
        
        function metaBookStartup(force){
            var metadata=false;
            if (metaBook._setup) return;
            if ((!force)&&(getQuery("nometabook"))) return;
            /* Cleanup, save initial hash location */
            if ((location.hash==="null")||(location.hash==="#null"))
                location.hash="";
            if ((location.hash)&&(location.hash!=="#")) {
                var hash=location.hash;
                if (hash[0]==='#') hash=hash.slice(1);
                if (glosshash_pat.exec(location.hash))
                    metaBook.glosshash=hash;
                else metaBook.inithash=location.hash;}
            metaBook._starting=fdjtTime();
            addClass(document.body,"mbSTARTUP");
            // This is all of the startup that we need to do synchronously
            syncStartup();

            metaBook.resizeUI().then(function(){dropSplashPage();});
            
            // The rest of the stuff we timeslice
            fdjtAsync.timeslice
            ([  // Scan the DOM for metadata.  This is surprisingly
                //  fast, so we don't currently try to timeslice it or
                //  cache it, though we could.
                function(){
                    applyTOCRules();
                    metadata=scanDOM();
                    metaBook.setupTOC(metadata[metaBook.content.id]);},
                function(){
                    var hasText=fdjtDOM.hasText;
                    var rules=fdjtDOM.getMeta("METABOOK.index",true)
                        .concat(fdjtDOM.getMeta("PUBTOOL.index",true))
                        .concat(fdjtDOM.getMeta("INDEX.include",true))
                        .concat(fdjtDOM.getMeta("textindex",true));
                    var content=$ID("CODEXCONTENT");
                    rules.push("p,li,ul,blockquote,div");
                    rules.push("h1,h2,h3,h4,h5,h6,h7,hgroup,.sbookindex");
                    var nodes=fdjtDOM.getChildren(content,rules.join(","));
                    var index=metaBook.textindex=new fdjt.TextIndex();
                    var i=0, lim=nodes.length; while (i<lim) {
                        var node=nodes[i++];
                        if (hasText(node)) index.indexText(node);}
                    index.finishIndex();},
                function(){
                    var toSet=RefDB.toSet;
                    var docdb=metaBook.docdb;
                    var index=metaBook.textindex;
                    var docinfo=metaBook.docinfo;
                    var allids=index.allids, idterms=index.idterms;
                    var allterms=index.allterms, termindex=index.termindex;
                    var wix=docdb.addIndex('strings',RefDB.StringMap);
                    var t=0, nterms=allterms.length; while (t<nterms) {
                        var term=allterms[t++];
                        wix[term]=toSet(termindex[term]);}
                    var n=0, nids=allids.length; while (n<nids) {
                        var id=allids[n++], doc=docinfo[id];
                        if (doc) doc.strings=toSet(idterms[id]);}},
                /*
                function(){
                    var six=docdb.addIndex('sectag',RefDB.StringMap);
                    var i=0, lim=allinfo.length; while (i<lim) {
                        var node=allinfo[i++], heads=node.heads;
                        if (node.sectag) six.add(node.sectag,node);
                        var h=0, nheads=heads.length;
                        while (h<nheads) {
                            if (heads[h].sectag)
                                six.add(node.sectag,node);}}},
                */
                // Now you're ready to lay out the book, which is
                //  timesliced and runs on its own.  We wait to do
                //  this until we've scanned the DOM because we may
                //  use results of DOM scanning in layout (for example,
                //  heading information).
                function(){
                    if (metaBook.bypage) metaBook.Paginate("initial");
                    else addClass(document.body,"_SCROLL");},
                // Load all source (user,layer,etc) information
                function(){
                    if (Trace.startup>1) fdjtLog("Loading sourcedb");
                    metaBook.sourcedb.load(true);},
                // Read knowledge bases (knodules) used by the book
                ((Knodule)&&(Knodule.HTML)&&
                 (Knodule.HTML.Setup)&&(metaBook.knodule)&&
                 (function(){
                     var knomsg=$ID("METABOOKSTARTUPKNO");
                     var knodetails=$ID("METABOOKSTARTUPKNODETAILS");
                     if (knodetails) {
                         knodetails.innerHTML=fdjtString(
                             "Processing knodule %s",metaBook.knodule.name);}
                     addClass(knomsg,"running");
                     if ((Trace.startup>1)||(Trace.indexing))
                         fdjtLog("Processing knodule %s",metaBook.knodule.name);
                     Knodule.HTML.Setup(metaBook.knodule);
                     dropClass(knomsg,"running");})),
                // Process locally stored (offline data) glosses
                function(){
                    if (metaBook.sync) {
                        if (metaBook.cacheglosses) 
                            return metaBook.initGlossesOffline();}
                    else if (window._sbook_loadinfo) {
                        metaBook.loadInfo(window._sbook_loadinfo);
                        window._sbook_loadinfo=false;}},
                // Process anything we got via JSONP ahead of processing
                //  _sbook_loadinfo
                ((window._sbook_newinfo)&&(function(){
                    metaBook.loadInfo(window._sbook_newinfo);
                    window._sbook_newinfo=false;})),
                function(){metaBook.setupIndex(metadata);},
                startupDone],
             {slice: 100, space: 25});}
        metaBook.Startup=metaBookStartup;
        
        function addTOCLevel(specs,level){
            var j=0, nspecs=specs.length; while (j<nspecs) {
                var nodes=fdjtDOM.$(specs[j++]);
                var i=0, lim=nodes.length; while (i<lim) {
                    nodes[i++].setAttribute("data-toclevel",level);}}}
        function applyTOCRules(){
            var h1=getMeta("TOC.head1",true,true)
                .concat(getMeta("TOC.sect1",true,true))
                .concat(getMeta("sbook1head",true));
            if (h1.length) addTOCLevel(h1,"1");
            var h2=getMeta("TOC.head2",true,true)
                .concat(getMeta("TOC.sect2",true,true))
                .concat(getMeta("sbook2head",true,true));
            if (h2.length) addTOCLevel(h2,"2");
            var h3=getMeta("TOC.head3",true,true)
                .concat(getMeta("TOC.sect3",true,true))
                .concat(getMeta("sbook3head",true));
            if (h3.length) addTOCLevel(h3,"3");
            var h4=getMeta("TOC.head4",true,true)
                .concat(getMeta("TOC.sect4",true,true))
                .concat(getMeta("sbook4head",true,true));
            if (h4.length) addTOCLevel(h4,"4");
            var h5=getMeta("TOC.head5",true,true)
                .concat(getMeta("TOC.sect5",true,true))
                .concat(getMeta("sbook5head",true,true));
            if (h5.length) addTOCLevel(h5,"5");
            var h6=getMeta("TOC.head6",true,true)
                .concat(getMeta("TOC.sect6",true,true))
                .concat(getMeta("sbook6head",true,true));
            if (h6.length) addTOCLevel(h6,"6");
            var h7=getMeta("TOC.head7",true,true)
                .concat(getMeta("TOC.sect7",true,true))
                .concat(getMeta("sbook7head",true,true));
            if (h7.length) addTOCLevel(h7,"7");}

        function scanDOM(){
            if ((Trace.startup)||(Trace.domscan))
                fdjtLog("Starting DOM scan with %o",metaBook.content);
            var scanmsg=$ID("METABOOKSTARTUPSCAN");
            addClass(scanmsg,"running");
            var metadata=new metaBook.DOMScan(
                metaBook.content,metaBook.refuri+"#");
            metaBook.docinfo=metadata;
            metaBook.ends_at=metaBook.docinfo._maxloc;
            if ((Trace.startup)||(Trace.domscan))
                fdjtLog("Done with DOM scan yielding %o",
                        metadata);
            dropClass(scanmsg,"running");
            if ((metaBook.state)&&(metaBook.state.target)&&
                (!((metaBook.state.location)))) {
                var info=metaBook.docinfo[metaBook.state.target];
                if ((info)&&(info.starts_at)) {
                    metaBook.state.location=info.starts_at;
                    // Save current state, skip history, force save
                    metaBook.saveState(false,true,true);}}
            
            if (metaBook.scandone) {
                var donefn=metaBook.scandone;
                delete metaBook.scandone;
                donefn();}
            return metadata;}
        
        function startupDone(mode){
            if ((metaBook.glosshash)&&(metaBook.glossdb.ref(metaBook.glosshash))) {
                if (metaBook.showGloss(metaBook.glosshash)) {
                    metaBook.glosshash=false;
                    metaBook.Timeline.initLocation=fdjtTime();}
                else metaBook.initLocation();}
            else metaBook.initLocation();
            window.onpopstate=function onpopstate(evt){
                if (evt.state) metaBook.restoreState(evt.state,"popstate");};
            fdjtLog("metaBook startup done");
            metaBook.resizeUI(); // Just in case
            metaBook.displaySync();
            fdjtDOM.dropClass(document.body,"mbSTARTUP");
            fdjtDOM.addClass(document.body,"mbREADY");
            if ($ID("METABOOKSPLASHPAGE"))
                setTimeout(function(){
                    addClass("METABOOKSPLASHPAGE","startupdone");},
                           3000);
            var rmsg=$ID("METABOOKREADYMESSAGE");
            if (!($ID("METABOOKOPENTAB"))) {
                rmsg.innerHTML="Open";
                rmsg.id="METABOOKOPENTAB";}
            else rmsg.style.display='none';
            if (mode) {}
            else if (getQuery("startmode"))
                mode=getQuery("startmode");
            else {}
            if (mode) metaBook.setMode(mode);
            else mode=metaBook.mode;
            metaBook._setup=new Date();
            metaBook._starting=false;
            if (metaBook.onsetup) {
                var onsetup=metaBook.onsetup;
                metaBook.onsetup=false;
                setTimeout(onsetup,10);}
            var msg=false, uuid_end=false, msgid=false;
            if ((msg=getQuery("APPMESSAGE"))) {
                if ((msg.slice(0,2)==="#{")&&
                    ((uuid_end=msg.indexOf('}'))>0)) {
                    msgid="MSG_"+msg.slice(2,uuid_end);
                    if (getLocal(msgid)) {}
                    else {
                        saveLocal(msgid,"seen");
                        fdjtUI.alertFor(10,msg.slice(uuid_end+1));}}
                else fdjtUI.alertFor(10,msg);}
            if ((msg=getCookie("APPMESSAGE"))) {
                fdjtUI.alertFor(10,msg);
                fdjtState.clearCookie("APPMESSAGE","bookhub.io","/");}
            if ((!(mode))&&(location.hash)&&(metaBook.state)&&
                (location.hash.slice(1)!==metaBook.state.target))
                metaBook.hideCover();
            else if ((!(mode))&&(metaBook.user)) {
                var opened=readLocal(
                    "mB("+mB.docid+").opened",true);
                if ((opened)&&((opened+((3600+1800)*1000))>fdjtTime()))
                    metaBook.hideCover();}
            if (fdjtDOM.vischange)
                fdjtDOM.addListener(document,fdjtDOM.vischange,
                                    metaBook.visibilityChange);
            fdjtDOM.addListener(window,"resize",metaBook.resizeHandler);}
        
        /* Application settings */
        
        var default_config=metaBook.default_config;

        function getRelLink(relname){
            return getLink(relname,false,true,false,true);}

        function readBookSettings(){
            // Basic stuff
            var refuri=_getsbookrefuri();
            var docuri=_getsbookdocuri();
            var locuri=window.location.href;
            var hashpos=locuri.indexOf('#');
            if (hashpos>0) metaBook.locuri=locuri.slice(0,hashpos);
            else metaBook.locuri=locuri;
            document.body.refuri=metaBook.refuri=refuri;
            metaBook.topuri=document.location.href;
            metaBook.docuri=docuri;
            
            var refuris=getLocal("mB.refuris",true)||[];
            var docuris=getLocal("mB.docuris",true)||[];
            var docids=getLocal("mB.docids",true)||[];
            var html=document.documentElement||
                ((document.querySelector)&&(document.querySelector("HTML")));

            metaBook.sourceid=
                html.getAttribute("data-sourceid")||
                getMeta("PUBTOOL.sourceid")||getMeta("PUBTOOL.fileid")||
                metaBook.docuri;
            var sourcetime=html.getAttribute("data-sourcetime")||
                getMeta("PUBTOOL.sourcetime");
            if (sourcetime)
                metaBook.sourcetime=fdjtTime.parse(sourcetime);
            var oldid=getLocal("mB("+mB.docid+").sourceid");
            if ((oldid)&&(oldid!==metaBook.sourceid)) {
                var layouts=getLocal("mB("+oldid+").layouts");
                if ((layouts)&&(layouts.length)) {
                    var i=0, lim=layouts.length; while (i<lim) 
                        CodexLayout.dropLayout(layouts[i++]);}}
            else saveLocal("mB("+mB.docid+").sourceid",
                           metaBook.sourceid);

            var bookbuild=html.getAttribute("data-buildstamp");
            if (bookbuild) {
                var brk=bookbuild.indexOf(' ');
                metaBook.buildstamp=bookbuild;
                if (brk>0) {
                    metaBook.bookbuildhost=bookbuild.slice(0,brk);
                    metaBook.bookbuildtime=
                        fdjtTime.parse(bookbuild.slice(brk+1));}}

            metaBook.bypage=(metaBook.page_style==='bypage'); 
            metaBook.max_excerpt=
                getMeta("METABOOK.maxexcerpt")||(metaBook.max_excerpt);
            metaBook.min_excerpt=
                getMeta("METABOOK.minexcerpt")||(metaBook.min_excerpt);
            
            var notespecs=getMeta("booknote",true).concat(
                getMeta("METABOOK.booknote",true));
            var noterefspecs=getMeta("booknoteref",true).concat(
                getMeta("METABOOK.booknoteref",true));
            metaBook.booknotes=(((notespecs)&&(notespecs.length))?
                                 (fdjtDOM.sel(notespecs)):(false));
            metaBook.booknoterefs=(((noterefspecs)&&(noterefspecs.length))?
                                   (fdjtDOM.sel(noterefspecs)):(false));
            
            if (refuris.indexOf(refuri)<0) {
                refuris.push(refuri);
                saveLocal("mB.refuris",refuris,true);}
            if (docuris.indexOf(docuri)<0) {
                docuris.push(docuri);
                saveLocal("mB.docuris",docuris,true);}

            var docref=getMeta("BOOKHUB.docref"), docid;
            if (docref) metaBook.docid=metaBook.docref=docid=docref;
            else metaBook.docid=docid=docuri;
            saveLocal("mB("+docid+")",docuri);

            if (docids.indexOf(docid)<0) {
                docuris.push(docuri);
                saveLocal("mB.docuris",docuris,true);}

            var coverpage=
                getRelLink("PUBTOOL.coverpage")||getRelLink("coverpage")||
                getRelLink("*.coverpage");
            if (coverpage) metaBook.coverpage=coverpage;
            var coverimage=
                getRelLink("PUBTOOL.coverimage")||getRelLink("coverimage")||
                getRelLink("*.coverimage");
            if (coverimage) metaBook.coverimage=coverimage;
            var thumbnail=
                getRelLink("PUBTOOL.thumbnail")||getRelLink("thumbnail")||
                getRelLink("*.thumbnail");
            if (thumbnail) metaBook.thumbnail=thumbnail;
            var icon=getRelLink("PUBTOOL.icon")||getRelLink("icon")||
                getRelLink("*.icon");
            if (icon) metaBook.icon=icon;
            
            var baseid=getMeta("BOOKHUB.id")||
                getMeta("*.prefix")||getMeta("*.baseid");
            if (baseid) metaBook.baseid=baseid;
            var prefix=getMeta("BOOKHUB.idprefix")||
                getMeta("*.prefix")||getMeta("*.idprefix")||baseid;
            if (prefix) metaBook.prefix=prefix;
            var targetprefix=getMeta("METABOOK.targetprefix");
            if ((targetprefix)&&(targetprefix==="*"))
                metaBook.targetids=false;
            else if ((targetprefix)&&(targetprefix[0]==='/'))
                metaBook.targetids=
                new RegExp(targetprefix.slice(1,targetprefix.length-1));
            else if (targetprefix)
                metaBook.targetids=new RegExp("^"+targetprefix);
            else if (prefix)
                metaBook.targetids=new RegExp("^"+prefix);
            else metaBook.targetids=false;
            
            var autofonts=fdjtDOM.getMeta("METABOOK.adjustfont",true);
            if (autofonts.length)
                fdjt.DOM.autofont=fdjt.DOM.autofont+","+autofonts.join(",");

            if (getMeta("METABOOK.forcelayout")) mB.forcelayout=true;

            var autotoc=getMeta("METABOOK.autotoc");
            if (autotoc) {
                if ((autotoc[0]==="y")||(autotoc[0]==="Y")||
                    (autotoc==="ON")||(autotoc==="on")||
                    (autotoc==="1")||(autotoc==="enable"))
                    metaBook.autotoc=true;
                else metaBook.autotoc=false;}

            if (!(metaBook.nologin)) {
                metaBook.mycopyid=getMeta("BOOKHUB.mycopyid")||
                    (getLocal("mycopyid("+refuri+")"))||
                    false;}}

        function setupDevice(){
            var root=document.documentElement||document.body;
            var useragent=navigator.userAgent;
            var device=fdjtDevice;
            if (Trace.startup>2) 
                fdjtLog("Starting device setup for %s",useragent);

            var started=fdjtTime();

            if ((!(device.touch))&&(getQuery("touch")))
                device.touch=getQuery("touch");
            
            // Don't bubble from TapHold regions (by default)
            fdjt.TapHold.default_opts.bubble=false;
            
            if (device.touch) {
                fdjtDOM.addClass(root,"_TOUCH");
                fdjt.TapHold.default_opts.fortouch=true;
                metaBook.ui="touch";
                metaBook.touch=true;
                metaBook.keyboard=false;
                viewportSetup();}
            if (device.android) {
                default_config.keyboardhelp=false;
                metaBook.updatehash=false;}
            else if ((useragent.search("Safari/")>0)&&
                     (useragent.search("Mobile/")>0)) { 
                hide_mobile_safari_address_bar();
                metaBook.updatehash=false;
                // Animation seems to increase crashes in iOS
                // metaBook.dontanimate=true;
                // default_config.layout='fastpage';
                default_config.keyboardhelp=false;
                // Have fdjtLog do it's own format conversion for the log
                fdjtLog.doformat=true;}
            else if (device.touch) {
                fdjtDOM.addClass(root,"_TOUCH");
                metaBook.ui="touch";}
            else if (!(metaBook.ui)) {
                // Assume desktop or laptop
                fdjtDOM.addClass(root,"_MOUSE");
                metaBook.ui="mouse";}
            else {}
            
            if (Trace.startup>1) {
                fdjtLog("setupDevice done in %dms: %s/%dx%d %s",
                        fdjtTime()-started,
                        metaBook.ui,fdjtDOM.viewWidth(),fdjtDOM.viewHeight(),
                        device.string);}}

        function setupBook(){
            if (metaBook.bookinfo) return;
            if (Trace.startup>2) fdjtLog("Book setup");
            var bookinfo=metaBook.bookinfo={}; var started=fdjtTime();
            bookinfo.title=
                getMeta("METABOOK.title")||
                getMeta("PUBTOOL.title")||
                getMeta("DC.title")||
                getMeta("~TITLE")||
                document.title||"untitled";
            var authors=getMeta("METABOOK.author",true)
                .concat(getMeta("PUBTOOL.author",true))
                .concat(getMeta("DC.creator",true))
                .concat(getMeta("AUTHOR"))
                .concat(getMeta("~AUTHOR"));
            if ((authors)&&(authors.length)) bookinfo.authors=authors;
            bookinfo.byline=
                getMeta("METABOOK.byline")||
                getMeta("PUBTOOL.byline")||
                getMeta("BYLINE")||
                ((authors)&&(authors.length)&&(authors[0]));
            bookinfo.copyright=
                getMeta("PUBTOOL.copyright")||
                getMeta("BOOKHUB.copyright")||
                getMeta("DC.rights")||
                getMeta("COPYRIGHT")||
                getMeta("RIGHTS");
            bookinfo.publisher=
                getMeta("PUBTOOL.pubname")||
                getMeta("BOOKHUB.pubname")||
                getMeta("DC.publisher")||
                getMeta("PUBLISHER");
            bookinfo.pubyear=
                getMeta("PUBTOOL.pubyear")||
                getMeta("BOOKHUB.pubyear")||
                getMeta("DC.date");
            bookinfo.description=
                getMeta("METABOOK.description")||
                getMeta("BOOKHUB.description")||
                getMeta("PUBTOOL.description")||
                getMeta("DC.description")||
                getMeta("DESCRIPTION");
            bookinfo.digitized=
                getMeta("PUBTOOL.digitized")||
                getMeta("DIGITIZED");
            bookinfo.converted=getMeta("PUBTOOL.converted");
            if (Trace.startup>1)
                fdjtLog("setupBook done in %dms",fdjtTime()-started);}
        function getBookInfo(){
            if (metaBook.bookinfo) return metaBook.bookinfo;
            else {setupBook(); return metaBook.bookinfo;}}
        metaBook.getBookInfo=getBookInfo;
        
        /* Viewport setup */

        var viewport_spec=
            "width=device-width,initial-scale=1.0,user-scalable=no";
        function viewportSetup(){
            var head=fdjtDOM.getHEAD();
            var viewport=getMeta("viewport",false,false,true);
            if (!(viewport)) {
                viewport=document.createElement("META");
                viewport.setAttribute("name","viewport");
                viewport.setAttribute("content",viewport_spec);
                head.appendChild(viewport);}
            var isapp=getMeta("apple-mobile-web-app-capable",false,false,true);
            if (!(isapp)) {
                isapp=document.createElement("META");
                isapp.setAttribute("name","apple-mobile-web-app-capable");
                isapp.setAttribute("content","yes");
                head.appendChild(isapp);}}

        function hide_mobile_safari_address_bar(){
            window.scrollTo(0,1);
            setTimeout(function(){window.scrollTo(0,0);},0);}

        /* Getting settings */

        function _getsbookrefuri(){
            var refuri=getLink("refuri",false,true)||
                getLink("METABOOK.refuri",false,true)||
                getLink("BOOKHUB.refuri",false,true)||
                getLink("PUBTOOL.refuri",false,true)||
                getMeta("refuri",false,true)||
                getLink("canonical",false,true);
            if (refuri) return decodeURI(refuri);
            else {
                var locref=document.location.href;
                var qstart=locref.indexOf('?');
                if (qstart>=0) locref=locref.slice(0,qstart);
                var hstart=locref.indexOf('#');
                if (hstart>=0) locref=locref.slice(0,hstart);
                return decodeURI(locref);}}
        function _getsbookdocuri(){
            return getLink("docuri",false)||
                getLink("METABOOK.docuri",false)||
                getLink("BOOKHUB.docuri",false)||
                getLink("PUBTOOL.docuri",false)||
                getLink("canonical",false)||
                _getsbookrefuri();}

        function lookupServer(string){
            var sbook_servers=metaBook.servers;
            var i=0;
            while (i<sbook_servers.length) 
                if (sbook_servers[i][0]===string)
                    return sbook_servers[i][1];
            else if (string.search(sbook_servers[i][0])>=0)
                return sbook_servers[i][1];
            else if ((sbook_servers[i][0].call) &&
                     (sbook_servers[i][0].call(string)))
                return sbook_servers[i][1];
            else i++;
            return false;}

        function gotServerInfo(data){
            var host_spec="<span class='host'>"+metaBook.server+"</span>";
            if ((metaBook.server_info)&&
                (metaBook.server_info.serverip!==data.serverip))
                fdjtLog.warn(
                    "Server %s IP change from %s to %s:\n\t%j\n\t%j",
                    metaBook.server,
                    metaBook.server_info.serverip,data.serverip,
                    metaBook.server_info,data);
            if (data.servername!==metaBook.server)
                host_spec=host_spec+" / "+
                "<span class='host'>"+data.servername+"</span>";
            if (data.hostname!==data.servername)
                host_spec=host_spec+" / "+
                "<span class='host'>"+data.hostname+"</span>";
            if (data.serverip) {
                host_spec=host_spec+" / "+
                    "<span class='host'>"+data.serverip+"</span>";}
            metaBook.server_info=data;
            var info=fdjt.DOM.$(".metabookserverinfo");
            var i=0, lim=info.length; while (i<lim) {
                info[i++].innerHTML="<strong>Glosses</strong> from "+host_spec;}}

        function fetchServerInfo(){
            var servername=metaBook.server;
            fdjtDOM.removeListener(window,"online",fetchServerInfo);
            fdjtAjax.jsonCall(gotServerInfo,"https://"+servername+"/_info");}
        function updateServerInfo(){
            if (navigator.onLine) fetchServerInfo();
            else fdjtDOM.addListener(window,"online",fetchServerInfo);}
        metaBook.updateServerInfo=updateServerInfo;
        
        function hasTOCLevel(elt){
            if ((elt.toclevel)||
                ((elt.getAttributeNS)&&
                 (elt.getAttributeNS('toclevel','http://beingmeta.com/TOC/')))||
                (elt.getAttribute('toclevel'))||
                (elt.getAttribute('data-toclevel'))||
                ((elt.className)&&(elt.className.search)&&
                 ((elt.className.search(/\bsbook\dhead\b/)>=0)||
                  (elt.className.search(/\bsbooknotoc\b/)>=0)||
                  (elt.className.search(/\bsbookignore\b/)>=0))))
                return true;
            else return false;}
        metaBook.hasTOCLevel=hasTOCLevel;

        function getScanSettings(){
            if ((!(metaBook.docroot))&&(getMeta("METABOOK.rootid")))
                metaBook.docroot=mbID(getMeta("METABOOK.rootid"));
            metaBook.docroot=metaBook.docroot||
                $ID("METABOOKROOT")||
                $ID("CODEXCONTENT")||
                document.body;
            if ((!(metaBook.start))&&(getMeta("METABOOK.startid")))
                metaBook.start=mbID(getMeta("METABOOK.startid"));
            metaBook.start=metaBook.start||
                $ID("METABOOKSTART")||$ID("BOOKSTART");
            var i=0; while (i<9) {
                var body=document.body;
                var rules=getMeta("TOC.head"+i,true)
                    .concat(getMeta("TOC.sect"+i,true))
                    .concat(getMeta("tochead"+i,true));
                if ((rules)&&(rules.length)) {
                    var j=0; var lim=rules.length; while (j<lim) {
                        var elements=fdjtDOM.getChildren(body,rules[j++]);
                        var k=0; var n=elements.length;
                        while (k<n) {
                            var elt=elements[k++];
                            if (!(hasTOCLevel(elt))) elt.toclevel=i;}}}
                i++;}
            // These are all meta class definitions, which is why
            //  they don't have regular schema prefixes
            var ignore=getMeta("htmlbookignore",true)
                .concat((getMeta("METABOOK.ignore",true)))
                .concat((getMeta("PUBTOOL.ignore",true)));
            if (ignore.length)
                metaBook.ignore=new fdjtDOM.Selector(ignore);
            var notoc=getMeta("tocheadnone",true)
                .concat(getMeta("TOC.ignore",true));
            if (notoc.length)
                metaBook.notoc=new fdjtDOM.Selector(notoc);
            var terminal=getMeta("htmlbookterminal",true)
                .concat(getMeta("METABOOK.terminal",true))
                .concat(getMeta("PUBTOOL.terminal",true));
            if (terminal.length)
                metaBook.terminals=new fdjtDOM.Selector(terminal.length);
            var focus=getMeta("htmlbooktarget",true)
                .concat(getMeta("METABOOK.target",true))
                .concat(getMeta("METABOOK.idify",true));
            if (focus.length)
                metaBook.focus=new fdjtDOM.Selector(focus);
            var nofocus=getMeta("htmlbooktarget",true).
                concat(getMeta("METABOOK.notarget",true));
            if (nofocus.length)
                metaBook.nofocus=new fdjtDOM.Selector(nofocus);}

        function setupBookInfo(){
            var info=fdjt.DOM.$(".metabookrefinfo"), elt;
            var i=0, lim=info.length; while (i<lim) {
                elt=info[i++];
                elt.innerHTML="<strong>Ref:</strong> ";
                fdjtDOM.append(elt,fdjtDOM("span.refuri",metaBook.refuri),
                               " ",fdjtDOM("span.oidref",metaBook.docref));}
            info=fdjt.DOM.$(".metabooksourceinfo");
            i=0; lim=info.length; while (i<lim) {
                elt=info[i++];
                elt.innerHTML="<strong>Source:</strong> ";
                if (metaBook.sourcetime)
                    elt.appendChild(timeDOM(metaBook.sourcetime));
                fdjtDOM.append(
                    elt," ",fdjtDOM("span.uuid",metaBook.sourceid));}
            info=fdjt.DOM.$(".metabookbuildinfo");
            i=0; lim=info.length; while (i<lim) {
                elt=info[i++]; elt.innerHTML="<strong>Book Build:</strong> ";
                if ((metaBook.bookbuild)&&(!(metaBook.bookbuildhost)))
                    elt.appendChild(metaBook.bookbuild);
                else {
                    if (metaBook.bookbuildtime) 
                        elt.appendChild(timeDOM(metaBook.bookbuildtime));
                    fdjtDOM.append(
                        elt," on ",fdjtDOM("span.host",metaBook.bookbuildhost));}}
            info=fdjt.DOM.$(".metabookappinfo");
            i=0; lim=info.length; while (i<lim) {
                elt=info[i++]; elt.innerHTML="";
                fdjtDOM(elt,fdjtDOM("strong","App:")," ",
                        "metaBook version ",metaBook.version,
                        " built on ",fdjtDOM("span.host",metaBook.buildhost),
                        ((metaBook.buildtime)&&(" at ")),
                        timeDOM(metaBook.buildtime), " loaded from ",
                        fdjtDOM("span.host",metaBook.appsource));}
            info=fdjt.DOM.$(".metabookcopyrightinfo");
            i=0; lim=info.length; while (i<lim) {
                info[i++].innerHTML=
                    "Program and Interface "+
                    "<span class='inlinesymbol'>©"+"</span>"+
                    " beingmeta, inc 2008-2015";}}

        function timeDOM(x){
            var elt;
            try {
                if (typeof x === "string")
                    elt=fdjtDOM("time",x);
                else elt=fdjtDOM("time",x.toString());
                if (typeof x === "string")
                    elt.setAttribute("datetime",x);
                else elt.setAttribute("datetime",x.toISOString());
                return elt;}
            catch (ex) {
                return document.createTextNode("??time??");}}

        function setupZoom(){
            var zoom=metaBook.Zoom=fdjtDOM(
                "div#METABOOKZOOM.metabookzoom.metabookcontent",
                fdjtDOM("div#METABOOKZOOMBOX",
                        fdjtDOM("div#METABOOKZOOMTARGET")),
                fdjtDOM("div#METABOOKZOOMCONTROLS",
                        fdjtDOM("div#METABOOKZOOMCLOSE"),
                        fdjtDOM("div#METABOOKUNZOOM"),
                        fdjtDOM("div#METABOOKZOOMIN"),
                        fdjtDOM("div#METABOOKZOOMOUT"),
                        fdjtDOM("div#METABOOKZOOMHELP"),
                        fdjtDOM("div#METABOOKZOOMHELPTEXT",
                                "Drag to pan, use two fingers to zoom")));
            zoom.metabookui=true;
            document.body.appendChild(zoom);}
        metaBook.setupZoom=setupZoom;
        
        function setupMedia(){
            var media=metaBook.Media=fdjtDOM(
                "div#METABOOKMEDIA.metabookmedia.metabookcontent",
                fdjtDOM("div#METABOOKMEDIATARGET"),
                fdjtDOM("div#METABOOKCLOSEMEDIA"));
            media.metabookui=true;
            document.body.appendChild(media);}
        metaBook.setupMedia=setupMedia;

        metaBook.addConfig("uisound",function(name,value){
            metaBook.uisound=(value)&&(true);});
        metaBook. addConfig("readsound",function(name,value){
            metaBook.readsound=(value)&&(true);});
        metaBook.addConfig("bodycontrast",function(name,value){
            var mbody=$ID("METABOOKBODY");
            if (!(value))
                dropClass(mbody,/\bmetabookcontrast[a-z]+\b/g);
            else swapClass(mbody,/\bmetabookcontrast[a-z]+\b/g,
                           "metabookcontrast"+value);
            fdjt.Async(function(){
                metaBook.updateSettings(name,value);});});
        
        /* Enable Open Sans */
        var open_sans_stack=
            "'Open Sans',Verdana, Tahoma, Arial, Helvetica, sans-serif, sans";
        function enableOpenSans(){
            var frame=$ID("METABOOKFRAME");
            if (!(frame)) return;
            frame.style.fontFamily=open_sans_stack;
            metaBook.resizeUI();}
        metaBook.enableOpenSans=enableOpenSans;

        /* Other setup */
        
        metaBook.StartupHandler=function(){
            metaBook.Startup();};

        return metaBookStartup;})();
metaBook.Setup=metaBook.StartupHandler;

//fdjt.DOM.noautotweakfonts="Handled by metaBook";
/*
  sbookStartup=metaBook.StartupHandler;
  sbook={Start: metaBook.Startup,
  setUser: metaBook.setUser,
  Startup: metaBook.Startup};
*/

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/slices.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements the display of lists of glosses or summaries
   referring to book passages.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.
   This file assumes that the sbooks.js file has already been loaded.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

metaBook.Slice=(function () {
    "use strict";
    
    var fdjtString=fdjt.String;
    var fdjtTime=fdjt.Time;
    var fdjtDOM=fdjt.DOM;
    var fdjtLog=fdjt.Log;
    var fdjtUI=fdjt.UI;
    var showPage=fdjt.showPage;
    var RefDB=fdjt.RefDB, Ref=RefDB.Ref;
    var $=fdjtDOM.$, $ID=fdjt.ID;

    var mB=metaBook, mbID=mB.ID, Trace=mB.Trace;

    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;

    var mbicon=metaBook.icon;
    var addListener=fdjtDOM.addListener;

    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var getChild=fdjtDOM.getChild;

    var getInitials=fdjtString.getInitials;

    var cancel=fdjtUI.cancel;
    
    var TOA=fdjtDOM.toArray;

    function getTargetDup(scan,target){
        var targetid=target.id;
        while (scan) {
            if (hasClass(scan,"codexpage")) return scan;
            else if ((scan.getAttribute)&&
                     ((scan.id===targetid)||
                      (scan.getAttribute("data-baseid")===targetid))) 
                return scan;
            else scan=scan.parentNode;}
        return target;}

    function generic_cancel(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        if (fdjtUI.isClickable(target)) return;
        else cancel(evt);}

    function renderCard(info,query,idprefix,standalone){
        var target_id=(info.frag)||(info.id);
        // var target=((target_id)&&(mbID(target_id)));
        var target_info=metaBook.docinfo[target_id];
        if (!(target_info)) return false;
        var head_info=((target_info.level)?(target_info):(target_info.head));
        var head=((head_info)&&(mbID(head_info.frag)));
        var score=((query)&&(query.scores.get(info)));
        var excerpt_len=((info.excerpt)?(info.excerpt.length):(0));
        var note=(info.note)&&(info.note.trim());
        var note_len=(note)&&note.length;
        var overlay=getoverlay(info);
        var shared=(info.shared)||[];
        var sample=(query)&&(!(standalone))&&(!(info.maker))&&
            sampletext(mbID(target_id));
        if (typeof shared === 'string') shared=[shared];
        if (overlay) shared=RefDB.remove(shared,(overlay._qid||overlay._id));
        var body=
            fdjtDOM("div.metabookcardbody",
                    ((score)&&(showscore(info,score,query))),
                    (((info.maker)||(info.tstamp))?(showglossinfo(info)):
                     (showdocinfo(info))),
                    (sample),
                    ((note_len>0)&&(info.maker)&&(showmaker(info))),
                    ((note_len>0)&&(shownote(info)))," ",
                    ((info.detail)&&(fdjtDOM("span.glossbody","More")))," ",
                    (((info.alltags)||(info.tags))&&(showtags(info,query)))," ",
                    ((info.links)&&(showlinks(info.links)))," ",
                    ((info.attachments)&&
                     (showlinks(info.attachments,"span.attachments")))," ",
                    ((shared)&&(shared.length)&&(showaudience(shared))),
                    ((excerpt_len>0)&&(showexcerpts(info.excerpt)))," ");
        var card=
            fdjtDOM(((info.maker) ?
                     "div.metabookcard.gloss" :
                     "div.metabookcard.passage"),
                    ((head)&&(makeTOCHead(head,((info.level)&&(info))))),
                    ((standalone)&&(makelocbar(target_info))),
                    body,
                    fdjtDOM("div.fdjtclearfloats"));
        if (info.maker) {
            info.maker.load().then(function(makerinfo){
                var tstamp=info.tstamp||info.modified||info.created;
                if (!(makerinfo._live)) return;
                if (makerinfo.kind!==':PERSON') return;
                if (tstamp)
                    body.title="gloss from "+((makerinfo.name)||"someone")+
                    " at "+fdjtTime.shortString(tstamp);
                else body.title="gloss from "+((makerinfo.name)||"someone");
                addClass(card,"personal");});}
        card.about="#"+info.frag;
        card.setAttribute('data-passage',target_id);
        card.setAttribute('data-location',target_info.starts_at);
        if (head_info) card.setAttribute('data-tochead',head_info.frag);
        if ((info.maker)||(info.tstamp)) {
            card.setAttribute('data-gloss',info._id);
            if (info.tstamp)
                card.setAttribute('data-timestamp',info.tstamp);}
        if (score) card.setAttribute("data-searchscore",score);
        if (idprefix) card.id=idprefix+info.id;
        if (info._id) {
            card.name=card.qref=info._id;
            card.setAttribute("name",info._id);}
        return card;}
    metaBook.renderCard=renderCard;
    
    function sampletext(para,len){
        if (!(len)) len=80;
        if (!(para)) return false;
        var fulltext=fdjtDOM.textify(para);
        var sample=(para.title)||para.getAttribute("data-summary")||
            ((fulltext.length<len)?(fulltext):(fulltext.slice(0,len)));
        var span=fdjtDOM("span.sample",sample);
        span.title=fulltext;
        return span;}

    function convertNote(note){
        if (note.search(/^{(md|markdown)}/)===0) {
            var close=note.indexOf('}');
            return metaBook.md2DOM(note.slice(close+1),true);}
        else return note;}
    function shownote(gloss){
        return fdjtDOM("span.note",convertNote(gloss.note));}

    function showmaker(gloss){
        var maker=gloss.maker;
        if (maker._live)
            return fdjtDOM("span.maker",maker.name||"From");
        else {
            var temp=fdjtDOM("span.maker","From");
            maker.load().then(function(m){
                if (m.name) temp.innerHTML=m.name;});
            return temp;}}

    var isArray=Array.isArray;

    function showtags(info,query){
        var tagicon=fdjtDOM.Image(mbicon("tagicon",64,64),
                                  "img.tagicon","tags");
        var matches=((query)&&(fdjtDOM("span.matches")));
        var toptags=fdjtDOM("span.top");
        var sectags=fdjtDOM("span.sectags");
        var othertags=fdjtDOM("span.other");
        var count=0, seen={};
        var tagslots=["**tags","*tags","+tags","+tags*","knodes","tags",
                      "**tags*","*tags*","tags*","^tags","^tags*"];
        var j=0, nslots=tagslots.length, ntags=0;
        while (j<nslots) {
            var slot=tagslots[j++], tags=info[slot];
            if (!(tags)) continue;
            else if (!(isArray(tags))) tags=[tags];
            else if (tags.length===0) continue;
            else {}
            var i=0, lim=tags.length; ntags=ntags+lim;
            while (i<lim) {
                var tag=tags[i++];
                if (!(tag)) continue;
                var tagstring=((typeof tag === "string")?(tag):
                               ((tag._qid)||(tag.getQID())));
                if (seen[tagstring]) continue;
                else {count++; seen[tagstring]=tag;}
                var sectag=((tag._qid)&&(tag._qid[0]==="\u00a7"));
                var elt=((sectag)?(sectag2HTML(tag)):
                         (Knodule.HTML(tag,metaBook.knodule)));
                if ((matches)&&(tag_matchp(tag,query)))
                    fdjtDOM(matches," ",elt);
                else if (sectag) fdjtDOM(sectags," ",elt);
                else if (count<4) fdjtDOM(toptags," ",elt);
                else fdjtDOM(othertags," ",elt);}}
        if (ntags)
            return fdjtDOM("span.tags",tagicon,
                           matches,toptags,othertags,sectags);
        else return false;}

    function tag_matchp(tag,query){
        var qtags=query.tags;
        var i=0, lim=qtags.length;
        while (i<lim) {
            var qtag=qtags[i++];
            if (qtag===tag) return true;
            else if ((tag.allways)&&(tag.allways.indexOf(qtag)>=0))
                return true;
            else {}}
        return false;}

    function sectag2HTML(sectag){
        var name=sectag._id;
        var span=fdjtDOM("span.sectname",name);
        span.setAttribute("data-value",sectag._qid);
        if (name.length>20) addClass(span,"longterm");
        return span;}

    function showaudience(outlets,spec){
        if (!(outlets instanceof Array)) outlets=[outlets];
        if (outlets.length===0) return false;
        var span=fdjtDOM(
            spec||((outlets.length>1)?("div.audience"):("span.audience")),
            ((outlets.length>1)&&
             (fdjtDOM("span.count",outlets.length, " outlets"))),
            " ");
        var i=0; var lim=outlets.length; while (i<lim) {
            var outlet=outlets[i]; var info=metaBook.sourcedb.ref(outlet);
            var outlet_span=fdjtDOM("span.outlet");
            if (info._live) {
                fdjtDOM(outlet_span,info.name);
                if (info.about) 
                    outlet_span.title="Shared with “"+info.name+
                    "” — "+info.about;
                else outlet_span.title="Shared with “"+info.name+"”";}
            else {
                outlet_span.setAttribute("NAME","OUTLETSPAN"+info._id);
                info.load().then(fill_outlet_spans);}
            fdjtDOM.append(span," ",outlet_span);
            i++;}
        return span;}
    function fill_outlet_spans(info){
        var outlet_spans=
            TOA(document.getElementsByName("OUTLETSPAN"+info._id));
        var i=0, len=outlet_spans.length; while (i<len) {
            var outlet_span=outlet_spans[i++];
            outlet_span.removeAttribute("NAME");
            fdjtDOM(outlet_span,info.name);
            if (info.about) 
                outlet_span.title="Shared with “"+info.name+"” — "+info.about;
            else outlet_span.title="Shared with “"+info.name+"”";}}

    function showlinks(refs,spec){
        var count=0;
        for (var url in refs) if (url[0]==='_') continue; else count++;
        if (count===0) return false;
        var span=fdjtDOM(spec||((count>4)?("div.links"):("span.links")),
                         ((count>1)&&(fdjtDOM("span.count",count, " links"))),
                         " ");
        for (url in refs) {
            if (url[0]==='_') continue;
            var urlinfo=refs[url], elt=false;
            var openinbook=(url.search("https://glossdata.bookhub.io/")===0)||
                (url.search("https://glossdata.sbooks.net/")===0)||
                (url.search("resources/")===0);
            var title; var icon=false, type=false, useclass=false;
            if (!(openinbook)) {
                var inbookurls=metaBook.inbookurls;
                var i=0, lim=inbookurls; while (i<lim) {
                    var pat=inbookurls[i++];
                    if (typeof pat === 'string') {
                        if (url.search(pat)===0) {openinbook=true; break;}}
                    else if (pat.exec(url)) {
                        openinbook=true; break;}
                    else {}}}
            if (typeof urlinfo === 'string') title=urlinfo;
            else {
                title=urlinfo.title;
                icon=urlinfo.icon;
                type=urlinfo.type;}
            if (!(type)) type=metaBook.urlType(url);
            if (!(icon)) icon=metaBook.typeIcon(type);
            if (!(useclass)) useclass=metaBook.mediaTypeClass(type);
            var image=fdjtDOM.Image(icon);
            if (openinbook) {
                elt=fdjtDOM("span.mbmedia",image,title);
                elt.setAttribute("data-src",url);
                if (type) elt.setAttribute("data-type",type);
                elt.title="Reveal "+title;}
            else elt=fdjtDOM.Anchor(
                url,{title:"Link to "+url,target:"_blank"},image,title);
            if (useclass) addClass(elt,useclass);
            fdjtDOM(span,elt,"\n");}
        return span;}
    function showexcerpts(excerpts){
        if (typeof excerpts==='string')
            return fdjtUI.Ellipsis("span.excerpt",excerpts,40);
        else if (excerpts.length===1)
            return fdjtUI.Ellipsis("span.excerpt",excerpts[0],40);
        else {
            var ediv=fdjtDOM("div.excerpts");
            var i=0; var lim=excerpts.length;
            while (i<lim)
                fdjtDOM(ediv,
                        ((i>0)&&" "),
                        fdjtUI.Ellipsis("span.excerpt",excerpts[i++],40));
            return ediv;}}
    function showscore(elt,score,query){
        var staricon=fdjtDOM.Image(mbicon("goldstar",24,24),"img.inline");
        var tagicon=fdjtDOM.Image(mbicon("tagicon",24,24),"img.inline");
        var count=((query)&&(query.counts)&&(query.counts.get(elt)));
        var partial=((count)&&(query.tags.length>1)&&
                     ((count!==query.tags.length)?                     
                      (fdjtDOM("span.note",count,tagicon)):
                      (fdjtDOM("span.note","all",tagicon))));
        if (count) count=count+":";
        if ((query)&&(query.max_score))
            return fdjtDOM(
                "span.score",partial,"(",score,"/",query.max_score,staricon,")");
        else return fdjtDOM("span.score",partial,"(",score,staricon,")");}
    function showglossinfo(info) {
        var maker=info.maker, makerid=(info.maker._id)||(info.maker);
        var can_edit=((maker===metaBook.user)||(maker===metaBook.user._id))||
            ((mB.outlets)&&(mB.outlets.indexOf(maker)>=0))||
            ((mB.outlets)&&(mB.outlets.indexOf(makerid)>=0));
        var agestring=timestring(info.modified||info.created||info.tstamp);
        var age=fdjtDOM("span.age",agestring);
        age.title=fdjtTime.timeString(info.modified||info.created||info.tstamp);
        var tool=fdjtDOM(
            "span.tool",age," ",
            fdjtDOM("span.label",((can_edit)?"modify":"respond")),
            ((can_edit)?
             (fdjtDOM.Image(mbicon("gloss_edit_titled",64,64),"img.button",
                            "edit","tap to edit this gloss, hold to reply")):
             (fdjtDOM.Image(mbicon("gloss_respond_titled",64,64),"img.button",
                            "reply","relay/reply to this gloss"))),
            ((info.private)&&(fdjtDOM("span.private","Private"))));
        addListener(tool,"tap",glossaction);
        addListener(tool,"release",glossaction);
        
        var pic=getglosspic(info);
        if (pic) fdjtDOM.addListener(pic,"touchstart",fdjt.UI.noDefault);

        return [pic,tool];}
    function showdocinfo(info) {
        if (info) return false; else return false;}

    function getoverlay(info){
        if (info.sources) {
            var sources=info.sources;
            if (typeof sources === 'string') sources=[sources];
            var i=0; var lim=sources.length;
            while (i<lim) {
                var source=metaBook.sourcedb.loadref(sources[i++]);
                if ((source)&&(source.kind===':OVERLAY'))
                    return source;}
            return false;}
        else return false;}

    var IMG=fdjtDOM.Image;

    function getglosspic(gloss){
        if (gloss._pic||gloss.pic) 
            return IMG(gloss._pic||gloss.pic,"img.glosspic.glossicon",
                       gloss.note||gloss.name);
        if ((gloss.links)&&(gloss.links.icon))
            return IMG(gloss.links.icon,"img.glosspic.glossicon");
        var maker=((gloss.maker)&&
                   ((typeof gloss.maker === "string")?
                    (gloss.maker=mB.sourcedb.ref(gloss.maker)):
                    (gloss.maker)));
        if ((maker)&&(maker._live)&&((maker._pic)||maker.pic)) 
            return IMG(maker._pic||maker.pic,"img.glosspic.userpic",
                       maker.name);
        else if ((maker)&&(maker._live)&&(maker.fbid))
            return IMG("https://graph.facebook.com/"+
                       gloss.maker.fbid+"/picture?type=square",
                       "img.glosspic.userpic.fbpic",
                       gloss.maker.name);
        else if ((maker)&&(maker._live))
            return fdjtDOM("div.glosspic.userpic.sbooknopic",
                           ((gloss.maker.name)?
                            (getInitials(gloss.maker.name,1)):
                            "?"));
        else if (maker) {
            var temp=
                fdjtDOM("div.glosspic.userpic.sbooknopic",
                        ((gloss.maker.name)?
                         (fdjtString.getInitials(gloss.maker.name,1)):
                         "?"));
            maker.load().then(function(maker){
                var usepic=false;
                if (!(maker._live)) usepic=false;
                else if ((maker._pic)||(maker.pic))
                    usepic=IMG(maker._pic||maker.pic,"img.glosspic.userpic",
                               getInitials(gloss.maker.name,1),
                               ((maker.about)?((maker.name)+": "+maker.about):
                                (maker.name)));
                else if (maker.fbid) 
                    usepic=IMG("https://graph.facebook.com/"+
                               maker.fbid+"/picture?type=square",
                               "img.glosspic.userpic.fbpic",
                               getInitials(gloss.maker.name,1),
                               ((maker.about)?((maker.name)+": "+maker.about):
                                (maker.name)));
                else {}
                if (usepic) fdjtDOM.replace(temp,usepic);});
            return temp;}
        else return false;}

    var months=["Jan","Feb","Mar","Apr","May","Jun",
                "Jul","Aug","Sep","Oct","Nov","Dec"];
    function timestring(tick){
        var now=fdjtTime.tick(), date=new Date(1000*tick);
        if ((now-tick)<(12*3600)) {
            var hour=date.getHours();
            var minute=date.getMinutes();
            return ""+hour+":"+((minute<10)?"0":"")+minute;}
        else {
            var year=date.getFullYear();
            var month=date.getMonth();
            var datenum=date.getDate();
            if (year<10)
                return ""+datenum+"/"+months[month]+"/0"+year;
            else return ""+datenum+"/"+months[month]+"/"+year;}}

    function makelocbar(target_info,cxt_info){
        var locrule=fdjtDOM("HR");
        var locbar=fdjtDOM("DIV.locbar",locrule);
        var target_start=target_info.starts_at;
        var target_end=target_info.ends_at;
        var target_len=target_end-target_start;
        if (!(cxt_info)) cxt_info=metaBook.docinfo[document.body.id];
        var cxt_start=cxt_info.starts_at;
        var cxt_end=cxt_info.ends_at;
        var cxt_len=cxt_end-cxt_start;
        locrule.style.width=((target_len/cxt_len)*100)+"%";
        locrule.style.left=(((target_start-cxt_start)/cxt_len)*100)+"%";
        var id=target_info.id||target_info.frag;
        if (id) {
            locbar.about="#"+id;
            locbar.title=sumText(mbID(id));}
        return locbar;}

    function makelocrule(target_info,cxtinfo,spec){
        var tocrule=(!(cxtinfo));
        if (!(cxtinfo)) cxtinfo=metaBook.docinfo[metaBook.content.id];
        var locrule=fdjtDOM(spec||"hr.locrule");
        var cxt_start=cxtinfo.starts_at;
        var cxt_end=cxtinfo.ends_at;
        var cxt_len=cxt_end-cxt_start;
        var target_start=target_info.starts_at-cxt_start;
        var target_len=target_info.ends_at-target_info.starts_at;
        var locstring="~"+Math.ceil(target_len/5)+ " words long ~"+
            Math.ceil((target_start/cxt_len)*100)+"% along";
        locrule.setAttribute("about","#"+(target_info.id||target_info.frag));
        locrule.locstring=locstring+".";
        locrule.title=
            ((tocrule)?("this section in the book"):
             ("this passage in the section, "))+
            locstring+": click or hold to glimpse";
        locrule.style.width=((target_len/cxt_len)*100)+"%";
        locrule.style.left=((target_start/cxt_len)*100)+"%";
        return locrule;}
    function makelocstring(target_info,cxtinfo){
        var tocrule=(!(cxtinfo));
        if (!(cxtinfo)) cxtinfo=metaBook.docinfo[metaBook.content.id];
        var cxt_start=cxtinfo.starts_at;
        var cxt_end=cxtinfo.ends_at;
        var cxt_len=cxt_end-cxt_start;
        var target_start=target_info.starts_at-cxt_start;
        var target_len=target_info.ends_at-target_info.starts_at;
        if (tocrule)
            return "this section is ~"+Math.ceil(target_len/7)+
            " words long and ~"+Math.ceil((target_start/cxt_len)*100)+
            "% into the book";
        else return "this passage is ~"+Math.ceil(target_len/7)+
            " words long and ~"+Math.ceil((target_start/cxt_len)*100)+
            "% into the section";}

    function glossaction(evt){
        var target=fdjtUI.T(evt), scan=target;
        fdjtUI.cancel(evt);
        while (scan) {
            if (scan.qref) break;
            else scan=scan.parentNode;}
        if (!(scan)) return;
        var qref=scan.qref;
        var gloss=metaBook.glossdb.ref(qref);
        var form=metaBook.setGlossTarget(gloss,evt.type==="hold");
        if (!(form)) return;
        metaBook.setMode("addgloss");}

    // Displayings sets of notes organized into threads

    function sumText(target){
        var title=metaBook.getTitle(target,true);
        if (title.length<40) return title;
        /* title.slice(0,40)+"\u22ef "; */
        else return title;}
    
    function makeTOCHead(target,head){
        if (!(head)) head=metaBook.getHead(target);
        var basespan=fdjtDOM("span");
        basespan.title='this location in the structure of the book';
        var info=metaBook.docinfo[target.id];
        if (head) {
            var text=sumText(head);
            var headtext=
                fdjtDOM("span.headtext.tocref",
                        fdjtDOM("span.spacer","\u00A7"),
                        text);
            headtext.setAttribute("data-tocref",head.id);
            var curspan=fdjtDOM("span.head",headtext);
            headtext.title='jump to the section: '+text;
            fdjtDOM.append(basespan," ",curspan);
            var heads=metaBook.Info(head).heads;
            if (heads) {
                var j=heads.length-1; while (j>0) {
                    var hinfo=heads[j--]; var elt=mbID(hinfo.frag);
                    if ((!(elt))||(!(hinfo.title))||
                        (elt===metaBook.docroot)||(elt===document.body))
                        continue;
                    var anchor=
                        fdjtDOM("span.tocref.headtext",
                                fdjtDOM("span.spacer","\u00A7"),
                                hinfo.title);
                    anchor.setAttribute("data-tocref",hinfo.frag);
                    var newspan=fdjtDOM("span.head"," ",anchor);
                    newspan.setAttribute("data-href",hinfo.frag);
                    anchor.title=
                        ((hinfo.title)?('jump to the section: '+hinfo.title):
                         "(jump to this section)");
                    if (target===head) fdjtDOM(curspan,newspan);
                    else fdjtDOM(curspan," \u22ef ",newspan);
                    curspan=newspan;}}}
        var tochead=fdjtDOM("div.tochead",
                            makelocrule(info,false),
                            basespan);
        tochead.title=makelocstring(info,false);
        return tochead;}

    /* Selecting a subset of glosses to display */

    var hasClass=fdjtDOM.hasClass;

    function selectSources(slice,sources){
        var sourcerefs=[], sourcedb=metaBook.sourcedb;
        if ((!(sources))||(sources.length===0)) {
            slice.filter(false); return;}
        var i=0; var lim=sources.length; while (i<lim) {
            var source=sourcedb.ref(sources[i++]);
            if (source) sourcerefs.push(source);}
        slice.filter(function(card){
            var gloss=card.gloss;
            return ((gloss)&&
                    ((RefDB.contains(sourcerefs,gloss.maker))||
                     (RefDB.overlaps(sourcerefs,gloss.sources))||
                     (RefDB.overlaps(sourcerefs,gloss.shared))));});}
    metaBook.UI.selectSources=selectSources;

    /* Results handlers */

    var named_slices={};

    function MetaBookSlice(container,cards,sortfn,opts){
        if (!(opts)) opts={};
        if (typeof container === "undefined") return false;
        else if (!(this instanceof MetaBookSlice))
            return new MetaBookSlice(container,cards,sortfn,opts);
        else if (!(container)) 
            container=fdjtDOM("div.metabookslice");
        else if (typeof container === "string") {
            if (named_slices.hasOwnProperty(container))
                return named_slices[container];
            else if (document.getElementById(container)) 
                container=document.getElementById(container);
            else return false;}
        else if ((container.nodeType)&&
                 (container.nodeType===1)&&
                 (container.id)) {
            if (named_slices.hasOwnProperty(container.id))
                return named_slices[container.id];
            else named_slices[container.id]=container;}
        else if ((container.nodeType)&&(container.nodeType===1))  {}
        else return false;
        if (!(opts.hasOwnProperty('initlayout')))
            opts.initLayout=false;
        if (!(opts.hasOwnProperty('noslip')))
            opts.noslip=false;
        if (!(opts.hasOwnProperty('id')))
            opts.id=container.id;
        if (!(opts.hasOwnProperty('holdmsecs')))
            opts.holdmsecs=400;
        if (opts.hasOwnProperty('holdclass'))
            opts.holdclass=false;
        if (opts.hasOwnProperty('touchtoo'))
            opts.touchtoo=function(evt){
                evt=evt||window.event;
                if (metaBook.previewing)
                    metaBook.stopPreview("touchtoo",true);
                this.abort(evt,"touchtoo");};
        if (container.id)
            metaBook.TapHold[container.id]=new fdjtUI.TapHold(
                container,opts);
        else fdjtUI.TapHold(container,opts);
        metaBook.UI.addHandlers(container,'summary');
        this.container=container; this.cards=[];
        if (sortfn) this.sortfn=sortfn;
        this.byid=new fdjt.RefMap();
        this.byfrag=new fdjt.RefMap();
        this.live=false; this.needupdate=false;
        this.addCards(cards);
        if (metaBook.touch) opts.packthresh=40;
        if ((cards)&&(cards.length)) this.update();
        return this;}

    MetaBookSlice.prototype.setLive=function setSliceLive(flag){
        if (flag) {
            if (this.live) return false;
            else {
                if (this.needupdate) this.update();
                this.live=true;
                return true;}}
        else if (this.live) {
            this.live=false;
            return true;}
        else return false;};

    MetaBookSlice.prototype.renderCard=function renderCardForSlice(about){
        return renderCard(about);};

    MetaBookSlice.prototype.sortfn=function defaultSliceSortFn(x,y){
        if (x.hasOwnProperty('location')) {
            if (y.hasOwnProperty("location")) {
                if (x.location===y.location) {
                    if (x.timestamp) {
                        if (y.timestamp)
                            return x.timestamp-y.timestamp;
                        else return -1;}
                    else return 1;}
                else return x.location-y.location;}
            else return -1;}
        else return 1;};

    MetaBookSlice.prototype.getCard=function getCard(ref){
        if ((ref.nodeType===1)&&
            ((hasClass(ref,"metabookcard"))||
             (hasClass(ref,"mbtoc")))) {
            var id=ref.getAttribute("data-gloss")||
                ref.getAttribute("data-passage");
            return this.byid.get(id);}
        else if (ref.nodeType===1) {
            if (!(ref.id)) ref=getFirstID(ref);
            if (ref) return this.byid.get(ref.id)||
                this.byfrag.get(ref.id);}
        else return ((ref._qid)&&(this.byid.get(ref._qid)))||
            ((ref._id)&&(this.byid.get(ref._id)));};
    function getFirstID(node){
        if (node.id) return node;
        else if (node.childNodes) {
            var children=node.childNodes;
            var i=0; var lim=children.length; while (i<lim) {
                if (children[i].nodeType===1) {
                    var found=getFirstID(children[i++]);
                    if (found) return found;}
                else i++;}}
        return false;}

    MetaBookSlice.prototype.update=function updateSlice(){
        if (metaBook.Trace.slices)
            fdjtLog("Updating slice %o over %o",
                    this,this.container);
        var cards=this.cards, visible=[], shown=[];
        var byfrag=this.byfrag;
        var container=this.container;
        cards.sort(this.sortfn);
        dropClass($(".slicenewpassage",container),"slicenewpassage");
        dropClass($(".slicenewhead",container),"slicenewhead");
        this.container.innerHTML="";
        var head=false, passage=false;
        var frag=document.createDocumentFragment()||this.container;
        var i=0, lim=cards.length; while (i<lim) {
            var card=cards[i++];
            if (card.hidden) continue;
            else if (card.passage!==passage) {
                passage=card.passage;
                byfrag[passage]=card;
                addClass(card.dom,"slicenewpassage");}
            if (card.head!==head) {
                head=card.head;
                addClass(card.dom,"slicenewhead");}
            frag.appendChild(card.dom);
            visible.push(card);
            shown.push(card.dom);}
        if (frag!==this.container) this.container.appendChild(frag);
        showPage.update(container);
        this.visible=visible;
        this.shown=shown;
        this.needupdate=false;};

    MetaBookSlice.prototype.refresh=function refreshSlice(force){
        var slice=this;
        if ((!(this.needupdate))&&(!(force))) return;
        if (this.refresh_timer) {
            clearTimeout(this.refresh_timer);
            this.refresh_timer=false;}
        this.refresh_timer=setTimeout(
            function(){slice_update(slice);},
            2000);};
    function slice_update(slice){
        slice.refresh_timer=false;
        slice.needupdate=false;
        slice.update(); if (slice.needupdate)
            slice.refresh();}

    MetaBookSlice.prototype.filter=function filterSlice(fn){
        var cards=this.cards; var i=0, n=cards.length;
        if (metaBook.Trace.slices) {
            if (fn) fdjtLog("Filtering slice %o by %o",this.container,fn);
            else fdjtLog("Restoring filtered slice %o",this.container);}
        if (!(fn)) while (i<n) delete cards[i++].hidden;
        else while (i<n) {
            var card=cards[i++];
            if (fn(card)) card.hidden=false;
            else card.hidden=true;}
        this.filterfn=fn;
        this.needupdate=true;
        this.update();};

    MetaBookSlice.prototype.addCards=function addCards(adds){
        if (!(adds)) return;
        if (!(adds instanceof Array)) adds=[adds];
        if (adds.length===0) return;
        if (metaBook.Trace.slices) 
            fdjtLog("Adding %d cards to slice %o",
                    adds.length,this.container);
        var byid=this.byid, cards=this.cards;
        var i=0, lim=adds.length;
        while (i<lim) {
            var add=adds[i++], info=false, card, id, about=false, replace=false;
            if ((add.about)&&(add.dom)) {
                info=add; card=add.dom;}
            if ((add.nodeType)&&(add.nodeType===1)&&
                     (hasClass(add,"metabookcard"))) {
                card=add; id=add.name||add.getAttribute("name");
                if (!(id)) continue;
                if ((info=byid[id])) {
                    if (info.dom!==add) replace=byid[id].dom;
                    card=add; info.dom=add;}
                else card=add;}
            else if (add instanceof Ref) {
                id=add._qid||add.getQID(); about=add;
                if (byid[id]) {info=byid[id]; card=info.dom;}
                else card=this.renderCard(add);}
            else {}
            if (!(card)) continue;
            if (!(about)) about=RefDB.resolve(id);
            if (!(info)) 
                byid[id]=info={added: fdjtTime(),id: id,about: about};
            info.dom=card;
            if (card.getAttribute("data-location"))
                info.location=parseInt(card.getAttribute("data-location"),10);
            if (card.getAttribute("data-gloss"))
                info.gloss=metaBook.glossdb.refs[card.getAttribute("data-gloss")];
            if (card.getAttribute("data-searchscore"))
                info.score=parseInt(card.getAttribute("data-searchscore"),10);
            if (card.getAttribute("data-timestamp"))
                info.timestamp=parseInt(card.getAttribute("data-timestamp"),10);
            if (card.getAttribute("data-passage")) 
                info.passage=card.getAttribute("data-passage");
            if (card.getAttribute("data-tochead"))
                info.head=card.getAttribute("data-tochead");
            if (this.filterfn) {
                var fn=this.filterfn;
                if (fn(info))
                    info.hidden=false;
                else info.hidden=true;}
            if (replace) this.container.replaceChild(card,replace);
            else cards.push(info);}
        this.needupdate=true;
        if (this.live) this.refresh();};

    /* Slice handlers */

    MetaBookSlice.prototype.setSkim=function setSkim(card){
        var visible=this.visible, shown=this.shown;
        var off=((card.nodeType)?(shown.indexOf(card)):(visible.indexOf(card)));
        if (off<0) return; else {
            card=shown[off];
            if (this.skimpoint) dropClass(this.skimpoint,"skimpoint");
            this.skimpoint=card; this.skimpos=off;
            this.atStart=(off===0);
            this.atEnd=(off>=(visible.length-1));
            addClass(card,"skimpoint");
            return card;}};
    MetaBookSlice.prototype.forward=
        function skimForward(card){
            var shown=this.shown;
            if (!(card)) card=this.skimpoint||shown[0];
            var off=shown.indexOf(card);
            if ((off<0)||(off+1>=this.visible.length))
                return; 
            else return this.setSkim(shown[off+1]);};
    MetaBookSlice.prototype.backward=
        function skimBackward(card){
            var shown=this.shown;
            if (!(card)) card=this.skimpoint||shown[shown.length-1];
            var off=shown.indexOf(card);
            if (off<=0) return; 
            else return this.setSkim(shown[off-1]);};
    MetaBookSlice.prototype.getInfo=function getSliceInfo(card){
        if (typeof card === "string") {
            var found=this.byid.get(card)||this.byfrag.get(card);
            if ((Array.isArray(found))&&(found.length))
                card=found[0];
            else card=found;}
        var pos; if (!(card)) pos=this.skimpos;
        else if ((pos=this.shown.indexOf(card))<0)
            pos=this.visible.indexOf(card);
        if (pos>=0) return this.visible[pos];
        else return false;};

    MetaBookSlice.prototype.setLocation=function setSliceLocation(location){
        var visible=this.visible; var i=0, lim=visible.length;
        while (i<lim) {
            var card=visible[i];
            if (typeof card.location !== "number") {i++; continue;}
            else if (card.location>=location) {
                this.setSkim(card);
                return;}
            else {i++; continue;}}};

    function getCard(target){
        if ((hasClass(target,"metabookcard"))||(hasClass(target,"mbtoc")))
            return target;
        else return getParent(target,".metabookcard,.mbtoc")||
            getChild(target,".metabookcard,.mbtoc");}

    function slice_tapped(evt){
        var target=fdjtUI.T(evt);
        if (Trace.gestures)
            fdjtLog("slice_tapped %o: %o",evt,target);
        if (metaBook.previewing) {
            // Because we're previewing, this slice is invisible, so
            //  the user really meant to tap on the body underneath,
            //  so we stop previewing and jump there We might try to
            //  figure out exactly which element was tapped somehow
            metaBook.stopPreview("slice_tapped",true);
            fdjtUI.cancel(evt);
            return;}
        if ((getParent(target,".ellipsis"))&&
            ((getParent(target,".elision"))||
             (getParent(target,".delision")))) {
            fdjtUI.Ellipsis.toggle(target);
            fdjtUI.cancel(evt);
            return;}
        if (getParent(target,".tochead")) {
            var anchor=getParent(target,".tocref");
            var href=(anchor)&&(anchor.getAttribute("data-tocref"));
            metaBook.SkimTo(href);
            fdjtUI.cancel(evt);
            return;}

        if (getParent(target,".mbmedia")) {
            var link=getParent(target,".mbmedia");
            var src=link.getAttribute("data-src"), cancel=false;
            var type=link.getAttribute("data-type");
            if (hasClass(link,"imagelink")) {
                metaBook.showMedia(src,type); cancel=true;}
            else if ((hasClass(link,"audiolink"))||
                     (hasClass(link,"musiclink"))) {
                metaBook.showMedia(src,type); cancel=true;}
            else {}
            if (cancel) {
                fdjtUI.cancel(evt);
                return;}}
        var card=getCard(target);
        var passage=mbID(card.getAttribute("data-passage"));
        var glossid=card.getAttribute("data-gloss");
        var gloss=((glossid)&&(metaBook.glossdb.ref(glossid)));
        if (!(passage)) return;
        else if ((!(gloss))&&(passage)) {
            metaBook.SkimTo(card,0);
            return fdjtUI.cancel(evt);}
        else if (getParent(target,".tool")) {
            var form=metaBook.setGlossTarget(gloss);           
            if (!(form)) return;
            metaBook.setMode("addgloss");
            return fdjtUI.cancel(evt);}
        else if (mB.mode==="openglossmark") {
            mB.clearGlossmark();
            goToGloss(card); 
            return fdjtUI.cancel(evt);}
        else if (getParent(target,".glossbody"))  {
            var detail=((gloss)&&(gloss.detail));
            if (!(detail)) return;
            else if (detail[0]==='<')
                $ID("METABOOKGLOSSDETAIL").innerHTML=gloss.detail;
            else if (detail.search(/^{(md|markdown)}/)===0) {
                var close=detail.indexOf('}');
                $ID("METABOOKGLOSSDETAIL").innerHTML=
                    metaBook.md2HTML(detail.slice(close+1));}
            else $ID("METABOOKGLOSSDETAIL").innerHTML=
                metaBook.md2HTML(detail);
            metaBook.setMode("glossdetail");
            return fdjtUI.cancel(evt);}
        else {
            metaBook.SkimTo(card,0);
            return fdjtUI.cancel(evt);}}
    function slice_held(evt){
        evt=evt||window.event;
        var slice_target=fdjtUI.T(evt), card=getCard(slice_target);
        if (Trace.gestures)
            fdjtLog("slice_held %o: %o, skimming=%o",
                    evt,card,metaBook.skimpoint);
        if (!(card)) return;
        /* Handle openglossmarks */
        if ((card.getAttribute("data-gloss"))&&
            (mB.mode==="openglossmark")) {
            goToGloss(card); return fdjtUI.cancel(evt);}
        // Put a clone of the card in the skimmer
        var clone=card.cloneNode(true);
        clone.id="METABOOKSKIM"; fdjtDOM.replace("METABOOKSKIM",clone);
        // If we're currently previewing something, clear it
        if (metaBook.previewTarget) {
            var drop=metaBook.getDups(metaBook.previewTarget);
            dropClass(drop,"mbpreviewing");
            metaBook.clearHighlights(drop);
            metaBook.previewTarget=false;}

        // Get the attributes of this card
        var passageid=card.getAttribute("data-passage");
        var glossid=card.getAttribute("data-gloss");
        var gloss=((glossid)&&metaBook.glossdb.ref(glossid));
        var passage=mbID(passageid), show_target=false;
        var dups=metaBook.getDups(passageid);
        // Set up for preview
        metaBook.previewTarget=passage; addClass(dups,"mbpreviewing");
        if ((gloss)&&(gloss.excerpt)) {
            // Highlight the gloss excerpt
            var range=metaBook.findExcerpt(dups,gloss.excerpt,gloss.exoff);
            if (range) {
                var starts=range.startContainer;
                if (!(getParent(starts,passage)))
                    // This is the case where the glosses excerpt
                    //  starts in a 'dup' generated by page layout
                    show_target=getTargetDup(starts,passage);
                fdjtUI.Highlight(range,"mbhighlightexcerpt");}}

        if (getParent(card,".sbookresults")) {
            // It's a search result, so highlight any matching terms
            var terms=metaBook.query.tags;
            var info=metaBook.docinfo[passageid];
            // knodeterms match tags to their originating strings
            var spellings=info.knodeterms;
            var i=0; var lim=terms.length; while (i<lim) {
                var term=terms[i++];
                var highlights=metaBook.highlightTerm(term,passage,info,spellings);
                if (!(show_target))
                    if ((highlights)&&(highlights.length)&&
                        (!(getParent(highlights[0],passage))))
                        show_target=getTargetDup(highlights[0],passage);}}
        metaBook.startPreview(show_target||passage,"slice_held");
        return fdjtUI.cancel(evt);}
    function slice_released(evt){
        var card=getCard(fdjtUI.T(evt||window.event));
        var glossid=(card)&&(card.getAttribute("data-gloss"));
        if (Trace.gestures) {
            fdjtLog("slice_released %o: %o, skimming=%o",evt,card);}
        if (metaBook.previewing)
            metaBook.stopPreview("slice_released");
        if ((glossid)&&(mB.mode==="openglossmark")) goToGloss(card);
        fdjtUI.cancel(evt);}
    function slice_slipped(evt){
        evt=evt||window.event;
        var rel=evt.relatedTarget||fdjtUI.T(evt);
        if (!(hasParent(rel,".metabookslice"))) {
            metaBook.slipTimeout(function(){
                if (Trace.gestures)
                    fdjtLog("slice_slipped/timeout %o",evt);
                metaBook.stopPreview("slice_slipped");});}}
    function slice_touchtoo(evt){
        evt=evt||window.event;
        metaBook.previewTimeout(false);
        if (!(metaBook.previewing)) return;
        else if (Trace.gestures) {
            fdjtLog("slice_touchtoo %o noabout",evt);
            metaBook.stopPreview("toc_touchtoo",true);}
        else {
            metaBook.stopPreview("toc_touchtoo",true);}
        fdjtUI.cancel(evt);}

    function slice_swiped(evt){
        var dx=evt.deltaX, dy=evt.deltaY;
        var vw=fdjtDOM.viewWidth();
        var adx=((dx<0)?(-dx):(dx)), ady=((dy<0)?(-dy):(dy));
        var target=fdjtUI.T(evt);
        var slice=getParent(target,".metabookslice");
        if (Trace.gestures)
            fdjtLog("slice_swiped d=%o,%o, ad=%o,%o, s=%o,%o vw=%o, n=%o",
                    dx,dy,adx,ady,evt.startX,evt.startY,vw,evt.ntouches);
        if (adx>(ady*2)) {
            // Horizontal swipe
            if (dx<(-(metaBook.minswipe||10))) {
                if (metaBook.skimming)
                    metaBook.skimForward();
                else showPage.forward(slice);}
            else if (dx>(metaBook.minswipe||10)) {
                if (metaBook.skimming)
                    metaBook.skimBackward();
                else showPage.backward(slice);}}
        else if (ady>(adx*2)) {
            // Vertical swipe
            if (!(metaBook.hudup)) {
                // Ignore really short swipes 
                if (ady<=(metaBook.minswipe||10)) return;
                else if ((evt.startX<(vw/5))&&(dy<0))
                    // On the left, up, show help
                    metaBook.setMode("help");
                else if ((evt.startX<(vw/5))&&(dy>0))
                    // On the left, down, show TOC
                    metaBook.setMode("statictoc");
                else if ((evt.startX>(vw*0.8))&&(dy>0))
                    // On the right, down, show SEARCH
                    metaBook.setMode("search");
                else if ((evt.startX>(vw*0.8))&&(dy<0))
                    // On the right, up, show GLOSSES
                    metaBook.setMode("allglosses");
                else if (dy>0) {
                    metaBook.clearStateDialog();
                    metaBook.showCover();}
                else metaBook.setHUD(true);}
            else if (dy<-(metaBook.minswipe||10)) metaBook.setMode("allglosses");
            else if (dy>(metaBook.minswipe||10)) metaBook.setMode("search");}
        else {}}

    metaBook.UI.getCard=getCard;

    function goToGloss(card){
        var glossid=card.getAttribute("data-gloss");
        var glosscard=(glossid)&&(mB.allglosses.byid[glossid]);
        if (glosscard) {
            metaBook.setMode("allglosses");
            fdjt.Async(function(){
                mB.allglosses.setSkim(glosscard);});}}
    
    fdjt.DOM.defListeners(
        metaBook.UI.handlers.mouse,
        {summary: {tap: slice_tapped, hold: slice_held,
                   release: slice_released, click: generic_cancel,
                   slip: slice_slipped}});

   fdjt.DOM.defListeners(
        metaBook.UI.handlers.touch,
        {summary: {tap: slice_tapped,
                   hold: slice_held,
                   release: slice_released,
                   touchtoo: slice_touchtoo,
                   swipe: slice_swiped,
                   slip: slice_slipped}});

    return MetaBookSlice;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/clouds.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements the search component for the e-reader web
   application, and relies heavily on the Knodules module.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.
   This file assumes that the sbooks.js file has already been loaded.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

(function(){
    "use strict";
    var mB=metaBook;
    var Trace=mB.Trace;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var $ID=fdjt.ID;
    var TapHold=fdjt.TapHold;
    var RefDB=fdjt.RefDB, Ref=fdjt.Ref;
    var KNode=Knodule.KNode;

    metaBook.search_cloud=false;
    if (!(metaBook.empty_cloud)) metaBook.empty_cloud=false;
    if (!(metaBook.show_refiners)) metaBook.show_refiners=25;
    if (!(metaBook.search_gotlucky)) metaBook.search_gotlucky=7;
    
    var Completions=fdjtUI.Completions;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var getChildren=fdjtDOM.getChildren;
    var getChild=fdjtDOM.getChild;
    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var hasClass=fdjtDOM.hasClass;
    var log=fdjtLog;
    var kbref=RefDB.resolve;

    function makeCloud(tags,scores,freqs,n,completions,init_dom,roots) {
        var start=new Date();
        var sourcedb=metaBook.sourcedb;
        var knodule=metaBook.knodule;
        var dom=init_dom||false;
        var i=0; var n_terms=tags.length;
        // Move it out of the flow
        var breadcrumb=false;
        if ((dom)&&(dom.parentNode)) {
            breadcrumb=document.createTextNode("");
            dom.parentNode.replaceChild(breadcrumb,dom);}
        if (dom) addClass(dom,"completions");
        else if ((completions)&&(completions.dom))
            dom=completions.dom;
        else dom=fdjtDOM("div.completions.cloud.noinput",
                         getShowAll(usecues,n_terms));
        var maxmsg=fdjtDOM(
            "div.maxcompletemsg",
            "There are a lot ","(",fdjtDOM("span.completioncount","really"),")",
            " of completions.  ");
        var emptymsg=fdjtDOM("div.nomatchmsg","(no matches)");
        fdjtDOM.prepend(dom,emptymsg,maxmsg);
        
        if (!(completions)) completions=new Completions(dom);

        var info=organize_tags(tags,scores,knodule,sourcedb);
        var usecues=(n_terms>17)&& (// lots of terms AND
            (info.n_primes>0) || // there are prime terms OR
            (info.max!==info.min) || // scores are different OR
            // there are a small number of real concepts to use
            ((info.normals._count)<17) ||
                // there's are a lot of weak terms
                ((n_terms/info.normals._count)>4));
        if (!(usecues)) fdjtDOM.addClass(dom,"showall");
        else if (getChild(dom,".showall"))
            fdjtDOM.prepend(dom,getShowAll(usecues,n_terms));
        else {}

        // Sort the tags before adding them
        tags=[].concat(tags);
        sort_tags(tags);

        // Compute score sum to get value for the cue threshold
        var score_sum=0; while (i<n_terms) {
            var score=scores.get(tags[i++]);
            if (score) score_sum=score_sum+score;}

        i=0; while (i<n_terms) {
            var dterm=tags[i++];
            var span=cloudSpan(
                dterm,completions,scores,freqs,score_sum/n_terms);
            dom.appendChild(span);
            dom.appendChild(document.createTextNode(" "));}
        sizeCloud(completions,scores,roots);

        var end=new Date();
        if (Trace.clouds)
            fdjtLog("Made cloud for %d tags in %f seconds",
                    tags.length,(end.getTime()-start.getTime())/1000);

        // Put the cloud back into the flow (if neccessary)
        if (breadcrumb) breadcrumb.parentNode.replaceChild(dom,breadcrumb);

        completions.updated=function(){adjustCloudFont(this);};

        return completions;}
    metaBook.makeCloud=makeCloud;

    function cloudSpan(dterm,completions,scores,freqs){
        var freq=freqs.get(dterm)||1;
        var score=scores.get(dterm);
        var span=cloudEntry(dterm,completions);
        var title=span.title;
        if (freq) {
            if (title) title=title+"; count="+freq;
            else title="count="+freq;}
        if ((score)&&(score!==freq)) title=title+"; s="+score;
        span.title=title;
        if (freq===1) addClass(span,"singleton");
        else if (freq===2) addClass(span,"doubleton");
        else {}
        return span;}
    
    function initCloudEntry(tag,entry,cloud,lang){
        // This is called when the KNode is loaded
        var variations=false, suffix=false;
        if (tag instanceof KNode) {
            var knode=tag, dterm=knode.dterm, origin=false;
            if (tag._db===metaBook.knodule) origin="index";
            else if (tag._db.fullname) {
                origin=tag._db.fullname; suffix=fdjtDOM("sup","*");}
            else {
                var sourceref=metaBook.sourcedb.probe(tag._db.name);
                if (sourceref) {
                    origin=tag._db.fullname=sourceref.name;
                    suffix=fdjtDOM("sup","*");}
                else {
                    origin="glosses";
                    suffix=fdjtDOM("sup","*");}}
            entry.setAttribute("data-key",dterm);
            if (typeof suffix === "string")
                entry.innerHTML=dterm+suffix;
            else if (suffix) {
                entry.innerHTML=dterm;
                entry.appendChild(suffix);}
            else entry.innerHTML=dterm;
            var synonyms=knode[lang];
            if ((synonyms)&&(typeof synonyms === 'string'))
                synonyms=[synonyms];
            if (synonyms) {
                var i=0; while (i<synonyms.length) {
                    var synonym=synonyms[i++];
                    if (synonym===dterm) continue;
                    var variation=fdjtDOM("span.variation",synonym,"=");
                    variation.setAttribute("data-key",synonym);
                    if (!(variations)) variations=fdjtDOM("span.variations");
                    variations.appendChild(variation);}}
            if (knode.prime) {
                addClass(entry,"prime");
                addClass(entry,"cue");}
            else if (knode.weak) addClass(entry,"weak");
            else {}
            var noun=((dterm.search(/\.\.\.$/)>0)?("root form"):("concept"));
            var title=
                ((knode.prime)?("key "):
                 (knode.weak)?("weak "):(""))+
                ((origin==="index")?("index "+noun+" "):
                 (noun+" (from "+origin+") "));
            if (knode.about)
                title=title+knode.dterm+": "+knode.about;
            else {
                var def=knode.toPlaintext();
                if ((def)&&(def!==knode.dterm))
                    title=title+knode.dterm+"="+knode.toPlaintext();
                else title=title+"'"+knode.dterm+"'";}
            entry.title=title;}
        else if (tag.name) {
            addClass(entry,"source"); addClass(entry,"account");
            entry.setAttribute("data-key",tag.name);
            entry.innerHTML=tag.name;}
        else if (tag.refuri) {
            addClass(entry,"doc");
            entry.setAttribute("data-key",tag.refuri);
            if ((cloud)&&(entry.title))
                cloud.addKeys(entry,entry.title);
            entry.innerHTML=tag.refuri;}
        else {}
        if (variations) fdjtDOM.prepend(entry,variations);
        if (cloud) cloud.addKeys(entry);}
    function initCloudEntries(tag){
        var droplets=tag.droplets;
        if (droplets) {
            var i=0, lim=droplets.length; 
            while (i<lim) {
                var droplet=droplets[i++];
                initCloudEntry(tag,droplet.entry,droplet.cloud,droplet.lang);}
            delete tag.droplets;}}

    function cloudEntry(tag,cloud,lang,usespec){
        var entry;
        if (!(usespec)) usespec="span.completion";
        if (typeof lang !== "string")
            lang=(metaBook.language)||(Knodule.language)||"EN";
        var existing=(cloud)&&(cloud.getByValue(tag,".completion"));
        if ((existing)&&(existing.length)) return existing[0];
        else if (typeof tag === "string") {
            var isrootform=tag.search(/\.\.\.$/)>0;
            var spec=usespec+
                ((isrootform)?(".rootform"):(".rawterm"))+
                ((tag.length>20)?(".longterm"):(""));
            entry=fdjtDOM(spec,fdjtDOM("span.text","\u201c"+tag+"\u201d"));
            entry.setAttribute("data-key",tag);
            entry.setAttribute("data-value",tag);
            if (isrootform)
                entry.title="forms "+tag;
            else entry.title=tag;
            if (cloud) cloud.addCompletion(entry,tag,tag);
            return entry;}
        else if (!(tag instanceof Ref)) {
            var strungout=entry.toString();
            entry=fdjtDOM(((strungout.length>20)?
                           (usespec+".weirdterm.longterm"):
                           (usespec+".weirdterm")),
                          "?"+strungout+"\u00bf");
            entry.title=strungout;
            if (cloud) cloud.addCompletion(entry,strungout,tag);
            return entry;}
        else {
            var qid=tag._qid||tag.getQID(), id=tag._id||tag.dterm;
            // Section names as tags
            if (tag._db===metaBook.docdb) {
                var sectname=tag.title, showname;
                if (sectname.length>40)
                    showname=fdjtDOM(
                        "span.name.ellipsis",sectname.slice(0,17),
                        fdjtDOM("span.elision","\u2026"),
                        fdjtDOM("span.elided",
                                sectname.slice(sectname.length-17)));
                else if (sectname.length>25)
                    showname=fdjtDOM("span.name.longname",sectname);
                else showname=fdjtDOM("span.name",sectname);
                showname=fdjtDOM("span.name",sectname);
                entry=fdjtDOM(usespec+".sectname","\u00A7",showname);
                entry.setAttribute("data-key",sectname);
                entry.setAttribute("data-value",tag._qid||tag.getQID());
                if (sectname.length>24) addClass(entry,"longterm");
                if (sectname.length>20) entry.title=sectname;
                if (cloud) cloud.addCompletion(entry,sectname,tag);
                return entry;}
            else if (tag instanceof KNode) 
                entry=fdjtDOM(((id.length>20)?
                               (usespec+".dterm.longterm"):
                               (usespec+".dterm")),
                              qid);
            else entry=fdjtDOM(((id.length>20)?
                                (usespec+".longterm"):
                                (usespec)),
                               qid);
            if (tag.cssclass) addClass(entry,tag.cssclass);
            entry.setAttribute("data-value",qid);
            if (cloud) cloud.addCompletion(entry,false,tag);
            if (tag._live) {
                initCloudEntry(tag,entry,cloud,lang);
                return entry;}
            else if (tag.droplets)
                tag.droplets.push({entry: entry,lang: lang,cloud: cloud});
            else {
                tag.droplets=[{entry: entry,lang: lang,cloud: cloud}];
                tag.onLoad(initCloudEntries);
                return entry;}}}
    metaBook.cloudEntry=cloudEntry;
    
    function addTag2Cloud(tag,cloud,kb,scores,freqs,thresh){
        if (!(kb)) kb=metaBook.knodule;
        if (!(tag)) return;
        else if (tag instanceof Array) {
            var i=0; var lim=tag.length;
            while (i<lim) addTag2Cloud(tag[i++],cloud,kb,scores,freqs,thresh);
            return;}
        else {
            var container=cloud.dom;
            var tagref=(((typeof tag === 'string')&&(kb))?
                        ((RefDB.resolve(tag,kb,Knodule,false))||(tag)):
                        (tag));
            var entry=((scores)?
                       (cloudSpan(tagref,cloud,scores,freqs,thresh)):
                       (cloudEntry(tagref,cloud)));
            if (!(hasParent(entry,container))) fdjtDOM(container,entry," ");
            return entry;}}
    metaBook.addTag2Cloud=addTag2Cloud;

    function getShowAll(use_cues,how_many){
        var showall=(use_cues)&&
            fdjtDOM(
                "span.showall",
                fdjtDOM("span.showmore","more"), 
                // ((how_many)&&(" ("+how_many+")"))
                fdjtDOM("span.showless","fewer"));
        if ((how_many)&&(showall))
            showall.title="There are "+how_many+" in all";
        if (showall) showall.onclick=showall_ontap;
        return showall;}
    metaBook.UI.getShowAll=getShowAll;

    function organize_tags(tags,scores,knodule,sourcedb){
        var min_score=false, max_score=false;
        var normals={}, n_normal=0, n_primes=0;
        var i=0; while (i<tags.length) {
            var tag=tags[i++];
            if (tag instanceof Ref) {
                if (tag.prime) n_primes++;
                if ((tag._db!==sourcedb)&&(!(tag.weak))) {
                    normals[tag]=true; n_normal++;}}
            if (scores) {
                var score=scores.get(tag);
                if (score) {
                    if (min_score===false) min_score=score;
                    else if (score<min_score) min_score=score;
                    if (score>max_score) max_score=score;}}}
        normals._count=n_normal;
        return {normals: normals, n_primes: n_primes,
                min: min_score, max: max_score};}

    function showall_ontap(evt){
        var target=fdjtUI.T(evt);
        var completions=getParent(target,".completions");
        if (completions) {
            fdjtUI.cancel(evt);
            fdjtDOM.toggleClass(completions,"showall");}}

    /* Getting query cloud */

    function queryCloud(query){
        if (query.cloud) return query.cloud;
        else if ((query.tags.length)===0) {
            query.cloud=metaBook.empty_cloud;
            return query.cloud;}
        else {
            var showtags=query.getRefiners();
            var completions=makeCloud(
                showtags,query.tagscores,query.tagfreqs,
                showtags.length,false,false,query.tags);
            var cloud=completions.dom;
            if (!(completions.taphold))
                completions.taphold=new TapHold(cloud);
            addClass(cloud,"searchcloud");
            metaBook.setupGestures(cloud);
            var n_refiners=showtags.length;
            var hide_some=(n_refiners>metaBook.show_refiners);
            if (hide_some) {
                var ranked=[].concat(showtags);
                var scores=query.tagscores;
                ranked.sort(function(x,y){
                    if (((typeof x === "string")&&(typeof y === "string"))||
                        ((x instanceof Ref)&&(y instanceof Ref))) {
                        var xs=scores.get(x), ys=scores.get(y);
                        if ((typeof xs === "number")&&
                            (typeof ys === "number")) 
                            return ys-xs;
                        else if (typeof xs === "number")
                            return -1;
                        else return 1;}
                    else if (typeof x === "string")
                        return 1;
                    else return -1;});
                var i=0, lim=metaBook.show_refiners;
                while (i<lim) {
                    var tag=ranked[i++], elt=completions.getByValue(tag);
                    addClass(elt,"cue");}}
            else addClass(cloud,"showall");
            query.cloud=completions;
            return query.cloud;}}
    metaBook.queryCloud=queryCloud;
    RefDB.Query.prototype.getCloud=function(){
        return queryCloud(this);};
    
    function tag_sorter(x,y,scores){
        // Knodes go before Refs go before strings
        // Otherwise, use scores
        if (x instanceof KNode) {
            if (y instanceof KNode) {} // Fall through
            else return -1;}
        else if (y instanceof KNode) return 1;
        else if (x instanceof Ref) { 
            if (y instanceof Ref) {} // Fall through
            else return -1;}
        else if (y instanceof Ref) return 1;
        else if ((typeof x === "string")&&
                 (typeof y === "string"))
        {}
        // We should never reach these cases because tags should
        //  always be strings, Refs, or KNodes.
        else if  (typeof x === typeof y) {
            if (x<y) return -1;
            else if (x>y) return 1;
            else return 0;}
        else {
            var xt=typeof x, yt=typeof y;
            if (xt<yt) return -1;
            else if (xt>yt) return 1;
            else return 0;}
        var xv=scores.get(x), yv=scores.get(y);
        if (typeof xv === "undefined") {
            if (typeof yv === "undefined") {
                var xid, yid;
                if (typeof x === "string") {
                    xid=x; yid=y;}
                else {
                    xid=x._qid||x.getQID();
                    yid=y._qid||y.getQID();}
                if (xid<yid) return -1;
                else if (yid>xid) return 1;
                else return 0;}
            else return 1;}
        else if (typeof yv === "undefined") return -1;
        else if (xv===yv) {
            if (x<y) return -1;
            else if (x>y) return 1;
            else return 0;}
        else if (xv>yv) return -1;
        else return 1;}
    metaBook.tag_sorter=tag_sorter;
    function sort_tags(tags){
        // Sort alphabetically, sort of
        tags.sort(function(x,y){
            var sx=x, sy=y;
            // Knodes go before Refs go before strings
            // Otherwise, use scores
            if (x instanceof KNode) {
                if (y instanceof KNode) {
                    sx=x.dterm; sy=y.dterm;}
                else return -1;}
            else if (y instanceof KNode) return 1;
            else if (x instanceof Ref) { 
                if (y instanceof Ref) {
                    sx=x._qid||x.getQID(); sy=y._qid||y.getQID();}
                else return -1;}
            else if (y instanceof Ref) return 1;
            else if ((typeof x === "string")&&
                     (typeof y === "string")) {}
            else if (typeof x === "string") return -1;
            else if (typeof y === "string") return 1;
            // We should never reach these cases because tags should
            //  always be strings, Refs, or KNodes.
            else if  (typeof x === typeof y) {
                if (x<y) return -1;
                else if (x>y) return 1;
                else return 0;}
            else {
                var xt=typeof x, yt=typeof y;
                if (xt<yt) return -1;
                else if (xt>yt) return 1;
                else return 0;}
            if ((sx[0]==='\u00a7')&&(sy[0]!=='\u00a7')) return 1;
            if ((sy[0]==='\u00a7')&&(sx[0]!=='\u00a7')) return -1;
            if (sx.search(/\w/)>0) sx=sx.slice(sx.search(/\w/));
            if (sy.search(/\w/)>0) sy=sy.slice(sy.search(/\w/));
            if (sx<sy) return -1;
            else if (sx>sy) return 1;
            else return 0;});}
    metaBook.sortTags=sort_tags;
    
    function sortCloud(cloud){
        var values=[].concat(cloud.values);
        sort_tags(values);
        var byvalue=cloud.byvalue;
        var holder=document.createDocumentFragment();
        var i=0, lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completion=byvalue.get(value);
            if (completion) {
                if (i>1) holder.appendChild(document.createTextNode(" "));
                holder.appendChild(completion);}}
        cloud.dom.appendChild(holder);}
    metaBook.sortCloud=sortCloud;

    function sizeCloud(cloud,scores,roots){
        var gscores=metaBook.tagscores;
        var gweights=metaBook.tagweights;
        var values=cloud.values, byvalue=cloud.byvalue;
        var compscores=new Array(values.length);
        var matchscores=new Array(values.length);
        var i=0, lim=values.length;
        var min_vscore=Infinity, max_vscore=-1;
        var min_score=Infinity, max_score=-1;
        if (Trace.clouds)
            fdjtLog("Sizing %d tags in cloud %o with roots %o",
                    values.length,cloud.dom,roots);
        while (i<lim) {
            var value=values[i], score, matchscore=false;
            if ((roots)&&(roots.length)&&(roots.indexOf(value)>=0)) {
                matchscores[i]=compscores[i]=false; i++; continue;}
            if (scores) {
                matchscore=scores.get(value);
                var gscore=gscores.get(value);
                if (gscore) {
                    var gweight=gweights.get(value)||1;
                    score=(matchscore/gscore)*(gweight);}
                else score=false;}
            else score=gscores.get(value);
            if ((typeof score === "number")&&(!(isNaN(score)))) {
                compscores[i]=score;
                if (score<min_vscore) min_vscore=score;
                if (score>max_vscore) max_vscore=score;}
            else compscores[i]=false;
            if ((typeof matchscore === "number")&&(!(isNaN(matchscore)))) {
                matchscores[i]=matchscore;
                if (matchscore<min_score) min_score=matchscore;
                if (matchscore>max_score) max_score=matchscore;}
            else matchscores[i]=false;
            i++;}
        if (Trace.clouds)
            fdjtLog("Sizing %d tags in %o with scores in [%o,%o]",
                    values.length,cloud.dom,min_vscore,max_vscore);
        cloud.dom.style.display='none';
        i=0; while (i<lim) {
            var v=values[i], s=compscores[i], ms=matchscores[i];
            var elt=byvalue.get(v);
            if (v.prime) {
                addClass(elt,"prime"); addClass(elt,"cue");}
            if ((roots)&&(roots.length)&&(roots.indexOf(v)>=0)) 
                addClass(elt,"cloudroot");
            if (!((s)||(ms))) {
                addClass(elt,"unscored");
                elt.style.fontSize=""; i++;
                continue;}
            var factor=((s)?((s-min_vscore)/(max_vscore-min_vscore)):
                        ((ms-min_score)/(max_score-min_score)));
            var fsize=50+(150*factor);
            if (fsize<200)
                elt.style.fontSize=Math.round(fsize)+"%";
            else elt.style.fontSize="200%";
            i++;}
        if (Trace.clouds)
            fdjtLog("Finished computing sizes for %o using scores [%o,%o]",
                    cloud.dom,min_vscore,max_vscore);
        cloud.dom.style.display='';
        dropClass(cloud.dom,"working");
        if (Trace.clouds)
            fdjtLog("Rendered new cloud %o using scores [%o,%o]",
                    cloud.dom,min_vscore,max_vscore);
        if (cloud.dom.parentNode) setTimeout(function(){
            adjustCloudFont(cloud);},50);
        if (Trace.clouds)
            fdjtLog("Finished sizing tags in %o using scores [%o,%o]",
                    cloud.dom,min_vscore,max_vscore);}
    metaBook.sizeCloud=sizeCloud;

    function searchcloud_select(evt){
        evt=evt||window.event;
        var target=fdjtDOM.T(evt);
        var completion=getParent(target,".completion");
        if (hasClass(completion,"cloudroot")) {
            if (Trace.gestures)
                log("cloud tap on cloudroot %o",completion);
            return;}
        if (Trace.gestures) log("cloud tap on %o",completion);
        var completions=getParent(target,".completions");
        if (completion) {
            var cinfo=metaBook.query.cloud||metaBook.query.getCloud();
            var value=cinfo.getValue(completion);
            if (typeof value !== 'string') add_searchtag(value);
            else  if (value.length===0) {}
            else if (value.indexOf('@')>=0)
                add_searchtag(kbref(value));
            else if ((metaBook.knodule)&&(metaBook.knodule.probe(value)))
                add_searchtag(metaBook.knodule.probe(value));
            else add_searchtag(value);
            fdjtUI.cancel(evt);}
        else if (fdjtDOM.inherits(target,".resultcounts")) {
            metaBook.showSearchResults(metaBook.query);
            metaBook.setMode("searchresults");
            $ID("METABOOKSEARCHINPUT").blur();
            $ID("METABOOKSEARCHRESULTS").focus();
            fdjtUI.cancel(evt);}
        else if (fdjtDOM.inherits(target,".refinercounts")) {
            fdjtDOM.toggleClass(completions,"showall");
            fdjtDOM.cancel(evt);}
        else if (fdjtDOM.inherits(target,".maxcompletemsg")) {
            if (!(metaBook.touch)) 
                $ID("METABOOKSEARCHINPUT").focus();
            fdjtDOM.toggleClass(completions,"showall");
            fdjtDOM.cancel(evt);}
        else {}}
    metaBook.UI.handlers.searchcloud_select=searchcloud_select;

    function add_searchtag(value){
        metaBook.setQuery(metaBook.extendQuery(metaBook.query,value));}

    metaBook.UI.searchCloudToggle=function(){
        fdjtDOM.toggleClass($ID('METABOOKSEARCHCLOUD'),'showall');};

    function setCloudCues(cloud,tags){
        // Clear any current tagcues from the last gloss
        var cursoft=getChildren(cloud.dom,".cue.softcue");
        var i=0; var lim=cursoft.length;
        while (i<lim) {
            var cur=cursoft[i++];
            dropClass(cur,"cue");
            dropClass(cur,"softcue");}
        // Get the tags on this element as cues
        var newcues=cloud.getByValue(tags);
        i=0; lim=newcues.length; while (i<lim) {
            var completion=newcues[i++];
            if (!(hasClass(completion,"cue"))) {
                addClass(completion,"cue");
                addClass(completion,"softcue");}}}
    function setCloudCuesFromTarget(cloud,target){
        var tags=[];
        var targetid=((target.codexbaseid)||(target.id)||(target.frag));
        var info=metaBook.docinfo[targetid];
        var glosses=metaBook.glossdb.find('frag',targetid);
        var knodule=metaBook.knodule;
        if ((info)&&(info.tags)) tags=tags.concat(info.tags);
        if ((info)&&(info.autotags)&&(info.autotags.length)) {
            var autotags=info.autotags; var j=0; var jlim=autotags.length;
            while (j<jlim) {
                var kn=knodule.probe(autotags[j]);
                if (kn) tags.push(kn.tagString());
                j++;}}
        var i=0; var lim=glosses.length;
        while (i<lim) {
            var g=glosses[i++]; var gtags=g.tags;
            if (gtags) tags=tags.concat(gtags);}
        setCloudCues(cloud,tags);}
    metaBook.setCloudCues=setCloudCues;
    metaBook.setCloudCuesFromTarget=setCloudCuesFromTarget;

    function adjustCloudFont(cloud){
        var round=Math.round, sqrt=Math.sqrt;
        var dom=cloud.dom, parent=dom.parentNode;
        if (!(parent)) {
            dom.style.fontSize="";
            return;}
        var pct=100;
        dom.style.fontSize="";
        var ih=dom.scrollHeight, oh=parent.clientHeight;
        if (Trace.clouds)
            fdjtLog("Adjusting cloud %o: %o/%o",dom,ih,oh);
        if ((oh===0)||(ih===0)) return;
        if ((ih<oh)&&(ih>(oh*0.8))) return;
        else if (ih>(oh*2)) return;
        else {
            oh=oh*0.9;
            if (ih<oh)
                pct=(round(sqrt(oh/ih)*(pct/100)*100));
            else pct=(round((oh/ih)*(pct/100)*100));
            if (pct>200)
                dom.style.fontSize="200%";
            else dom.style.fontSize=pct+"%";
            if (Trace.clouds)
                fdjtLog("Adjusted cloud %o: %o/%o to %o%%",dom,ih,oh,pct);}}
    metaBook.adjustCloudFont=adjustCloudFont;
    Completions.prototype.adjustCloudFont=function(){
        return adjustCloudFont(this);};

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/simpletoc.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements the "dynamic table of contents" for the metaBook
   e-reader web application.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

metaBook.TOCSlice=
    (function(){
        "use strict";
        var fdjtDOM=fdjt.DOM;
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var $=fdjtDOM.$;
        
        var MetaBookSlice=metaBook.Slice;

        var mbicon=metaBook.icon;
        function navicon(kind){
            switch (kind) {
            case 'right': return mbicon("skim_right",64,64);
            case 'left': return mbicon("skim_left",64,64);
            case 'start': return mbicon("skim_left_stop",64,64);
            case 'end': return mbicon("skim_right_stop",64,64);
            default: return false;}}
        metaBook.navicon=navicon;

        function tocBar(headinfo,context){
            var title=fdjtDOM("a.sectname",headinfo.title);
            var elements=fdjtDOM("div.elements");
            var tocbar=fdjtDOM("div.mbtoc",elements,
                               fdjtDOM("div.toctext",
                                       ((context)&&(context.cloneNode(true))),
                                       title));
            var start=headinfo.starts_at, end=headinfo.ends_at, sectlen=end-start;
            if ((headinfo.sub)&&(headinfo.sub.length)) {
                var sub=headinfo.sub; var s=0, smax=sub.length;
                addClass(tocbar,"fdjtpagehead");
                while (s<smax) {
                    var subsect=sub[s++], brick=fdjtDOM("a.brick"); // ," "
                    var left=subsect.starts_at, size=subsect.ends_at-left;
                    brick.name="MBTOC4"+subsect.frag;
                    brick.style.left=(((left-start)/sectlen)*100)+"%";
                    brick.style.width=(((size)/sectlen)*100)+"%";
                    elements.appendChild(brick);}}
            else {
                var parent=headinfo.head;
                var rel_start=headinfo.starts_at-parent.starts_at;
                var outer_length=parent.ends_at-parent.starts_at;
                var inner_length=headinfo.ends_at-headinfo.starts_at;
                var showsize=fdjtDOM("a.showsize");
                showsize.style.width=((inner_length/outer_length)*100)+"%";
                showsize.style.left=((rel_start/outer_length)*100)+"%";
                elements.appendChild(showsize);}
            elements.appendChild(fdjtDOM("div.posbar"));
            tocbar.id="MBTOC4"+headinfo.frag;
            tocbar.setAttribute("name","MBTOC4"+headinfo.frag);
            tocbar.setAttribute("data-passage",headinfo.frag);
            tocbar.setAttribute("data-location",headinfo.starts_at);
            tocbar.setAttribute("data-level",headinfo.toclevel);
            addClass(tocbar,"mbtoc"+headinfo.toclevel);
            return tocbar;}

        function maketoc(slice,headinfo,context){
            var bar=((headinfo.toclevel)&&(tocBar(headinfo,context)));
            var card=((bar)&&
                      ({dom: bar,about: headinfo,id: headinfo._id,
                        head: headinfo.frag,passage: headinfo._id,
                        location: headinfo.starts_at}));
            if (card) {
                slice.addCards([card]);
                slice.container.appendChild(bar);}
            context=fdjtDOM("span.context",fdjtDOM("span.tocpath","§",headinfo.title));
            if ((headinfo.sub)&&(headinfo.sub.length)) {
                var sub=headinfo.sub;
                var s=0, slim=sub.length; while (s<slim) {
                    maketoc(slice,sub[s++],context);}}
            return slice;}

        function MetaBookTOC(rootinfo,dom){
            if (!(this instanceof MetaBookTOC))
                return new MetaBookTOC(rootinfo,dom);
            MetaBookSlice.call(this,dom);
            maketoc(this,rootinfo);
            return this;}
        MetaBookTOC.prototype=new MetaBookSlice();

        MetaBookTOC.setHead=function setHead(headinfo){
            dropClass($(".mblivetoc"),"mblivetoc");
            dropClass($(".mbcurtoc"),"mbcurtoc");
            var head=headinfo;
            while (head) {
                var refs=document.getElementsByName("MBTOC4"+head.frag);
                var j=0; var jlim=refs.length;
                while (j<jlim) {
                    var ref=refs[j++];
                    addClass(ref,"mblivetoc");
                    if (head===headinfo) addClass(ref,"mbcurtoc");}
                head=head.head;}
            var toc=metaBook.statictoc;
            if (toc) {
                var info=toc.byfrag[headinfo.frag];
                if (info) toc.setSkim(info.dom);}};
        MetaBookTOC.prototype.mode="statictoc";

        metaBook.TOC=MetaBookTOC;

        return MetaBookTOC;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/hud.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file provides initialization and some interaction for the
   metaBook HUD (Heads Up Display), an layer on the book content
   provided by the metaBook e-reader web application.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

metaBook.setMode=
    (function(){
        "use strict";
        var fdjtString=fdjt.String;
        var fdjtTime=fdjt.Time;
        var fdjtState=fdjt.State;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        var $ID=fdjt.ID;
        var TapHold=fdjtUI.TapHold;
        var mbID=metaBook.ID;
        
        var mB=metaBook;
        var Trace=mB.Trace;

        var MetaBookTOC=mB.TOCSlice;

        // Helpful dimensions
        // Whether to call displaySync on mode changes
        var display_sync=false;
        
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var hasClass=fdjtDOM.hasClass;
        var getParent=fdjtDOM.getParent;
        var hasParent=fdjtDOM.hasParent;
        var hasSuffix=fdjtString.hasSuffix;

        var fixStaticRefs=metaBook.fixStaticRefs;

        var metaBookHUD=false;

        // This will contain the interactive input console (for debugging)
        var frame=false, hud=false;
        var allglosses=false;

        function initHUD(){
            if ($ID("METABOOKHUD")) return;
            var started=fdjtTime();
            var messages=fdjtDOM("div#METABOOKSTARTUPMESSAGES.startupmessages");
            messages.innerHTML=fixStaticRefs(metaBook.HTML.messages);
            if (Trace.startup>2) fdjtLog("Initializing HUD layout");
            metaBook.HUD=metaBookHUD=hud=
                fdjtDOM("div#METABOOKHUD.metabookhud");
            hud.innerHTML=fixStaticRefs(metaBook.HTML.hud);
            hud.metabookui=true;
            fdjtDOM.append(messages);
            if ($ID("METABOOKFRAME")) frame=$ID("METABOOKFRAME");
            else {
                frame=fdjtDOM("div#METABOOKFRAME");
                fdjtDOM.prepend(document.body,frame);}
            addClass(frame,"metabookframe");
            frame.appendChild(messages); frame.appendChild(hud);
            if (metaBook.getConfig("uisize"))
                addClass(frame,"metabookuifont"+metaBook.getConfig("uisize"));
            metaBook.Frame=frame;
            // Fill in the HUD help
            var hudhelp=$ID("METABOOKHUDHELP");
            hudhelp.innerHTML=fixStaticRefs(metaBook.HTML.hudhelp);
            // Fill in the HUD help
            var helptext=$ID("METABOOKAPPHELP");
            helptext.innerHTML=fixStaticRefs(metaBook.HTML.help);
            // Setup heart
            var heart=$ID("METABOOKHEARTBODY");
            heart.innerHTML=fixStaticRefs(metaBook.HTML.heart);
            metaBook.DOM.heart=heart;
            var gloss_attach=$ID("METABOOKGLOSSATTACH");
            gloss_attach.innerHTML=fixStaticRefs(metaBook.HTML.attach);
            metaBook.DOM.heart=heart;
            // Other HUD parts
            metaBook.DOM.top=$ID("METABOOKHEAD");
            metaBook.DOM.heart=$ID("METABOOKHEARTBODY");
            metaBook.DOM.head=$ID("METABOOKTOPBAR");
            metaBook.DOM.foot=$ID("METABOOKFOOT");
            metaBook.DOM.tabs=$ID("METABOOKTABS");

            metaBook.DOM.noteshud=$ID("METABOOKNOTETEXT");
            metaBook.DOM.asidehud=$ID("METABOOKASIDE");

            // Initialize the pagebar
            metaBook.DOM.pagebar=$ID("METABOOKPAGEBAR");
            
            // Initialize search UI
            var search=$ID("METABOOKSEARCH");
            search.innerHTML=fixStaticRefs(metaBook.HTML.searchbox);
            addClass(metaBook.HUD,"emptysearch");

            // Setup addgloss prototype
            var addgloss=$ID("METABOOKADDGLOSSPROTOTYPE");
            addgloss.innerHTML=fixStaticRefs(metaBook.HTML.addgloss);

            metaBook.UI.addHandlers(hud,"hud");

            if (Trace.startup>1)
                fdjtLog("Created basic HUD in %dms",fdjtTime()-started);

            if (!(metaBook.svg)) {
                var images=fdjtDOM.getChildren(hud,"img");
                var i=0; var lim=images.length;
                if (Trace.startup) fdjtLog("Switching images to SVG");
                while (i<lim) {
                    var img=images[i++];
                    if ((img.src)&&
                        ((hasSuffix(img.src,".svg"))||
                         (hasSuffix(img.src,".svgz")))&&
                        (img.getAttribute('bmp')))
                        img.src=img.getAttribute('bmp');}}

            metaBook.hudtick=fdjtTime();

            fdjtDOM.setInputs(".metabookrefuri",metaBook.refuri);
            fdjtDOM.setInputs(".metabookdocuri",metaBook.docuri);
            fdjtDOM.setInputs(".metabooktopuri",metaBook.topuri);
            
            // Initialize gloss UI
            metaBook.DOM.allglosses=$ID("METABOOKALLGLOSSES");
            if ((Trace.startup>2)&&(metaBook.DOM.allglosses))
                fdjtLog("Setting up gloss UI %o",allglosses);

            metaBook.allglosses=allglosses=
                new metaBook.Slice(metaBook.DOM.allglosses);
            metaBook.allglosses.mode="allglosses";
            metaBook.glossdb.onAdd("maker",function(f,p,v){
                metaBook.sourcedb.ref(v).oninit
                (metaBook.UI.addGlossSource,"newsource");});
            metaBook.glossdb.onAdd("sources",function(f,p,v){
                metaBook.sourcedb.ref(v).oninit
                (metaBook.UI.addGlossSource,"newsource");});
            metaBook.glossdb.onLoad(addGloss2UI);
            
            function messageHandler(evt){
                var origin=evt.origin;
                if (Trace.messages)
                    fdjtLog("Got a message from %s with payload %o",
                            origin,evt.data);
                if (origin.search(/https:\/\/[^\/]+.(metabooks|sbooks).net/)!==0) {
                    fdjtLog.warn("Rejecting insecure message from %s",
                                 origin);
                    return;}
                if (evt.data==="sbooksapp") {
                    setMode("sbooksapp");}
                else if (evt.data==="metabooksapp") {
                    setMode("sbooksapp");}
                else if (evt.data==="loggedin") {
                    if (!(metaBook.user)) {
                        metaBook.userSetup();}}
                else if ((typeof evt.data === "string")&&
                         (evt.data.search("setuser=")===0)) {
                    if (!(metaBook.user)) {
                        metaBook.userinfo=JSON.parse(evt.data.slice(8));
                        metaBook.loginUser(metaBook.userinfo);
                        metaBook.setMode("welcome");
                        metaBook.userSetup();}}
                else if (evt.data.updateglosses) {
                    metaBook.updateInfo();}
                else if (evt.data.addlayer) {
                    metaBook.updateInfo();}
                else if ((evt.data.droplayer)||(evt.data.hidelayer)||
                         (evt.data.showlayer)) {
                    metaBook.refreshOffline();}
                else if (evt.data.userinfo) {
                    if (!(metaBook.user)) {
                        metaBook.userinfo=evt.data.userinfo;
                        metaBook.loginUser(metaBook.userinfo);
                        metaBook.setMode("welcome");
                        metaBook.userSetup();}}
                else if (evt.data)
                    fdjtDOM("METABOOKINTRO",evt.data);
                else {}}
            if (Trace.messages)
                fdjtLog("Setting up message listener");
            fdjtDOM.addListener(window,"message",messageHandler);
            
            metaBook.TapHold.foot=
                new fdjtUI.TapHold(
                    metaBook.DOM.foot,
                    {override: true,holdfast: true,
                     taptapmsecs: 0,holdmsecs: 150,
                     minswipe:0});
            metaBook.TapHold.head=
                new TapHold(metaBook.DOM.head,
                            {override: true,taptapmsecs: 0,
                             holdmsecs: 200});
            metaBook.DOM.skimmer=$ID("METABOOKSKIMMER");
            metaBook.TapHold.skimmer=
                new TapHold(metaBook.DOM.skimmer,{taptapmsecs: 300});
            
            metaBook.DOM.sources=$ID("METABOOKSOURCES");
            metaBook.TapHold.sources=
                new TapHold(metaBook.DOM.sources,{taptapmsecs: 300});

            var help=metaBook.DOM.help=$ID("METABOOKHELP");
            help.innerHTML=fixStaticRefs(metaBook.HTML.help);

            /* Setup clouds */
            var dom_gloss_cloud=$ID("METABOOKGLOSSCLOUD");
            metaBook.gloss_cloud=
                new fdjtUI.Completions(
                    dom_gloss_cloud,$ID("METABOOKADDTAGINPUT"),
                    fdjtUI.FDJT_COMPLETE_OPTIONS|
                        fdjtUI.FDJT_COMPLETE_CLOUD|
                        fdjtUI.FDJT_COMPLETE_ANYWORD);
            metaBook.TapHold.gloss_cloud=new TapHold(metaBook.gloss_cloud.dom);

            metaBook.empty_cloud=
                new fdjtUI.Completions(
                    $ID("METABOOKALLTAGS"),false,
                    fdjtUI.FDJT_COMPLETE_OPTIONS|
                        fdjtUI.FDJT_COMPLETE_CLOUD|
                        fdjtUI.FDJT_COMPLETE_ANYWORD);
            if (metaBook.adjustCloudFont)
                metaBook.empty_cloud.updated=function(){
                    metaBook.adjustCloudFont(this);};
            metaBook.DOM.empty_cloud=$ID("METABOOKALLTAGS");
            metaBook.TapHold.empty_cloud=new TapHold(metaBook.empty_cloud.dom);
            
            var dom_share_cloud=$ID("METABOOKSHARECLOUD");
            metaBook.share_cloud=
                new fdjtUI.Completions(
                    dom_share_cloud,$ID("METABOOKADDSHAREINPUT"),
                    fdjtUI.FDJT_COMPLETE_OPTIONS|
                        fdjtUI.FDJT_COMPLETE_CLOUD|
                        fdjtUI.FDJT_COMPLETE_ANYWORD);
            metaBook.DOM.share_cloud=dom_share_cloud;
            metaBook.TapHold.share_cloud=new TapHold(metaBook.share_cloud.dom);

            fdjtDOM.setupCustomInputs($ID("METABOOKHUD"));

            if (Trace.startup>1)
                fdjtLog("Initialized basic HUD in %dms",fdjtTime()-started);}
        metaBook.initHUD=initHUD;
        
        function resizeHUD(){
            fdjt.DOM.adjustFonts(metaBook.HUD);}
        metaBook.resizeHUD=resizeHUD;

        /* Various UI methods */
        function addGloss2UI(item){
            if (!(item.frag)) {
                fdjtLog.warn(
                    "Warning: skipping gloss %o with no fragment identifier",
                    item.uuid);}
            else if (mbID(item.frag)) {
                var addGlossmark=metaBook.UI.addGlossmark;
                // Assume it belongs to the user if it doesn't say
                if ((!(item.maker))&&(metaBook.user))
                    item.maker=(metaBook.user);
                allglosses.addCards(item);
                var nodes=metaBook.getDups(item.frag);
                addClass(nodes,"glossed");
                var i=0, lim=nodes.length; while (i<lim) {
                    addGlossmark(nodes[i++],item);}
                if (item.excerpt) {
                    var range=metaBook.findExcerpt(
                        nodes,item.excerpt,item.exoff);
                    if (range) {
                        fdjtUI.Highlight(
                            range,"mbexcerpt",
                            item.note,{"data-glossid":item._id});}}
                if (item.tags) {
                    var gloss_cloud=metaBook.gloss_cloud;
                    var tags=item.tags, j=0, n_tags=tags.length;
                    while (j<n_tags)
                        metaBook.cloudEntry(tags[j++],gloss_cloud);}
                if (item.tstamp>metaBook.syncstamp)
                    metaBook.syncstamp=item.tstamp;}
            else {
                fdjtLog("Gloss (add2UI) refers to nonexistent '%s': %o",item.frag,item);
                return;}}
        metaBook.addGloss2UI=addGloss2UI;

        /* Creating the HUD */
        
        function setupTOC(root_info){
            var panel=fdjtDOM("div#METABOOKSTATICTOC.metabookslice.mbtocslice.hudpanel");
            fdjtDOM.replace("METABOOKSTATICTOC",panel);
            var tocslice=new MetaBookTOC(root_info,panel);
            tocslice.update();
            metaBook.tocslice=tocslice;
            metaBook.statictoc=tocslice;
            metaBook.setupGestures(panel);
            return tocslice;}
        metaBook.setupTOC=setupTOC;

        /* HUD animation */

        function setHUD(flag,clearmode){
            if (typeof clearmode === 'undefined') clearmode=true;
            if ((Trace.gestures)||(Trace.mode))
                fdjtLog("setHUD(%s) %o mode=%o hudup=%o bc=%o hc=%o",
                        ((clearmode)?("clearmode"):("keepmode")),
                        flag,metaBook.mode,metaBook.hudup,
                        document.body.className,
                        metaBookHUD.className);
            if (flag) {
                metaBook.hudup=true;
                dropClass(document.body,"mbSKIMMING");
                metaBook.skimming=false;
                addClass(document.body,"hudup");}
            else {
                metaBook.hudup=false;
                if (metaBook.previewing)
                    metaBook.stopPreview("setHUD");
                dropClass(document.body,"mbSHRINK");
                if (clearmode) {
                    if (metaBook.popmode) {
                        var fn=metaBook.popmode;
                        metaBook.popmode=false;
                        fn();}
                    dropClass(metaBookHUD,"openheart");
                    dropClass(metaBookHUD,"openhead");
                    dropClass(metaBookHUD,"full");
                    dropClass(metaBookHUD,metaBookModes);
                    dropClass(document.body,"mbSKIMMING");
                    dropClass(document.body,"mbSKIMSTART");
                    dropClass(document.body,"mbSKIMEND");
                    metaBook.skimming=false;
                    metaBook.mode=false;}
                dropClass(document.body,"hudup");
                dropClass(document.body,"openhud");
                metaBook.focusBody();}}
        metaBook.setHUD=setHUD;

        /* Opening and closing the cover */

        function showCover(){
            if (metaBook._setup)
                fdjtState.dropLocal("mB("+mB.docid+").opened");
            setHUD(false);
            metaBook.closed=true;
            if (metaBook.covermode) {
                addClass(metaBook.cover,metaBook.covermode);
                metaBook.mode=metaBook.covermode;}
            addClass(document.body,"mbCOVER");}
        metaBook.showCover=showCover;
        function hideCover(){
            if (metaBook._setup)
                fdjtState.setLocal(
                    "mB("+mB.docid+").opened",fdjtTime());
            metaBook.closed=false;
            dropClass(document.body,"mbCOVER");
            if (metaBook.mode) {
                metaBook.covermode=metaBook.mode;
                metaBook.mode=false;
                metaBook.cover.className="";}}
        metaBook.hideCover=hideCover;
        function toggleCover(){
            if (hasClass(document.body,"mbCOVER")) hideCover();
            else showCover();}
        metaBook.toggleCover=toggleCover;
        
        /* Mode controls */
        
        var metaBookModes=/\b((search)|(refinesearch)|(expandsearch)|(searchresults)|(overtoc)|(openglossmark)|(allglosses)|(context)|(statictoc)|(minimal)|(addgloss)|(gotoloc)|(gotoref)|(gotopage)|(shownote)|(showaside)|(glossdetail))\b/g;
        var metabookHeartModes=/\b((statictoc)|(search)|(refinesearch)|(expandsearch)|(searchresults)|(allglosses)|(showaside)|(glossaddtag)|(glossaddtag)|(glossaddoutlet)|(glossdetail))\b/g;
        var metabookHeadModes=/\b((overtoc)|(search)|(refinesearch)|(expandsearch)|(searchresults)|(allglosses)|(addgloss)|(shownote))\b/g;
        var metaBookPopModes=/\b((glossdetail))\b/g;
        var metaBookCoverModes=/\b((welcome)|(help)|(layers)|(login)|(settings)|(cover)|(aboutsbooks)|(aboutmetabooks)|(console)|(aboutbook)|(titlepage))\b/g;
        var metaBookSearchModes=/((refinesearch)|(searchresults)|(expandsearch))/;
        metaBook.searchModes=metaBookSearchModes;
        var metabook_mode_foci=
            {gotopage: "METABOOKPAGEINPUT",
             gotoloc: "METABOOKLOCINPUT",
             gotoref: "METABOOKREFINPUT",
             search: "METABOOKSEARCHINPUT",
             refinesearch: "METABOOKSEARCHINPUT",
             expandsearch: "METABOOKSEARCHINPUT"};
        
        function setMode(mode,nohud){
            var oldmode=metaBook.mode, mode_focus, mode_input;
            if (typeof mode === 'undefined') return oldmode;
            if (mode==='last') mode=metaBook.last_mode;
            if ((!(mode))&&(metaBook.mode)&&
                (metaBook.mode.search(metaBookPopModes)>=0))
                mode=metaBook.last_mode;
            if (mode==='none') mode=false;
            if (mode==='heart') mode=metaBook.heart_mode||"statictoc";
            if (Trace.mode)
                fdjtLog("setMode %o, cur=%o dbc=%o",
                        mode,metaBook.mode,document.body.className);
            if ((mode!==metaBook.mode)&&(metaBook.previewing))
                metaBook.stopPreview("setMode");
            if ((mode!==metaBook.mode)&&(metaBook.popmode)) {
                var fn=metaBook.popmode;
                metaBook.popmode=false;
                fn();}
            if ((mode==="layers")&&
                (!($ID("BOOKHUBAPP").src))&&
                (!(metaBook.appinit)))
                metaBook.initIFrameApp();
            if ((metaBook.mode==="addgloss")&&(mode!=="addgloss")&&
                (hasClass("METABOOKLIVEGLOSS","modified")))
                metaBook.submitGloss($ID("METABOOKLIVEGLOSS"));
            if (mode) {
                if (mode==="search") mode=metaBook.search_mode||"refinesearch";
                if (mode==="addgloss") {}
                else dropClass(document.body,"mbSHRINK");
                if (mode===true) {
                    /* True just puts up the HUD with no mode info */
                    metaBook.hideCover();
                    if (metabook_mode_foci[metaBook.mode]) {
                        mode_focus=metabook_mode_foci[metaBook.mode];
                        mode_input=
                            (((mode_focus.search(/[.#]/))>=0)?
                             (fdjtDOM.$1(mode_focus)):($ID(mode_focus)));
                        mode_input.blur();}
                    dropClass(metaBookHUD,metaBookModes);
                    metaBook.mode=false;
                    metaBook.last_mode=true;}
                else if (typeof mode !== 'string') 
                    throw new Error('mode arg not a string');
                else if (mode.search(metaBookCoverModes)>=0) {
                    if (mode!==metaBook.mode) {
                        $ID("METABOOKCOVER").className=mode;
                        metaBook.mode=mode;
                        metaBook.modechange=fdjtTime();}
                    if (mode==="console") fdjtLog.update();
                    showCover();
                    return;}
                else if (mode===metaBook.mode) {}
                else {
                    metaBook.hideCover();
                    metaBook.modechange=fdjtTime();
                    if (metabook_mode_foci[metaBook.mode]) {
                        mode_focus=metabook_mode_foci[metaBook.mode];
                        mode_input=
                            (((mode_focus.search(/[.#]/))>=0)?
                             (fdjtDOM.$1(mode_focus)):($ID(mode_focus)));
                        mode_input.blur();}
                    if (mode!==metaBook.mode) metaBook.last_mode=metaBook.mode;
                    metaBook.mode=mode;}
                // If we're switching to the inner app but the iframe
                //  hasn't been initialized, we do it now.
                if ((mode==="sbooksapp")&&
                    (!($ID("BOOKHUBAPP").src))&&
                    (!(metaBook.appinit)))
                    initIFrameApp();

                if ((mode==='refinesearch')||
                    (mode==='searchresults')||
                    (mode==='expandsearch'))
                    metaBook.search_mode=mode;

                if (mode==='addgloss') 
                    addClass(document.body,"openhud");
                else if (mode==="openglossmark") {
                    addClass(document.body,"openhud");
                    addClass(document.body,"openglossmark");}
                else if (nohud) {}
                // And if we're not skimming, we just raise the hud
                else setHUD(true);
                // Actually change the class on the HUD object
                if (mode===true) {
                    dropClass(metaBookHUD,"openhead");
                    dropClass(metaBookHUD,"openheart");
                    fdjtDOM.swapClass(metaBookHUD,metaBookModes,"minimal");}
                else if (mode==="addgloss") {
                    // addgloss has submodes which may specify the
                    //  open heart configuration
                    addClass(metaBookHUD,"openhead");
                    dropClass(metaBookHUD,"openheart");}
                else {
                    if (mode.search(metabookHeartModes)<0) {
                        dropClass(metaBookHUD,"openheart");}
                    if (mode.search(metabookHeadModes)<0)
                        dropClass(metaBookHUD,"openhead");
                    if (mode.search(metabookHeartModes)>=0) {
                        metaBook.heart_mode=mode;
                        addClass(metaBookHUD,"openheart");}
                    if (mode.search(metabookHeadModes)>=0) {
                        metaBook.head_mode=mode;
                        addClass(metaBookHUD,"openhead");}}
                changeMode(mode);}
            else {
                // Clearing the mode is a lot simpler, in part because
                //  setHUD clears most of the classes when it brings
                //  the HUD down.
                metaBook.last_mode=metaBook.mode;
                if (hasClass(document.body,"mbCOVER")) hideCover();
                if ((metaBook.mode==="openglossmark")&&
                    ($ID("METABOOKOPENGLOSSMARK"))) {
                    $ID("METABOOKOPENGLOSSMARK").id="";
                    dropClass(document.body,"openglossmark");}
                if (metaBook.textinput) {
                    metaBook.setFocus(false);}
                metaBook.focusBody();
                if (metaBook.skimpoint) {
                    var dups=metaBook.getDups(metaBook.target);
                    metaBook.clearHighlights(dups);
                    dropClass(dups,"mbhighlightpassage");}
                dropClass(metaBookHUD,"openheart");
                dropClass(metaBookHUD,"openhead");
                dropClass(document.body,"dimmed");
                dropClass(document.body,"mbSHOWHELP");
                dropClass(document.body,"mbPREVIEW");
                dropClass(document.body,"mbSHRINK");
                dropClass(metaBookHUD,metaBookModes);
                metaBook.cxthelp=false;
                if (display_sync) metaBook.displaySync();
                if (nohud) metaBook.setHUD(false);
                else setHUD(false);}}
        
        function changeMode(mode){      
            if (Trace.mode)
                fdjtLog("changeMode %o, cur=%o dbc=%o",
                        mode,metaBook.mode,document.body.className);
            fdjtDOM.dropClass(metaBookHUD,metaBookModes);
            fdjtDOM.addClass(metaBookHUD,mode);
            if (mode==="statictoc") {
                var headinfo=((metaBook.head)&&(metaBook.head.id)&&
                              (metaBook.docinfo[metaBook.head.id]));
                var static_head=$ID("MBTOC4"+headinfo.frag);
                var toc=fdjt.ID("METABOOKSTATICTOC");
                fdjt.showPage.check(toc);
                if (static_head.offsetHeight===0)
                    fdjt.showPage.showNode(toc,static_head);}
            else if (mode==="allglosses") {
                var curloc=metaBook.location;
                var glossdiv=fdjt.ID("METABOOKALLGLOSSES");
                var allcards=glossdiv.childNodes;
                var i=0, lim=allcards.length, card=false;
                if (metaBook.allglosses) metaBook.allglosses.setLive(true);
                while (i<lim) {
                    card=allcards[i++];
                    if (card.nodeType===1) {
                        var loc=card.getAttribute("data-location");
                        if (loc) loc=parseInt(loc,10); else continue;
                        if (loc>=curloc) break;}}
                fdjt.showPage.check(glossdiv);
                if ((card)&&(card.offsetHeight===0))
                    fdjt.showPage.showNode(glossdiv,card);}
            else if (metaBook.pagers[mode])
                fdjt.showPage.check(metaBook.pagers[mode]);
            else {}
            
            // We autofocus any input element appropriate to the
            // mode
            if (metabook_mode_foci[mode]) {
                var mode_focus=metabook_mode_foci[metaBook.mode];
                var mode_input=
                    (((mode_focus.search(/[.#]/))>=0)?
                     (fdjtDOM.$1(mode_focus)):($ID(mode_focus)));
                if ((mode_input)&&
                    ((!(metaBook.touch))||
                     (hasParent(mode_input,metaBook.DOM.foot)))) {
                    setTimeout(function(){
                        metaBook.setFocus(mode_input);},
                               50);}}
            else if ((mode==="addgloss")&&(metaBook.glossform)) {
                var glossform=metaBook.glossform;
                var curglossmode=metaBook.getGlossMode(glossform);
                metaBook.setGlossMode(curglossmode,glossform);}
            // Moving the focus back to the body lets keys work
            else setTimeout(metaBook.focusBody,50);
            
            if (display_sync) metaBook.displaySync();}

        function metaBookHUDToggle(mode,keephud){
            if (!(metaBook.mode)) setMode(mode);
            else if (mode===metaBook.mode)
                if (keephud) setMode(true); else setMode(false);
            else if ((mode==='heart')&&
                     (metaBook.mode.search(metabookHeartModes)===0))
                if (keephud) setMode(true); else setMode(false);
            else setMode(mode);}
        metaBook.toggleMode=metaBookHUDToggle;

        metaBook.dropHUD=function(){return setMode(false);};
        metaBook.toggleHUD=function(evt){
            evt=evt||window.event;
            if ((evt)&&(fdjtUI.isClickable(fdjtUI.T(evt)))) return;
            fdjtLog("toggle HUD %o hudup=%o",evt,metaBook.hudup);
            if (metaBook.hudup) setHUD(false,false);
            else setHUD(true);};
        
        /* The App HUD */

        var iframe_app_init=false;
        function initIFrameApp(){
            if (iframe_app_init) return;
            if (metaBook.appinit) return;
            var query="";
            if (document.location.search) {
                if (document.location.search[0]==="?")
                    query=query+document.location.search.slice(1);
                else query=query+document.location.search;}
            if ((query.length)&&(query[query.length-1]!=="&"))
                query=query+"&";
            var refuri=metaBook.refuri;
            var appuri="https://"+metaBook.server+"/flyleaf?"+query;
            if (query.search("REFURI=")<0)
                appuri=appuri+"REFURI="+encodeURIComponent(refuri);
            if (query.search("TOPURI=")<0)
                appuri=appuri+"&TOPURI="+
                encodeURIComponent(document.location.href);
            if (document.title) {
                appuri=appuri+"&DOCTITLE="+encodeURIComponent(document.title);}
            if (metaBook.user) {
                appuri=appuri+"&BOOKUSER="+encodeURIComponent(metaBook.user._id);}
            if (document.location.hash) {
                appuri=appuri+"&HASH="+document.location.hash.slice(1);}

            var app=$ID("BOOKHUBAPP");
            app.src=appuri;
            iframe_app_init=true;}
        metaBook.initIFrameApp=initIFrameApp;

        metaBook.selectApp=function(){
            if (metaBook.mode==='sbooksapp') setMode(false);
            else setMode('sbooksapp');};

        /* Skimming */

        function stopSkimming(){
            // Tapping the tochead returns to results/glosses/etc
            var skimming=metaBook.skimpoint;
            if (!(metaBook.skimming)) return;
            dropClass(document.body,"mbSKIMMING");
            metaBook.skimming=false;
            if (getParent(skimming,$ID("METABOOKALLGLOSSES"))) 
                metaBook.setMode("allglosses");
            else if (getParent(skimming,$ID("METABOOKSTATICTOC"))) 
                metaBook.setMode("statictoc");
            else if (getParent(skimming,$ID("METABOOKSEARCHRESULTS"))) 
                metaBook.setMode("searchresults");
            else {}}
        metaBook.stopSkimming=stopSkimming;
        
        function metaBookSkimTo(card,dir,expanded){
            var skimmer=$ID("METABOOKSKIMMER");
            var skimpoint=metaBook.skimpoint;
            var slice=getSlice(card);
            if (!(slice)) {
                fdjtLog.warn("Can't determine slice for skimming to %o",card);
                return;}
            var cardinfo=slice.getInfo(card);
            if (!(cardinfo)) {
                fdjtLog.warn("No info for skimming to %s in %s",card,slice);
                return;}
            else card=cardinfo.dom||card;
            if ((slice.mode)&&(mB.mode!==slice.mode))
                mB.setMode(slice.mode);
            var passage=mbID(cardinfo.passage||cardinfo.id);
            var i=0, lim=0;
            if (typeof dir !== "number") dir=0;
            if (typeof expanded === "undefined")
                expanded=hasClass(skimmer,"expanded");
            addClass(document.body,"mbSKIMMING");
            if (hasParent(card,metaBook.DOM.allglosses))
                metaBook.skimming=metaBook.allglosses;
            else if (hasParent(card,$ID("METABOOKSEARCHRESULTS")))
                metaBook.skimming=metaBook.searchresults;
            else if (hasParent(card,$ID("METABOOKSTATICTOC")))
                metaBook.skimming=metaBook.statictoc;
            else metaBook.skimming=true;
            setHUD(false,false);
            if (Trace.mode)
                fdjtLog("metaBookSkim() %o (card=%o) mode=%o scn=%o/%o dir=%o",
                        passage,card,
                        metaBook.mode,metaBook.skimpoint,
                        metaBook.target,
                        dir);
            // Copy the description of what we're skimming into the
            // skimmer (at the top of the page during skimming and
            // preview)
            if (skimpoint!==card) {
                var clone=card.cloneNode(true);
                var pct=((dir<0)?("-120%"):(dir>0)?("120%"):(false));
                dropClass(skimmer,"expanded");
                dropClass(skimmer,"transimate");
                clone.id="METABOOKSKIM";
                fdjtDOM.replace("METABOOKSKIM",clone);
                if ((clone.offsetHeight)>skimmer.offsetHeight)
                    addClass(skimmer,"oversize");
                else dropClass(skimmer,"oversize");
                var dropTransAnimate=function(){
                    dropClass(skimmer,"transanimate");
                    fdjtDOM.removeListener(
                        skimmer,"transitionend",dropTransAnimate);};
                if ((skimpoint)&&(pct)) {
                    skimmer.style[fdjtDOM.transform]=
                        "translate("+pct+",0)";
                    setTimeout(function(){
                        addClass(skimmer,"transanimate");
                        fdjtDOM.addListener(
                            skimmer,"transitionend",dropTransAnimate);
                        setTimeout(function(){
                            skimmer.style[fdjtDOM.transform]="";},
                                   0);},
                               0);}
                slice.setSkim(card);
                if (slice.atStart)
                    $ID("METABOOKSKIMINDEX").innerHTML="";
                else $ID("METABOOKSKIMINDEX").innerHTML=""+(slice.skimpos);
                if (slice.atEnd)
                    $ID("METABOOKSKIMLIMIT").innerHTML="";
                else $ID("METABOOKSKIMLIMIT").innerHTML=
                    ""+(slice.visible.length-slice.skimpos-1);
                // This marks where we are currently skimming
                if (skimpoint) dropClass(skimpoint,"skimpoint");
                if (card) addClass(card,"skimpoint");
                metaBook.skimpoint=card;}
            else {}
            if (expanded) addClass("METABOOKSKIMMER","expanded");
            else dropClass("METABOOKSKIMMER","expanded");
            // This all makes sure that the >| and |< buttons
            // appear appropriately
            if (slice.atEnd)
                addClass(document.body,"mbSKIMEND");
            else dropClass(document.body,"mbSKIMEND");
            if (slice.atStart)
                addClass(document.body,"mbSKIMSTART");
            else dropClass(document.body,"mbSKIMSTART");
            var highlights=[];
            if (metaBook.target)
                metaBook.clearHighlights(metaBook.getDups(metaBook.target));
            dropClass("METABOOKSKIMMER","mbfoundhighlights");
            metaBook.setTarget(passage);
            if ((card)&&(hasClass(card,"gloss"))) {
                var glossinfo=metaBook.glossdb.ref(card.name);
                if (glossinfo.excerpt) {
                    var searching=metaBook.getDups(passage.id);
                    var range=metaBook.findExcerpt(
                        searching,glossinfo.excerpt,glossinfo.exoff);
                    if (range) {
                        highlights=
                            fdjtUI.Highlight(range,"mbhighlightexcerpt");
                        addClass("METABOOKSKIMMER","mbfoundhighlights");}}
                else if (card.about[0]==="#")
                    addClass(metaBook.getDups(card.about.slice(1)),
                             "mbhighlightpassage");
                else addClass(metaBook.getDups(card.about),"mbhighlightpassage");}
            else if ((card)&&(getParent(card,".sbookresults"))) {
                var about=card.about, target=mbID(about);
                if (target) {
                    var info=metaBook.docinfo[target.id];
                    var terms=metaBook.query.tags;
                    var spellings=info.knodeterms;
                    i=0; lim=terms.length;
                    if (lim===0)
                        addClass(metaBook.getDups(target),
                                 "mbhighlightpassage");
                    else while (i<lim) {
                        var term=terms[i++];
                        var h=metaBook.highlightTerm(term,target,info,spellings);
                        highlights=highlights.concat(h);}}}
            metaBook.GoTo(passage,"Skim");}
        metaBook.SkimTo=metaBookSkimTo;

        function getSlice(card){
            var cur_slice=mB[mB.mode];
            if ((cur_slice)&&(cur_slice.getInfo(card)))
                return cur_slice;
            else if (card.nodeType) {
                if (hasParent(card,mB.DOM.allglosses))
                    return mB.allglosses;
                else if (hasParent(card,$ID("SBOOKSEARCHRESULTS")))
                    return mB.searchresults;
                else return false;}
            else if (typeof card === "string") {
                if (mB.glossdb.probe(card))
                    return mB.allglosses;
                else if (mB.docinfo[card])
                    return mB.statictoc;
                else return false;}
            else return false;}

        metaBook.addConfig("uisize",function(name,value){
            fdjtDOM.swapClass(
                metaBook.Frame,/metabookuifont\w+/g,"metabookuifont"+value);
            fdjt.Async(function(){metaBook.resizeUI();});
            fdjt.Async(function(){
                metaBook.updateSettings(name,value);});});
        metaBook.addConfig("dyslexical",function(name,value){
            var root=document.documentElement||document.body;
            if ((value)&&(typeof value === 'string')&&
                (/yes|on|t/i.exec(value))) {
                if (hasClass(root,"_DYSLEXICAL")) return;
                else {
                    metaBook.dyslexical=true;
                    addClass(root,"_DYSLEXICAL");}}
            else if (!(hasClass(root,"_DYSLEXICAL")))
                return;
            else {
                metaBook.dyslexical=false;
                fdjtDOM.dropClass(root,"_DYSLEXICAL");}
            fdjt.Async(function(){
                metaBook.resizeUI();
                if (metaBook.layout) metaBook.Paginate("typechange");},
                       10);});
        metaBook.addConfig("animatecontent",function(name,value){
            if (metaBook.dontanimate) {}
            else if (value) addClass(document.body,"_ANIMATE");
            else dropClass(metaBook.page,"_ANIMATE");
            fdjt.Async(function(){
                metaBook.updateSettings(name,value);});});
        metaBook.addConfig("animatehud",function(name,value){
            if (metaBook.dontanimate) {}
            else if (value) addClass("METABOOKFRAME","_ANIMATE");
            else dropClass("METABOOKFRAME","_ANIMATE");
            fdjt.Async(function(){
                metaBook.updateSettings(name,value);});});

        /* Settings apply/save handlers */

        function keyboardHelp(arg,force){
            if (arg===true) {
                if (metaBook.keyboardHelp.timer) {
                    clearTimeout(metaBook.keyboardHelp.timer);
                    metaBook.keyboardHelp.timer=false;}
                dropClass("METABOOKKEYBOARDHELPBOX","closing");
                dropClass("METABOOKKEYBOARDHELPBOX","closed");
                return;}
            else if (arg===false) {
                if (metaBook.keyboardHelp.timer) {
                    clearTimeout(metaBook.keyboardHelp.timer);
                    metaBook.keyboardHelp.timer=false;}
                addClass("METABOOKKEYBOARDHELPBOX","closed");
                dropClass("METABOOKKEYBOARDHELPBOX","closing");
                return;}
            if ((!force)&&(!(metaBook.keyboardhelp))) return;
            if (typeof arg === 'string') arg=$ID(arg);
            if ((!(arg))||(!(arg.nodeType))) return;
            var box=$ID("METABOOKKEYBOARDHELPBOX");
            var content=arg.cloneNode(true);
            content.id="METABOOKKEYBOARDHELP";
            fdjtDOM.replace("METABOOKKEYBOARDHELP",content);
            fdjtDOM.dropClass(box,"closed");
            metaBook.keyboardHelp.timer=
                setTimeout(function(){
                    fdjtDOM.addClass(box,"closing");
                    metaBook.keyboardHelp.timer=
                        setTimeout(function(){
                            metaBook.keyboardHelp.timer=false;
                            fdjtDOM.swapClass(box,"closing","closed");},
                                   5000);},
                           5000);}
        metaBook.keyboardHelp=keyboardHelp;

        /* Showing a particular gloss */

        metaBook.showGloss=function showGloss(uuid){
            if (!(metaBook.glossdb.ref(uuid))) return false;
            var elts=document.getElementsByName(uuid);
            if (!(elts)) return false;
            else if (!(elts.length)) return false;
            else {
                var hasParent=fdjtDOM.hasParent;
                var i=0, lim=elts.length;
                while (i<lim) {
                    var src=elts[i++];
                    if (hasParent(src,allglosses)) {
                        setMode("allglosses");
                        metaBook.SkimTo(src);
                        return true;}}
                return false;}};

        /* Setting/clearing help mode */
        metaBook.hideHelp=function(){
            fdjtDOM.dropClass(document.body,"mbSHOWHELP");};
        metaBook.showHelp=function(){
            fdjtDOM.addClass(document.body,"mbSHOWHELP");};

        return setMode;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/preview.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log;
    var dropClass=fdjtDOM.dropClass, addClass=fdjtDOM.addClass;
    var hasClass=fdjtDOM.hasClass;
    var mB=metaBook, mbID=mB.ID, getTarget=mB.getTarget;
    var Trace=mB.Trace;
    var mbGoTo=mB.GoTo;

    // Preview functions
    var oldscroll=false, preview_elt=false;
    function scrollPreview(elt,caller){
        var xoff=window.scrollLeft||0, yoff=window.scrollTop||0;
        if (elt) {
            if (elt.frag) elt=elt.frag;
            if (typeof elt==="string") elt=mbID(elt);
            if (!(elt)) return;
            else preview_elt=elt;
            if (!(oldscroll)) oldscroll={x: 0,y: yoff};
            var offinfo=fdjtDOM.getGeometry(elt,mB.content);
            if (Trace.flips)
                fdjtLog("startScrollPreview/%s to %d for %o",
                        caller||"nocaller",offinfo.top-100,elt);
            // metaBook.content.style.top=(-offinfo.top)+"px";
            var use_top=offinfo.top-((fdjtDOM.viewHeight()-50)/2);
            if (use_top<0) use_top=0;
            window.scrollTo(0,use_top);}
        else if (oldscroll) {
            if (Trace.flips)
                fdjtLog("stopScrollPreview/%s to %j from %d,%d(%o)",
                        caller||"nocaller",oldscroll,xoff,yoff,
                        preview_elt);
            preview_elt=false;
            window.scrollTo(oldscroll.x,oldscroll.y);
            oldscroll=false;}
        else {
            if (Trace.flips)
                fdjtLog("stopScrollPreview/%s to %j from %d,%d(%o)",
                        caller||"nocaller",oldscroll,xoff,yoff,
                        preview_elt);
            preview_elt=false; oldscroll=false;}}
    
    function clearPreview(){
        var current=fdjtDOM.$(".mbpreviewing");
        var i=0, lim=current.length; while (i<lim) {
            var p=current[i++];
            dropClass(p,"mbpreviewing");
            mB.clearHighlights(p);}}

    function startPreview(spec,caller){
        var target=((spec.nodeType)?(spec):(mbID(spec)));
        if ((Trace.flips)||(Trace.preview))
            fdjtLog("startPreview %o (%s)",target,caller);
        if (target===mB.previewing) {}
        if (mB.skimming) mB.stopSkimming();
        if (mB.layout instanceof fdjt.CodexLayout) {
            var dups=((getTarget(target))&&(mB.getDups(target)));
            mB.startPagePreview(target,caller);
            addClass(target,"mbpreviewing");
            if (dups) addClass(dups,"mbpreviewing");}
        else {
            scrollPreview(target,caller);
            addClass(target,"mbpreviewing");}
        metaBook.previewing=target;
        addClass(document.body,"mbPREVIEW");
        if (hasClass(target,"codexpage"))
            addClass(document.body,"mbPAGEPREVIEW");
        return target;}
    metaBook.startPreview=startPreview;
    function stopPreview(caller,jumpto){
        clearPreview();
        if ((jumpto)&&(!(jumpto.nodeType)))
            jumpto=mB.previewTarget||mB.previewing;
        if ((Trace.flips)||(Trace.preview))
            fdjtLog("stopPreview/%s jump to %o, pt=%o, p=%o",
                    caller||"nocaller",jumpto,
                    mB.previewTarget,mB.previewing);
        if (mB.layout instanceof fdjt.CodexLayout) {
            mB.stopPagePreview(caller,jumpto);}
        else if (!(jumpto)) scrollPreview(false,caller);
        else if (jumpto===mB.previewing) {
            oldscroll=false; scrollPreview(false,caller);}
        else scrollPreview(false,caller);
        mB.previewing=false; mB.previewTarget=false;
        dropClass(document.body,"mbPREVIEW");
        dropClass(document.body,"mbPAGEPREVIEW");
        if (jumpto) {
            if (mB.hudup) mB.setHUD(false);
            mbGoTo(jumpto);}
        return false;}
    metaBook.stopPreview=stopPreview;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/nav.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* globals Promise */

// resize.js
(function (){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log, $ID=fdjt.ID;
    var addClass=fdjtDOM.addClass;
    var showPage=fdjt.showPage;
    var fdjtUI=fdjt.UI;
    var Trace=metaBook.Trace, mB=metaBook;

    var getGeometry=fdjtDOM.getGeometry;

    // This is the window outer dimensions, which is stable across
    // most chrome changes, especially on-screen keyboards.  We
    // track so that we can avoid resizes which shouldn't force
    // layout updates.
    var outer_height=window.outerHeight, outer_width=window.outerWidth;

    /* Whether to resize by default */
    var resize_default=false;
    var ui_resize_wait=false, ui_resize_done=[];
    var ui_width=false, ui_height=false;
    
    function resizeUI(wait){
        function resizing(done){
            if (ui_resize_wait) clearTimeout(ui_resize_wait);
            ui_resize_wait=setTimeout(function(){
                var h=fdjtDOM.viewHeight(), w=fdjtDOM.viewWidth();
                if ((w!==ui_width)||(h!==ui_height)) {
                    var adjstart=fdjt.Time();
                    var hud=$ID("METABOOKHUD");
                    var cover=$ID("METABOOKCOVER");
                    ui_height=h; ui_width=w;
                    if (cover) mB.resizeCover(cover);
                    if (hud) mB.resizeHUD(hud);
                    if ((hud)||(cover))
                        fdjtLog("Resized UI in %fsecs, running %d callbacks",
                                ((fdjt.Time()-adjstart)/1000),
                                ui_resize_done.length);}
                var when_done=ui_resize_done; 
                ui_resize_wait=false; ui_resize_done=[];
                var i=0, n=when_done.length;
                while (i<n) when_done[i++]();},
                                      wait);
            ui_resize_done.push(done);}
        if (typeof wait !== "number") wait=100;
        return new Promise(resizing);}

    metaBook.resizeUI=resizeUI;

    function metabookResize(){
        var layout=mB.layout;
        if (Trace.resize)
            fdjtLog("Real resize w/layout=%o",layout);
        if (resizing) {
            clearTimeout(resizing); resizing=false;}
        updateSizeClasses();
        mB.resizeUI();
        mB.sizeContent();
        // Unscale the layout
        if (layout) mB.scaleLayout(false);
        if ((mB.touch)&&
            ((mB.textinput)||
             ((document.activeElement)&&
              (document.activeElement.tagName==="INPUT")))) {
            if (Trace.resize)
                fdjtLog("Resize for soft keyboard, mostly ignoring");
            return;}
        if ((window.outerWidth===outer_width)&&
            (window.outerHeight===outer_height)) {
            // Not a real change (we think), so just scale the
            // layout, don't make a new one.
            if (layout) metaBook.scaleLayout(true);
            if (Trace.resize) fdjtLog("Resize to norm, ignoring");
            return;}
        resizePagers();
        // Set these values to the new one
        outer_width=window.outerWidth;
        outer_height=window.outerHeight;
        // Possibly a new layout
        var width=getGeometry($ID("CODEXPAGE"),false,true).width;
        var height=getGeometry($ID("CODEXPAGE"),false,true).inner_height;
        if ((layout)&&(layout.width===width)&&(layout.height===height)) {
            if (Trace.resize) fdjtLog("Layout size unchanged, ignoring");
            return;}
        if ((layout)&&(layout.onresize)&&(!(metaBook.freezelayout))) {
            // This handles prompting for whether or not to update
            // the layout.  We don't prompt if the layout didn't
            // take very long (metaBook.long_layout_thresh) or is already
            // cached (metaBook.layoutCached()).
            if ((metaBook.long_layout_thresh)&&(layout.started)&&
                ((layout.done-layout.started)<=metaBook.long_layout_thresh))
                resizing=setTimeout(resizeNow,50);
            else if (choosing_resize) {}
            else if (metaBook.layoutCached())
                resizing=setTimeout(resizeNow,50);
            else {
                // This prompts for updating the layout
                var msg=fdjtDOM("div.title","Update layout?");
                // This should be fast, so we do it right away.
                metaBook.scaleLayout(true);
                choosing_resize=true;
                // When a choice is made, it becomes the default
                // When a choice is made to not resize, the
                // choice timeout is reduced.
                var choices=[
                    {label: "Yes",
                     handler: function(){
                         choosing_resize=false;
                         resize_default=true;
                         metaBook.layout_choice_timeout=10;
                         resizing=setTimeout(resizeNow,50);},
                     isdefault: resize_default},
                    {label: "No",
                     handler: function(){
                         choosing_resize=false;
                         resize_default=false;
                         metaBook.layout_choice_timeout=10;},
                     isdefault: (!(resize_default))}];
                var spec={choices: choices,
                          timeout: (metaBook.layout_choice_timeout||
                                    metaBook.choice_timeout||20),
                          spec: "div.fdjtdialog.fdjtconfirm.updatelayout"};
                choosing_resize=fdjtUI.choose(spec,msg);}}}
    metaBook.resize=metabookResize;

    function resizeNow(evt){
        if (resizing) clearTimeout(resizing);
        resizing=false;
        metaBook.layout.onresize(evt);}

    function resizePagers(){
        var pagers=fdjtDOM.$(".fdjtpage");
        var i=0, lim=pagers.length; while (i<lim) {
            var pager=pagers[i++];
            if (pager.offsetHeight) showPage.update(pager);
            else addClass(pager,"needsresize");}}

    var sizeclass_regexp=/\b_(NARROW|WIDE|REALLYSHORT|SHORT|TALL)\b/g;
    function updateSizeClasses(){
        var addClass=fdjtDOM.addClass, body=document.body;
        var w=fdjtDOM.viewWidth(), h=fdjtDOM.viewHeight();
        fdjtDOM.dropClass(body,sizeclass_regexp);
        if (w<700) addClass(body,"_NARROW");
        else if (w>1200) addClass(body,"_WIDE");
        else {}
        if (h<350) addClass(document.body,"_REALLYSHORT");
        else if (h<600) addClass(document.body,"_SHORT");
        else if (h>1200) addClass(document.body,"_TALL");
        else {}}
    metaBook.updateSizeClasses=updateSizeClasses;

    var resizing=false;
    var resize_wait=false;
    var choosing_resize=false;
    
    function resizeHandler(evt){
        evt=evt||window.event;
        if (Trace.resize)
            fdjtLog("Resize event %o, waiting=%o",evt,resize_wait);
        if (resize_wait) clearTimeout(resize_wait);
        if (choosing_resize) {
            if (Trace.resize) fdjtLog("Close resize dialog %o",evt);
            fdjt.Dialog.close(choosing_resize);
            choosing_resize=false;}
        resize_wait=setTimeout(metabookResize,metaBook.resize_wait);}
    metaBook.resizeHandler=resizeHandler;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/social.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements basic features for browsing glosses based on
   their "sources" --- the reasons they're overlaid on the reader's
   book in the first place.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

(function(){
    "use strict";

    var fdjtString=fdjt.String;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var RefDB=fdjt.RefDB, $ID=fdjt.ID;

    var getInitials=fdjtString.getInitials;
    var addClass=fdjtDOM.addClass, dropClass=fdjtDOM.dropClass;
    var hasClass=fdjtDOM.hasClass, toggleClass=fdjtDOM.toggleClass;
    var mbicon=metaBook.icon;
    var mB=metaBook;

    /* Social UI components */

    function addSource(info,withgloss){
        if (typeof info === 'string') info=RefDB.resolve(info);
        var humid=info.humid;
        if (!(info.name)) return;
        if (withgloss) {
            var icon=$ID("SBOOKSOURCEICON"+humid);
            if (!(icon)) { // Add icon to the sources bar
                var pic=(info._pic)||(info.pic)||
                    ((info.fbid)&&
                     ("https://graph.facebook.com/"+info.fbid+
                      "/picture?type=square"));
                var kind=info.kind;
                if (pic) {}
                else if ((kind===':CIRCLE')||(info.iscircle))
                    pic=mbicon("readingcircle",64,64);
                else pic=mbicon("sideguide",64,64);
                if (pic)
                    icon=fdjtDOM.Image
                (pic,".button.source",info.name|info.kind,
                 ("click to show/hide glosses from "+info.name));
                else {
                    icon=fdjtDOM("div.button.source",getInitials(info.name));}
                var title=
                    ((kind===':CIRCLE')?("the reading circle "):
                     (kind===':OVERLAY')?("the reading guide "):
                     ("the layer "))+
                    ((info.name)?("“"+(info.name)+"”"):"")+
                    ((info.about)?": ":"")+
                    ((info.about)?(info.about):"");
                icon.title=title; icon.oid=info._id;
                if (info.name) icon.alt=getInitials(info.name);
                icon.id="SBOOKSOURCEICON"+humid;
                fdjtDOM($ID("METABOOKSOURCES")," ",icon);}}
        return info;}
    metaBook.UI.addSource=addSource;
    metaBook.UI.addGlossSource=function(info){addSource(info,true);};

    function everyone_ontap(evt){
        evt=evt||window.event||null;
        var target=fdjtDOM.T(evt);
        // var sources=fdjtDOM.getParent(target,".metabooksources");
        // var glosses=fdjtDOM.getParent(target,".sbookglosses");
        var sources=$ID("METABOOKSOURCES");
        var glosses=$ID("METABOOKALLGLOSSES");
        if ((!(sources))||(!(glosses)))
            return; /* Warning? */
        if (fdjtDOM.hasClass(target,"selected")) {
            metaBook.setMode(false);
            fdjtDOM.cancel(evt);
            return;}
        var selected=fdjtDOM.$(".selected",sources);
        toggleClass(selected,"selected");
        addClass(target,"selected");
        metaBook.UI.selectSources(metaBook.allglosses,false);
        fdjtDOM.cancel(evt);}
    metaBook.UI.handlers.everyone_ontap=everyone_ontap;

    function sources_tapped(evt){
        evt=evt||window.event||null;
        // if (!(metaBook.user)) return;
        var target=fdjtDOM.T(evt);
        // var sources=fdjtDOM.getParent(target,".metabooksources");
        // var glosses=fdjtDOM.getParent(target,".sbookglosses");
        var sources=$ID("METABOOKSOURCES");
        var glosses=$ID("METABOOKALLGLOSSES");
        var new_sources=[];
        if ((!(sources))||(!(glosses))||(!(target))||(!(target.oid)))
            return; /* Warning? */
        var selected=fdjtDOM.$(".selected",sources);
        toggleClass(target,"selected");
        if (!(evt.shiftKey)) dropClass(selected,"selected");
        selected=fdjtDOM.$(".selected",sources);
        var i=0, lim=selected.length; while (i<lim) {
            new_sources.push(selected[i++].oid);}
        var everyone=fdjtDOM.$(".everyone",sources)[0];
        if (new_sources.length) {
            if (everyone) dropClass(everyone,"selected");
            metaBook.UI.selectSources(metaBook.allglosses,new_sources);}
        else {
            if (everyone) addClass(everyone,"selected");
            metaBook.UI.selectSources(metaBook.allglosses,false);}
        fdjtDOM.cancel(evt);}

    function sources_taptap(evt){
        evt=evt||window.event||null;
        // if (!(metaBook.user)) return;
        var target=fdjtDOM.T(evt);
        // var sources=fdjtDOM.getParent(target,".metabooksources");
        // var glosses=fdjtDOM.getParent(target,".sbookglosses");
        var sources=$ID("METABOOKSOURCES");
        var glosses=$ID("METABOOKALLGLOSSES");
        var new_sources=[];
        if ((!(sources))||(!(glosses))||(!(target))||(!(target.oid)))
            return; /* Warning? */
        var selected=fdjtDOM.$(".selected",sources);
        toggleClass(target,"selected");
        selected=fdjtDOM.$(".selected",sources);
        var i=0, lim=selected.length; while (i<lim) {
            new_sources.push(selected[i++].oid);}
        var everyone=fdjtDOM.$(".everyone",sources)[0];
        if (new_sources.length) {
            if (everyone) dropClass(everyone,"selected");
            metaBook.UI.selectSources(metaBook.allglosses,new_sources);}
        else {
            if (everyone) addClass(everyone,"selected");
            metaBook.UI.selectSources(metaBook.allglosses,false);}
        fdjtDOM.cancel(evt);}

    function geticon(source){
        return ((source._pic)||(source.pic)||(source.fb_pic)||
                (source.twitter_pic)||(source.gplus_pic)||
                ((source.fbid)&&
                 ("https://graph.facebook.com/"+
                  source.fbid+"/picture?type=square")));}

    function extendGlossmark(glossmark,glosses,image){
        var sources=metaBook.sourcedb; var glossdb=metaBook.glossdb;
        if (!(image)) image=fdjtDOM.getChild(glossmark,".wedge");
        var images=image.getAttribute("data-images").split("|");
        if ((images.length===1)&&(images[0]==="")) images=[];
        var i=0; var lim=glosses.length;
        while (i<lim) {
            var glossid=glosses[i++];
            if (typeof glossid!=="string") glossid=glossid._id;
            if (!(glossid)) continue;
            var gloss=glossdb.ref(glossid);
            var cur=glossmark.glosses;
            var maker=((gloss.maker)&&(sources.ref(gloss.maker)));
            var maker_img=((maker)&&geticon(maker));
            if (maker_img) images.push(maker_img);
            if (cur) {
                if (cur.indexOf(glossid)<0) cur.push(glossid);}
            else glossmark.glosses=[glossid];
            var outlets=gloss.sources||[];
            if (typeof outlets === 'string') outlets=[outlets];
            var j=0, jlim=outlets.length; while (j<jlim) {
                var outlet=sources.ref(outlets[j++]);
                var outlet_img=geticon(outlet);
                if (outlet_img) images.push(outlet_img);}}
        image.setAttribute("data-images",images.join("|"));
        return glossmark;}
    
    metaBook.UI.addGlossmark=function(passage,gloss){
        var Glosses=metaBook.glossdb;
        var current_glossmark=fdjtDOM.getChild(passage,".glossmark");
        if ((current_glossmark)&&(current_glossmark.parentNode===passage)) {
            if (gloss) extendGlossmark(current_glossmark,[gloss]);
            return current_glossmark;}
        var imgsrc=(mbicon("sbwedge",64,64));
        var wedge=fdjtDOM.Image(imgsrc,"wedge","glosses");
        var glossmark=fdjtDOM("a.glossmark.fdjtskiptext",wedge);
        // Get all the glosses from the index
        var id=passage.getAttribute("data-baseid")||passage.id;
        var glosses=Glosses.find("frag",id);
        glossmark.title=
            ((glosses.length>1)?
             ("See "+glosses.length+" glosses on this passage"):
             ("See the gloss on this passage"));
        wedge.defaultsrc=imgsrc;
        wedge.setAttribute("data-images","");
        extendGlossmark(glossmark,glosses,wedge);
        metaBook.UI.addHandlers(glossmark,"glossmark");
        addClass(passage,"glossed");
        fdjtDOM.prepend(passage,glossmark);
        glossmark.name="METABOOK_GLOSSMARK_"+id;
        return glossmark;};
    
    var MetaBookSlice=metaBook.Slice;

    function showGlossmark(target,point) {
        var id=target.codexbaseid||target.id;
        if (!(id)) return;
        var dups=metaBook.getDups(target.id);
        var glossids=metaBook.glossdb.find('frag',id), glosses=[];
        var slicediv=fdjtDOM("div.metabookglosses.metabookslice");
        if ((!(glossids))||(!(glossids.length)))
            addClass(slicediv,"noglosses");
        if (metaBook.target) metaBook.clearHighlights(metaBook.target);
        var i=0, lim=glossids.length; while (i<lim) {
            var glossref=metaBook.glossdb.ref(glossids[i++]);
            glosses.push(glossref);}
        // metaBook.glossdb.load(glosses);
        i=0; while (i<lim) {
            var gloss=glosses[i++];
            if (gloss.excerpt) {
                var range=metaBook.findExcerpt(dups,gloss.excerpt,gloss.exoff);
                if (range) {
                    var starts=range.startContainer;
                    if (!(hasClass(starts,"mbhighlightexcerpt"))) {
                        fdjtUI.Highlight(range,"mbhighlightexcerpt");}}}}
        var slice=new MetaBookSlice(slicediv,glosses,sort_point_glosses);
        var hudwrapper=fdjtDOM("div.hudpanel#METABOOKPOINTGLOSSES",slicediv);
        metaBook.openglossmark=slice;
        if (point) {
            mB.setMode(false);
            hudwrapper.style.display='block';
            hudwrapper.style.opacity=0.0;
            if ($ID("METABOOKPOINTGLOSSES"))
                fdjtDOM.replace("METABOOKPOINTGLOSSES",hudwrapper);
            else mB.body.appendChild(hudwrapper);
            var geom=fdjtDOM.getGeometry(slicediv);
            var wgeom=fdjtDOM.getGeometry(hudwrapper);
            var pgeom=fdjtDOM.getGeometry(point);
            var tgeom=fdjtDOM.getGeometry(target);
            var w=fdjtDOM.viewWidth(), h=fdjtDOM.viewHeight();
            if (metaBook.fullwidth) {
                var wspec=(w-30)+"px";
                hudwrapper.style.left="10px";
                hudwrapper.style.width=
                    hudwrapper.style.maxWidth=
                    hudwrapper.style.minWidth=wspec;}
            else if (geom.width>w) {
                hudwrapper.style.maxWidth=(w-20)+"px";
                hudwrapper.style.minWidth=Math.floor(w/2)+"px";
                hudwrapper.style.left="10px";}
            else if ((geom.height>h/2)||(w<500)) {
                // If the slice is big, drop the width constraint
                if (w<500) {
                    hudwrapper.style.maxWidth=(w-20)+"px";
                    hudwrapper.style.minWidth=Math.floor(w/2)+"px";
                    hudwrapper.style.left="10px";}
                else hudwrapper.style.maxWidth=(w-100)+"px";}
            geom=fdjtDOM.getGeometry(slicediv);
            wgeom=fdjtDOM.getGeometry(hudwrapper);
            if ((!(metaBook.fullwidth))&&(geom.width>(w-50)))
                hudwrapper.style.left="10px";
            var wh=false;
            if ((geom.height+15)>h/2) wh=h/2;
            else wh=geom.height+10;
            if ((!(metaBook.fullwidth))&&(wh>50))
                hudwrapper.style.minHeight=wh+'px';
            slicediv.style.overflowX='hidden';
            slicediv.style.overflowY='auto';
            var above_point=pgeom.top-60, below_point=(h-60)-pgeom.bottom;
            var below_passage=(h-60)-tgeom.bottom;
            // If the glossmark is taller than the target, use the
            // glossmark bottom
            if (tgeom.bottom<pgeom.bottom) tgeom.bottom=pgeom.bottom+10;
            if (wh<above_point) 
                hudwrapper.style.top=(pgeom.top-(wh+15))+'px';
            else if (geom.height<below_passage) 
                hudwrapper.style.top=(tgeom.bottom+5)+'px';
            else if (geom.height<below_point) 
                hudwrapper.style.top=(pgeom.bottom+15)+'px';
            else {
                // Now, we're scrolling
                if (!(metaBook.fullwidth)) {
                    hudwrapper.style.right=(w-pgeom.left+10)+'px';
                    hudwrapper.style.left='50px';}
                if (pgeom.top-(h/4)<50) {
                    hudwrapper.style.top='50px';
                    hudwrapper.style.bottom='auto';
                    hudwrapper.style.height=(h/2)+'px';}
                else {
                    hudwrapper.style.top=(pgeom.top-h/4)+'px';
                    hudwrapper.style.bottom='auto';
                    hudwrapper.style.height=(h/2)+'px';}}
            // fdjtLog("geom=%j, pgeom=%j, wgeom=%j ph=%j",geom,pgeom,wgeom,fdjtDOM.viewHeight());
            if (metaBook.fullwidth) {}
            else if (fdjtDOM.viewWidth()<300)
                hudwrapper.style.minWidth=((fdjtDOM.viewWidth())-10)+"px";
            else {}
            hudwrapper.style.display='';
            hudwrapper.style.opacity='';}
        else fdjtDOM.replace("METABOOKPOINTGLOSSES",hudwrapper);
        if (point) {
            var cur=$ID("METABOOKOPENGLOSSMARK");
            if (cur) {
                if (metaBook.target)
                    metaBook.clearHighlights(metaBook.target);
                cur.id="";}
            point.id="METABOOKOPENGLOSSMARK";}
        metaBook.setTarget(target);
        slice.update();
        metaBook.setMode("openglossmark");}
    metaBook.showGlossmark=showGlossmark;

    function sort_point_glosses(g1,g2){
        if ((g1.location)&&(g2.location)) {
            if (g1.location>g2.location) return -1;
            else if (g1.location<g2.location) return 1;
            else return 0;}
        else if ((g1.exoff)&&(g2.exoff)) {
            if (g1.exoff>g2.exoff) return -1;
            else if (g1.exoff<g2.exoff) return 1;
            else return 0;}
        else if (g1.created>g2.created) return -1;
        else if (g1.created<g2.created) return 1;
        else return 0;}

    function clearGlossmark() {
        if (metaBook.mode==="openglossmark") metaBook.setMode(false,true);
        var slicediv=fdjtDOM("div.metabookglosses.metabookslice");
        var hudwrapper=fdjtDOM("div.hudpanel#METABOOKPOINTGLOSSES",slicediv);
        fdjtDOM.replace("METABOOKPOINTGLOSSES",hudwrapper);}
    metaBook.clearGlossmark=clearGlossmark;

    var cancel=fdjtUI.cancel;

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.mouse,
        {"#METABOOKSOURCES": {
            tap: sources_tapped,taptap: sources_taptap},
         "#METABOOKSOURCES .button.everyone": {
             tap: function(evt){
                 evt=evt||window.event;
                 metaBook.UI.handlers.everyone_ontap(evt);
                 fdjt.UI.cancel(event);}}});

   fdjt.DOM.defListeners(
        metaBook.UI.handlers.touch,
       {"#METABOOKSOURCES": {
            tap: sources_tapped,taptap: sources_taptap},
        "#METABOOKSOURCES .button.everyone": {
            touchstart: cancel,
            touchend: function(evt){
                evt=evt||window.event;
                metaBook.UI.handlers.everyone_ontap(evt);
                fdjt.UI.cancel(event);}}});

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/search.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements the search component for the e-reader web
   application, and relies heavily on the Knodules module.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.
   This file assumes that the sbooks.js file has already been loaded.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

(function(){
    "use strict";
    var mB=metaBook;
    var Trace=mB.Trace;
    var fdjtString=fdjt.String;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var $ID=fdjt.ID;
    var RefDB=fdjt.RefDB, Query=RefDB.Query; 

    metaBook.search_cloud=false;
    if (!(metaBook.empty_cloud)) metaBook.empty_cloud=false;
    if (!(metaBook.show_refiners)) metaBook.show_refiners=25;
    if (!(metaBook.search_gotlucky)) metaBook.search_gotlucky=7;
    
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var getChild=fdjtDOM.getChild;
    var log=fdjtLog;
    var kbref=RefDB.resolve;

    /* Query functions */

    /* Set on main search input */
    // id="METABOOKSEARCHINPUT" 
    // completions="METABOOKSEARCHCLOUD"
    var search_modes=/(search|refinesearch|searchresults|expandsearch)/;

    metaBook.getQuery=function(){return metaBook.query;};
    
    function setQuery(query){
        if (query instanceof Query) query=query;
        else query=new metaBook.Query(query);
        if (query===metaBook.query) return query;
        if (Trace.search) log("Setting working query to %o",query);
        if (query.tags.length===0) {
            addClass(metaBook.HUD,"emptysearch");
            metaBook.empty_cloud.dom.style.fontSize="";
            metaBook.search_cloud=metaBook.empty_cloud;
            fdjtDOM.replace(
                "METABOOKSEARCHCLOUD",fdjtDOM("div#METABOOKSEARCHCLOUD"));
            displayQuery(query,$ID("METABOOKSEARCH"));
            metaBook.empty_cloud.complete("");
            addClass(metaBook.HUD,"emptysearch");
            metaBook.query=mB.empty_query;
            metaBook.qstring="";
            return;}
        else dropClass(metaBook.HUD,"emptysearch");
        var qstring=query.getString();
        if (qstring!==metaBook.qstring) {
            displayQuery(query,$ID("METABOOKSEARCH"));
            metaBook.query=query;
            metaBook.qstring=qstring;}
        if (search_modes.exec(metaBook.mode)) {
            if (query.results.length===0) {}
            else if (query.results.length<7)
                showSearchResults();
            else if (!(metaBook.touch)) {
                $ID("METABOOKSEARCHINPUT").focus();}
            else {}}
        return query;}
    metaBook.setQuery=setQuery;

    function displayQuery(query,box_arg){
        if ((box_arg)&&(typeof box_arg === 'string'))
            box_arg=document.getElementById(box_arg);
        var box=box_arg||query._box||$ID("METABOOKSEARCH");
        var qstring=query.getString();
        if ((query.dom)&&(box)&&(box!==query.dom))
            fdjtDOM.replace(box_arg,query.dom);
        box.setAttribute("qstring",qstring);
        query.execute();
        var cotags=query.getCoTags();
        var showtags=query.getRefiners();
        var input=getChild(box,".searchinput");
        var cloudid=input.getAttribute("completions");
        var infoid=input.getAttribute("info");
        var qtags=getChild(box,".qtags")||$ID("METABOOKSEARCHTAGS");
        /* These should possibly be used in initializing the .listing
         * field of the query */
        //var resultsid=input.getAttribute("results");
        //var results=((resultsid)&&($ID(resultsid)));
        var info=((infoid)&&($ID(infoid)));
        var resultcount=getChild(info,".resultcount");
        var refinecount=getChild(info,".refinecount");
        // Update (clear) the input field
        input.value='';
        var elts=query.tags; var i=0; var lim=elts.length;
        // Update 'notags' class
        if (elts.length) {
            fdjtDOM.dropClass(metaBook.HUD,"emptysearch");
            fdjtDOM.dropClass("METABOOKSEARCHINFO","notags");}
        else {
            addClass(metaBook.HUD,"emptysearch");
            fdjtDOM.dropClass("METABOOKSEARCHINFO","notags");}
        // Update the query tags
        var newtags=fdjtDOM("div.qtags");
        while (i<lim) {
            var tag=elts[i];
            if (typeof tag === 'string') tag=kbref(tag)||tag;
            var entry=metaBook.cloudEntry(tag,false,false,"span.qelt");
            entry.appendChild(fdjtDOM("span.redx","x"));
            fdjtDOM(newtags,((i>0)&&("\u00a0\u00B7 ")),entry);
            //fdjtDOM(newtags,((i>0)&&(" ")),entry);
            i++;}
        if (qtags.id) newtags.id=qtags.id;
        fdjtDOM.replace(qtags,newtags);
        // Update the results display
        if (query.tags.length===0) {}
        else if (query.results.length) {
            var plural=(query.results.length!==1);
            resultcount.innerHTML=query.results.length+" <br/>"+
                ((elts.length>2)?
                 ((plural)?("results"):("result")):
                 ((plural)?("matches"):("match")));
            fdjtDOM.dropClass([box,info],"noresults");}
        else {
            resultcount.innerHTML="no results";
            addClass([box,info],"noresults");}
        // Tweak font size for qtags
        newtags.setAttribute("data-maxfont","120%");
        newtags.setAttribute("data-min","60%");
        fdjt.DOM.adjustFontSize(newtags);
        // Update the search cloud
        var n_refiners=((showtags)?(showtags.length):
                        (cotags)?(cotags.length):(0));
        var completions=metaBook.queryCloud(query);
        refinecount.innerHTML=n_refiners+" <br/>"+
            ((n_refiners===1)?("co-tag"):("co-tags"));
        fdjtDOM.dropClass(box,"norefiners");
        if (completions!==mB.empty_cloud) {
            fdjtDOM.replace(cloudid,completions.dom);
            if (cloudid) completions.dom.id=cloudid;
            addClass(completions.dom,"hudpanel");}
        else cloudid="METABOOKALLTAGS";
        metaBook.search_cloud=completions;
        if (Trace.search>1)
            log("Setting search cloud for %o to %o",box,completions.dom);
        completions.complete("",function(){
            completions.dom.style.fontSize="";
            if ($ID(cloudid))
                fdjtDOM.replace(cloudid,completions.dom);
            else fdjtDOM.append(
                $ID("METABOOKHEARTBODY"),
                completions.dom);
            metaBook.adjustCloudFont(completions);});
        if (n_refiners===0) {
            addClass(box,"norefiners");
            refinecount.innerHTML="no refiners";}
        query._box=box; box.setAttribute("qstring",qstring);
        return query;}

    var hasParent=fdjtDOM.hasParent;
    var getParent=fdjtDOM.hasParent;

    function searchTags_onclick(evt){
        var target=fdjtUI.T(evt);
        var onx=hasParent(target,".redx");
        var qelt=getParent(target,".qelt");
        if (!(qelt)) return; else fdjtUI.cancel(evt);
        var eltval=qelt.getAttribute("data-value"), elt;
        if (eltval.indexOf('@')>=0) elt=kbref(eltval)||eltval;
        if (Trace.gestures)
            fdjtLog("searchTags_ontap %o: %s%o",
                    evt,((onx)?("(onx) "):("")),
                    elt);
        var cur=[].concat(metaBook.query.tags);
        var splicepos=((elt)?(cur.indexOf(elt)):
                       (cur.indexOf(eltval)));
        if (splicepos<0) splicepos=cur.indexOf(eltval);
        if (splicepos<0) return;
        else cur.splice(splicepos,1);
        if (cur.length===0) {
            metaBook.empty_cloud.dom.style.fontSize="";
            setQuery(metaBook.empty_query);}
        else setQuery(new metaBook.Query(cur));
        fdjtUI.cancel(evt);}
    metaBook.searchTags_onclick=searchTags_onclick;

    function extendQuery(query,elt){
        var elts=[].concat(query.tags);
        if (typeof elt === 'string') {
            if (elt.indexOf('@')>=0) 
                elts.push(kbref(elt)||elt);
            else elts.push(elt);}
        else elts.push(elt);
        return new metaBook.Query(elts);}
    metaBook.extendQuery=extendQuery;

    metaBook.updateQuery=function(input_elt){
        var q=Knodule.Query.string2query(input_elt.value);
        if ((q)!==(metaBook.query.tags))
            metaBook.setQuery(q,false);};

    function showSearchResults(){
        var results=metaBook.query.showResults();
        var results_panel=results.container;
        addClass(results_panel,"hudpanel");
        results_panel.id="METABOOKSEARCHRESULTS";
        fdjtDOM.replace("METABOOKSEARCHRESULTS",results_panel);
        results.update();
        metaBook.searchresults=results;
        metaBook.setMode("searchresults");
        $ID("METABOOKSEARCHINPUT").blur();
        $ID("METABOOKSEARCHRESULTS").focus();}
    metaBook.showSearchResults=showSearchResults;

    /* Call this to search */

    function startSearch(tag){
        setQuery([tag]);
        metaBook.setMode("refinesearch");}
    metaBook.startSearch=startSearch;

    /* Text input handlers */

    var Selector=fdjtDOM.Selector;
    
    function searchInput_keydown(evt){
        evt=evt||window.event||null;
        var ch=evt.charCode||evt.keyCode;
        var target=fdjtDOM.T(evt), completeinfo=false, completions=false;
        if ((ch===13)||(ch===13)||(ch===59)||(ch===93)) {
            var qstring=target.value; 
            if (fdjtString.isEmpty(qstring)) showSearchResults();
            else {
                completeinfo=metaBook.queryCloud(metaBook.query);
                if (completeinfo.timer) {
                    clearTimeout(completeinfo.timer);
                    completeinfo.timer=false;}
                completions=completeinfo.complete(qstring);
                var completion=(completeinfo.selection)||
                    completeinfo.select(new Selector(".cue"))||
                    completeinfo.select();
                // Signal error?
                if (!(completion)) {
                    var found=metaBook.textindex.termindex[qstring];
                    if ((found)&&(found.length))
                        setQuery(extendQuery(metaBook.query,qstring));
                    return;}
                var value=completeinfo.getValue(completion);
                setQuery(extendQuery(metaBook.query,value));}
            fdjtDOM.cancel(evt);
            if ((metaBook.search_gotlucky) && 
                (metaBook.query.results.length>0) &&
                (metaBook.query.results.length<=metaBook.search_gotlucky))
                showSearchResults();
            else {
                /* Handle new info */
                completeinfo=metaBook.queryCloud(metaBook.query);
                completeinfo.complete("");}
            return false;}
        else if (ch===9) { /* tab */
            var partial_string=target.value;
            completeinfo=metaBook.queryCloud(metaBook.query);
            completions=completeinfo.complete(partial_string);
            fdjtUI.cancel(evt);
            if ((completions.prefix)&&
                (completions.prefix!==partial_string)) {
                target.value=completions.prefix;
                fdjtDOM.cancel(evt);
                completeinfo.selectNext();}
            else if (evt.shiftKey) completeinfo.selectPrevious();
            else completeinfo.selectNext();}
        else {}}
    metaBook.UI.handlers.search_keydown=searchInput_keydown;

    function searchInput_keyup(evt){
        evt=evt||window.event||null;
        var ch=evt.charCode||evt.keyCode;
        var target=fdjtDOM.T(evt);
        if ((ch===13)||(ch===13)||(ch===59)||(ch===93)||(ch===9)) {}
        else if (ch===8) {
            setTimeout(function(){searchUpdate(target);},100);}
        else searchUpdate(target);}
    metaBook.UI.handlers.search_keyup=searchInput_keyup;
    
    function searchInput_keypress(evt){
        evt=evt||window.event||null;
        var ch=evt.charCode||evt.keyCode;
        var target=fdjtDOM.T(evt);
        if ((ch===13)||(ch===13)||(ch===59)||(ch===93)||(ch===9)||(ch===8)) {}
        else searchUpdate(target);}
    metaBook.UI.handlers.search_keypress=searchInput_keypress;

    function searchUpdate(input,cloud){
        if (!(input)) input=$ID("METABOOKSEARCHINPUT");
        if (!(cloud)) cloud=metaBook.queryCloud(metaBook.query);
        if (input.value.length===0) cloud.clearSelection();
        cloud.complete(input.value,function(results){
            if ((input.value.length>0)&&
                ((!(results))||
                 (results.length===0)||
                 (input.value.length>4))) {
                addRawText(cloud,input.value);
                setTimeout(function(){cloud.complete(input.value);},50);}
            else {}});}
    metaBook.searchUpdate=searchUpdate;

    function addRawText(cloud,text,ptree,maxmatch){
        if (!(ptree)) ptree=metaBook.textindex.prefixTree();
        if (!(maxmatch)) maxmatch=42;
        var matches=fdjtString.prefixFind(ptree,text);
        if (matches.length===0) return;
        else if (matches.length>maxmatch) return;
        else {
            var i=0, lim=matches.length; while (i<lim) 
                metaBook.cloudEntry(matches[i++],cloud);}}

    function searchInput_focus(evt){
        evt=evt||window.event||null;
        var input=fdjtDOM.T(evt);
        metaBook.setFocus(input);
        if ((metaBook.mode)&&(metaBook.mode==='searchresults'))
            metaBook.setMode("refinesearch");
        searchUpdate(input);}
    metaBook.UI.handlers.search_focus=searchInput_focus;

    function searchInput_blur(evt){
        evt=evt||window.event||null;
        var input=fdjtDOM.T(evt);
        metaBook.clearFocus(input);}
    metaBook.UI.handlers.search_blur=searchInput_blur;

    function clearSearch(evt){
        var target=fdjtUI.T(evt||window.event);
        var box=fdjtDOM.getParent(target,".searchbox");
        var input=getChild(box,".searchinput");
        fdjtUI.cancel(evt);
        if ((metaBook.query.tags.length===0)&&
            (input.value.length===0)) {
            metaBook.setMode(false); return;}
        else {
            metaBook.empty_cloud.dom.style.fontSize="";
            setQuery(metaBook.empty_query);
            input.value="";
            metaBook.empty_cloud.clearSelection();
            metaBook.empty_cloud.complete("");}
        input.focus();}
    metaBook.UI.handlers.clearSearch=clearSearch;
    
    metaBook.toggleSearch=function(evt){
        evt=evt||window.event;
        if ((metaBook.mode==="refinesearch")||
            (metaBook.mode==="searchresults"))
            metaBook.setMode(false);
        else {
            metaBook.setMode("refinesearch");
            if (!(metaBook.touch))
                $ID("METABOOKSEARCHINPUT").focus();}
        fdjtUI.cancel(evt);};
    
    /* Search result listings */

    var MetaBookSlice=metaBook.Slice;
    function SearchResults(query){
        if (!(this instanceof SearchResults))
            return new SearchResults(query);
        this.query=query; this.results=query.results;
        return MetaBookSlice.call(
            this,fdjtDOM("div.metabookslice.sbookresults"),this.results);}
    metaBook.SearchResults=SearchResults;

    SearchResults.prototype=new MetaBookSlice();
    SearchResults.prototype.renderCard=function renderSearchResult(result){
        return metaBook.renderCard(result,this.query);};
    SearchResults.prototype.sortfn=function searchResultsSortFn(x,y){
        if (x.score) {
            if (y.score) {
                if (x.score===y.score) {
                    if (x.location) {
                        if (y.location) {
                            if (x.location===y.location) {
                                if (x.timestamp) {
                                    if (y.timestamp)
                                        return x.timestamp-y.timestamp;
                                    else return -1;}
                                else return 1;}
                            else return x.location-y.location;}
                        else return -1;}}
                else return (y.score-x.score);}
            else return -1;}
        else return 1;};

    /* Show search results */

    function showResults(query){
        if (query.listing) return query.listing;
        else query.listing=new SearchResults(query);
        return query.listing;}
    RefDB.Query.prototype.showResults=
        function(){return showResults(this);};
    
})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/glosses.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements the interface for adding and editing **glosses**,
   which are annotations associated with text passages in a document.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.
   This file assumes that the sbooks.js file has already been loaded.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false, Promise: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

(function () {
    "use strict";

    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var RefDB=fdjt.RefDB;
    var Ref=fdjt.Ref;
    var $ID=fdjt.ID;
    var mB=metaBook;
    var mbID=mB.ID;
    var Trace=metaBook.Trace;

    var addClass=fdjtDOM.addClass;
    var hasClass=fdjtDOM.hasClass;
    var dropClass=fdjtDOM.dropClass;
    var toggleClass=fdjtDOM.toggleClass;
    var swapClass=fdjtDOM.swapClass;
    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var getChildren=fdjtDOM.getChildren;
    var getChild=fdjtDOM.getChild;
    var getInput=fdjtDOM.getInput;
    var getInputs=fdjtDOM.getInputs;
    var getInputFor=fdjtDOM.getInputFor;
    var getInputsFor=fdjtDOM.getInputsFor;
    var getInputValues=fdjtDOM.getInputValues;

    var cancel=fdjtUI.cancel;
    var setCheckSpan=fdjtUI.CheckSpan.set;
    var glossmodes=metaBook.glossmodes;
    var mbicon=metaBook.icon;
    var getTarget=metaBook.getTarget;
    var getGlossTags=metaBook.getGlossTags;

    var uri_prefix=/(http:)|(https:)|(ftp:)|(urn:)/;
    
    var saving_dialog=false;
    var selectors=[];

    function goodURL(string){
        return (/https?:[\/][\/](\w+[.])+\w+[\/]/).exec(string);}

    // The gloss mode is stored in two places:
    //  * the class of the gloss FORM element
    //  * as the class gloss+mode on METABOOKHUD (e.g. glossaddtag)
    function getGlossMode(arg){
        if (!(arg)) arg=$ID("METABOOKLIVEGLOSS");
        if (typeof arg === 'string') arg=$ID(arg);
        if ((!(arg))||(!(arg.nodeType))) return false;
        if (arg.tagName!=="FORM") arg=getChild(arg,"FORM");
        var classname=arg.className;
        var match=glossmodes.exec(classname);
        if ((!(match))||(match.length===0)||(!(match[0])))
            return false;
        else return match[0];}
    metaBook.getGlossMode=getGlossMode;

    function setGlossMode(mode,arg,toggle){
        var node, form;
        function setglossmode(resolve){
            var div=getParent(form,".metabookglossform"), input=false;
            var frag=fdjtDOM.getInput(form,"FRAG");
            var uuid=fdjtDOM.getInput(form,"UUID");
            if ((Trace.mode)||(Trace.glossing)) {
                fdjtLog("setGlossMode %o%s: #%s #U%s",
                        mode,((toggle)?(" (toggle)"):("")),
                        ((frag)&&(frag.value)),
                        ((uuid)&&(uuid.value)));}
            if ((toggle)&&(mode===form.className)) mode=false;
            if (mode) addClass(div,"focused");
            if (!(mode)) {
                dropClass(form,glossmodes);
                dropClass("METABOOKHUD",/\bgloss\w+\b/);
                dropClass("METABOOKHUD","openheart");
                if (!(metaBook.touch)) {
                    var glossinput=getInput(form,"NOTE");
                    if (glossinput) metaBook.setFocus(glossinput);
                    addClass(div,"focused");}
                return;}
            if (mode==="addtag") input=$ID("METABOOKADDTAGINPUT");
            else if (mode==="attach") {
                var upload_glossid=$ID("METABOOKUPLOADGLOSSID");
                upload_glossid.value=uuid.value;
                var upload_itemid=$ID("METABOOKUPLOADITEMID");
                upload_itemid.value=fdjtState.getUUID();
                input=$ID("METABOOKATTACHURL");}
            else if (mode==="addoutlet") 
                input=$ID("METABOOKADDSHAREINPUT");
            else {
                dropClass(form,glossmodes);
                dropClass("METABOOKHUD",/\bgloss\w+\b/);
                return resolve(form);}
            if ((Trace.mode)||(Trace.glossing))
                fdjtLog("setGlossMode gm=%s input=%o",mode,input);
            form.className=mode;
            swapClass("METABOOKHUD",/\bgloss\w+\b/,"gloss"+mode);
            metaBook.setHUD(true);
            if ((mode)&&(/(addtag|addoutlet)/.exec(mode)))
                addClass("METABOOKHUD","openheart");
            if (input) metaBook.setFocus(input);
            return resolve(form);}
        if ((mode)&&(arg)&&(mode.nodeType)&&
            (typeof arg === "string")) {
            node=mode; mode=arg;}
        else if (!(arg)) node=$ID("METABOOKLIVEGLOSS");
        else if (typeof arg === 'string') node=$ID(arg);
        else node=arg;
        if ((node)&&(node.nodeType)) {
            form=((node.tagName==="FORM")?(node):
                  ((fdjtDOM.getParent(node,"form"))||
                   (fdjtDOM.getChild(node,"form"))));
            if (!(form)) {
                fdjtLog.warn("Missing FORM for setGlossMode");
                return;} 
            else return new Promise(setglossmode);}
        else {
            fdjtLog.warn("Missing DOM arg for setGlossMode");
            return false;}}
    metaBook.setGlossMode=setGlossMode;

    // set the gloss target for a particular passage
    function getGlossForm(arg,response) {
        if (typeof arg === 'string')
            arg=mbID(arg)||metaBook.glossdb.ref(arg)||false;
        if (!(arg)) return false;
        var gloss=((!(arg.nodeType))&&((arg.maker)||(arg.gloss))&&(arg));
        var maker=(gloss)&&gloss.maker, makerid=(maker)&&maker._id;
        if (!(maker)) response=false;
        else if ((maker===metaBook.user)||
                 (makerid===metaBook.user._id)||
                 (metaBook.outlets.indexOf(arg.maker)>=0)||
                 (metaBook.outlets.indexOf(arg.maker._id)>=0))
            response=false;
        else response=true;
        var passage=((gloss)?(mbID(gloss.frag)):(arg));
        var passageid=((passage.codexbaseid)||(passage.id));
        var formid=((gloss)?
                    ((response)?
                     ("METABOOKRESPONDGLOSS_"+gloss._id):
                     ("METABOOKEDITGLOSS_"+gloss._id)):
                    ("METABOOKADDGLOSS_"+passageid));
        var form=$ID(formid);
        var div=((form)&&(form.parentNode));
        var proto=$ID("METABOOKADDGLOSSPROTOTYPE");
        if (!(div)) {
            div=proto.cloneNode(true); div.id="";
            fdjtDOM($ID("METABOOKADDGLOSS"),div);
            form=getChildren(div,"form")[0];
            form.id=formid;
            form=setupGlossForm(form,passage,gloss,response||false);
            metaBook.setupGestures(div);}
        else form=getChildren(div,"form")[0];
        if (gloss) {
            if (response) addClass(div,"glossreply");
            else {
                addClass(div,"glossedit");
                addClass(metaBook.HUD,"editgloss");}}
        else addClass(div,"glossadd");
        if (form) return div; else return false;}
    metaBook.getGlossForm=getGlossForm;
    
    function setupGlossForm(form,passage,gloss,response){
        var passageid=((passage.codexbaseid)||(passage.id));
        var info=metaBook.docinfo[passageid];
        if (form.getAttribute("sbooksetup")) return false;
        if (!(info)) return false;
        form.onsubmit=submitGloss;
        getInput(form,"REFURI").value=metaBook.refuri;
        getInput(form,"DOCTITLE").value=document.title;
        getInput(form,"DOCURI").value=document.location.href;
        getInput(form,"FRAG").value=passageid;
        if (info.wsnid) {getInput(form,"WSNID").value=info.wsnid;}
        if (metaBook.user) {
            getInput(form,"MAKER").value=
                ((gloss)&&(gloss.maker)&&(gloss.maker._id))||
                metaBook.user._id;}
        if (metaBook.mycopyid) {
            getInput(form,"MYCOPYID").value=metaBook.mycopyid;}
        if (metaBook.mycopyid) {
            getInput(form,"MYCOPYID").value=metaBook.mycopyid;}
        if (gloss) {
            var glossdate_elt=getChild(form,".glossdate");
            fdjtDOM(glossdate_elt,fdjtTime.shortString(gloss.created));
            glossdate_elt.title=fdjtTime.timeString(gloss.created);}
        var glossinput=getInput(form,"NOTE");
        var notespan=getChild(form,".notespan");
        if (glossinput) {
            glossinput.onkeypress=glossinput_onkeypress;
            glossinput.onkeydown=glossinput_onkeydown;
            glossinput.onfocus=glossinput_onfocus;
            if ((gloss)&&(!(response))) {
                glossinput.value=gloss.note||"";
                if (notespan) notespan.innerHTML=glossinput.value;}
            else glossinput.value="";}
        if (metaBook.syncstamp) {
            getInput(form,"SYNC").value=(metaBook.syncstamp+1);}
        var menu=getChild(form,".addglossmenu");
        fdjt.UI.TapHold(menu,{override: true});
        var loc=getInput(form,"LOCATION");
        var loclen=getInput(form,"LOCLEN");
        var tagline_elt=getInput(form,"TAGLINE");
        var respondsto=getInput(form,"RE");
        var thread=getInput(form,"THREAD");
        var uuidelt=getInput(form,"UUID");
        var detail_elt=getInput(form,"DETAIL");
        var response_elt=getChild(form,"div.response");
        if ((response_elt)&&(response)&&(gloss)) {
            var maker_elt=getChild(response_elt,".respmaker");
            var date_elt=getChild(response_elt,".respdate");
            var note_elt=getChild(response_elt,".respnote");
            var makerinfo=metaBook.sourcedb.ref(gloss.maker);
            fdjtDOM(maker_elt,makerinfo.name);
            fdjtDOM(date_elt,fdjtTime.shortString(gloss.created));
            if (gloss.note) {
                if (gloss.note.length>42) 
                    fdjtDOM(note_elt,gloss.note.slice(0,42)+"…");
                else fdjtDOM(note_elt,gloss.note);
                note_elt.title=gloss.note;}
            else fdjtDOM.remove(note_elt);}
        else {
            fdjtDOM.remove(response_elt); response_elt=false;}
        if (loc) {loc.value=info.starts_at;}
        if (loclen) {loclen.value=info.ends_at-info.starts_at;}
        if ((response)&&(gloss)) {
            thread.disabled=false; respondsto.disabled=false;
            thread.value=gloss.thread||gloss._id;
            respondsto.value=gloss._id;}
        else {
            respondsto.disabled=true;
            thread.disabled=true;}
        var tagline=getTagline(passage);
        if (tagline) tagline_elt.value=tagline;
        if (gloss) {
            var tags=getGlossTags(gloss);
            if (tags.length) {
                var i=0; var lim=tags.length;
                while (i<lim) addTag(form,tags[i++],false);}}
        if ((gloss)&&(!(response))&&(gloss.posted)) {
            var wasposted=getChild(form,".wasposted");
            if (wasposted) wasposted.disabled=false;
            var postgloss=getChild(form,".postgloss");
            fdjtUI.setCheckspan(postgloss,true);}
        if ((gloss)&&(!(response))&&(gloss.links)) {
            var links=gloss.links;
            for (var url in links) {
                if (url[0]==='_') continue;
                var urlinfo=links[url];
                var title;
                if (typeof urlinfo === 'string') title=urlinfo;
                else title=urlinfo.title;
                addLink(form,url,title);}}
        if (gloss) {detail_elt.value=gloss.detail||"";}
        if ((gloss)&&(gloss.share)) {
            var share=gloss.share;
            if (typeof share === 'string') share=[share];
            var share_i=0; var share_lim=share.length;
            while (share_i<share_lim)
                addTag(form,share[share_i++],"SHARE");}
        if ((!(response))&&(gloss)&&(gloss._id)) {
            uuidelt.value=gloss._id;}
        else uuidelt.value=fdjtState.getUUID(metaBook.nodeid);
        if (gloss) {
            // Set the default outlets to unchecked before
            //  adding/setting the assigned outlets.
            resetOutlets(form);
            var shared=((gloss)&&(gloss.shared))||[];
            if (typeof shared === 'string') {shared=[shared];}
            var outlet_i=0, n_outlets=shared.length;
            while (outlet_i<n_outlets) {
                addOutlet(form,shared[outlet_i++],"SHARE",true);}
            var private_span=getChild(form,".private");
            setCheckSpan(private_span,gloss.private);}
        if (((gloss)&&(gloss.excerpt))) {
            metaBook.setExcerpt(form,gloss.excerpt,gloss.exoff);}
        var cancel_button=fdjtDOM.getChild(form,".cancelbutton");
        if (cancel_button) {
            fdjtDOM.addListener(
                cancel_button,"click",cancelGloss_handler);}
        form.setAttribute("sbooksetup","yes");
        updateForm(form);
        var container=getParent(form,".metabookglossform");
        if (container) {dropClass(container,"modified");}
        return form;}

    /***** Setting the gloss target ******/

    // The target can be either a passage or another gloss
    function setGlossTarget(target,form,selecting){
        if (Trace.glossing)
            fdjtLog("setGlossTarget %o form=%o selecting=%o",
                    target,form,selecting);
        if (metaBook.glosstarget) {
            dropClass(metaBook.glosstarget,"mbglosstarget");}
        dropClass("METABOOKHUD",/\bgloss\w+\b/);
        dropClass("METABOOKHUD","editgloss");
        if (!(target)) {
            var cur=$ID("METABOOKLIVEGLOSS");
            if (cur) cur.id="";
            metaBook.glosstarget=false;
            metaBook.glossform=false;
            setSelecting(false);
            return;}
        var gloss=false;
        // Identify when the target is a gloss
        if ((typeof target === 'string')&&(mbID(target))) 
            target=mbID(target);
        else if ((typeof target === 'string')&&
                 (metaBook.glossdb.probe(target))) {
            gloss=metaBook.glossdb.ref(target);
            target=mbID(gloss.frag);}
        else if (target._db===metaBook.glossdb) {
            gloss=target; target=mbID(gloss.frag);}
        else {}
        if ((gloss)&&(form)&&(!(form.nodeType))) {
            // Passing a non-false non-node as a form forces a
            // response, even if the user is the maker of the gloss
            form=getGlossForm(gloss,true);}
        // Handle or create the form
        if (form) {
            var frag=fdjtDOM.getInput(form,"FRAG");
            if (frag.value!==target.id) {
                setExcerpt(form,false);
                fdjtDOM.addClass(getParent(form,".metabookglossform"),"modified");
                frag.value=target.id;}}
        else {
            if (gloss) form=getGlossForm(gloss);
            else form=getGlossForm(target);
            if (!(form)) {
                fdjtUI.alert("There was a problem adding a gloss");
                return false;}}
        metaBook.glosstarget=target;
        // Reset this when we actually get a gloss
        metaBook.select_target=false;
        addClass(target,"mbglosstarget");
        if (gloss.exoff)
            metaBook.GoTo({target: target,offset: gloss.exoff},"addgloss",true);
        else metaBook.GoTo(target,"addgloss",true);
        metaBook.setCloudCuesFromTarget(metaBook.gloss_cloud,target);
        setGlossForm(form);
        // Clear current selection and set up new selection
        setSelecting(false);
        metaBook.clearHighlights(target);
        if (selecting) setSelecting(selecting);
        else setSelecting(selectText(target));
        if ((gloss)&&(gloss.excerpt)&&(gloss.excerpt.length))
            metaBook.selecting.setString(gloss.excerpt);
        else if (selecting) 
            updateExcerpt(form,selecting);
        else {}
        metaBook.selecting.onchange=function(){
            updateExcerpt(form,this);};
        return form;}
    metaBook.setGlossTarget=setGlossTarget;

    function glossModified(arg){
        var target=((arg.nodeType)?(arg):(fdjtUI.T(arg)));
        var form=getParent(target,"FORM");
        var div=getParent(form,".metabookglossform");
        if (div) addClass(div,"modified");}

    function setSelecting(selecting){
        if (metaBook.selecting===selecting) return;
        else if (metaBook.selecting) {
            if ((Trace.selection)||(Trace.glossing))
                fdjtLog("setSelecting, replacing %o with %o",
                        metaBook.selecting,selecting);
            metaBook.selecting.clear();}
        else {}
        metaBook.selecting=selecting;}
    metaBook.setSelecting=setSelecting;

    function updateExcerpt(form,sel){
        var info=sel.getInfo();
        if ((Trace.glossing)||(Trace.selection))
            fdjtLog("Updating excerpt for %o from %o: %s",
                    form,sel,sel.getString());
        if (!(info)) {
            metaBook.setExcerpt(form,false);
            return;}
        metaBook.setExcerpt(form,info.string,info.off);
        var start_target=getTarget(info.start,true);
        var new_target=((start_target)&&
                        (!(hasParent(metaBook.glosstarget,start_target)))&&
                        (start_target));
        if (new_target) {
            // When real_target is changed, we need to get a new EXOFF
            //  value, which we should probably get by passing real_target
            //  to a second call to getInfo (above)
            var input=fdjtDOM.getInput(form,"FRAG");
            input.value=new_target.id;
            if ((sel)&&(typeof info.off === "number")) {
                var offinput=fdjtDOM.getInput(form,"EXOFF");
                var newoff=sel.getOffset(new_target);
                offinput.value=newoff;}}}

    function selectText(passages,opts){
        if (passages.nodeType) passages=[passages];
        var dups=[];
        var i=0, lim=passages.length;
        while (i<lim) dups=dups.concat(metaBook.getDups(passages[i++]));
        if ((Trace.selection)||(Trace.glossing))
            fdjtLog("selectText %o, dups=%o",passages,dups);
        return new fdjt.UI.TextSelect(
            dups,{ontap: gloss_selecting_ontap,
                  onrelease: ((opts)&&(opts.onrelease)),
                  onslip: ((opts)&&(opts.onslip)),
                  fortouch: metaBook.touch,
                  holdmsecs: 150,
                  movethresh: 250});}
    metaBook.UI.selectText=selectText;

    function gloss_selecting_ontap(evt){
        evt=evt||window.event;
        if ((Trace.selection)||(Trace.glossing)||(Trace.gestures))
            fdjtLog("gloss_selecting_ontap %o, mode=%o, livegloss=%o",
                    evt,metaBook.mode,$ID("METABOOKLIVEGLOSS"));
        if (metaBook.mode!=="addgloss") 
            metaBook.setMode("addgloss",false);
        else if ((metaBook.modechange)&&
                 ((fdjtTime()-metaBook.modechange)<1500)) {}
        else metaBook.setHUD(false);
        fdjtUI.cancel(evt);
        return;}

    function setGlossForm(form){
        var cur=$ID("METABOOKLIVEGLOSS");
        if (cur) cur.id="";
        if (Trace.glossing)
            fdjtLog("setGlossForm %o <== %o",form,metaBook.glossform);
        if (!(form)) {
            metaBook.glossform=false;
            return;}
        form.id="METABOOKLIVEGLOSS";
        metaBook.glossform=form;
        $ID("METABOOKGLOSSBODYTEXT").value=
            fdjtDOM.getInputValue(form,"DETAIL")||"";
        var syncelt=getInput(form,"SYNC");
        syncelt.value=(metaBook.syncstamp+1);
        /* Do completions based on those input's values */
        metaBook.share_cloud.complete();
        metaBook.gloss_cloud.complete();}
    metaBook.setGlossForm=setGlossForm;

    function updateForm(form){
        var glossetc=getChild(form,".glossetc");
        fdjtUI.Overflow(glossetc);}

    function getTagline(target){
        var attrib=
            target.getAttributeNS("tagline","https://beingmeta.com/METABOOK/")||
            target.getAttributeNS("tagline","https://metabooks.net/")||
            target.getAttributeNS("tagline","https://sbooks.net/")||
            target.getAttribute("data-tagline")||
            target.getAttribute("tagline");
        if (attrib) return attrib;
        var text=fdjtDOM.textify(target);
        if (!(text)) return false;
        text=fdjtString.stdspace(text);
        if (text.length>40) return text.slice(0,40)+"...";
        else return text;}
    
    /***** Adding outlets ******/

    function addOutlet(form,outlet,formvar,checked) {
        if (typeof checked === 'undefined') checked=true;
        var wrapper=getParent(form,".metabookglossform");
        addClass(wrapper,"modified");
        if (Trace.glossing)
            fdjtLog(
                "addOutlet wrapper=%o form=%o outlet=%o formvar=%o checked=%o",
                wrapper,form,outlet,formvar,checked);
        var outletspan=getChild(form,".outlets");
        var outlet_id=((typeof outlet === 'string')?(outlet):(outlet._id));
        if (typeof outlet === 'string') {
            if ((outlet[0]==='@')||
                ((outlet[0]===':')&&(outlet[0]==='@')))
                outlet=metaBook.sourcedb.ref(outlet);
            else {
                outlet={name: outlet};
                spanspec="span.checkspan.email";
                if (!(formvar)) formvar="EMAIL";}}
        else if (outlet.nodeType) {
            if (!(formvar)) formvar="NETWORK";
            outlet_id=outlet.getAttribute("data-value");
            outlet={name: outlet.getAttribute("data-key")||outlet_id};}
        else {}
        if (!(formvar)) formvar="SHARE";
        var inputs=getInputs(form,formvar);
        var i=0; var lim=inputs.length;
        while (i<lim) {
            if (inputs[i].value===outlet_id) {
                var current_checkspan=getParent(inputs[i],".checkspan");
                setCheckSpan(current_checkspan,checked);
                return current_checkspan;}
            else i++;}
        var spanspec=(
            "span.checkspan.waschecked.ischecked.outlet."+
                formvar.toLowerCase());
        var checkspan=fdjtUI.CheckSpan(
            spanspec,formvar||"SHARE",outlet_id,checked,
            fdjtDOM.Image(mbicon("share",32,32),"img.share","↣"),
            outlet.nick||outlet.name,
            fdjtDOM.Image(mbicon("redx",32,32),"img.redx","x"));
        if ((outlet.nick)&&(outlet.description))
            checkspan.title=outlet.name+": "+outlet.description;
        else if (outlet.description)
            checkspan.title=outlet.description;
        else checkspan.title=outlet.name;
        fdjtDOM(outletspan,checkspan," ");
        dropClass(outletspan,"empty");
        return checkspan;}
    metaBook.addOutlet2Form=addOutlet;

    function clearOutlets(form){
        var outletspan=getChild(form,".outlets");
        fdjtDOM.replace(outletspan,fdjtDOM("span.outlets"));}
    function resetOutlets(form){
        var outletspan=getChild(form,".outlets");
        var outlets=getChildren(outletspan,".checkspan");
        var i=0, lim=outlets.length;
        while (i<lim) {
            var span=outlets[i++];
            setCheckSpan(span,false);}}
    
    /***** Adding links ******/
    
    function addLink(form,url,title,replace) {
        var linkselt=getChild(form,'.links');
        var linkval=((title)?(url+" "+title):(url));
        var type=metaBook.urlType(url);
        var icon=metaBook.typeIcon(type);
        var img=fdjtDOM.Image(icon,"img");
        var text=fdjtDOM("span.linktext",((title)||url));
        var checkbox=fdjtDOM.Checkbox("LINKS",linkval,true);
        var aspan=fdjtDOM(
            "span.checkspan.ischecked.waschecked.glosslink",
            img,checkbox,text);
        aspan.title=title||url; aspan.setAttribute("data-href",url);
        if (url.search(/https:\/\/glossdata./)===0)
            addClass(aspan,"glossdata");
        if (type) addClass(aspan,metaBook.mediaTypeClass(type));
        var wrapper=getParent(form,".metabookglossform");
        if (Trace.glossing)
            fdjtLog("addOutlet wrapper=%o form=%o url=%o title=%o",
                    wrapper,form,url,title);
        addClass(wrapper,"modified");
        if (replace)
            fdjtDOM.replace(replace,aspan);
        else fdjtDOM(linkselt,aspan," ");
        dropClass(linkselt,"empty");
        updateForm(form);
        return aspan;}

    function changeLink(form,oldlink,newlink,title){
        var exists=fdjtDOM.getChild(form,"[data-href='"+oldlink+"']");
        addLink(form,newlink,title,exists);}

    /***** Adding excerpts ******/
    
    function setExcerpt(form,excerpt,off) {
        var wrapper=getParent(form,".metabookglossform");
        var excerpt_span=getChild(form,'.excerpt'), changed=false;
        var input=getInput(form,'EXCERPT'), exoff=getInput(form,'EXOFF');
        if ((!(excerpt))||(fdjtString.isEmpty(excerpt))) {
            if (input.value) changed=true;
            input.value=""; exoff.value="";
            input.disabled=exoff.disabled=true;
            if (excerpt_span) excerpt_span.innerHTML="";}
        else {
            input.disabled=exoff.disabled=false;
            input.value=excerpt; changed=true;
            if (typeof off === "number") exoff.value=off;
            else {exoff.value="";exoff.disabled=true;}
            if (excerpt_span) {
                excerpt_span.innerHTML=trim_excerpt(excerpt);
                excerpt_span.title=excerpt;}}
        if ((Trace.glossing)||(Trace.selecting))
            fdjtLog("setExcerpt %o form=%o excerpt=%o off=%o",
                    wrapper,form,excerpt,off);
        updateForm(form);
        if (changed) addClass(wrapper,"modified");
        return;}
    metaBook.setExcerpt=setExcerpt;

    function trim_excerpt(string,lim){
        var len=string.length; if (!(lim)) lim=20; 
        if (len<lim) return string;
        var words=string.split(/\s+/), nwords=words.length;
        if (words.length<3)
            return (string.slice(0,Math.floor(lim/2))+"..."+
                    string.slice(Math.floor(len-(lim/2))));
        var left=1, left_len=words[0].length+1;
        var right=nwords-2, right_len=words[nwords-1].length+1;
        while ((left<right)&&((left_len+right_len)<lim)) {
            left_len+=words[left++].length;
            right_len+=words[right--].length;}
        return words.slice(0,left).join(" ")+"..."+
            words.slice(right).join(" ");}

    /***** Adding tags ******/

    function addTag(form,tag,varname,checked,knodule) {
        // fdjtLog("Adding %o to tags for %o",tag,form);
        var prefix=false;
        if (!(tag)) tag=form;
        if (tag.prefix) {prefix=tag.prefix; tag=tag.tag;}
        if (form.tagName!=='FORM')
            form=getParent(form,'form')||form;
        if (!(knodule)) knodule=metaBook.getMakerKnodule(metaBook.user);
        if (typeof checked==="undefined") checked=true;
        var wrapper=getParent(form,".metabookglossform");
        if (Trace.glossing)
            fdjtLog(
                "AddTag %o form=%o tag=%o var=%o checked=%o kno=%o",
                wrapper,form,tag,varname,checked,knodule);
        addClass(wrapper,"modified");
        var tagselt=getChild(form,'.tags');
        var title=false; var textspec='span.term';
        if (!(varname)) varname='TAGS';
        if ((tag.nodeType)&&(hasClass(tag,'completion'))) {
            if (hasClass(tag,'outlet')) {
                varname='SHARED'; textspec='span.outlet';}
            else if (hasClass(tag,'source')) {
                varname='SHARE'; textspec='span.source';}
            else {}
            if (tag.title) title=tag.title;
            tag=metaBook.gloss_cloud.getValue(tag);}
        var ref=
            ((tag instanceof Ref)?(tag):
             ((typeof tag === 'string')&&
              (knodule.handleSubjectEntry(tag))));
        var text=
            ((ref)?
             (((ref.toHTML)&&(ref.toHTML()))||
              ref.name||ref.dterm||ref.title||ref.norm||
              ((typeof ref.EN === "string")||(ref.EN))||
              ((ref.EN instanceof Array)||(ref.EN[0]))||
              ref._qid||ref._id):
             (typeof tag === "string")?(tag):
             (tag.toString()));
        var tagval=tag;
        if (ref) {
            if (ref.knodule===knodule) tagval=ref.dterm;
            else tagval=ref._qid||ref.getQID();}
        if (prefix) tagval=prefix+tagval;
        if ((ref)&&(ref._db===metaBook.sourcedb)) varname='SHARED';
        var checkspans=getChildren(tagselt,".checkspan");
        var i=0; var lim=checkspans.length;
        while (i<lim) {
            var cspan=checkspans[i++];
            if (((cspan.getAttribute("data-varname"))===varname)&&
                ((cspan.getAttribute("data-tagval"))===tagval)) {
                if (checked) addClass(cspan,"waschecked");
                return cspan;}}
        var span=fdjtUI.CheckSpan("span.checkspan",varname,tagval,checked);
        if (checked) addClass(span,"waschecked");
        if (title) span.title=title;
        span.setAttribute("data-varname",varname);
        span.setAttribute("data-tagval",tag);
        addClass(span,("glosstag"));
        addClass(span,((varname.toLowerCase())+"var"));
        if (typeof text === 'string')
            fdjtDOM.append(span,fdjtDOM(textspec,text));
        else fdjtDOM.append(span,text);
        fdjtDOM.append(
            span,fdjtDOM.Image(mbicon("redx",32,32),"img.redx","x"));
        fdjtDOM.append(tagselt,span," ");
        dropClass(tagselt,"empty");
        updateForm(form);
        return span;}
    metaBook.addTag2Form=addTag;

    metaBook.setGlossNetwork=function(form,network,checked){
        if (typeof form === 'string') form=$ID(form);
        if (!(form)) return;
        var input=getInput(form,'NETWORKS',network);
        if (!(input)) return;
        var cs=getParent(input,".checkspan");
        if (!(cs)) return;
        setCheckSpan(cs,checked);};

    /* Text handling for the gloss text input */

    // An inline tag is of the form #<txt> or @<txt> where <txt> is
    //  either
    //  1. a word without spaces or terminal punctuation
    //  2. a string wrapped in delimiters, including
    //      "xx" 'yy' /zz/ [ii] (jj) {kk} «aa»
    var tag_delims={"\"": "\"", "'": "'", "/": "/","<":">",
                    "[": "]","(":")","{":"}","«":"»"};
    var tag_ends=/["'\/\[(<{}>)\]«»]/g;
    
    // Keep completion calls from clobbering one another
    var glossinput_timer=false;
    
    // Find the tag overlapping pos in string
    // Return a description of the tag
    function findTag(string,pos,partialok,nospaces){
        if ((string)&&(string.length)&&(pos>0)) {
            var space=false, start=pos-1, delim=false, need=false;
            var c=string[start], pc=string[start-1], cstart=start;
            while (start>=0) {
                if (pc==='\\') {}
                else if (/\s/.test(c)) space=start;
                else if ((c==='@')||(c==='#')) break;
                else if (start===0) return false;
                start--; c=pc; pc=string[start-1];}
            var prefix=string[start];
            var sc=string[start+1], end=string.length;
            if (tag_delims[sc]) {
                var matching=tag_delims[sc]; delim=sc; cstart=start+2;
                var match_off=string.slice(start+2).indexOf(matching);
                if (match_off<0) {
                    if (partialok) {end=pos; need=matching;}
                    else return false;}
                else end=start+2+match_off;
                if (end<pos) return false;}
            else if ((nospaces)&&(space)) return false;
            else {
                var end_off=string.slice(start).search(tag_ends);
                if (end_off>0) end=start+end_off;
                cstart=start+1;}
            var result={text: string.slice(start,end),
                        start: start,end: end,pos: pos,prefix: prefix,
                        content: (((delim)&&(need))?(string.slice(start+2,end)):
                                  (delim)?(string.slice(start+2,end-1)):
                                  (string.slice(start+1,end)))};
            if (delim) result.delim=delim;
            if ((delim)&&(partialok)) result.needs=tag_delims[delim];
            return result;}
        else return false;}
    metaBook.findTag=findTag;

    function tagclear(input_elt,pos){
        var text=input_elt.value;
        if (!(pos)) pos=input_elt.selectionStart;
        var info=findTag(text,pos);
        if (info) {
            input_elt.value=
                text.slice(0,info.start)+text.slice(info.end);}}

    function glossinput_onfocus(evt){
        var target=fdjtUI.T(evt);
        var text=target.value;
        var pos=target.selectionStart;
        var taginfo=findTag(text,pos);
        if ((Trace.glossing)||(Trace.gestures))
            fdjtLog("glossinput_onfocus %o text=%o pos=%o taginfo=%o",
                    evt,text,pos,taginfo);
        glossform_focus(evt);
        if (!(taginfo)) return;
        if (glossinput_timer) clearTimeout(glossinput_timer);
        glossinput_timer=setTimeout(function(){
            glosstag_complete(target);},150);}

    function glossinput_onkeypress(evt){
        var target=fdjtUI.T(evt), form=getParent(target,"FORM");
        var text=target.value, pos=target.selectionStart||0;
        var ch=evt.charCode, charstring=String.fromCharCode(ch);
        var taginfo=findTag(text,pos,true);

        if ((Trace.glossing)||(Trace.gestures>2))
            fdjtLog("glossinput_onkeypress '%o' %o text=%o pos=%o taginfo=%o",
                    ch,evt,text,pos,taginfo);
        if (ch!==13) {
            addClass(getParent(form,".metabookglossform"),"focused");
            addClass(getParent(form,".metabookglossform"),"modified");}
        if (ch===13) {
            if (taginfo) {
                // Remove tag text
                target.value=text.slice(0,taginfo.start)+
                    text.slice(taginfo.end);
                // Add a selection or tag as appropriate
                glosstag_done(target,taginfo.content,evt.ctrlKey,
                              taginfo.prefix==="@");
                fdjt.UI.cancel(evt);}
            else if (evt.shiftKey) {
                target.value=text.slice(0,pos)+"\n"+text.slice(pos);
                target.selectionStart++;
                return fdjtUI.cancel(evt);}
            else {
                fdjtUI.cancel(evt);
                submitGloss(form);}}
        else if (!(taginfo)) {}
        else if (tag_ends.test(charstring)) {
            // Handles tag closing, which is an implicit add tag
            taginfo=findTag(text,pos,true);
            if (!(taginfo)) return;
            else if (taginfo.needs===charstring) {
                target.value=text.slice(0,taginfo.start)+
                    text.slice(taginfo.end);
                glosstag_done(target,taginfo.content,evt.ctrlKey,
                              taginfo.prefix==="@");
                fdjtUI.cancel(evt);}
            else {}
            return;}
        else {
            if (glossinput_timer) clearTimeout(glossinput_timer);
            glossinput_timer=setTimeout(function(){
                glosstag_complete(target);},
                                        150);}}

    function glossinput_onkeydown(evt){
        var ch=evt.keyCode, target=fdjtUI.T(evt);
        if (ch===27) {
            metaBook.cancelGloss(); fdjtUI.cancel(evt);
            return;}
        else if ((ch===9)||(ch===13)) {
            var form=getParent(target,"FORM"), text=target.value;
            var pos=target.selectionStart||0, taginfo=findTag(text,pos,true);
            var cloud=((taginfo.prefix==="@")?
                       (metaBook.share_cloud):
                       (metaBook.gloss_cloud));
            if ((Trace.glossing)||(Trace.gestures>2))
                fdjtLog("glossinput_onkeydown '%o' %o taginfo=%o cloud=%o",
                        ch,evt,taginfo,cloud);
            if (!(taginfo)) return;
            else if (ch===9) {
                var content=taginfo.content;
                cloud.complete(content);
                if ((cloud.prefix)&&(cloud.prefix!==content)) {
                    var replace_start=taginfo.start+((taginfo.delim)?(2):(1));
                    var replace_end=taginfo.end-((taginfo.needs)?(0):(1));
                    if (cloud.prefix.search(/\s/)>=0)
                        target.value=text.slice(0,replace_start)+
                        ((taginfo.delim)?(""):("\""))+cloud.prefix+
                        ((taginfo.needs)?(taginfo.needs):(""))+
                        text.slice(replace_end);
                    else target.value=
                        text.slice(0,replace_start)+cloud.prefix+
                        text.slice(replace_end);
                    return;}
                else if (evt.shiftKey) cloud.selectPrevious();
                else cloud.selectNext();
                fdjtUI.cancel(evt);}
            else if (cloud.selection) {
                if (taginfo.prefix==="@") {
                    var outlet=cloud.selection.getAttribute("data-value");
                    metaBook.addOutlet2Form(form,outlet,"SHARE");}
                else metaBook.addTag2Form(form,cloud.selection);
                target.value=text.slice(0,taginfo.start)+
                    text.slice(taginfo.end);
                dropClass("METABOOKHUD",/gloss(tagging|tagoutlet)/g);
                setTimeout(function(){cloud.complete("");},10);
                cloud.clearSelection();
                fdjtUI.cancel(evt);}
            else {}}
        else if ((ch===8)||(ch===46)||((ch>=35)&&(ch<=40))) {
            // These may change content, so we update the completion state
            glossModified(evt);
            if (glossinput_timer) clearTimeout(glossinput_timer);
            glossinput_timer=setTimeout(function(){
                glosstag_complete(target);},150);}}

    function glosstag_complete(input_elt){
        var text=input_elt.value;
        var pos=input_elt.selectionStart||0;
        var taginfo=findTag(text,pos,true);
        if (taginfo) {
            var completions;
            var isoutlet=(taginfo.prefix==="@");
            if (isoutlet)
                swapClass(
                    "METABOOKHUD",/gloss(tagging|tagoutlet)/g,"glosstagoutlet");
            else swapClass(
                "METABOOKHUD",/gloss(tagging|tagoutlet)/g,"glosstagging");
            if (isoutlet)
                completions=metaBook.share_cloud.complete(taginfo.content);
            else completions=metaBook.gloss_cloud.complete(taginfo.content);
            if (Trace.glossing)
                fdjtLog("Got %d completions for %s",
                        completions.length,taginfo.content);}
        else dropClass("METABOOKHUD",/gloss(tagging|addoutlet)/g);}

    function glosstag_done(input_elt,tagtext,personal,isoutlet){
        var form=getParent(input_elt,"FORM"), tag=false;
        if ((!(isoutlet))&&(personal)) 
            tag=metaBook.knodule.def(tagtext);
        else if (tagtext.indexOf('|')>0) {
            if (isoutlet) 
                fdjtLog.warn("Can't define outlets (sources) from %s",tagtext);
            else tag=metaBook.knodule.def(tagtext);}
        else {
            var cloud=((isoutlet)?(metaBook.share_cloud):(metaBook.gloss_cloud));
            var completions=cloud.complete(tagtext);
            if (completions.length===0) {}
            else if (completions.length===1) tag=completions[0];
            else {}
            if ((isoutlet)&&(!(tag))) 
                fdjtLog.warn("Unknown outlet %s",tagtext);
            else if (isoutlet) addOutlet(form,tag);
            else if (!(tag)) {
                tag=metaBook.knodule.ref(tagtext);
                if (tag) addTag(form,tag);
                else addTag(form,tagtext);}
            else addTag(form,tag);}
        dropClass("METABOOKHUD",/gloss(tagging|addoutlet)/);}
    
    function getTagString(span,content){
        var tagval=span.getAttribute("data-tagval");
        if (tagval) {
            var at=tagval.indexOf('@');
            if ((metaBook.knodule)&&(at>0)&&
                (tagval.slice(at+1)===metaBook.knodule.name))
                return tagval.slice(0,at);
            else return tagval;}
        else {
            var bar=content.indexOf('|');
            if (bar>0) return content.slice(0,bar);
            else return content;}}

    var stdspace=fdjtString.stdspace;

    function handleTagInput(tagstring,form,exact){
        var isoutlet=(tagstring[0]==="@");
        var cloud=((isoutlet)?(metaBook.share_cloud):(metaBook.gloss_cloud));
        var text=(((tagstring[0]==='@')||(tagstring[0]==='#'))?
                  (tagstring.slice(1)):(tagstring));
        var completions=cloud.complete(text);
        var std=stdspace(text);
        if (isoutlet) {
            var oc=[]; var j=0, jlim=completions.length; while (j<jlim) {
                var c=completions[j++];
                if (hasClass(c,"outlet")) oc.push(c);}
            completions=oc;}
        if ((!(completions))||(completions.length===0)) {
            if (isoutlet) addOutlet(form,std); // Should probably just warn
            else addTag(form,std);
            cloud.complete("");
            return std;}
        else {
            var completion=false;
            if (completions.length===1)
                completion=completions[0];
            else if ((completions.exact)&&
                     (completions.exact.length===1))
                completion=completions.exact[0];
            else {
                // Multiple completions
                completion=completions[0];
                var i=0, lim=completions.length;
                while (i<lim) {
                    var mc=completions[i++];
                    if (mc!==completion) {completion=false; break;}}}
            if ((completion)&&(completion===completions[0])) {
                var ks=metaBook.gloss_cloud.getKey(completions.matches[0]);
                if ((exact)?(ks.toLowerCase()!==std.toLowerCase()):
                    (ks.toLowerCase().search()!==0)) {
                    // When exact is true, count on exact matches;
                    // even if it is false, don't except non-prefix
                    // matches
                    addTag(form,std);
                    metaBook.gloss_cloud.complete("");
                    return std;}}
            if (completion) {
                var span=addTag(form,completion);
                metaBook.gloss_cloud.complete("");
                return getTagString(span,metaBook.gloss_cloud.getKey(completion));}
            else {
                addTag(form,std);
                metaBook.gloss_cloud.complete("");
                return std;}}}
    metaBook.handleTagInput=handleTagInput;

    function get_addgloss_callback(form,keep,uri){
        return function(req){
            return addgloss_callback(req,form,keep,uri);};}

    function addgloss_callback(req,form,keep){
        if ((Trace.network)||(Trace.glossing))
            fdjtLog("Got AJAX gloss response %o from %o",
                    req,req.responseURL);
        if (Trace.savegloss)
            fdjtLog("Gloss %o successfully added (status %d) to %o",
                    getInput(form,"UUID").value,req.status,
                    getInput(form,"FRAG").value);
        dropClass(form.parentNode,"submitting");
        if ((req.status<200)||(req.status>=300)) {
            addClass(form.parentNode,"submitfailed");
            if (req.status===403)
                fdjt.Dialog.alert(
                    "Sorry, you're not allowed to save this gloss");
            else fdjt.Dialog.alert("There was a problem saving your gloss");
            if ((form.parentNode)&&(form.parentNode))
                fdjtDOM.remove(form.parentNode);
            setGlossTarget(false);
            metaBook.setTarget(false);
            metaBook.setMode(false);
            return;}
        if (keep)
            addClass(form.parentNode,"submitdone");
        else {
            addClass(form.parentNode,"submitclose");
            metaBook.setHUD(false,false);}
        var json=JSON.parse(req.responseText);
        var ref=metaBook.glossdb.Import(
            // item,rules,flags
            json,false,((RefDB.REFINDEX)|(RefDB.REFSTRINGS)|(RefDB.REFLOAD)));
        var reps=document.getElementsByName(ref._id);
        var i=0, lim=reps.length;
        while (i<lim) {
            var rep=reps[i++];
            if (hasClass(rep,"metabookcard")) {
                var new_card=metaBook.renderCard(ref);
                if (new_card) fdjtDOM.replace(rep,new_card);}}
        ref.save();
        if (metaBook.selecting) {
            if (metaBook.selecting.onclear)
                metaBook.selecting.onclear.push(function(){
                    metaBook.addGloss2UI(ref);});
            else metaBook.selecting.onclear=[function(){
                metaBook.addGloss2UI(ref);}];}
        /* Turn off the target lock */
        if ((form)&&(!(keep))) {
            setTimeout(function(){
                if (hasClass(form.parentNode,"submitclose")) {
                    if ((form.parentNode)&&(form.parentNode))
                        fdjtDOM.remove(form.parentNode);
                    setGlossTarget(false);
                    metaBook.setTarget(false);
                    metaBook.setMode(false);}},
                       1500);}
        else if (form)
            setTimeout(function(){
                dropClass(form.parentNode,"submitdone");},
                       1500);
        else {}}

    function clearGlossForm(form){
        // Clear the UUID, and other fields
        var uuid=getInput(form,"UUID");
        if (uuid) uuid.value="";
        var note=getInput(form,"NOTE");
        if (note) note.value="";
        var href=getInput(form,"HREF");
        if (href) href.value="";
        var tagselt=getChildren(form,".tags");
        if ((tagselt)&&(tagselt.length)) {
            var tags=getChildren(tagselt[0],".checkspan");
            fdjtDOM.remove(fdjtDOM.Array(tags));}}

    /***** The Gloss Cloud *****/

    function glosscloud_select(evt){
        var target=fdjtUI.T(evt);
        var completion=getParent(target,'.completion');
        if (completion) {
            var live=$ID("METABOOKLIVEGLOSS");
            var form=((live)&&(getChild(live,"form")));
            var span=addTag(form,completion);
            if (!(hasClass("METABOOKHUD","glossaddtag"))) {
                // This means we have a bracketed reference
                var tagstring=getTagString(
                    span,metaBook.gloss_cloud.getKey(completion));
                var input=getInput(form,"NOTE");
                if ((input)&&(tagstring)) tagclear(input);}}
        fdjtUI.cancel(evt);}
    metaBook.UI.handlers.glosscloud_select=glosscloud_select;

    /***** The Outlet Cloud *****/

    function sharecloud_ontap(evt){
        var target=fdjtUI.T(evt);
        var completion=getParent(target,'.completion');
        if (completion) {
            var live=$ID("METABOOKLIVEGLOSS");
            var form=((live)&&(getChild(live,"form")));
            var value=completion.getAttribute("data-value");
            if (hasClass(completion,"source")) {
                if (value) addOutlet(form,metaBook.sourcedb.ref(value),"SHARE");}
            else if (hasClass(completion,"network")) 
                addOutlet(form,completion,"NETWORK");
            else if (hasClass(completion,"email")) 
                if (value) addOutlet(form,completion,"EMAIL");
            else addOutlet(form,completion);}
        fdjtUI.cancel(evt);}
    metaBook.UI.sharecloud_ontap=sharecloud_ontap;

    /***** Saving (submitting/queueing) glosses *****/

    var login_message=false;

    // Submits a gloss, queueing it if offline.
    function submitGloss(arg,keep){
        var div=false, form=false;
        if (typeof arg === "undefined") {
            div=$ID("METABOOKLIVEGLOSS");
            if (!(div)) return;
            form=getChild(div,"FORM");}
        else {
            if (!(arg.nodeType)) arg=fdjtUI.T(arg);
            if ((arg.nodeType)&&(arg.nodeType===1)&&
                (arg.tagName==="FORM")) {
                form=arg; div=getParent(form,".metabookglossform");}
            else if ((arg.nodeType)&&(arg.nodeType===1)&&
                     (arg.tagName==="DIV")&&(hasClass(arg,"metabookglossform"))) {
                div=arg; form=getChild(div,"FORM");}}
        if (!(form)) return;
        var detail_elt=getInput(form,"DETAIL");
        var glossbodytext=$ID("METABOOKGLOSSBODYTEXT");
        detail_elt.value=glossbodytext.value||"";
        addClass(div,"submitting");
        if (!((hasParent(form,".glossedit"))||
              (hasParent(form,".glossreply"))))
            // Only save defaults if adding a new gloss
            saveGlossDefaults(
                form,getChild("METABOOKADDGLOSSPROTOTYPE","FORM"));
        var uuidelt=getInput(form,"UUID");
        if (!((uuidelt)&&(uuidelt.value)&&(uuidelt.value.length>5))) {
            fdjtLog.warn('missing UUID');
            if (uuidelt) uuidelt.value=fdjtState.getUUID(metaBook.nodeid);}
        var note_input=getInputs(form,"NOTE")[0];
        if (note_input.value.search(uri_prefix)===0) {
            // This is a convenience kludge where notes that look like
            // URLs are stored as links.
            var note=note_input.value;
            var brk=note.search(/\s/);
            if (brk<0) addLink(form,note);
            else addLink(form,note.slice(0,brk),note.slice(brk+1));
            note_input.value="";}
        if ((!(login_message))&&
            ((!(navigator.onLine))||(!(metaBook.connected)))) {
            var choices=[];
            if (navigator.onLine) 
                choices.push({label: "Login",
                              isdefault: true,
                              handler: function(){
                                  setTimeout(function()
                                             {metaBook.setMode("login");},0);
                                  var resubmit=function(){
                                      submitGloss(form,keep);};
                                  if (metaBook._onconnect)
                                      metaBook._onconnect.push(resubmit);
                                  else metaBook._onconnect=[resubmit];
                                  login_message=true;}});
            if ((metaBook.user)&&(metaBook.persist)) 
                choices.push({label: "Queue",
                              isdefault: ((!(navigator.onLine))&&
                                          (metaBook.cacheglosses)),
                              handler: function(){
                                  if (metaBook.nocache)
                                      metaBook.setConfig("cacheglosses",true);
                                  login_message=true;
                                  if (!((navigator.onLine)&&(metaBook.connected)))
                                      queueGloss(form,false,keep);
                                  else submitGloss(form,keep);}});
            else {
                choices.push({label: "Cache",
                              isdefault: ((!(navigator.onLine))&&
                                          (metaBook.cacheglosses)),
                              handler: function(){
                                  if (metaBook.nocache)
                                      metaBook.setConfig("cacheglosses",true,true);
                                  login_message=true;
                                  queueGloss(form,false,keep);}});
                if (metaBook.nocache)
                    choices.push({label: "Lose",
                                  isdefault:((!(navigator.onLine))&&
                                             (metaBook.nocache)),
                                  handler: function(){
                                      tempGloss(form); login_message=true;}});}
            choices.push({label: "Cancel",
                          handler: function(){
                              fdjtDOM.remove(form.parentNode);
                              setGlossTarget(false);
                              metaBook.setTarget(false);
                              metaBook.setMode(false);}});
            fdjtUI.choose(choices,
                          ((navigator.onLine)&&(!(metaBook.user))&&
                           ([fdjtDOM("p.smaller",
                                     "This book isn't currently associated with an sBooks account, ",
                                     "so any highlights or glosses you add will not be permanently saved ",
                                     "until you login."),
                             fdjtDOM("p.smaller",
                                     "You may either login now, cache your changes ",
                                     "on this machine until you do login, ",
                                     "lose your changes when this page closes, ",
                                     "or cancel the change you're about to make.")])),
                          (((navigator.onLine)&&(metaBook.user)&&
                            ([fdjtDOM("p.smaller",
                                      "You aren't currently logged into your sBooks account from ",
                                      "this machine, so any highlights or glosses you add won't ",
                                      "be saved until you do."),
                              fdjtDOM("p.smaller","In addition, you won't get updated glosses from ",
                                      "your networks or layers."),
                              fdjtDOM("p.smaller",
                                      "You may either login now, queue any changes you make until ",
                                      "you do login, or cancel the change you were trying to make.")]))),
                          ((!(navigator.onLine))&&(metaBook.nocache)&&
                           ([fdjtDOM("p.smaller",
                                     "You are currently offline and have elected to not save ",
                                     "highlights or glosses locally on this computer."),
                             fdjtDOM("p.smaller",
                                     "You can either queue your changes by storing information locally, ",
                                     "lose your changes when this page closes,",
                                     "or cancel the change you were about to make.")])));
            return;}
        var sent=((navigator.onLine)&&(metaBook.connected)&&(metaBook.user)&&
                  (fdjt.Ajax.onsubmit(form,get_addgloss_callback(form,keep))));
        if (!(sent)) queueGloss(form,((arg)&&(arg.type)&&(arg)),keep);
        else dropClass(div,"modified");}
    metaBook.submitGloss=submitGloss;

    function cancelGloss_handler(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        cancelGloss(target);
        fdjtUI.cancel(evt);}

    function cancelGloss(arg){
        var evt=arg||window.event||null;
        var target=((!arg)?($ID("METABOOKLIVEGLOSS")):
                    (arg.nodeType)?(arg):(fdjtUI.T(arg)));
        var glossform=(target)&&
            (fdjtDOM.getParent(target,".metabookglossform"));
        setGlossTarget(false);
        metaBook.setMode(false);
        if ((arg)&&((arg.cancelable)||(arg.bubbles))) {
            fdjtUI.cancel(evt);}
        if (glossform) fdjtDOM.remove(glossform);}
    metaBook.cancelGloss=cancelGloss;

    // We save gloss defaults on the prototype gloss form hidden in the DOM
    function saveGlossDefaults(form,proto){
        // Save gloss mode (??)
        var mode=form.className; var i, lim;
        swapClass(proto,glossmodes,mode);
        // Save post setting
        var post=getInput(form,"POSTGLOSS");
        var proto_post=getInput(form,"POSTGLOSS");
        setCheckSpan(proto_post,post.checked);
        // Save network settings
        var networks=getInputs(form,"NETWORKS");
        i=0; lim=networks.length; while (i<lim) {
            var network_input=networks[i++];
            var proto_input=getInputFor(form,"NETWORKS",network_input.value);
            setCheckSpan(proto_input,network_input.checked);}
        // Save outlets
        clearOutlets(proto);
        var shared=getChild(form,".outlets");
        var inputs=getChildren(shared,"INPUT");
        // Here's the logic: we save all checked outlets and any
        // others up to 5.
        i=0; lim=inputs.length; var n_others=0; while (i<lim) {
            var input=inputs[i++];
            if ((input.checked)||(n_others<=5)) {
                var checkspan=addOutlet(
                    proto,input.value,input.name,input.checked);
                if (input.checked) addClass(checkspan,"waschecked");
                else n_others++;}}}

    // These are for glosses saved only in the current session,
    // without using local storage.
    var queued_data={};

    // Queues a gloss when offline
    function queueGloss(form,evt,keep){
        // We use the JSON to update the local database and save the
        // params to send when we get online
        var json=fdjt.Ajax.formJSON(form,true);
        var params=fdjt.Ajax.formParams(form);
        var queued=metaBook.queued;
        queued.push(json.uuid);
        if (metaBook.cacheglosses) {
            fdjtState.setLocal("mB("+json.uuid+").params",params);
            fdjtState.setLocal(
                "mB("+mB.docid+").queued",queued,true);}
        else queued_data[json.uuid]=params;
        // Now save it to the in-memory database
        var glossdata=
            {refuri: json.refuri,frag: json.frag,
             _id: json.uuid,uuid: json.uuid,
             maker: json.user||metaBook.user,
             qid: json.uuid,gloss: json.uuid,
             created: ((json.created)||(fdjtTime()))};
        glossdata.tstamp=fdjtTime.tick();
        if ((json.note)&&(!(fdjtString.isEmpty(json.note))))
            glossdata.note=json.note;
        if ((json.excerpt)&&(!(fdjtString.isEmpty(json.excerpt)))) {
            glossdata.excerpt=json.excerpt;
            glossdata.exoff=json.exoff;}
        if ((json.detail)&&(!(fdjtString.isEmpty(json.detail))))
            glossdata.detail=json.detail;
        if ((json.tags)&&(json.tags.length>0)) glossdata.tags=json.tags;
        if ((json.xrefs)&&(json.xrefs.length>0)) glossdata.xrefs=json.xrefs;
        metaBook.glossdb.Import(
            glossdata,false,RefDB.REFLOAD|RefDB.REFSTRINGS|RefDB.REFINDEX,
            true);
        if (evt) fdjtUI.cancel(evt);
        dropClass(form.parentNode,"submitting");
        /* Turn off the target lock */
        if (!(keep)) {
            // Clear the UUID
            clearGlossForm(form);
            setGlossTarget(false);
            metaBook.setTarget(false);
            metaBook.setMode(false);}}

    // Creates a gloss which will go away when the page closes
    function tempGloss(form,evt){
        // We use the JSON to update the local database and save the
        // params to send when we get online
        var json=fdjt.Ajax.formJSON(form,true);
        // save it to the in-memory database
        var glossdata=
            {refuri: json.refuri,frag: json.frag,
             maker: json.user,_id: json.uuid,uuid: json.uuid,
             qid: json.uuid,gloss: json.uuid,
             created: fdjtTime()};
        glossdata.tstamp=fdjtTime.tick();
        if ((json.note)&&(!(fdjtString.isEmpty(json.note))))
            glossdata.note=json.note;
        if ((json.excerpt)&&(!(fdjtString.isEmpty(json.excerpt)))) {
            glossdata.excerpt=json.excerpt;
            glossdata.exoff=json.exoff;}
        if ((json.detail)&&(!(fdjtString.isEmpty(json.detail))))
            glossdata.detail=json.detail;
        if ((json.tags)&&(json.tags.length>0)) glossdata.tags=json.tags;
        if ((json.xrefs)&&(json.xrefs.length>0)) glossdata.xrefs=json.xrefs;
        metaBook.glossdb.Import(glossdata,false,false,true);
        // Clear the UUID
        clearGlossForm(form);
        if (evt) fdjtUI.cancel(evt);
        dropClass(form.parentNode,"submitting");
        /* Turn off the target lock */
        setGlossTarget(false);
        metaBook.setTarget(false);
        metaBook.setMode(false);}

    // Saves queued glosses
    function writeQueuedGlosses(){
        if (metaBook.queued.length) {
            var ajax_uri=getChild($ID("METABOOKADDGLOSSPROTOTYPE"),"form").
                getAttribute("ajaxaction");
            var queued=metaBook.queued; var glossid=queued[0];
            var post_data=((metaBook.nocache)?((queued_data[glossid])):
                           (fdjtState.getLocal("mB("+glossid+").params")));
            if (post_data) {
                var req=new XMLHttpRequest();
                req.open('POST',ajax_uri);
                req.withCredentials='yes';
                req.onreadystatechange=function () {
                    if ((req.readyState === 4) &&
                        (req.status>=200) && (req.status<300)) {
                        fdjtState.dropLocal("mB("+glossid+").params");
                        var pending=metaBook.queued;
                        if ((pending)&&(pending.length)) {
                            var pos=pending.indexOf(glossid);
                            if (pos>=0) {
                                pending.splice(pos,1);
                                if (metaBook.cacheglosses)
                                    fdjtState.setLocal(
                                        "mB("+mB.docid+").queued",pending,true);
                                metaBook.queued=pending;}}
                        addgloss_callback(req,false,false);
                        if (pending.length) setTimeout(writeQueuedGlosses,200);
                        fdjtState.dropLocal("mB("+mB.docid+").queued");}
                    else if (req.readyState===4) {
                        metaBook.setConnected(false);}
                    else {}};
                try {
                    req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                    req.send(post_data);}
                catch (ex) {metaBook.setConnected(false);}}}}
    metaBook.writeQueuedGlosses=writeQueuedGlosses;
    
    /* Glossform interaction */

    /**** Clicking on outlets *****/
    
    function glossform_outlets_tapped(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        if (getParent(target,".checkspan"))
            return fdjt.UI.CheckSpan.onclick(evt);
        else if (getParent(target,".sharing"))
            toggleClass(getParent(target,".sharing"),"expanded");
        else {}}
    metaBook.UI.glossform_outlets_tapped=glossform_outlets_tapped;

    function outlet_select(evt){
        var target=fdjtUI.T(evt);
        var outletspan=getParent(target,'.outlet')||
            getParent(target,'.source');
        if (!(outletspan)) return;
        var live=$ID("METABOOKLIVEGLOSS");
        var form=((live)&&(getChild(live,"form")));
        var outlet=metaBook.share_cloud.getValue(outletspan);
        metaBook.addOutlet2Form(form,outlet);
        fdjtUI.cancel(evt);}

    /* The addgloss menu */

    var slip_timeout=false;

    function glossmode_tap(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var alt=target.alt;
        
        if (!(alt)) return;

        var menu=getParent(target,'.addglossmenu');
        var form=getParent(target,'form');
        var div=getParent(form,"div.metabookglossform");
        
        if (alt==="downmenu") {
            addClass(menu,"expanded");
            dropClass(menu,"held");}
        else if (alt==="upmenu") {
            dropClass(menu,"expanded");
            dropClass(menu,"held");}
        else if (alt==="glossdelete") 
            addgloss_delete(menu,form,false,true);
        else if (alt==="glosscancel") 
            addgloss_cancel(menu,form,div);
        else if (alt==="glosspush") {
            metaBook.submitGloss(form,false);
            dropClass(menu,"expanded");}
        else if (alt==="glossupdate") {
            metaBook.submitGloss(form,false);
            dropClass(menu,"expanded");}
        else if (alt==="glossrespond") 
            addgloss_respond(menu,form);
        else if (alt==="glosscancel") {
            addgloss_cancel(menu,form,div);}
        else if (alt===form.className) {
            metaBook.setGlossMode(false,form);
            dropClass(menu,"expanded");}
        else if (metaBook.glossmodes.exec(alt)) {
            metaBook.setGlossMode(alt,form);
            dropClass(menu,"expanded");}
        else fdjtLog.warn("Bad alt=%s in glossmode_tap",alt);
        fdjtUI.cancel(evt);
        return;}

    function glossmode_hold(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var alt=target.alt;
        
        if (!(alt)) return;

        if (slip_timeout) {
            clearTimeout(slip_timeout);
            slip_timeout=false;}

        var menu=getParent(target,'.addglossmenu');
        
        if (hasClass(menu,"expanded")) {
            addClass(menu,"held");
            addClass(target,"held");}
        else {
            addClass(menu,"expanded");
            addClass(menu,"held");}}

    function glossmode_release(evt) {
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var menu=getParent(target,'.addglossmenu');
        var form=getParent(target,'form');
        var div=getParent(form,"div.metabookglossform");
        var alt=target.alt;
        dropClass(target,"held");
        if (hasClass(target,"menutop")) {
            metaBook.setGlossMode(false,form);}
        else if (alt==="glossdelete") 
            addgloss_delete(menu,form);
        else if (alt==="glosscancel") 
            addgloss_cancel(menu,form,div);
        else if (alt==="glosspush")
            metaBook.submitGloss(form,false);
        else if (alt==="glossupdate") {
            metaBook.submitGloss(form,false);}
        else if (alt==="glossrespond") 
            addgloss_respond(menu,form);
        else if (metaBook.glossmodes.exec(alt))
            metaBook.setGlossMode(alt,form);
        else fdjtLog.warn("Bad alt=%s in glossmode_release",alt);
        dropClass(menu,"expanded");
        dropClass(menu,"held");}

    function glossmode_slip(evt) {
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var menu=getParent(target,'.addglossmenu');
        dropClass(target,"held");
        if (!(slip_timeout)) {
            slip_timeout=setTimeout(function(){
                dropClass(menu,"expanded");},
                                    500);}}

    function addgloss_delete(menu,form,div,noprompt){
        if (!(form)) form=getParent(menu,"FORM");
        if (!(div)) div=getParent(form,".metabookglossform");
        var modified=fdjtDOM.hasClass(div,"modified");
        // This keeps it from being saved when it loses the focus
        dropClass(div,"modified");
        dropClass(menu,"expanded");
        var uuid=getInputValues(form,"UUID")[0];
        var gloss=metaBook.glossdb.probe(uuid);
        if ((!(gloss))||(!(gloss.created))) {
            delete_gloss(uuid);
            metaBook.setMode(false);
            fdjtDOM.remove(div);
            setGlossTarget(false);
            metaBook.setTarget(false);
            return;}
        if (noprompt) {
            delete_gloss(uuid);
            metaBook.setMode(false);
            fdjtDOM.remove(div);
            setGlossTarget(false);
            metaBook.setTarget(false);
            return;}
        fdjt.UI.choose([{label: "Delete",
                         handler: function(){
                             delete_gloss(uuid);
                             metaBook.setMode(false);
                             fdjtDOM.remove(div);
                             setGlossTarget(false);
                             metaBook.setTarget(false);},
                         isdefault: true},
                        {label: "Cancel"}],
                       ((modified)?
                        ("Delete this gloss?  Discard your changes?"):
                        ("Delete this gloss?")),
                       fdjtDOM(
                           "div.smaller",
                           "(Created ",
                           fdjtTime.shortString(gloss.created),
                           ")"));}

    function addgloss_cancel(menu,form,div){
        if (!(form)) form=getParent(menu,"FORM");
        if (!(div)) div=getParent(form,".metabookglossform");
        metaBook.cancelGloss();
        metaBook.setMode(false);
        fdjtDOM.remove(div);
        setGlossTarget(false);
        metaBook.setTarget(false);
        return;}

    function addgloss_respond(target){
        var block=getParent(target,".metabookglossform");
        if (!(block)) return;
        var glosselt=getInput(block,'UUID');
        if (!(glosselt)) return;
        var qref=glosselt.value;
        var gloss=metaBook.glossdb.probe(qref);
        if (!(gloss)) return;
        var form=setGlossTarget(gloss,metaBook.getGlossForm(gloss,true));
        if (!(form)) return;
        metaBook.setMode("addgloss");}
    
    /* Changing gloss networks */
    
    function changeGlossNetwork(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var alternate=$ID(
            (fdjtDOM.hasParent(target,".metabookglossform"))?
                ("METABOOKNETWORKBUTTONS"):(("METABOOKLIVEGLOSS")));
        var doppels=getInputsFor(alternate,'NETWORK',target.value);
        fdjtUI.CheckSpan.set(doppels,target.checked);}
    metaBook.UI.changeGlossNetwork=changeGlossNetwork;

    function changeGlossPosting(evt){
        var target=fdjtUI.T(evt=(evt||window.event));
        var glossdiv=getParent(target,".metabookglossform");
        if (target.checked) fdjtDOM.addClass(glossdiv,"posted");
        else fdjtDOM.dropClass(glossdiv,"posted");}
    metaBook.UI.changeGlossPosting=changeGlossPosting;

    function changeGlossPrivacy(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt=(evt||window.event));
        var glossdiv=getParent(target,".metabookglossform");
        var postgloss=getChild(glossdiv,".postgloss");
        var postinput=(postgloss)&&(getInput(postgloss,"POSTGLOSS"));
        if (postgloss) {
            if (target.checked) {
                if (postinput) postinput.disabled=true;}
            else {
                if (postinput) postinput.disabled=false;}}
        if (target.checked) fdjtDOM.addClass(glossdiv,"private");
        else fdjtDOM.dropClass(glossdiv,"private");}
    metaBook.UI.changeGlossPrivacy=changeGlossPrivacy;

    /* New simpler UI */

    var gloss_focus=false;
    var gloss_blurred=false;
    var gloss_blur_timeout=false;

    function glossform_focus(evt){
        evt=evt||window.event;
        gloss_blurred=false;
        var target=fdjtUI.T(evt);
        var form=getParent(target,"FORM");
        var div=((form)&&(getParent(form,".metabookglossform")));
        var input=((div)&&(getChild(div,"TEXTAREA")));
        if (div) {
            metaBook.setGlossMode(false);}
        if (input) metaBook.setFocus(input);
        metaBook.setHUD(true);
        metaBook.freezelayout=true;
        gloss_focus=form;}
    metaBook.UI.glossFormFocus=glossform_focus;
    function glossform_blur(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var form=getParent(target,"FORM");
        var div=((form)&&(getParent(form,".metabookglossform")));
        var input=((div)&&(getChild(div,"TEXTAREA")));
        if (div) dropClass(div,"focused");
        if (input) metaBook.clearFocus(input);
        metaBook.setHUD(false,false);
        gloss_blurred=fdjtTime();
        metaBook.freezelayout=false;
        // Restore this without removal of the gloss
        // if ((div)&&(hasClass(div,"modified"))) metaBook.submitGloss(div);
        gloss_focus=false;}
    function glossform_touch(evt){
        evt=evt||window.event;
        if (gloss_blur_timeout) clearTimeout(gloss_blur_timeout);
        var target=fdjtUI.T(evt);
        var closing=getParent(target,".submitclose");
        if (closing) dropClass(closing,"submitclose");
        var form=getParent(target,"FORM");
        var div=((form)&&(getParent(form,".metabookglossform")));
        var input=((div)&&(getChild(div,"TEXTAREA")));
        if (hasClass(div,"focused")) {
            setTimeout(function(){
                if (input) {
                    metaBook.setFocus(input);
                    input.focus();}},
                       150);
            return;}
        if ((hasParent(target,".addglossmenu"))||
            (hasParent(target,".glossexposure")))
            return;
        if (!(hasParent(target,".textbox"))) fdjtUI.cancel(evt);
        addClass(div,"focused");
        metaBook.setHUD(true);
        glossform_focus(evt);}
    metaBook.UI.glossform_touch=glossform_touch;
    metaBook.UI.glossform_focus=glossform_focus;
    metaBook.UI.glossform_blur=glossform_blur;

    /* Adding a gloss button */
    
    function glossbutton_ontap(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var passage=getTarget(target);
        if ((metaBook.mode==="addgloss")&&
            (metaBook.glosstarget===passage)) {
            fdjtUI.cancel(evt);
            metaBook.setMode(true);}
        else if (passage) {
            fdjtUI.cancel(evt);
            var form=setGlossTarget(passage);
            if (!(form)) return;
            metaBook.setMode("addgloss");
            setGlossForm(form);}}

    function glossdeleted(response,glossid,frag){
        if (response===glossid) {
            metaBook.glossdb.drop(glossid);
            var editform=$ID("METABOOKEDITGLOSS_"+glossid);
            if (editform) {
                var editor=editform.parentNode;
                if (editor===$ID('METABOOKLIVEGLOSS')) {
                    metaBook.glosstarget=false;
                    metaBook.setMode(false);}
                fdjtDOM.remove(editor);}
            var renderings=fdjtDOM.Array(document.getElementsByName(glossid));
            var i=0; var lim=renderings.length;
            if (renderings) {
                while (i<lim) {
                    var rendering=renderings[i++];
                    if (rendering.id==='METABOOKSKIM')
                        fdjtDOM.replace(
                            rendering,fdjtDOM("div.metabookcard.deletedgloss"));
                    else fdjtDOM.remove(rendering);}}
            var glossmarks=
                document.getElementsByName("METABOOK_GLOSSMARK_"+frag);
            glossmarks=fdjtDOM.Array(glossmarks);
            i=0; lim=glossmarks.length; while (i<lim) {
                var glossmark=glossmarks[i++];
                var newglosses=RefDB.remove(glossmark.glosses,glossid);
                if (newglosses.length===0) fdjtDOM.remove(glossmark);
                else glossmark.glosses=newglosses;}
            var highlights=fdjtDOM.$(
                ".mbexcerpt[data-glossid='"+glossid+"']");
            highlights=fdjtDOM.Array(highlights);
            i=0; lim=highlights.length; while (i<lim) {
                fdjtUI.Highlight.remove(highlights[i++]);}}
        else fdjtUI.alert(response);}

    function delete_gloss(uuid){
        var gloss=metaBook.glossdb.probe(uuid);
        // If this isn't defined, the gloss hasn't been saved so we
        //  don't try to delete it.
        if ((gloss)&&(gloss.created)&&(gloss.maker)) {
            var frag=gloss.get("frag");
            fdjt.Ajax.jsonCall(
                function(response){glossdeleted(response,uuid,frag);},
                "https://"+metaBook.server+"/1/delete",
                "gloss",uuid);}
        else if ((gloss)&&(gloss.frag)) {
            // This is the case where the gloss hasn't been saved
            //  or is an anonymous gloss by a non-logged in user
            glossdeleted(uuid,uuid,gloss.frag);}}
    
    function addoutlet_keydown(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var content=target.value;
        var glossdiv=$ID("METABOOKLIVEGLOSS");
        if (!(glossdiv)) return;
        var form=getChild(glossdiv,"FORM");
        var share_cloud=metaBook.share_cloud;
        var ch=evt.keyCode||evt.charCode;
        if ((fdjtString.isEmpty(content))&&(ch===13)) {
            if (share_cloud.selection) 
                metaBook.addOutlet2Form(
                    form,share_cloud.selection.getAttribute("data-value"));
            else metaBook.setGlossMode("editnote");
            return;}
        else if ((ch===13)&&(share_cloud.selection)) {
            metaBook.addOutlet2Form(form,share_cloud.selection);
            share_cloud.complete("");
            target.value="";}
        else if (ch===13) {
            var completions=share_cloud.complete(content);
            if (completions.length)
                metaBook.addOutlet2Form(
                    form,completions[0].getAttribute("data-value"));
            else metaBook.addOutlet2Form(form,content);
            fdjtUI.cancel(evt);
            target.value="";
            share_cloud.complete("");}
        else if (ch===9) { /* tab */
            share_cloud.complete(content);
            fdjtUI.cancel(evt);
            if ((share_cloud.prefix)&&
                (share_cloud.prefix!==content)) {
                target.value=share_cloud.prefix;
                fdjtDOM.cancel(evt);
                return;}
            else if (evt.shiftKey) share_cloud.selectPrevious();
            else share_cloud.selectNext();}
        else setTimeout(function(){
            share_cloud.complete(target.value);},
                        100);}

    function addtag_keydown(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var content=target.value;
        var glossdiv=$ID("METABOOKLIVEGLOSS");
        if (!(glossdiv)) return;
        var form=getChild(glossdiv,"FORM");
        var gloss_cloud=metaBook.gloss_cloud;
        var ch=evt.keyCode||evt.charCode;
        if ((fdjtString.isEmpty(content))&&(ch===13)) {
            if (gloss_cloud.selection) 
                metaBook.addTag2Form(form,gloss_cloud.selection);
            else metaBook.setGlossMode(false);
            gloss_cloud.clearSelection();
            return;}
        else if ((ch===13)&&(gloss_cloud.selection)) {
            metaBook.addTag2Form(form,gloss_cloud.selection);
            gloss_cloud.complete("");
            gloss_cloud.clearSelection();
            target.value="";}
        else if (ch===13) {
            gloss_cloud.complete(content);
            if ((content.indexOf('|')>=0)||
                (content.indexOf('@')>=0))
                metaBook.addTag2Form(form,content);
            else metaBook.handleTagInput(content,form,true);
            fdjtUI.cancel(evt);
            target.value="";
            gloss_cloud.complete("");}
        else if (ch===9) { /* tab */
            gloss_cloud.complete(content);
            fdjtUI.cancel(evt);
            if ((gloss_cloud.prefix)&&
                (gloss_cloud.prefix!==content)) {
                target.value=gloss_cloud.prefix;
                fdjtDOM.cancel(evt);
                return;}
            else if (evt.shiftKey) gloss_cloud.selectPrevious();
            else gloss_cloud.selectNext();}
        else setTimeout(function(){
            gloss_cloud.complete(target.value);},
                        100);}

    var attach_types=/\b(link|upload|body|capture)\b/g;
    function changeAttachment(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var form=getParent(target,'form');
        var newtype=target.value;
        if (target.checked)
            fdjtDOM.swapClass(form,attach_types,newtype);
        else dropClass(form,target.value);}
    metaBook.UI.changeAttachment=changeAttachment;

    function setAttachType(newtype){
        var livegloss=$ID("METABOOKLIVEGLOSS");
        var form=fdjtDOM.getChild(livegloss,"FORM");
        fdjtDOM.swapClass(form,attach_types,newtype);
        var attachform=$ID("METABOOKATTACHFORM");
        var input=fdjtDOM.getInputFor(
            attachform,"ATTACHTYPE",newtype);
        fdjt.UI.CheckSpan.set(input,true);}
    metaBook.setAttachType=setAttachType;

    function attach_submit(evt){
        evt=evt||window.event;
        var form=fdjtUI.T(evt);
        if (form.tagName!=="FORM") form=getParent(form,"form");
        var livegloss=$ID("METABOOKLIVEGLOSS");
        var linkinput=fdjtDOM.getInput(form,"URL");
        var titleinput=fdjtDOM.getInput(form,"TITLE");
        var title=(titleinput.value)&&
            (fdjtString.stdspace(titleinput.value));
        var isokay=fdjtDOM.getInput(form,"FILEOKAY");
        var path=linkinput.value;
        fdjtUI.cancel(evt);
        if (!(livegloss)) return;
        if ((!(title))&&(path)) {
            var namestart=((path.indexOf('/')>=0)?
                           (path.search(/\/[^\/]+$/)):(0));
            if (namestart<0) title=path;
            else title=path.slice(namestart);}
        if (hasClass(form,"link")) {
            if (!(goodURL(linkinput.value))) {
                fdjtUI.alert("This URL doesn't look right");
                return;}
            if (metaBook.editlink) {
                changeLink(form,metaBook.editlink,
                           linkinput.value,title);
                metaBook.editlink=false;}
            else addLink(form,linkinput.value,title);
            fdjtDOM.addClass(livegloss,"modified");
            metaBook.setGlossMode("editnote");
            clearAttachForm();}
        else if (hasClass(form,"upload")) {
            if ((!(metaBook.glossattach))&&(!(metaBook.editlink))) {
                fdjtUI.alert("You need to specify a file!");
                return;}
            else if ((metaBook.glossattach)&&(!(isokay.checked)))
                fdjt.UI.choose([{label: "Yes",
                                 handler: function(){
                                     fdjtUI.CheckSpan.set(isokay,true);
                                     doFileAttach(title,livegloss);}},
                                {label: "Cancel"}],
                               fdjtDOM("P","By choosing 'Yes,' I affirm that ",
                                       "I have the right to use and share this ",
                                       "file according to the sBooks ",
                                       fdjtDOM.Anchor(
                                           "https://www.bookhub.io/legalia/TOS/",
                                           "A[target='_blank']",
                                           "Terms of Service"),
                                       "."));
            else if (metaBook.glossattach) {
                var filename=metaBook.glossattach.name;
                attachFile(metaBook.glossattach,
                           title||metaBook.glossattach.name,
                           livegloss).
                    then(function(req){
                        if (metaBook.editlink) {
                            changeLink(livegloss,metaBook.editlink,
                                       req.responseURL,title);
                            metaBook.editlink=false;}
                        else addLink(livegloss,req.responseURL,
                                     title||filename||"attachment");
                        fdjtDOM.addClass("METABOOKLIVEGLOSS","modified");
                        metaBook.setGlossMode("editnote");
                        clearAttachForm();}).
                    catch(function(trouble){
                        fdjtLog("Trouble attaching file %o (%o)",
                                metaBook.glossattach,trouble);});}
            else if (metaBook.editlink) {
                fdjtDOM.addClass("METABOOKLIVEGLOSS","modified");
                changeLink(livegloss,metaBook.editlink,metaBook.editlink,title);
                clearAttachForm();
                metaBook.editlink=false;}
            else {fdjtLog.warn("Fall through in attach_submit");}}
        else {fdjtLog.warn("Fall through in attach_submit");}
        return;}
    function attach_cancel(evt){
        var livegloss=$ID("METABOOKLIVEGLOSS");
        clearAttachForm(); fdjtUI.cancel(evt);
        if (!(livegloss)) return;
        metaBook.setGlossMode("editnote");}
    function attach_keydown(evt){
        evt=evt||window.event;
        var ch=evt.keyCode||evt.charCode;
        if (ch!==13) return;
        fdjtUI.cancel(evt);
        var livegloss=$ID("METABOOKLIVEGLOSS");
        if (!(livegloss)) return;
        attach_submit(evt);
        metaBook.setGlossMode("editnote");}

    function editLink(href,title){
        metaBook.editlink=href;
        setGlossMode("attach");
        if (href.search(/https:\/\/glossdata\./)===0) {
            var name=/\/([^\/]+)$/.exec(href);
            setAttachType("upload");
            addClass("METABOOKGLOSSATTACH","haveupload");
            $ID("METABOOKATTACHFILENAME").innerHTML=name[1];}
        else if (href.search(/\/capture\.[A-Za-z0-9]+$/)>=0)
            setAttachType("capture");
        else {
            setAttachType("link");
            $ID("METABOOKATTACHURL").value=href;}
        fdjt.UI.CheckSpan.set($ID("METABOOKUPLOADRIGHTS"),true);
        $ID("METABOOKATTACHTITLE").value=title||href;
        addClass($ID("METABOOKATTACHFORM"),"editlink");
        $ID("METABOOKATTACHTITLE").focus();}

    function doFileAttach(title,livegloss){
        var filename=metaBook.glossattach.name;
        attachFile(metaBook.glossattach,
                   title||metaBook.glossattach.name,
                   livegloss).
            then(function(req){
                if (metaBook.editlink) {
                    changeLink(livegloss,metaBook.editlink,
                               req.responseURL,title);
                    metaBook.editlink=false;}
                else addLink(livegloss,req.responseURL,
                             title||filename||"attachment");
                metaBook.setGlossMode("editnote");
                addClass(livegloss,"modified");
                clearAttachForm();}).
            catch(function(trouble){
                fdjtLog("Trouble attaching file %o (%o)",
                        metaBook.glossattach,trouble);});}

    function attach_file_click(evt){
        var file_input=$ID("METABOOKFILEINPUT");
        var ev=document.createEvent("MouseEvents");
        ev.initMouseEvent('click', true, true, evt.view);
        file_input.dispatchEvent(ev);
        fdjtUI.cancel(evt);}

    function clearAttachForm(){
        var linkinput=$ID("METABOOKATTACHURL");
        var titleinput=$ID("METABOOKATTACHTITLE");
        var rightsok=$ID("METABOOKUPLOADRIGHTS");
        var fileinput=$ID("METABOOKFILEINPUT");
        linkinput.value=""; titleinput.value="";
        fdjtDOM.dropClass("METABOOKGLOSSATTACH","haveupload");
        $ID("METABOOKATTACHFILE").className="nofile";
        $ID("METABOOKATTACHFILENAME").innerHTML="";
        fdjt.UI.CheckSpan.set(rightsok,false);        
        metaBook.glossattach=false;
        metaBook.editlink=false;
        fileinput.value="";}

    function attach_delete(evt){
        var oldlink=metaBook.editlink;
        var livegloss=$ID("METABOOKLIVEGLOSS");
        var exists=fdjtDOM.getChild(livegloss,"[data-href='"+oldlink+"']");
        fdjtUI.cancel(evt);
        if (exists) {
            addClass(livegloss,"modified");
            fdjtUI.CheckSpan.set(exists,false);}
        clearAttachForm();
        setGlossMode("editnote");}

    function attachFile(file,title,livegloss){
        var glossid=fdjtDOM.getInputValue(livegloss,"UUID");
        var itemid=fdjtState.getUUID();
        var filename=file.name, filetype=file.type;
        // var reader=new FileReader();
        var savereq=new XMLHttpRequest();
        var endpoint="https://glossdata.bookhub.io/"+
            glossid+"/"+itemid+"/"+filename;
        var aborted=false, done=false;
        function attaching_file(resolve,reject){        
            savereq.onreadystatechange=function(){
                if (aborted) {}
                else if (done) {}
                else if (savereq.readyState===4) {
                    if (savereq.status===200) {
                        metaBook.glossattach=false;
                        done=true; resolve(savereq);}
                    else {done=aborted=true; reject(savereq);}}
                else {}};
            savereq.ontimeout=function(evt){reject(evt);};
            savereq.open("POST",endpoint);
            savereq.setRequestHeader("content-type",filetype);
            savereq.withCredentials=true; // savereq.timeout=10000;
            savereq.send(file);}
        return new Promise(attaching_file);}

    function glossetc_click(evt){
        var target=fdjtUI.T(evt);
        var link=getParent(target,".glosslink");
        if (link) {
            editLink(link.getAttribute("data-href"),
                     link.title);
            fdjtUI.cancel(evt);
            return;}
        fdjtUI.CheckSpan.onclick(evt);
        var form=getParent(target,"form");
        var input=getInput(form,"NOTE");
        input.focus();}

    function addGlossDragOK(evt){
        evt=evt||window.event;
        var types=evt.dataTransfer.types;
        if (!(types)) return;
        else if (types.indexOf("Files")>=0)
            fdjt.UI.cancel(evt);
        else if (types.indexOf("text/uri-list")>=0)
            fdjt.UI.cancel(evt);
        else if (types.indexOf("text/plain")>=0) {
            var text=evt.dataTransfer.getData("text/plain");
            if (text.search(/^\s*https?:\/\//)===0)
                fdjt.UI.cancel(evt);}
        else {}}
    function addGlossDrop(evt){
        evt=evt||window.event;
        var attachform=$ID("METABOOKATTACHFORM");
        var types=evt.dataTransfer.types;
        if (!(types)) return;
        else if (types.indexOf("Files")>=0) {
            var files=evt.dataTransfer.files;
            var file=files[0];
            fdjtUI.cancel(evt);
            metaBook.glossattach=file;
            setAttachType("uploadfile");
            $ID("METABOOKATTACHFILENAME").innerHTML=file.name;
            fdjtDOM.addClass("METABOOKGLOSSATTACH","haveupload");
            if (hasClass(attachform,"editlink"))
                fdjt.UI.CheckSpan.set($ID("METABOOKUPLOADRIGHTS"),false);}
        else if (types.indexOf("text/uri-list")>=0) {
            var url=evt.dataTransfer.getData("URL")||
                evt.dataTransfer.getData("text/uri-list");
            if (!(url)) return;
            fdjt.UI.cancel(evt);
            metaBook.setGlossMode("attach");
            setAttachType("linkurl");
            $ID("METABOOKATTACHURL").value=url;
            $ID("METABOOKATTACHTITLE").focus();}
        else if (types.indexOf("text/plain")>=0) {
            var text=evt.dataTransfer.getData("text/plain");
            fdjt.UI.cancel(evt);
            if (text.search(/^\s*https?:\/\//)===0) {
                metaBook.setGlossMode("attach");
                if (hasClass(attachform,"linkurl")) {}
                else if (hasClass(attachform,"copyurl")) {}
                else setAttachType("linkurl");
                $ID("METABOOKATTACHURL").value=text;
                $ID("METABOOKATTACHTITLE").focus();}
            else {
                var livegloss=$ID("METABOOKLIVEGLOSS");
                var input=fdjtDOM.getInput(livegloss,"NOTE");
                metaBook.setGlossMode(false);
                input.value=text;
                input.focus();}}
        else {}}

    function glossUploadChanged(evt){
        var target=fdjtUI.T(evt), file=target.files[0];
        if (file) {
            metaBook.glossattach=file;
            $ID("METABOOKATTACHFILENAME").innerHTML=file.name;
            fdjtDOM.addClass("METABOOKGLOSSATTACH","haveupload");
            if (hasClass("METABOOKATTACHFORM","editlink"))
                fdjt.UI.CheckSpan.set($ID("METABOOKUPLOADRIGHTS"),
                                      false);}}

    function editglossnote(evt){
        evt=evt||window.event;
        metaBook.setGlossMode("editnote");
        fdjtUI.cancel(evt);}

    function startGloss(passage){
        var selecting=metaBook.UI.selectText(passage);
        if ((metaBook.TapHold.body)&&(metaBook.TapHold.body.abort))
            metaBook.TapHold.body.abort();
        metaBook.select_target=passage;
        selectors.push(selecting);
        selectors[passage.id]=selecting;
        fdjtUI.TapHold.clear();
        startAddGloss(passage,false,false);}
    metaBook.startGloss=startGloss;

    function startAddGloss(passage,mode,evt){
        if (metaBook.glosstarget===passage) {
            if ((Trace.gestures)||(Trace.glossing))
                fdjtLog("startAddGloss/resume %o %o form=%o",
                        evt,passage,metaBook.glossform);
            if (mode) metaBook.setGlossMode(mode,metaBook.glossform);
            metaBook.setMode("addgloss",true);
            if (evt) fdjtUI.cancel(evt);
            return;}
        var selecting=selectors[passage.id]; abortSelect(selecting);
        var form_div=setGlossTarget(
            passage,((metaBook.mode==="addgloss")&&
                     (metaBook.glossform)),selecting);
        var form=getChild(form_div,"form");
        if (!(form)) return;
        else if (evt) fdjtUI.cancel(evt);
        if ((Trace.gestures)||(Trace.glossing))
            fdjtLog("startAddGloss (%o) %o f=%o/%o",
                    evt,passage,form_div,form);
        setGlossForm(form_div);
        if (mode) form.className=mode;
        metaBook.setMode("addgloss",false);}
    metaBook.startAddGloss=startAddGloss;
    
    function saveGlossDialog(){
        // This prompts for updating the layout
        var msg=fdjtDOM("div.message","Save gloss?");
        saving_dialog=true;
        // When a choice is made, it becomes the default
        // When a choice is made to not resize, the
        // choice timeout is reduced.
        var choices=[
            {label: "Save",
             handler: function(){
                 metaBook.submitGloss();
                 saving_dialog=false;},
             isdefault: true},
            {label: "Discard",
             handler: function(){
                 metaBook.cancelGloss();
                 saving_dialog=false;}}];
        var spec={choices: choices,
                  timeout: (metaBook.save_gloss_timeout||
                            metaBook.choice_timeout||7),
                  spec: "div.fdjtdialog.fdjtconfirm.savegloss"};
        saving_dialog=fdjtUI.choose(spec,msg);
        return saving_dialog;}
    metaBook.saveGlossDialog=saveGlossDialog;

    function startSelect(passage,evt){
        var selecting=metaBook.UI.selectText(passage);
        if ((metaBook.TapHold.body)&&(metaBook.TapHold.body.abort))
            metaBook.TapHold.body.abort();
        metaBook.select_target=passage;
        selectors.push(selecting);
        selectors[passage.id]=selecting;
        fdjtUI.TapHold.clear();
        // This makes a selection start on the region we just created.
        if ((Trace.gestures)||(Trace.selecting)) 
            fdjtLog("body_held/select_wait %o %o %o",
                    selecting,passage,evt);
        setTimeout(function(){
            if ((Trace.gestures)||(Trace.selecting)) 
                fdjtLog("body_held/select_start %o %o %o",
                        selecting,passage,evt);
            selecting.startEvent(evt,250);},
                   0);}
    metaBook.startSelect=startSelect;

    function abortSelect(except){
        var i=0, lim=selectors.length;
        while (i<lim) {
            var sel=selectors[i++];
            if (sel!==except) sel.clear();}
        selectors=[];
        metaBook.select_target=false;}
    metaBook.abortSelect=abortSelect;

    metaBook.getTextSelectors=function getTextSelectors(){return selectors;};

    function closeGlossForm(glossform,evt){
        if (!(glossform)) glossform=metaBook.glossform;
        if (!(glossform)) return;
        if (saving_dialog) return;
        if (!(hasClass(glossform,"modified")))
            metaBook.cancelGloss();
        else if (hasClass(glossform,"glossadd")) 
            saveGlossDialog();
        else metaBook.submitGloss(glossform);
        if (evt) fdjtUI.cancel(evt);
        return;}
    metaBook.closeGlossForm=closeGlossForm;

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.mouse,
        {".metabookglossform":
         {click: glossform_touch,touchstart: glossform_touch},
         glossbutton: {mouseup: glossbutton_ontap,mousedown: cancel},
         "span.metabooksharegloss": {
             tap: fdjt.UI.CheckSpan.onclick},
         ".metabookglossform .response": {click: metaBook.toggleHUD},
         ".addglossmenu": {
             tap: glossmode_tap,
             hold: glossmode_hold,
             slip: glossmode_slip,
             release: glossmode_release,
             click: cancel},
         "div.glossetc": {click: glossetc_click},
         "div.glossetc div.sharing": {click: glossform_outlets_tapped},
         "div.glossetc div.notetext": {click: editglossnote},
         "#METABOOKADDGLOSS": {
             dragenter: addGlossDragOK,
             dragover: addGlossDragOK,
             drop: addGlossDrop},
         "#METABOOKATTACHFILE": {
             click: attach_file_click},
         "#METABOOKGLOSSATTACH": {
             dragenter: addGlossDragOK,
             dragover: addGlossDragOK,
             drop: addGlossDrop},
         "#METABOOKADDTAGINPUT": {keydown: addtag_keydown},
         "#METABOOKADDSHAREINPUT": {keydown: addoutlet_keydown},
         "#METABOOKATTACHFORM": {submit: attach_submit},
         "#METABOOKATTACHURL": {keydown: attach_keydown},
         "#METABOOKATTACHTITLE": {keydown: attach_keydown},
         "#METABOOKATTACHCANCEL": {click: attach_cancel},
         "#METABOOKATTACHDELETE": {click: attach_delete},
         "#METABOOKFILEINPUT": {change: glossUploadChanged},
         "#METABOOKGLOSSCLOUD": {
             tap: metaBook.UI.handlers.glosscloud_select,
             release: metaBook.UI.handlers.glosscloud_select},
         "#METABOOKSHARECLOUD": {
             tap: outlet_select,release: outlet_select}});

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.touch,
        {".metabookglossform .response": {click: metaBook.toggleHUD},
         ".addglossmenu": {
             tap: glossmode_tap,
             hold: glossmode_hold,
             slip: glossmode_slip,
             release: glossmode_release,
             click: cancel},
         "div.glossetc": {
             touchstart: glossetc_click,
             touchend: cancel},
         "div.glossetc div.sharing": {
             touchend: glossform_outlets_tapped,
             click: cancel},
         "div.glossetc div.notetext": {
             touchend: editglossnote,
             click: cancel},
         "#METABOOKADDTAGINPUT": {keydown: addtag_keydown},
         "#METABOOKADDSHAREINPUT": {keydown: addoutlet_keydown},
         "#METABOOKATTACHFORM": {submit: attach_submit},
         "#METABOOKATTACHURL": {keydown: attach_keydown},
         "#METABOOKATTACHTITLE": {keydown: attach_keydown},
         "#METABOOKATTACHFILE": {click: attach_file_click},
         "#METABOOKATTACHCANCEL": {click: attach_cancel},
         "#METABOOKATTACHDELETE": {click: attach_delete},
         "#METABOOKADDGLOSS": {
             dragenter: addGlossDragOK,
             dragover: addGlossDragOK,
             drop: addGlossDrop},
         "#METABOOKFILEINPUT": {change: glossUploadChanged},
         "#METABOOKGLOSSCLOUD": {
             tap: metaBook.UI.handlers.glosscloud_select,
             release: metaBook.UI.handlers.glosscloud_select},
         "#METABOOKSHARECLOUD": {
             tap: outlet_select,release: outlet_select}});

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/interaction.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements most of the interaction handling for the
   e-reader web application.

   This file is part of metaBook, a Javascript/DHTML web application
   for reading large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

/* There are four basic display modes:
   reading (minimal decoration, with 'minimal' configurable)
   skimming (card at top, buttons on upper edges)
   addgloss (addgloss form at top, text highlighted)
   tool (lots of tools unfaded)

   Tap on content:
   if not hudup and no mode, raise the HUD;
   if not hudup and mode, clear the mode
   if hudup, drop the HUD
   Hold on content:
   if adding gloss to target, raise the hud
   otherwise, start adding gloss to target
*/

/* New content interaction rules, based on assuming taphold for content */
/*
  tap: if previewing, stop and jump to the previewed location
  tap: if over anchor, detail, aside, etc, and fdjtselecting, treat it like a click below,
  tap: if over fdjtselecting, go to addgloss mode with the hud up, and pass event
  on to the fdjtselecting region
  tap: if on anchor, detail, aside, etc, either treat it especially (and set clicked to
  the current time) or ignore it (and let click handle it)
  tap: otherwise, go forward or backward based on the x position

  hold: if previewing, stop and jump to the previewed location
  hold: if over fdjtselecting, switch to addgloss with HUD down and pass it on.
  hold: if not over fdjtselecting:
  if not over a passage, toggle the HUD
  if over a passage, and no current glosstarget,
  start selecting, fake a press, create a gloss;
  if over a passage, and current glosstarget is a reply, retarget the reply;
  if over a passage, and current glosstarget hasn't been modified or save,
  retarget the gloss
*/

(function(){
    "use strict";

    var mB=metaBook;
    var Trace=mB.Trace;
    var fdjtString=fdjt.String;
    var showPage=fdjt.showPage;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var RefDB=fdjt.RefDB;
    var $ID=fdjt.ID;
    var mbID=metaBook.ID;

    // Imports (kind of)
    var addClass=fdjtDOM.addClass;
    var hasClass=fdjtDOM.hasClass;
    var dropClass=fdjtDOM.dropClass;
    var toggleClass=fdjtDOM.toggleClass;
    var getTarget=metaBook.getTarget;
    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var isClickable=fdjtUI.isClickable;
    var getChild=fdjtDOM.getChild;
    var getChildren=fdjtDOM.getChildren;
    var getInput=fdjtDOM.getInput;
    var Selector=fdjtDOM.Selector;

    var isEmptyString=fdjtString.isEmpty;
    var decodeEntities=fdjtString.decodeEntities;
    var fillIn=fdjtString.fillIn;

    var getCard=metaBook.UI.getCard;
    var pagers=metaBook.pagers, mbDOM=metaBook.DOM;

    var submitEvent=fdjtUI.submitEvent;
    var noDefault=fdjt.UI.noDefault;
    var cancel=fdjt.UI.cancel;

    var reticle=fdjtUI.Reticle;

    var setMode=metaBook.setMode;
    var setHUD=metaBook.setHUD;

    /* For tracking gestures */
    var preview_timer=false;
    function previewTimeout(fcn,interval){
        if (fcn===true)
            return preview_timer;
        else if (fcn) {
            if (preview_timer) return;
            else setTimeout(function(){preview_timer=false; fcn();},
                            interval||400);}
        else if (preview_timer) {
            clearTimeout(preview_timer);
            preview_timer=false;}
        else {}}
    metaBook.previewTimeout=previewTimeout;

    var slip_timer=false;
    function slipTimeout(fcn,interval){
        if (fcn===true)
            return slip_timer;
        else if (fcn) {
            if (slip_timer) return;
            else setTimeout(function(){slip_timer=false; fcn();},
                            interval||500);}
        else if (slip_timer) {
            clearTimeout(slip_timer);
            slip_timer=false;}
        else {}}
    metaBook.slipTimeout=slipTimeout;

    metaBook.uiclasses=/\b(metabookui|glossmark)\b/gi;

    metaBook.addConfig("controlc",function(key,val){metaBook.controlc=val;});

    /* Setup for gesture handling */

    function addHandlers(node,type){
        var mode=metaBook.ui;
        fdjtDOM.addListeners(node,mB.UI.handlers[mode][type]);}
    metaBook.UI.addHandlers=addHandlers;

    function setupGestures(domnode){
        var mode=metaBook.ui;
        if (!(mode)) metaBook.ui=mode="mouse";
        if ((!(domnode))&&((Trace.startup>1)||(Trace.gestures)))
            fdjtLog("Setting up basic handlers for %s UI",mode);
        if ((domnode)&&(Trace.gestures))
            fdjtLog("Setting up %s UI handlers for %o",mode,domnode);
        if (!(domnode)) {
            addHandlers(false,'window');
            addHandlers(document,'document');
            addHandlers(document.body,'body');
            addHandlers($ID("METABOOKBODY"),'content');
            metaBook.TapHold.body=fdjtUI.TapHold(
                $ID("METABOOKBODY"),
                {override: true,noslip: true,id: "METABOOKBODY",
                 maxtouches: 3,taptapmsecs: true,
                 movethresh: 10,untouchable: false});
            addHandlers(metaBook.HUD,'hud');}
        if (mode) {
            var handlers=metaBook.UI.handlers[mode];
            var keys=[], seen=[];
            for (var key in handlers) {
                if ((handlers.hasOwnProperty(key))&&
                    ((key.indexOf('.')>=0)||(key.indexOf('#')>=0)))
                    keys.push(key);}
            // Appropximate sort for selector priority
            keys=keys.sort(function(kx,ky){return ky.length-kx.length;});
            var i=0, lim=keys.length;
            while (i<lim) {
                key=keys[i++];
                var nodes=fdjtDOM.$(key,domnode);
                var h=handlers[key], sel=new Selector(key);
                if ((domnode)&&(sel.match(domnode)))
                    fdjtDOM.addListeners(domnode,h);
                var j=0, jlim=nodes.length;
                while (j<jlim) {
                    var node=nodes[j++];
                    if (seen.indexOf(node)<0) { 
                        seen.push(node);
                        fdjtDOM.addListeners(node,h);}}}}
        if (Trace.startup>2) fdjtLog("Done with handler setup");}
    metaBook.setupGestures=setupGestures;

    /* Functionality:
       on selection:
       save but keep selection,
       set target (if available)
       if hud is down, raise it
       on tap: (no selection)
       if hud is down, set target and raise it
       if no target, raise hud
       if tapping target, lower HUD
       if tapping other, set target, drop mode, and raise hud
       (simpler) on tap:
       if hudup, drop it
       otherwise, set target and raise HUD
    */

    /*
      Tap on content:
      if not hudup and no mode, raise the HUD;
      if not hudup and mode, clear the mode
      if hudup, drop the HUD
      Hold on content:
      if adding gloss to target, raise the hud
      otherwise, start adding gloss to target
    */

    /* Holding */

    var held=false;

    function clear_hold(caller){
        if (held) {
            clearTimeout(held); held=false;
            if (Trace.gestures)
                fdjtLog("clear_hold from %s",(caller||"somewhere"));}}

    /* Generic content interaction handler */

    var gesture_start=false;
    var clicked=false;

    function body_tapped(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var sX=evt.screenX, sY=evt.screenY;
        var cX=evt.clientX, cY=evt.clientY;
        var now=fdjtTime(), touch=false;
        var vw=fdjtDOM.viewWidth();

        if ((evt.changedTouches)&&(evt.changedTouches.length)) {
            touch=evt.changedTouches[0];
            sX=touch.screenX; sY=touch.screenY;
            cX=touch.clientX; cY=touch.clientY;}

        if (Trace.gestures) {
            fdjtLog("body_tapped %o c=%d,%d now=%o p=%o %s",
                    evt,cX,cY,now,mB.previewing,(touch?("(touch)"):""));}
        
        // If we're previewing, stop it and go to the page we're
        //  previewing (which was touched)
        if (mB.previewing) {
            var jumpto=getTarget(target);
            metaBook.stopPreview("body_tapped/stop_preview",jumpto||true);
            fdjtUI.TapHold.clear();
            cancel(evt);
            return false;}

        if (hasClass(document.body,"mbSHOWHELP")) {
            dropClass(document.body,"mbSHOWHELP");
            cancel(evt);
            return;}

        if ((hasParent(target,".glossmark"))||
            (handle_content_click(target))) {
            cancel(evt);
            return false;}

        if ((mB.touch)&&(mB.textinput)) {
            metaBook.clearFocus(mB.textinput);
            cancel(evt);
            return;}
        
        if (mB.passage_menu) {
            if (Trace.gestures)
                fdjtLog("body_tapped %o closing menu %o",
                        evt,mB.passage_menu);
            if (mB.TapHold.body) metaBook.TapHold.body.abort();
            cancel(evt);
            return closePassageMenu(evt);}

        if (mB.skimming) {
            if (hasClass("METABOOKSKIMMER","expanded")) 
                dropClass("METABOOKSKIMMER","expanded");
            else if ((touch)&&(cX<vw/4)) 
                pageBackward(evt,true);
            else  if ((touch)&&(cX<vw/4)) 
                pageForward(evt,true);
            else setHUD(false);
            cancel(evt);
            return;}

        if (mB.glosstarget) {
            var glossform=metaBook.glossform;
            if (hasParent(target,mB.glosstarget)) {
                setMode("addgloss",false);
                cancel(evt); return;}
            else {
                metaBook.closeGlossForm(glossform);
                cancel(evt); return;}}
        
        if ((mB.hudup)||(mB.mode)) {
            setMode(false); setHUD(false);
            if ($ID("METABOOKOPENGLOSSMARK")) {
                if (mB.target)
                    metaBook.clearHighlights(mB.target);
                $ID("METABOOKOPENGLOSSMARK").id="";}
            cancel(evt); gesture_start=false;
            clicked=fdjtTime();
            // if (getTarget(target)) metaBook.setTarget(false);
            return false;}
        
        if ($ID("METABOOKOPENGLOSSMARK")) {
            $ID("METABOOKOPENGLOSSMARK").id="";
            if (mB.target) metaBook.clearHighlights(mB.target);
            cancel(evt); gesture_start=false;
            return;}

        // If we get here, we're doing a page flip
        if (Trace.gestures)
            fdjtLog("body_tapped/fallthrough (%o) %o, m=%o, @%o,%o, vw=%o",
                    evt,target,mB.mode,cX,cY,fdjtDOM.viewWidth());
        if ((mB.fullheight)&&(!(mB.hudup))&&
            ((cY<50)||(cY>(fdjtDOM.viewHeight()-50)))) 
            setHUD(true);
        else if (cX<(fdjtDOM.viewWidth()*0.4)) 
            pageBackward(evt,true);
        else pageForward(evt,true);
        cancel(evt); gesture_start=false;
        return;}

    function resolve_anchor(ref){
        var elt=mbID(ref);
        if (elt) return elt;
        var elts=document.getElementsByName(ref);
        if (elts.length===0) return false;
        else if (elts.length===1) return elts[0];
        else {
            var found=0; var i=0, lim=elts.length;
            var metabook_page=metaBook.page;
            while (i<lim) {
                var r=elts[i++];
                if (hasClass(r,"metabookdupstart")) return r;
                else if (found) continue;
                else if (hasParent(r,metabook_page)) found=4;
                else {}}
            if (!(found)) return elts[0];
            else return found;}}

    var MetaBookSlice=metaBook.Slice;

    var note_classes=
        /\b(((sbook)|(book)|(mbook)|(metabook)|(foot)|(end)|())note)\b/;
    var noteref_classes=
        /\b((((sbook)|(book)|(meta))book)|(foot)|(end)|())(note|noteref)\b/;
    var aside_rels=/\b((sidebar)|(breakout)|(tangent))\b/;
    var iframe_rels=/\b((iframe)|(popin))\b/;
    var iframe_classes=
        /\b(()|(s)|(m)|(meta))book((iframe)|(popin))\b/;

    function handle_content_click(target){
        // Assume 1s gaps are spurious
        if ((clicked)&&((fdjtTime()-clicked)<1000)) return true;

        // Handle various click-like operations, overriding to sBook
        //  navigation where appropriate.  Set *clicked* to the
        //  current time when you do so, letting the body_click handler
        //  appropriately ignore its invocation.
        var anchor=getParent(target,"A"), href, elt=false;
        // If you tap on a relative anchor, move there using metaBook
        // rather than the browser default
        var rel=anchor.rel, classname=anchor.className;
        if (typeof classname !== "string") classname="";
        if (typeof rel !== "string") rel="";
        if ((anchor)&&(anchor.href)&&(href=anchor.getAttribute("href"))) {
            if (Trace.gestures)
                fdjtLog("ctouch: follow link %s",href);
            if (href[0]==="#") {
                var idref=href.slice(1);
                if (typeof classname !== "string") classname="";
                if (typeof rel !== "string") rel="";
                if ((rel.search(note_classes)>=0)||
                    (classname.search(noteref_classes)>=0)||
                    ((mB.noterefspecs)&&(mB.noterefspecs.match(anchor)))) {
                    var note_node=getNoteNode(idref);
                    var noteid=note_node.id;
                    metaBook.DOM.noteshud.innerHTML="";
                    var shownote=note_node.cloneNode(true);
                    fdjtDOM.stripIDs(shownote);
                    dropClass(shownote,/\bmetabook\S+/g);
                    addClass(shownote,"metabooknotebody");                
                    metaBook.DOM.noteshud.setAttribute(
                        "data-note",noteid||idref);
                    fdjtDOM.append(mbDOM.noteshud,shownote);
                    setMode("shownote");
                    gesture_start=false;
                    clicked=fdjtTime();
                    return true;}
                else if (rel.search(aside_rels)>=0) {
                    var aside_target=$ID(idref);
                    fdjtDOM.removeChildren(mbDOM.asidehud);
                    fdjtDOM.append(mbDOM.asidehud,aside_target.cloneNode(true));
                    setMode("showaside");
                    gesture_start=false;
                    clicked=fdjtTime();
                    return true;}
                else if ((fn=metaBook.xtargets[idref])) {
                    var fn=metaBook.xtargets[idref];
                    gesture_start=false;
                    clicked=fdjtTime();
                    fn();
                    return true;}
                else if ((elt=resolve_anchor(idref))) {
                    // It's an internal jump, so we follow that
                    metaBook.JumpTo(elt);
                    gesture_start=false;
                    clicked=fdjtTime();
                    return true;}
                else {
                    fdjtLog.warn("Couldn't resolve %s",idref);
                    return true;}}
            else if ((rel.search(iframe_rels)>=0)||
                     (classname.search(iframe_classes)>=0)) {
                gesture_start=false;
                fdjtDOM.triggerClick(anchor);
                return true;}
            else {
                // We force links to leave the page, hoping people
                //  won't find it obnoxious.  We could also open up
                //  a little iframe in some circumstances
                if (!(anchor.target)) anchor.target="_blank";
                gesture_start=false;
                fdjtDOM.triggerClick(anchor);
                return true;}}

        var details=getParent(target,"details,.html5details,.sbookdetails");
        if (details) {
            fdjtDOM.removeChildren(mbDOM.notehud);
            metaBook.DOM.notehud.innerHTML=details.innerHTML;
            setMode("showdetails");
            clicked=fdjtTime();
            return true;}
        
        var aside=getParent(target,"aside,.html5aside,.sbookaside");
        if (aside) {
            fdjtDOM.removeChildren(mbDOM.asidehud);
            metaBook.DOM.asidehud.innerHTML=aside.innerHTML;
            setMode("showaside");
            clicked=fdjtTime();
            return true;}

        var glossref=getParent(target,"[data-glossid]");
        if (glossref) {
            var glossid=glossref.getAttribute("data-glossid");
            var gloss=metaBook.glossdb.ref(glossid);
            if (!(gloss)) return false;
            var slicediv=fdjtDOM("div.metabookglosses.metabookslice");
            var slice=new MetaBookSlice(slicediv,[gloss],false);
            var hudwrapper=fdjtDOM("div.hudpanel#METABOOKPOINTGLOSSES",slicediv);
            fdjtDOM.replace("METABOOKPOINTGLOSSES",hudwrapper);
            metaBook.setTarget(target);
            slice.update();
            setMode("openglossmark");
            return true;}

        return false;}

    function getNoteNode(ref){
        var elt=mbID(ref);
        var body=$ID("METABOOKBODY"), db=document.body;
        if (!(elt)) {
            var elts=document.getElementsByName(ref);
            if (!(body)) return false;
            if (elts.length) {
                var i=0, lim=elts.length; while (i<lim) {
                    if (hasParent(elt[i],body)) {elt=elt[i]; break;}
                    else i++;}}}
        if (!(elt)) return;
        var scan=elt, style=fdjtDOM.getStyle(elt), block=false;
        var notespecs=metaBook.notespecs;
        while (scan) {
            if (scan===body) break;
            else if (scan===db) break;
            else if ((notespecs)&&(notespecs.match(scan))) return scan;
            else if (block) {}
            else if (style.display==='block') {block=scan; style=false;}
            else {}
            scan=scan.parentNode;
            style=fdjtDOM.getStyle(scan);}
        if (block) return block; else return elt;}

    function jumpToNote(evt){
        evt=evt||window.event;
        var target=fdjt.UI.T(evt);
        var anchor=getParent(target,"A[href]");
        if (!(anchor)) {
            cancel(evt);
            var noteshud=mB.DOM.noteshud;
            var jumpto=noteshud.getAttribute("data-note");
            if (jumpto) {
                noteshud.removeAttribute("data-note");
                noteshud.innerHTML="";
                mB.setMode(false);
                mB.GoTo(jumpto,"jumpToNote",true,true);}
            else mB.setMode(false);}}

    function body_held(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var passage=getTarget(target);
        if (Trace.gestures) 
            fdjtLog("body_held %o p=%o p.p=%o bc=%s hc=%s",
                    evt,passage,((passage)&&(passage.parentNode)),
                    document.body.className,
                    metaBook.HUD.className);
        if (mB.previewing) return;
        else if (hasParent(target,"A")) {
            var anchor=getParent(target,"A");
            var href=((anchor)&&(anchor.getAttribute("href")));
            cancel(evt);
            if ((href)&&(href[0]==="#")&&(mbID(href.slice(1)))) {
                if (Trace.gestures) 
                    fdjtLog("anchor_preview/body_held %o %o %o",
                            evt,anchor,href);
                mB.startPreview(href.slice(1),"content/anchor_held");
                return;}}
        if (!(passage)) return;
        if (mB.glosstarget===passage) {
            if (mB.mode!=="addgloss")
                setMode("addgloss",false);
            return;}
        if (mB.skimming) {
            cancel(evt);
            if (hasClass("METABOOKSKIMMER","expanded")) 
                dropClass("METABOOKSKIMMER","expanded");
            else setHUD(false);
            mB.TapHold.body.abort();
            return;}
        mB.startSelect(passage,evt);
        mB.startAddGloss(passage,false,evt);}

    function body_taptap(evt){
        var target=fdjtUI.T(evt);
        var passage=getTarget(target);
        if (Trace.gestures) 
            fdjtLog("body_taptap %o p=%o p.p=%o bc=%s hc=%s t=%o gt=%o",
                    evt,passage,((passage)&&(passage.parentNode)),
                    document.body.className,mB.HUD.className,
                    target,mB.glosstarget);
        if (hasParent(target,"IMG,AUDIO,VIDEO,OBJECT")) {
            metaBook.startZoom(getParent(target,"IMG,AUDIO,VIDEO,OBJECT"));
            cancel(evt);
            return;}
        if (mB.glosstarget) {
            if (hasParent(target,mB.glosstarget)) {
                setMode("addgloss",false);}
            else metaBook.closeGlossForm();}
        if (!(passage)) return;
        if (mB.glosstarget===passage) {
            if (mB.mode!=="addgloss")
                setMode("addgloss",false);
            return;}
        var choices=[
            {label: "Add Gloss",
             handler: function(){
                 metaBook.startGloss(passage);},
             isdefault: true}];
        /*
          if (window.ClipboardEvent) {
            choices.push({label: "Copy link",
                          handler: function(){copyURI(passage);}});
            choices.push({label: "Copy content",
                          handler: function(){copyContent(passage);}});}
        */
        if (true) choices.push(
            {label: "Zoom content",
             handler: function(){
                 metaBook.startZoom(passage);
                 cancel(evt);
                 return;}});
        addOptions(passage,choices);
        if (choices.length===1) {
            cancel(evt);
            metaBook.startGloss(passage);
            return;}
        cancel(evt);
        choices.push(
            {label: "Cancel",
             handler: function(){
                 metaBook.cancelGloss();}});
        var max=0, i=0, lim=choices.length;
        while (i<lim) {
            var ch=choices[i++];
            var len=ch.label.length;
            if (len>max) max=len;}
        var spec={choices: choices,
                  spec: "div.fdjtdialog.metabooktaptap"};
        metaBook.passage_menu=fdjtUI.choose(spec);}

    function addOptions(passage,choices){
        var scan=passage; while (scan) {
            var link=passage.getAttribute("data-xref");
            if (link) {
                var space=link.indexOf(' ');
                var href=((space>0)?(link.slice(0,space)):(link));
                var label=((space>0)?(link.slice(space+1)):(link));
                var data={id:passage.id,docid:mB.docref,refuri:mB.refuri,
                          docuri:mB.docuri};
                if ((mB.user)&&(mB.user._id)) data.user=mB.user._id;
                var opt={label: label, handler: makeOpener(fillIn(href,data))};
                choices.push(opt);}
            scan=scan.parentNode;}
        var anchors=getChildren(passage,"a[href]");
        var i=0, lim=anchors.length; while (i<lim) {
            var anchor=anchors[i++];
            var linkref=decodeEntities(anchor.getAttribute("href"));
            var uselabel=anchor.title||(getAnchorContext(anchor));
            var handler=((linkref.search("#")===0)?(makeGoTo(linkref)):
                         (makeOpener(anchor.href)));
            var anchor_opt={label: uselabel,handler: handler,
                            classname: "anchor"};
            choices.push(anchor_opt);}}
    
    function getAnchorContext(anchor){
        var frag=document.createDocumentFragment();
        var context=fdjtDOM("span.anchorcontext");
        frag.appendChild(fdjtDOM("span.anchortext",anchor.innerHTML));
        frag.appendChild(context);
        if (anchor.title) fdjtDOM(context,anchor.title);
        else {
            var next=anchor.nextSibling; while (next) {
                context.appendChild(next.cloneNode(true));
                next=next.nextSibling;}}
        return frag;}

    function closePassageMenu(evt){
        evt=evt||window.event;
        if (!(mB.passage_menu)) return false;
        if (evt) {
            var target=fdjtUI.T(evt);
            if ((mB.passage_menu)&&(hasParent(target,mB.passage_menu)))
                return false;}
        var menu=mB.passage_menu;
        mB.passage_menu=false;
        fdjt.Dialog.close(menu);
        if (evt) cancel(evt);
        return true;}
    metaBook.closePassageMenu=closePassageMenu;

    function makeGoTo(href){
        return function (){metaBook.GoTo(href);};}

    function makeOpener(url){
        return function (){window.open(url);};}
    /*
    function copyURI(passage){
        var ClipboardEvent=window.ClipboardEvent;
        var evt = new ClipboardEvent(
            'copy',{ dataType: 'text/plain', 
                     data: metaBook.refuri+"#"+passage.id } );
        document.dispatchEvent(evt);}
    function copyContent(passage){
        var ClipboardEvent=window.ClipboardEvent;
        var evt = new ClipboardEvent(
            'copy',{ dataType: 'text/html', data: passage.innerHTML } );
        document.dispatchEvent(evt);}
    */

    var body_tapstart=false;
    function body_touchstart(evt){
        evt=evt||window.event;
        body_tapstart=false;
        if (mB.zoomed) return;
        var target=fdjtUI.T(evt);
        if (target.id!=="METABOOKBODY") return;
        body_tapstart=fdjtTime();}

    function body_touchend(evt){
        evt=evt||window.event;
        if (mB.zoomed) return;
        var target=fdjtUI.T(evt);
        if (target.id!=="METABOOKBODY") return;
        // If the touch is directly over the BODY, treat it as a
        // paging gesture
        if ((body_tapstart)&&((fdjtTime()-body_tapstart)<1000)) {
            if (mB.TapHold.body) metaBook.TapHold.body.abort();
            cancel(evt);
            var x=(evt.clientX)||
                ((evt.changedTouches)&&
                 (evt.changedTouches.length)&&
                 (evt.changedTouches[0].clientX));
            var w=fdjtDOM.viewWidth();
            if (x>(w/2)) pageForward(evt);
            else pageBackward(evt);}}
    
    function body_released(evt){
        evt=evt||window.event;
        if (mB.zoomed) return;
        var target=fdjtUI.T(evt), children=false;
        if (Trace.gestures) fdjtLog("body_released %o",evt);
        if (mB.previewing) {
            metaBook.stopPreview("body_released");
            cancel(evt);
            return;}
        else if (hasParent(target,"A")) {
            cancel(evt);
            return;}
        var passage=((hasParent(target,".fdjtselecting"))&&
                     (getTarget(target)));
        if (!(passage)) {
            children=getChildren(target,".fdjtselected");
            if (children.length===0) {
                metaBook.abortSelect(); 
                return;}
            target=children[0]; passage=getTarget(target);}
        if (Trace.gestures)
            fdjtLog("body_released %o p=%o gt=%o gf=%o",
                    evt,passage,mB.glosstarget,mB.glossform);
        if (mB.glosstarget===passage) {
            if (mB.glossform)
                metaBook.glossform.id="METABOOKLIVEGLOSS";
            if (mB.mode!=="addgloss") setMode("addgloss");}
        else metaBook.startAddGloss(passage,((evt.shiftKey)&&("addtag")),evt);}

    function body_swiped(evt){
        if (mB.zoomed) return;
        var dx=evt.deltaX, dy=evt.deltaY;
        var vw=fdjtDOM.viewWidth();
        var adx=((dx<0)?(-dx):(dx)), ady=((dy<0)?(-dy):(dy));
        if (Trace.gestures)
            fdjtLog("swiped d=%o,%o, ad=%o,%o, s=%o,%o vw=%o, n=%o",
                    dx,dy,adx,ady,evt.startX,evt.startY,vw,evt.ntouches);
        if (adx>(ady*2)) {
            // Horizontal swipe
            if (dx<-(mB.minswipe||10)) {
                if (evt.ntouches>2) window.history.forward();
                else if (evt.ntouches>1) {
                    if (mB.skimming)
                        metaBook.skimForward(evt);
                    else window.history.forward();}
                else if ((mB.mode)&&(!(mB.skimming))&&
                         (pagers[metaBook.mode])) {
                    if (evt.touches===2)
                        showPage.fastFrward(pagers[metaBook.mode]);
                    else showPage.forward(pagers[metaBook.mode]);}
                else if (mB.skimming) pageForward(evt);
                else pageForward(evt,true);}
            else if (dx>(mB.minswipe||10)) {
                if (evt.ntouches>2) window.history.back();
                else if (evt.ntouches>1) {
                    if (mB.skimming)
                        metaBook.skimBackward(evt);
                    else window.history.back();}
                else if ((mB.mode)&&(!(mB.skimming))&&
                         (pagers[metaBook.mode])) {
                    if (evt.touches===2)
                        showPage.fastBckward(pagers[metaBook.mode]);
                    else showPage.backward(pagers[metaBook.mode]);}
                else if (mB.skimming)
                    metaBook.pageBackward(evt);
                else metaBook.pageBackward(evt,true);}}
        else if (ady>(adx*2)) {
            // Vertical swipe
            if (!(mB.hudup)) {
                if (ady<=(mB.minswipe||10)) return; // Ignore really short swipes 
                else if ((evt.startX<(vw/5))&&(dy<0))
                    // On the left, up, show help
                    setMode("help");
                else if ((evt.startX<(vw/5))&&(dy>0))
                    // On the left, down, show TOC
                    setMode("statictoc");
                else if ((evt.startX>(vw*0.8))&&(dy>0))
                    // On the right, down, show SEARCH
                    setMode("search");
                else if ((evt.startX>(vw*0.8))&&(dy<0))
                    // On the right, up, show GLOSSES
                    setMode("allglosses");
                else if ((dy>0)&&(metaBook.skimming)) {
                    metaBook.stopSkimming();}
                else if (dy>0) {
                    metaBook.clearStateDialog();
                    metaBook.showCover();}
                else setHUD(true);}
            else if (dy<-(mB.minswipe||10)) setMode("allglosses");
            else if (dy>(mB.minswipe||10)) setMode("search");}
        else {}}

    function initGlossMode(){
        var form=getChild("METABOOKLIVEGLOSS","form");
        if (form) {
            var input=getInput(form,"NOTE");
            if (input) metaBook.setFocus(input);
            metaBook.setGlossMode(form.className);}}
    metaBook.initGlossMode=initGlossMode;

    /* TOC handlers */

    function getAbout(elt){
        var body=document.body;
        while (elt) {
            if (elt===body) return false;
            else if (elt.nodeType!==1) return false;
            else if ((elt.name)&&(elt.name.search("SBR")===0))
                return elt;
            else if ((elt.getAttribute("name"))&&
                     (elt.getAttribute("name").search("SBR")===0))
                return elt;                     
            else elt=elt.parentNode;}
        return false;}

    function getTitleSpan(toc,ref){
        var titles=getChildren(toc,".metabooktitle");
        var i=0; var lim=titles.length;
        while (i<lim) {
            var title=titles[i++];
            if (title.name===ref) return title;}
        return false;}

    function toc_tapped(evt){
        evt=evt||window.event;
        var tap_target=fdjtUI.T(evt);
        if (mB.previewing) {
            // Because we're previewing, this slice is invisible, so
            //  the user really meant to tap on the body underneath,
            //  so we stop previewing and jump there We might try to
            //  figure out exactly which element was tapped somehow
            metaBook.stopPreview("toc_tapped");
            cancel(evt);
            return;}
        var about=getAbout(tap_target);
        if (about) {
            var name=about.name||about.getAttribute("name");
            var ref=name.slice(3);
            var info=metaBook.docinfo[ref];
            var target=info.elt||mbID(ref);
            if (target.id!==ref) target=mbID(ref);
            if (Trace.gestures)
                fdjtLog("toc_tapped %o about=%o ref=%s target=%o",
                        evt,about,ref,target);
            metaBook.JumpTo(target);
            cancel(evt);}
        else if (Trace.gestures) fdjtLog("toc_tapped %o noabout", evt);
        else {}}
    function toc_held(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt), about=getAbout(target);
        previewTimeout(false); slipTimeout(false);
        if (about) {
            var name=about.name||about.getAttribute("name");
            var ref=name.slice(3);
            var toc=getParent(about,".metabooktoc");
            var title=getTitleSpan(toc,name);
            if (Trace.gestures)
                fdjtLog("toc_held %o about=%o ref=%s toc=%o title=%s",
                        evt,about,ref,toc,title);
            addClass(title,"metabookpreviewtitle");
            addClass(about.parentNode,"metabookheld");
            var spanbar=getParent(about,".spanbar")||getChild(toc,".spanbar");
            addClass(spanbar,"metabookvisible");
            addClass(toc,"metabookheld");
            metaBook.startPreview(mbID(ref),"toc_held");
            return cancel(evt);}
        else if (Trace.gestures) fdjtLog("toc_held %o noabout", evt);
        else {}}
    function toc_released(evt){
        evt=evt||window.event;
        var about=getAbout(fdjtUI.T(evt));
        previewTimeout(false);
        if (about) {
            var name=about.name||about.getAttribute("name");
            var ref=name.slice(3);
            var toc=getParent(about,".metabooktoc");
            var title=getTitleSpan(toc,name);
            if (Trace.gestures)
                fdjtLog("toc_released %o ref=%o about=%o toc=%o title=%s",
                        evt,ref,about,toc,title);
            dropClass(title,"metabookpreviewtitle");
            dropClass(about.parentNode,"metabookheld");
            var spanbar=getParent(about,".spanbar")||getChild(toc,".spanbar");
            dropClass(spanbar,"metabookvisible");
            dropClass(toc,"metabookheld");
            if (mB.previewing)
                metaBook.stopPreview("toc_released");}
        else if (Trace.gestures) {
            fdjtLog("toc_released %o noabout",evt);
            metaBook.stopPreview("toc_released");}
        else {
            metaBook.stopPreview("toc_released");}
        cancel(evt);}
    function toc_touchtoo(evt){
        evt=evt||window.event;
        previewTimeout(false);
        if (!(mB.previewing)) return;
        else if (Trace.gestures) {
            fdjtLog("toc_touchtoo %o noabout",evt);
            metaBook.stopPreview("toc_touchtoo",true);}
        else {
            metaBook.stopPreview("toc_touchtoo",true);}
        cancel(evt);}
    function toc_slipped(evt){
        evt=evt||window.event;
        if (slip_timer) return;
        slipTimeout(function(){
            slip_timer=false;
            if (Trace.gestures)
                fdjtLog("toc_slipped/timeout %o",evt);
            metaBook.stopPreview("toc_slipped");});}

    /* Highlighting terms in passages (for skimming, etc) */

    var wordRegExp=fdjtDOM.wordRegExp;

    function highlightTerm(term,target,info,spellings){
        var words=[]; var highlights=[];
        if (typeof term === 'string')
            words=((spellings)&&(spellings[term]))||[term];
        else {
            var knodes=info.knodes;
            if (!(knodes)) knodes=[];
            else if (!(knodes instanceof Array)) knodes=[knodes];
            var i=0; var lim=knodes.length;
            while (i<lim) {
                var knode=knodes[i++];
                if ((knode===term)||(RefDB.contains(knode.allways,term))) {
                    var qid=knode._qid; var dterm=knode.dterm;
                    var spelling=
                        ((spellings)&&
                         ((spellings[qid])||(spellings[dterm])));
                    if (!(spelling)) {
                        var synonyms=knode.EN;
                        if (!(synonyms)) {}
                        else if (typeof synonyms === 'string')
                            words.push(synonyms);
                        else words=words.concat(synonyms);
                        var hooks=knode.hooks;
                        if (!(hooks)) {}
                        else if (typeof hooks === 'string')
                            words.push(hooks);
                        else words=words.concat(hooks);}
                    else if (typeof spelling === 'string')
                        words.push(spelling);
                    else words=words.concat(spelling);}}
            if (words.length===0) words=false;}
        if (!(words)) return [];
        if (typeof words === 'string') words=[words];
        var j=0; var jlim=words.length;
        while (j<jlim) {
            var word=words[j++];
            var pattern=wordRegExp(word);
            var dups=metaBook.getDups(target);
            var ranges=fdjtDOM.findMatches(dups,pattern);
            if (!((ranges)&&(ranges.length))) {
                pattern=wordRegExp(word,true);
                ranges=fdjtDOM.findMatches(dups,pattern);}
            if (Trace.highlight)
                fdjtLog("Trying to highlight %s (using %o) in %o, ranges=%o",
                        word,pattern,target,ranges);
            if ((ranges)&&(ranges.length)) {
                var k=0; while (k<ranges.length) {
                    var h=fdjtUI.Highlight(
                        ranges[k++],"mbhighlightsearch");
                    highlights=highlights.concat(h);}}}
        return highlights;}
    metaBook.highlightTerm=highlightTerm;

    /* Keyboard handlers */

    // We use keydown to handle navigation functions and keypress
    //  to handle mode changes
    function onkeydown(evt){
        evt=evt||window.event||null;
        var kc=evt.keyCode;
        var target=fdjtUI.T(evt);
        // fdjtLog("sbook_onkeydown %o",evt);
        if (evt.keyCode===27) { /* Escape works anywhere */
            if (mB.previewing) {
                metaBook.stopPreview("escape_key");
                fdjtUI.TapHold.clear();}
            dropClass(document.body,"mbZOOM");
            dropClass(document.body,"mbMEDIA");
            if (mB.mode==="addgloss") metaBook.cancelGloss();
            if (mB.mode) {
                metaBook.last_mode=metaBook.mode;
                setMode(false);
                metaBook.setTarget(false);
                $ID("METABOOKSEARCHINPUT").blur();}
            else {}
            return;}
        else if ((target.tagName==="TEXTAREA")||
                 (target.tagName==="INPUT")||
                 (target.tagName==="BUTTON"))
            return;
        else if (hasClass(document.body,"mbZOOM"))
            return;
        else if ((mB.controlc)&&(evt.ctrlKey)&&((kc===99)||(kc===67))) {
            if (mB.previewing) metaBook.stopPreview("onkeydown",true);
            fdjtUI.TapHold.clear();
            setMode("console");
            cancel(evt);}
        else if ((evt.altKey)||(evt.ctrlKey)||(evt.metaKey)) return true;
        else if (mB.previewing) {
            // Any key stops a preview and goes to the target
            metaBook.stopPreview("onkeydown",true);
            fdjtUI.TapHold.clear();
            setHUD(false);
            cancel(evt);
            return false;}
        else if (hasClass(document.body,"mbCOVER")) {
            metaBook.clearStateDialog();
            metaBook.hideCover();
            cancel(evt);
            return false;}
        else if (mB.glossform) {
            var input=fdjt.DOM.getInput(mB.glossform,"NOTE");
            metaBook.UI.glossFormFocus(mB.glossform);
            metaBook.setFocus(input); input.focus();
            var new_evt=document.createEvent("UIEvent");
            new_evt.initUIEvent("keydown",true,true,window);
            new_evt.keyCode=kc;
            input.dispatchEvent(new_evt);
            cancel(evt);
            return;}
        else if (kc===34) pageForward(evt);   /* page down */
        else if (kc===33) pageBackward(evt);  /* page up */
        else if (kc===40) { /* arrow down */
            setHUD(false);
            pageForward(evt);}
        else if (kc===38) {  /* arrow up */
            setHUD(false);
            metaBook.pageBackward(evt);}
        else if (kc===37) metaBook.skimBackward(evt); /* arrow left */
        else if (kc===39) metaBook.skimForward(evt); /* arrow right */
        // Don't interrupt text input for space, etc
        else if (fdjtDOM.isTextInput(fdjtDOM.T(evt))) return true;
        else if (kc===32) { // Space
            if ((mB.mode)&&(!(mB.skimming))&&
                (pagers[metaBook.mode])) {
                if (evt.shiftKey)
                    showPage.fastForward(pagers[metaBook.mode]);
                else showPage.forward(pagers[metaBook.mode]);}
            else if (mB.skimming) pageForward(evt);
            else pageForward(evt,true);}
        else if ((kc===8)||(kc===45)) { // backspace or delete
            if ((mB.mode)&&(!(mB.skimming))&& (pagers[metaBook.mode])) {
                if (evt.shiftKey)
                    showPage.fastBackward(pagers[metaBook.mode]);
                else showPage.backward(pagers[metaBook.mode]);}
            else if (mB.skimming) pageBackward(evt);
            else pageBackward(evt,true);}
        // Home goes to the current head.
        else if (kc===36) metaBook.JumpTo(mB.head);
        else if (mB.mode==="addgloss") {
            var mode=metaBook.getGlossMode();
            if (mode) return;
            var formdiv=$ID("METABOOKLIVEGLOSS");
            var form=(formdiv)&&(getChild(formdiv,"FORM"));
            if (!(form)) return;
            if (kc===13) { // return/newline
                submitEvent(form);}
            else if ((kc===35)||(kc===91)) // # or [
                metaBook.setGlossMode("addtag",form);
            else if (kc===32) // Space
                metaBook.setGlossMode("editnote",form);
            else if ((kc===47)||(kc===58)) // /or :
                metaBook.setGlossMode("attach",form);
            else if ((kc===64)) // @
                metaBook.setGlossMode("addoutlet",form);
            else {}}
        else return;
        cancel(evt);}

    // At one point, we had the shift key temporarily raise/lower the HUD.
    //  We might do it again, so we keep this definition around
    function onkeyup(evt){
        evt=evt||window.event||null;
        if (fdjtDOM.isTextInput(fdjtDOM.T(evt))) return true;
        else if ((evt.ctrlKey)||(evt.altKey)||(evt.metaKey)) return true;
        else {}}
    metaBook.UI.handlers.onkeyup=onkeyup;

    /* Keypress handling */

    // We have a big table of command characters which lead to modes
    var modechars={
        63: "searching",102: "searching",
        65: "openheart", 97: "openheart",
        83: "searching",115: "searching",
        80: "gotopage",112: "gotopage",
        76: "gotoloc",108: "gotoloc",
        70: "searching",
        100: "device",68: "device",
        110: "overtoc",78: "overtoc",
        116: "statictoc",84: "statictoc", 72: "help", 
        103: "allglosses",71: "allglosses",
        67: "console", 99: "console"};

    // Handle mode changes
    function onkeypress(evt){
        var modearg=false; 
        evt=evt||window.event||null;
        var ch=evt.charCode||evt.keyCode;
        // metaBook.trace("sbook_onkeypress",evt);
        if (fdjtDOM.isTextInput(fdjtDOM.T(evt))) return true;
        else if ((evt.altKey)||(evt.ctrlKey)||(evt.metaKey)) return true;
        else if ((ch===72)||(ch===104)) { // 'H' or 'h'
            metaBook.clearStateDialog();
            metaBook.hideCover();
            fdjtDOM.toggleClass(document.body,'metabookhelp');
            return false;}
        else if ((ch===67)||(ch===99)) { // 'C' or 'c'
            metaBook.clearStateDialog();
            metaBook.toggleCover();
            return false;}
        else modearg=modechars[ch];
        if (modearg==="openheart")
            modearg=metaBook.last_heartmode||"about";
        var mode=setMode();
        if (modearg) {
            if (mode===modearg) {
                setMode(false); mode=false;}
            else {
                setMode(modearg); mode=modearg;}}
        else {}
        if (mode==="searching")
            metaBook.setFocus($ID("METABOOKSEARCHINPUT"));
        else metaBook.clearFocus($ID("METABOOKSEARCHINPUT"));
        fdjtDOM.cancel(evt);}
    metaBook.UI.handlers.onkeypress=onkeypress;

    function goto_keypress(evt){
        evt=evt||window.event||null;
        var target=fdjtUI.T(evt);
        var ch=evt.charCode||evt.keyCode;
        var max=false; var min=false;
        var handled=false;
        if (target.name==='GOTOLOC') {
            min=0; max=Math.floor(mB.ends_at/128);}
        else if (target.name==='GOTOPAGE') {
            min=1; max=metaBook.pagecount;}
        else if (ch===13) cancel(evt);
        if (ch===13) {
            if (target.name==='GOTOPAGE') {
                var num=parseInt(target.value,10);
                if (typeof num === 'number') {
                    handled=true; metaBook.GoToPage(num);}
                else if (isEmptyString(target.value))
                    handled=true;
                else {}}
            else if (target.name==='GOTOREF') {
                var pagemap=metaBook.layout.pagemap;
                var page=pagemap[target.value];
                if (page) {
                    metaBook.GoToPage(page); handled=true;}
                else if (isEmptyString(target.value))
                    handled=true;
                else {}}
            else if (target.name==='GOTOLOC') {
                var locstring=target.value;
                var loc=parseFloat(locstring);
                if ((typeof loc === 'number')&&(loc>=0)&&(loc<=100)) {
                    loc=Math.floor((loc/100)*metaBook.ends_at)+1;
                    metaBook.JumpTo(loc); handled=true;}
                else if (isEmptyString(target.value))
                    handled=true;
                else {}}
            else {}
            if (handled) {
                target.value="";
                setMode(false);}}}
    metaBook.UI.goto_keypress=goto_keypress;

    /* HUD button handling */

    function hudmodebutton(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var mode=target.getAttribute("hudmode");
        if (Trace.gestures)
            fdjtLog("hudmodebutton() %o mode=%o cl=%o skim=%o sbh=%o mode=%o",
                    evt,mode,(isClickable(target)),
                    metaBook.skimpoint,mB.hudup,mB.setMode());
        metaBook.clearStateDialog();
        if (reticle.live) reticle.flash();
        cancel(evt);
        if (!(mode)) return;
        if ((evt.type==='click')||
            (evt.type==='tap')||
            (evt.type==='release')) {
            dropClass(document.body,"_HOLDING");
            if ((mB.skimpoint)&&(!(mB.hudup))) {
                if ((mode==="refinesearch")||(mode==="searchresults")) {
                    setMode("searchresults"); return;}
                else if (mode==="allglosses") {
                    setMode("allglosses"); return;}
                else if (mode==="statictoc") {
                    setMode("statictoc"); return;}}
            if ((mB.closed)?
                (fdjtDOM.hasClass(mB.HUD,mode)):
                (fdjtDOM.hasClass(mB.HUD,mode)))
                setMode(false,true);
            else if ((mode==="search")&&
                     (fdjtDOM.hasClass(mB.HUD,mB.searchModes)))
                setMode(false,true);
            else setMode(mode);}
        else if (evt.type==="tap")
            setHUD(true);
        else if (evt.type==="hold") 
            addClass(document.body,"_HOLDING");
        else dropClass(document.body,"_HOLDING");}
    metaBook.UI.hudmodebutton=hudmodebutton;

    metaBook.UI.dropHUD=function(evt){
        var target=fdjtUI.T(evt);
        if (isClickable(target)) {
            if (Trace.gestures)
                fdjtLog("Clickable: don't dropHUD %o",evt);
            return;}
        if (Trace.gestures) fdjtLog("dropHUD %o",evt);
        cancel(evt); setMode(false);};

    /* Glossmarks */
    
    function glossmark_tapped(evt){
        evt=evt||window.event||null;
        if (held) clear_hold("glossmark_tapped");
        if ((evt.ctrlKey)||(evt.altKey)||(evt.metaKey)||(evt.shiftKey))
            return;
        var target=fdjtUI.T(evt);
        var glossmark=getParent(target,".glossmark");
        var passage=
            ((glossmark.name)&&
             (glossmark.name.search("GLOSSMARK_NAME_")===0)&&
             ($ID(glossmark.name.slice(15))))||
            getTarget(glossmark.parentNode,true);
        if ((passage)&&(passage.getAttribute("data-baseid"))) 
            passage=mbID(passage.getAttribute("data-baseid"));
        if (Trace.gestures)
            fdjtLog("glossmark_tapped (%o) on %o gmark=%o passage=%o mode=%o target=%o",
                    evt,target,glossmark,passage,mB.mode,mB.target);
        if (!(glossmark)) return false;
        cancel(evt);
        if ((mB.mode==='openglossmark')&&
            (mB.target===passage)) {
            setMode(false);
            metaBook.clearGlossmark();
            return;}
        else if (mB.select_target) return;
        else metaBook.showGlossmark(passage,glossmark);}

    var animated_glossmark=false;
    var glossmark_animated=false;
    var glossmark_image=false;
    function animate_glossmark(target,enable){
        if ((target)&&(enable)) {
            var glossmark=((hasClass(target,"glossmark"))?(target):
                           (getParent(target,".glossmark")));
            if (!(glossmark)) return;
            if (animated_glossmark===glossmark) return;
            if (glossmark_animated) {
                clearInterval(glossmark_animated);
                animated_glossmark=false;
                glossmark_animated=false;
                if (glossmark_image) fdjtUI.ImageSwap.reset(glossmark_image);}
            var wedge=getChild(glossmark,"img.wedge");
            if (!(wedge)) return;
            animated_glossmark=glossmark;
            glossmark_image=wedge;
            glossmark_animated=fdjtUI.ImageSwap(wedge,750);}
        else {
            if (glossmark_animated) {
                clearInterval(glossmark_animated);
                animated_glossmark=false;
                glossmark_animated=false;
                if (glossmark_image) fdjtUI.ImageSwap.reset(glossmark_image);
                glossmark_image=false;}}}

    function glossmark_hoverstart(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var passage=getTarget(target);
        if (!(fdjtDOM.hasClass(passage,"mbtarget")))
            animate_glossmark(target,true);}

    function glossmark_hoverdone(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var passage=getTarget(target);
        if (!(fdjtDOM.hasClass(passage,"mbtarget")))
            animate_glossmark(target,false);}

    function setTargetUI(target){
        if (target) {
            var glossmark=getChild(target,".glossmark");
            if (glossmark) animate_glossmark(glossmark,true);
            else animate_glossmark(false,false);}
        else animate_glossmark(false,false);}
    metaBook.UI.setTarget=setTargetUI;

    /* Various actions */

    function forceSyncAction(evt){
        evt=evt||window.event;
        cancel(evt);
        metaBook.forceSync();
        if (!(navigator.onLine))
            fdjtUI.alertFor(
                15,"You're currently offline; information will be synchronized when you're back online");
        else if (!(mB.connected))
            fdjtUI.alertFor(
                15,"You're not currently logged into sBooks.  Information will be synchronized when you've logged in.");
        else fdjtUI.alertFor(7,"Sychronizing glosses, etc with the remote server");
        return false;}
    metaBook.UI.forceSyncAction=forceSyncAction;


    /* Moving forward and backward */

    var last_motion=false;

    function forward(evt){
        if (!(evt)) evt=window.event||false;
        if (evt) cancel(evt);
        if (Trace.nav)
            fdjtLog("Forward e=%o h=%o t=%o",evt,
                    metaBook.head,mB.target);
        if (mB.skimming)
            skimForward(evt);
        else if ((mB.mode)&&(pagers[metaBook.mode]))
            showPage.forward(pagers[metaBook.mode]);
        else if ((evt)&&(evt.shiftKey))
            skimForward(evt);
        else pageForward(evt);}
    metaBook.Forward=forward;
    function backward(evt){
        if (!(evt)) evt=window.event||false;
        if (evt) cancel(evt);
        if (Trace.nav)
            fdjtLog("Backward e=%o h=%o t=%o",evt,
                    metaBook.head,mB.target);
        if (mB.skimming)
            skimBackward(evt);
        else if ((mB.mode)&&(pagers[metaBook.mode]))
            showPage.backward(pagers[metaBook.mode]);
        else if ((evt)&&(evt.shiftKey))
            skimBackward();
        else pageBackward();}
    metaBook.Backward=backward;

    function preview_touchmove_nodefault(evt){
        if (mB.previewing) fdjtUI.noDefault(evt);}

    function pageForward(evt,clearmodes){
        evt=evt||window.event;
        dropClass(document.body,/\bmb(PAGE)?PREVIEW/g);
        var now=fdjtTime();
        if ((last_motion)&&((now-last_motion)<100)) return;
        else last_motion=now;
        dropClass(document.body,/\bmb(PAGE)?PREVIEW/g);
        if ((clearmodes)&&((mB.hudup)||(mB.mode)))
            fdjt.Async(function(){mB.setHUD(false);});
        else if (mB.skimming) dropClass("METABOOKSKIMMER","expanded");
        else {}
        if (mB.readsound)
            fdjtDOM.playAudio("METABOOKPAGEORWARDAUDIO");
        if ((Trace.gestures)||(Trace.flips))
            fdjtLog("pageForward (on %o) c=%o n=%o",
                    evt,mB.curpage,mB.pagecount);
        if ((mB.bypage)&&(typeof metaBook.curpage === "number")) {
            var pagemax=((mB.bypage)&&
                         ((mB.pagecount)||(mB.layout.pagenum-1)));
            var newpage=false;
            if (mB.curpage>=pagemax) {}
            else metaBook.GoToPage(
                newpage=metaBook.curpage+1,"pageForward",true,true);}
        else {
            var delta=fdjtDOM.viewHeight()-50;
            if (delta<0) delta=fdjtDOM.viewHeight();
            var newy=fdjtDOM.viewTop()+delta;
            window.scrollTo(fdjtDOM.viewLeft(),newy);}}
    metaBook.pageForward=pageForward;

    function pageBackward(evt,clearmodes){
        var now=fdjtTime();
        dropClass(document.body,/\bmb(PAGE)?PREVIEW/g);
        if ((last_motion)&&((now-last_motion)<100)) return;
        else last_motion=now;
        evt=evt||window.event;
        if (clearmodes) fdjt.Async(function(){mB.setHUD(false);});
        else if (mB.skimming) dropClass("METABOOKSKIMMER","expanded");
        else {}
        if (mB.readsound)
            fdjtDOM.playAudio("METABOOKPAGEBACKWARDAUDIO");
        if ((Trace.gestures)||(Trace.flips))
            fdjtLog("pageBackward (on %o) c=%o n=%o",
                    evt,mB.curpage,mB.pagecount);
        if ((mB.bypage)&&(typeof metaBook.curpage === "number")) {
            var newpage=false;
            if (mB.curpage===0) {}
            else {
                newpage=metaBook.curpage-1;
                metaBook.GoToPage(newpage,"pageBackward",true,true);}}
        else {
            var delta=fdjtDOM.viewHeight()-50;
            if (delta<0) delta=fdjtDOM.viewHeight();
            var newy=fdjtDOM.viewTop()-delta;
            window.scrollTo(fdjtDOM.viewLeft(),newy);}}
    metaBook.pageBackward=pageBackward;

    function skimForward(evt){
        var now=fdjtTime(), slice=metaBook[metaBook.mode];
        if ((Trace.gestures)||(Trace.nav))
            fdjtLog("skimForward %o: mode=%s",evt,mB.mode);
        dropClass(document.body,/\bmb(PAGE)?PREVIEW/g);
        if ((last_motion)&&((now-last_motion)<100)) return;
        else last_motion=now;
        if (mB.uisound)
            fdjtDOM.playAudio("METABOOKSKIMFORWARDAUDIO");
        if (!(slice)) return;
        if (mB.uisound)
            fdjtDOM.playAudio("METABOOKSKIMFORWARDAUDIO");
        addClass("METABOOKSKIMMER","flash");
        addClass("METABOOKNEXTSKIM","flash");
        setTimeout(function(){
            dropClass("METABOOKSKIMMER","flash");
            dropClass("METABOOKNEXTSKIM","flash");},
                   200);
        var next=slice.forward();
        if (next) metaBook.SkimTo(next,1);
        return next;}
    metaBook.skimForward=skimForward;

    function skimBackward(evt){
        var now=fdjtTime(), slice=metaBook[metaBook.mode];
        if ((Trace.gestures)||(Trace.nav))
            fdjtLog("skimBackward %o: mode=%s",evt,mB.mode);
        dropClass(document.body,/\bmb(PAGE)?PREVIEW/g);
        if ((last_motion)&&((now-last_motion)<100)) return;
        else last_motion=now;
        if (mB.uisound)
            fdjtDOM.playAudio("METABOOKSKIMBACKWARDAUDIO");
        if (!(slice)) return;
        addClass("METABOOKPREVSKIM","flash");
        addClass("METABOOKSKIMMER","flash");
        setTimeout(function(){
            dropClass("METABOOKSKIMMER","flash");
            dropClass("METABOOKPREVSKIM","flash");},
                   200);
        var next=slice.backward();
        if (next) metaBook.SkimTo(next,-1);
        return next;}
    metaBook.skimBackward=skimBackward;

    function skimmer_tapped(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        if (isClickable(target)) return;
        if ((getParent(target,".ellipsis"))&&
            ((getParent(target,".elision"))||
             (getParent(target,".delision")))){
            fdjtDOM.toggleClass("METABOOKSKIMMER","expanded");
            // fdjtUI.Ellipsis.toggle(target);
            cancel(evt);
            return;}
        if ((getParent(target,".tool"))) {
            var card=getCard(target);
            if ((card)&&((card.name)||(card.getAttribute("name")))) {
                var name=(card.name)||(card.getAttribute("name"));
                var gloss=RefDB.resolve(name,mB.glossdb);
                if (!(gloss)) return;
                var form=metaBook.setGlossTarget(gloss);
                if (!(form)) return;
                metaBook.stopSkimming();
                setMode("addgloss");
                return;}
            else return;}
        if (getParent(target,".mbmedia")) {
            var link=getParent(target,".mbmedia");
            var src=link.getAttribute("data-src"), cancelling=false;
            var type=link.getAttribute("data-type");
            if (hasClass(link,"imagelink")) {
                metaBook.showMedia(src,type); cancelling=true;}
            else if ((hasClass(link,"audiolink"))||
                     (hasClass(link,"musiclink"))) {
                metaBook.showMedia(src,type); cancelling=true;}
            else {}
            if (cancelling) {
                cancel(evt);
                return;}}
        if (getParent(target,".tochead")) {
            var anchor=getParent(target,".tocref");
            var href=(anchor)&&(anchor.getAttribute("data-tocref"));
            if (href) metaBook.GoTOC(href);
            else toggleClass("METABOOKSKIMMER","expanded");}
        else toggleClass("METABOOKSKIMMER","expanded");
        cancel(evt);
        return;}

    function skimmer_taptap(evt){
        metaBook.stopSkimming();
        cancel(evt);}
    
    function skimmer_swiped(evt){
        var dx=evt.deltaX, dy=evt.deltaY;
        var vw=fdjtDOM.viewWidth();
        var adx=((dx<0)?(-dx):(dx)), ady=((dy<0)?(-dy):(dy));
        if (Trace.gestures)
            fdjtLog("skimmer_swiped d=%o,%o, ad=%o,%o, s=%o,%o vw=%o, n=%o",
                    dx,dy,adx,ady,evt.startX,evt.startY,vw,evt.ntouches);
        if (adx>(ady*2)) {
            // Horizontal swipe
            if (dx<-(mB.minswipe||10))
                metaBook.skimForward(evt);
            else if (dx>(mB.minswipe||10))
                metaBook.skimBackward(evt);
            else {/* Ignored */}}
        else if (ady>(adx*2)) {
            // Vertical swipe
            if (ady<=(mB.minswipe||10)) return;
            else if (dy<0) mB.setHUD(false);
            else mB.stopSkimming();}
        else {}
        cancel(evt);}

    /* Entering page numbers and locations */

    function enterPageNum(evt) {
        evt=evt||window.event;
        if ((mB.hudup)||(mB.mode)||(mB.cxthelp)) {
            cancel(evt);
            setMode(false);
            return;}
        cancel(evt);
        if (mB.hudup) {setMode(false); return;}
        setMode("gotopage",true);}
    function enterPageRef(evt) {
        evt=evt||window.event;
        if ((mB.hudup)||(mB.mode)||(mB.cxthelp)) {
            cancel(evt);
            setMode(false);
            return;}
        cancel(evt);
        if (mB.hudup) {setMode(false); return;}
        setMode("gotoref",true);}
    function enterLocation(evt) {
        evt=evt||window.event;
        if ((mB.hudup)||(mB.mode)||(mB.cxthelp)) {
            cancel(evt);
            setMode(false);
            return;}
        cancel(evt);
        if (mB.hudup) {setMode(false); return;}
        setMode("gotoloc",true);}
    function enterPercentage(evt) {
        evt=evt||window.event;
        if ((mB.hudup)||(mB.mode)||(mB.cxthelp)) {
            cancel(evt);
            setMode(false);
            return;}
        cancel(evt);
        if (mB.hudup) {setMode(false); return;}
        setMode("gotoloc",true);}
    
    /* Other handlers */

    function flyleaf_tap(evt){
        if (isClickable(evt)) return;
        else setMode(false);}

    function head_tap(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        if (Trace.gestures) fdjtLog("head_tap %o t=%o",evt,target);
        if (mB.previewing) {
            metaBook.stopPreview("head_tap");
            cancel(evt);
            return;}
        if (fdjtUI.isClickable(target)) return;
        if (!((target===metaBook.DOM.head)||
              (target===metaBook.DOM.tabs)))
            return;
        else if (mB.mode) {
            cancel(evt);
            setMode(false);}
        else if (fdjtDOM.hasClass(document.body,"mbSHOWHELP")) {
            cancel(evt);
            dropClass(document.body,"mbSHOWHELP");}
        else if (mB.hudup) {
            cancel(evt);
            setMode(false);}
        else {
            cancel(evt);
            setMode(true);}}
    function foot_tap(evt){
        if (Trace.gestures) fdjtLog("foot_tap %o",evt);
        if (mB.previewing) {
            metaBook.stopPreview("foot_tap");
            cancel(evt);
            return;}
        if ((isClickable(evt))||(hasParent(fdjtUI.T(evt),"hudbutton")))
            return;
        else if ((mB.hudup)||(mB.mode)||(mB.cxthelp)) {
            cancel(evt);
            setMode(false);
            return;}}

    /* Back to the text */

    function back_to_reading(evt){
        evt=evt||window.event;
        cancel(evt);
        if (mB.mode==="addgloss") 
            metaBook.cancelGloss();
        setMode(false);
        dropClass(document.body,"mbSHOWHELP");}

    function clearMode(evt){
        evt=evt||window.event; setMode(false);}

    /* Tracking text input */

    function setFocus(target){
        if (!(target)) {
            var cur=metaBook.textinput;
            metaBook.textinput=false;
            metaBook.freezelayout=false;
            if (cur) cur.blur();
            return;}
        else if (mB.textinput===target) return;
        else {
            metaBook.textinput=target;
            metaBook.freezelayout=true;
            target.focus();}}
    metaBook.setFocus=setFocus;
    function clearFocus(target){
        if (!(target)) target=metaBook.textinput;
        if ((target)&&(mB.textinput===target)) {
            metaBook.textinput=false;
            metaBook.freezelayout=false;
            target.blur();}}
    metaBook.clearFocus=clearFocus;

    function metabookfocus(evt){
        evt=evt||window.event;
        var target=fdjtUI.T(evt);
        var input=getParent(target,'textarea');
        if (!(input)) input=getParent(target,'input');
        if ((!(input))||(typeof input.type !== "string")||
            (input.type.search(fdjtDOM.text_types)!==0))
            return;
        setFocus(input);}
    metaBook.UI.focus=metabookfocus;
    function metabookblur(evt){
        evt=evt||window.event;
        var target=((evt.nodeType)?(evt):(fdjtUI.T(evt)));
        var input=getParent(target,'textarea');
        if ((metaBook.previewing)&&(target===window))
            metaBook.stopPreview();
        if (!(input)) input=getParent(target,'input');
        if ((!(input))||(typeof input.type !== "string")||
            (input.type.search(fdjtDOM.text_types)!==0))
            return;
        clearFocus(input);}
    metaBook.UI.blur=metabookblur;

    function metabookmouseout(evt){
        var target=fdjtUI.T(evt);
        if ((target===window)||(target===document.documentElement)) {
            if (metaBook.previewing) metaBook.stopPreview();}}

    function metabookvischange(evt){
        evt=evt||window.event;
        if (document[fdjtDOM.isHidden]) {
            if (metaBook.previewing) metaBook.stopPreview();}}

    /* Rules */

    
    function setHelp(flag){
        if (flag) {
            addClass(document.body,"mbSHOWHELP");
            metaBook.cxthelp=true;}
        else {
            dropClass(document.body,"mbSHOWHELP");
            metaBook.cxthelp=false;}
        return false;}
    metaBook.setHelp=setHelp;
    
    function toggleHelp(evt){
        evt=evt||window.event;
        if (Trace.gestures) fdjtLog("toggleHelp %o",evt);
        cancel(evt);
        if (mB.cxthelp) {
            dropClass(document.body,"mbSHOWHELP");
            metaBook.cxthelp=false;}
        else {
            addClass(document.body,"mbSHOWHELP");
            metaBook.cxthelp=true;}
        return false;}
    metaBook.toggleHelp=toggleHelp;

    function handleXTarget(evt){
        evt=evt||window.event;
        var anchor=fdjtUI.T(evt);
        if ((anchor.href)&&(anchor.href[0]==='#')&&
            (mB.xtargets[anchor.href.slice(1)])) {
            var fn=metaBook.xtargets[anchor.href.slice(1)];
            cancel(evt);
            fn();}}

    function showcover_tapped(evt){
        evt=evt||window.event;
        if ((mB.touch)&&(!(mB.hudup))) return;
        if (!((evt.shiftKey)||((evt.touches)&&(evt.touches.length>=2)))) {
            var opened=
                metaBook.readLocal(
                    "mB("+mB.docid+").opened",
                    true);
            if ((opened)&&((opened-fdjtTime())>(60*10*1000))) {
                if ($ID("METABOOKCOVERHOLDER"))
                    $ID("METABOOKCOVER").className="bookcover";
                else $ID("METABOOKCOVER").className="titlepage";}}
        metaBook.clearStateDialog();
        metaBook.showCover();
        cancel(evt);}
    function showcover_released(evt){
        evt=evt||window.event;
        if (!((evt.shiftKey)||((evt.touches)&&(evt.touches.length>=2))))
            $ID("METABOOKCOVER").className="bookcover";
        metaBook.clearStateDialog();
        metaBook.showCover();
        cancel(evt);}

    function global_mouseup(evt){
        evt=evt||window.event;
        if (mB.zoomed) return;
        if (mB.page_turner) {
            clearInterval(mB.page_turner);
            metaBook.page_turner=false;
            return;}
        if (mB.select_target) {
            metaBook.startAddGloss(
                metaBook.select_target,
                ((evt.shiftKey)&&("addtag")),evt);
            metaBook.select_target=false;}}
    
    function raiseHUD(evt){
        evt=evt||window.event;
        if (Trace.gestures) fdjtLog("raiseHUD %o",evt);
        setHUD(true);
        cancel(evt);
        return false;}
    metaBook.raiseHUD=raiseHUD;
    function lowerHUD(evt){
        evt=evt||window.event;
        if (Trace.gestures) fdjtLog("lowerHUD %o",evt);
        setHUD(false);
        cancel(evt);
        return false;}
    metaBook.lowerHUD=lowerHUD;

    function saveGloss(evt){
        evt=evt||window.event;
        if (Trace.gestures) fdjtLog("saveGloss %o",evt);
        metaBook.submitGloss();}
    function refreshLayout(evt){
        evt=evt||window.event; cancel(evt);
        if (Trace.gestures) fdjtLog("refreshLayout %o",evt);
        metaBook.refreshLayout();}
    function resetState(evt){
        evt=evt||window.event; cancel(evt);
        fdjtUI.choose(
            {choices: [{label: "OK",isdefault: true,
                        handler: function(){
                            metaBook.resetState();}},
                       {label: "Cancel"}],
             spec: "div.fdjtdialog.mbsettings"},
            "Mark current location as ",
            fdjtDOM("em","latest")," and ",
            fdjtDOM("em","farthest"),"?",
            ((mB.locsync)&&("for all syncing devices")));}
    function refreshOffline(evt){
        evt=evt||window.event; cancel(evt);
        fdjtUI.choose(
            {choices: [{label: "OK",isdefault: true,
                        handler: function(){
                            metaBook.refreshOffline();}},
                       {label: "Cancel"}],
             spec: "div.fdjtdialog.mbsettings"},
            "Reload all glosses and layers?");}
    function clearOffline(evt){
        evt=evt||window.event; cancel(evt);
        if (Trace.gestures) fdjtLog("clearOffline %o",evt);
        metaBook.clearOffline();}
    function consolefn(evt){
        evt=evt||window.event; metaBook.consolefn(evt);}

    var devmode_click=false;
    function toggleDevMode(evt){
        fdjtLog("toggleDevMode %o",evt);
        if (devmode_click) {
            var root=document.documentElement||document.body;
            var now=fdjtTime();
            if ((now-devmode_click)<1000) {
                if (mB.devmode)  {
                    metaBook.devmode=false;
                    fdjtState.dropLocal("mB.devmode");
                    dropClass(root,"_DEVMODE");}
                else {
                    metaBook.devmode=true;
                    fdjtState.setLocal("mB.devmode",true);
                    addClass(root,"_DEVMODE");}
                devmode_click=false;}
            else devmode_click=now;}
        else devmode_click=fdjtTime();
        cancel(evt);}

    function cancelNotAnchor(evt){
        var target=fdjt.UI.T(evt);
        if (hasParent(target,"A[href]")) {
            if ((clicked)&&((fdjtTime()-clicked)<2000)) 
                cancel(evt);
            return;}
        else cancel(evt);}

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.mouse,
        {window: {
            keyup: onkeyup,
            keydown: onkeydown,
            keypress: onkeypress,
            focus: metabookfocus,
            mouseout: metabookmouseout,
            blur: metabookblur},
         "#METABOOKBODY": {
             mouseup: global_mouseup},
         content: {tap: body_tapped,
                   taptap: body_taptap,
                   hold: body_held,
                   release: body_released,
                   mousedown: body_touchstart,
                   mouseup: body_touchend,
                   click: cancelNotAnchor},
         toc: {tap: toc_tapped,hold: toc_held,
               release: toc_released, slip: toc_slipped,
               mouseover: fdjtUI.CoHi.onmouseover,
               mouseout: fdjtUI.CoHi.onmouseout,
               click: cancel},
         ".mbtocslice": {
             mouseover: fdjtUI.CoHi.onmouseover,
             mouseout: fdjtUI.CoHi.onmouseout},
         glossmark: {mouseup: glossmark_tapped,
                     click: cancel, mousedown: cancel,
                     mouseover: glossmark_hoverstart,
                     mouseout: glossmark_hoverdone},
         hud: {click: handleXTarget, tap: handleXTarget},
         "#METABOOKSTARTPAGE": {click: metaBook.UI.dropHUD},
         "#METABOOKTOPBAR": {tap: raiseHUD},
         "#METABOOKSHOWCOVER": {
             tap: showcover_tapped, release: showcover_released},
         "#METABOOKHUDHELP": {click: metaBook.UI.dropHUD},
         ".helphud": {click: metaBook.UI.dropHUD},
         ".metabookheart": {tap: flyleaf_tap},
         "#METABOOKPAGEREFTEXT": {tap: enterPageRef},
         "#METABOOKPAGENOTEXT": {tap: enterPageNum},
         "#METABOOKLOCPCT": {tap: enterPercentage},
         "#METABOOKLOCOFF": {tap: enterLocation},
         // Return to skimmer
         "#METABOOKSKIMMER": {tap: skimmer_tapped,
                              taptap: skimmer_taptap,
                              swipe: skimmer_swiped},
         // Expanding/contracting the skimmer
         // Raise and lower HUD
         "#METABOOKPAGEHEAD": {click: head_tap},
         "#METABOOKTABS": {click: head_tap},
         "#METABOOKHEAD": {click: head_tap},
         "#METABOOKPAGEFOOT": {tap: foot_tap},
         ".searchcloud": {
             tap: metaBook.UI.handlers.searchcloud_select,
             release: metaBook.UI.handlers.searchcloud_select},
         "#METABOOKHELPBUTTON": {
             tap: toggleHelp,
             hold: function(evt){setHelp(true); cancel(evt);},
             release: function(evt){setHelp(false); cancel(evt);},
             slip: function(evt){setHelp(false); cancel(evt);}},
         "#METABOOKHELP": {
             click: toggleHelp, mousedown: cancel,mouseup: cancel},
         "#METABOOKNEXTPAGE": {click: function(evt){
             pageForward(evt); cancel(evt);}},
         "#METABOOKPREVPAGE": {click: function(evt){
             pageBackward(evt); cancel(evt);}},
         "#METABOOKNEXTSKIM": {click: function(evt){
             skimForward(evt); cancel(evt);}},
         "#METABOOKPREVSKIM": {click: function(evt){
             skimBackward(evt); cancel(evt);}},
         "#METABOOKSHOWTEXT": {click: back_to_reading},
         "#METABOOKGLOSSDETAIL": {click: metaBook.UI.dropHUD},
         "#METABOOKNOTETEXT": {click: jumpToNote},
         ".hudmodebutton": {
             tap: hudmodebutton,hold: hudmodebutton,
             slip: hudmodebutton,release: hudmodebutton},
         ".hudbutton[alt='save gloss']": {
             tap: saveGloss,hold: saveGloss},
         ".metabookclosehud": {click: back_to_reading},
         "#METABOOKSETTINGS": {click: fdjt.UI.CheckSpan.onclick},
         ".metabooktogglehelp": {click: toggleHelp},
         "#METABOOKCONSOLETEXTINPUT": {
             focus: function(){
                 fdjt.DOM.addClass('METABOOKCONSOLEINPUT','uptop');},
             blur: function(){
                 fdjt.DOM.dropClass('METABOOKCONSOLEINPUT','uptop');}},
         "#METABOOKCONSOLEBUTTON": {click: consolefn},
         "#METABOOKREFRESHOFFLINE": {tap: refreshOffline},
         "#METABOOKREFRESHLAYOUT": {tp: refreshLayout},
         "#METABOOKRESETSYNC": {tap: resetState},
         ".clearoffline": {click: clearOffline},
         ".metabookclearmode": {click: clearMode},
         "#METABOOKGOTOREFHELP": {click: clearMode},
         "#METABOOKGOTOPAGEHELP": {click: clearMode},
         "#METABOOKGOTOLOCHELP": {click: clearMode},
         ".metabookshowsearch": {click: function(evt){
             metaBook.showSearchResults(); cancel(evt);}},
         ".metabookrefinesearch": {click: function(evt){
             setMode('refinesearch'); cancel(evt);}},
         ".metabookexpandsearch": {click: function(evt){
             setMode('expandsearch'); cancel(evt);}},
         ".metabookclearsearch": {click: function(evt){
             evt=evt||window.event;
             metaBook.UI.handlers.clearSearch(evt);
             cancel(evt);
             return false;}},
         "#METABOOKSEARCHINFO": { click: metaBook.searchTags_onclick },
         "#METABOOKINFOPANEL": {
             click: toggleDevMode},
         ".metabooksettings input[type='RADIO']": {
             change: mB.configChange},
         ".metabooksettings input[type='CHECKBOX']": {
             change: mB.configChange}
        });

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.touch,
        {window: {
            keyup: onkeyup,
            keydown: onkeydown,
            keypress: onkeypress,
            touchmove: preview_touchmove_nodefault,
            focus: metabookfocus,
            blur: metabookblur},
         content: {tap: body_tapped,
                   hold: body_held,
                   taptap: body_taptap,
                   release: body_released,
                   swipe: body_swiped,
                   touchstart: body_touchstart,
                   touchend: body_touchend,
                   touchmove: noDefault,
                   click: cancelNotAnchor},
         hud: {touchend: handleXTarget, tap: handleXTarget},
         toc: {tap: toc_tapped,hold: toc_held,
               slip: toc_slipped, release: toc_released,
               touchtoo: toc_touchtoo,
               touchmove: preview_touchmove_nodefault},
         glossmark: {touchstart: glossmark_tapped,touchend: cancel},
         "#METABOOKSTARTPAGE": {touchend: metaBook.UI.dropHUD},
         "#METABOOKTOPBAR": {tap: raiseHUD},
         "#METABOOKSHOWCOVER": {
             tap: showcover_tapped, release: showcover_released},
         "#METABOOKSEARCHINFO": { click: metaBook.searchTags_onclick },
         "#METABOOKPAGEFOOT": {},
         "#METABOOKPAGEREFTEXT": {tap: enterPageRef},
         "#METABOOKPAGENOTEXT": {tap: enterPageNum},
         "#METABOOKLOCPCT": {tap: enterPercentage},
         "#METABOOKLOCOFF": {tap: enterLocation},
         // Return to skimming
         "#METABOOKSKIMMER": {
             tap: skimmer_tapped,
             taptap: skimmer_taptap,
             swipe: skimmer_swiped},
         // Expanding/contracting the skimmer
         // Raise and lower HUD
         "#METABOOKPAGEHEAD": {touchstart: head_tap},
         "#METABOOKTABS": {touchstart: head_tap},
         "#METABOOKHEAD": {touchend: head_tap},
         "#METABOOKFOOT": {
             tap: foot_tap,touchstart: noDefault,touchmove: noDefault},
         "#METABOOKGLOSSDETAIL": {
             touchend: metaBook.UI.dropHUD,click: cancel},
         ".searchcloud": {
             tap: metaBook.UI.handlers.searchcloud_select,
             release: metaBook.UI.handlers.searchcloud_select},
         "#METABOOKNEXTPAGE": {touchstart: function(evt){
             pageForward(evt); cancel(evt);}},
         "#METABOOKPREVPAGE": {touchstart: function(evt){
             pageBackward(evt); cancel(evt);}},
         "#METABOOKNEXTSKIM": {touchstart: function(evt){
             skimForward(evt); cancel(evt);}},
         "#METABOOKPREVSKIM": {touchstart: function(evt){
             skimBackward(evt); cancel(evt);}},
         "#METABOOKHELP": {tap: toggleHelp, swipe: cancel},
         "#METABOOKHELPBUTTON": {
             tap: toggleHelp,
             hold: function(evt){setHelp(true); cancel(evt);},
             release: function(evt){setHelp(false); cancel(evt);},
             slip: function(evt){setHelp(false); cancel(evt);}},
         "#METABOOKNOTETEXT": {touchend: jumpToNote,click: cancel},
         "#METABOOKSHOWTEXT": {
             touchstart: back_to_reading,
             touchmove: cancel,
             touchend: cancel},
         ".hudmodebutton": {
             tap: hudmodebutton,hold: hudmodebutton,release: hudmodebutton,
             slip: hudmodebutton},
         ".hudbutton[alt='save gloss']": {
             tap: saveGloss,hold: saveGloss},
         // GLOSSFORM rules
         ".metabookclosehud": {
             click: back_to_reading,
             touchmove: cancel,
             touchend: cancel},
         "#METABOOKSETTINGS": {
             touchend: fdjt.UI.CheckSpan.onclick},
         ".metabooktogglehelp": {
             touchstart: cancel,
             touchend: toggleHelp},
         
         "#METABOOKCONSOLETEXTINPUT": {
             touchstart: function(){
                 $ID('METABOOKCONSOLETEXTINPUT').focus();},
             focus: function(){
                 fdjt.DOM.addClass('METABOOKCONSOLEINPUT','ontop');},
             blur: function(){
                 fdjt.DOM.dropClass('METABOOKCONSOLEINPUT','ontop');}},

         "#METABOOKCONSOLEBUTTON": {
             touchstart: cancel, touchend: consolefn},
         "#METABOOKREFRESHOFFLINE": {
             touchstart: refreshOffline, touchend: cancel},
         "#METABOOKREFRESHLAYOUT": {
             touchstart: refreshLayout, touchend: cancel},
         "#METABOOKRESETSYNC": {touchend: cancel, touchstart: resetState},
         ".clearoffline": {touchstart: cancel, touchend: clearOffline},
         ".metabookclearmode": {touchstart: cancel, touchend: clearMode},
         "#METABOOKGOTOREFHELP": {touchstart: cancel, touchend: clearMode},
         "#METABOOKGOTOPAGEHELP": {touchstart: cancel, touchend: clearMode},
         "#METABOOKGOTOLOCHELP": {touchstart: cancel, touchend: clearMode},
         ".metabookshowsearch": {
             touchstart: cancel,
             touchend: function(evt){
                 metaBook.showSearchResults(); cancel(evt);}},
         ".metabookrefinesearch": {
             touchstart: cancel,
             touchend: function(evt){
                 setMode('refinesearch'); cancel(evt);}},
         ".metabookexpandsearch": {
             touchstart: cancel,
             touchend: function(evt){
                 setMode('expandsearch'); cancel(evt);}},
         ".metabookclearsearch": {
             touchstart: cancel,
             touchend: function(evt){
                 evt=evt||window.event;
                 metaBook.UI.handlers.clearSearch(evt);
                 cancel(evt);
                 return false;}},
         summary: {touchmove: preview_touchmove_nodefault},
         "#METABOOKINFOPANEL": {
             touchstart: toggleDevMode},
         ".metabooksettings input[type='RADIO']": {
             change: mB.configChange},
         ".metabooksettings input[type='CHECKBOX']": {
             change: mB.configChange}});

    var vis_listeners={window: {}};
    vis_listeners.window[fdjtDOM.vischange]=metabookvischange;

    fdjt.DOM.defListeners(metaBook.UI.handlers.touch,vis_listeners);
    fdjt.DOM.defListeners(metaBook.UI.handlers.mouse,vis_listeners);
    
})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/

/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/pagebar.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.
   This file implements a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */

(function(){
    "use strict";
    var fdjtDOM=fdjt.DOM, fdjtLog=fdjt.Log, fdjtUI=fdjt.UI, $ID=fdjt.ID;
    var fdjtString=fdjt.String;
    var dropClass=fdjtDOM.dropClass, hasClass=fdjtDOM.hasClass;
    var hasParent=fdjtDOM.hasParent, getParent=fdjtDOM.getParent;
    var mB=metaBook, mbDOM=metaBook.DOM, previewTimeout=mB.previewTimeout;
    var cancel=fdjtUI.cancel;
    var Trace=metaBook.Trace;

    function getGoPage(target){
        return parseInt(target.innerHTML,10);}

    var previewing_page=false, preview_start_page=false;
    function pagebar_hold(evt,target){
        evt=evt||window.event; if (!(target)) target=fdjtUI.T(evt);
        var pagebar=$ID("METABOOKPAGEBAR");
        previewTimeout(false);
        if (((mB.hudup)||(mB.mode))&&
            (!(mB.fullheight))) {
            fdjtUI.cancel(evt);
            metaBook.setMode(false);
            return;}
        if (target.nodeType===3) target=target.parentNode;
        if (((hasParent(target,pagebar))&&(target.tagName!=="SPAN")))
            return;
        var gopage=getGoPage(target,evt);
        if ((Trace.gestures)||(hasClass(pagebar,"metabooktrace")))
            fdjtLog("pagebar_span_hold %o t=%o gopage: %o=>%o/%o, start=%o",
                    evt,target,previewing_page,gopage,mB.pagecount,
                    preview_start_page);
        if (!(preview_start_page)) preview_start_page=gopage;
        if (previewing_page===gopage) return;
        if (!(gopage)) {
            // fdjtLog.warn("Couldn't get page from METABOOKPAGEBAR");
            return;}
        if (previewing_page)
            pagebar.title=fdjtString(
                "Release to go to this page (%d), move away to return to page %d",
                gopage,mB.curpage);
        else pagebar.title=fdjtString(
            ((mB.touch)?
             ("Release to return to page %d, tap the content or margin to settle here (page %d)"):
             ("Release to return to page %d, tap a key to settle here (page %d)")),
            metaBook.curpage,gopage);
        previewing_page=gopage;
        metaBook.startPreview(
            "CODEXPAGE"+previewing_page,"pagebar_span_hold/timeout");}
    function pagebar_tap(evt,target){
        evt=evt||window.event; if (!(target)) target=fdjtUI.T(evt);
        var pagebar=$ID("METABOOKPAGEBAR");
        if ((Trace.gestures)||(hasClass(pagebar,"metabooktrace")))
            fdjtLog("pagebar_tap %o",evt);
        previewTimeout(false);
        if ((mB.previewing)&&(!(previewing_page))) {
            metaBook.stopPreview("pagebar_tap",true);
            return;}
        if ((mB.hudup)||(mB.mode)||(mB.cxthelp)) {
            if (Trace.gestures)
                fdjtLog("clearHUD %s %s %s",mB.mode,
                        ((mB.hudup)?"hudup":""),
                        ((mB.cxthelp)?"hudup":""));
            fdjtUI.cancel(evt);
            metaBook.setMode(false);
            return;}
        if (target.nodeType===3) target=target.parentNode;
        if (((hasParent(target,pagebar))&&(target.tagName!=="SPAN")))
            return;
        var gopage=getGoPage(target,evt);
        if (previewing_page===gopage) return;
        metaBook.GoToPage(gopage,"pagebar_tap",true);
        metaBook.setMode(false);}
    function pagebar_release(evt,target){
        evt=evt||window.event; if (!(target)) target=fdjtUI.T(evt);
        var pagebar=$ID("METABOOKPAGEBAR");
        if ((Trace.gestures)||(hasClass(pagebar,"metabooktrace")))
            fdjtLog("pagebar_release %o, previewing=%o, ptarget=%o start=%o",
                    evt,mB.previewing,mB.previewTarget,
                    preview_start_page);
        previewTimeout(false);
        if (target.nodeType===3) target=target.parentNode;
        if (!(mB.previewing)) {preview_start_page=false; return;}
        dropClass(target,"preview");
        metaBook.stopPreview("pagebar_release",true);
        preview_start_page=false;
        previewing_page=false;
        fdjtUI.cancel(evt);
        if (((hasParent(target,pagebar))&&(target.tagName==="SPAN"))) {
            return;}}
    function pagebar_slip(evt,target){
        evt=evt||window.event; if (!(target)) target=fdjtUI.T(evt);
        var rel=evt.relatedTarget;
        var pagebar=$ID("METABOOKPAGEBAR");
        previewTimeout(false);
        if ((Trace.gestures)||(hasClass(pagebar,"metabooktrace")))
            fdjtLog("pagebar_slip %o, pre=%o, target=%o start=%o, rel=%o",
                    evt,mB.previewing,mB.previewTarget,
                    preview_start_page,rel);
        if (!(mB.previewing)) return;
        if (getParent(rel,mbDOM.pagebar)) return;
        if ((rel)&&(hasParent(rel,mB.body)))
            previewTimeout(function(){
                var pagebar=$ID("METABOOKPAGEBAR");
                pagebar.title=""; metaBook.GoTo(rel,evt);});
        else previewTimeout(function(){
            var pagebar=$ID("METABOOKPAGEBAR");
            pagebar.title=""; dropClass(target,"preview");
            metaBook.stopPagePreview("pagebar_slip/timeout");});
        previewing_page=false;}
    function pagebar_touchtoo(evt,target){
        evt=evt||window.event; if (!(target)) target=fdjtUI.T(evt);
        if (mB.previewing) {
            metaBook.stopPreview("touchtoo");
            fdjtUI.TapHold.clear();
            metaBook.setHUD(false);
            fdjt.UI.cancel(evt);
            return false;}}
    
    fdjt.DOM.defListeners(
        metaBook.UI.handlers.mouse,
        {"#METABOOKPAGEBAR": {
            tap: pagebar_tap,
            hold: pagebar_hold,
            release: pagebar_release,
            slip: pagebar_slip,
            click: cancel}});
    
    fdjt.DOM.defListeners(
        metaBook.UI.handlers.touch,
        {"#METABOOKPAGEBAR": {tap: pagebar_tap,
                              hold: pagebar_hold,
                              release: pagebar_release,
                              slip: pagebar_slip,
                              touchtoo: pagebar_touchtoo,
                              click: cancel}});

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/interaction.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements most of the interaction handling for the
   e-reader web application.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

(function(){
    "use strict";

    var fdjtDOM=fdjt.DOM;

    var mB=metaBook, $ID=fdjt.ID;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;

    /* Full page zoom mode */
    
    function startZoom(node){
        var zoom_target=$ID("METABOOKZOOMTARGET"), copy;
        if (!(node)) return stopZoom();
        if (metaBook.zoomtarget===node) {
            metaBook.zoomed=node;
            addClass(document.body,"mbZOOM");}
        metaBook.zoomtarget=node;
        if (!(metaBook.layout)) {}
        else {
            var layout=metaBook.layout;
            var id=node.getAttribute("data-baseid")||node.id;
            if ((layout.lostids)&&(layout.lostids[id]))
                copy=layout.lostids[id].cloneNode(true);
            else if (layout.splits[id])
                copy=layout.splits[id].cloneNode(true);
            else {}}
        if (!(copy)) copy=node.cloneNode(true);
        fdjtDOM.stripIDs(copy,false,"data-baseid");
        copy.setAttribute("style","");
        copy.id="METABOOKZOOMTARGET";
        fdjt.DOM.replace(zoom_target,copy);
        addClass(document.body,"mbZOOM");}
    metaBook.startZoom=startZoom;

    function stopZoom(evt){
        dropClass(document.body,"mbZOOM");
        metaBook.zoomed=false;
        if (evt) fdjt.UI.cancel(evt);}
    metaBook.stopZoom=stopZoom;

    function zoomIn(evt){
        evt=evt||window.event;
        var zb=$ID("METABOOKZOOMBOX");
        var scale=metaBook.zoomscale;
        if (!(scale)) scale=metaBook.zoomscale=1.0;
        scale=scale*1.1;
        metaBook.zoomscale=scale;
        zb.style[fdjt.DOM.transform]="scale("+scale+")";
        fdjt.UI.cancel(evt);}
    function zoomOut(evt){
        evt=evt||window.event;
        var zb=$ID("METABOOKZOOMBOX");
        var scale=metaBook.zoomscale;
        if (!(scale)) scale=metaBook.zoomscale=1.0;
        scale=scale/1.1;
        metaBook.zoomscale=scale;
        zb.style[fdjt.DOM.transform]="scale("+scale+")";
        fdjt.UI.cancel(evt);}
    function unZoom(evt){
        evt=evt||window.event;
        var zb=$ID("METABOOKZOOMBOX");
        zb.style[fdjt.DOM.transform]="";
        metaBook.zoomscale=false;
        fdjt.UI.cancel(evt);}

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.mouse,
	{"#METABOOKZOOMCLOSE": {click: stopZoom},
         "#METABOOKZOOMHELP": {click: metaBook.toggleHelp},
         "#METABOOKZOOMIN": {click: zoomIn},
         "#METABOOKZOOMOUT": {click: zoomOut},
         "#METABOOKUNZOOM": {click: unZoom}});

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.touch,
        {"#METABOOKZOOMCLOSE": {click: metaBook.stopZoom},
         "#METABOOKZOOMHELP": {click: metaBook.toggleHelp},
         "#METABOOKZOOMIN": {click: zoomIn},
         "#METABOOKZOOMOUT": {click: zoomOut},
         "#METABOOKUNZOOM": {click: unZoom}});

    // Not yet implemented, but the idea is to save some number of
    // audio/video/iframe elements to make restoring them faster.
    // var saved_players=[];
    // var n_players_to_save=7;
    
    function showMedia(url,type){
        var media_target=$ID("METABOOKMEDIATARGET");
        var media_elt=false, src_elt=false;
        function placeMedia(){
            if (media_elt) {
                // if mediaTarget doesn't have a parent node,
                // it's been replaced, so we don't do anything
                if (media_target.parentNode)
                    fdjt.DOM.replace(media_target,media_elt);}
            else $ID("METABOOKMEDIA").appendChild(media_target);
            addClass(document.body,"mbMEDIA");}
        if (metaBook.showing===url) {
            addClass(document.body,"mbMEDIA");
            return;}
        else if (type.search("image")===0) {
            src_elt=media_elt=fdjtDOM("IMG");}
        else if (type.search("audio")===0) {
            src_elt=fdjtDOM("SOURCE");
            media_elt=fdjtDOM("AUDIO",src_elt);
            media_elt.setAttribute("CONTROLS","CONTROLS");
            media_elt.setAttribute("AUTOPLAY","AUTOPLAY");
            src_elt.type=type;}
        else if (type.search("video")===0) {
            src_elt=fdjtDOM("SOURCE");
            src_elt.type=type;
            media_elt=fdjtDOM("VIDEO",src_elt);
            media_elt.setAttribute("CONTROLS","CONTROLS");
            media_elt.setAttribute("AUTOPLAY","AUTOPLAY");}
        else if (url.search("https://www.youtube.com/embed/")===0) {
            url="https://www.youtube-nocookie.com/"+
                url.slice("https://www.youtube.com/".length);
            if (url.indexOf("?")>0) 
                url=url+"&rel=0";
            else url=url+"?rel=0";}
        else {
            src_elt=media_elt=fdjtDOM("IFRAME");}
        media_elt.id="METABOOKMEDIATARGET";
        metaBook.showing=url;
        if ((src_elt)&&(mB.glossdata[url])) {
            src_elt.src=mB.glossdata[url];
            placeMedia();}
        else if (src_elt) {
            addClass($ID("METABOOKMEDIA"),"loadingcontent");
            addClass(src_elt,"loadingcontent");
            metaBook.getGlossData(url).then(function(val){
                dropClass($ID("METABOOKMEDIA"),"loadingcontent");
                dropClass(src_elt,"loadingcontent");
                src_elt.src=val;
                placeMedia();});}
        else placeMedia();}
    metaBook.showMedia=showMedia;
    function hideMedia(){
        dropClass(document.body,"mbMEDIA");}
    metaBook.hideMedia=hideMedia;

    var pause_media_timeout=false;
    function closeMedia_tapped(evt){
        evt=evt||window.event;
        var media_elt=$ID("METABOOKMEDIATARGET");
        if (pause_media_timeout) {
            clearTimeout(pause_media_timeout);
            pause_media_timeout=false;
            dropClass(document.body,"mbMEDIA");}
        else if (evt.shiftKey) {
            clearTimeout(pause_media_timeout);
            pause_media_timeout=false;
            dropClass(document.body,"mbMEDIA");}
        else if ((media_elt)&&(media_elt.pause)&&
                 (!(media_elt.paused))) {
            pause_media_timeout=setTimeout(function(){
                media_elt.pause();
                pause_media_timeout=false;
                dropClass(document.body,"mbMEDIA");},
                                           1500);}
        else dropClass(document.body,"mbMEDIA");
        fdjt.UI.cancel(evt);}
    metaBook.hideMedia=hideMedia;

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.mouse,
        {"#METABOOKCLOSEMEDIA": {mousedown: closeMedia_tapped}});

    fdjt.DOM.defListeners(
        metaBook.UI.handlers.touch,
        {"#METABOOKCLOSEMEDIA": {touchstart: closeMedia_tapped}});

})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/

/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### metabook/layout.js ###################### */

/* Copyright (C) 2009-2015 beingmeta, inc.

   This file implements the layout component of metaBook, relying heavily
   on CodexLayout from the FDJT library.

   This file is part of metaBook, a Javascript/DHTML web application for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/
/* jshint browser: true */
/* global metaBook: false */

/* Reporting progress, debugging */

/* Initialize these here, even though they should always be
   initialized before hand.  This will cause various code checkers to
   not generate unbound variable warnings when called on individual
   files. */
// var fdjt=((typeof fdjt !== "undefined")?(fdjt):({}));
// var metaBook=((typeof metaBook !== "undefined")?(metaBook):({}));
// var Knodule=((typeof Knodule !== "undefined")?(Knodule):({}));

metaBook.Paginate=
    (function(){
        "use strict";

        var mB=metaBook;
        var Trace=mB.Trace;
        var fdjtString=fdjt.String;
        var fdjtState=fdjt.State;
        var fdjtHash=fdjt.Hash;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var $ID=fdjt.ID;
        var mbID=metaBook.ID;
        var CodexLayout=fdjt.CodexLayout;

        var getGeometry=fdjtDOM.getGeometry;
        var getParent=fdjtDOM.getParent;
        var getChildren=fdjtDOM.getChildren;
        var hasClass=fdjtDOM.hasClass;
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var toArray=fdjtDOM.toArray;
        var textWidth=fdjtDOM.textWidth;
        var hasContent=fdjtDOM.hasContent;
        var isEmpty=fdjtString.isEmpty;
        var secs2short=fdjtTime.secs2short;
        
        var getLocal=fdjtState.getLocal;
        var setLocal=fdjtState.setLocal;

        var getMeta=fdjtDOM.getMeta;

        var atoi=parseInt;

        function layoutMessage(string,pct){
            var pb=$ID("METABOOKLAYOUTMESSAGE");
            fdjt.UI.ProgressBar.setMessage(pb,string);
            if (typeof pct==="number")
                fdjt.UI.ProgressBar.setProgress(pb,pct);}

        /* Reporting progress, debugging */
        function layout_progress(info){
            var tracelevel=info.tracelevel;
            var started=info.started;
            var pagenum=info.pagenum;
            if (!(pagenum)) return;
            var now=fdjtTime();
            var howlong=secs2short((now-started)/1000);
            var indicator=$ID("METABOOKLAYOUTINDICATOR");
            if (info.done) {
                if (indicator)
                    indicator.style.width=Math.floor(pct)+"%";
                fdjtDOM.replace(
                    "METABOOKPAGENOTEXT",
                    fdjtDOM("div.metabookpageno#METABOOKPAGENOTEXT",
                            metaBook.curpage||"?",
                            "/",pagenum," (",Math.floor(pct),
                            "%)"));
                layoutMessage(fdjtString(
                    "Finished laying out %d %dx%d pages in %s",
                    pagenum,info.width,info.height,
                    secs2short((info.done-info.started)/1000)),
                              100);
                fdjtLog("Finished laying out %d %dx%d pages in %s",
                        pagenum,info.width,info.height,
                        secs2short((info.done-info.started)/1000));}
            else {
                if ((info.lastid)&&(metaBook.docinfo)&&
                    ((metaBook.docinfo[info.lastid]))) {
                    var docinfo=metaBook.docinfo;
                    var maxloc=docinfo._maxloc;
                    var lastloc=docinfo[info.lastid].starts_at;
                    var pct=(100*lastloc)/maxloc, fpct=Math.floor(pct);
                    if (indicator) indicator.style.width=fpct+"%";
                    fdjtDOM.replace(
                        "METABOOKPAGENOTEXT",
                        fdjtDOM("div.metabookpageno#METABOOKPAGENOTEXT",
                                metaBook.curpage||"?",
                                "/",pagenum," (",fpct,"%)"));
                    if (metaBook.devmode) 
                        layoutMessage(fdjtString(
                            "Formatted %d %dx%d pages (%d%%)",
                            pagenum,info.width,info.height,fpct),
                                      pct);
                    else layoutMessage(fdjtString(
                        "Formatting for your device (%d%%)",fpct),
                                       pct);
                    if (tracelevel)
                        fdjtLog("Formatted %d %dx%d pages (%d%%) in %s",
                                pagenum,info.width,info.height,fpct,howlong);}
                else {
                    layoutMessage(fdjtString(
                        "Formatted %d %dx%d pages in %s",
                        info.pagenum,info.width,info.height,howlong));
                    if (tracelevel)
                        fdjtLog("Formatted %d pages in %s",
                                info.pagenum,howlong);}}}

        function Paginate(why,init){
            if (((metaBook.layout)&&(!(metaBook.layout.done)))) return;
            if (!(why)) why="because";
            if (Trace.layout)
                fdjtLog("Starting pagination (%s) with %j",why,init);
            layoutMessage("Preparing your book",0);
            dropClass(document.body,"_SCROLL");
            addClass(document.body,"mbLAYOUT");
            scaleLayout(false);
            if (Trace.layout) fdjtLog("Unscaled layout");
            var forced=((init)&&(init.forced));
            var geom=getGeometry($ID("CODEXPAGE"),false,true);
            var height=geom.inner_height, width=geom.width;
            var justify=metaBook.textjustify;
            var spacing=metaBook.bodyspacing;
            var size=metaBook.bodysize||"normal";
            var family=(metaBook.dyslexical)?("opendyslexic"):
                (metaBook.bodyfamily||"default");
            if ((!(metaBook.layout))&&(Trace.startup))
                fdjtLog("Page layout requires %dx%d %s pages",
                        width,height,size);
            if (metaBook.layout) {
                var current=metaBook.layout;
                if ((!(forced))&&
                    (width===current.width)&&
                    (height===current.height)&&
                    (size===current.bodysize)&&
                    (family===current.bodyfamily)&&
                    ((!(spacing))||(spacing===current.bodyspacing))&&
                    (((justify)&&(current.justify))||
                     ((!justify)&&(!current.justify)))) {
                    dropClass(document.body,"mbLAYOUT");
                    fdjtLog("Skipping redundant pagination for %s",
                            current.layout_id);
                    return;}
                // Repaginating, start with reversion
                if (Trace.layout) fdjtLog("Reverting current layout");
                metaBook.layout.Revert();
                metaBook.layout=false;}

            // Resize the content
            if (Trace.layout) fdjtLog("Sizing the content");
            metaBook.sizeContent();

            // Create a new layout
            var layout_args=getLayoutArgs();
            if ((init)&&(init.hasOwnProperty("timeslice"))) {
                layout_args.timeslice=init.timeslice;}
            
            if (Trace.layout) fdjtLog("Starting content layout");
            var layout=new CodexLayout(layout_args);
            layout.bodysize=size; layout.bodyfamily=family;
            metaBook.layout=layout;

            var timeslice=
                ((layout.hasOwnProperty('timeslice'))?(layout.timeslice):
                 (CodexLayout.timeslice));
            var timeskip=
                ((typeof timeslice === "number")&&
                 ((layout.hasOwnProperty('timeskip'))?(layout.timeskip):
                  (CodexLayout.timeskip)));
            var async=(typeof timeslice === "number");
            
            var layout_id=layout.layout_id;

            function restore_layout(content,layout_id){
                fdjtLog("Using saved layout %s",layout_id);
                $ID("CODEXCONTENT").style.display='none';
                layoutMessage("Using cached layout",0);
                dropClass(document.body,"_SCROLL");
                addClass(document.body,"_BYPAGE");
                layout.started=fdjtTime();
                layout.restoreLayout(content).then(finish_layout);}
            function finish_layout(layout) {
                var started=layout.started;
                $ID("CODEXPAGE").style.visibility='';
                $ID("CODEXCONTENT").style.visibility='';
                dropClass(document.body,"mbLAYOUT");
                metaBook.layout=layout;
                metaBook.pagecount=layout.pages.length;
                if (Trace.startup)
                    fdjtLog("Restored %d-page layout %s in %ds, adding glosses",
                            layout.pages.length,layout_id,
                            (fdjtTime()-started)/1000);
                var lostids=layout.lostids, moved_ids=lostids._all_ids;
                var i=0, lim=moved_ids.length;
                while (i<lim) {
                    var addGlossmark=metaBook.UI.addGlossmark;
                    var id=moved_ids[i++];
                    var glosses=metaBook.glossdb.find('frag',id);
                    if (!((glosses)&&(glosses.length))) continue;
                    var j=0, jlim=glosses.length; while (j<jlim) {
                        var gloss=metaBook.glossdb.probe(glosses[j++]);
                        if (gloss) {
                            var nodes=metaBook.getDups(gloss.frag);
                            addClass(nodes,"glossed");
                            var k=0, klim=nodes.length; while (k<klim) {
                                addGlossmark(nodes[k++],gloss);}}}}
                if (Trace.startup)
                    fdjtLog("Finished adding glossmarks to saved layout");
                setupPagebar();
                if (metaBook.layoutdone) {
                    var fn=metaBook.layoutdone;
                    metaBook.layoutdone=false;
                    fn();}
                if (metaBook.state)
                    metaBook.restoreState(metaBook.state,"layoutRestored");
                metaBook.layout.running=false;

                return false;}
            
            var max_layouts=3;

            function recordLayout(layout_id,source_id){
                var key="mB("+source_id+").layouts";
                var saved=getLocal(key,true);
                if (!(saved)) setLocal(key,[layout_id],true);
                else {
                    var loc=saved.indexOf(layout_id);
                    // Place at end, removing current position if neccessary
                    if (loc>=0) saved.splice(loc,1);
                    saved.push(layout_id);
                    if (saved.length>max_layouts) {
                        var j=saved.length-max_layouts-1;
                        while (j>=0) {
                            fdjtLog("Dropping layout #%d %s",j,saved[j]);
                            CodexLayout.dropLayout(saved[j--]);}
                        saved=saved.slice(saved.length-max_layouts);}
                    setLocal(key,saved,true);}}

            function finishPageInfo(page,layout){
                var pages=layout.pages, pagenum=atoi(page.getAttribute("data-pagenum"),10);
                var docinfo=mB.docinfo, curloc=false;
                var lastid=getPageLastID(page);
                var prevpage=
                    (((pagenum)&&(pagenum>1))&&(pages[pagenum-2]));
                if (lastid) page.setAttribute("data-lastid",lastid);
                if ((!(page.getAttribute("data-sbookloc")))&&(prevpage)) {
                    var prevlast=prevpage.getAttribute("data-lastid");
                    var lastinfo=((prevlast)&&(docinfo[prevlast]));
                    if (lastinfo) {
                        curloc=lastinfo.starts_at;
                        page.setAttribute("data-sbookloc",lastinfo.ends_at);}
                    else {
                        var prevoff=prevpage.getAttribute("data-sbookloc");
                        if (prevoff)
                            page.setAttribute("data-sbookloc",prevoff);
                        else page.setAttribute("data-sbookloc","0");}}}

            function getPageLastID(node,id) {
                if (hasClass(node,"codexpage")) {}
                else if ((node.id)&&(!(node.codexbaseid))&&
                         (metaBook.docinfo[node.id]))
                    id=node.id;
                if (node.nodeType!==1) return id;
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        if (child.nodeType===1) {
                            id=getPageLastID(child,id);}}}
                return id;}

            function new_layout(){

                // Prepare to do the layout
                dropClass(document.body,"_SCROLL");
                addClass(document.body,"_BYPAGE");
                // This keeps the page content hidden during layout
                // $ID("CODEXPAGE").style.visibility='hidden';
                // This shouldn't be neccessary because CODEXCONTENT 
                //  should have display:none with body._BYPAGE.
                //$ID("CODEXCONTENT").style.visibility='hidden';
                
                // Now make the content (temporarily) the same width as
                // the page
                var saved_width=metaBook.content.style.width;
                metaBook.content.style.width=
                    getGeometry(metaBook.page).width+"px";
                
                // Now walk the content
                var content=metaBook.content;
                var roots=toArray(content.childNodes);
                fdjtLog("Laying out %d root nodes into %dx%d pages (%s), id=%s, async=%s",
                        roots.length,layout.width,layout.height,
                        (why||""),layout_id,
                        ((!(timeslice))?("no"):(fdjtString("%d(%d)",timeslice,timeskip))));
                
                layoutMessage("Starting new layout",0);
                
                // Do the adjust font bit.  We rely on metaBook.content
                //  having the same width as metaBook.page
                fdjt.DOM.adjustFonts(content);
                
                // Now reset the width
                metaBook.content.style.width=saved_width;
                
                var root_i=0; var n_roots=roots.length;
                function rootloop(){
                    if (root_i>=n_roots) {
                        layout.Finish();
                        layout_progress(layout);
                        var pages=layout.pages;
                        var i=0, n=pages.length; while (i<n)
                            finishPageInfo(pages[i++],layout);
                        var cachethresh=metaBook.cache_layout_thresh;
                        if (cachethresh) {
                            var elapsed=layout.done-layout.started;
                            if ((typeof cachethresh === "number")?
                                (elapsed>cachethresh):(elapsed>5000)) {
                                layout.saveLayout(function(l){
                                    recordLayout(l.layout_id,metaBook.sourceid);});}}
                        $ID("CODEXPAGE").style.visibility='';
                        $ID("CODEXCONTENT").style.visibility='';
                        dropClass(document.body,"mbLAYOUT");
                        metaBook.layout=layout;
                        metaBook.pagecount=layout.pages.length;
                        setupPagebar();
                        if (metaBook.layoutdone) {
                            var fn=metaBook.layoutdone;
                            metaBook.layoutdone=false;
                            fn();}
                        if (metaBook.state)
                            metaBook.restoreState(metaBook.state,"layoutDone");
                        metaBook.layout.running=false;
                        if (async) setTimeout(checkLayout,100);
                        return false;}
                    else {
                        var root=roots[root_i++];
                        if (((root.nodeType===3)&&(!(isEmpty(root.nodeValue))))||
                            ((root.nodeType===1)&&
                             (root.tagName!=='LINK')&&(root.tagName!=='META')&&
                             (root.tagName!=='SCRIPT')&&(root.tagName!=='BASE'))) {
                            layout.addContent(root,timeslice,timeskip,
                                              layout.tracelevel,
                                              layout_progress,
                                              ((async)&&(rootloop)));
                            if (async) return rootloop;
                            else return true;}
                        else if (async) return rootloop();
                        else return true;}}

                if (async) rootloop();
                else {
                    var running=true;
                    while (running) running=rootloop();}}
            
            if ((metaBook.cache_layout_thresh)&&
                (!((metaBook.forcelayout)))&&
                (!(forced))) {
                if (Trace.layout)
                    fdjtLog("Fetching layout %s",layout_id);
                CodexLayout.fetchLayout(layout_id).
                    then(function(content){
                        if (!(content)) return new_layout();
                        if (Trace.layout) fdjtLog("Got layout %s",layout_id);
                        recordLayout(layout_id,metaBook.sourceid);
                        try {
                            return restore_layout(content,layout_id);}
                        catch (ex) {
                            fdjtLog("Layout restore error: %o",ex);
                            return new_layout();}}).
                    catch(function(){return new_layout();});}
            else if (async) {
                setTimeout(new_layout,10);}
            else return new_layout();}
        metaBook.Paginate=Paginate;

        CodexLayout.prototype.onresize=function(){
            if (metaBook.bypage) metaBook.Paginate("resize");
            else fdjt.DOM.adjustFonts(metaBook.content);};
        
        metaBook.addConfig(
            "layout",
            function(name,val){
                metaBook.page_style=val;
                if (val==='bypage') {
                    if (!(metaBook.docinfo)) {
                        // If there isn't any docinfo (during startup, for
                        // instance), don't bother actually paginating.
                        metaBook.bypage=true;}
                    else if (!(metaBook.bypage)) {
                        // set this
                        metaBook.bypage=true;
                        if (metaBook.postconfig)
                            // If we're in the middle of config,
                            // push off the work of paginating
                            metaBook.postconfig.push(Paginate);
                        // Otherwise, paginate away
                        else metaBook.Paginate("config");}}
                else {
                    // If you've already paginated, revert
                    if (metaBook.layout) {
                        metaBook.layout.Revert();
                        metaBook.layout=false;}
                    else if (((metaBook.layout)&&(!(metaBook.layout.done)))) {
                        if (metaBook.layout.timer) {
                            clearTimeout(metaBook.layout.timer);
                            metaBook.layout.timer=false;}
                        metaBook.layout.Revert();
                        metaBook.layout=false;}
                    metaBook.bypage=false;
                    if (metaBook.layout) {
                        metaBook.layout.Revert();
                        metaBook.layout=false;}
                    dropClass(document.body,"_BYPAGE");
                    addClass(document.body,"_SCROLL");
                    fdjt.DOM.adjustFonts(metaBook.content);}});

        function updateLayoutProperty(name,val){
            // This updates layout properties
            if (val===true) 
                fdjtDOM.addClass(metaBook.body,"metabook"+name);
            else if (!(val))
                fdjtDOM.dropClass(
                    metaBook.body,new RegExp("metabook"+name+"\\w*"));
            else fdjtDOM.swapClass(
                metaBook.body,new RegExp("metabook"+name+"\\w*"),
                "metabook"+name+val);
            metaBook[name]=val;
            if ((metaBook.postconfig)&&(metaBook.content)) {
                if (metaBook.postconfig.indexOf(metaBook.sizeContent)<0)
                    metaBook.sized=false;
                metaBook.postconfig.push(metaBook.sizeContent);}
            else if (metaBook.content) metaBook.sizeContent();
            if (metaBook.layout) {
                // If you're already paginated, repaginate.  Either
                // when done with the config or immediately.
                if (metaBook.postconfig) {
                    metaBook.postconfig.push(function(){
                        metaBook.Paginate(name);});}
                else {
                    metaBook.Paginate(name);}}
            fdjt.Async(function(){metaBook.updateSettings(name,val);});}
        metaBook.addConfig("bodysize",updateLayoutProperty);
        metaBook.addConfig("bodyfamily",updateLayoutProperty);
        metaBook.addConfig("bodyspacing",updateLayoutProperty);
        metaBook.addConfig("textjustify",updateLayoutProperty);
        
        function getLayoutID(width,height,family,size,spacing,
                             justify,source_id){
            var page=$ID("CODEXPAGE");
            var left=page.style.left, right=page.style.right;
            var docref=metaBook.docref, sourceid=metaBook.sourceid;
            var sourcehash=fdjt.CodexLayout.sourcehash;
            page.style.left=""; page.style.right="";
            if (!(width))
                width=getGeometry(page,false,true).width;
            if (!(height))
                height=getGeometry($ID("CODEXPAGE"),false,true).inner_height;
            if (!(size)) size=metaBook.bodysize||"normal";
            if (!(source_id))
                source_id=metaBook.sourceid||fdjtHash.hex_md5(metaBook.docuri);
            if (!(justify)) justify=metaBook.textjustify;
            if (!(spacing)) spacing=metaBook.linespacing;
            page.style.left=left; page.style.right=right;
            return fdjtString(
                "%s%dx%d-%s-%s%s%s%s%s",
                ((docref)?(docref+":"):("")),
                width,height,family,size,
                ((justify)?("-j"):("")),
                ((spacing)?("-l"+spacing):("")),
                // Layout depends on the actual file ID, if we've got
                // one, rather than just the REFURI
                ((sourceid)?("#"+sourceid):("")),
                ((sourcehash)?("/"+sourcehash):("")));}
        metaBook.getLayoutID=getLayoutID;

        function layoutCached(layout_id){
            if (!(layout_id)) layout_id=getLayoutID();
            else if (typeof layout_id === "number")
                layout_id=getLayoutID.apply(null,arguments);
            else {}
            var layouts=getLocal("mB("+metaBook.sourceid+").layouts",true);
            return ((layouts)&&(layouts.indexOf(layout_id)>=0));}
        metaBook.layoutCached=layoutCached;
        
        function clearLayouts(source_id){
            if (typeof source_id === "undefined")
                source_id=metaBook.sourceid;
            if (source_id) {
                var layouts=getLocal("mB("+source_id+").layouts",true);
                var i=0, lim=layouts.length; while (i<lim) {
                    var layout=layouts[i++];
                    fdjtLog("Dropping layout %s",layout);
                    CodexLayout.dropLayout(layout);}
                fdjtState.dropLocal("mB("+source_id+").layouts");}
            else {
                CodexLayout.clearLayouts();
                CodexLayout.clearAll();
                fdjtState.dropLocal(/^mB.layouts\(/g);}}
        metaBook.clearLayouts=clearLayouts;

        function getLayoutArgs(){
            var width=getGeometry($ID("CODEXPAGE"),false,true).width;
            var height=getGeometry($ID("CODEXPAGE"),false,true).inner_height;
            var origin=fdjtDOM("div#CODEXCONTENT");
            var container=fdjtDOM("div.metabookpages#METABOOKPAGES");
            var bodyfamily=(metaBook.dyslexical)?("opendyslexic"):
                (metaBook.bodyfamily||"default");
            var bodysize=metaBook.bodysize||"normal";
            var docref=metaBook.docref;
            var sourceid=metaBook.sourceid;
            var justify=metaBook.textjustify;
            var spacing=metaBook.linespacing;
            var sourcehash=fdjt.CodexLayout.sourcehash;
            var layout_id=fdjtString(
                "%s%dx%d-%s-%s%s%s%s%s",
                ((docref)?(docref+":"):("")),
                width,height,bodyfamily,bodysize,
                ((justify)?("-j"):("")),
                ((spacing)?("-l"+spacing):("")),
                // Layout depends on the actual file ID, if we've got
                // one, rather than just the REFURI
                ((sourceid)?("#"+sourceid):("")),
                ((sourcehash)?("/"+sourcehash):("")));

            var docinfo=metaBook.docinfo;
            var goneto=false;
            var getChild=fdjtDOM.getChild;
            var stripMarkup=fdjtString.stripMarkup;

            function finishedPage(page,layout){
                var pages=layout.pages, pagenum=layout.pagenum;
                var topnode=getPageTop(page);
                var topid=topnode.codexbaseid||topnode.id;
                var prevpage=(((pagenum)&&(pagenum>1))&&(pages[pagenum-2]));
                var staticref=getChild(page,".staticpageref");
                var curloc=false;
                if (staticref) {
                    var pageref=staticref.getAttribute("data-pageref");
                    if (!(pageref)) pageref=stripMarkup(staticref.innerHTML);
                    if (pageref) {
                        if (!(layout.pagemap)) layout.pagemap={};
                        page.setAttribute("data-staticpageref",pageref);
                        if (!(layout.pagemap[pageref]))
                            layout.laststaticref=pageref;
                        layout.pagemap[pageref]=page;}}
                else if (prevpage) {
                    var prevref=prevpage.getAttribute("data-staticpageref");
                    if (prevref)
                        page.setAttribute("data-staticpageref",prevref);}
                if (topnode) {
                    var topstart=mbID(topid);
                    var locoff=((topstart===topnode)?(0):
                                (getLocOff(pages,topstart,topnode)));
                    var info=docinfo[topid];
                    curloc=info.starts_at+locoff;
                    if (topid) page.setAttribute("data-topid",topid);
                    page.setAttribute("data-sbookloc",curloc);}
                if ((typeof curloc === "number")&&(pagenum)&&
                    (!(metaBook.curpage))&&(metaBook.state)&&
                    (goneto!==metaBook.state)&&
                    (metaBook.state.hasOwnProperty('location'))&&
                    (curloc>=metaBook.state.location)) {
                    goneto=metaBook.state;
                    setTimeout(function(){
                        metaBook.GoToPage(pagenum,"layout",false);},
                               10);}}
            
            function getPageTop(node) {
                var last=false;
                if (hasClass(node,"codexpage")) {}
                else if (((node.id)&&(docinfo[node.id]))||
                         ((node.codexbaseid)&&(docinfo[node.codexbaseid]))) {
                    if (hasContent(node,true)) last=node;}
                else {}
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        if (child.nodeType===1) {
                            var first=getPageTop(child);
                            if (first) return first;}}}
                return last;}
            
            function getDupNode(under,id){
                var children;
                if (under.nodeType!==1) return false;
                else if (under.codexbaseid===id) return under;
                if (!(children=under.childNodes))
                    return false;
                else if (!(children.length)) return false;
                else {
                    var i=0, lim=children.length;
                    while (i<lim) {
                        var found=getDupNode(children[i++],id);
                        if (found) return found;}}}

            function getLocOff(pages,topstart,topnode){
                var id=topstart.id; var locoff=0;
                var pagescan=topstart, pagenum, elt=topstart;
                while (pagescan) {
                    if (hasClass(pagescan,"codexpage")) {
                        break;}
                    else pagescan=pagescan.parentNode;}
                if (!(pagescan)) return locoff;
                else pagenum=parseInt(
                    pagescan.getAttribute("data-pagenum"),10);
                while ((elt)&&(elt!==topnode)) {
                    var width=textWidth(elt);
                    if (width) locoff=locoff+width;
                    pagescan=pages[pagenum++];
                    if (pagescan) elt=getDupNode(pagescan,id);
                    else return locoff;}
                return locoff;}

            // We track the sourceid to know when, for example, any
            //  cached layouts need to be invalidated.
            var saved_sourceid=
                fdjtState.getLocal("mB("+mB.docid+").sourceid");
            if ((saved_sourceid)&&(sourceid)&&(sourceid!==sourceid)) {
                var layouts=fdjtState.getLocal("fdjtmetaBook.layouts",true);
                var kept=[];
                if (layouts) {
                    var pat=new RegExp("\\("+saved_sourceid+"\\)$");
                    var i=0, lim=layouts.length; while (i<lim) {
                        var cacheid=layouts[i++];
                        if (cacheid.search(pat)>0)
                            CodexLayout.dropLayout(cacheid);
                        else kept.push(cacheid);}}
                if (kept.length)
                    fdjtState.setLocal("fdjtmetaBook.layouts",kept);
                else fdjtState.dropLocal("fdjtmetaBook.layouts",kept);}
            
            if (sourceid)
                fdjtState.setLocal("mB("+mB.docid+").sourceid",sourceid);
            
            var args={page_height: height,page_width: width,
                      orientation: fdjtDOM.getOrientation(window),
                      // Include this line to disable timeslicing
                      //  of layout (can help with debugging)
                      // timeslice: false,timeskip: false,
                      container: container,origin: origin,
                      pagerule: metaBook.CSS.pagerule,
                      tracelevel: Trace.layout,
                      layout_id: layout_id,
                      pagefn: finishedPage,
                      logfn: fdjtLog};
            fdjtDOM.replace("METABOOKPAGES",container);
            metaBook.pages=container;
            
            var fbb=getMeta("alwaysbreakbefore",true,true).
                concat(getMeta("forcebreakbefore",true,true));
            if ((fbb)&&(fbb.length)) args.forcebreakbefore=fdjtDOM.sel(fbb);

            var fba=getMeta("alwaysbreakafter",true,true)
                .concat(getMeta("forcebreakafter",true,true));
            if ((fba)&&(fba.length)) args.forcebreakafter=fdjtDOM.sel(fba);
            
            var abb=getMeta("avoidbreakbefore",true,true)
                .concat(getMeta("dontbreakbefore",true,true));
            if ((abb)&&(abb.length)) args.avoidbreakbefore=fdjtDOM.sel(abb);

            var aba=getMeta("avoidbreakafter",true,true)
                 .concat(getMeta("dontbreakafter",true,true));
            if ((aba)&&(aba.length)) args.avoidbreakafter=fdjtDOM.sel(aba);
            
            var abi=getMeta("avoidbreakinside",true,true).
                concat(getMeta("dontbreakinside",true,true));
            if ((abi)&&(abi.length)) args.avoidbreakinside=abi;

            var fullpages=[".sbookfullpage",".sbooktitlepage",".sbookpage"].
                concat(getMeta("codexfullpage",true));
            args.fullpages=fdjtDOM.sel(fullpages);
            
            var floatpages=[".codexfloatpage"].concat(
                getMeta("codexfloatpage",true));
            if ((floatpages)&&(floatpages.length))
                args.floatpages=fdjtDOM.sel(floatpages);
            
            var floating=[".codexfloating",".codexfloat"].concat(
                getMeta("codexfloat",true)).concat(
                    getMeta("codexfloating",true));
            if ((floating)&&(floating.length))
                args.floating=fdjtDOM.sel(floating);

            if ((getMeta("metaBook.dontbreakblocks"))||
                (getMeta("metaBook.keepblocks"))||
                (getMeta("~=metaBook.dontbreakblocks"))||
                (getMeta("~=metaBook.keepblocks"))||
                (getMeta("~dontbreakblocks"))||
                (getMeta("~keepblocks")))
                args.break_blocks=false;
            else args.break_blocks=true;
            
            if ((getMeta("metaBook.dontscalepages"))||
                (getMeta("~=metaBook.dontscalepages"))||
                (getMeta("dontscalepages")))
                args.scale_pages=false;
            else args.scale_pages=true;

            args.dontsave=fdjt.DOM.Selector(".glossmark");
            
            return args;}
        CodexLayout.getLayoutArgs=getLayoutArgs;

        function sizeCodexPage(){
            var page=metaBook.page, geom=getGeometry(page);
            var page_height=geom.height, view_height=fdjtDOM.viewHeight();
            var page_width=geom.width, view_width=fdjtDOM.viewWidth();
            var page_hmargin=(view_width-page_width);
            var page_vmargin=(view_height-page_height);
            // Set explicit left and right (and top and bottom) to
            // ensure that the page is centered (sometimes not on
            // Safari)
            if (page_hmargin!==50) {
                page.style.left=page_hmargin/2+'px';
                page.style.right=page_hmargin/2+'px';}
            else page.style.left=page.style.right='';
            if (page_vmargin<80) metaBook.fullheight=true;
            else metaBook.fullheight=false;
            if (page_hmargin<80) metaBook.fullwidth=true;
            else metaBook.fullwidth=false;
            if (metaBook.fullwidth) addClass(document.body,"_FULLWIDTH");
            else dropClass(document.body,"_FULLWIDTH");
            if (metaBook.fullheight) addClass(document.body,"_FULLHEIGHT");
            else dropClass(document.body,"_FULLHEIGHT");}
        metaBook.sizeCodexPage=sizeCodexPage;
        
        function scaleLayout(flag){
            // This adjusts to a resize by just scaling (using CSS
            // transforms) the current layout.
            var cheaprule=metaBook.CSS.resizerule;
            if (typeof flag==="undefined") flag=true;
            if ((flag)&&(hasClass(document.body,"_SCALEDLAYOUT"))) return;
            if ((!(flag))&&(!(hasClass(document.body,"_SCALEDLAYOUT")))) return;
            if (cheaprule) {
                cheaprule.style[fdjtDOM.transform]="";
                cheaprule.style[fdjtDOM.transformOrigin]="";
                cheaprule.style.left="";
                cheaprule.style.top="";}
            if (!(flag)) {
                dropClass(document.body,"_SCALEDLAYOUT");
                sizeCodexPage();
                return;}
            else sizeCodexPage();
            var layout=metaBook.layout;
            var geom=getGeometry($ID("CODEXPAGE"),false,true);
            var width=geom.width, height=geom.inner_height;
            var lwidth=layout.width, lheight=layout.height;
            var hscale=height/lheight, vscale=width/lwidth;
            var scale=((hscale<vscale)?(hscale):(vscale));
            if (!(cheaprule)) {
                var s="#CODEXPAGE div.codexpage";
                metaBook.CSS.resizerule=cheaprule=fdjtDOM.addCSSRule(
                    s+", body._ANIMATE.mbPREVIEW "+s,"");}
            cheaprule.style[fdjtDOM.transformOrigin]="left top";
            cheaprule.style[fdjtDOM.transform]="scale("+scale+","+scale+")";
            var nwidth=lwidth*scale, nheight=lheight*scale;
            // If the width has shrunk (it can't have grown), that means
            //  that there is an additional left margin, so we move the page
            //  over to the left
            if (nwidth<width)
                cheaprule.style.left=((width-nwidth)/2)+"px";
            if (nheight<height) cheaprule.style.top="0px";
            var n=metaBook.pagecount;
            var spanwidth=($ID("METABOOKPAGEBAR").offsetWidth)/n;
            if (spanwidth<1) spanwidth=1;
            if (metaBook.CSS.pagespanrule)
                metaBook.CSS.pagespanrule.style.width=spanwidth+"px";
            else metaBook.CSS.pagespanrule=fdjtDOM.addCSSRule(
                "div.metabookpagespans > span","width: "+spanwidth+"px;");
            addClass(document.body,"_SCALEDLAYOUT");}
        metaBook.scaleLayout=scaleLayout;
        
        /* Updating the page display */

        function updatePageDisplay(pagenum,staticref,location,classname) {
            var update_progress=(!(classname));
            if (!(classname)) classname="current";
            var npages=metaBook.pagecount;
            var staticmax=metaBook.layout.laststaticref;
            var page_elt=$ID("METABOOKPAGESPAN"+pagenum);
            var cur=getChildren("METABOOKPAGEBAR","."+classname);
            if (Trace.flips)
                fdjtLog("updatePageDisplay/%s %d %d/%d",
                        classname,location,pagenum,npages);
            if (cur[0]!==page_elt) {
                dropClass(cur,classname);
                addClass(page_elt,classname);}
            var locoff;
            if (typeof location==='number') {
                var max_loc=metaBook.ends_at;
                var pct=(100*location)/max_loc;
                // This is (very roughly) intended to be the precision needed
                //  for line level (40 character) accuracy.
                var prec=Math.round(Math.log(max_loc/40)/Math.log(10))-2;
                if (prec<0) prec=0;
                locoff=fdjtDOM(
                    "span.metabookloc#METABOOKLOCPCT",
                    ((prec===0)?(Math.floor(pct)):
                     (fdjtString.precString(pct,prec)))+"%");
                locoff.title=location+"/"+max_loc;}
            else locoff=fdjtDOM("span.metabookloc#METABOOKLOCPCT");
            var pageno_text=fdjtDOM(
                "span#METABOOKPAGENOTEXT.metabookpageno",pagenum,"/",npages);
            pageno_text.title="select to change page number";
            fdjtDOM.replace("METABOOKPAGENOTEXT",pageno_text);
            var pageref_text=
                ((staticref)&&(staticmax)&&
                 (fdjtDOM("span#METABOOKPAGEREFTEXT.metabookpageno",
                          staticref+"("+staticmax+")")));
            if (pageref_text) {
                pageref_text.title=
                    "Reference page number (from some print version)"; 
                fdjtDOM.replace("METABOOKPAGEREFTEXT",pageref_text);}
            fdjtDOM.replace("METABOOKLOCPCT",locoff);
            locoff.title=
                ((locoff.title)||"")+
                ((locoff.title)?("; "):(""))+
                " select to change %";
            if (update_progress) {
                var page_progress=$ID("METABOOKPAGEPROGRESS");
                if (page_progress) page_progress.style.width=
                    (((pagenum-1)*100)/npages)+"%";}
            if (update_progress) {
                /* Update section markers */
                var page=$ID("CODEXPAGE"+pagenum);
                var topid=(page)&&page.getAttribute("data-topid");
                var info=(topid)&&metaBook.docinfo[topid];
                if (info) {
                    var head1=((info.level)?(info):(info.head));
                    var head2=((head1)&&(head1.head));
                    var head3=((head2)&&(head2.head));
                    var span1=(head1)&&getPageSpan(head1);
                    var span2=(head2)&&getPageSpan(head2);
                    var span3=(head3)&&getPageSpan(head3);
                    while ((span3)&&(span2)&&(span1.width<=1)) {
                        var nextspan=(head3.head)&&(getPageSpan(head3.head));
                        if (!(nextspan)) break;
                        head1=head2; head2=head3; head3=head3.head;
                        span1=span2; span2=span3; span3=nextspan;}
                    var marker1=$ID("METABOOKSECTMARKER1");
                    var marker2=$ID("METABOOKSECTMARKER2");
                    var marker3=$ID("METABOOKSECTMARKER3");
                    if ((span1)&&(span1.width)) {
                        marker1.style.left=(100*((span1.start-1)/npages))+"%";
                        marker1.style.width=(100*(span1.width/npages))+"%";
                        marker1.style.display='block';                    }
                    else marker1.style.display='none';
                    if ((span2)&&(span2.width)) {
                        marker2.style.left=(100*((span2.start-1)/npages))+"%";
                        marker2.style.width=(100*(span2.width/npages))+"%";
                        marker2.style.display='block';                    }
                    else marker2.style.display='none';
                    if ((span3)&&(span3.width)) {
                        marker3.style.left=(100*((span3.start-1)/npages))+"%";
                        marker3.style.width=(100*(span3.width/npages))+"%";
                        marker3.style.display='block';                    }
                    else marker3.style.display='none';}}
            var handlers=metaBook.UI.handlers[metaBook.ui];
            fdjtDOM.addListeners(locoff,handlers["#METABOOKLOCPCT"]);
            fdjtDOM.addListeners(
                pageno_text,handlers["#METABOOKPAGENOTEXT"]);
            if (pageref_text) fdjtDOM.addListeners(
                pageref_text,handlers["#METABOOKPAGEREFTEXT"]);}
        metaBook.updatePageDisplay=updatePageDisplay;
        
        function getPageSpan(headinfo) {
            var scan=headinfo, nextinfo, result={};
            while (scan) {
                if (scan.next) {nextinfo=scan.next; break;}
                else scan=scan.head;}
            var start_page=getPage(headinfo.frag,headinfo.starts_at);
            if (!(start_page)) return false;
            else result.start=parseInt(
                (start_page).getAttribute("data-pagenum"),10);
            if (nextinfo) {
                var end_page=getPage(nextinfo.frag,nextinfo.starts_at);
                if (end_page)
                    result.end=parseInt(
                        (end_page).getAttribute("data-pagenum"),10);}
            if (!(result.end)) result.end=metaBook.layout.pages.length+1;
            result.width=result.end-result.start;
            return result;}

        /* Page info */
        
        function setupPagebar(){
            var layout=metaBook.layout, pages=layout.pages;
            var i=0, n=pages.length; var html=[];
            var pagemax=$ID("METABOOKGOTOPAGEMAX");
            if (pagemax) pagemax.innerHTML=""+n;
            var spanwidth=
                ($ID("METABOOKPAGEBAR").offsetWidth)/n;
            if (spanwidth<1) spanwidth=1;
            if (metaBook.CSS.pagespanrule)
                metaBook.CSS.pagespanrule.style.width=spanwidth+"px";
            else metaBook.CSS.pagespanrule=fdjtDOM.addCSSRule(
                "div.metabookpagespans > span","width: "+spanwidth+"px;");
            while (i<n) {
                var page=pages[i];
                var topid=(page)&&(page.getAttribute("data-topid"));
                var topinfo=(topid)&&(metaBook.docinfo[topid]);
                var zstyle=(((topinfo)&&(topinfo.level))?
                            ("; z-index: 50;"):(""));
                html.push("<span id='METABOOKPAGESPAN"+(i+1)+"' "+
                          "class='metabookpagespan' "+
                          "title='p"+(i+1)+". Hold to glimpse, tap to jump' "+
                          "style='left: "+(100*(i/n))+"%"+zstyle+"'"+
                          ">"+(i+1)+"</span>");
                var pageref=page.getAttribute("data-staticpageref");
                if (pageref) {
                    var pagemap=layout.pagemap;
                    var pagerefmax=$ID("METABOOKGOTOPAGEREFMAX");
                    if (pagerefmax) pagerefmax.innerHTML=""+pageref;
                    if (!(pagemap)) layout.pagemap=pagemap={};
                    layout.laststaticref=pageref;
                    pagemap[pageref]=page;}
                i++;}
            if (layout.laststaticref)
                addClass(document.body,"mbPAGEREFS");
            else dropClass(document.body,"mbPAGEREFS");
            var spans=$ID("METABOOKPAGESPANS");
            spans.innerHTML=html.join("");
            var outer_width=getGeometry(spans);
            var inner_width=fdjt.DOM.getInsideBounds(spans);
            var tweak=outer_width/inner_width;
            spans.style[fdjt.DOM.transform]="scale("+tweak+",1)";}
        metaBook.setupPagebar=setupPagebar;


        function getDups(id){
            if (!(id)) return false;
            else if (typeof id === "string") {
                if ((metaBook.layout)&&(metaBook.layout.dups)) {
                    var dups=metaBook.layout.dups;
                    var d=dups[id];
                    if (d) return [mbID(id)].concat(d);
                    else return [mbID(id)];}
                else return [mbID(id)];}
            else return getDups(id.codexbaseid||id.id);}
        metaBook.getDups=getDups;

        /* Movement by pages */
        
        var curpage=false;
        
        function GoToPage(spec,caller,savestate,skiphist){
            if (typeof savestate === 'undefined') savestate=true;

            if (metaBook.previewing) metaBook.stopPreview("GoToPage",false);
            dropClass(document.body,"mbSHOWHELP");
            metaBook.clearGlossmark();
            
            var page=(metaBook.layout)&&
                (metaBook.layout.getPage(spec)||metaBook.layout.getPage(1));
            if (!(page)) return;
            else if (page===curpage) return;
            else {
                var pagenum=parseInt(page.getAttribute("data-pagenum"),10);
                var dirclass=false;
                if (metaBook.mode==="addgloss") metaBook.setMode(false,false);
                if (savestate) metaBook.clearStateDialog();
                if (Trace.flips)
                    fdjtLog("GoToPage/%s Flipping to %o (%d) for %o",
                            caller,page,pagenum,spec);
                // Clean up any inconsistent curpage settings
                if (!(curpage)) {
                    var curpages=metaBook.pages.getElementsByClassName(
                        'curpage');
                    if (curpages.length)
                        dropClass(toArray(curpages),"curpage");
                    addClass(page,"curpage");}
                else {
                    var curpagestring=curpage.getAttribute("data-pagenum");
                    var curnum=parseInt(curpagestring,10);
                    // This does the page flip animation;
                    dropClass(curpage,/(oldpage|newpage|onleft|onright)/g);
                    dropClass(page,/(oldpage|newpage|onleft|onright)/g);
                    if (pagenum<curnum) dirclass="onleft";
                    else dirclass="onright";
                    if (dirclass) addClass(page,dirclass);
                    addClass(curpage,"oldpage");
                    addClass(page,"newpage");
                    var lastpage=curpage;
                    setTimeout(function(){
                        // This handles left over curpages from race
                        // conditions, etc.
                        var whoops=
                            metaBook.pages.getElementsByClassName('curpage');
                        if (whoops.length) dropClass(toArray(whoops),"curpage");
                        dropClass(lastpage,"curpage");
                        addClass(page,"curpage");
                        dropClass(page,"newpage");
                        dropClass(page,"onright");},
                               50);
                    setTimeout(function(){
                        dropClass(lastpage,"oldpage");},
                               500);}
                if (typeof spec === 'number') {
                    var locval=page.getAttribute("data-sbookloc");
                    var location=((locval)&&(parseInt(locval,10)));
                    if (location) metaBook.setLocation(location);}
                var staticref=page.getAttribute("data-staticpageref");
                updatePageDisplay(pagenum,staticref,metaBook.location);
                curpage=page; metaBook.curpage=pagenum;
                var curnode=mbID(page.getAttribute("data-lastid"))||
                    mbID(page.getAttribute("data-topid"));
                if (curnode) metaBook.setHead(curnode);
                if (savestate) {
                    metaBook.point=curnode;
                    if (!((metaBook.hudup)||(metaBook.mode)))
                        metaBook.skimpoint=false;}
                if ((savestate)&&(page)) {
                    var loc=page.getAttribute("data-sbookloc");
                    var pageno=page.getAttribute("data-pagenum");
                    metaBook.saveState(
                        {location: atoi(loc,10),
                         page: atoi(pageno,10),
                         target: ((curnode)&&
                                  ((curnode.getAttribute("data-baseid"))||
                                   (curnode.id)))},
                        skiphist);}
                var glossed=fdjtDOM.$(".glossed",page);
                if (glossed) {
                    var addGlossmark=metaBook.UI.addGlossmark;
                    var i=0; var lim=glossed.length;
                    while (i<lim) addGlossmark(glossed[i++]);}}}
        metaBook.GoToPage=GoToPage;
        

        /** Previewing **/

        var previewing=false;
        function startPagePreview(spec,caller){
            var page=((spec.nodeType)&&(getParent(spec,".codexpage")))||
                metaBook.layout.getPage(spec)||
                metaBook.layout.getPage(1);
            if ((Trace.preview)||(Trace.flips)) {
                fdjtLog("startPagePreview for %o from %s",page,spec);}
            if (!(page)) return;
            var pagenum=parseInt(page.getAttribute("data-pagenum"),10);
            var pageloc=parseInt(page.getAttribute("data-sbookloc"),10);
            if (previewing===page) return;
            if (previewing) dropClass(previewing,"previewpage");
            dropClass(getChildren(metaBook.pages,".previewpage"),
                      "previewpage");
            if ((Trace.flips)||(Trace.gestures))
                fdjtLog("startPagePreview/%s to %o (%d) for %o",
                        caller||"nocaller",page,pagenum,spec);
            if (curpage) addClass(curpage,"hidepage");
            addClass(page,"previewpage");
            metaBook.previewing=previewing=page;
            addClass(document.body,"mbPREVIEW");
            var staticref=page.getAttribute("data-staticpageref");
            updatePageDisplay(pagenum,staticref,pageloc,"preview");}
        metaBook.startPagePreview=startPagePreview;
        function stopPagePreview(caller,target){
            var pagenum=parseInt(curpage.getAttribute("data-pagenum"),10);
            if ((Trace.flips)||(Trace.gestures))
                fdjtLog("stopPagePreview/%s from %o to %o (%d)",
                        caller||"nocaller",previewing,curpage,pagenum);
            var newpage=false;
            if (!(previewing)) return;
            if ((target)&&(target.nodeType)) {
                dropClass(curpage,"curpage");
                dropClass(curpage,"hidepage");
                addClass(previewing,"curpage");
                if (hasClass(target,"codexpage")) newpage=target;
                else newpage=getParent(target,".codexpage");}
            else if (target)  {
                dropClass(curpage,"curpage");
                dropClass(curpage,"hidepage");
                addClass(previewing,"curpage");
                newpage=curpage;}
            else {
                dropClass(previewing,"preview");
                dropClass(curpage,"hidepage");}
            dropClass(previewing,"previewpage");
            dropClass(getChildren(metaBook.pages,".previewpage"),
                      "previewpage");
            metaBook.previewing=previewing=false;
            dropClass(document.body,"mbPREVIEW");
            dropClass(document.body,"mbPAGEPREVIEW");
            if (newpage) {
                var newnum=parseInt(newpage.getAttribute("data-pagenum"),10);
                var newloc=metaBook.getLocInfo(target);
                updatePageDisplay(
                    newnum,newpage.getAttribute("data-staticpageref"),
                    ((newloc)&&(newloc.starts_at)),"current");}
            else updatePageDisplay(
                pagenum,curpage.getAttribute("data-staticpageref"),
                metaBook.location,"current");
            if (typeof newpage === "number") metaBook.GoToPage(newpage);}
        metaBook.stopPagePreview=stopPagePreview;
        
        function getPage(arg,location){
            var node=((arg)&&
                      ((arg.nodeType)?(arg):
                       (typeof arg === "string")?(mbID(arg)):
                       (false)));
            var page=((node)&&(getParent(node,".codexpage")));
            if ((!(location))||(!(page))) return page;
            var loc=parseInt(page.getAttribute("data-sbookloc"),10);
            if (loc===location) return page;
            var layout=metaBook.layout, pages=layout.pages, npages=pages.length;
            var i=((page)?(parseInt(page.getAttribute("data-pagenum"),10)):(1)); i--;
            var prev=page; while (i<npages) {
                var next=pages[i++];
                loc=parseInt(next.getAttribute("data-sbookloc"),10);
                if (typeof loc !== "number") return prev;
                else if (loc===location) return next;
                else if (loc>location) return prev;
                else prev=next;}
            return page;}
        metaBook.getPage=getPage;
        
        function refreshLayout(why,slice,skip){
            var opts={forced: true};
            if (slice) opts.timeslice=slice;
            if (skip) opts.timeskip=skip;
            metaBook.Paginate(why||"refreshLayout",opts);}
        metaBook.refreshLayout=refreshLayout;
        
        function syncLayout(why){
            metaBook.Paginate(why,{forced: true,timeslice: false});}
        metaBook.syncLayout=syncLayout;

        function checkLayout(){
            if (metaBook.layout.running) return;
            var geom=getGeometry($ID("CODEXPAGE"),false,true);
            var height=geom.inner_height, width=geom.width;
            if ((metaBook.layout.height===height)&&
                (metaBook.layout.width===width))
                return;
            else refreshLayout("checkLayout");}

        function displaySync(){
            if ((metaBook.pagecount)&&(metaBook.curpage))
                metaBook.GoToPage(metaBook.curpage,"displaySync",false);}
        metaBook.displaySync=displaySync;

        return Paginate;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* No debugging Javascript */
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/searchbox.html" */

metaBook.HTML.searchbox=
    "<div class='query'>\n"+
    "  <input id=\"METABOOKSEARCHINPUT\"\n"+
    "         type=\"TEXT\" class=\"autoprompt searchinput\"\n"+
    "         name=\"QTEXT\" value=\"\" isempty=\"yes\" autocomplete=\"off\"\n"+
    "         onfocus=\"metaBook.UI.handlers.search_focus(event);\"\n"+
    "         onblur=\"metaBook.UI.handlers.search_blur(event);\"\n"+
    "         onkeydown=\"metaBook.UI.handlers.search_keydown(event);\"\n"+
    "         onkeyup=\"metaBook.UI.handlers.search_keyup(event);\"\n"+
    "         onkeypress=\"metaBook.UI.handlers.search_keypress(event);\"\n"+
    "         completeopts=\"anywhere cloud\" enterchars=\";\" maxcomplete=\"45\"\n"+
    "         placeholder=\"type or tap tags or terms\"\n"+
    "         completions=\"METABOOKSEARCHCLOUD\"\n"+
    "         results=\"METABOOKSEARCHRESULTS\"\n"+
    "         info=\"METABOOKSEARCHINFO\"/>\n"+
    "  <img class=\"metabookclearsearch\" alt=\"X\" title=\"clear search\"\n"+
    "       svg=\"{{bmg}}metabook/redx.svgz\"\n"+
    "       src=\"{{bmg}}metabook/redx64x64.png\"/>\n"+
    "</div>\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/addgloss.html" */

metaBook.HTML.addgloss=
    "<form action=\"https://glosses.bookhub.io/glosses\"\n"+
    "      ajaxaction=\"https://glosses.bookhub.io/glosses\"\n"+
    "      method=\"POST\" target=\"addgloss\"\n"+
    "      accept-charset=\"utf-8\">\n"+
    "  <div class=\"messageoverlay\">\n"+
    "    <div class=\"saving\">Saving...</div>\n"+
    "    <div class=\"saved\">Saved</div>\n"+
    "  </div>\n"+
    "  <div class=\"hidden\">\n"+
    "    <input type=\"HIDDEN\" name=\"FRAG\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"WSNID\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"REFURI\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"DOCURI\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"SYNC\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"UUID\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"TAGLINE\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"LOCATION\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"LOCLEN\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"DOCTITLE\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"MYCOPYID\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"MAKER\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"RE\"/>\n"+
    "    <input type=\"HIDDEN\" name=\"THREAD\"/>\n"+
    "    <input TYPE=\"HIDDEN\" NAME=\"DETAIL\" VALUE=\"\"/>\n"+
    "    <input TYPE=\"HIDDEN\" NAME=\"EXCERPT\" VALUE=\"\"/>\n"+
    "    <input TYPE=\"HIDDEN\" NAME=\"EXOFF\" VALUE=\"\"/>\n"+
    "    <!-- Force IE to send the form in UTF-8 -->\n"+
    "    <input type=\"HIDDEN\" name=\"IEHACK\" VALUE=\"&#9760;\"/>\n"+
    "  </div>\n"+
    "  <div class=\"response\">\n"+
    "    Responding to <span class=\"respmaker\"></span>\n"+
    "    <span class=\"respdate\"></span> <span class=\"respnote\"></span> \n"+
    "    <span class=\"resptags\"></span> <span class=\"resplinks\"></span>\n"+
    "  </div>\n"+
    "  <div class=\"metabookglossformbody\">\n"+
    "    <div class=\"addglossmenu\" data-touchable=\"img\">\n"+
    "      <img svg=\"{{bmg}}metabook/upmenu.svgz\"\n"+
    "           src=\"{{bmg}}metabook/upmenu64x64.png\"\n"+
    "           class=\"button menutop\" alt=\"upmenu\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/downmenu.svgz\"\n"+
    "           src=\"{{bmg}}metabook/downmenu64x64.png\"\n"+
    "           class=\"button menutop\" alt=\"downmenu\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/holdmenu.svgz\"\n"+
    "           src=\"{{bmg}}metabook/holdmenu64x64.png\"\n"+
    "           class=\"button menutop\" alt=\"holdmenu\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_save_titled.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_save_titled64x64.png\"\n"+
    "           title=\"save this gloss\" class=\"button\" alt=\"glosspush\"\n"+
    "           tabindex=\"2\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_save_titled.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_save_titled64x64.png\"\n"+
    "           title=\"update this gloss\" class=\"button\" alt=\"glossupdate\"\n"+
    "           tabindex=\"2\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_tag_titled.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_tag_titled64x64.png\"\n"+
    "           title=\"add tags\" class=\"button\" alt=\"addtag\"\n"+
    "           tabindex=\"3\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_attach_titled.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_attach_titled64x64.png\"\n"+
    "           title=\"attach files\" class=\"button\" alt=\"attach\"\n"+
    "           tabindex=\"4\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_share_titled.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_share_titled64x64.png\"\n"+
    "           title=\"add outlets/share this gloss\" class=\"button\" alt=\"addoutlet\"\n"+
    "           tabindex=\"6\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_respond_toptitle.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_respond_toptitle64x64.png\"\n"+
    "           title=\"respond to this gloss\" class=\"button\" alt=\"glossrespond\"\n"+
    "           tabindex=\"7\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_delete_titled.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_delete_titled64x64.png\"\n"+
    "           title=\"delete gloss\" class=\"button\" alt=\"glossdelete\"\n"+
    "           tabindex=\"9\"/>\n"+
    "      <img svg=\"{{bmg}}metabook/gloss_cancel_titled.svgz\"\n"+
    "           src=\"{{bmg}}metabook/gloss_cancel_titled64x64.png\"\n"+
    "           title=\" cancel gloss\" class=\"button\" alt=\"glosscancel\"\n"+
    "           tabindex=\"8\"/>\n"+
    "    </div>\n"+
    "    <div class=\"textbox\">\n"+
    "      <textarea\n"+
    "         name=\"NOTE\"\n"+
    "         placeholder=\"Use #tag or @share or to add tags or shares.  Markdown to format, Enter to save, Escape to cancel.\"\n"+
    "         title=\"Add text (using markdown), using @share and #tag to add outlets and tags.\"\n"+
    "         class=\"markdowninput\"\n"+
    "         wrap=\"virtual\"\n"+
    "         tabindex=\"0\"></textarea>\n"+
    "    </div>\n"+
    "    <div class=\"glossetc\">\n"+
    "      <span class=\"glossexposure\">\n"+
    "        <span class=\"checkspan private\" tabindex=\"5\">\n"+
    "          <input type=\"CHECKBOX\" name=\"PRIVATE\" value=\"yes\"\n"+
    "                 onchange=\"metaBook.UI.changeGlossPrivacy(event);\"/>\n"+
    "          <span class=\"checked\"\n"+
    "                title=\"this gloss won't be shared with my associated networks\">\n"+
    "            Private</span>\n"+
    "          <span class=\"unchecked\"\n"+
    "                title=\"this gloss will be shared with my associated networks\">\n"+
    "            Shared</span>\n"+
    "        </span>\n"+
    "      </span>\n"+
    "      <span class=\"glossdate\"></span>\n"+
    "      <span class=\"tags empty\"></span>    \n"+
    "      <span class=\"links empty\"></span>\n"+
    "      <span class=\"outlets empty\"></span>\n"+
    "      <span class=\"excerpt\"></span>\n"+
    "    </div>\n"+
    "  </div>\n"+
    "</form>\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/hud.html" */

metaBook.HTML.hud=
    "<div id=\"METABOOKTOPBAR\">\n"+
    "  <img svg=\"{{bmg}}metabook/tocicon.svgz\"\n"+
    "       src=\"{{bmg}}metabook/tocicon50x50.png\"\n"+
    "       alt=\"toc\" title=\"navigate sections\"\n"+
    "       class=\"hudbutton hudmodebutton topleft\"\n"+
    "       id=\"METABOOKTOCBUTTON\"\n"+
    "       hudmode=\"statictoc\"/>\n"+
    "  <div id=\"METABOOKTOPCENTER\">\n"+
    "    <img svg=\"{{bmg}}metabook/mbsettings.svgz\"\n"+
    "         src=\"{{bmg}}metabook/mbsettings50x50.png\"\n"+
    "         alt=\"toc\" title=\"book settings\"\n"+
    "         class=\"hudbutton hudmodebutton left\"\n"+
    "         id=\"METABOOKSETTINGSBUTTON\"\n"+
    "         hudmode=\"settings\"/>\n"+
    "    <div id=\"METABOOKTOOLTAB\"\n"+
    "         title=\"Open the meta layer for navigation, search, etc.\">\n"+
    "      &nbsp;</div>\n"+
    "    <div class=\"hudbutton\" id=\"METABOOKSHOWCOVER\">Cover</div>\n"+
    "    <img svg=\"{{bmg}}metabook/overlay.svgz\"\n"+
    "         src=\"{{bmg}}metabook/overlay50x50.png\"\n"+
    "         alt=\"toc\" title=\"see book layers\"\n"+
    "         class=\"hudbutton hudmodebutton right\"\n"+
    "         id=\"METABOOKLAYERSBUTTON\"\n"+
    "         hudmode=\"layers\"/>\n"+
    "  </div>\n"+
    "  <img svg=\"{{bmg}}metabook/tagsearch.svgz\"\n"+
    "       src=\"{{bmg}}metabook/tagsearch50x50.png\"\n"+
    "       alt=\"search\" title=\"search tags\"\n"+
    "       class=\"hudbutton hudmodebutton topright\"\n"+
    "       hudmode=\"search\"/>\n"+
    "</div>\n"+
    "<div id=\"METABOOKHEAD\">\n"+
    "  <div id=\"METABOOKTOC\" class=\"hudpanel\"></div>\n"+
    "  <div id=\"METABOOKSEARCH\" class=\"searchbox hudpanel notags\">\n"+
    "    <!-- This content comes from searchbox.html -->\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKNOTETEXT\" class=\"hudpanel\"\n"+
    "       title=\"tap/click to jump to the note\">\n"+
    "    <!-- This displays the text for a \"note\" -->\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKGLOSS\" class=\"hudpanel\">\n"+
    "    <div class=\"editbar\">\n"+
    "      <span class=\"deletebutton\">Delete</span>\n"+
    "      <span class=\"deletebutton\">Edit</span>\n"+
    "      <span class=\"deletebutton\">Reply</span>\n"+
    "    </div>\n"+
    "    <div id=\"METABOOKTARGETGLOSS\">\n"+
    "      <!-- This is generated on demand -->\n"+
    "    </div>\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKSOURCES\" class=\"hudpanel metabooksources\">\n"+
    "    <img svg=\"{{bmg}}metabook/sbookspeople.svgz\"\n"+
    "         src=\"{{bmg}}metabook/sbookspeople50x50.png\"\n"+
    "         class=\"button everyone selected\"\n"+
    "         alt=\"show all\" title=\"show all glosses\"/>\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKADDGLOSS\" class=\"metabookaddgloss hudpanel\">\n"+
    "  </div>\n"+
    "  <div class=\"metabookglossform\" id=\"METABOOKADDGLOSSPROTOTYPE\">\n"+
    "    <!-- This content comes from addgloss.html -->\n"+
    "  </div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSKIMMER\">\n"+
    "  <div id=\"METABOOKSKIM\"></div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKTOPHELPCONTENT\">\n"+
    "  <div id=\"METABOOKSLICEHELP\" class=\"hudpanel\">\n"+
    "    Press to see the context, tap to start skimming\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKSEETHRUHELP\" class=\"metabookhelp helpbox\">\n"+
    "    <p><span class=\"action\">Release</span> to\n"+
    "      <span class=\"result\">return</span>.\n"+
    "      <span class=\"notouch action\">Press any key</span>\n"+
    "      <span class=\"fortouch action\">Tap anywhere else</span>\n"+
    "      to <span class=\"result\">settle</span> here.</p>\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKPAGEBARHELP\" class=\"metabookhelp helpbox\">\n"+
    "    <p><span class=\"action\">Release</span>\n"+
    "      <span class=\"fortouch action\">or tap the text</span>\n"+
    "      to <span class=\"result\">settle</span> here.\n"+
    "      <span class=\"action notouch\">Press any key</span>\n"+
    "      <span class=\"notouch\">or</span>\n"+
    "      <span class=\"notouch action\">move the pointer away</span>\n"+
    "      <span class=\"action fortouch\">Move your finger away</span>\n"+
    "      to <span class=\"result\">return</span> to where you were.</p>\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKPREVIEWHELP\" class=\"helpbox\">\n"+
    "    <p>You're <em>previewing</em> a reference. <strong>Let go</strong>\n"+
    "      to <em>go back</em> to the\n"+
    "      reference, <strong class=\"fortouch\">tap anywhere\n"+
    "        else</strong> <strong class=\"notouch\">tap any key</strong>\n"+
    "      to <em>settle here</em>.</p>\n"+
    "  </div>\n"+
    "</div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKHEART\">\n"+
    "  <div id=\"METABOOKRIBBON\">\n"+
    "    <div class=\"inputbox\" ID=\"METABOOKADDTAGHOLDER\">\n"+
    "      <input TYPE=\"TEXT\" NAME=\"TAG\" VALUE=\"\"\n"+
    "             placeholder=\"Type or define a tag, with completion\"\n"+
    "             autocomplete=\"off\"\n"+
    "             ID=\"METABOOKADDTAGINPUT\"/>\n"+
    "    </div>\n"+
    "    <div class=\"inputbox\" ID=\"METABOOKADDSHAREHOLDER\">\n"+
    "      <input TYPE=\"TEXT\" NAME=\"OUTLET\" VALUE=\"\"\n"+
    "             placeholder=\"Type a group or individual name\"\n"+
    "             autocomplete=\"off\"\n"+
    "             ID=\"METABOOKADDSHAREINPUT\"/>\n"+
    "    </div>\n"+
    "    <div class=\"resultinfo notags noresults\" id=\"METABOOKSEARCHINFO\">\n"+
    "      <span class=\"noresults\">No results</span>\n"+
    "      <span class=\"noquery\">Add tags to see or refine results</span>\n"+
    "      <span class=\"stats\">\n"+
    "        <span class=\"resultcount metabookshowsearch\"></span>\n"+
    "        <span class=\"refinecount metabookrefinesearch\"></span>\n"+
    "        <span class=\"showalltags metabookexpandsearch\">all<br/>tags</span>\n"+
    "      </span>\n"+
    "      <span id=\"METABOOKSEARCHTAGS\" class=\"qtags\"></span>\n"+
    "    </div>\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKHEARTBODY\"></div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKHELPCONTENT\">\n"+
    "  <div id=\"METABOOKHELP\" class=\"hudpanel metabookhelp\">\n"+
    "    <!-- This is the help text for reading the book as a whole (it get's\n"+
    "         displayed for help when there isn't an active reader mode) -->\n"+
    "    <div id=\"METABOOKAPPHELP\"></div>\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKHUDHELP\"></div>\n"+
    "  <div id=\"METABOOKKEYBOARDHELPBOX\" class=\"closed\">\n"+
    "    <span class=\"keep\" onclick=\"metaBook.keyboardHelp(true);\">keep</span>\n"+
    "    <span class=\"close\" onclick=\"metaBook.keyboardHelp(false);\">close</span>\n"+
    "    <div id=\"METABOOKKEYBOARDHELP\"></div>\n"+
    "    <div class=\"checkspan\">\n"+
    "      <input TYPE=\"CHECKBOX\" NAME=\"METABOOKKEYBOARDHELP\" VALUE=\"yes\"\n"+
    "             CHECKED>\n"+
    "      Show keyboard help\n"+
    "    </div>\n"+
    "  </div>\n"+
    "  <div class=\"helphud topcenter\">\n"+
    "    <span class=\"fortouch\">Tap</span><span class=\"notouch\">Click</span>\n"+
    "    at the top of the page to see the &metaBook; <em>tools</em>\n"+
    "  </div>\n"+
    "  <div class=\"helphud topleft\" data-hudmode=\"toc\">\n"+
    "    <span class=\"nobreak\"><span class=\"arrow\">&#x2190;</span>navigate</span><br/>\n"+
    "    <span class=\"nobreak\">outline</span></div>\n"+
    "  <div class=\"helphud topright\" data-hudmode=\"search\">\n"+
    "    <span class=\"nobreak\"><span class=\"arrow\">&#x2192;</span>search</span><br/>\n"+
    "    for&nbsp;tags\n"+
    "  </div>\n"+
    "  <div class=\"helphud leftmiddle\">\n"+
    "    back page\n"+
    "  </div>\n"+
    "  <div class=\"helphud rightmiddle\">\n"+
    "    next page\n"+
    "  </div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKFOOT\" data-touchable=\"span.metabookpagespan,span.metabookpageno,span.metabookloc,img.hudbutton\">\n"+
    "  <div id=\"METABOOKSHOWTEXT\">\n"+
    "    <span>\n"+
    "      <span class=\"justreading\">close tools</span>\n"+
    "      <span class=\"stopskimming\">stop skimming</span>\n"+
    "      <span class=\"cancelgloss\">cancel gloss</span>\n"+
    "      <span class=\"cancelchanges\">discard changes</span>\n"+
    "    </span>\n"+
    "  </div>\n"+
    "  <div class=\"helphud botcenter\">\n"+
    "    <span style=\"font-size: 200%; font-weight: bold; position: absolute; left: 2px; bottom: 2px;\">\n"+
    "      &#x2193;</span> this bar shows where you are in the book:\n"+
    "    <span class=\"fortouch\">tap</span><span class=\"notouch\">click</span>\n"+
    "    to jump, press to preview,\n"+
    "    or <span style=\"white-space: nowrap;\"><span class=\"fortouch\">tap</span>\n"+
    "      <span class=\"notouch\">click</span> numbers to change them</span>\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKPAGEBAR\">\n"+
    "    <div class=\"textfoot\">\n"+
    "      <div id=\"METABOOKLAYOUTADJUST\">Updating layout</div>\n"+
    "      <span id=\"METABOOKPAGEREFTEXT\" class=\"metabookpageno\"></span>\n"+
    "      <span id=\"METABOOKPAGENOTEXT\" class=\"metabookpageno\">p/n</span>\n"+
    "      <span class=\"metabookloc\" id=\"METABOOKLOCPCT\">??.??%</span>\n"+
    "      <div id=\"METABOOKGOTOLOC\" class=\"metabookgoto\">\n"+
    "        <span class=\"gototext\">\n"+
    "          <input type=\"text\" name=\"GOTOLOC\" value=\"\" placeholder=\"loc\"\n"+
    "                 title=\"Enter a percent (<= 100) or an immediate location (> 100)\"\n"+
    "                 id=\"METABOOKLOCINPUT\"\n"+
    "                 onkeypress=\"metaBook.UI.goto_keypress(event);\"/>%</span>\n"+
    "      </div>\n"+
    "      <div id=\"METABOOKGOTOPAGE\" class=\"metabookgoto\">\n"+
    "        <span class=\"gototext\">\n"+
    "          <input type=\"text\" name=\"GOTOPAGE\" value=\"\"\n"+
    "                 id=\"METABOOKPAGEINPUT\" placeholder=\"page#\"\n"+
    "                 onkeypress=\"metaBook.UI.goto_keypress(event);\"/>/\n"+
    "          <span id=\"METABOOKGOTOPAGEMAX\"></span></span>\n"+
    "      </div>\n"+
    "      <div id=\"METABOOKGOTOREF\" class=\"metabookgoto\">\n"+
    "        <span class=\"gototext\">\n"+
    "          <input type=\"text\" name=\"GOTOREF\" value=\"\"\n"+
    "                 id=\"METABOOKREFINPUT\" placeholder=\"pg ref#\"\n"+
    "                 onkeypress=\"metaBook.UI.goto_keypress(event);\"/>/\n"+
    "          <span id=\"METABOOKGOTOPAGEREFMAX\"></span></span>\n"+
    "      </div>\n"+
    "    </div>\n"+
    "    <hr class=\"metabooklayoutindicator\" id=\"METABOOKLAYOUTINDICATOR\"/>\n"+
    "    <div class=\"metabookpageprogress\" id=\"METABOOKPAGEPROGRESS\"></div>\n"+
    "    <div class=\"metabooksectmarker\" id=\"METABOOKSECTMARKER1\"></div>\n"+
    "    <div class=\"metabooksectmarker\" id=\"METABOOKSECTMARKER2\"></div>\n"+
    "    <div class=\"metabooksectmarker\" id=\"METABOOKSECTMARKER3\"></div>\n"+
    "    <div class=\"metabookpagespans\" id=\"METABOOKPAGESPANS\">\n"+
    "    </div>\n"+
    "  </div>\n"+
    "  <img svg=\"{{bmg}}metabook/allglosses.svgz\"\n"+
    "       src=\"{{bmg}}metabook/allglosses50x50.png\"\n"+
    "       alt=\"allglosses\" title=\"show all glosses\"\n"+
    "       class=\"hudbutton hudmodebutton botright\"\n"+
    "       id=\"METABOOKALLGLOSSESBUTTON\"\n"+
    "       hudmode=\"allglosses\"/>\n"+
    "  <img svg=\"{{bmg}}metabook/tagsearch.svgz\"\n"+
    "       src=\"{{bmg}}metabook/tagsearch50x50.png\"\n"+
    "       alt=\"searchresults\" title=\"show searchresults\"\n"+
    "       class=\"hudbutton hudmodebutton botright\"\n"+
    "       hudmode=\"searchresults\"/>\n"+
    "  <img svg=\"{{bmg}}metabook/tocicon.svgz\"\n"+
    "       src=\"{{bmg}}metabook/tocicon50x50.png\"\n"+
    "       alt=\"statictoc\" title=\"show TOC\"\n"+
    "       class=\"hudbutton hudmodebutton botright\"\n"+
    "       hudmode=\"statictoc\"/>\n"+
    "  <img svg=\"{{bmg}}metabook/gloss_save_titled.svgz\"\n"+
    "       src=\"{{bmg}}metabook/gloss_save_titled50x50.png\"\n"+
    "       alt=\"save gloss\" title=\"save gloss\"\n"+
    "       class=\"hudbutton botright\"/>\n"+
    "  <img svg=\"{{bmg}}metabook/help.svgz\"\n"+
    "       src=\"{{bmg}}metabook/help50x50.png\"\n"+
    "       alt=\"help\" title=\"show contextual help\"\n"+
    "       class=\"hudbutton hudmodebutton botleft\"\n"+
    "       id=\"METABOOKHELPBUTTON\"\n"+
    "       hudmode=\"help\"/>\n"+
    "  <div class=\"helphud botright\" data-hudmode=\"toc\">\n"+
    "    <span class=\"nobreak\">browse</span><br/>\n"+
    "    <span class=\"nobreak\">glosses<span class=\"arrow\">&#x2192;</span></span></div>\n"+
    "  <div class=\"helphud botleft\">\n"+
    "    <span class=\"nobreak\">toggle</span><br/>\n"+
    "    <span class=\"nobreak\"><span class=\"arrow\">&#x2190;</span>help</span></div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKAUDIO\">\n"+
    "  <audio id=\"METABOOKPAGEFORWARDAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/pageforward.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/pageforward.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKPAGEBACKWARDAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/pagebackward.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/pagebackward.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKSKIMFORWARDAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/skimforward.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/skimforward.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKSKIMBACKWARDAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/skimbackward.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/skimbackward.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKSKIMSTOPAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/skimstop.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/skimstop.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKTEXTSELECTAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/selecting.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/selecting.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKRAISEHUDAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/raisehud.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/raisehud.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKDROPHUDAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/drophud.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/drophud.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "  <audio id=\"METABOOKGLOSSEDAUDIO\" volume=\"0.5\" preload=\"auto\">\n"+
    "    <source src=\"{{bmg}}metabook/glossed.wav\" type=\"audio/wave\"/>\n"+
    "    <source src=\"{{bmg}}metabook/glossed.ogg\" type=\"audio/ogg\"/>\n"+
    "  </audio>\n"+
    "</div>\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  --\n"+
    "    >\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/heart.html" */

metaBook.HTML.heart=
    "<div id=\"METABOOKALLGLOSSES\" class=\"metabookslice hudpanel\">\n"+
    "  <!-- This is filled in on startup -->\n"+
    "</div>\n"+
    "<div id=\"METABOOKGLOSSDETAIL\" class=\"hudpanel\">\n"+
    "  <!-- This displays detail text for a gloss -->\n"+
    "</div>\n"+
    "<div id=\"METABOOKASIDE\" class=\"hudpanel\">\n"+
    "  <!-- This displays the text for an aside -->\n"+
    "</div>\n"+
    "<div id=\"METABOOKGLOSSEDITDETAIL\" class=\"hudpanel\">\n"+
    "  <!-- This is for editing the detail text for a gloss -->\n"+
    "  <textarea NAME=\"METABOOKDETAILTEXT\" class=\"markdowninput\"\n"+
    "            ID=\"METABOOKDETAILTEXT\">\n"+
    "  </textarea>\n"+
    "</div>\n"+
    "<div id=\"METABOOKGLOSSATTACH\" class=\"hudpanel\"></div>\n"+
    "<div id=\"METABOOKSEARCHCLOUD\" class=\"completions cloud searchcloud\"></div>\n"+
    "<div id=\"METABOOKALLTAGS\" class=\"completions searchcloud cloud noinput\">\n"+
    "</div>\n"+
    "<div id=\"METABOOKSEARCHRESULTS\" class=\"metabookslice hudpanel\"></div>\n"+
    "<div id=\"METABOOKSHARECLOUD\" class=\"hudpanel completions cloud showall\"></div>\n"+
    "<div id=\"METABOOKGLOSSCLOUD\" class=\"hudpanel completions cloud showall\">\n"+
    "  <div class=\"nomatchmsg\">(no matches)</div>\n"+
    "</div>\n"+
    "<div class=\"tabcontent flyleaftab hudpanel\" id=\"METABOOKSTATICTOC\"></div>\n"+
    "<iframe name=\"METABOOKGLOSSCOMM\" id=\"METABOOKGLOSSCOMM\"\n"+
    "        frameborder=\"0\" scrolling=\"auto\"\n"+
    "        class=\"hudpanel tabcontent\"></iframe>\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/attach.html" */

metaBook.HTML.attach=
    "<form id=\"METABOOKATTACHFORM\" target=\"METABOOKGLOSSCOMM\"\n"+
    "      method=\"POST\" enctype=\"multipart/form-data\" accept-charset=\"utf-8\"\n"+
    "      action=\"https://glossdata.bookhub.io/1/attach\"\n"+
    "      class=\"link\">\n"+
    "  <table class=\"fdjtform\"\n"+
    "         onclick=\"fdjt.UI.CheckSpan.onclick(event);\">\n"+
    "    <input TYPE=\"HIDDEN\" NAME=\"GLOSSID\" VALUE=\"\" id=\"METABOOKUPLOADGLOSSID\"/>\n"+
    "    <input TYPE=\"HIDDEN\" NAME=\"ITEMID\" VALUE=\"\" id=\"METABOOKUPLOADITEMID\"/>\n"+
    "    <tr class=\"attachtype\">\n"+
    "      <th class=\"headcell\">\n"+
    "        Attach<img src=\"{{bmg}}metabook/gloss_attach.svgz\"/></th>\n"+
    "      <td>\n"+
    "        <button id=\"METABOOKATTACHDELETE\" NAME=\"ATTACH\" VALUE=\"DELETE\">\n"+
    "          Delete</button>\n"+
    "        <span class=\"checkspan ischecked mbaddlink\"\n"+
    "              title=\"Attach a link to this gloss\">\n"+
    "          <input type=\"RADIO\" NAME=\"ATTACHTYPE\" VALUE=\"link\"\n"+
    "                 onchange=\"metaBook.UI.changeAttachment(event);\"\n"+
    "                 CHECKED/>\n"+
    "          Link</span>\n"+
    "        <span class=\"checkspan mbupload\"\n"+
    "              title=\"Upload a file and attach it to this gloss\">\n"+
    "          <input type=\"RADIO\" NAME=\"ATTACHTYPE\" VALUE=\"upload\"\n"+
    "                 onchange=\"metaBook.UI.changeAttachment(event);\"/>\n"+
    "          File</span>\n"+
    "        <span class=\"checkspan mbeditbody\"\n"+
    "              title=\"Create or edit a 'body' for this gloss\">\n"+
    "          <input type=\"RADIO\" NAME=\"ATTACHTYPE\" VALUE=\"body\"\n"+
    "                 onchange=\"metaBook.UI.changeAttachment(event);\"/>\n"+
    "          Body</span>\n"+
    "        <span class=\"checkspan mbcapture\"\n"+
    "              title=\"Attach audio or video recorded on this device\">\n"+
    "          <input type=\"RADIO\" NAME=\"ATTACHTYPE\" VALUE=\"capture\"\n"+
    "                 onchange=\"metaBook.UI.changeAttachment(event);\"/>\n"+
    "          Capture</span>\n"+
    "      </td>\n"+
    "      <th class=\"button\">\n"+
    "        <button id=\"METABOOKATTACHLINK\" NAME=\"ATTACH\" VALUE=\"LINK\">\n"+
    "          Link</button>\n"+
    "        <button id=\"METABOOKUPLOADOK\" NAME=\"ATTACH\" VALUE=\"UPLOAD\">\n"+
    "          Save</button>\n"+
    "        <button id=\"METABOOKUPLOADOK\" NAME=\"ATTACH\" VALUE=\"SAVE\">\n"+
    "          Save</button>\n"+
    "        <button id=\"METABOOKATTACHLINK\" NAME=\"ATTACH\" VALUE=\"BODY\">\n"+
    "          Save</button>\n"+
    "        <button id=\"METABOOKATTACHLINK\" NAME=\"ATTACH\" VALUE=\"DONE\">\n"+
    "          Done</button>\n"+
    "        <button id=\"METABOOKATTACHCANCEL\" VALUE=\"CANCEL\">\n"+
    "          Cancel</button></th>\n"+
    "    </tr>\n"+
    "    <tr class=\"title\">\n"+
    "      <th>Label</th>\n"+
    "      <td colspan=\"2\">\n"+
    "        <INPUT TYPE=\"TEXT\" NAME=\"TITLE\" VALUE=\"\" ID=\"METABOOKATTACHTITLE\"\n"+
    "               placeholder=\"a descriptive label\"/></tr>\n"+
    "    <tr class=\"checkspan uploadrights\"\n"+
    "        id=\"METABOOKUPLOADRIGHTS\">\n"+
    "      <th><input TYPE=\"CHECKBOX\" NAME=\"FILEOKAY\" VALUE=\"yes\"/></th>\n"+
    "      <td colspan=\"2\">\n"+
    "        I affirm that I have the right to use and share this\n"+
    "        content according to the bookhub.io\n"+
    "        <a href=\"https://www.bookhub.io/legalia/TOS/\" target=\"_blank\">\n"+
    "          Terms of Service</a>.</td>\n"+
    "    </tr>\n"+
    "    <tr class=\"url\">\n"+
    "      <th>URL</th>\n"+
    "      <td colspan=\"2\">\n"+
    "        <input TYPE=\"TEXT\" NAME=\"URL\" VALUE=\"\"\n"+
    "               ID=\"METABOOKATTACHURL\" class=\"fdjturlinput\"\n"+
    "               placeholder=\"a URL to attach\"/>\n"+
    "      </td>\n"+
    "    </tr>\n"+
    "    <tr class=\"capturefile\">\n"+
    "      <th>Capture</th>\n"+
    "      <td id=\"METABOOKCAPTUREFILE\" class=\"nofile\" colspan=\"2\">\n"+
    "	<button NAME=\"CAPTURE\" VALUE=\"AUDIO\">Audio</button>\n"+
    "	<button NAME=\"CAPTURE\" VALUE=\"VIDEO\">Video</button>\n"+
    "	<button NAME=\"CAPTURE\" VALUE=\"IMAGE\">Photo</button>\n"+
    "    </td></tr>\n"+
    "    <tr class=\"uploadfile\">\n"+
    "      <th>Upload<input TYPE=\"FILE\" NAME=\"UPLOAD\" ID=\"METABOOKFILEINPUT\"/></th>\n"+
    "      <td id=\"METABOOKATTACHFILE\" class=\"nofile\" colspan=\"2\">\n"+
    "        <span class=\"mbdragmessage\">Drag a file here or click to browse</span>\n"+
    "        <span class=\"mbmessage\">Tap to find files or media</span>\n"+
    "        <span class=\"mbfilename\" id=\"METABOOKATTACHFILENAME\"></span>\n"+
    "    </td></tr>\n"+
    "    <tbody class=\"glossbody\" id=\"METABOOKGLOSSBODY\">\n"+
    "      <tr>\n"+
    "        <td colspan=\"3\">\n"+
    "          <textarea NAME=\"BODYTEXT\" ID=\"METABOOKGLOSSBODYTEXT\"></textarea>\n"+
    "      </td></tr>\n"+
    "    </tbody>\n"+
    "  </table>\n"+
    "</form>\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/help.html" */

metaBook.HTML.help=
    "<h1><span class=\"metabooktogglehelp\">Ok</span>Using &metaBook;</h1>\n"+
    "\n"+
    "<p><img src=\"{{bmg}}metabook/browser_edges.svgz\" alt=\"top of browser\" class=\"svg floatright\"/>\n"+
    "  <img src=\"{{bmg}}metabook/browser_edges32x32.png\" alt=\"top of browser\" class=\"nosvg floatright\"/>\n"+
    "  <strong>Move by pages</strong> <span class=\"fortouch\">by swiping left or right</span>\n"+
    "  <span class=\"notouch\">using the Space or Backspace keys</span> or\n"+
    "  <span class=\"fortouch\">tapping</span> <span class=\"notouch\">clicking</span>\n"+
    "  on the left or right of the page.</p>\n"+
    "<p><img src=\"{{bmg}}metabook/browser_corners.svgz\" alt=\"top of browser\" class=\"svg floatright\"/>\n"+
    "  <img src=\"{{bmg}}metabook/browser_corners32x32.png\" alt=\"top of browser\" class=\"nosvg floatright\"/>\n"+
    "  <strong>Open the <dfn>book tools</dfn></strong> by\n"+
    "  <span class=\"fortouch\">tapping</span>\n"+
    "  <span class=\"notouch\">clicking</span> at the top of the\n"+
    "  page.  <strong>Navigate, search, or skim</strong> using the icons\n"+
    "  in the corners of the page.</p>\n"+
    "<p><strong>Show this and other help</strong> by\n"+
    "  <span class=\"fortouch\">tapping</span><span class=\"notouch\">clicking</span>\n"+
    "  the <img src=\"{{bmg}}metabook/help.svgz\" alt=\"top of browser\"\n"+
    "           class=\"svg inline\"/> <img src=\"{{bmg}}metabook/help50x50.png\"\n"+
    "                                     alt=\"top of browser\" class=\"nosvg inline\"/> icon in the lower left\n"+
    "  corner of the page.</p>\n"+
    "<p><strong>Mark up your book</strong> by pressing and holding or\n"+
    "  double <span class=\"fortouch\">tapping</span>\n"+
    "  <span class=\"notouch\">clicking</span> on the\n"+
    "content.  <strong>Enter notes, tags, links, etc</strong> in\n"+
    "the <dfn>gloss box</dfn> at the top of the\n"+
    "page. <strong>Drag <span class=\"fortouch\">your finger</span>\n"+
    "  <span class=\"notouch\">the pointer</span></strong> to highlight an\n"+
    "excerpt.</p>\n"+
    "<p style=\"text-indent: 0px;\">\n"+
    "  <span class=\"glossbarbox\"> </span>\n"+
    "  <strong>Blue <dfn>gloss bars</dfn></strong> in the right margin\n"+
    "  indicate glosses already overlaid on your\n"+
    "  book.  <strong><span class=\"fortouch\">Tap or drag\n"+
    "      left</span> <span class=\"notouch\">Click to the left</span></strong>\n"+
    "  of the blue bar to see associated notes, tags, links, etc.</p>\n"+
    "\n"+
    "<p class=\"tightbottom\">\n"+
    "  <img src=\"{{bmg}}metabook/docs/pagebar_zoom.png\" class=\"floatright\"/>\n"+
    "  <strong>Browse the book</strong> using the <dfn>pagebar</dfn> along\n"+
    "  the bottom.  The dark blue line show the current location with\n"+
    "  lighter regions around for the current section and its parent.\n"+
    "  <img src=\"{{bmg}}metabook/docs/pagebar_wide.png\" class=\"wideimage\"/>\n"+
    "  <img src=\"{{bmg}}metabook/docs/pagebar_wide.png\"\n"+
    "  class=\"narrowimage\"/><br/>\n"+
    "  <span class=\"subpara\">\n"+
    "    <span class=\"fortouch\">Tap</span><span class=\"notouch\">Click</span>\n"+
    "    the page number (in the middle) or percentage (on the right) to move\n"+
    "    precisely.  Press and hold the pagebar to see a particular page,\n"+
    "    moving <span class=\"fortouch\">your\n"+
    "      finger</span> <span class=\"notouch\">the pointer</span> to skim\n"+
    "    through pages.  <span class=\"notouch\">Release</span>\n"+
    "    <span class=\"fortouch\">Lift your finger</span> to settle where you\n"+
    "    are or <span class=\"fortouch\">move\n"+
    "      it</span> <span class=\"notouch\">drag the mouse</span> out of the\n"+
    "    pagebar to return to where you were.</span></p>\n"+
    "\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/hudhelp.html" */

metaBook.HTML.hudhelp=
    "<div id=\"METABOOKTOCHELP\" class=\"helpbox atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Navigating your &sBook;</h2>\n"+
    "  <p>The <strong>outline overleaf</strong> at the top of the page\n"+
    "    shows a partial map of your book centered on the current location.\n"+
    "    You can use it to browse or navigate the book.\n"+
    "    The <span style=\"color: blue;\">blue regions</span> indicate your\n"+
    "    current location.</p>\n"+
    "  <p><span class=\"fortouch\">Tapping</span>\n"+
    "    <span class=\"notouch\">Clicking</span> on the map jumps to the\n"+
    "    corresponding location in the book;</p>\n"+
    "  <p><span>Pressing or holding</span> lets you glimpse the\n"+
    "    location without actually jumping there.</p>\n"+
    "  <p><span>Layout stripes</span> <img class=\"screenshot right\"\n"+
    "                                      src=\"{{bmg}}metabook/tocstripe_screenshot.png\"/>\n"+
    "    display the arrangement and sizes of divisions at a particular\n"+
    "    level in the book.  The segment for the current section is light\n"+
    "    blue and contains a red bar indicating your relative position.</p>\n"+
    "  <p><strong>Subsection clouds</strong> appear when you're at the\n"+
    "    beginning of a section which has its own subsections.  It consists\n"+
    "    of a layout stripe for all of its subsections together with a\n"+
    "    cloud of subsection names.\n"+
    "    <span class=\"fortouch\">Tapping</span><span class=\"notouch\">Clicking</span>\n"+
    "    a name or segment jumps to that subsection.\n"+
    "    <span class=\"fortouch\">Pressing</span><span class=\"notouch\">Clicking</span>\n"+
    "    and holding a name shows the corresponding segment;\n"+
    "    <span class=\"fortouch\">Tapping</span><span class=\"notouch\">Clicking</span>\n"+
    "    the segment lets you glimpse the start of that section.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKADDGLOSSHELP\" class=\"helpbox atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Add your own gloss</h2>\n"+
    "  <p><strong class=\"fortouch\">Tap</strong>\n"+
    "    <strong class=\"notouch\">Click</strong> or <strong>drag and\n"+
    "    release</strong> the menu button\n"+
    "    <img svg=\"{{bmg}}metabook/downmenu.svgz\"\n"+
    "         src=\"{{bmg}}metabook/downmenu64x64.png\" class=\"inline\"\n"+
    "         style=\"border: solid black 1px; padding: 0px;\"/> for more\n"+
    "    options.</p>\n"+
    "  <p><img svg=\"{{bmg}}metabook/remark.svgz\"\n"+
    "          src=\"{{bmg}}metabook/remark64x64.png\" class=\"screengrab\"\n"+
    "          alt=\"the balloon icon\"/> Type your comments in the input\n"+
    "          box, ending with <kbd>Enter</kbd> and using\n"+
    "    <kbd>Shift-Enter</kbd> to insert a newline.  Specify **bold** or\n"+
    "    *italics* and other formatting using\n"+
    "    <a href=\"http://daringfireball.net/projects/markdown/syntax\"\n"+
    "       target=\"_blank\">\n"+
    "      Markdown syntax</a>.</p>\n"+
    "  <p><img svg=\"{{bmg}}metabook/tagicon.svgz\"\n"+
    "          src=\"{{bmg}}metabook/tagicon64x64.png\"\n"+
    "          class=\"screengrab\" alt=\"the tag icon\"/>\n"+
    "    <strong>Add simple tags</strong> as <tt>#tag</tt> or even\n"+
    "    &ldquo;<tt>#compound tag</tt>,&rdquo; pressing <kbd>Enter</kbd>\n"+
    "    when done.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKGLOSSATTACHHELP\" class=\"helpbox atfoot\">\n"+
    "  <p><img svg=\"{{bmg}}metabook/diaglink.svgz\"\n"+
    "          src=\"{{bmg}}metabook/diaglink64x64.png\"\n"+
    "          class=\"inline\" alt=\"the link icon\"/>\n"+
    "    <strong>Add links</strong>\n"+
    "    as <strong>[@</strong><em><tt>uri</tt></em>\n"+
    "    <em>title</em><strong>]</strong>,\n"+
    "    e.g. <strong>[@</strong><tt>http://www.whitehouse.gov/</tt>\n"+
    "    The White House<strong>]</strong>.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKGLOSSTAGHELP\" class=\"helpbox atfoot\">\n"+
    "  <p><img svg=\"{{bmg}}metabook/tagicon.svgz\"\n"+
    "          src=\"{{bmg}}metabook/tagicon64x64.png\"\n"+
    "          class=\"inline\" alt=\"the tag icon\"/>\n"+
    "    Specify <strong>synonyms</strong> for your tags (e.g.\n"+
    "    <span class=\"tagsample\"><strong>[</strong>airplane|plane|aircraft<strong>]</strong></span>)\n"+
    "    or describe <strong>relations</strong>\n"+
    "    (e.g. <span class=\"tagsample\">\n"+
    "      <strong>[</strong>sloop|^sailboat|^boat<strong>]</strong></span>)\n"+
    "    to make your tags <strong>more useful</strong> for browsing\n"+
    "    and search by yourself or others.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSKIMTOCHELP\" class=\"helpbox atfoot fdjtadjustfont\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Skimming by sections</h2>\n"+
    "  <p>You're <span>skimming</span> through a slice of your book\n"+
    "    based on the chapters and sections in the book's table of\n"+
    "    contents.</p>\n"+
    "  <p class=\"fortouch\">\n"+
    "    <span>Swipe left or right with two fingers</span> to move\n"+
    "    forward and backward by sections or use the\n"+
    "    <img svg=\"{{bmg}}metabook/skim_left.svgz\"\n"+
    "         src=\"{{bmg}}metabook/skim_left100x100.png\" class=\"inline\"/>\n"+
    "    double arrows <img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "                       src=\"{{bmg}}metabook/skim_right100x100.png\" class=\"inline\"/>\n"+
    "    on the edges of the page.</p>\n"+
    "  <p class=\"notouch\">\n"+
    "    Use the <span>arrow keys</span> to move forward and backward by\n"+
    "    sections or click the <img svg=\"{{bmg}}metabook/skim_left.svgz\"\n"+
    "    src=\"{{bmg}}metabook/skim_left100x100.png\" class=\"inline\"/> double\n"+
    "    arrows <img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "    src=\"{{bmg}}metabook/skim_right100x100.png\" class=\"inline\"/> on\n"+
    "    the edges of the page.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSKIMSEARCHHELP\" class=\"helpbox atfoot fdjtadjustfont\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Skimming your search</h2>\n"+
    "  <p>You're currently <span>skimming</span> through the results\n"+
    "    of your search.  The current search result is shown in\n"+
    "    the <strong>overleaf</strong> at the top of the page and\n"+
    "    matching text is highlighted in the body.</p>\n"+
    "  <p>Return to the search results by\n"+
    "    <span class=\"fortouch\">double\n"+
    "      tapping</span> <span class=\"notouch\">double clicking</span> the\n"+
    "    overleaf or using the <img svg=\"{{bmg}}metabook/tagsearch.svgz\"\n"+
    "                               src=\"{{bmg}}metabook/tagsearch50x50.png\" class=\"inline\"/> icon\n"+
    "    in the lower\n"+
    "    right of the page.  <span class=\"fortouch\">Tap</span><span class=\"notouch\">Click\n"+
    "      on</span> the overleaf to see (or hide) the rest of the\n"+
    "    result.  <span class=\"fortouch\">Tap</span>\n"+
    "    <span class=\"notouch\">Click</span> the content to stop skimming.</p>\n"+
    "  <p class=\"fortouch\">\n"+
    "    <span>Swipe left or right with two fingers</span> to move\n"+
    "    forward and backward by single results or use the\n"+
    "    <img svg=\"{{bmg}}metabook/skim_left.svgz\"\n"+
    "         src=\"{{bmg}}metabook/skim_left100x100.png\" class=\"inline\"/>\n"+
    "    double arrows <img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "                       src=\"{{bmg}}metabook/skim_right100x100.png\" class=\"inline\"/>\n"+
    "    on the edges of the page.</p>\n"+
    "  <p class=\"notouch\">\n"+
    "    Use the <span>arrow keys</span> on your keyboard to move forward and\n"+
    "    backward by single results or <span class=\"fortouch\">tap</span>\n"+
    "    <span class=\"notouch\">click</span>\n"+
    "    the <img svg=\"{{bmg}}metabook/skim_left.svgz\"\n"+
    "             src=\"{{bmg}}metabook/skim_left100x100.png\" class=\"inline\"/>\n"+
    "    double arrows <img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "                       src=\"{{bmg}}metabook/skim_right100x100.png\"\n"+
    "                       class=\"inline\"/>\n"+
    "    on the edges of the page.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSKIMGLOSSESHELP\" class=\"helpbox fdjtadjustfont atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Skimming Glosses</h2>\n"+
    "  <p>You're <span>skimming</span> through your book based on the\n"+
    "    glosses (highlights, notes, etc) which you or others have added.\n"+
    "    The <strong>overleaf</strong> at the top of the page shows the\n"+
    "    current gloss and the text itself shows any highlights.</p>\n"+
    "  <p>Return to the list of glosses by\n"+
    "    <span class=\"fortouch\">double\n"+
    "      tapping</span> <span class=\"notouch\">double clicking</span> the\n"+
    "    overleaf or using the <img svg=\"{{bmg}}metabook/allglosses.svgz\"\n"+
    "                               src=\"{{bmg}}metabook/allglosses50x50.png\" class=\"inline\"/> icon\n"+
    "    in the lower right of the\n"+
    "    page.  <span class=\"fortouch\">Tap</span><span class=\"notouch\">Click\n"+
    "      on</span> the overleaf to see the entire text of the\n"+
    "    gloss.  <span class=\"fortouch\">Tap</span>\n"+
    "    <span class=\"notouch\">Click</span> the content to stop skimming the\n"+
    "    glosses.</p>\n"+
    "  <p><span class=\"fortouch\">Tap</span>\n"+
    "    <span class=\"notouch\">Click on</span>\n"+
    "    the <strong>overleaf</strong> to expand or contract it;\n"+
    "    <span class=\"fortouch\">Double tap</span>\n"+
    "    <span class=\"notouch\">Double click</span> to return to the search\n"+
    "    results.  <span class=\"fortouch\">Tap</span>\n"+
    "    <span class=\"notouch\">Click</span> the content to stop\n"+
    "    skimming.\n"+
    "  </p>\n"+
    "  <p class=\"fortouch\">\n"+
    "    <span>Swipe left or right with two fingers</span> to move\n"+
    "    forward and backward by single glosses or use the\n"+
    "    <img svg=\"{{bmg}}metabook/skim_left.svgz\"\n"+
    "         src=\"{{bmg}}metabook/skim_left100x100.png\" class=\"inline\"/>\n"+
    "    double arrows <img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "                       src=\"{{bmg}}metabook/skim_right100x100.png\" class=\"inline\"/>\n"+
    "    on the edges of the page.</p>\n"+
    "  <p class=\"notouch\">\n"+
    "    Use the <span>arrow keys</span> on your keyboard to move forward and\n"+
    "    backward by single glosses or <span class=\"fortouch\">tap</span>\n"+
    "    <span class=\"notouch\">click</span>\n"+
    "    the <img svg=\"{{bmg}}metabook/skim_left.svgz\"\n"+
    "             src=\"{{bmg}}metabook/skim_left100x100.png\" class=\"inline\"/>\n"+
    "    double arrows <img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "                       src=\"{{bmg}}metabook/skim_right100x100.png\"\n"+
    "                       class=\"inline\"/>\n"+
    "    on the edges of the page.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKGOTOPAGEHELP\" class=\"helpbox atfoot\">\n"+
    "  <p>Enter a page number at the top of the page to jump directly to that\n"+
    "    page.<br/> Use the escape key or <span class=\"fortouch\">tap</span>\n"+
    "    <span class=\"notouch\">click</span> at the bottom of the page to\n"+
    "    cancel.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKGOTOREFHELP\" class=\"helpbox atfoot\">\n"+
    "  <p>Enter a reference page number (from the reference version of the\n"+
    "    book) at the top of the page to jump to that part of the book.<br/>\n"+
    "    Use the escape key or <span class=\"fortouch\">tap</span>\n"+
    "    <span class=\"notouch\">click</span> at the bottom of the page to\n"+
    "    cancel.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKGOTOLOCHELP\" class=\"helpbox atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Got to a specific location</h2>\n"+
    "  <p>Enter a numeric percentage (in the field at the top of the page)\n"+
    "    to jump directly to that point within the book.<br/>  These\n"+
    "    percentages will remain stable even as page layout or font size\n"+
    "    changes.  Use the escape key or <span class=\"fortouch\">tap</span>\n"+
    "    <span class=\"notouch\">click</span> at the bottom of the page to\n"+
    "    cancel and return to the text.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSEARCHINPUTHELP\" class=\"helpbox atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Searching tags and text</h2>\n"+
    "  <p>You are searching for passages or glosses within your book, using\n"+
    "    either semantic <span class=\"dterm\">tags</span>\n"+
    "    or literal <span class=\"rawterm\">terms</span>.  As you type or edit in\n"+
    "    the search box, the cloud of tags and phrases will grow or shrink\n"+
    "    to display matching phrases, tags, or synonyms of tags.</p>\n"+
    "  <p><span class=\"fortouch\">Tapping</span>\n"+
    "    <span class=\"notouch\">Clicking</span>\n"+
    "    <span>adds a term or tag</span> to the current search, generating\n"+
    "    both results and an updated cloud of terms and tags.  Tags may\n"+
    "    be related to other tags (for\n"+
    "    example, <span class=\"dterm\">dachshund</span>\n"+
    "    to <span class=\"dterm\">dog</span>) and those relationships are\n"+
    "    used in your search.</p>\n"+
    "  <p>Once you have specified <span>at least one tag or term</span>, you\n"+
    "    can see the matching results by\n"+
    "    either <span class=\"fortouch\">tapping</span>\n"+
    "    <span class=\"notouch\">clicking</span> on the result count or\n"+
    "    using the <kbd>Enter</kbd> key in an empty input box.  If there\n"+
    "    are few enough results, it will switch to them automatically.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSEARCHRESULTSHELP\" class=\"helpbox atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    Browsing search results</h2>\n"+
    "  <p><img src=\"/static/g/metabook/searchtabs.png\" class=\"screengrab\"/>\n"+
    "          These are the <span>results of your search</span>, ordered by\n"+
    "          relevance and position within the book.  You may change or\n"+
    "          refine your search by either using the text box or selecting\n"+
    "          one of the tag tabs above the results.</p>\n"+
    "  <p class=\"notouch\">Use the space and backspace keys to move through\n"+
    "    the list of glosses page-by-page; combine with the shift key to move\n"+
    "    in larger increments.</p>\n"+
    "  <p class=\"fortouch\">Swipe to the left or right to move page-by-page\n"+
    "    through the search results or swipe with two fingers to move in\n"+
    "    larger increments.</p>\n"+
    "  <p><span class=\"fortouch\">Tap</span>\n"+
    "    <span class=\"notouch\">Click</span> a result to jump to that part\n"+
    "    of the book and begin <span>skimming</span> through the search results\n"+
    "    from that point.</p>\n"+
    "  <p><span class=\"notouch\">Holding the mouse button down\n"+
    "      on</span><span class=\"fortouch\">Pressing and holding\n"+
    "    </span> a result lets you glimpse the result in context\n"+
    "    without leaving the list of results.</p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKALLGLOSSESHELP\" class=\"helpbox atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    All glosses</h2>\n"+
    "  <p>These are <span>all of the glosses</span> applied to your\n"+
    "    copy of this book.</p>\n"+
    "  <p class=\"notouch\">Use the space and backspace keys to move through\n"+
    "    the list of glosses page-by-page; combine with the shift key to move\n"+
    "    in larger increments.</p>\n"+
    "  <p class=\"fortouch\">Swipe to the left or right to move\n"+
    "    page-by-page through the list of glosses or swipe with two fingers\n"+
    "    to move in larger increments.</p>\n"+
    "  <p><span class=\"fortouch\">Tap</span>\n"+
    "    <span class=\"notouch\">Click</span> a gloss to jump to the\n"+
    "    location where it is applied.  You can\n"+
    "    then <span>skim</span> through the book based on the these\n"+
    "    glosses.</p>\n"+
    "  <p><span class=\"notouch\">Hold down the mouse button\n"+
    "      over</span><span class=\"fortouch\">Press and hold\n"+
    "    </span> a gloss to see its context without leaving the list of\n"+
    "    glosses.</p>\n"+
    "  <p>The <span>icons</span> at the top of the screen show\n"+
    "    the <span>creators or layers</span> where different glosses\n"+
    "    originate. <span class=\"fortouch\">Tap</span>\n"+
    "    <span class=\"notouch\">Click</span> the icons to see glosses from\n"+
    "    a single source or double <span class=\"fortouch\">tap</span>\n"+
    "    <span class=\"notouch\">click</span> to add more sources.\n"+
    "  </p>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSTATICTOCHELP\" class=\"helpbox atfoot\">\n"+
    "  <h2><span class=\"metabooktogglehelp\">Ok</span>\n"+
    "    The Table of Contents</h2>\n"+
    "  <p>The <span>table of contents</span> provides a visually\n"+
    "    annotated hierarchical map of your book.  Red lines indicate your\n"+
    "    current reading location and the blue bars indicate the size and\n"+
    "    relative position of a subsection within its section.</p>\n"+
    "  <p><span class=\"action fortouch\">Touch</span>\n"+
    "    <span class=\"notouch action\">Click</span> an entry to\n"+
    "    start <em>skimming</em> the book starting at that\n"+
    "    location; <span class=\"action fortouch\">Touch</span>\n"+
    "    <span class=\"notouch action\">Click</span> the text to stop\n"+
    "    skimming.</p>\n"+
    "  <p><span class=\"action fortouch\">Press and hold</span>\n"+
    "    <span class=\"notouch action\">Press and hold over</span> an entry\n"+
    "    to view that part of the book <em>without</em> leaving the table\n"+
    "    of contents.</p>\n"+
    "</div>\n"+
    "\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/console.html" */

metaBook.HTML.console=
    "<h1>metaBook Console</h1>\n"+
    "<div class='message' id='METABOOKCONSOLEMESSAGE'></div>\n"+
    "<div id=\"METABOOKCONSOLELOG\" class='sbookmessagelog'></div>\n"+
    "<div id=\"METABOOKCONSOLEINPUT\">\n"+
    "  <span class=\"button\" id=\"METABOOKCONSOLEBUTTON\">run</span>\n"+
    "  <textarea id=\"METABOOKCONSOLETEXTINPUT\">\n"+
    "  </textarea>\n"+
    "</div>\n"+
    "\n"+
    "<!--\n"+
    "/* Emacs local variables\n"+
    ";;;  Local variables: ***\n"+
    ";;;  compile-command: \"cd ../..; make\" ***\n"+
    ";;;  indent-tabs-mode: nil ***\n"+
    ";;;  End: ***\n"+
    "*/\n"+
    "-->\n"+
    "\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/messages.html" */

metaBook.HTML.messages=
    "<div class=\"startupmessage fdjtprogress\" id=\"METABOOKSTARTUPSCAN\">\n"+
    "  <div class=\"indicator\"></div>\n"+
    "  <div class=\"message\">\n"+
    "    Scanning the book content for structure and metadata.</div>\n"+
    "</div>\n"+
    "<div class=\"startupmessage fdjtprogress\" id=\"METABOOKSTARTUPTOC\">\n"+
    "  <div class=\"indicator\"></div>\n"+
    "  <div class=\"message\">\n"+
    "    Setting up tables of content for book navigation.</div>\n"+
    "</div>\n"+
    "<div class=\"startupmessage fdjtprogress\" id=\"METABOOKSTARTUPKNO\">\n"+
    "  <div class=\"indicator\"></div>\n"+
    "  <div class=\"message\">\n"+
    "    Processing embedded or referenced knowledge bases.\n"+
    "    <div id=\"METABOOKSTARTUPKNODETAILS\"></div>\n"+
    "  </div>\n"+
    "</div>\n"+
    "<div class=\"startupmessage fdjtprogress\" id=\"METABOOKSTARTUPTAGGING\">\n"+
    "  <div class=\"indicator\"></div>\n"+
    "  <div class=\"message\">Indexing with published tags.</div>\n"+
    "</div>\n"+
    "<div class=\"startupmessage fdjtprogress\" id=\"METABOOKSTARTUPCLOUDS\">\n"+
    "  <div class=\"indicator\"></div>\n"+
    "  <div class=\"message\">Setting up tag clouds for search and glossing.</div>\n"+
    "</div>\n"+
    "</div>\n"+
    "<div class=\"startupmessage fdjtprogress\" id=\"METABOOKNEWGLOSSES\">\n"+
    "  <div class=\"indicator\"></div>\n"+
    "  <div class=\"message\">Applying your glosses to your book.</div>\n"+
    "</div>\n"+
    "<!--\n"+
    "     /* Emacs local variables\n"+
    "     ;;;  Local variables: ***\n"+
    "     ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "     ;;;  End: ***\n"+
    "     */\n"+
    "  -->\n"+
    "\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/cover.html" */

metaBook.HTML.cover=
    "<div id=\"METABOOKCOVERMESSAGE\" class=\"controls\">\n"+
    "  <div id=\"METABOOKOPENTAB\"\n"+
    "       style=\"width: 7em; margin-left: auto; margin-right: auto; color: white; background-color: gray; margin-top: 0.2ex; padding:  0px 1em 0px 1em; border: solid transparent 2px; font-variant: small-caps; border-radius: 1ex; box-sizing: border-box;\">\n"+
    "    Open\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKREADYMESSAGE\" class=\"message\"\n"+
    "       style=\"width: 7em; margin-left: auto; margin-right: auto; color: white; background-color: gray; margin-top: 0.2ex; padding:  0px 1em 0px 1em; border: solid transparent 2px; font-variant: small-caps; border-radius: 1ex; box-sizing: border-box;\">\n"+
    "    Loading\n"+
    "  </div>\n"+
    "  <div id=\"METABOOKBUSYMESSAGE\" class=\"message\"\n"+
    "       style=\"width: 7em; margin-left: auto; margin-right: auto; color: white; background-color: gray; margin-top: 0.7ex; padding:  0px 1em 0px 1em; border: solid transparent 2px; font-variant: small-caps; border-radius: 1ex; box-sizing: border-box;\">\n"+
    "    Busy\n"+
    "  </div>\n"+
    "  <div class=\"metabookstatus\" id=\"METABOOKLAYOUTMESSAGE\" class=\"message\">\n"+
    "    <div class=\"metabookprogressbox\"><div class=\"indicator\"></div></div>\n"+
    "    <div class=\"message\" style=\"font-size: 24px; font-size: 5vmin;\"></div>\n"+
    "  </div>\n"+
    "  <div class=\"metabookstatus\" id=\"METABOOKINDEXMESSAGE\" class=\"message\">\n"+
    "    <div class=\"metabookprogressbox\"><div class=\"indicator\"></div></div>\n"+
    "    <div class=\"message\" style=\"font-size: 24px; font-size: 5vmin;\"></div>\n"+
    "  </div>\n"+
    "  <div class=\"metabookstatus\" id=\"METABOOKGLOSSMESSAGE\" class=\"message\">\n"+
    "    <div class=\"metabookprogressbox\"><div class=\"indicator\"></div></div>\n"+
    "    <div class=\"message\" style=\"font-size: 24px; font-size: 5vmin;\"></div>\n"+
    "  </div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKCOVERPAGE\" class=\"flap\"\n"+
    "     style=\"position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto; overflow: hidden;\">\n"+
    "  <img src=\"{{coverimage|}}\" alt=\"{{covertext|}}\"\n"+
    "       style=\"max-width: 95%; width: auto; height: 90%;\"\n"+
    "       id=\"METABOOKCOVERIMAGE\"/>\n"+
    "</div>\n"+
    "<div id=\"METABOOKTITLE\" class=\"flap\"\n"+
    "     style=\"position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto; overflow: hidden;\">\n"+
    "</div>\n"+
    "<div id=\"METABOOKCREDITS\" class=\"flap metabookcredits\"\n"+
    "     style=\"position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto; overflow: hidden;\">\n"+
    "</div>\n"+
    "<div id=\"METABOOKBLURB\" class=\"scrolling flap\"\n"+
    "     style=\"position: absolute; top: 50px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;\">\n"+
    "</div>\n"+
    "<div id=\"METABOOKAPPHELP\" class=\"metabookhelp scrolling flap\"\n"+
    "     style=\"position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;\">\n"+
    "  <h1><span class=\"adjustfont\">Welcome to the &metaBook; web-based\n"+
    "      e-reader</span></h1>\n"+
    "  \n"+
    "  <p>You're using &metaBook;, a web-based e-reader created to deepen\n"+
    "    reading and engagement while connecting to networks of knowledge,\n"+
    "    conversation, and commmunity.  &metaBook; aims to reclaim the\n"+
    "    virtues of physical books for electronic books, making them\n"+
    "    natural to navigate, annotate, search, and personalize.</p>\n"+
    "  <div id=\"METABOOKCOVERHELP\"></div>\n"+
    "</div>\n"+
    "<div id=\"METABOOKSETTINGS\" class=\"scrolling flap\"\n"+
    "     style=\"position: absolute; top: 50px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;\">\n"+
    "</div>\n"+
    "<div id=\"METABOOKCONSOLE\" class=\"scrolling flap\"\n"+
    "     style=\"position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;\">\n"+
    "</div>\n"+
    "<div id=\"METABOOKLAYERS\" class=\"scrolling flap\"\n"+
    "     style=\"position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;\">\n"+
    "  <iframe name=\"BOOKHUBAPP\" id=\"BOOKHUBAPP\" frameborder=\"0\" scrolling=\"auto\"></iframe>\n"+
    "</div>\n"+
    "<div id=\"METABOOKCOVERCONTROLS\" \n"+
    "     style=\"position: absolute; bottom: 40px; left: 50px; right: 50px; width: auto; height: 60px; top: auto; font-size: 0.8em; font-size: 1.5rem; font-size: 3vw;\">\n"+
    "  <span class=\"control\" data-mode=\"coverpage\" title=\"see the cover\"\n"+
    "        tabindex=\"1\">\n"+
    "    Cover</span>\n"+
    "  <span class=\"control\" data-mode=\"titlepage\"\n"+
    "        title=\"this book's title page and other information\"\n"+
    "        tabindex=\"2\">\n"+
    "    Title</span>\n"+
    "  <span class=\"control\" data-mode=\"creditspage\"\n"+
    "        title=\"Credits to people and organizations contributing to this book, including bibliographic information\"\n"+
    "        tabindex=\"3\">\n"+
    "    Credits</span>\n"+
    "  <span class=\"control\" data-mode=\"blurb\"\n"+
    "        title=\"learn more about this book and its background\"\n"+
    "        tabindex=\"4\">\n"+
    "    About</span>\n"+
    "  <span class=\"control\" data-mode=\"layers\"\n"+
    "        title=\"manage added layers of glosses for your sBook\"\n"+
    "        tabindex=\"5\">\n"+
    "    Layers</span>\n"+
    "  <span class=\"control\" data-mode=\"console\"\n"+
    "        title=\"the debugging console (advanced)\"\n"+
    "        tabindex=\"6\">\n"+
    "    Console</span>\n"+
    "  <span class=\"control\" data-mode=\"settings\"\n"+
    "        title=\"alter this e-reader's appearance and interactions\"\n"+
    "        tabindex=\"7\">\n"+
    "    Settings</span>\n"+
    "  <span class=\"control\" data-mode=\"help\"\n"+
    "        title=\"simple help for using metaBook\"\n"+
    "        tabindex=\"8\">\n"+
    "    Help</span>\n"+
    "</div>\n"+
    "<div class=\"userbox controls\"\n"+
    "     data-maxfont=\"120%\" id=\"METABOOKUSERBOX\">\n"+
    "  <span class=\"bookplate\">\n"+
    "    <span class=\"text\">This</span>\n"+
    "    <a href=\"https://www.bookhub.io/\" target=\"_blank\"\n"+
    "       title=\"Learn more about the metaBook reader and bookhub.io\" tabindex=\"9\">\n"+
    "      book</a>\n"+
    "    <span class=\"text\">is personalized for</span>\n"+
    "    <a href=\"https://my.bookhub.io/profile/\" class=\"metabookusername\"\n"+
    "       title=\"Edit your profile, add social networks, etc\"\n"+
    "       target=\"_blank\" tabindex=\"10\">\n"+
    "      you</a></span>\n"+
    "</div>\n"+
    "<div class=\"loginbox controls\" data-maxfont=\"120%\" id=\"METABOOKLOGINBOX\">\n"+
    "  <div class=\"loginmessage\">\n"+
    "    Login to bookhub.io to read smarter</div>\n"+
    "  <form action=\"https://auth.bookhub.io/\" method=\"POST\">\n"+
    "    <input TYPE=\"HIDDEN\" NAME=\"FRESHLOGIN\" VALUE=\"yes\"/>\n"+
    "    <input TYPE=\"HIDDEN\" NAME=\"LOGINFORM\" VALUE=\"yes\"/>\n"+
    "    <input TYPE=\"TEXT\" NAME=\"LOGIN\" VALUE=\"\"\n"+
    "           PLACEHOLDER=\"email/cell login\"\n"+
    "           ONKEYPRESS=\"fdjt.UI.submitOnEnter(event);\"\n"+
    "           AUTOCOMPLETE=\"off\"\n"+
    "           tabindex=\"9\"/>\n"+
    "    <span>or use</span>\n"+
    "    <select NAME=\"AUTHORITY\">\n"+
    "      <option value=\"\" selected=\"SELECTED\">Using account</option>\n"+
    "      <option value=\":FACEBOOK\">Facebook</option>\n"+
    "      <option value=\":TWITTER\">Twitter</option>\n"+
    "      <option value=\":YAHOO\">Yahoo!</option>\n"+
    "      <option value=\":GOOGLE\">Google</option>\n"+
    "      <option value=\":GPLUS\">Google+</option>\n"+
    "      <option value=\":LINKEDIN\">Linked In</option>\n"+
    "      <option value=\":AMAZON\">Amazon</option>\n"+
    "      <option value=\":PAYPAL\">PayPal</option>\n"+
    "    </select>\n"+
    "    <button name=\"AUTHORITY\" TABINDEX=\"11\"\n"+
    "            value=\":FACEBOOK\">\n"+
    "      <img src=\"{{bmg}}metabook/facebook64x64.png\" class=\"nosvg\"\n"+
    "           alt=\"Facebook\" class=\"noautoscale\"/>\n"+
    "      <img src=\"{{bmg}}metabook/facebook.svgz\" class=\"svg\"\n"+
    "           alt=\"Facebook\" class=\"noautoscale\"/>\n"+
    "    </button>\n"+
    "    <button NAME=\"AUTHORITY\" TABINDEX=\"12\"\n"+
    "            VALUE=\":TWITTER\">\n"+
    "      <img src=\"{{bmg}}metabook/twitter64x64.png\"\n"+
    "           alt=\"Twitter\" title=\"login with Twitter\"\n"+
    "           class=\"nosvg\"/>\n"+
    "      <img src=\"{{bmg}}metabook/twitter.svgz\"\n"+
    "           alt=\"Twitter\" title=\"login with Twitter\"\n"+
    "           class=\"svg\"/>\n"+
    "    </button>\n"+
    "    <button NAME=\"AUTHORITY\" TABINDEX=\"13\"\n"+
    "            VALUE=\"https://open.login.yahooapis.com/openid/op/auth\">\n"+
    "      <img src=\"{{bmg}}metabook/yahoo64x64.png\" class=\"nosvg\"\n"+
    "           alt=\"Yahoo!\" title=\"login using Yahoo!\"/>\n"+
    "      <img src=\"{{bmg}}metabook/yahoo.svgz\" class=\"svg\"\n"+
    "           alt=\"Yahoo!\" title=\"login using Yahoo!\"/>\n"+
    "    </button>\n"+
    "    <button NAME=\"AUTHORITY\" TABINDEX=\"14\"\n"+
    "            VALUE=\":GOOGLE\">\n"+
    "      <img src=\"{{bmg}}metabook/google64x64.png\"\n"+
    "           alt=\"Google\" title=\"login using your Google account\"\n"+
    "           class=\"nosvg\"/>\n"+
    "      <img src=\"{{bmg}}metabook/google.svgz\"\n"+
    "           alt=\"Google\" title=\"login using your Google account\"\n"+
    "           class=\"svg\"/>\n"+
    "    </button>\n"+
    "    <button NAME=\"AUTHORITY\" TABINDEX=\"15\"\n"+
    "            VALUE=\":GPLUS\">\n"+
    "      <img src=\"{{bmg}}metabook/googleplus64x64.png\"\n"+
    "           alt=\"Google\" title=\"login using Google+\"\n"+
    "           class=\"nosvg\"/>\n"+
    "      <img src=\"{{bmg}}metabook/googleplus.svgz\"\n"+
    "           alt=\"Google\" title=\"login using Google+\"\n"+
    "           class=\"svg\"/>\n"+
    "    </button>\n"+
    "    <button NAME=\"AUTHORITY\" VALUE=\":LINKEDIN\" TABINDEX=\"16\">\n"+
    "      <img src=\"{{bmg}}metabook/linkedin64x64.png\"\n"+
    "           alt=\"Linked In\" title=\"login with Linked In\"\n"+
    "           class=\"nosvg\"/>\n"+
    "      <img src=\"{{bmg}}metabook/linkedin.svgz\"\n"+
    "           alt=\"Linked In\" title=\"login with Linked In\"\n"+
    "           class=\"svg\"/>\n"+
    "    </button>\n"+
    "    <button name=\"AUTHORITY\" TABINDEX=\"17\"\n"+
    "            value=\":AMAZON\">\n"+
    "      <img src=\"{{bmg}}metabook/amazon64x64.png\"\n"+
    "           alt=\"Amazon\" title=\"login with your Amazon account\"/>\n"+
    "    </button>\n"+
    "    <button name=\"AUTHORITY\" TABINDEX=\"18\"\n"+
    "            value=\":PAYPAL\">\n"+
    "      <img src=\"{{bmg}}metabook/paypalsquare64x64.png\" class=\"nosvg\"\n"+
    "           alt=\"PayPal\" title=\"login with PayPal\"/>\n"+
    "      <img src=\"{{bmg}}metabook/paypalsquare.svgz\" class=\"svg\"\n"+
    "           alt=\"PayPal\" title=\"login with PayPal\"/>\n"+
    "    </button>\n"+
    "  </form>\n"+
    "</div>\n"+
    "\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/settings.html" */

metaBook.HTML.settings=
    "<form onsubmit=\"fdjt.UI.cancel(event); return false;\" class=\"metabooksettings\">\n"+
    "  <h1 class=\"cf\">\n"+
    "    Settings\n"+
    "    <span class=\"message\" ID=\"METABOOKSETTINGSMESSAGE\"></span></h1>\n"+
    "  <div class=\"fontsizes body\"\n"+
    "       title=\"Set the font sizes used for the body text.\">\n"+
    "    <span class=\"label\" id=\"METABOOKBODYSIZELABEL\">\n"+
    "      Body size<br/>\n"+
    "      <button name=\"REFRESH\" value=\"Layout\"\n"+
    "              id=\"METABOOKREFRESHLAYOUT\">\n"+
    "        <img src=\"{{bmg}}metabook/refresh.svgz\" alt=\"Update\">\n"+
    "        Layout</button></span>\n"+
    "    <span class=\"samples\">\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"bodysize\"\n"+
    "               VALUE=\"xlarge\"/>\n"+
    "        <span class=\"sample xlarge\">Aa</span></span>\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"bodysize\" \n"+
    "               VALUE=\"large\"/>\n"+
    "        <span class=\"sample large\">Aa</span></span>\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"bodysize\" \n"+
    "               VALUE=\"normal\"/>\n"+
    "        <span class=\"sample normal\">Aa</span></span>\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"bodysize\" \n"+
    "               VALUE=\"small\"/>\n"+
    "        <span class=\"sample small\">Aa</span></span>\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"bodysize\"\n"+
    "               VALUE=\"tiny\"/>\n"+
    "        <span class=\"sample tiny\">Aa</span></span>\n"+
    "    </span>\n"+
    "  </div>\n"+
    "  <!--\n"+
    "  <div class=\"checkspans fontfamily\"\n"+
    "       title=\"Set the font sizes used for the body text.\">\n"+
    "    <span class=\"label smaller\">Font family</span>\n"+
    "    <span class=\"checkspan sanserif\">\n"+
    "      <input TYPE=\"RADIO\" NAME=\"bodyfamily\"\n"+
    "             VALUE=\"sanserif\"/>\n"+
    "      <span class=\"sample sanserif\">Sans</span></span>\n"+
    "    <span class=\"checkspan serif\">\n"+
    "      <input TYPE=\"RADIO\" NAME=\"bodyfamily\" \n"+
    "             VALUE=\"serif\"/>\n"+
    "      <span class=\"sample serif\">Serif</span></span>\n"+
    "    <span class=\"checkspan lowcontrast\">\n"+
    "      <input TYPE=\"RADIO\" NAME=\"bodyfamily\"\n"+
    "             VALUE=\"opendyslexic\"/>\n"+
    "      <span class=\"sample opendyslexic\">Open Dyslexic</span></span>\n"+
    "  </div>\n"+
    "  -->\n"+
    "  <div class=\"contrast checkspans\"\n"+
    "       title=\"Select the contrast level for body text\">\n"+
    "    <span class=\"label smaller\">Text Contrast</span>\n"+
    "    <span class=\"checkspan highcontrast\">\n"+
    "      <input TYPE=\"RADIO\" NAME=\"bodycontrast\"\n"+
    "             VALUE=\"high\"/>\n"+
    "      <span class=\"sample\">High</span></span>\n"+
    "    <span class=\"checkspan normalcontrast\">\n"+
    "      <input TYPE=\"RADIO\" NAME=\"bodycontrast\" \n"+
    "             VALUE=\"medium\"/>\n"+
    "      <span class=\"sample\">Normal</span></span>\n"+
    "    <span class=\"checkspan lowcontrast\">\n"+
    "      <input TYPE=\"RADIO\" NAME=\"bodycontrast\"\n"+
    "             VALUE=\"low\"/>\n"+
    "      <span class=\"sample\">Low</span></span>\n"+
    "  </div>\n"+
    "  <div class=\"textlayout checkspans\">\n"+
    "    <span class=\"label smaller\">Layout</span>\n"+
    "    <span class=\"checkspans\">\n"+
    "      <span class=\"checkspan codex\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"METABOOKLAYOUT\"\n"+
    "               VALUE=\"bypage\"/>\n"+
    "        by pages</span>\n"+
    "      <span class=\"checkspan scrolling\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"METABOOKLAYOUT\" \n"+
    "               VALUE=\"scrolling\"/>\n"+
    "        just scroll</span>\n"+
    "      <span class=\"checkspan scrollio\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"METABOOKLAYOUT\"\n"+
    "               VALUE=\"scrollio\"/>\n"+
    "        hybrid (<em>scrollio</em>)</span>\n"+
    "    </span>\n"+
    "  </div>\n"+
    "  <div class=\"also checkspans\">\n"+
    "    <span class=\"label smaller\">Other Options</span>\n"+
    "    <span class=\"checkspan opendyslexical\"\n"+
    "          title=\"OpenDyslexic is a font designed to increase readability for readers with dyslexia\">\n"+
    "      <input TYPE=\"CHECKBOX\" NAME=\"dyslexical\" VALUE=\"yes\"/>\n"+
    "      <span class=\"text\">Use OpenDyslexic font</span>\n"+
    "      <a href=\"http://opendyslexic.org/\"\n"+
    "         title=\"The Open Dyslexic font site\">(about)</a>\n"+
    "    </span>\n"+
    "    <span class=\"sep\">//</span>\n"+
    "    <span class=\"checkspan justify\"\n"+
    "          title=\"left/right justify paragraphs of body text\">\n"+
    "      <input TYPE=\"CHECKBOX\" NAME=\"textjustify\" VALUE=\"yes\"/>\n"+
    "      Justify paragraphs</span>\n"+
    "  </div>\n"+
    "  <div class=\"fontsizes device\"\n"+
    "       title=\"Set the font sizes used by the interface components of metaBook\">\n"+
    "    <span class=\"label\">App font</span>\n"+
    "    <span class=\"samples\">\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"uisize\" VALUE=\"large\"/>\n"+
    "        <span class=\"sample xlarge\">Aa</span></span>\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"uisize\" VALUE=\"normal\"/>\n"+
    "        <span class=\"sample normal\">Aa</span></span>\n"+
    "      <span class=\"checkspan\">\n"+
    "        <input TYPE=\"RADIO\" NAME=\"uisize\" VALUE=\"small\"/>\n"+
    "        <span class=\"sample small\">Aa</span></span>\n"+
    "    </span>\n"+
    "  </div>\n"+
    "  <div class=\"animation\">\n"+
    "    <span class=\"label smaller\">Animate</span>\n"+
    "    <span class=\"checkspan\">\n"+
    "      <input TYPE=\"CHECKBOX\" NAME=\"animatecontent\" VALUE=\"yes\"/>\n"+
    "      <span class=\"text\">content (page flips, etc)</span></span>\n"+
    "    <span class=\"checkspan\">\n"+
    "      <input TYPE=\"CHECKBOX\" NAME=\"animatehud\" VALUE=\"yes\"/>\n"+
    "      <span class=\"text\">interface (overlays, controls, etc)</span></span>\n"+
    "  </div>\n"+
    "  <div class=\"header dataheader cf\">\n"+
    "    <button NAME=\"CLEARDATA\" VALUE=\"ALL\">Erase all</button>\n"+
    "    <span class=\"label\">Storage</span>\n"+
    "  </div>\n"+
    "  <div class=\"checkspan syncloc cf\">\n"+
    "    <button id=\"METABOOKRESETSYNC\" name=\"SYNC\" VALUE=\"RESET\"\n"+
    "            class=\"reset floatright\"\n"+
    "            title=\"Reset synchronized location information.\">\n"+
    "      <img src=\"{{bmg}}metabook/reset.svgz\" alt=\"\"/>\n"+
    "      Reset</button>\n"+
    "    <input TYPE=\"CHECKBOX\" NAME=\"locsync\" VALUE=\"yes\"/>\n"+
    "    <span class=\"text\">\n"+
    "      Sync your <strong>reading location</strong> with other devices</span>\n"+
    "  </div>\n"+
    "  <div class=\"checkspan saveglosses cf\">\n"+
    "    <button id=\"METABOOKREFRESHOFFLINE\" class=\"refresh floatright\"\n"+
    "            title=\"Reload glosses and layers for this book from the cloud.\">\n"+
    "      <img src=\"{{bmg}}metabook/refresh.svgz\" alt=\"\"/>\n"+
    "      Reload</button>\n"+
    "    <input TYPE=\"CHECKBOX\" NAME=\"cacheglosses\" VALUE=\"yes\" CHECKED/>\n"+
    "    <span class=\"text\">\n"+
    "      Save copies of <strong>glosses</strong>\n"+
    "      and <strong>layers</strong> on this device</span>\n"+
    "  </div>\n"+
    "  <div class=\"checkspan showconsole cf\">\n"+
    "    <span class=\"label\">Developer</span>\n"+
    "    <input TYPE=\"CHECKBOX\" NAME=\"showconsole\" VALUE=\"yes\"/>\n"+
    "    <span class=\"text\">Show the application console</span>\n"+
    "  </div>\n"+
    "  <div class=\"info\" id=\"METABOOKINFOPANEL\">\n"+
    "    <span class=\"label\">Info</span>\n"+
    "    <p class=\"metabookrefinfo\"></p>\n"+
    "    <p class=\"metabooksourceinfo\"></p>\n"+
    "    <p class=\"metabookbuildinfo\"></p>\n"+
    "    <p class=\"metabookappinfo\"></p>\n"+
    "    <p class=\"metabookserverinfo\"></p>\n"+
    "  </div>\n"+
    "  <div class=\"metabookcopyright\">\n"+
    "    <p class=\"metabookcopyrightinfo\"></p>\n"+
    "  </div>\n"+
    "\n"+
    "</form>\n"+
    "\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/pageleft.html" */

metaBook.HTML.pageleft=
    "<img svg=\"{{bmg}}metabook/page_left.svgz\"\n"+
    "     src=\"{{bmg}}metabook/page_left100h.png\"\n"+
    "     id=\"METABOOKPREVPAGE\" class=\"metabookpagebutton\" alt=\"prev\"\n"+
    "     title=\"go to the previous page\"/>\n"+
    "<img svg=\"{{bmg}}metabook/skim_left.svgz\"\n"+
    "     src=\"{{bmg}}metabook/skim_left100x100.png\"\n"+
    "     id=\"METABOOKPREVSKIM\" class=\"metabookskimbutton\" alt=\"prev\"\n"+
    "     title=\"go to the previous result/gloss\"/>\n"+
    "<img svg=\"{{bmg}}metabook/skim_left_stop.svgz\"\n"+
    "     src=\"{{bmg}}metabook/skim_left_stop100x100.png\"\n"+
    "     id=\"METABOOKSTARTSKIM\" class=\"metabookskimbutton\"\n"+
    "     alt=\"beginning\"/>\n"+
    "<img svg=\"{{bmg}}metabook/page_right.svgz\"\n"+
    "     src=\"{{bmg}}metabook/page_right100h.png\"\n"+
    "     id=\"METABOOKNEXTPAGE\" class=\"metabookpagebutton\" alt=\"next\"\n"+
    "     title=\"go to the next page\"/>\n"+
    "<img svg=\"{{bmg}}metabook/skim_right_stop.svgz\"\n"+
    "     src=\"{{bmg}}metabook/skim_right_stop100x100.png\"\n"+
    "     id=\"METABOOKENDSKIM\" class=\"metabookskimbutton\"\n"+
    "     alt=\"end\"/>\n"+
    "<img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "     src=\"{{bmg}}metabook/skim_right100x100.png\"\n"+
    "     id=\"METABOOKNEXTSKIM\" class=\"metabookskimbutton\" alt=\"next\"\n"+
    "     title=\"go to the next result/gloss\"/>\n"+
    "<div class=\"metabookskimindicator\" id=\"METABOOKSKIMINDEX\"></div>\n"+
    "\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "metabook/html/pageright.html" */

metaBook.HTML.pageright=
    "<img svg=\"{{bmg}}metabook/page_right.svgz\"\n"+
    "     src=\"{{bmg}}metabook/page_right100h.png\"\n"+
    "     id=\"METABOOKNEXTPAGE\" class=\"metabookpagebutton\" alt=\"next\"\n"+
    "     title=\"go to the next page\"/>\n"+
    "<img svg=\"{{bmg}}metabook/skim_right_stop.svgz\"\n"+
    "     src=\"{{bmg}}metabook/skim_right_stop100x100.png\"\n"+
    "     id=\"METABOOKENDSKIM\" class=\"metabookskimbutton\"\n"+
    "     alt=\"end\"/>\n"+
    "<img svg=\"{{bmg}}metabook/skim_right.svgz\"\n"+
    "     src=\"{{bmg}}metabook/skim_right100x100.png\"\n"+
    "     id=\"METABOOKNEXTSKIM\" class=\"metabookskimbutton\" alt=\"next\"\n"+
    "     title=\"go to the next result/gloss\"/>\n"+
    "<div class=\"metabookskimindicator\" id=\"METABOOKSKIMLIMIT\"></div>\n"+
    "\n"+
    "<!--\n"+
    "    /* Emacs local variables\n"+
    "    ;;;  Local variables: ***\n"+
    "    ;;;  compile-command: \"cd ../..; make\" ***\n"+
    "    ;;;  indent-tabs-mode: nil ***\n"+
    "    ;;;  End: ***\n"+
    "    */\n"+
    "  -->\n"+
    "";
// FDJT build information
fdjt.revision='1.5-1472-g43454b7';
fdjt.buildhost='moby.dc.beingmeta.com';
fdjt.buildtime='Mon Sep 28 20:49:42 EDT 2015';
fdjt.builduuid='1c1b7bbc-07c5-40e8-a9c9-93bd7d5b4b38';

fdjt.CodexLayout.sourcehash='EB4183B4E761BC2D03C3E6FDC3627EDF69BC566A';


Knodule.version='v0.8-152-gc2cb02e';
// sBooks metaBook build information
metaBook.version='v0.8-74-g2367567';
metaBook.buildid='e863ff8b-5a3c-46a4-98a0-c57377755d07';
metaBook.buildtime='Mon Sep 28 20:49:52 EDT 2015';
metaBook.buildhost='moby.dc.beingmeta.com';

if ((typeof _metabook_suppressed === "undefined")||(!(_metabook_suppressed)))
    window.onload=function(evt){metaBook.Setup();};
fdjt.CodexLayout.sourcehash='EB4183B4E761BC2D03C3E6FDC3627EDF69BC566A';
