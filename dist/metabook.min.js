window._metabook_amalgam = document && document.currentScript && document.currentScript.src;

var fdjt = fdjt === void 0 ? {} : fdjt, fdjt_versions = fdjt_versions === void 0 ? [] : fdjt_versions || [];

(function() {
    "use strict";
    fdjt_versions.decl = function(name, num) {
        (!fdjt_versions[name] || num > fdjt_versions[name]) && (fdjt_versions[name] = num);
    }, Array.prototype.indexOf || (Array.prototype.indexOf = function(elt, i) {
        i || (i = 0);
        for (var len = this.length; len > i; ) {
            if (this[i] === elt) return i;
            i++;
        }
        return -1;
    }), Object.keys || (Object.keys = function(o) {
        if (o !== Object(o)) throw new TypeError("Object.keys called on non-object");
        var p, ret = [];
        for (p in o) Object.prototype.hasOwnProperty.call(o, p) && ret.push(p);
        return ret;
    }), String.prototype.trim || (String.prototype.trim = function() {
        var trimLeft = /^\s+/, trimRight = /\s+$/;
        return function() {
            return this.replace(trimLeft, "").replace(trimRight, "");
        };
    });
})(), function() {
    "use strict";
    function bind(fn, thisArg) {
        return function() {
            fn.apply(thisArg, arguments);
        };
    }
    function PromiseFillIn(fn) {
        if ("object" != typeof this) throw new TypeError('Use "new" to make Promises');
        if ("function" != typeof fn) throw new TypeError("not a function");
        this._state = null, this._value = null, this._deferreds = [], doResolve(fn, bind(resolve, this), bind(reject, this));
    }
    function handle(deferred) {
        var me = this;
        return null === this._state ? (this._deferreds.push(deferred), void 0) : (asap(function() {
            var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
            if (null === cb) return (me._state ? deferred.resolve : deferred.reject)(me._value), 
            void 0;
            var ret;
            try {
                ret = cb(me._value);
            } catch (e) {
                return deferred.reject(e), void 0;
            }
            deferred.resolve(ret);
        }), void 0);
    }
    function resolve(newValue) {
        try {
            if (newValue === this) throw new TypeError("A promise cannot be resolved with itself.");
            if (newValue && ("object" == typeof newValue || "function" == typeof newValue)) {
                var then = newValue.then;
                if ("function" == typeof then) return doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this)), 
                void 0;
            }
            this._state = !0, this._value = newValue, finale.call(this);
        } catch (e) {
            reject.call(this, e);
        }
    }
    function reject(newValue) {
        this._state = !1, this._value = newValue, finale.call(this);
    }
    function finale() {
        for (var i = 0, len = this._deferreds.length; len > i; i++) handle.call(this, this._deferreds[i]);
        this._deferreds = null;
    }
    function Handler(onFulfilled, onRejected, resolve, reject) {
        this.onFulfilled = "function" == typeof onFulfilled ? onFulfilled : null, this.onRejected = "function" == typeof onRejected ? onRejected : null, 
        this.resolve = resolve, this.reject = reject;
    }
    function doResolve(fn, onFulfilled, onRejected) {
        var done = !1;
        try {
            fn(function(value) {
                done || (done = !0, onFulfilled(value));
            }, function(reason) {
                done || (done = !0, onRejected(reason));
            });
        } catch (ex) {
            if (done) return;
            done = !0, onRejected(ex);
        }
    }
    var root;
    root = "object" == typeof window && window ? window : global;
    var asap = root.Promise && root.Promise.immediateFn || root.setImmediate || function(fn) {
        setTimeout(fn, 1);
    }, isArray = Array.isArray || function(value) {
        return "[object Array]" === Object.prototype.toString.call(value);
    };
    PromiseFillIn.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
    }, PromiseFillIn.prototype.then = function(onFulfilled, onRejected) {
        var me = this;
        return new PromiseFillIn(function(resolve, reject) {
            handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
        });
    }, PromiseFillIn.all = function() {
        var args = Array.prototype.slice.call(1 === arguments.length && isArray(arguments[0]) ? arguments[0] : arguments);
        return new PromiseFillIn(function(resolve, reject) {
            function res(i, val) {
                try {
                    if (val && ("object" == typeof val || "function" == typeof val)) {
                        var then = val.then;
                        if ("function" == typeof then) return then.call(val, function(val) {
                            res(i, val);
                        }, reject), void 0;
                    }
                    args[i] = val, 0 === --remaining && resolve(args);
                } catch (ex) {
                    reject(ex);
                }
            }
            if (0 === args.length) return resolve([]);
            for (var remaining = args.length, i = 0; args.length > i; i++) res(i, args[i]);
        });
    }, PromiseFillIn.resolve = function(value) {
        return value && "object" == typeof value && value.constructor === PromiseFillIn ? value : new PromiseFillIn(function(resolve) {
            resolve(value);
        });
    }, PromiseFillIn.reject = function(value) {
        return new PromiseFillIn(function(resolve, reject) {
            reject(value);
        });
    }, PromiseFillIn.race = function(values) {
        return new PromiseFillIn(function(resolve, reject) {
            for (var i = 0, len = values.length; len > i; i++) values[i].then(resolve, reject);
        });
    }, "undefined" != typeof module && module.exports ? module.exports = PromiseFillIn : root.Promise || (root.Promise = PromiseFillIn);
}(), fdjt.Async = fdjt.ASync = fdjt.async = function() {
    "use strict";
    function fdjtAsync(fn, args) {
        function async_call(resolve, reject) {
            function async_doit() {
                var value;
                try {
                    value = args ? fn.call(null, args) : fn(), resolve(value);
                } catch (ex) {
                    reject(ex);
                }
            }
            setTimeout(async_doit, 1);
        }
        return new Promise(async_call);
    }
    function getnow() {
        return new Date().getTime();
    }
    function timeslice(fcns, slice, space, stop, done, fail) {
        function slicefn() {
            for (var timelim = getnow() + slice, nextspace = !1; lim > i; ) {
                var fcn = fcns[i++];
                if (fcn) {
                    if ("number" == typeof fcn) {
                        nextspace = fcn;
                        break;
                    }
                    try {
                        fcn();
                    } catch (ex) {
                        fail(ex);
                    }
                    if (getnow() > timelim) break;
                }
            }
            !(lim > i) || stop && stop() ? (clearTimeout(timer), timer = !1, done(!1)) : timer = setTimeout(slicefn, nextspace || space);
        }
        var timer = !1;
        "number" != typeof slice && (slice = 100), "number" != typeof space && (space = 100);
        var i = 0, lim = fcns.length;
        return slicefn();
    }
    function timeslice_method(fcns, opts) {
        function timeslicing(success, failure) {
            timeslice(fcns, slice, space, stop, success, failure);
        }
        opts || (opts = {});
        var slice = opts.slice || 100, space = opts.space || 100, stop = opts.stop || !1;
        return new Promise(timeslicing);
    }
    function slowmap(fn, vec, watch, done, failed, slice, space, onerr, watch_slice) {
        function slowmap_stepfn() {
            try {
                var started = getnow(), now = started, stopat = started + slice;
                for (watch && watch(0 === i ? "start" : "resume", i, lim, chunks, used, zerostart); lim > i && stopat > (now = getnow()); ) {
                    var elt = vec[i];
                    watch && (watch_slice && 0 === i % watch_slice || i + 1 === lim) && watch("element", i, lim, elt, used, now - zerostart);
                    try {
                        fn(elt);
                    } catch (ex) {
                        var exdata = {
                            elt: elt,
                            i: i,
                            lim: lim,
                            vec: vec
                        };
                        if (onerr && onerr(ex, elt, exdata)) continue;
                        if (failed) return failed(ex);
                        throw ex;
                    }
                    watch && (watch_slice && 0 === i % watch_slice || i + 1 === lim) && watch("after", i, lim, elt, used + (getnow() - started), zerostart, getnow() - now), 
                    i++;
                }
                if (chunks += 1, lim > i) used += now - started, watch && watch("suspend", i, lim, chunks, used, zerostart), 
                timer = setTimeout(slowmap_stepfn, space); else {
                    now = getnow(), used += now - started, clearTimeout(timer), timer = !1, watch && watch("finishing", i, lim, chunks, used, zerostart);
                    var donetime = done && getnow() - now;
                    now = getnow(), used += now - started, watch && watch("done", i, lim, chunks, used, zerostart, donetime), 
                    done && done.call && done(vec, now - zerostart, used);
                }
            } catch (ex) {
                failed && failed(ex);
            }
        }
        var i = 0, lim = vec.length, chunks = 0, used = 0, zerostart = getnow(), timer = !1;
        slice || (slice = 100), space || (space = slice), watch_slice || (watch_slice = 0), 
        timer = setTimeout(slowmap_stepfn, space);
    }
    function slowmap_handler(fcn, vec, opts) {
        function slowmapping(resolve, reject) {
            if (sync) {
                for (var i = 0, lim = vec.length; lim > i; ) {
                    var elt = vec[i++];
                    try {
                        fcn(vec[elt]);
                    } catch (ex) {
                        var exdata = {
                            elt: elt,
                            i: i,
                            lim: lim,
                            vec: vec
                        };
                        if (onerr && onerr(ex, elt, exdata)) continue;
                        if (reject) return reject(ex);
                        throw ex;
                    }
                }
                resolve && resolve(vec);
            } else slowmap(fcn, vec, watchfn, donefn ? function() {
                donefn(), resolve && resolve(vec);
            } : resolve, reject, slice, space, onerr, watch_slice);
        }
        opts || (opts = {});
        var slice = opts.slice, space = opts.space, onerr = opts.onerr, watchfn = opts.watchfn, watch_slice = opts.watch, sync = opts.hasOwnProperty("sync") ? opts.sync : opts.hasOwnProperty("async") ? !opts.async : !1, donefn = opts.done;
        return 1 > watch_slice && (watch_slice = vec.length * watch_slice), new Promise(slowmapping);
    }
    function debounce(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this, args = arguments, later = function() {
                timeout = null, immediate || func.apply(context, args);
            }, callNow = immediate && !timeout;
            clearTimeout(timeout), timeout = setTimeout(later, wait), callNow && func.apply(context, args);
        };
    }
    function poll(fn, callback, errback, timeout, interval) {
        var endTime = Number(new Date()) + (timeout || 2e3);
        interval = interval || 100, function p() {
            fn() ? callback() : endTime > Number(new Date()) ? setTimeout(p, interval) : errback(Error("timed out for " + fn + ": " + arguments));
        }();
    }
    function once(fn, context) {
        var result;
        return function() {
            return fn && (result = fn.apply(context || this, arguments), fn = null), result;
        };
    }
    return fdjtAsync.timeslice = timeslice_method, fdjtAsync.slowmap = slowmap_handler, 
    fdjtAsync.debounce = debounce, fdjtAsync.poll = poll, fdjtAsync.once = once, fdjtAsync;
}(), function(self) {
    "use strict";
    function normalizeName(name) {
        if ("string" != typeof name && (name += ""), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) throw new TypeError("Invalid character in header field name");
        return name.toLowerCase();
    }
    function normalizeValue(value) {
        return "string" != typeof value && (value += ""), value;
    }
    function Headers(headers) {
        this.map = {}, headers instanceof Headers ? headers.forEach(function(value, name) {
            this.append(name, value);
        }, this) : headers && Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
        }, this);
    }
    function consumed(body) {
        return body.bodyUsed ? Promise.reject(new TypeError("Already read")) : (body.bodyUsed = !0, 
        void 0);
    }
    function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
            reader.onload = function() {
                resolve(reader.result);
            }, reader.onerror = function() {
                reject(reader.error);
            };
        });
    }
    function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        return reader.readAsArrayBuffer(blob), fileReaderReady(reader);
    }
    function readBlobAsText(blob) {
        var reader = new FileReader();
        return reader.readAsText(blob), fileReaderReady(reader);
    }
    function Body() {
        return this.bodyUsed = !1, this._initBody = function(body) {
            if (this._bodyInit = body, "string" == typeof body) this._bodyText = body; else if (support.blob && Blob.prototype.isPrototypeOf(body)) this._bodyBlob = body; else if (support.formData && FormData.prototype.isPrototypeOf(body)) this._bodyFormData = body; else if (body) {
                if (!support.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(body)) throw Error("unsupported BodyInit type");
            } else this._bodyText = "";
        }, support.blob ? (this.blob = function() {
            var rejected = consumed(this);
            if (rejected) return rejected;
            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
            if (this._bodyFormData) throw Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([ this._bodyText ]));
        }, this.arrayBuffer = function() {
            return this.blob().then(readBlobAsArrayBuffer);
        }, this.text = function() {
            var rejected = consumed(this);
            if (rejected) return rejected;
            if (this._bodyBlob) return readBlobAsText(this._bodyBlob);
            if (this._bodyFormData) throw Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
        }) : this.text = function() {
            var rejected = consumed(this);
            return rejected ? rejected : Promise.resolve(this._bodyText);
        }, support.formData && (this.formData = function() {
            return this.text().then(decode);
        }), this.json = function() {
            return this.text().then(JSON.parse);
        }, this;
    }
    function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
    }
    function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (Request.prototype.isPrototypeOf(input)) {
            if (input.bodyUsed) throw new TypeError("Already read");
            this.url = input.url, this.credentials = input.credentials, options.headers || (this.headers = new Headers(input.headers)), 
            this.method = input.method, this.mode = input.mode, body || (body = input._bodyInit, 
            input.bodyUsed = !0);
        } else this.url = input;
        if (this.credentials = options.credentials || this.credentials || "omit", (options.headers || !this.headers) && (this.headers = new Headers(options.headers)), 
        this.method = normalizeMethod(options.method || this.method || "GET"), this.mode = options.mode || this.mode || null, 
        this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && body) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(body);
    }
    function decode(body) {
        var form = new FormData();
        return body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
                var split = bytes.split("="), name = split.shift().replace(/\+/g, " "), value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
        }), form;
    }
    function headers(xhr) {
        var head = new Headers(), pairs = xhr.getAllResponseHeaders().trim().split("\n");
        return pairs.forEach(function(header) {
            var split = header.trim().split(":"), key = split.shift().trim(), value = split.join(":").trim();
            head.append(key, value);
        }), head;
    }
    function Response(bodyInit, options) {
        options || (options = {}), this._initBody(bodyInit), this.type = "default", this.status = options.status, 
        this.ok = this.status >= 200 && 300 > this.status, this.statusText = options.statusText, 
        this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers), 
        this.url = options.url || "";
    }
    if (!self.fetch) {
        Headers.prototype.append = function(name, value) {
            name = normalizeName(name), value = normalizeValue(value);
            var list = this.map[name];
            list || (list = [], this.map[name] = list), list.push(value);
        }, Headers.prototype["delete"] = function(name) {
            delete this.map[normalizeName(name)];
        }, Headers.prototype.get = function(name) {
            var values = this.map[normalizeName(name)];
            return values ? values[0] : null;
        }, Headers.prototype.getAll = function(name) {
            return this.map[normalizeName(name)] || [];
        }, Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
        }, Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = [ normalizeValue(value) ];
        }, Headers.prototype.forEach = function(callback, thisArg) {
            Object.getOwnPropertyNames(this.map).forEach(function(name) {
                this.map[name].forEach(function(value) {
                    callback.call(thisArg, value, name, this);
                }, this);
            }, this);
        };
        var support = {
            blob: "FileReader" in self && "Blob" in self && function() {
                try {
                    return new Blob(), !0;
                } catch (e) {
                    return !1;
                }
            }(),
            formData: "FormData" in self,
            arrayBuffer: "ArrayBuffer" in self
        }, methods = [ "DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT" ];
        Request.prototype.clone = function() {
            return new Request(this);
        }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
            });
        }, Response.error = function() {
            var response = new Response(null, {
                status: 0,
                statusText: ""
            });
            return response.type = "error", response;
        };
        var redirectStatuses = [ 301, 302, 303, 307, 308 ];
        Response.redirect = function(url, status) {
            if (-1 === redirectStatuses.indexOf(status)) throw new RangeError("Invalid status code");
            return new Response(null, {
                status: status,
                headers: {
                    location: url
                }
            });
        }, self.Headers = Headers, self.Request = Request, self.Response = Response, self.fetch = function(input, init) {
            return new Promise(function(resolve, reject) {
                function responseURL() {
                    return "responseURL" in xhr ? xhr.responseURL : /^X-Request-URL:/m.test(xhr.getAllResponseHeaders()) ? xhr.getResponseHeader("X-Request-URL") : void 0;
                }
                var request;
                request = Request.prototype.isPrototypeOf(input) && !init ? input : new Request(input, init);
                var xhr = new XMLHttpRequest();
                xhr.onload = function() {
                    var status = 1223 === xhr.status ? 204 : xhr.status;
                    if (100 > status || status > 599) return reject(new TypeError("Network request failed")), 
                    void 0;
                    var options = {
                        status: status,
                        statusText: xhr.statusText,
                        headers: headers(xhr),
                        url: responseURL()
                    }, body = "response" in xhr ? xhr.response : xhr.responseText;
                    resolve(new Response(body, options));
                }, xhr.onerror = function() {
                    reject(new TypeError("Network request failed"));
                }, xhr.open(request.method, request.url, !0), "include" === request.credentials && (xhr.withCredentials = !0), 
                "responseType" in xhr && support.blob && (xhr.responseType = "blob"), request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                }).xhr.send(request._bodyInit === void 0 ? null : request._bodyInit);
            });
        }, self.fetch.polyfill = !0;
    }
}(self || window || this), fdjt.charnames = {
    AElig: "Æ",
    Aacgr: "Ά",
    Aacute: "Á",
    Abreve: "Ă",
    Acirc: "Â",
    Acy: "А",
    Agr: "Α",
    Agrave: "À",
    Alpha: "Α",
    Amacr: "Ā",
    Aogon: "Ą",
    Aring: "Å",
    Atilde: "Ã",
    Auml: "Ä",
    Barwed: "⌆",
    Bcy: "Б",
    Beta: "Β",
    Bgr: "Β",
    CHcy: "Ч",
    Cacute: "Ć",
    Cap: "⋒",
    Ccaron: "Č",
    Ccedil: "Ç",
    Ccirc: "Ĉ",
    Cdot: "Ċ",
    Chi: "Χ",
    Cup: "⋓",
    DJcy: "Ђ",
    DScy: "Ѕ",
    DZcy: "Џ",
    Dagger: "‡",
    Dcaron: "Ď",
    Dcy: "Д",
    Delta: "Δ",
    Dgr: "Δ",
    Dot: "¨",
    DotDot: "⃜",
    Dstrok: "Đ",
    EEacgr: "Ή",
    EEgr: "Η",
    ENG: "Ŋ",
    ETH: "Ð",
    Eacgr: "Έ",
    Eacute: "É",
    Ecaron: "Ě",
    Ecirc: "Ê",
    Ecy: "Э",
    Edot: "Ė",
    Egr: "Ε",
    Egrave: "È",
    Emacr: "Ē",
    Eogon: "Ę",
    Epsilon: "Ε",
    Eta: "Η",
    Euml: "Ë",
    Fcy: "Ф",
    GJcy: "Ѓ",
    Gamma: "Γ",
    Gbreve: "Ğ",
    Gcedil: "Ģ",
    Gcirc: "Ĝ",
    Gcy: "Г",
    Gdot: "Ġ",
    Gg: "⋙",
    Ggr: "Γ",
    Gt: "≫",
    HARDcy: "Ъ",
    Hcirc: "Ĥ",
    Hstrok: "Ħ",
    IEcy: "Е",
    IJlig: "Ĳ",
    IOcy: "Ё",
    Iacgr: "Ί",
    Iacute: "Í",
    Icirc: "Î",
    Icy: "И",
    Idigr: "Ϊ",
    Idot: "İ",
    Igr: "Ι",
    Igrave: "Ì",
    Imacr: "Ī",
    Iogon: "Į",
    Iota: "Ι",
    Itilde: "Ĩ",
    Iukcy: "І",
    Iuml: "Ï",
    Jcirc: "Ĵ",
    Jcy: "Й",
    Jsercy: "Ј",
    Jukcy: "Є",
    KHcy: "Х",
    KHgr: "Χ",
    KJcy: "Ќ",
    Kappa: "Κ",
    Kcedil: "Ķ",
    Kcy: "К",
    Kgr: "Κ",
    LJcy: "Љ",
    Lacute: "Ĺ",
    Lambda: "Λ",
    Larr: "↞",
    Lcaron: "Ľ",
    Lcedil: "Ļ",
    Lcy: "Л",
    Lgr: "Λ",
    Ll: "⋘",
    Lmidot: "Ŀ",
    Lstrok: "Ł",
    Lt: "≪",
    Mcy: "М",
    Mgr: "Μ",
    Mu: "Μ",
    NJcy: "Њ",
    Nacute: "Ń",
    Ncaron: "Ň",
    Ncedil: "Ņ",
    Ncy: "Н",
    Ngr: "Ν",
    Ntilde: "Ñ",
    Nu: "Ν",
    OElig: "Œ",
    OHacgr: "Ώ",
    OHgr: "Ω",
    Oacgr: "Ό",
    Oacute: "Ó",
    Ocirc: "Ô",
    Ocy: "О",
    Odblac: "Ő",
    Ogr: "Ο",
    Ograve: "Ò",
    Omacr: "Ō",
    Omega: "Ω",
    Omicron: "Ο",
    Oslash: "Ø",
    Otilde: "Õ",
    Ouml: "Ö",
    PHgr: "Φ",
    PSgr: "Ψ",
    Pcy: "П",
    Pgr: "Π",
    Phi: "Φ",
    Pi: "Π",
    Prime: "″",
    Psi: "Ψ",
    Racute: "Ŕ",
    Rarr: "↠",
    Rcaron: "Ř",
    Rcedil: "Ŗ",
    Rcy: "Р",
    Rgr: "Ρ",
    Rho: "Ρ",
    SHCHcy: "Щ",
    SHcy: "Ш",
    SOFTcy: "Ь",
    Sacute: "Ś",
    Scaron: "Š",
    Scedil: "Ş",
    Scirc: "Ŝ",
    Scy: "С",
    Sgr: "Σ",
    Sigma: "Σ",
    Sub: "⋐",
    Sup: "⋑",
    THORN: "Þ",
    THgr: "Θ",
    TSHcy: "Ћ",
    TScy: "Ц",
    Tau: "Τ",
    Tcaron: "Ť",
    Tcedil: "Ţ",
    Tcy: "Т",
    Tgr: "Τ",
    Theta: "Θ",
    Tstrok: "Ŧ",
    Uacgr: "Ύ",
    Uacute: "Ú",
    Ubrcy: "Ў",
    Ubreve: "Ŭ",
    Ucirc: "Û",
    Ucy: "У",
    Udblac: "Ű",
    Ugr: "Υ",
    Ugrave: "Ù",
    Umacr: "Ū",
    Uogon: "Ų",
    Upsi: "Υ",
    Upsilon: "Υ",
    Uring: "Ů",
    Utilde: "Ũ",
    Uuml: "Ü",
    Vcy: "В",
    Vdash: "⊩",
    Verbar: "‖",
    Vvdash: "⊪",
    Wcirc: "Ŵ",
    Xgr: "Ξ",
    Xi: "Ξ",
    YAcy: "Я",
    YIcy: "Ї",
    YUcy: "Ю",
    Yacute: "Ý",
    Ycirc: "Ŷ",
    Ycy: "Ы",
    Yuml: "Ÿ",
    ZHcy: "Ж",
    Zacute: "Ź",
    Zcaron: "Ž",
    Zcy: "З",
    Zdot: "Ż",
    Zeta: "Ζ",
    Zgr: "Ζ",
    aacgr: "ά",
    aacute: "á",
    abreve: "ă",
    acirc: "â",
    acute: "´",
    acy: "а",
    aelig: "æ",
    agr: "α",
    agrave: "à",
    alefsym: "ℵ",
    aleph: "ℵ",
    alpha: "α",
    amacr: "ā",
    amalg: "∐",
    amp: "&",
    and: "∧",
    ang: "∠",
    ang90: "∟",
    angmsd: "∡",
    angsph: "∢",
    angst: "Å",
    aogon: "ą",
    ap: "≈",
    ape: "≊",
    apos: "'",
    aposmod: "ʼ",
    aring: "å",
    ast: "*",
    asymp: "≈",
    atilde: "ã",
    auml: "ä",
    "b.Delta": "Δ",
    "b.Gamma": "Γ",
    "b.Lambda": "Λ",
    "b.Omega": "Ω",
    "b.Phi": "Φ",
    "b.Pi": "Π",
    "b.Psi": "Ψ",
    "b.Sigma": "Σ",
    "b.Theta": "Θ",
    "b.Upsi": "Υ",
    "b.Xi": "Ξ",
    "b.alpha": "α",
    "b.beta": "β",
    "b.chi": "χ",
    "b.delta": "δ",
    "b.epsi": "ε",
    "b.epsis": "ε",
    "b.epsiv": "ε",
    "b.eta": "η",
    "b.gamma": "γ",
    "b.gammad": "Ϝ",
    "b.iota": "ι",
    "b.kappa": "κ",
    "b.kappav": "ϰ",
    "b.lambda": "λ",
    "b.mu": "μ",
    "b.nu": "ν",
    "b.omega": "ώ",
    "b.phis": "φ",
    "b.phiv": "ϕ",
    "b.pi": "π",
    "b.piv": "ϖ",
    "b.psi": "ψ",
    "b.rho": "ρ",
    "b.rhov": "ϱ",
    "b.sigma": "σ",
    "b.sigmav": "ς",
    "b.tau": "τ",
    "b.thetas": "θ",
    "b.thetav": "ϑ",
    "b.upsi": "υ",
    "b.xi": "ξ",
    "b.zeta": "ζ",
    barwed: "⊼",
    bcong: "≌",
    bcy: "б",
    bdquo: "„",
    becaus: "∵",
    bepsi: "∍",
    bernou: "ℬ",
    beta: "β",
    beth: "ℶ",
    bgr: "β",
    blackstar: "✦",
    blank: "␣",
    blk12: "▒",
    blk14: "░",
    blk34: "▓",
    block: "█",
    bottom: "⊥",
    bowtie: "⋈",
    boxDL: "╗",
    boxDR: "╔",
    boxDl: "╖",
    boxDr: "╓",
    boxH: "═",
    boxHD: "╦",
    boxHU: "╩",
    boxHd: "╤",
    boxHu: "╧",
    boxUL: "╝",
    boxUR: "╚",
    boxUl: "╜",
    boxUr: "╙",
    boxV: "║",
    boxVH: "╬",
    boxVL: "╣",
    boxVR: "╠",
    boxVh: "╫",
    boxVl: "╢",
    boxVr: "╟",
    boxdL: "╕",
    boxdR: "╒",
    boxdl: "┐",
    boxdr: "┌",
    boxh: "─",
    boxhD: "╥",
    boxhU: "╨",
    boxhd: "┬",
    boxhu: "┴",
    boxuL: "╛",
    boxuR: "╘",
    boxul: "┘",
    boxur: "└",
    boxv: "│",
    boxvH: "╪",
    boxvL: "╡",
    boxvR: "╞",
    boxvh: "┼",
    boxvl: "┤",
    boxvr: "├",
    bprime: "‵",
    breve: "˘",
    brvbar: "¦",
    bsim: "∽",
    bsime: "⋍",
    bsol: "\\",
    bull: "•",
    bump: "≎",
    bumpe: "≏",
    cacute: "ć",
    cap: "∩",
    caret: "⁁",
    caron: "ˇ",
    ccaron: "č",
    ccedil: "ç",
    ccirc: "ĉ",
    cdot: "ċ",
    cedil: "¸",
    cent: "¢",
    chcy: "ч",
    check: "✓",
    chi: "χ",
    cir: "○",
    circ: "ˆ",
    cire: "≗",
    clubs: "♣",
    colon: ":",
    colone: "≔",
    comma: ",",
    commat: "@",
    comp: "∁",
    compfn: "∘",
    cong: "≅",
    conint: "∮",
    coprod: "∐",
    copy: "©",
    copysr: "℗",
    crarr: "↵",
    cross: "✗",
    cuepr: "⋞",
    cuesc: "⋟",
    cularr: "↶",
    cup: "∪",
    cupre: "≼",
    curarr: "↷",
    curren: "¤",
    cuvee: "⋎",
    cuwed: "⋏",
    dArr: "⇓",
    dagger: "†",
    daleth: "ℸ",
    darr: "↓",
    darr2: "⇊",
    dash: "‐",
    dashv: "⊣",
    dblac: "˝",
    dcaron: "ď",
    dcy: "д",
    deg: "°",
    delta: "δ",
    dgr: "δ",
    dharl: "⇃",
    dharr: "⇂",
    diam: "⋄",
    diams: "♦",
    die: "¨",
    divide: "÷",
    divonx: "⋇",
    djcy: "ђ",
    dlarr: "↙",
    dlcorn: "⌞",
    dlcrop: "⌍",
    dollar: "$",
    dot: "˙",
    drarr: "↘",
    drcorn: "⌟",
    drcrop: "⌌",
    dscy: "ѕ",
    dstrok: "đ",
    dtri: "▿",
    dtrif: "▾",
    dzcy: "џ",
    eDot: "≑",
    eacgr: "έ",
    eacute: "é",
    ecaron: "ě",
    ecir: "≖",
    ecirc: "ê",
    ecolon: "≕",
    ecy: "э",
    edot: "ė",
    eeacgr: "ή",
    eegr: "η",
    efDot: "≒",
    egr: "ε",
    egrave: "è",
    egs: "⋝",
    ell: "ℓ",
    els: "⋜",
    emacr: "ē",
    empty: "∅",
    emsp: " ",
    emsp13: " ",
    emsp14: " ",
    eng: "ŋ",
    ensp: " ",
    eogon: "ę",
    epsi: "ε",
    epsilon: "ε",
    epsis: "∊",
    epsiv: "ο",
    equals: "=",
    equiv: "≡",
    erDot: "≓",
    esdot: "≐",
    eta: "η",
    eth: "ð",
    euml: "ë",
    euro: "€",
    excl: "!",
    exist: "∃",
    fcy: "ф",
    female: "♀",
    ffilig: "ﬃ",
    fflig: "ﬀ",
    ffllig: "ﬄ",
    filig: "ﬁ",
    flat: "♭",
    fllig: "ﬂ",
    fnof: "ƒ",
    forall: "∀",
    fork: "⋔",
    frac12: "½",
    frac13: "⅓",
    frac14: "¼",
    frac15: "⅕",
    frac16: "⅙",
    frac18: "⅛",
    frac23: "⅔",
    frac25: "⅖",
    frac34: "¾",
    frac35: "⅗",
    frac38: "⅜",
    frac45: "⅘",
    frac56: "⅚",
    frac58: "⅝",
    frac78: "⅞",
    frasl: "⁄",
    frown: "⌢",
    gE: "≧",
    gEl: "⪌",
    gacute: "ǵ",
    gamma: "γ",
    gammad: "Ϝ",
    gap: "⪆",
    gbreve: "ğ",
    gcedil: "ģ",
    gcirc: "ĝ",
    gcy: "г",
    gdot: "ġ",
    ge: "≥",
    gel: "⋛",
    ges: "≥",
    ggr: "γ",
    gimel: "ℷ",
    gjcy: "ѓ",
    gl: "≷",
    gnE: "≩",
    gnap: "⪊",
    gne: "≩",
    gnsim: "⋧",
    grave: "`",
    gsdot: "⋗",
    gsim: "≳",
    gt: ">",
    gvnE: "≩",
    hArr: "⇔",
    hairsp: " ",
    half: "½",
    hamilt: "ℋ",
    hardcy: "ъ",
    harr: "↔",
    harrw: "↭",
    hcirc: "ĥ",
    hearts: "♥",
    hellip: "…",
    horbar: "―",
    hstrok: "ħ",
    hybull: "⁃",
    hyphen: "-",
    iacgr: "ί",
    iacute: "í",
    icirc: "î",
    icy: "и",
    idiagr: "ΐ",
    idigr: "ϊ",
    iecy: "е",
    iexcl: "¡",
    iff: "⇔",
    igr: "ι",
    igrave: "ì",
    ijlig: "ĳ",
    imacr: "ī",
    image: "ℑ",
    incare: "℅",
    infin: "∞",
    inodot: "ı",
    "int": "∫",
    intcal: "⊺",
    iocy: "ё",
    iogon: "į",
    iota: "ι",
    iquest: "¿",
    isin: "∈",
    itilde: "ĩ",
    iukcy: "і",
    iuml: "ï",
    jcirc: "ĵ",
    jcy: "й",
    jsercy: "ј",
    jukcy: "є",
    kappa: "κ",
    kappav: "ϰ",
    kcedil: "ķ",
    kcy: "к",
    kgr: "κ",
    kgreen: "ĸ",
    khcy: "х",
    khgr: "χ",
    kjcy: "ќ",
    lAarr: "⇚",
    lArr: "⇐",
    lE: "≦",
    lEg: "⪋",
    lacute: "ĺ",
    lagran: "ℒ",
    lambda: "λ",
    lang: "〈",
    lap: "⪅",
    laquo: "«",
    larr: "←",
    larr2: "⇇",
    larrhk: "↩",
    larrlp: "↫",
    larrtl: "↢",
    lcaron: "ľ",
    lcedil: "ļ",
    lceil: "⌈",
    lcub: "{",
    lcy: "л",
    ldot: "⋖",
    ldquo: "“",
    ldquor: "„",
    le: "≤",
    leg: "⋚",
    les: "≤",
    lfloor: "⌊",
    lg: "≶",
    lgr: "λ",
    lhard: "↽",
    lharu: "↼",
    lhblk: "▄",
    ljcy: "љ",
    lmidot: "ŀ",
    lnE: "≨",
    lnap: "⪉",
    lne: "≨",
    lnsim: "⋦",
    lowast: "∗",
    lowbar: "_",
    loz: "◊",
    lozf: "✦",
    lpar: "(",
    lrarr2: "⇆",
    lrhar2: "⇋",
    lrm: "‎",
    lsaquo: "‹",
    lsh: "↰",
    lsim: "≲",
    lsqb: "[",
    lsquo: "‘",
    lsquor: "‚",
    lstrok: "ł",
    lt: "<",
    lthree: "⋋",
    ltimes: "⋉",
    ltri: "◃",
    ltrie: "⊴",
    ltrif: "◂",
    lvnE: "≨",
    macr: "¯",
    male: "♂",
    malt: "✠",
    map: "↦",
    marker: "▮",
    mcy: "м",
    mdash: "—",
    mgr: "μ",
    micro: "µ",
    mid: "∣",
    middot: "·",
    minus: "−",
    minusb: "⊟",
    mldr: "…",
    mnplus: "∓",
    models: "⊧",
    mu: "μ",
    mumap: "⊸",
    nVDash: "⊯",
    nVdash: "⊮",
    nabla: "∇",
    nacute: "ń",
    nap: "≉",
    napos: "ŉ",
    natur: "♮",
    nbsp: " ",
    ncaron: "ň",
    ncedil: "ņ",
    ncong: "≇",
    ncy: "н",
    ndash: "–",
    ne: "≠",
    nearr: "↗",
    nequiv: "≢",
    nexist: "∄",
    nge: "≱",
    nges: "≱",
    ngr: "ν",
    ngt: "≯",
    nhArr: "⇎",
    nharr: "↮",
    ni: "∋",
    njcy: "њ",
    nlArr: "⇍",
    nlarr: "↚",
    nldr: "‥",
    nle: "≰",
    nles: "≰",
    nlt: "≮",
    nltri: "⋪",
    nltrie: "⋬",
    nmid: "∤",
    not: "¬",
    notin: "∉",
    npar: "∦",
    npr: "⊀",
    npre: "⋠",
    nrArr: "⇏",
    nrarr: "↛",
    nrtri: "⋫",
    nrtrie: "⋭",
    nsc: "⊁",
    nsce: "⋡",
    nsim: "≁",
    nsime: "≄",
    nsmid: "∤",
    nspar: "∦",
    nsub: "⊄",
    nsubE: "⊈",
    nsube: "⊈",
    nsup: "⊅",
    nsupE: "⊉",
    nsupe: "⊉",
    ntilde: "ñ",
    nu: "ν",
    num: "#",
    numero: "№",
    numsp: " ",
    nvDash: "⊭",
    nvdash: "⊬",
    oS: "Ⓢ",
    oacgr: "ό",
    oacute: "ó",
    oast: "⊛",
    ocir: "⊚",
    ocirc: "ô",
    ocy: "о",
    odash: "⊝",
    odblac: "ő",
    odot: "⊙",
    oelig: "œ",
    ogon: "˛",
    ogr: "ο",
    ograve: "ò",
    ohacgr: "ώ",
    ohgr: "ω",
    ohm: "Ω",
    olarr: "↺",
    oline: "‾",
    omacr: "ō",
    omega: "ω",
    omicron: "ο",
    ominus: "⊖",
    oplus: "⊕",
    or: "∨",
    orarr: "↻",
    order: "ℴ",
    ordf: "ª",
    ordm: "º",
    oslash: "ø",
    osol: "⊘",
    otilde: "õ",
    otimes: "⊗",
    ouml: "ö",
    par: "∥",
    para: "¶",
    part: "∂",
    pcy: "п",
    percnt: "%",
    period: ".",
    permil: "‰",
    perp: "⊥",
    pgr: "π",
    phgr: "φ",
    phi: "φ",
    phis: "φ",
    phiv: "ϕ",
    phmmat: "ℳ",
    phone: "☎",
    pi: "π",
    piv: "ϖ",
    planck: "ℏ",
    plus: "+",
    plusb: "⊞",
    plusdo: "∔",
    plusmn: "±",
    pound: "£",
    pr: "≺",
    prap: "⪷",
    pre: "≼",
    prime: "′",
    prnE: "⪵",
    prnap: "⪹",
    prnsim: "⋨",
    prod: "∏",
    prop: "∝",
    prsim: "≾",
    psgr: "ψ",
    psi: "ψ",
    puncsp: " ",
    quest: "?",
    quot: '"',
    rAarr: "⇛",
    rArr: "⇒",
    racute: "ŕ",
    radic: "√",
    rang: "〉",
    raquo: "»",
    rarr: "→",
    rarr2: "⇉",
    rarrhk: "↪",
    rarrlp: "↬",
    rarrtl: "↣",
    rarrw: "↝",
    rcaron: "ř",
    rcedil: "ŗ",
    rceil: "⌉",
    rcub: "}",
    rcy: "р",
    rdquo: "”",
    rdquor: "“",
    real: "ℜ",
    rect: "▭",
    reg: "®",
    rfloor: "⌋",
    rgr: "ρ",
    rhard: "⇁",
    rharu: "⇀",
    rho: "ρ",
    rhov: "ϱ",
    ring: "˚",
    rlarr2: "⇄",
    rlhar2: "⇌",
    rlm: "‏",
    rpar: ")",
    rpargt: "⦔",
    rsaquo: "›",
    rsh: "↱",
    rsqb: "]",
    rsquo: "’",
    rsquor: "‘",
    rthree: "⋌",
    rtimes: "⋊",
    rtri: "▹",
    rtrie: "⊵",
    rtrif: "▸",
    rx: "℞",
    sacute: "ś",
    samalg: "∐",
    sbquo: "‚",
    sbsol: "\\",
    sc: "≻",
    scap: "⪸",
    scaron: "š",
    sccue: "≽",
    sce: "≽",
    scedil: "ş",
    scirc: "ŝ",
    scnE: "⪶",
    scnap: "⪺",
    scnsim: "⋩",
    scsim: "≿",
    scy: "с",
    sdot: "⋅",
    sdotb: "⊡",
    sect: "§",
    semi: ";",
    setmn: "∖",
    sext: "✶",
    sfgr: "ς",
    sfrown: "⌢",
    sgr: "σ",
    sharp: "♯",
    shchcy: "щ",
    shcy: "ш",
    shy: "­",
    sigma: "σ",
    sigmaf: "ς",
    sigmav: "ς",
    sim: "∼",
    sime: "≃",
    smid: "∣",
    smile: "⌣",
    softcy: "ь",
    sol: "/",
    spades: "♠",
    spar: "∥",
    sqcap: "⊓",
    sqcup: "⊔",
    sqsub: "⊏",
    sqsube: "⊑",
    sqsup: "⊐",
    sqsupe: "⊒",
    squ: "□",
    square: "□",
    squf: "▪",
    ssetmn: "∖",
    ssmile: "⌣",
    sstarf: "⋆",
    star: "☆",
    starf: "★",
    sub: "⊂",
    subE: "⊆",
    sube: "⊆",
    subnE: "⊊",
    subne: "⊊",
    sum: "∑",
    sung: "♪",
    sup: "⊃",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    supE: "⊇",
    supe: "⊇",
    supnE: "⊋",
    supne: "⊋",
    szlig: "ß",
    target: "⌖",
    tau: "τ",
    tcaron: "ť",
    tcedil: "ţ",
    tcy: "т",
    tdot: "⃛",
    telrec: "⌕",
    tgr: "τ",
    there4: "∴",
    theta: "θ",
    thetas: "θ",
    thetasym: "ϑ",
    thetav: "ϑ",
    thgr: "θ",
    thinsp: " ",
    thkap: "≈",
    thksim: "∼",
    thorn: "þ",
    tilde: "˜",
    times: "×",
    timesb: "⊠",
    top: "⊤",
    tprime: "‴",
    trade: "™",
    trie: "≜",
    tscy: "ц",
    tshcy: "ћ",
    tstrok: "ŧ",
    twixt: "≬",
    uArr: "⇑",
    uacgr: "ύ",
    uacute: "ú",
    uarr: "↑",
    uarr2: "⇈",
    ubrcy: "ў",
    ubreve: "ŭ",
    ucirc: "û",
    ucy: "у",
    udblac: "ű",
    udiagr: "ΰ",
    udigr: "ϋ",
    ugr: "υ",
    ugrave: "ù",
    uharl: "↿",
    uharr: "↾",
    uhblk: "▀",
    ulcorn: "⌜",
    ulcrop: "⌏",
    umacr: "ū",
    uml: "¨",
    uogon: "ų",
    uplus: "⊎",
    upsi: "υ",
    upsih: "ϒ",
    upsilon: "υ",
    urcorn: "⌝",
    urcrop: "⌎",
    uring: "ů",
    utilde: "ũ",
    utri: "▵",
    utrif: "▴",
    uuml: "ü",
    vArr: "⇕",
    vDash: "⊨",
    varr: "↕",
    vcy: "в",
    vdash: "⊢",
    veebar: "⊻",
    vellip: "⋮",
    verbar: "|",
    vltri: "⊲",
    vprime: "′",
    vprop: "∝",
    vrtri: "⊳",
    vsubnE: "⊊",
    vsubne: "⊊",
    vsupnE: "⊋",
    vsupne: "⊋",
    wcirc: "ŵ",
    wedgeq: "≙",
    weierp: "℘",
    whitestar: "✧",
    wreath: "≀",
    xcirc: "○",
    xdtri: "▽",
    xgr: "ξ",
    xhArr: "↔",
    xharr: "↔",
    xi: "ξ",
    xlArr: "⇐",
    xrArr: "⇒",
    xutri: "△",
    yacute: "ý",
    yacy: "я",
    ycirc: "ŷ",
    ycy: "ы",
    yen: "¥",
    yicy: "ї",
    yucy: "ю",
    yuml: "ÿ",
    zacute: "ź",
    zcaron: "ž",
    zcy: "з",
    zdot: "ż",
    zeta: "ζ",
    zgr: "ζ",
    zhcy: "ж",
    zwj: "‍",
    zwnj: "‌"
}, fdjt.String = function() {
    "use strict";
    function fdjtString(string) {
        if ("string" != typeof string && !(string instanceof String)) return stringify(string);
        for (var arg, output = "", cmd = string.indexOf("%"), i = 1; cmd >= 0; ) {
            if (cmd > 0 && (output += string.slice(0, cmd)), "%" === string[cmd + 1]) output += "%"; else if ("o" === string[cmd + 1]) if (arg = arguments[i++], 
            "string" == typeof arg) output = output + "'" + arg + "'"; else if ("number" == typeof arg) output += arg; else if (Array.isArray(arg)) {
                var j = 0, len = arg.length;
                for (output += "["; len > j; ) output = output + (j > 0 ? "," : "") + stringify(arg[j++]);
                output += "]";
            } else output += stringify(arg); else if ("j" === string[cmd + 1]) if (arg = arguments[i++], 
            Array.isArray(arg)) {
                var k = 0, lim = arg.length;
                for (output += "["; lim > k; ) output = output + (k > 0 ? "," : "") + JSON.stringify(arg[k++]);
            } else if ("object" == typeof arg) {
                var objstr = !1;
                try {
                    objstr = JSON.stringify(arg);
                } catch (ex1) {
                    var norm = {};
                    for (var p in arg) if (arg.hasOwnProperty(p)) {
                        var nv, pv = arg[p];
                        if (Array.isArray(pv)) {
                            nv = [];
                            for (var ei = 0, elim = pv.length; elim > ei; ) {
                                var sv, e = pv[ei++];
                                try {
                                    sv = fdjtString(e);
                                } catch (ex2) {
                                    sv = "" + e;
                                }
                                nv.push(sv);
                            }
                        } else try {
                            nv = fdjtString(pv);
                        } catch (ex) {
                            nv = "" + pv;
                        }
                        norm[p] = nv;
                    }
                    objstr = JSON.stringify(norm);
                }
                output += objstr;
            } else output += JSON.stringify(arg); else "x" === string[cmd + 1] && "number" == typeof arguments[i] && arguments[i] >= 0 && arguments[i] % 1 >= 0 ? (arg = arguments[i++], 
            output += arg.toString(16)) : arguments[i] ? output += arguments[i++] : arguments[i] === void 0 ? (output += "?undef?", 
            i++) : output += arguments[i++];
            string = string.slice(cmd + 2), cmd = string.indexOf("%");
        }
        return output += string;
    }
    function stringify(arg) {
        if (arg === void 0) return "?undef?";
        if (arg) {
            if ("number" == typeof arg) return "" + arg;
            if (arg.tagName) {
                var output = "[" + arg.tagName;
                arg.className && (output = output + "." + arg.className.replace(/\s+/g, ".")), arg.id && (output = output + "#" + arg.id), 
                arg.name && (output = output + "[name=" + arg.name + "]");
                var txt = arg.innerText ? arg.innerText.trim() : stripMarkup(arg.innerHTML).trim();
                return txt && 0 !== txt.length && (output = 32 > txt.length ? output + "'" + txt.replace(/\n/g, "\\n") + "'" : output + "'" + txt.slice(0, 16).replace(/\n/g, "\\n") + "'..."), 
                output + "]";
            }
            if (arg.nodeType) return 3 === arg.nodeType ? '["' + arg.nodeValue + '"]' : "<" + arg.nodeType + ">";
            if (arg.oid) return arg.oid;
            if (arg._fdjtid) return "#@" + arg._fdjtid;
            if (arg.type && (arg.target || arg.srcElement)) {
                var target = arg.target || arg.srcElement;
                return "[" + arg.type + "@" + stringify(target) + ((arg.target || arg.srcElement).nodeType ? getDOMEventInfo(arg) : "") + "]";
            }
            return "" + arg;
        }
        return arg;
    }
    function getDOMEventInfo(arg) {
        var info = "(m=" + (arg.shiftKey === !0 ? "s" : "") + (arg.ctrlKey === !0 ? "c" : "") + (arg.metaKey === !0 ? "m" : "") + (arg.altKey === !0 ? "a" : "") + (arg.button !== void 0 ? ",b=" + arg.button : "") + (arg.which !== void 0 ? ",w=" + arg.which : ""), ox = arg.clientX, oy = arg.clientY;
        return ("number" == typeof ox || "number" == typeof oy) && (info = info + ",cx=" + ox + ",cy=" + oy), 
        arg.touches && (info = info + ",touches=" + arg.touches.length), arg.keyCode && (info = info + ",kc=" + arg.keyCode), 
        arg.charCode && (info = info + ",cc=" + arg.charCode), info + ")";
    }
    function ellipsize(string, lim, fudge) {
        var before, after, chopped, broke;
        if ("number" != typeof fudge && (fudge = .1), !lim) return string;
        if ("number" == typeof lim) ; else {
            if (lim.constructor !== Array) return string;
            before = lim[0] || 0, after = lim[1] || 0, lim = after + before;
        }
        if (lim) {
            if (lim + floor(fudge * lim) > string.length) return string;
            if (before && after) {
                var start, end, len = string.length;
                return 0 === /\s/.test(string[before]) ? start = before : (chopped = string.slice(0, before), 
                broke = chopped.search(/\s+\w+$/), start = broke > 0 ? broke : before), 0 === /\s/.test(string[len - after]) ? end = len - after : (chopped = string.slice(len - after), 
                broke = chopped.search(/\s+/), end = broke > 0 ? len - after + broke : after), [ string.slice(0, start), string.slice(end) ];
            }
            var edge = string[lim];
            return 0 === /\s/.test(edge) ? string.slice(0, lim) : (chopped = string.slice(0, lim), 
            broke = chopped.search(/\s+\w+$/), broke > 0 ? chopped.slice(0, broke) : chopped);
        }
        return string;
    }
    function isEmpty(string) {
        if ("string" == typeof string) {
            var pt;
            return 0 === string.length ? !0 : (pt = string.search(notspace), 0 > pt ? !0 : "&" !== string[pt] ? !1 : (string = string.replace(/&nbsp;/g, " "), 
            pt = string.search(notspace), 0 > pt));
        }
        return !1;
    }
    function trim(string) {
        var start = 0, len = string.length;
        if (0 >= len) return string;
        for (;len > start && spacechars.indexOf(string.charAt(start)) > -1; ) start++;
        if (start === len) return "";
        for (var end = len - 1; end > start && spacechars.indexOf(string.charAt(end)) > -1; ) end--;
        return start > 0 || len > end ? string.slice(start, end + 1) : string;
    }
    function stdspace(string) {
        string = string.replace(/\s+/g, " ");
        var start = 0, len = string.length;
        if (0 >= len) return string;
        for (;len > start && spacechars.indexOf(string.charAt(start)) > -1; ) start++;
        if (start === len) return "";
        for (var end = len - 1; end > start && spacechars.indexOf(string.charAt(end)) > -1; ) end--;
        return start > 0 || len > end ? string.slice(start, end + 1) : string;
    }
    function stdcap(string) {
        var somecaps = string.search(/(^|\s)[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/g) >= 0;
        if (!somecaps) return string.replace(/\s+/g, " ").replace(/(^ | $)/g, "");
        for (var words = string.split(/\s+/g), i = 0, lim = words.length; lim > i; ) {
            var word = words[i], weird = word.slice(1).search(/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/) >= 0;
            weird || (words[i] = word[0].toUpperCase() + word.slice(1)), i++;
        }
        return words.join(" ");
    }
    function flatten(string) {
        return string.replace(/\s+/g, " ");
    }
    function oneline(string) {
        string = trim(string);
        var flat = string.replace(/\s*[\f\n\r]+\s+/gm, " //· ").replace(/\s*[\f\n\r]+\s*/gm, " // "), tight = flat.replace(/\s\s+/g, "");
        return tight;
    }
    function stripMarkup(string) {
        return string.replace(/<[^>]*>/g, "");
    }
    function unEscape(string) {
        return string.indexOf("\\") >= 0 ? string.replace(/\\(.)/g, "$1") : string;
    }
    function normstring(string) {
        return string.replace(/\W*\s\W*/g, " ").toLowerCase();
    }
    function dCharCode(whole, paren) {
        return String.fromCharCode(parseInt(paren, 10));
    }
    function xCharCode(whole, paren) {
        return String.fromCharCode(parseInt(paren, 16));
    }
    function nCharCode(whole, paren) {
        return fdjt.charnames[paren] || "&" + paren + ";";
    }
    function expandEntity(whole, paren) {
        return entities.hasOwnProperty(paren) ? entities[paren] : "&" + paren + ";";
    }
    function decodeEntities(string) {
        return string.replace(/&#(\d+);/g, dCharCode).replace(/&#x([0123456789ABCDEFabcdef]+);/g, xCharCode).replace(/&([abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.]+)/g, nCharCode).replace(/&([A-Za-z][A-Za-z0-9-_.]+;)/g, expandEntity);
    }
    function expandEntities(string) {
        return string.replace(/&([A-Za-z][A-Za-z0-9-_.]+);/g, expandEntity);
    }
    function getMatch(string, rx, i, literal) {
        var match = rx.exec(string);
        return i === void 0 && (i = 0), match && match.length > i ? literal ? match[i] : numpat.test(match[i]) ? parseFloat(match[i]) : match[i] : !1;
    }
    function segment(string, brk, start, keepspace) {
        start && (string = string.slice(start));
        for (var brk_source = "string" == typeof brk ? brk : brk.source, brk_flags = "string" == typeof brk ? "" : brk.ignoreCase ? "i" : "", brkpat = RegExp("(" + brk_source + ")", brk_flags), results = [], segs = string.split(brkpat), i = 0, lim = segs.length, merged = !1; lim > i; ) {
            var seg = segs[i++], sep = segs[i++];
            if (seg && !(0 > seg.search(/\S/))) if (seg.length && "\\" === seg.slice(-1) && (2 > seg.length || "\\" !== seg.slice(-2, -1))) {
                var unescaped = seg.slice(0, -1) + sep;
                merged ? merged += unescaped : merged = unescaped;
            } else merged ? (keepspace ? results.push(merged + seg) : results.push(stdspace(merged + seg)), 
            merged = !1) : keepspace ? results.push(seg) : results.push(stdspace(seg));
        }
        return results;
    }
    function padNum(num, digits, prec) {
        var ndigits = 10 > num ? 1 : 100 > num ? 2 : 1e3 > num ? 3 : 1e4 > num ? 4 : 1e5 > num ? 5 : 1e6 > num ? 6 : 1e6 > num ? 7 : 1e8 > num ? 8 : 1e9 > num ? 9 : 1e10 > num ? 10 : 11;
        !prec && 0 > digits && (prec = -digits, digits = 0);
        var j, nzeroes = digits - ndigits, numstring = "" + num, point = numstring.indexOf("."), prefix = "", suffix = "";
        if (prec) if (point >= 0 && numstring.length > point + prec) numstring = numstring.slice(0, point + prec + 1); else if (0 > point || point + prec + 1 > numstring.length) {
            j = 0;
            var pad = point + prec + 1 - numstring.length;
            for (0 > point && (suffix += "."); pad > j; ) suffix += "0", j++;
        }
        switch (nzeroes) {
          case 0:
            prefix = "";
            break;

          case 1:
            prefix = "0";
            break;

          case 2:
            prefix = "00";
            break;

          case 3:
            prefix = "000";
            break;

          case 4:
            prefix = "0000";
            break;

          case 5:
            prefix = "00000";
            break;

          case 6:
            prefix = "000000";
            break;

          case 7:
            prefix = "0000000";
            break;

          case 8:
            prefix = "00000000";
            break;

          case 9:
            prefix = "000000000";
            break;

          case 10:
            prefix = "0000000000";
            break;

          default:
            for (j = 0; nzeroes > j; ) prefix += "0", j++;
        }
        return prefix + numstring + suffix;
    }
    function precString(num, prec) {
        var numstring = "" + num, suffix = "";
        if ("number" == typeof prec && prec >= 0 && 100 > prec) {
            var point = numstring.indexOf(".");
            if (point >= 0 && numstring.length > point + prec) numstring = numstring.slice(0, point + prec + 1); else if (0 > point || point + prec + 1 > numstring.length) {
                var j = 0, pad = point + prec + 1 - numstring.length;
                for (0 > point && (suffix = "."); pad >= j; ) suffix += "0", j++;
            }
        }
        return numstring + suffix;
    }
    function getInitials(string, n) {
        for (var words = string.split(/\W/), initials = "", i = 0, lim = n && words.length > n ? n : words.length; lim > i; ) {
            var word = words[i++];
            word.length && (initials += word.slice(0, 1));
        }
        return initials;
    }
    function hasPrefix(string, prefix) {
        return 0 === string.indexOf(prefix);
    }
    function hasSuffix(string, suffix) {
        return string.lastIndexOf(suffix) === string.length - suffix.length;
    }
    function commonPrefix(string1, string2, brk, foldcase) {
        for (var i = 0, last = -1; string1.length > i && string2.length > i && (string1[i] === string2[i] || foldcase && string1[i].toLowerCase() === string2[i].toLowerCase()); ) brk ? brk === string1[i] ? (last = i - 1, 
        i++) : i++ : last = i++;
        return last >= 0 ? string1.slice(0, last + 1) : !1;
    }
    function commonSuffix(string1, string2, brk, foldcase) {
        for (var i = string1.length, j = string2.length, last = 0; i >= 0 && j >= 0 && (string1[i] === string2[j] || foldcase && string1[i].toLowerCase() === string2[i].toLowerCase()); ) brk ? brk === string1[i] ? (last = i + 1, 
        i--, j--) : (i--, j--) : (last = i, i--, j--);
        return last > 0 ? string1.slice(last) : !1;
    }
    function stripSuffix(string) {
        var start = string.search(/\.\w+$/);
        return start > 0 ? string.slice(0, start) : string;
    }
    function arrayContains(array, element) {
        if (array.indexOf) return array.indexOf(element) >= 0;
        for (var i = 0, len = array.length; len > i; ) {
            if (array[i] === element) return !0;
            i++;
        }
        return !1;
    }
    function add_prefix(ptree, string, i) {
        var strings = ptree.strings;
        if (i === string.length) return (strings.indexOf ? strings.indexOf(string) >= 0 : arrayContains(strings, string)) ? !1 : (strings.push(string), 
        !0);
        if (ptree.splits) {
            var splitchar = string[i], split = ptree[splitchar];
            return split || (split = {}, split.strings = [], split.splitchar = splitchar, ptree[splitchar] = split, 
            ptree.splits.push(split)), add_prefix(split, string, i + 1) ? (strings.push(string), 
            !0) : !1;
        }
        if (5 > ptree.strings.length) return (strings.indexOf ? strings.indexOf(string) >= 0 : arrayContains(strings, string)) ? !1 : (strings.push(string), 
        !0);
        ptree.splits = [];
        for (var pstrings = ptree.strings, j = 0; pstrings.length > j; ) add_prefix(ptree, pstrings[j++], i);
        return add_prefix(ptree, string, i);
    }
    function prefixAdd(ptree, string, i) {
        return ("number" != typeof i || 0 > i) && (i = 0), add_prefix(ptree, string, i);
    }
    function find_prefix(ptree, prefix, i, plen) {
        if (plen || (plen = prefix.length), i === plen) return ptree.strings;
        if (5 >= ptree.strings.length) {
            for (var strings = ptree.strings, results = [], j = 0; strings.length > j; ) {
                var string = strings[j++];
                hasPrefix(string, prefix) && results.push(string);
            }
            return results.length ? results : !1;
        }
        var split = ptree[prefix[i]];
        return split ? find_prefix(split, prefix, i + 1, plen) : !1;
    }
    function prefixFind(ptree, prefix, i, plen) {
        return ("number" != typeof i || 0 > i) && (i = 0), plen || (plen = prefix.length), 
        find_prefix(ptree, prefix, i, plen);
    }
    function paraHash(node) {
        var text = "string" == typeof node.innerText ? node.innerText : stripMarkup(node.innerHTML), words = text.split(/\W*\S+\W*/g), len = words.length;
        return "_H" + (len > 0 ? words[0][0] : ".") + (len > 1 ? words[1][0] : ".") + (len > 2 ? words[2][0] : ".") + (len > 3 ? words[3][0] : ".") + (len > 0 ? words[len - 1][0] : ".") + (len > 1 ? words[len - 2][0] : ".") + (len > 2 ? words[len - 3][0] : ".") + (len > 3 ? words[len - 4][0] : ".");
    }
    function escapeRegExp(str) {
        return (str + "").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    function fillIn(text, data) {
        var dom = !1;
        if ("string" == typeof data) {
            var tmp = data;
            data = text, text = tmp;
        }
        if (!text && data && data.template ? text = data.template : !data && text.template && (data = text, 
        text = data.template), "string" == typeof text) ; else if (3 === text.nodeType) dom = text, 
        text = dom.nodeValue; else {
            if (1 !== text.nodeType) return fdjt.Log.warn("Bad argument %o to Template", text), 
            void 0;
            dom = text, text = dom.innerHTML;
        }
        var substs = text.match(/\{\{\w+(\|([^\}])*)?\}\}/gm), done = {};
        if (substs && substs.length) for (var i = 0, n = substs.length; n > i; ) {
            var match = substs[i++], prop = match.slice(2, -2), bar = prop.search(/\|/), propname = bar >= 0 ? prop.slice(0, bar) : prop;
            if (!done[prop] && !done[propname]) if (data.hasOwnProperty(propname)) {
                var val = data[propname];
                if (done[propname] = prop, val) {
                    var pat = RegExp("\\{\\{" + propname + "(\\|[^\\}]*)?\\}\\}", "gm"), stringval = "" + val;
                    text = text.replace(pat, stringval);
                }
            } else if (bar > 0) {
                var replace = prop.slice(bar + 1);
                text = text.replace("{{" + prop + "}}", replace), done[prop] = prop;
            } else fdjt.Log.warn("No data for %s in %j to substitute for %s", propname, data, "{{" + prop + "}}");
        }
        return dom ? (3 === dom.nodeType ? dom.nodeValue = text : dom.innerHTML = text, 
        dom) : text;
    }
    var notspace = /[^ \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff]/g;
    fdjtString.nbsp = " ", fdjtString.middot = "·", fdjtString.emdash = "–", fdjtString.endash = "—", 
    fdjtString.lsq = "‘", fdjtString.rsq = "’", fdjtString.ldq = "“", fdjtString.rdq = "”";
    var spacechars = " \n\r	\f  ᠎           ​\u2028\u2029  　";
    fdjtString.truncate = function(string, lim) {
        return lim || (lim = 42), lim > string.length ? string : string.slice(0, lim);
    };
    var floor = Math.floor;
    fdjtString.ellipsize = ellipsize, fdjtString.isEmpty = isEmpty, fdjtString.findSplit = function(string, split, escape) {
        for (var next, start = 0; (next = string.indexOf(split, start)) >= 0; ) {
            if (!(escape && next > 0 && string[next - 1] === escape)) return next;
            start = next + 1;
        }
        return -1;
    }, fdjtString.split = function(string, split, escape, mapfn) {
        if (mapfn || escape) {
            for (var next, results = [], start = 0; (next = string.indexOf(split, start)) >= 0; ) escape && next > 0 && string[next - 1] === escape ? start = next + 1 : mapfn && next > start ? (results.push(mapfn(string.slice(start, next))), 
            start = next + 1) : next > start ? (results.push(string.slice(start, next)), start = next + 1) : start = next + 1;
            return string.length > start && (mapfn ? results.push(mapfn(string.slice(start))) : results.push(string.slice(start))), 
            results;
        }
        return string.split(split);
    }, fdjtString.semiSplit = function(string, escape, mapfn) {
        if (mapfn || escape) {
            for (var next, results = [], start = 0; (next = string.indexOf(";", start)) >= 0; ) escape && next > 0 && string[next - 1] === escape ? start = next + 1 : mapfn && next > start ? (results.push(mapfn(string.slice(start, next))), 
            start = next + 1) : next > start ? (results.push(string.slice(start, next)), start = next + 1) : start = next + 1;
            return string.length > start && (mapfn ? results.push(mapfn(string.slice(start))) : results.push(string.slice(start))), 
            results;
        }
        return string.split(";");
    }, fdjtString.lineSplit = function(string, escape, mapfn) {
        if (mapfn || escape) {
            for (var next, results = [], start = 0; (next = string.indexOf("\n", start)) >= 0; ) escape && next > 0 && string[next - 1] === escape ? start = next + 1 : mapfn && next > start ? (results.push(mapfn(string.slice(start, next))), 
            start = next + 1) : next > start ? (results.push(string.slice(start, next)), start = next + 1) : start = next + 1;
            return string.length > start && (mapfn ? results.push(mapfn(string.slice(start))) : results.push(string.slice(start))), 
            results;
        }
        return string.split("\n");
    }, fdjtString.trim = trim, fdjtString.stdspace = stdspace, fdjtString.stdcap = stdcap, 
    fdjtString.flatten = flatten, fdjtString.oneline = oneline, fdjtString.stripMarkup = stripMarkup, 
    fdjtString.unEscape = unEscape, fdjtString.normString = normstring;
    var entities = {};
    fdjtString.entities = entities, fdjtString.decodeEntities = decodeEntities, fdjtString.expandEntities = expandEntities;
    var numpat = /^\d+(\.\d+)$/;
    return fdjtString.getMatch = getMatch, fdjtString.segment = segment, fdjtString.padNum = padNum, 
    fdjtString.precString = precString, fdjtString.getInitials = getInitials, fdjtString.hasPrefix = hasPrefix, 
    fdjtString.hasSuffix = hasSuffix, fdjtString.commonPrefix = commonPrefix, fdjtString.commonSuffix = commonSuffix, 
    fdjtString.stripSuffix = stripSuffix, fdjtString.prefixAdd = prefixAdd, fdjtString.prefixFind = prefixFind, 
    fdjtString.paraHash = paraHash, fdjtString.escapeRegExp = escapeRegExp, fdjtString.escapeRX = escapeRegExp, 
    fdjtString.templates = {}, fdjtString.fillIn = fillIn, fdjtString;
}(), fdjt.Time = function() {
    "use strict";
    function _(x) {
        return x;
    }
    function fdjtTime() {
        return new Date().getTime();
    }
    function shortString(tstamp) {
        var now = new Date();
        "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp));
        var diff = (now.getTime() - tstamp.getTime()) / 1e3;
        if (diff > 43200) return tstamp.toDateString();
        var hours = tstamp.getHours(), minutes = tstamp.getMinutes();
        return tstamp.toDateString() + " (" + (10 > hours ? "0" : "") + hours + ":" + (0 === minutes ? "00" : (10 > minutes ? "0" : "") + minutes) + ")";
    }
    function compactString(tstamp, curdate) {
        "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp));
        var date_string = tstamp.toLocaleDateString();
        curdate === void 0 && (first_date ? curdate = first_date : first_date = new Date().toLocaleDateString());
        var show_date = date_string !== curdate, hours = tstamp.getHours(), minutes = tstamp.getMinutes(), seconds = tstamp.getSeconds();
        return (show_date ? date_string : "") + (show_date ? " - " : "") + (10 > hours ? "0" : "") + hours + ":" + (0 === minutes ? "00" : (10 > minutes ? "0" : "") + minutes) + ":" + (0 === seconds ? "00" : (10 > seconds ? "0" : "") + seconds);
    }
    var loaded = fdjtTime.loaded = new Date().getTime();
    fdjtTime.tick = function() {
        return Math.floor(new Date().getTime() / 1e3);
    }, fdjtTime.dateString = function(tstamp) {
        return "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp)), 
        tstamp.toDateString();
    }, fdjtTime.timeString = function(tstamp) {
        return "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp)), 
        "" + tstamp;
    }, fdjtTime.shortString = shortString, fdjtTime.tick2shortstring = function(tick) {
        return shortString(new Date(1e3 * tick));
    };
    var first_date = !1;
    fdjtTime.compactString = compactString, fdjtTime.tick2string = function(tick) {
        return "" + new Date(1e3 * tick);
    }, fdjtTime.tick2date = function(tick) {
        return new Date(1e3 * tick).toDateString();
    }, fdjtTime.tick2locale = function(tick) {
        return new Date(1e3 * tick).toLocaleString();
    }, fdjtTime.tick2time = function(tick) {
        return new Date(1e3 * tick).toTimeString();
    };
    var fmt = fdjt.String;
    fdjtTime.secs2string = function(interval) {
        var weeks, days, hours, minutes, seconds;
        return 1 > interval ? fmt("%f seconds", interval) : 1 === interval ? fmt("%f second", interval) : 10 > interval ? fmt("%f seconds", interval) : 60 > interval ? fmt("~%d seconds", Math.round(interval / 60)) : 120 > interval ? (minutes = Math.floor(interval / 60), 
        seconds = Math.round(interval - 60 * minutes), 1 === seconds ? _("one minute, one second") : fmt("one minute, %d seconds", seconds)) : 3600 > interval ? (minutes = Math.floor(interval / 60), 
        fmt("~%d minutes", minutes)) : 7200 > interval ? (hours = Math.floor(interval / 3600), 
        minutes = Math.round((interval - 3600 * hours) / 60), 1 === minutes ? _("one hour and one minutes") : fmt("one hour, %d minutes", minutes)) : 86400 > interval ? (hours = Math.floor(interval / 3600), 
        fmt("~%d hours", hours)) : 172800 > interval ? (hours = Math.floor((interval - 86400) / 3600), 
        1 === hours ? _("one day and one hour") : fmt("one day, %d hours", hours)) : 604800 > interval ? (days = Math.floor(interval / 86400), 
        fmt("%d days", days)) : 1209600 > interval ? (days = Math.floor((interval - 604800) / 86400), 
        1 === days ? "one week and one day" : fmt("one week and %d days", days)) : (weeks = Math.floor(interval / 604800), 
        days = Math.round((interval - 3600 * 24 * 7 * days) / 604800), fmt("%d weeks, %d days", weeks, days));
    }, fdjtTime.secs2short = function(interval) {
        if (.001 > interval) return Math.round(1e6 * interval) + "us";
        if (.1 > interval) return Math.round(1e3 * interval) + "ms";
        if (120 > interval) return Math.round(100 * interval) / 100 + "s";
        var min = Math.floor(interval / 60), secs = interval - 60 * min;
        return min + "m, " + Math.round(100 * secs) / 100 + "s";
    }, fdjtTime.runTimes = function(pname, start) {
        for (var point = start, report = "", i = 2; arguments.length > i; ) {
            var phase = arguments[i++], time = arguments[i++];
            report = report + "; " + phase + ": " + (time.getTime() - point.getTime()) / 1e3 + "s", 
            point = time;
        }
        return pname + " " + (point.getTime() - start.getTime()) / 1e3 + "s" + report;
    }, fdjtTime.diffTime = function(time1, time2) {
        time2 || (time2 = new Date());
        var diff = time1.getTime() - time2.getTime();
        return diff > 0 ? diff / 1e3 : -(diff / 1e3);
    }, fdjtTime.ET = function(arg) {
        return arg || (arg = new Date()), (arg.getTime() - loaded) / 1e3;
    };
    var tzpat = /(EST|EDT|PDT|PST|CST|CDT|ECT|GMT|Z|([+-]\d\d?(:\d+)?))$/i;
    return fdjtTime.parse = function(string) {
        var value = !1;
        try {
            value = Date.parse ? new Date(Date.parse(string)) : new Date(string);
        } catch (ex) {
            fdjt.Log("Error parsing time '%s': %o", string, ex);
        }
        if (value instanceof Date && !isNaN(value.getYear())) return value;
        var strip = string.search(tzpat);
        return strip > 0 ? fdjtTime.parse(string.slice(0, strip)) : (fdjt.Log("Couldn't parse time '%s'", string), 
        string);
    }, fdjtTime.timeslice = fdjt.Async.timeslice, fdjtTime.slowmap = fdjt.Async.slowmap, 
    fdjtTime;
}(), fdjt.ET = fdjt.Time.ET, fdjt.Template = function() {
    "use strict";
    function Template(text, data, xdata) {
        var dom = !1;
        if ("string" == typeof data) {
            var tmp = data;
            data = text, text = tmp;
        }
        if (!text && data && data.template && (text = data.template), "string" == typeof text) ; else if (3 === text.nodeType) dom = text, 
        text = dom.nodeValue; else {
            if (1 !== text.nodeType) return fdjt.Log.warn("Bad argument %o to Template", text), 
            void 0;
            dom = text, text = dom.innerHTML;
        }
        Template.localTemplates.hasOwnProperty(text) ? text = Template.localTemplates[text] : templates.hasOwnProperty(text) && (text = templates[text]);
        var substs = text.match(/\{\{\w+\}\}/gm), done = {};
        if (substs) for (var i = 0, n = substs.length; n > i; ) {
            var match = substs[i++], prop = match.slice(2, -2), pat = RegExp("\\{\\{" + prop + "\\}\\}", "gm");
            if (!done[prop]) if (data.hasOwnProperty(prop) || xdata && xdata.hasOwnProperty(prop)) {
                var val = data[prop] || xdata && xdata[prop] || "";
                done[prop] = prop, text = text.replace(pat, "" + val);
            } else fdjt.Log.warn("No data for %s in %s to use in %s", prop, data, text), done[prop] = prop;
        }
        return dom ? (3 === dom.nodeType ? dom.nodeValue = text : dom.innerHTML = text, 
        dom) : text;
    }
    function toDOM(text, data, dom_arg) {
        var output = template(text, data), dom = dom_arg ? dom_arg.nodeType ? dom_arg : "string" == typeof dom_arg ? document.createElement(dom_arg) : document.createElement("div") : document.createElement("div");
        if (dom.innerHTML = output, dom_arg && dom_arg.nodeType) return dom;
        if (dom.childNodes) {
            if (1 === dom.childNodes.length) return dom.childNodes[0];
            for (var frag = document.createDocumentFragment, nodes = [], children = dom.childNodes, i = 0, lim = children.length; lim > i; ) nodes.push(children[i++]);
            for (i = 0; lim > i; ) frag.appendChild(nodes[i++]);
            return frag;
        }
        return !1;
    }
    var templates = {}, template = Template;
    return fdjt.Templates = templates, Template.localTemplates = {}, Template.toDOM = toDOM, 
    Template;
}(), fdjt.Hash || (fdjt.Hash = function() {
    "use strict";
    function gethexcase() {
        return hexcase_default;
    }
    function sethexcase(v) {
        hexcase_default = v;
    }
    function getpadchar() {
        return b64pad_default;
    }
    function setpadchar(v) {
        b64pad_default = v;
    }
    function getenc() {}
    function setenc(v) {
        enc = "string" == typeof v ? fdjt.Hash[v] || !1 : v;
    }
    function rstr2binb(input) {
        var i, output = Array(input.length >> 2);
        for (i = 0; output.length > i; i++) output[i] = 0;
        for (i = 0; 8 * input.length > i; i += 8) output[i >> 5] |= (255 & input.charCodeAt(i / 8)) << 24 - i % 32;
        return output;
    }
    function binb2rstr(input) {
        for (var output = "", i = 0; 32 * input.length > i; i += 8) output += String.fromCharCode(255 & input[i >> 5] >>> 24 - i % 32);
        return output;
    }
    function rstr2hex(input, hexcase) {
        hexcase === void 0 && (hexcase = hexcase_default);
        for (var x, hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef", output = "", i = 0; input.length > i; i++) x = input.charCodeAt(i), 
        output += hex_tab.charAt(15 & x >>> 4) + hex_tab.charAt(15 & x);
        return output;
    }
    function rstr2b64(input, b64pad) {
        b64pad || (b64pad = b64pad_default);
        for (var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", output = "", len = input.length, i = 0; len > i; i += 3) for (var triplet = input.charCodeAt(i) << 16 | (len > i + 1 ? input.charCodeAt(i + 1) << 8 : 0) | (len > i + 2 ? input.charCodeAt(i + 2) : 0), j = 0; 4 > j; j++) output += 8 * i + 6 * j > 8 * input.length ? b64pad : tab.charAt(63 & triplet >>> 6 * (3 - j));
        return output;
    }
    function rstr2any(input, encoding) {
        if (!encoding) return enc ? enc(input) : rstr2hex(input);
        var i, j, q, x, quotient, divisor = encoding.length, dividend = Array(Math.ceil(input.length / 2));
        for (i = 0; dividend.length > i; i++) dividend[i] = input.charCodeAt(2 * i) << 8 | input.charCodeAt(2 * i + 1);
        var full_length = Math.ceil(8 * input.length / (Math.log(encoding.length) / Math.log(2))), remainders = Array(full_length);
        for (j = 0; full_length > j; j++) {
            for (quotient = [], x = 0, i = 0; dividend.length > i; i++) x = (x << 16) + dividend[i], 
            q = Math.floor(x / divisor), x -= q * divisor, (quotient.length > 0 || q > 0) && (quotient[quotient.length] = q);
            remainders[j] = x, dividend = quotient;
        }
        var output = "";
        for (i = remainders.length - 1; i >= 0; i--) output += encoding.charAt(remainders[i]);
        return output;
    }
    function str2rstr_utf8(input) {
        for (var x, y, output = "", i = -1; input.length > ++i; ) x = input.charCodeAt(i), 
        y = input.length > i + 1 ? input.charCodeAt(i + 1) : 0, x >= 55296 && 56319 >= x && y >= 56320 && 57343 >= y && (x = 65536 + ((1023 & x) << 10) + (1023 & y), 
        i++), 127 >= x ? output += String.fromCharCode(x) : 2047 >= x ? output += String.fromCharCode(192 | 31 & x >>> 6, 128 | 63 & x) : 65535 >= x ? output += String.fromCharCode(224 | 15 & x >>> 12, 128 | 63 & x >>> 6, 128 | 63 & x) : 2097151 >= x && (output += String.fromCharCode(240 | 7 & x >>> 18, 128 | 63 & x >>> 12, 128 | 63 & x >>> 6, 128 | 63 & x));
        return output;
    }
    function rstr2binl(input) {
        var i, output = Array(input.length >> 2);
        for (i = 0; output.length > i; i++) output[i] = 0;
        for (i = 0; 8 * input.length > i; i += 8) output[i >> 5] |= (255 & input.charCodeAt(i / 8)) << i % 32;
        return output;
    }
    function binl2rstr(input) {
        for (var output = "", i = 0; 32 * input.length > i; i += 8) output += String.fromCharCode(255 & input[i >> 5] >>> i % 32);
        return output;
    }
    function safe_add(x, y) {
        var lsw = (65535 & x) + (65535 & y), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | 65535 & lsw;
    }
    function bit_rol(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
    }
    function hex_md5(s) {
        return rstr2hex(rstr_md5(str2rstr_utf8(s)));
    }
    function b64_md5(s) {
        return rstr2b64(rstr_md5(str2rstr_utf8(s)));
    }
    function any_md5(s, e) {
        return rstr2any(rstr_md5(str2rstr_utf8(s)), e);
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_md5(k, d) {
        return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_md5(k, d, e) {
        return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), 8 * s.length));
    }
    function rstr_hmac_md5(key, data) {
        var bkey = rstr2binl(key);
        bkey.length > 16 && (bkey = binl_md5(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + 8 * data.length);
        return binl2rstr(binl_md5(opad.concat(hash), 640));
    }
    function binl_md5(x, len) {
        x[len >> 5] |= 128 << len % 32, x[(len + 64 >>> 9 << 4) + 14] = len;
        for (var a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, i = 0; x.length > i; i += 16) {
            var olda = a, oldb = b, oldc = c, oldd = d;
            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936), d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586), 
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819), b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330), 
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897), d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426), 
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341), b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983), 
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416), d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417), 
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063), b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162), 
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682), d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101), 
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290), b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329), 
            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510), d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632), 
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713), b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302), 
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691), d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083), 
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335), b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848), 
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438), d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690), 
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961), b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501), 
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467), d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784), 
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473), b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734), 
            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558), d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463), 
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562), b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556), 
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060), d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353), 
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632), b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640), 
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174), d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222), 
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979), b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189), 
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487), d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835), 
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520), b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651), 
            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844), d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415), 
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905), b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055), 
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571), d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606), 
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523), b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799), 
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359), d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744), 
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380), b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649), 
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070), d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379), 
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259), b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551), 
            a = safe_add(a, olda), b = safe_add(b, oldb), c = safe_add(c, oldc), d = safe_add(d, oldd);
        }
        return Array(a, b, c, d);
    }
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    function hex_rmd160(s) {
        return rstr2hex(rstr_rmd160(str2rstr_utf8(s)));
    }
    function b64_rmd160(s) {
        return rstr2b64(rstr_rmd160(str2rstr_utf8(s)));
    }
    function any_rmd160(s, e) {
        return rstr2any(rstr_rmd160(str2rstr_utf8(s)), e);
    }
    function hex_hmac_rmd160(k, d) {
        return rstr2hex(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_rmd160(k, d) {
        return rstr2b64(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_rmd160(k, d, e) {
        return rstr2any(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_rmd160(s) {
        return binl2rstr(binl_rmd160(rstr2binl(s), 8 * s.length));
    }
    function rstr_hmac_rmd160(key, data) {
        var bkey = rstr2binl(key);
        bkey.length > 16 && (bkey = binl_rmd160(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binl_rmd160(ipad.concat(rstr2binl(data)), 512 + 8 * data.length);
        return binl2rstr(binl_rmd160(opad.concat(hash), 672));
    }
    function binl_rmd160(x, len) {
        x[len >> 5] |= 128 << len % 32, x[(len + 64 >>> 9 << 4) + 14] = len;
        for (var h0 = 1732584193, h1 = 4023233417, h2 = 2562383102, h3 = 271733878, h4 = 3285377520, i = 0; x.length > i; i += 16) {
            for (var T, A1 = h0, B1 = h1, C1 = h2, D1 = h3, E1 = h4, A2 = h0, B2 = h1, C2 = h2, D2 = h3, E2 = h4, j = 0; 79 >= j; ++j) T = safe_add(A1, rmd160_f(j, B1, C1, D1)), 
            T = safe_add(T, x[i + rmd160_r1[j]]), T = safe_add(T, rmd160_K1(j)), T = safe_add(bit_rol(T, rmd160_s1[j]), E1), 
            A1 = E1, E1 = D1, D1 = bit_rol(C1, 10), C1 = B1, B1 = T, T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2)), 
            T = safe_add(T, x[i + rmd160_r2[j]]), T = safe_add(T, rmd160_K2(j)), T = safe_add(bit_rol(T, rmd160_s2[j]), E2), 
            A2 = E2, E2 = D2, D2 = bit_rol(C2, 10), C2 = B2, B2 = T;
            T = safe_add(h1, safe_add(C1, D2)), h1 = safe_add(h2, safe_add(D1, E2)), h2 = safe_add(h3, safe_add(E1, A2)), 
            h3 = safe_add(h4, safe_add(A1, B2)), h4 = safe_add(h0, safe_add(B1, C2)), h0 = T;
        }
        return [ h0, h1, h2, h3, h4 ];
    }
    function rmd160_f(j, x, y, z) {
        return j >= 0 && 15 >= j ? x ^ y ^ z : j >= 16 && 31 >= j ? x & y | ~x & z : j >= 32 && 47 >= j ? (x | ~y) ^ z : j >= 48 && 63 >= j ? x & z | y & ~z : j >= 64 && 79 >= j ? x ^ (y | ~z) : "rmd160_f: j out of range";
    }
    function rmd160_K1(j) {
        return j >= 0 && 15 >= j ? 0 : j >= 16 && 31 >= j ? 1518500249 : j >= 32 && 47 >= j ? 1859775393 : j >= 48 && 63 >= j ? 2400959708 : j >= 64 && 79 >= j ? 2840853838 : "rmd160_K1: j out of range";
    }
    function rmd160_K2(j) {
        return j >= 0 && 15 >= j ? 1352829926 : j >= 16 && 31 >= j ? 1548603684 : j >= 32 && 47 >= j ? 1836072691 : j >= 48 && 63 >= j ? 2053994217 : j >= 64 && 79 >= j ? 0 : "rmd160_K2: j out of range";
    }
    function hex_sha1(s) {
        return rstr2hex(rstr_sha1(str2rstr_utf8(s)));
    }
    function b64_sha1(s) {
        return rstr2b64(rstr_sha1(str2rstr_utf8(s)));
    }
    function any_sha1(s, e) {
        return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);
    }
    function hex_hmac_sha1(k, d) {
        return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_sha1(k, d) {
        return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_sha1(k, d, e) {
        return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_sha1(s) {
        return binb2rstr(binb_sha1(rstr2binb(s), 8 * s.length));
    }
    function rstr_hmac_sha1(key, data) {
        var bkey = rstr2binb(key);
        bkey.length > 16 && (bkey = binb_sha1(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + 8 * data.length);
        return binb2rstr(binb_sha1(opad.concat(hash), 672));
    }
    function binb_sha1(x, len) {
        x[len >> 5] |= 128 << 24 - len % 32, x[(len + 64 >> 9 << 4) + 15] = len;
        for (var w = Array(80), a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, e = -1009589776, i = 0; x.length > i; i += 16) {
            for (var olda = a, oldb = b, oldc = c, oldd = d, olde = e, j = 0; 80 > j; j++) {
                w[j] = 16 > j ? x[i + j] : bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
                e = d, d = c, c = bit_rol(b, 30), b = a, a = t;
            }
            a = safe_add(a, olda), b = safe_add(b, oldb), c = safe_add(c, oldc), d = safe_add(d, oldd), 
            e = safe_add(e, olde);
        }
        return Array(a, b, c, d, e);
    }
    function sha1_ft(t, b, c, d) {
        return 20 > t ? b & c | ~b & d : 40 > t ? b ^ c ^ d : 60 > t ? b & c | b & d | c & d : b ^ c ^ d;
    }
    function sha1_kt(t) {
        return 20 > t ? 1518500249 : 40 > t ? 1859775393 : 60 > t ? -1894007588 : -899497514;
    }
    function hex_sha256(s) {
        return rstr2hex(rstr_sha256(str2rstr_utf8(s)));
    }
    function b64_sha256(s) {
        return rstr2b64(rstr_sha256(str2rstr_utf8(s)));
    }
    function any_sha256(s, e) {
        return rstr2any(rstr_sha256(str2rstr_utf8(s)), e);
    }
    function hex_hmac_sha256(k, d) {
        return rstr2hex(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_sha256(k, d) {
        return rstr2b64(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_sha256(k, d, e) {
        return rstr2any(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_sha256(s) {
        return binb2rstr(binb_sha256(rstr2binb(s), 8 * s.length));
    }
    function rstr_hmac_sha256(key, data) {
        var bkey = rstr2binb(key);
        bkey.length > 16 && (bkey = binb_sha256(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binb_sha256(ipad.concat(rstr2binb(data)), 512 + 8 * data.length);
        return binb2rstr(binb_sha256(opad.concat(hash), 768));
    }
    function sha256_S(X, n) {
        return X >>> n | X << 32 - n;
    }
    function sha256_R(X, n) {
        return X >>> n;
    }
    function sha256_Ch(x, y, z) {
        return x & y ^ ~x & z;
    }
    function sha256_Maj(x, y, z) {
        return x & y ^ x & z ^ y & z;
    }
    function sha256_Sigma0256(x) {
        return sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22);
    }
    function sha256_Sigma1256(x) {
        return sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25);
    }
    function sha256_Gamma0256(x) {
        return sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3);
    }
    function sha256_Gamma1256(x) {
        return sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10);
    }
    function binb_sha256(m, l) {
        var a, b, c, d, e, f, g, h, i, j, T1, T2, HASH = Array(1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225), W = Array(64);
        for (m[l >> 5] |= 128 << 24 - l % 32, m[(l + 64 >> 9 << 4) + 15] = l, i = 0; m.length > i; i += 16) {
            for (a = HASH[0], b = HASH[1], c = HASH[2], d = HASH[3], e = HASH[4], f = HASH[5], 
            g = HASH[6], h = HASH[7], j = 0; 64 > j; j++) W[j] = 16 > j ? m[j + i] : safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]), sha256_Gamma0256(W[j - 15])), W[j - 16]), 
            T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)), sha256_K[j]), W[j]), 
            T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c)), h = g, g = f, f = e, e = safe_add(d, T1), 
            d = c, c = b, b = a, a = safe_add(T1, T2);
            HASH[0] = safe_add(a, HASH[0]), HASH[1] = safe_add(b, HASH[1]), HASH[2] = safe_add(c, HASH[2]), 
            HASH[3] = safe_add(d, HASH[3]), HASH[4] = safe_add(e, HASH[4]), HASH[5] = safe_add(f, HASH[5]), 
            HASH[6] = safe_add(g, HASH[6]), HASH[7] = safe_add(h, HASH[7]);
        }
        return HASH;
    }
    function hex_sha512(s) {
        return rstr2hex(rstr_sha512(str2rstr_utf8(s)));
    }
    function b64_sha512(s) {
        return rstr2b64(rstr_sha512(str2rstr_utf8(s)));
    }
    function any_sha512(s, e) {
        return rstr2any(rstr_sha512(str2rstr_utf8(s)), e);
    }
    function hex_hmac_sha512(k, d) {
        return rstr2hex(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_sha512(k, d) {
        return rstr2b64(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_sha512(k, d, e) {
        return rstr2any(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_sha512(s) {
        return binb2rstr(binb_sha512(rstr2binb(s), 8 * s.length));
    }
    function rstr_hmac_sha512(key, data) {
        var bkey = rstr2binb(key);
        bkey.length > 32 && (bkey = binb_sha512(bkey, 8 * key.length));
        for (var ipad = Array(32), opad = Array(32), i = 0; 32 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binb_sha512(ipad.concat(rstr2binb(data)), 1024 + 8 * data.length);
        return binb2rstr(binb_sha512(opad.concat(hash), 1536));
    }
    function binb_sha512(x, len) {
        void 0 === sha512_k && (sha512_k = Array(new Int64(1116352408, -685199838), new Int64(1899447441, 602891725), new Int64(-1245643825, -330482897), new Int64(-373957723, -2121671748), new Int64(961987163, -213338824), new Int64(1508970993, -1241133031), new Int64(-1841331548, -1357295717), new Int64(-1424204075, -630357736), new Int64(-670586216, -1560083902), new Int64(310598401, 1164996542), new Int64(607225278, 1323610764), new Int64(1426881987, -704662302), new Int64(1925078388, -226784913), new Int64(-2132889090, 991336113), new Int64(-1680079193, 633803317), new Int64(-1046744716, -815192428), new Int64(-459576895, -1628353838), new Int64(-272742522, 944711139), new Int64(264347078, -1953704523), new Int64(604807628, 2007800933), new Int64(770255983, 1495990901), new Int64(1249150122, 1856431235), new Int64(1555081692, -1119749164), new Int64(1996064986, -2096016459), new Int64(-1740746414, -295247957), new Int64(-1473132947, 766784016), new Int64(-1341970488, -1728372417), new Int64(-1084653625, -1091629340), new Int64(-958395405, 1034457026), new Int64(-710438585, -1828018395), new Int64(113926993, -536640913), new Int64(338241895, 168717936), new Int64(666307205, 1188179964), new Int64(773529912, 1546045734), new Int64(1294757372, 1522805485), new Int64(1396182291, -1651133473), new Int64(1695183700, -1951439906), new Int64(1986661051, 1014477480), new Int64(-2117940946, 1206759142), new Int64(-1838011259, 344077627), new Int64(-1564481375, 1290863460), new Int64(-1474664885, -1136513023), new Int64(-1035236496, -789014639), new Int64(-949202525, 106217008), new Int64(-778901479, -688958952), new Int64(-694614492, 1432725776), new Int64(-200395387, 1467031594), new Int64(275423344, 851169720), new Int64(430227734, -1194143544), new Int64(506948616, 1363258195), new Int64(659060556, -544281703), new Int64(883997877, -509917016), new Int64(958139571, -976659869), new Int64(1322822218, -482243893), new Int64(1537002063, 2003034995), new Int64(1747873779, -692930397), new Int64(1955562222, 1575990012), new Int64(2024104815, 1125592928), new Int64(-2067236844, -1578062990), new Int64(-1933114872, 442776044), new Int64(-1866530822, 593698344), new Int64(-1538233109, -561857047), new Int64(-1090935817, -1295615723), new Int64(-965641998, -479046869), new Int64(-903397682, -366583396), new Int64(-779700025, 566280711), new Int64(-354779690, -840897762), new Int64(-176337025, -294727304), new Int64(116418474, 1914138554), new Int64(174292421, -1563912026), new Int64(289380356, -1090974290), new Int64(460393269, 320620315), new Int64(685471733, 587496836), new Int64(852142971, 1086792851), new Int64(1017036298, 365543100), new Int64(1126000580, -1676669620), new Int64(1288033470, -885112138), new Int64(1501505948, -60457430), new Int64(1607167915, 987167468), new Int64(1816402316, 1246189591)));
        var j, i, H = Array(new Int64(1779033703, -205731576), new Int64(-1150833019, -2067093701), new Int64(1013904242, -23791573), new Int64(-1521486534, 1595750129), new Int64(1359893119, -1377402159), new Int64(-1694144372, 725511199), new Int64(528734635, -79577749), new Int64(1541459225, 327033209)), T1 = new Int64(0, 0), T2 = new Int64(0, 0), a = new Int64(0, 0), b = new Int64(0, 0), c = new Int64(0, 0), d = new Int64(0, 0), e = new Int64(0, 0), f = new Int64(0, 0), g = new Int64(0, 0), h = new Int64(0, 0), s0 = new Int64(0, 0), s1 = new Int64(0, 0), Ch = new Int64(0, 0), Maj = new Int64(0, 0), r1 = new Int64(0, 0), r2 = new Int64(0, 0), r3 = new Int64(0, 0), W = Array(80);
        for (i = 0; 80 > i; i++) W[i] = new Int64(0, 0);
        for (x[len >> 5] |= 128 << 24 - (31 & len), x[(len + 128 >> 10 << 5) + 31] = len, 
        i = 0; x.length > i; i += 32) {
            for (int64copy(a, H[0]), int64copy(b, H[1]), int64copy(c, H[2]), int64copy(d, H[3]), 
            int64copy(e, H[4]), int64copy(f, H[5]), int64copy(g, H[6]), int64copy(h, H[7]), 
            j = 0; 16 > j; j++) W[j].h = x[i + 2 * j], W[j].l = x[i + 2 * j + 1];
            for (j = 16; 80 > j; j++) int64rrot(r1, W[j - 2], 19), int64revrrot(r2, W[j - 2], 29), 
            int64shr(r3, W[j - 2], 6), s1.l = r1.l ^ r2.l ^ r3.l, s1.h = r1.h ^ r2.h ^ r3.h, 
            int64rrot(r1, W[j - 15], 1), int64rrot(r2, W[j - 15], 8), int64shr(r3, W[j - 15], 7), 
            s0.l = r1.l ^ r2.l ^ r3.l, s0.h = r1.h ^ r2.h ^ r3.h, int64add4(W[j], s1, W[j - 7], s0, W[j - 16]);
            for (j = 0; 80 > j; j++) Ch.l = e.l & f.l ^ ~e.l & g.l, Ch.h = e.h & f.h ^ ~e.h & g.h, 
            int64rrot(r1, e, 14), int64rrot(r2, e, 18), int64revrrot(r3, e, 9), s1.l = r1.l ^ r2.l ^ r3.l, 
            s1.h = r1.h ^ r2.h ^ r3.h, int64rrot(r1, a, 28), int64revrrot(r2, a, 2), int64revrrot(r3, a, 7), 
            s0.l = r1.l ^ r2.l ^ r3.l, s0.h = r1.h ^ r2.h ^ r3.h, Maj.l = a.l & b.l ^ a.l & c.l ^ b.l & c.l, 
            Maj.h = a.h & b.h ^ a.h & c.h ^ b.h & c.h, int64add5(T1, h, s1, Ch, sha512_k[j], W[j]), 
            int64add(T2, s0, Maj), int64copy(h, g), int64copy(g, f), int64copy(f, e), int64add(e, d, T1), 
            int64copy(d, c), int64copy(c, b), int64copy(b, a), int64add(a, T1, T2);
            int64add(H[0], H[0], a), int64add(H[1], H[1], b), int64add(H[2], H[2], c), int64add(H[3], H[3], d), 
            int64add(H[4], H[4], e), int64add(H[5], H[5], f), int64add(H[6], H[6], g), int64add(H[7], H[7], h);
        }
        var hash = Array(16);
        for (i = 0; 8 > i; i++) hash[2 * i] = H[i].h, hash[2 * i + 1] = H[i].l;
        return hash;
    }
    function Int64(h, l) {
        this.h = h, this.l = l;
    }
    function int64copy(dst, src) {
        dst.h = src.h, dst.l = src.l;
    }
    function int64rrot(dst, x, shift) {
        dst.l = x.l >>> shift | x.h << 32 - shift, dst.h = x.h >>> shift | x.l << 32 - shift;
    }
    function int64revrrot(dst, x, shift) {
        dst.l = x.h >>> shift | x.l << 32 - shift, dst.h = x.l >>> shift | x.h << 32 - shift;
    }
    function int64shr(dst, x, shift) {
        dst.l = x.l >>> shift | x.h << 32 - shift, dst.h = x.h >>> shift;
    }
    function int64add(dst, x, y) {
        var w0 = (65535 & x.l) + (65535 & y.l), w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16), w2 = (65535 & x.h) + (65535 & y.h) + (w1 >>> 16), w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);
        dst.l = 65535 & w0 | w1 << 16, dst.h = 65535 & w2 | w3 << 16;
    }
    function int64add4(dst, a, b, c, d) {
        var w0 = (65535 & a.l) + (65535 & b.l) + (65535 & c.l) + (65535 & d.l), w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (w0 >>> 16), w2 = (65535 & a.h) + (65535 & b.h) + (65535 & c.h) + (65535 & d.h) + (w1 >>> 16), w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (w2 >>> 16);
        dst.l = 65535 & w0 | w1 << 16, dst.h = 65535 & w2 | w3 << 16;
    }
    function int64add5(dst, a, b, c, d, e) {
        var w0 = (65535 & a.l) + (65535 & b.l) + (65535 & c.l) + (65535 & d.l) + (65535 & e.l), w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (e.l >>> 16) + (w0 >>> 16), w2 = (65535 & a.h) + (65535 & b.h) + (65535 & c.h) + (65535 & d.h) + (65535 & e.h) + (w1 >>> 16), w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (e.h >>> 16) + (w2 >>> 16);
        dst.l = 65535 & w0 | w1 << 16, dst.h = 65535 & w2 | w3 << 16;
    }
    var sha512_k, hexcase_default = 0, b64pad_default = "", enc = !1, rmd160_r1 = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ], rmd160_r2 = [ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ], rmd160_s1 = [ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ], rmd160_s2 = [ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ], sha256_K = Array(1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998);
    return {
        _get_hexcase_: gethexcase,
        _set_hexcase_: sethexcase,
        _get_padchar_: getpadchar,
        _set_padchar_: setpadchar,
        _get_outenc_: getenc,
        _set_outenc_: setenc,
        hex: rstr2hex,
        b64: "rst2b64",
        base64: "rst2b64",
        array: rstr2binl,
        binl: rstr2binl,
        hex_md5: hex_md5,
        b64_md5: b64_md5,
        md5: any_md5,
        hex_hmac_md5: hex_hmac_md5,
        b64_hmac_md5: b64_hmac_md5,
        hmac_md5: any_hmac_md5,
        hex_rmd160: hex_rmd160,
        b64_rmd160: b64_rmd160,
        rmd160: any_rmd160,
        hex_hmac_rmd160: hex_hmac_rmd160,
        b64_hmac_rmd160: b64_hmac_rmd160,
        hmac_rmd160: any_hmac_rmd160,
        hex_sha1: hex_sha1,
        b64_sha1: b64_sha1,
        sha1: any_sha1,
        hex_hmac_sha1: hex_hmac_sha1,
        b64_hmac_sha1: b64_hmac_sha1,
        hmac_sha1: any_hmac_sha1,
        hex_sha256: hex_sha256,
        b64_sha256: b64_sha256,
        sha256: any_sha256,
        hex_hmac_sha256: hex_hmac_sha256,
        b64_hmac_sha256: b64_hmac_sha256,
        hmac_sha256: any_hmac_sha256,
        hex_sha512: hex_sha512,
        b64_sha512: b64_sha512,
        sha512: any_sha512,
        hex_hmac_sha512: hex_hmac_sha512,
        b64_hmac_sha512: b64_hmac_sha512,
        hmac_sha512: any_hmac_sha512
    };
}()), fdjt.Log = function() {
    "use strict";
    function fdjtLog(string) {
        var i, lim, output = !1, now = ET(), date = new Date();
        if ((fdjtLog.doformat || string.search("%j")) && fdjtString !== void 0 && (output = fdjtString.apply(null, arguments)), 
        fdjtLog.console_fn && (output ? fdjtLog.console_fn.call(fdjtLog.console, output) : fdjtLog.console_fn.apply(fdjtLog.console, arguments)), 
        fdjtLog.logurl) {
            var msg = "[" + now + "s " + compactString(date, !1) + "] " + fdjtString.apply(null, arguments);
            window.console && window.console.log("remote logging %s", msg), remote_log(msg);
        }
        if (fdjtLog.console) {
            var domconsole = fdjtLog.console, timespan = fdjt.DOM("span.time", now), abstime = fdjt.DOM("span.abstime", compactString(date)), entry = fdjt.DOM("div.fdjtlog");
            if (entry.innerHTML = output ? output : fdjtString.apply(null, arguments), fdjt.DOM.prepend(entry, timespan), 
            fdjt.DOM.prepend(entry, abstime), "string" == typeof domconsole) {
                var found = document.getElementById(domconsole);
                domconsole = found ? fdjtLog.console = found : !1;
            }
            domconsole && !domconsole.nodeType && (domconsole = !1), domconsole && fdjtLog.livelog ? (update_log(domconsole), 
            domconsole.appendChild(entry), domconsole.appendChild(document.createTextNode("\n"))) : domconsole && 0 !== domconsole.offsetHeight ? (update_log(domconsole), 
            domconsole.appendChild(entry), domconsole.appendChild(document.createTextNode("\n"))) : backlog.push(entry);
        }
        if ((fdjtLog.useconsole || !fdjtLog.console && !fdjtLog.console_fn) && (use_console_log === void 0 && init_use_console_log(), 
        use_console_log)) if (window.console.log.call) if (output) window.console.log.call(window.console, "[" + now + "s] " + output); else {
            var newargs = Array(arguments.length + 1);
            for (newargs[0] = "[%fs] " + string, newargs[1] = now, i = 1, lim = arguments.length; lim > i; ) newargs[i + 1] = arguments[i], 
            i++;
            window.console.log.apply(window.console, newargs);
        } else window.console.log("[" + now + "s] " + fdjtString.apply(null, arguments));
    }
    function update_log(domconsole) {
        if (backlog && backlog.length) {
            var frag = document.createDocumentFragment(), log = backlog;
            backlog = !1;
            for (var i = 0, lim = log.length; lim > i; ) frag.appendChild(log[i++]), frag.appendChild(document.createTextNode("\n"));
            domconsole.appendChild(frag), backlog = [];
        }
    }
    function updateLogHandler() {
        fdjtLog.console && update_log(fdjtLog.console);
    }
    function remote_log(msg) {
        var req = new XMLHttpRequest();
        return req.open("POST", fdjtLog.logurl, !fdjtLog.logsync), req.setRequestHeader("Content-type", "text; charset=utf-8"), 
        req.send(msg), req;
    }
    function fdjtLogWarn() {
        if (!fdjtLog.console_fn && !window.console && window.console.log && window.console.log.count) {
            var output = fdjtString.apply(null, arguments);
            window.alert(output);
        } else fdjtLog.apply(null, arguments);
    }
    function fdjtLogUhOh() {
        fdjtLog.debugging && fdjtLog.warn.call(null, arguments);
    }
    function fdjtLogBkpt() {
        var output = !1;
        fdjtLog.doformat && fdjtString !== void 0 && (output = fdjtString.apply(null, arguments)), 
        fdjtLog.console_fn ? output ? fdjtLog.console_fn(fdjtLog.console, output) : fdjtLog.console_fn.apply(fdjtLog.console, arguments) : window.console && window.console.log && window.console.count && (output ? window.console.log.call(window.console, output) : window.console.log.apply(window.console, arguments));
    }
    function init_use_console_log() {
        if (window.console && window.console.log) if (window.console.count) use_console_log = !0; else {
            use_console_log = !0;
            try {
                window.console.log("Testing console");
            } catch (ex) {
                use_console_log = !1;
            }
        } else use_console_log = !1;
    }
    var use_console_log, fdjtString = fdjt.String, backlog = [], compactString = fdjt.Time.compactString, ET = fdjt.ET;
    return fdjtLog.console = null, fdjtLog.update = updateLogHandler, fdjtLog.warn = fdjtLogWarn, 
    fdjtLog.uhoh = fdjtLogUhOh, fdjtLog.bkpt = fdjtLogBkpt, fdjtLog.useconsole = !0, 
    fdjt.Trace = fdjt.Log, fdjtLog.getBacklog = function() {
        return backlog;
    }, fdjtLog;
}(window, document), function() {
    "use strict";
    function addInit(fcn, name, runagain) {
        if (checkInit(fcn, name)) {
            for (var replace = name && init_names[name], i = 0, lim = inits.length; lim > i; ) {
                if (replace && inits[i] === replace || inits[i] === fcn) return inits_run ? (fdjtLog.warn("Replacing init %s which has already run", name), 
                runagain ? (fdjtLog.warn("Running the new version"), inits[i] = fcn, name && (init_names[name] = fcn), 
                fcn(), void 0) : void 0) : (inits[i] = fcn, name && (init_names[name] = fcn), void 0);
                i++;
            }
            name && (init_names[name] = fcn), inits.push(fcn), inits_run ? (fcn(), run.push(!0)) : run.push(!1);
        }
    }
    function checkInit(fcn, name) {
        return fcn && fcn.call ? !0 : (fdjtLog.warn("Bad argument to addInit(): %s", name || "anonymous", fcn), 
        !1);
    }
    function getMatch(string, rx, i) {
        var match = rx.exec(string);
        return i === void 0 && (i = 0), match && match.length > i ? match[i] : !1;
    }
    function stdspace(string) {
        string = string.replace(/\s+/g, " ");
        var start = 0, len = string.length;
        if (0 >= len) return string;
        for (;len > start && spacechars.indexOf(string.charAt(start)) > -1; ) start++;
        if (start === len) return "";
        for (var end = len - 1; end > start && spacechars.indexOf(string.charAt(end)) > -1; ) end--;
        return start > 0 || len > end ? string.slice(start, end + 1) : string;
    }
    function getVersionNum(s) {
        if ("number" == typeof s) return s;
        if ("string" != typeof s) return s;
        if (s.indexOf("_") && (s = s.replace(/_/g, ".")), /^\d+\.?$/.exec(s)) ; else {
            if (!vnum_pat.exec(s)) return s;
            s = vnum_pat.exec(s)[1];
        }
        try {
            return parseFloat(s) || s;
        } catch (ex) {
            return s;
        }
    }
    function identifyDevice() {
        if (!fdjt.device || !fdjt.device.started) {
            var navigator = window.navigator, ua = navigator.userAgent, isAndroid = getMatch(ua, /\bAndroid +(\d+\.\d+)\b/g, 1), isWebKit = getMatch(ua, /\bAppleWebKit\/(\d+\.\d+)\b/g, 1), isGecko = getMatch(ua, /\bGecko\/(\d+)\b/gi, 1, !0), isChrome = getMatch(ua, /\bChrome\/(\d+\.\d+(.\d+)*)\b/g, 1), isFirefox = getMatch(ua, /\bFirefox\/(\d+\.\d+(.\d+)*)\b/gi, 1), isSafari = getMatch(ua, /\bSafari\/(\d+\.\d+(.\d+)*)\b/gi, 1), isOSX = getMatch(ua, /\bMac OS X \/(\d+\_\d+)\b/gi, 1, !0), isMobileSafari = isSafari && getMatch(ua, /\bMobile\/(\w+)\b/gi, 1, !0), isMobileWebKit = isWebKit && getMatch(ua, /\bMobile\/(\w+)\b/gi, 1, !0), isMobile = getMatch(ua, /\bMobile\/(\w+)\b/gi, 1, !0), hasVersion = getMatch(ua, /\bVersion\/(\d+\.\d+)\b/gi, 1), os_version = getMatch(ua, /\bOS (\d+_\d+(_\d)*)\b/gi, 1), isUbuntu = /ubuntu/gi.test(ua), isRedHat = /redhat/gi.test(ua), isLinux = /linux/gi.test(ua), isMacintosh = /Macintosh/gi.test(ua), isTouchPad = /Touchpad/gi.test(ua), iPhone = /iphone/gi.test(ua), iPad = /ipad/gi.test(ua), isTouch = iPhone || iPad || isAndroid || isTouchPad, isIOS = (iPhone || iPad) && (getMatch(ua, /\bVersion\/(\d+\.\d+)\b/gi, 1) || !0), opt_string = stdspace((isAndroid ? " Android/" + isAndroid : "") + (isWebKit ? " WebKit/" + isWebKit : "") + (isGecko ? " Gecko/" + isGecko : "") + (isChrome ? " Chrome/" + isChrome : "") + (isFirefox ? " Firefox/" + isFirefox : "") + (isSafari ? " Safari/" + isSafari : "") + (isMobileSafari ? " MobileSafari/" + isMobileSafari : "") + (isMobileWebKit ? " MobileWebKit/" + isMobileWebKit : "") + (isIOS ? " IOS/" + isIOS : "") + (isOSX ? " OSX/" + isOSX : "") + (navigator.platform ? " " + navigator.platform : "") + (iPhone ? " iPhone" : "") + (iPad ? " iPad" : "") + (isTouchPad ? " TouchPad" : "") + (isTouch ? " touch" : " mouse"));
            navigator.vendor && (device.vendor = navigator.vendor), navigator.platform && (device.platform = navigator.platform), 
            navigator.oscpu && (device.oscpu = navigator.oscpu), navigator.cookieEnabled && (device.cookies = navigator.cookieEnabled), 
            navigator.doNotTrack && (device.notrack = navigator.doNotTrack), navigator.standalone && (device.standalone = navigator.standalone), 
            device.string = opt_string, isAndroid && (device.android = getVersionNum(isAndroid), 
            device.android_version = isAndroid), isIOS && (device.ios = getVersionNum(os_version) || isIOS, 
            device.ios_version = isIOS, iPhone && (device.iphone = isIOS), iPad && (device.ipad = isIOS)), 
            isChrome && (device.chrome_version = isChrome, device.chrome = getVersionNum(isChrome)), 
            iPad && (device.iPad = !0), iPhone && (device.iPhone = !0), isOSX && (device.osx = getVersionNum(isOSX), 
            device.osx_version = isOSX), isWebKit && (device.webkit = getVersionNum(isWebKit), 
            device.webkit_version = isWebKit), isSafari && (device.safari = getVersionNum(isSafari), 
            device.safari_version = isSafari), isMobileSafari && (device.mobilesafari_version = isMobileSafari, 
            device.mobilesafari = getVersionNum(isMobileSafari)), isMobileWebKit && (device.mobilewebkit_version = isMobileWebKit, 
            device.mobilewebkit = getVersionNum(isMobileWebKit)), isMobile && (device.mobile = isMobile), 
            hasVersion && (device.version = hasVersion), isMacintosh && (device.isMacintosh = !0), 
            isUbuntu && (device.ubuntu = !0), isRedHat && (device.redhat = !0), isLinux && (device.linux = !0), 
            isTouch ? device.touch = !0 : device.mouse = !0, fdjtLog("Device: %j", device);
        }
    }
    var fdjtLog = fdjt.Log, inits_run = !1, inits = [], run = [], init_names = {};
    fdjt.addInit = addInit, fdjt.Init = function() {
        var names = [];
        if (inits_run) return !1;
        for (var name in init_names) init_names.hasOwnProperty(name) && names.push(name);
        0 === names.length ? fdjtLog("Running %d DOM inits", inits.length) : names.length === inits.length ? fdjtLog("Running %d DOM inits (%s)", inits.length, names.join()) : fdjtLog("Running %d DOM inits (including %s)", inits.length, names.join());
        for (var i = 0, lim = inits.length; lim > i; ) run[i] ? i++ : (run[i] = !0, inits[i](), 
        i++);
        inits_run = !0;
    };
    var spacechars = "\n\r	\f  ᠎           ​\u2028\u2029  　", vnum_pat = /^(\d+(\.\d+)).*/, device = fdjt.device || (fdjt.device = {});
    (function() {
        "undefined" != typeof window && window.navigator && window.navigator.appVersion && identifyDevice();
    })();
}(), fdjt.State = function() {
    "use strict";
    function fdjtState(name, val, persist) {
        if (1 === arguments.length) return window.sessionStorage && getSession(name) || window.sessionStorage && getLocal(name) || getCookie(name);
        if (persist) if (window.localStorage) val ? setLocal(name, val) : dropLocal(name); else {
            var domain = fdjtState.domain || location.hostname, path = fdjtState.path || "/", duration = fdjtState.duration || 220752e3;
            val ? setCookie(name, val, duration, path, domain) : clearCookie(name, path, domain);
        } else val ? window.sessionStorage ? setSession(name, val) : setCookie(name, val) : window.sessionStorage ? dropSession(name) : clearCookie(name);
    }
    function getCookie(name, parse) {
        try {
            var valuestring, cookies = document.cookie, namepat = RegExp("(^|(; ))" + name + "=", "g"), pos = cookies.search(namepat);
            if (!(pos >= 0)) return !1;
            var start = cookies.indexOf("=", pos) + 1, end = cookies.indexOf(";", start);
            return valuestring = end > 0 ? cookies.slice(start, end) : cookies.slice(start), 
            parse ? JSON.parse(decodeURIComponent(valuestring)) : decodeURIComponent(valuestring);
        } catch (ex) {
            return !1;
        }
    }
    function setCookie(name, value, expires, path, domain, secure) {
        try {
            if (value) {
                var valuestring = "string" == typeof value ? value : value.toJSON ? value.toJSON() : value.toString ? "" + value : value, cookietext = name + "=" + encodeURIComponent(valuestring);
                if (expires) if ("string" == typeof expires) cookietext = cookietext + "; " + expires; else if (expires.toGMTString) cookietext = cookietext + "; expires=" + expires.toGMTString(); else if ("number" == typeof expires) if (expires > 0) {
                    var now = new Date();
                    now.setTime(now.getTime() + expires), cookietext = cookietext + "; expires=" + now.toGMTString;
                } else cookietext += "; expires=Sun 1 Jan 2000 00:00:00 UTC";
                path && (cookietext = cookietext + "; path=" + path), domain && (cookietext = cookietext + "; domain=" + domain), 
                secure && (cookietext += "; Secure"), document.cookie = cookietext;
            } else clearCookie(name, path, domain);
        } catch (ex) {
            fdjtLog.warn("Error setting cookie %s", name);
        }
    }
    function clearCookie(name, path, domain) {
        try {
            var cookietext = encodeURIComponent(name) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
            path && (cookietext = cookietext = cookietext + "; path=" + path), domain && (cookietext = cookietext = cookietext + "; domain=" + domain), 
            document.cookie = cookietext;
        } catch (ex) {
            fdjtLog.warn("Error clearing cookie %s: %s", name, ex);
        }
        if (getCookie(name)) {
            var altcookietext = encodeURIComponent(name) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
            document.cookie = altcookietext;
        }
    }
    function setSession(name, val, unparse) {
        unparse && (val = JSON.stringify(val)), window.sessionStorage ? window.sessionStorage[name] = val : setCookie(name, val);
    }
    function getSession(name, parse) {
        var val = window.sessionStorage ? window.sessionStorage[name] : getCookie(name);
        return val ? parse ? JSON.parse(val) : val : !1;
    }
    function existsSession(name) {
        if (name) {
            if (window.sessionStorage) {
                if (name instanceof RegExp) {
                    for (var storage = window.sessionStorage, i = 0, lim = storage.length; lim > i; ) {
                        var key = storage.key(i++);
                        if (key.search(name) >= 0) return !0;
                    }
                    return !1;
                }
                var val = window.sessionStorage[name];
                return val === void 0 ? !1 : !0;
            }
            return !1;
        }
        throw {
            error: "bad name",
            name: name
        };
    }
    function dropSession(name) {
        return window.sessionStorage ? window.sessionStorage.removeItem(name) : (clearCookie(name), 
        void 0);
    }
    function clearSession(pat) {
        if (window.sessionStorage) {
            var storage = window.sessionStorage, i = 0, lim = storage.length, keys = [];
            if (pat) for (;lim > i; ) {
                var key = storage.key(i++);
                pat.exec(key) && keys.push(key);
            } else for (;lim > i; ) keys.push(storage.key(i++));
            for (i = 0, lim = keys.length; lim > i; ) storage.removeItem(keys[i++]);
        }
    }
    function listSession(name) {
        var keys = [];
        if ("string" == typeof name && (name = RegExp("^" + fdjtString.escapeRX(name), "g")), 
        window.sessionStorage) {
            var storage = window.sessionStorage, i = 0, lim = storage.length, key = !1;
            if (name) {
                if (name instanceof RegExp) for (;lim > i; ) key = storage.key(i++), key.search(name) >= 0 && keys.push(key);
            } else for (;lim > i; ) keys.push(storage.key(i++));
        }
        return keys;
    }
    function setLocal(name, val, unparse) {
        if (!name) throw {
            error: "bad name",
            name: name
        };
        if (val === void 0) throw {
            error: "undefined value",
            name: name
        };
        if (!val) return dropLocal(name), void 0;
        if (unparse && (val = JSON.stringify(val)), window.localStorage) if (name instanceof RegExp) {
            for (var keys = [], storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                var key = storage.key(i++);
                key.search(name) >= 0 && keys.push(key);
            }
            for (i = 0, lim = keys.length; lim > i; ) storage[keys[i++]] = val;
        } else window.localStorage[name] = val;
    }
    function getLocal(name, parse) {
        if (name) {
            if (window.localStorage) {
                if (name instanceof RegExp) {
                    for (var storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                        var key = storage.key(i++);
                        if (key.search(name) >= 0) return parse ? JSON.parse(storage[key]) : storage[key];
                    }
                    return !1;
                }
                var val = window.localStorage[name];
                return val ? parse ? JSON.parse(val) : val : !1;
            }
            return !1;
        }
        throw {
            error: "bad name",
            name: name
        };
    }
    function pushLocal(name, val) {
        if (!name) throw {
            error: "bad name",
            name: name
        };
        var fetched = window.localStorage[name], array = !1;
        if (fetched) {
            if (array = JSON.parse(fetched), Array.isArray(array) || (array = [ array ]), !(0 > array.indexOf(val))) return !1;
            array.push(val);
        } else array = [ val ];
        return window.localStorage[name] = JSON.stringify(array), !0;
    }
    function removeLocal(name, val) {
        if (!name) throw {
            error: "bad name",
            name: name
        };
        var fetched = window.localStorage[name];
        if (fetched) {
            var loc, array = JSON.parse(fetched);
            if (array === val) return dropLocal(name), void 0;
            if (!Array.isArray(array)) return;
            if (loc = array.indexOf(val), 0 > loc) return;
            array.splice(loc, 1), window.localStorage[name] = JSON.stringify(array);
        }
        return !0;
    }
    function existsLocal(name) {
        if (name) {
            if (window.localStorage) {
                if (name instanceof RegExp) {
                    for (var storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                        var key = storage.key(i++);
                        if (key.search(name) >= 0) return !0;
                    }
                    return !1;
                }
                var val = window.localStorage[name];
                return val === void 0 ? !1 : !0;
            }
            return !1;
        }
        throw {
            error: "bad name",
            name: name
        };
    }
    function findLocal(name, val, parse) {
        if (window.localStorage) {
            for (var result = {}, storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                var key = storage.key(i++);
                if (!name || key.search(name) >= 0) {
                    var v = storage[key];
                    if (!val || v.search(val) >= 0) {
                        if (parse) try {
                            v = JSON.parse(v);
                        } catch (ex) {}
                        result[key] = v;
                    }
                }
            }
            return result;
        }
        return !1;
    }
    function dropLocal(name) {
        if (!window.localStorage) return !1;
        if (!(name instanceof RegExp)) return window.localStorage.removeItem(name);
        for (var drop = [], storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
            var key = storage.key(i++);
            key.search(name) >= 0 && drop.push(key);
        }
        for (i = 0, lim = drop.length; lim > i; ) storage.removeItem(drop[i++]);
    }
    function listLocal(name) {
        var keys = [];
        if ("string" == typeof name && (name = RegExp("^" + fdjtString.escapeRX(name), "g")), 
        window.localStorage) {
            var storage = window.localStorage, i = 0, lim = storage.length, key = !1;
            if (name) {
                if (name instanceof RegExp) for (;lim > i; ) key = storage.key(i++), key.search(name) >= 0 && keys.push(key);
            } else for (;lim > i; ) keys.push(storage.key(i++));
        }
        return keys;
    }
    function clearLocal(pat) {
        if ("string" == typeof pat && (pat = RegExp(".*" + pat + ".*")), window.localStorage) {
            var storage = window.localStorage, i = 0, lim = storage.length, keys = [];
            if (pat) for (;lim > i; ) {
                var key = storage.key(i++);
                pat.exec(key) && keys.push(key);
            } else for (;lim > i; ) keys.push(storage.key(i++));
            for (i = 0, lim = keys.length; lim > i; ) storage.removeItem(keys[i++]);
        }
    }
    function getParam(from, name, multiple, matchcase, verbatim, start) {
        var results = [], ename = encodeURIComponent(name), namepat = RegExp("(&|^)" + ename + "(=|&|$)", matchcase ? "g" : "gi");
        for (start = from.search(namepat); start >= 0; ) {
            "&" === from[start] && start++;
            var valstart = start + ename.length, valstring = from.slice(valstart + 1), end = valstring.search(/(&|$)/g);
            if ("=" === from[valstart]) {
                if (0 >= end) {
                    if (results.push(""), !multiple) break;
                } else if (results.push(valstring.slice(0, end)), end = end + valstart + 1, !multiple) break;
            } else {
                if (!multiple) return verbatim ? from.slice(start, end) : querydecode(from.slice(start, end));
                results.push(from.slice(start, end));
            }
            end > 0 && (from = from.slice(end), start = from.search(namepat));
        }
        if (!verbatim) for (var i = 0, lim = results.length; lim > i; ) results[i] = querydecode(results[i]), 
        i++;
        return multiple ? results : results.length ? results[0] : !1;
    }
    function getQuery(name, multiple, matchcase, verbatim) {
        if (!location.search) return multiple ? [] : !1;
        var from = location.search;
        return "?" === from[0] && (from = from.slice(1)), getParam(from, name, multiple, matchcase, verbatim);
    }
    function getHash(name, multiple, matchcase, verbatim) {
        if (!location.hash) return multiple ? [] : !1;
        var from = location.hash;
        return "#" === from[0] && (from = from.slice(1)), getParam(location.hash, name, multiple, matchcase, verbatim);
    }
    function querydecode(string) {
        return decodeURIComponent ? decodeURIComponent(string) : string.replace(/%3A/gi, ":").replace(/%2F/gi, "/").replace(/%3F/gi, "?").replace(/%3D/gi, "=").replace(/%20/gi, " ").replace(/%40/gi, "@").replace(/%23/gi, "#");
    }
    function test_opt(pos, neg) {
        for (var pospat = pos && RegExp("\\b" + pos + "\\b"), negpat = neg && negative_opt_pat(neg), i = 2; arguments.length > i; ) {
            var arg = arguments[i++];
            if (arg) {
                if ("string" == typeof arg) {
                    if (pospat && arg.search(pospat) >= 0) return !0;
                    if (negpat && arg.search(negpat) >= 0) return !1;
                    continue;
                }
                if (arg.length) {
                    for (var j = 0, len = arg.length; len > j; ) {
                        if (pos && arg[j] === pos) return !0;
                        if (neg && arg[j] === neg) return !1;
                        j++;
                    }
                    return !1;
                }
            } else ;
        }
        return !1;
    }
    function negative_opt_pat(neg) {
        if (neg) {
            if ("string" == typeof neg) return RegExp("\\b" + neg + "\\b", "gi");
            if (neg.length) {
                for (var rule = "\\b(", i = 0; neg.length > i; ) {
                    var name = neg[i];
                    i > 0 && (rule += "|"), rule = rule + "(" + name + ")", i++;
                }
                return rule += ")\\b", RegExp(rule, "gi");
            }
            return !1;
        }
        return neg;
    }
    function zeropad(string, len) {
        return string.length === len ? string : string.length > len ? string.slice(0, len) : zeros.slice(0, len - string.length) + string;
    }
    function getUUID(node) {
        var now = new Date().getTime();
        last_time > now ? (now = 1e4 * now, clockid++) : now === last_time ? now = 1e4 * now + msid++ : (now = 1e4 * now, 
        msid = 1), now += 122192928e9, node || (node = nodeid);
        var timestamp = now.toString(16), tlen = timestamp.length;
        return 15 > tlen && (timestamp = zeros.slice(0, 15 - tlen) + timestamp), timestamp.slice(7) + "-" + timestamp.slice(3, 7) + "-1" + timestamp.slice(0, 3) + "-" + (32768 + clockid % 16384).toString(16) + "-" + (node ? "number" == typeof node ? zeropad(node.toString(16), 12) : zeropad(node, 12) : nodeid);
    }
    function versionInfo() {
        for (var start, s = navigator.userAgent, result = {}; (start = s.search(/\w+\/\d/g)) >= 0; ) {
            var slash = s.indexOf("/", start), afterslash = s.slice(slash + 1), num_end = afterslash.search(/\W/), numstring = afterslash.slice(0, num_end);
            try {
                result[s.slice(start, slash)] = parseInt(numstring, 10);
            } catch (ex) {
                result[s.slice(start, slash)] = numstring;
            }
            s = afterslash.slice(num_end);
        }
        return result.browser = result.Chrome ? "Chrome" : result.Opera ? "Opera" : result.Safari ? "Safari" : result.Safari && result.Mobile ? "MobileSafari" : result.Firefox ? "Firefox" : result.Explorer || result.IE || result.InternetExplorer || result.MSIE ? "IE" : result.Mozilla ? "Mozilla" : "Browser", 
        result.platform = navigator.platform || "Turing", result;
    }
    function getStyleTag() {
        var tag = window.getComputedStyle(document.body, ":after").getPropertyValue("content");
        return tag = tag.replace(/"/g, "");
    }
    function getURL(keepquery, keephash) {
        var url = window.location.href, hashpos = url.indexOf("#"), qpos = url.indexOf("?"), hash = keephash && hashpos >= 0 && url.slice(hashpos + 1), query = keepquery && qpos >= 0 && (hashpos >= 0 ? url.slice(qpos + 1, hashpos) : url.slice(qpos + 1));
        return url = qpos >= 0 ? url.slice(0, qpos) : hashpos >= 0 ? url.slice(0, hashpos) : url, 
        url + (query ? "?" + query : "") + (hash ? "#" + hash : "");
    }
    var fdjtLog = fdjt.Log, fdjtString = fdjt.String;
    fdjtState.domain = !1, fdjtState.path = !1, fdjtState.duration = !1, fdjtState.getCookie = getCookie, 
    fdjtState.setCookie = setCookie, fdjtState.clearCookie = clearCookie, fdjtState.setSession = setSession, 
    fdjtState.getSession = getSession, fdjtState.existsSession = existsSession, fdjtState.dropSession = dropSession, 
    fdjtState.clearSession = clearSession, fdjtState.listSession = listSession, fdjtState.setLocal = setLocal, 
    fdjtState.getLocal = getLocal, fdjtState.pushLocal = pushLocal, fdjtState.removeLocal = removeLocal, 
    fdjtState.existsLocal = existsLocal, fdjtState.findLocal = findLocal, fdjtState.dropLocal = dropLocal, 
    fdjtState.listLocal = listLocal, fdjtState.clearLocal = clearLocal, fdjtState.getParam = getParam, 
    fdjtState.getQuery = getQuery, fdjtState.getHash = getHash, fdjtState.testOption = test_opt, 
    fdjtState.argVec = function(argobj, start) {
        for (var i = start || 0, result = Array(argobj.length - i); argobj.length > i; ) result[i - start] = argobj[i], 
        i++;
        return result;
    };
    var zeros = "000000000000000000000000000000000000000000000000000000000000000", nodeid = zeropad((Math.floor(65536 * Math.random()).toString(16) + Math.floor(65536 * Math.random()).toString(16) + Math.floor(65536 * Math.random()).toString(16) + (1 | Math.floor(65536 * Math.random()))).toString(16), 12), clockid = Math.floor(16384 * Math.random()), msid = 1, last_time = new Date().getTime();
    return fdjtState.getNodeID = function() {
        return nodeid;
    }, fdjtState.setNodeID = function(arg) {
        if ("number" == typeof arg) nodeid = zeropad(arg.toString(16), 12); else {
            if ("string" != typeof arg) throw {
                error: "invalid node id",
                value: arg
            };
            if (!(0 > arg.search(/[^0123456789abcdefABCDEF]/))) throw {
                error: "invalid node id",
                value: arg
            };
            nodeid = zeropad(arg, 12);
        }
    }, fdjtState.getUUID = getUUID, fdjtState.versionInfo = versionInfo, fdjtState.getStyleTag = getStyleTag, 
    fdjtState.getURL = getURL, fdjtState;
}(), fdjt.iDB = function() {
    "use strict";
    var iDB = {}, device = fdjt.device;
    return !window.indexedDB || device.ios && device.standalone ? (iDB.indexedDB = idbModules.shimIndexedDB, 
    iDB.IDBDatabase = idbModules.IDBDatabase, iDB.IDBTransaction = idbModules.IDBTransaction, 
    iDB.IDBCursor = idbModules.IDBCursor, iDB.IDBKeyRange = idbModules.IDBKeyRange) : (iDB.indexedDB = window.indexedDB, 
    iDB.IDBDatabase = window.IDBDatabase, iDB.IDBTransaction = window.IDBTransaction, 
    iDB.IDBCursor = window.IDBCursor, iDB.IDBKeyRange = window.IDBKeyRange, iDB.IDBTransaction = window.IDBTransaction, 
    iDB.IDBTransaction = window.IDBTransaction), iDB;
}();

var _fdjt_init;

fdjt.DOM = function() {
    "use strict";
    function fdjtDOM(spec) {
        var node;
        if (spec.nodeType) node = spec; else {
            if ("string" == typeof spec && "<" === spec[0]) {
                var container = document.createDocumentFragment();
                container.innerHTML = spec;
                var children = container.childNodes;
                return 1 === children.length ? children[0] : container;
            }
            if ("string" == typeof spec && "#" === spec[0] && (node = document.getElementById(spec.slice(1)))) ; else if ("string" == typeof spec) {
                var elts = spec.match(css_selector_regex);
                if (!elts) return fdjtLog.warn("bad CSS spec"), !1;
                var classname = !1;
                node = document.createElement(elts[0]);
                for (var i = 1, len = elts.length; len > i; ) {
                    var sel = elts[i++];
                    if ("#" === sel[0]) node.id = sel.slice(1); else if ("." === sel[0]) classname = classname ? classname + " " + sel.slice(1) : sel.slice(1); else if ("[" === sel[0]) {
                        var eqpos = sel.indexOf("=");
                        if (0 > eqpos) node.setAttribute(sel.slice(1, sel.length - 1), sel.slice(1, sel.length - 1)); else {
                            var val = sel.slice(eqpos + 1, sel.length - 1);
                            ("'" === val[0] && "'" === val[val.length - 1] || '"' === val[0] && '"' === val[val.length - 1]) && (val = val.slice(1, val.length - 1)), 
                            node.setAttribute(sel.slice(1, eqpos), val);
                        }
                    }
                }
                classname && (node.className = classname);
            } else {
                node = document.createElement(spec.tagName || "span");
                for (var attrib in spec) "tagName" !== attrib && node.setAttribute(attrib, spec[attrib]);
            }
        }
        for (var j = 1, lim = arguments.length; lim > j; ) domappend(node, arguments[j++]);
        return node;
    }
    function getIE() {
        if ("Microsoft Internet Explorer" === navigator.appName) {
            var rv, ua = navigator.userAgent, re = RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})");
            return rv = null !== re.exec(ua) ? parseFloat(re.$1) : 1, 0 >= rv && (rv = 1), rv;
        }
        return 0;
    }
    function fdjtID(id) {
        return id && (document.getElementById(id) || "#" === id[0] && document.getElementById(id.slice(1)));
    }
    function domappend(node, content, i) {
        if (0 === content) node.appendChild(document.createTextNode("0")); else {
            if (!content) return;
            if (content.nodeType) node.appendChild(content); else if ("string" == typeof content) node.appendChild(document.createTextNode(content)); else {
                if (content.toDOM) return domappend(node, content.toDOM());
                if (content.toHTML) return domappend(node, content.toHTML());
                if (content.length && (!i || content.length > i)) {
                    var frag = window.DocumentFragment && node instanceof window.DocumentFragment ? node : document.createDocumentFragment(), elts = window.NodeList && content instanceof window.NodeList ? TOA(content) : content, len = elts.length;
                    for (i === void 0 && (i = 0); len > i; ) {
                        var elt = elts[i++];
                        "string" == typeof elt ? frag.appendChild(document.createTextNode(elt)) : "number" == typeof elt ? frag.appendChild(document.createTextNode("" + elt)) : elt && (elt.nodeType ? frag.appendChild(elt) : elt.length ? domappend(frag, elt, 0) : elt.toDOM ? domappend(frag, elt.toDOM()) : elt.toHTML ? domappend(frag, elt.toHTML()) : elt.toString ? frag.appendChild(document.createTextNode("" + elt)) : frag.appendChild(document.createTextNode("" + elt)));
                    }
                    node !== frag && node.appendChild(frag);
                } else content.length || node.appendChild(document.createTextNode("" + content));
            }
        }
        return node;
    }
    function dominsert(before, content, i) {
        var node = before.parentNode;
        if (!content.nodeType || content !== before) {
            if (content.nodeType) node.insertBefore(content, before); else if ("string" == typeof content) node.insertBefore(document.createTextNode(content), before); else {
                if (content.toDOM) return dominsert(before, content.toDOM());
                if (content.toHTML) return dominsert(before, node, content.toHTML());
                if (content.length - i > 1) {
                    var frag = window.documentFragment && node instanceof window.DocumentFragment ? node : document.createDocumentFragment();
                    return domappend(frag, content, i), node.insertBefore(frag, before), before;
                }
                if (content.length) {
                    var c = content[i];
                    if (c === before) return;
                    node.insertBefore(c, before);
                } else node.insertBefore(document.createTextNode("" + content), before);
            }
            return node;
        }
    }
    function toArray(arg) {
        return aslice.call(arg);
    }
    function extendArray(result, arg) {
        for (var i = 0, lim = arg.length; lim > i; ) result.push(arg[i]), i++;
        return result;
    }
    function TOA(arg, start) {
        return arg.constructor === Array || arg instanceof Array ? start ? arg.slice(start) : arg : start ? aslice.call(arg, start || 0) : aslice.call(arg, start || 0);
    }
    function wrapChildren(node, spec) {
        spec || (spec = "div.fdjtwrapper");
        var wrapper = getFirstChild(node, spec);
        return wrapper && wrapper.nodeType && wrapper.parentNode === node ? wrapper : (wrapper = fdjtDOM(spec, toArray(node.childNodes)), 
        node.appendChild(wrapper), wrapper);
    }
    function unwrapChildren(nodes, cxt) {
        "string" == typeof nodes ? nodes = cxt ? fdjt.DOM.getChildren(cxt, nodes) : fdjt.DOM.$(nodes) : nodes.nodeType && (nodes = [ nodes ]);
        for (var i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++], frag = document.createDocumentFragment();
            domappend(frag, toArray(node.childNodes)), node.parentNode.replaceChild(frag, node);
        }
    }
    function parsePX(arg, dflt) {
        if (dflt === void 0 && (dflt = 0), 0 === arg) return 0;
        if (arg) {
            if ("none" === arg) return dflt;
            if ("auto" === arg) return dflt;
            if ("number" == typeof arg) return arg;
            if ("string" == typeof arg) {
                var len = arg.length, num = !1;
                return num = len > 2 && "x" === arg[len - 1] && "p" === arg[len - 2] ? parseInt(arg.slice(0, -2), 10) : parseInt(arg, 10), 
                0 === num ? 0 : isNaN(num) ? dflt : "number" == typeof num ? num : dflt;
            }
            return !1;
        }
        return dflt;
    }
    function getLineHeight(node, style) {
        style || (style = getStyle(node));
        var lh = style.lineHeight, fs = style.fontSize;
        return "normal" === lh ? parsePX(fs) : lh.search(/px$/) > 0 ? parsePX(lh) : lh.search(/%$/) > 0 ? parseFloat(lh.slice(0, -1)) / 100 * parsePX(fs) : parsePX(fs);
    }
    function classPat(name) {
        var rx = RegExp("\\b" + name + "\\b", "g");
        return classpats[name] = rx, rx;
    }
    function string_trim(string) {
        var start = string.search(/\S/), end = string.search(/\s+$/g);
        return 0 === start && 0 > end ? string : string.slice(start, end);
    }
    function nodeString(node) {
        if (3 === node.nodeType) return "<'" + node.value + "'>";
        if (1 === node.nodeType) {
            var output = "<" + node.tagName;
            return node.id && (output = output + "#" + node.id), "input" === node.tagName ? (output = output + "[type=" + node.type + "]", 
            output = output + "[name=" + node.name + "]") : "textarea" === node.tagName ? output = output + "[name=" + node.name + "]" : "img" === node.tagName && (node.alt ? output = output + "[alt=" + node.alt + "]" : node.src && (output = output + "[src=" + node.src + "]")), 
            "string" == typeof node.className && (output = output + "." + node.className.replace(/\s+/g, ".")), 
            output + ">";
        }
        return "" + node;
    }
    function make(spec, content, data, init) {
        var dom = fdjtDOM(spec);
        return init || (init = data), data && (content = fdjt.Template(content, data)), 
        init.id && !dom.id && (dom.id = init.id), init.title && !dom.title && (dom.title = init.title), 
        init.name && !dom.name && (dom.name = init.name), init.href && !dom.href && (dom.href = init.href), 
        init.value && !dom.value && (dom.value = init.value), init.src && !dom.src && (dom.src = init.src), 
        init.alt && !dom.alt && (dom.alt = init.alt), addListeners(dom, init), dom;
    }
    function getElementValues(elt, spec, parse, multiple) {
        var candidates = [];
        if (candidates = spec.search(/(\.|#|\[|,)/g) >= 0 ? getChildren(elt, spec) : elt.getElementsByClassName ? elt.getElementsByClassName(spec) : getChildren(), 
        0 === candidates.length) return multiple ? [] : !1;
        if (multiple) {
            for (var values = [], i = 0, lim = multiple.length; lim > i; ) {
                var txt = candidates[i++].innerText;
                parse ? values.push(JSON.parse(txt)) : values.push(txt);
            }
            return values;
        }
        return parse ? JSON.parse(candidates[0].innerText) : candidates[0].innerText;
    }
    function getElementValue(elt, spec, parse) {
        return getElementValues(elt, spec, parse, !1);
    }
    function hasClass(elt, classname, attrib) {
        if (elt && ("string" != typeof elt || (elt = document.getElementById(elt)))) {
            var classinfo = attrib ? elt.getAttribute(attrib) || "" : elt.className;
            if ("string" != typeof classinfo || "" === classinfo) return !1;
            if (classname === !0) return !0;
            if (classinfo === classname) return !0;
            if ("string" == typeof classname) {
                if (0 > classinfo.indexOf(" ")) return !1;
                classname = classpats[classname] || classPat(classname);
            }
            return classinfo.search(classname) >= 0 ? !0 : !1;
        }
    }
    function addClass(elt, classname, attrib) {
        if (elt && classname) {
            if ("string" == typeof elt) {
                if (!(elt = document.getElementById(elt))) return;
            } else {
                if (window.NodeList && elt instanceof window.NodeList) return addClass(TOA(elt), classname, attrib);
                if (elt.length && !elt.nodeType) {
                    for (var elts = TOA(elt), i = 0, lim = elts.length; lim > i; ) addClass(elts[i++], classname, attrib || !1);
                    return;
                }
                if (!attrib && elt.classList && "string" == typeof classname) return elt.classList.contains(classname) || elt.classList.add(classname), 
                void 0;
            }
            var classinfo = (attrib ? elt.getAttribute(attrib) || "" : elt.className) || null;
            if (classinfo && "string" != typeof classinfo) return fdjtLog.warn("Non string classname for %o", elt), 
            !1;
            if (!classinfo) return elt.className = classname, !0;
            var class_regex = classpats[classname] || classPat(classname), newinfo = classinfo;
            return classinfo === classname ? !1 : classinfo.search(class_regex) >= 0 ? !1 : (newinfo = classname + " " + classinfo, 
            attrib ? (elt.setAttribute(attrib, newinfo), elt.className = elt.className) : elt.className = newinfo, 
            !0);
        }
    }
    function dropClass(elt, classname, attrib, keep) {
        if (elt) {
            if ("string" == typeof elt) {
                if (!(elt = document.getElementById(elt))) return;
            } else {
                if (window.NodeList && elt instanceof window.NodeList) return dropClass(TOA(elt), classname, attrib);
                if (elt.length && !elt.nodeType) {
                    for (var elts = TOA(elt), i = 0, lim = elts.length; lim > i; ) dropClass(elts[i++], classname, attrib || !1);
                    return;
                }
                if (!attrib && elt.classList && "string" == typeof classname) return elt.classList.contains(classname) && elt.classList.remove(classname), 
                void 0;
            }
            var classinfo = (attrib ? elt.getAttribute(attrib) || "" : elt.className) || null;
            if ("string" != typeof classinfo || "" === classinfo) return !1;
            var class_regex = "string" == typeof classname ? classpats[classname] || classPat(classname) : classname, newinfo = classinfo;
            if (classinfo === classname) newinfo = ""; else {
                if (!(classinfo.search(class_regex) >= 0)) return !1;
                newinfo = classinfo.replace(class_regex, "");
            }
            return newinfo && (newinfo = newinfo.replace(whitespace_pat, " ").replace(trimspace_pat, "")), 
            attrib ? newinfo ? (elt.setAttribute(attrib, newinfo), elt.className = elt.className) : keep || (elt.removeAttribute(attrib), 
            elt.className = elt.className) : elt.className = newinfo ? newinfo : keep ? "" : "", 
            !0;
        }
    }
    function swapClass(elt, drop, add, attrib) {
        dropClass(elt, drop, attrib), addClass(elt, add, attrib);
    }
    function setClass(elt, classname, add) {
        "string" == typeof elt && (elt = document.getElementById(elt)), add ? addClass(elt, classname) : dropClass(elt, classname);
    }
    function toggleClass(elt, classname, attrib, keep) {
        if ("string" == typeof elt) elt = document.getElementById(elt); else {
            if (window.NodeList && elt instanceof window.NodeList) return toggleClass(TOA(elt), classname, attrib);
            if (elt.length && !elt.nodeType) {
                for (var elts = TOA(elt), i = 0, lim = elts.length; lim > i; ) toggleClass(elts[i++], classname, attrib || !1);
                return;
            }
            if (!attrib && elt.classList && "string" == typeof classname) return elt.classList.toggle(classname), 
            void 0;
        }
        var classinfo = (attrib ? elt.getAttribute(attrib) || "" : elt.className) || null;
        if ("string" != typeof classinfo || "" === classinfo) return attrib ? elt.setAttribute(attrib, classname) : elt.className = classname, 
        !0;
        var class_regex = "string" == typeof classname ? classpats[classname] || classPat(classname) : classname, newinfo = classinfo;
        if (classinfo === classname) newinfo = ""; else {
            if (!(classinfo.search(class_regex) >= 0)) return attrib ? elt.setAttribute(attrib, classinfo + " " + classname) : elt.className = classinfo + " " + classname, 
            !0;
            newinfo = classinfo.replace(class_regex, "");
        }
        return newinfo && (newinfo = newinfo.replace(whitespace_pat, " ").replace(trimspace_pat, "")), 
        attrib ? newinfo ? (elt.setAttribute(attrib, newinfo), elt.className = elt.className) : keep || (elt.removeAttribute(attrib), 
        elt.className = elt.className) : elt.className = newinfo, !1;
    }
    function toggleParent(node, spec, classname, attrib, keep) {
        var parent = getParent(node, spec);
        parent && toggleClass(parent, classname, attrib, keep);
    }
    function isTextInput(target) {
        return "INPUT" === target.tagName && 0 === target.type.search(text_input_types) || "TEXTAREA" === target.tagName;
    }
    function isImage(target) {
        return "IMG" === target.tagName;
    }
    function Selector(spec, tagcs) {
        var i, lim;
        if (!spec) return this;
        if (selectors[spec]) return selectors[spec];
        if (!(this instanceof Selector)) return Selector.call(new Selector(), spec);
        if (Array.isArray(spec) || "string" == typeof spec && spec.indexOf(",") > 0) {
            var compound = [], specs = [];
            if ("string" == typeof spec) specs = spec.split(","); else for (var j = 0, jlim = spec.length; jlim > j; ) "string" != typeof spec[j] ? j++ : spec[j].indexOf(",") >= 0 ? specs = specs.concat(spec[j++].split(",")) : specs.push(spec[j++]);
            for (i = 0, lim = specs.length; lim > i; ) {
                var sub = string_trim(specs[i++]), sel = new Selector(sub);
                sel && compound.push(sel);
            }
            return this.compound = compound, selectors[spec] = this, this.spec = "string" == typeof spec ? spec : specs.join(","), 
            this;
        }
        var elts = spec.match(css_selector_regex), classes = [], classnames = [], attribs = !1;
        if (elts || fdjtLog.warn("Couldn't parse spec %s", spec), this.tag = !1, elts) for (i = 0, 
        lim = elts.length, "." !== elts[0][0] && "#" !== elts[0][0] && "[" !== elts[0][0] && (this.tag = tagcs ? elts[0] : elts[0].toUpperCase(), 
        i = 1); lim > i; ) if ("#" === elts[i][0]) this.id = elts[i++].slice(1); else if ("." === elts[i][0]) classnames.push(elts[i].slice(1)), 
        classes.push(classPat(elts[i++].slice(1))); else if ("[" === elts[i][0]) {
            var aelts = elts[i++], eltsend = aelts.length - 1;
            attribs || (attribs = {});
            var eqpos = aelts.indexOf("=");
            0 > eqpos ? attribs[aelts.slice(1, eltsend)] = !0 : attribs[aelts.slice(1, eqpos)] = "~" === aelts[eqpos + 1] ? classPat(aelts.slice(eqpos + 2, eltsend)) : aelts.slice(eqpos + 1, eltsend);
        } else fdjtLog.uhoh("weird elts %o", elts[i++]);
        return classes.length ? (this.classes = classes, this.classnames = classnames) : this.classes = !1, 
        this.attribs = attribs ? attribs : !1, this.rank = [ 0, this.id ? 1 : 0, classnames.length + (attribs ? attribs.length : 0), 1 ], 
        selectors[spec] = this, this.spec = spec, this;
    }
    function gatherByClass(node, pat, results) {
        if (1 === node.nodeType) {
            var classname = node.className;
            "string" == typeof classname && classname.search(pat) >= 0 && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) gatherByClass(children[i++], pat, results);
        }
    }
    function gatherByTag(node, tag, results) {
        if (1 === node.nodeType) {
            ("string" == typeof tag ? node.tagName.toLowerString() === tag : tag instanceof RegExp && tag.match(node.tagName)) && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) gatherByTag(children[i++], tag, results);
        }
    }
    function gatherByAttrib(node, attrib, val, results) {
        if (1 === node.nodeType) {
            node.getAttribute(attrib) && ("string" == typeof val ? node.getAttribute(attrib) === val : node.getAttribute(attrib).search(val) >= 0) && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) gatherByAttrib(children[i++], attrib, val, results);
        }
    }
    function gather_children(node, pat, attrib, results) {
        attrib ? "class" === attrib ? gatherByClass(node, pat, results) : "tagName" === attrib ? gatherByTag(node, pat, results) : gatherByAttrib(node, attrib, pat, results) : gatherByClass(node, pat, results);
    }
    function getParent(elt, parent) {
        if ("string" == typeof elt && (elt = "#" === elt[0] ? document.getElementById(elt.slice(1)) : document.getElementById(elt)), 
        elt) {
            if (parent) {
                if (parent.nodeType) {
                    for (;elt; ) {
                        if (elt === parent) return parent;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if ("function" == typeof parent) {
                    for (;elt; ) {
                        if (parent(elt)) return elt;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if (parent instanceof Selector) {
                    for (;elt; ) if (1 !== elt.nodeType) elt = elt.parentNode; else {
                        if (parent.match(elt)) return elt;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if (parent instanceof RegExp) {
                    for (;elt; ) if (1 !== elt.nodeType) elt = elt.parentNode; else {
                        if (elt.className && parent.test(elt.className)) return elt;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if ("string" == typeof parent) return getParent(elt, new Selector(parent));
                throw {
                    error: "invalid parent spec"
                };
            }
            return !1;
        }
        return !1;
    }
    function getChildNodes(node) {
        return 1 !== node.nodeType ? [] : node.childNodes ? toArray(node.childNodes) : [];
    }
    function getChildren(node, classname, attrib, results) {
        if ("string" == typeof node && (node = fdjtID(node)), !node) return [];
        if (results || (results = []), attrib) {
            if ("string" != typeof attrib) throw {
                error: "bad selector arg",
                selector: classname
            };
            gather_children(node, classname, attrib || !1, results);
        } else if ("function" == typeof classname) filter_children(node, classname, results); else if (classname instanceof RegExp) regexp_filter_children(node, classname, results); else {
            if (classname instanceof Selector) return classname.find(node, results);
            if ("string" == typeof classname) return usenative && node.querySelectorAll ? node.querySelectorAll(classname) : getChildren(node, new Selector(classname), !1, results);
            if (classname.length) for (var i = 0, lim = classname.length; lim > i; ) getChildren(node, classname[i++], attrib, results);
        }
        return results;
    }
    function getFirstChild(elt, spec) {
        var children = getChildren(elt, spec);
        return children.length ? children[0] : !1;
    }
    function filter_children(node, filter, results) {
        if (1 === node.nodeType) {
            filter(node) && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) filter_children(children[i++], filter, results);
        }
    }
    function regexp_filter_children(node, rx, results) {
        if (1 === node.nodeType) {
            var classname = node.className;
            "string" == typeof classname && classname.search(rx) >= 0 && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) regexp_filter_children(children[i++], rx, results);
        }
    }
    function getFirstElement(node) {
        return node.firstElementChild ? node.firstElementChild : node.children && node.children.length ? node.children[0] : !1;
    }
    function getLastElement(node) {
        return node.lastElementChild ? node.lastElementChild : node.children && node.children.length ? node.children[node.children.length - 1] : !1;
    }
    function remove_node(node) {
        if (node instanceof Array) for (var i = 0, lim = node.length; lim > i; ) remove_node(node[i++]); else {
            var cur = node;
            "string" == typeof node && (cur = "#" === node[0] ? document.getElementById(node.slice(1)) : document.getElementById(node)), 
            cur && cur.parentNode ? cur.parentNode.removeChild(cur) : cur ? fdjtLog.uhoh("Looks like %o has already been removed (no parent)", cur) : fdjtLog.uhoh("Can't find %o to remove it", node);
        }
    }
    function removeChildren(node) {
        for (var children = node.childNodes, n = children.length - 1; n >= 0; ) node.removeChild(children[n--]);
    }
    function DOMappend(node) {
        "string" == typeof node && (node = document.getElementById(node)), domappend(node, aslice.call(arguments), 1);
    }
    function DOMprepend(node) {
        "string" == typeof node && (node = document.getElementById(node)), node.firstChild ? dominsert(node.firstChild, aslice.call(arguments), 1) : domappend(node, aslice.call(arguments), 1);
    }
    function DOMinsertBefore(before) {
        "string" == typeof before && (before = document.getElementById(before)), dominsert(before, aslice.call(arguments), 1);
    }
    function DOMinsertAfter(after) {
        "string" == typeof after && (after = document.getElementById(after)), after.nextSibling ? dominsert(after.nextSibling, aslice.call(arguments), 1) : domappend(after.parentNode, aslice.call(arguments), 1);
    }
    function tag_spec(spec, tag) {
        if (spec) {
            if ("string" == typeof spec) {
                var wordstart = spec.search(/\w/g), puncstart = spec.search(/\W/g);
                return 0 > puncstart ? tag + "." + spec : 0 !== wordstart ? tag + spec : spec;
            }
            return spec.tagName ? spec : (spec.tagName = tag, spec);
        }
        return tag;
    }
    function getInputs(root, name, type) {
        var results = [];
        if ("string" == typeof root) {
            var root_elt = document.getElementById(root);
            root_elt || fdjtLog.warn("Couldn't resolve %s to an object", root), root = root_elt;
        }
        if (!root) return results;
        for (var inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name || type && inputs[i].type !== type ? i++ : results.push(inputs[i++]);
        if (!type || "textarea" === type || "text" === type) for (inputs = root.getElementsByTagName("textarea"), 
        i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name || type && inputs[i].type !== type ? i++ : results.push(inputs[i++]);
        if (!type || "button" === type || "submit" === type) for (inputs = root.getElementsByTagName("button"), 
        i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name || type && inputs[i].type !== type ? i++ : results.push(inputs[i++]);
        if (!type || "select" === type) for (inputs = root.getElementsByTagName("select"), 
        i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name ? i++ : results.push(inputs[i++]);
        return results;
    }
    function getInputValues(root, name) {
        for (var results = [], inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            input.name === name && ("checkbox" !== input.type && "radio" !== input.type || input.checked) && results.push(input.value);
        }
        return results;
    }
    function getInputValue(root, name, n) {
        for (var r = 0, inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            if (!input.disabled && input.name === name && ("checkbox" !== input.type && "radio" !== input.type || input.checked)) {
                if (!n) return input.value;
                if (r === n) return input.value;
                r++;
            }
        }
        return !1;
    }
    function getInputsFor(root, name, value) {
        if ("string" == typeof root && (root = document.getElementById(root)), !root) return [];
        for (var results = [], inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            input.name === name && input.value === value && results.push(input);
        }
        return results;
    }
    function setInputs(selector, value) {
        if (value) for (var inputs = fdjtDOM.$(selector), i = 0, lim = inputs.length; lim > i; ) inputs[i++].value = value;
    }
    function getStyle(elt, prop) {
        if ("string" == typeof elt && (elt = document.getElementById(elt)), !elt) return elt;
        if (1 !== elt.nodeType) throw "Not an element";
        var style = window.getComputedStyle && window.getComputedStyle(elt, null) || elt.currentStyle;
        return style ? prop ? style[prop] : style : !1;
    }
    function styleString(elt) {
        var result, style = elt.style;
        if (!style) return !1;
        var i = 0, lim = style.length;
        if (0 === lim) return !1;
        for (;lim > i; ) {
            var p = style[i], v = style[p];
            result = 0 === i ? p + ": " + v : result + "; " + p + ": " + v, i++;
        }
        return result;
    }
    function getDisplayStyle(elt) {
        return elt && elt.nodeType && 1 === elt.nodeType ? window.getComputedStyle && window.getComputedStyle(elt, null) && window.getComputedStyle(elt, null).display || display_styles[elt.tagName] || "inline" : !1;
    }
    function flatten(string) {
        return string.replace(/\s+/, " ");
    }
    function textify(arg, flat, depth, domarkup) {
        if ("number" != typeof depth && (depth = 0), !arg.nodeType) return arg.toString ? "" + arg : "" + arg;
        if (3 === arg.nodeType) return flat ? flatten(arg.nodeValue) : arg.nodeValue;
        if (1 === arg.nodeType) {
            var children = arg.childNodes, style = getStyle(arg), display_type = style.display, position_type = style.position, whitespace = style.whiteSpace, classname = arg.className, string = "", suffix = "";
            if ("normal" !== whitespace && (flat = !1), "none" === display_type) return "";
            if ("static" !== position_type && "" !== position_type) return "";
            if ("string" == typeof classname && ("fdjtskiptext" === classname || classname.search(/\bfdjtskiptext\b/) >= 0)) return "";
            if (!children || 0 === children.length) return domarkup ? arg.alt ? "[" + arg.alt + "]" : "[?]" : "";
            display_type && ("inline" === display_type || (flat ? suffix = " " : "block" === display_type || "table" === display_type || "preformatted" === display_type ? (string = "\n", 
            suffix = "\n") : "table-row" === display_type ? suffix = "\n" : "table-cell" === display_type && (string = "	")));
            for (var i = 0; children.length > i; ) {
                var child = children[i++];
                if (child.nodeType) if (3 === child.nodeType) string += flat ? flatten(child.nodeValue) : child.nodeValue; else {
                    if (1 !== child.nodeType) continue;
                    var stringval = textify(child, flat, !0, domarkup);
                    stringval && (string += stringval);
                }
            }
            return string + suffix;
        }
    }
    function Geometry(elt, root) {
        if (!elt) return this;
        if ("string" == typeof elt && (elt = document.getElementById(elt)), elt) {
            var top = elt.offsetTop, left = elt.offsetLeft, width = elt.offsetWidth, height = elt.offsetHeight, rootp = root && root.offsetParent;
            if (this.elt = elt, this.root = root, elt === root) left = 0, top = 0, bottom = height, 
            right = width; else for (elt = elt.offsetParent; elt && (!root || elt !== root && elt !== rootp); ) top += elt.offsetTop, 
            left += elt.offsetLeft, elt = elt.offsetParent;
            var bottom = top + height, right = left + width;
            return this.left = left, this.top = top, this.width = width, this.height = height, 
            this.right = right, this.bottom = bottom, this;
        }
    }
    function XGeometry(elt, root, withstack) {
        if (withstack = withstack ? [] : !1, !elt) return this;
        "string" == typeof elt && (elt = document.getElementById(elt));
        var top = elt.offsetTop, left = elt.offsetLeft, width = elt.offsetWidth, height = elt.offsetHeight, rootp = root && root.offsetParent, style = getStyle(elt);
        if (this.elt = elt, this.root = root, elt === root) left = 0, top = 0, bottom = height, 
        right = width; else for (elt = elt.offsetParent; elt && (!root || elt !== root && elt !== rootp); ) withstack && withstack.push(elt), 
        top += elt.offsetTop, left += elt.offsetLeft, elt = elt.offsetParent;
        var bottom = top + height, right = left + width;
        if (this.left = left, this.top = top, this.width = width, this.height = height, 
        this.right = right, this.bottom = bottom, style) {
            var t_margin = parsePX(style.marginTop), r_margin = parsePX(style.marginRight), b_margin = parsePX(style.marginBottom), l_margin = parsePX(style.marginLeft), t_padding = parsePX(style.paddingTop), r_padding = parsePX(style.paddingRight), b_padding = parsePX(style.paddingBottom), l_padding = parsePX(style.paddingLeft), t_border = parsePX(style.borderTopWidth), r_border = parsePX(style.borderRightWidth), b_border = parsePX(style.borderBottomWidth), l_border = parsePX(style.borderLeftWidth), outer_width = width + l_margin + r_margin, outer_height = height + t_margin + b_margin, inner_width = width - (l_border + l_padding + r_border + r_padding), inner_height = height - (t_border + t_padding + b_border + b_padding), lh = style.lineHeight, fs = style.fontSize, lhpx = !1;
            lhpx = "normal" === lh ? parsePX(fs) : lh.search(/px$/) > 0 ? parsePX(lh) : lh.search(/%$/) > 0 ? parseFloat(lh.slice(0, -1)) / 100 * parsePX(fs) : parsePX(fs), 
            this.top_margin = t_margin, this.bottom_margin = b_margin, this.left_margin = l_margin, 
            this.right_margin = r_margin, this.top_border = t_border, this.bottom_border = b_border, 
            this.left_border = l_border, this.right_border = r_border, this.top_padding = t_padding, 
            this.bottom_padding = b_padding, this.left_padding = l_padding, this.right_padding = r_padding, 
            this.outer_height = outer_height, this.outer_width = outer_width, this.inner_height = inner_height, 
            this.inner_width = inner_width, this.line_height = lhpx;
        }
        return withstack && (this.stack = withstack), this;
    }
    function getGeometry(elt, root, extra) {
        return extra ? new XGeometry(elt, root) : new Geometry(elt, root);
    }
    function geomString(geom) {
        return +("number" == typeof geom.width ? geom.width : "?") + "x" + ("number" == typeof geom.height ? geom.height : "?") + "@l:" + ("number" == typeof geom.left ? geom.left : "?") + ",t:" + ("number" == typeof geom.top ? geom.top : "?") + "/r:" + ("number" == typeof geom.right ? geom.right : "?") + ",b:" + ("number" == typeof geom.bottom ? geom.bottom : "?");
    }
    function isVisible(elt, partial) {
        if (partial || (partial = !1), elt.offsetParent && elt.offsetParent !== document.body) {
            var container = elt.offsetParent, offtop = elt.offsetTop, offbot = offtop + elt.offsetHeight, offleft = elt.offsetLeft, offright = offleft + elt.offsetWidth, l = container.scrollLeft, r = l + container.clientWidth, t = container.scrollTop, b = t + container.clientHeight;
            return partial ? (offleft >= l && r >= offleft || offright >= l && r >= offright || l > offleft && offright > r) && (offtop >= t && b >= offtop || offbot >= t && b >= offbot || t >= offtop && offbot >= b) : offleft >= l && r >= offleft && offright >= l && r >= offright && offtop >= t && b >= offtop && offbot >= t && b >= offbot;
        }
        for (var top = elt.offsetTop, left = elt.offsetLeft, width = elt.offsetWidth, height = elt.offsetHeight, winx = window.pageXOffset || document.documentElement.scrollLeft || 0, winy = window.pageYOffset || document.documentElement.scrollTop || 0, winxedge = winx + document.documentElement.clientWidth, winyedge = winy + document.documentElement.clientHeight; elt.offsetParent && elt !== window; ) elt = elt.offsetParent, 
        top += elt.offsetTop, left += elt.offsetLeft;
        return elt && elt !== window && elt !== document.body && (elt.scrollTop || elt.scrollLeft) && (fdjtLog("Adjusting for inner DIV"), 
        winx = elt.scrollLeft, winy = elt.scrollTop, winxedge = winx + elt.scrollWidth, 
        winyedge = winy + elt.scrollHeight), partial ? top > winy && winyedge > top && left > winx && winxedge > left || top + height > winy && winyedge > top + height && left + width > winx && winxedge > left + width || (winy > top || winx > left) && top + height > winyedge && left + width > winxedge : top > winy && left > winx && winyedge >= top + height && winxedge >= left + width;
    }
    function isAtTop(elt, delta) {
        delta || (delta = 50);
        for (var top = elt.offsetTop, left = elt.offsetLeft, winy = window.pageYOffset || document.documentElement.scrollTop || 0, winyedge = winy + document.documentElement.clientHeight; elt.offsetParent; ) elt = elt.offsetParent, 
        top += elt.offsetTop, left += elt.offsetLeft;
        return top > winy && winyedge > top && winy + delta > top;
    }
    function textwidth(node) {
        if (3 === node.nodeType) return node.nodeValue.length;
        if (1 !== node.nodeType) return 0;
        var style = getStyle(node), display = style.display, position = style.position;
        if ("none" === display) return 0;
        if ("" !== position && "static" !== position) return 0;
        if ("string" != typeof node.className) return 0;
        if ("fdjtskiptext" === node.className || "string" == typeof node.className && node.className.search(/\bfdjtskiptext/) >= 0) return 0;
        if (node.getAttribute("data-locwidth")) return parseInt(node.getAttribute("data-locwidth"));
        if (node.childNodes) {
            for (var children = node.childNodes, padding = "inline" === display ? 0 : /^(li|td|dt|dd|label|input)$/i.exec(node.tagName) ? 1 : 2, i = 0, lim = children.length, width = 0; lim > i; ) {
                var child = children[i++];
                3 === child.nodeType ? width += child.nodeValue.length : 1 === child.nodeType && (width += textwidth(child));
            }
            return width + 2 * padding;
        }
        return node.alt ? node.alt.length + 2 : 3;
    }
    function countBreaks(arg) {
        return "string" == typeof arg ? arg.match(/\W*\s+\W*/g).length : arg.nodeType ? 1 !== arg.nodeType ? 3 === arg.nodeType ? arg.nodeValue.match(/\W*\s+\W*/g).length : 0 : void 0 : 0;
    }
    function hasContent(node, recur, test, limit) {
        if (node === limit) return !1;
        if (3 === node.nodeType) return node.nodeValue.search(/\w/g) >= 0;
        if (1 !== node.nodeType) return !1;
        if (test && test.match && test.match(node)) return !0;
        if (0 === node.tagName.search(nontext_content)) return !0;
        if ("string" == typeof node.className && node.className.search(/\bfdjtskiptext\b/g) >= 0) return !1;
        if (node.childNodes && node.childNodes.length) {
            for (var children = node.childNodes, i = 0; children.length > i; ) {
                var child = children[i++];
                if (child === limit) return !1;
                if (3 !== child.nodeType) {
                    if (1 === child.nodeType) if (recur) {
                        if (hasContent(child, recur, test, limit)) return !0;
                    } else ;
                } else if (child.nodeValue.search(/\w/g) >= 0) return !0;
            }
            return !1;
        }
        return !1;
    }
    function hasText(node) {
        if (node.childNodes) {
            for (var children = node.childNodes, i = 0; children.length > i; ) {
                var child = children[i++];
                if (3 === child.nodeType && child.nodeValue.search(/\w/g) >= 0) return !0;
            }
            return !1;
        }
        return !1;
    }
    function addListener(node, evtype, handler) {
        if (node || (node = document), "string" == typeof node) {
            var elt = fdjtID(node);
            if (!node) return fdjtLog.warn("Can't find #%s", node), void 0;
            node = elt;
        } else {
            if (Array.isArray && Array.isArray(node) || window.NodeList && node instanceof window.NodeList) {
                for (var i = 0, lim = node.length; lim > i; ) addListener(node[i++], evtype, handler);
                return;
            }
            if (node !== window && !node.nodeType) return fdjtLog.warn("Bad target(s) arg to addListener(%s) %o", evtype, node), 
            void 0;
        }
        if ("title" === evtype) "string" == typeof handler && (node.title = node.title ? "(" + handler + ") " + node.title : handler); else if ("=" === evtype[0]) node[evtype.slice(1)] = handler; else {
            if (node.addEventListener) return node.addEventListener(evtype, handler, !1);
            if (node.attachEvent) return node.attachEvent("on" + evtype, handler);
            fdjtLog.warn("This node never listens: %o", node);
        }
    }
    function defListeners(handlers, defs) {
        if (handlers && defs) for (var domspec in defs) if (defs.hasOwnProperty(domspec)) {
            var evtable = defs[domspec], addto = handlers[domspec];
            addto && handlers.hasOwnProperty(domspec) || (handlers[domspec] = addto = {});
            for (var evtype in evtable) evtable.hasOwnProperty(evtype) && (addto[evtype] = evtable[evtype]);
        }
    }
    function addListeners(node, handlers) {
        if (handlers) for (var evtype in handlers) if (handlers.hasOwnProperty(evtype)) {
            var match = !1, val = handlers[evtype];
            if (val.call) {
                if (events_pat.exec(evtype)) addListener(node, evtype, handlers[evtype]); else if (match = spec_events_pat.exec(evtype)) {
                    var ev = match[2], handler = handlers[evtype], elts = node.querySelectorAll(match[1]);
                    addListener(elts, ev, handler);
                }
            } else ;
        }
    }
    function removeListener(node, evtype, handler) {
        if (node || (node = document), "string" == typeof node) {
            var elt = fdjtID(node);
            if (!node) return fdjtLog("Can't find #%s", node), void 0;
            node = elt;
        } else {
            if (Array.isArray && Array.isArray(node) || window.NodeList && node instanceof window.NodeList) {
                for (var i = 0, lim = node.length; lim > i; ) removeListener(node[i++], evtype, handler);
                return;
            }
            if (node !== window && !node.nodeType) return fdjtLog.warn("Bad target(s) arg to removeListener(%s) %o", evtype, node), 
            void 0;
        }
        return node.removeEventListener ? node.removeEventListener(evtype, handler, !1) : node.detachEvent ? node.detachEvent("on" + evtype, handler) : (fdjtLog.warn("This node never listens: %o", node), 
        void 0);
    }
    function eventTarget(evt) {
        return evt = evt || window.event, evt.target || evt.srcElement;
    }
    function cancelEvent(evt) {
        evt = evt || window.event, evt.preventDefault ? evt.preventDefault() : evt.returnValue = !1, 
        evt.cancelBubble = !0;
    }
    function triggerClick(elt) {
        if (document.createEvent) {
            var e = document.createEvent("MouseEvents");
            return e.initEvent("click", !0, !0), elt.dispatchEvent(e), void 0;
        }
        return fdjtLog.warn("Couldn't trigger click"), void 0;
    }
    function pageScroll(container, n) {
        var ch = container.clientHeight, delta = ch * n, sh = container.scrollHeight, st = container.scrollTop, nt = st + delta;
        ch >= sh || (container.scrollTop = 0 > nt ? 0 : nt + ch >= sh ? sh - ch : nt);
    }
    function getInsideBounds(container) {
        for (var left = !1, top = !1, right = !1, bottom = !1, children = container.childNodes, i = 0, lim = children.length; lim > i; ) {
            var child = children[i++];
            if ("number" == typeof child.offsetLeft) {
                var style = getStyle(child);
                if ("static" === style.position) {
                    var child_left = child.offsetLeft - parsePX(style.marginLeft), child_top = child.offsetTop - parsePX(style.marginTop), child_right = child.offsetLeft + child.offsetWidth + parsePX(style.marginRight), child_bottom = child.offsetTop + child.offsetHeight + parsePX(style.marginBottom);
                    left === !1 ? (left = child_left, right = child_right, top = child_top, bottom = child_bottom) : (left > child_left && (left = child_left), 
                    top > child_top && (top = child_top), child_right > right && (right = child_right), 
                    child_bottom > bottom && (bottom = child_bottom));
                }
            }
        }
        return {
            left: left,
            right: right,
            top: top,
            bottom: bottom,
            width: right - left,
            height: bottom - top
        };
    }
    function applyScale(container, scale) {
        var images = fdjtDOM.getChildren(container, "IMG"), ilim = images.length;
        if (scale) {
            container.scale = scale, container.style.fontSize = scale + "%";
            var rounded = 10 * Math.round(scale / 10);
            fdjtDOM.addClass(container, "fdjtscaled"), fdjtDOM.swapClass(container, /\bfdjtscale\d+\b/, "fdjtscale" + rounded);
        } else {
            if (!container.scale) return;
            delete container.scale, container.style.fontSize = "", fdjtDOM.dropClass(container, "fdjtscaled"), 
            fdjtDOM.dropClass(container, /\bfdjtscale\d+\b/);
        }
        for (var iscan = 0; ilim > iscan; ) {
            var image = images[iscan++];
            if (!fdjtDOM.hasClass(image, "nofdjtscale") && !fdjtDOM.hasClass(image, "noautoscale") && (image.style.maxWidth = image.style.width = image.style.maxHeight = image.style.height = "", 
            scale)) {
                var width = image.offsetWidth, height = image.offsetHeight;
                image.style.maxWidth = image.style.width = Math.round(width * (scale / 100)) + "px", 
                image.style.maxHeight = image.style.height = Math.round(height * (scale / 100)) + "px";
            }
        }
    }
    function adjustInside(elt, container, step, min, pad) {
        function adjust() {
            var outside = getGeometry(container), inside = getGeometry(elt, container), style = getStyle(container), maxwidth = outside.width - (parsePX(style.paddingLeft, 0) + parsePX(style.borderLeft, 0) + parsePX(style.paddingRight, 0) + parsePX(style.borderRight, 0)), maxheight = outside.height - (parsePX(style.paddingTop, 0) + parsePX(style.borderTop, 0) + parsePX(style.paddingBottom, 0) + parsePX(style.borderBottom, 0));
            trace_adjust && fdjtLog("adjustInside scale=%o step=%o min=%o pad=%o [l%o,t%o,r%o,b%o] << %ox%o < %ox%o", scale, step, min, pad, inside.left, inside.top, inside.right, inside.bottom, maxwidth * pad, maxheight * pad, maxwidth, maxheight), 
            inside.top >= 0 && pad * maxheight >= inside.bottom && inside.left >= 0 && pad * maxwidth >= inside.right || min >= scale || (scale -= step, 
            applyScale(elt, scale, trace_adjust), setTimeout(adjust, 10));
        }
        var trace_adjust = elt.traceadjust || container.traceadjust || fdjtDOM.trace_adjust || "string" == typeof elt.className && elt.className.search(/\btraceadjust\b/) >= 0 || "string" == typeof container.className && container.className.search(/\btraceadjust\b/) >= 0 || default_trace_adjust;
        step || (step = 5), min || (min = 50), pad || (pad = 1);
        var scale = 100;
        setTimeout(adjust, 10);
    }
    function adjustToFit(container, threshold, padding) {
        var trace_adjust = container.traceadjust || fdjtDOM.trace_adjust || "string" == typeof container.className && container.className.search(/\btraceadjust\b/) >= 0 || default_trace_adjust, style = getStyle(container), geom = getGeometry(container), maxheight = style.maxHeight && parsePX(style.maxHeight) || geom.height, maxwidth = style.maxWidth && parsePX(style.maxWidth) || geom.width, goodenough = threshold || .1, scale = container.scale || 100, bounds = getInsideBounds(container), hpadding = (fdjtDOM.parsePX(style.paddingLeft) || 0) + (fdjtDOM.parsePX(style.paddingRight) || 0) + (fdjtDOM.parsePX(style.borderLeftWidth) || 0) + (fdjtDOM.parsePX(style.borderRightWidth) || 0) + padding, vpadding = (fdjtDOM.parsePX(style.paddingTop) || 0) + (fdjtDOM.parsePX(style.paddingBottom) || 0) + (fdjtDOM.parsePX(style.borderTopWidth) || 0) + (fdjtDOM.parsePX(style.borderBottomWidth) || 0) + padding;
        maxwidth -= hpadding, maxheight -= vpadding;
        var itfits = 1 >= bounds.height / maxheight && 1 >= bounds.width / maxwidth;
        if (trace_adjust && fdjtLog("Adjust (%o) %s cur=%o%s, best=%o~%o, limit=%ox%o=%o, box=%ox%o=%o, style=%s", goodenough, fdjtDOM.nodeString(container), scale, itfits ? " (fits)" : "", container.bestscale || -1, container.bestfit || -1, maxwidth, maxheight, maxwidth * maxheight, bounds.width, bounds.height, bounds.width * bounds.height, styleString(container)), 
        itfits) {
            var fit = Math.max(1 - bounds.width / maxwidth, 1 - bounds.height / maxheight), bestfit = container.bestfit || 1.5;
            if (trace_adjust && (container.bestscale ? fdjtLog("%s %o~%o vs. %o~%o", goodenough > fit ? "Good enough!" : bestfit > fit ? "Better!" : "Worse!", scale, fit, container.bestscale, container.bestfit) : fdjtLog("First fit %o~%o", scale, fit)), 
            bestfit > fit && (container.bestscale = scale, container.bestfit = fit), goodenough > fit) return container.goodscale = scale, 
            void 0;
        }
        var rh = maxheight / bounds.height, rw = maxwidth / bounds.width, newscale = itfits ? scale * Math.sqrt(maxwidth * maxheight / (bounds.width * bounds.height)) : rw > rh ? scale * rh : scale * rw;
        trace_adjust && fdjtLog("[%fs] Trying newscale=%o, rw=%o rh=%o", fdjt.ET(), newscale, rw, rh), 
        applyScale(container, newscale, trace_adjust);
    }
    function scale_node(node, fudge, origin, shrink) {
        origin || (origin = node.getAttribute("data-origin")), shrink || (shrink = node.getAttribute("data-shrink")), 
        fudge || (fudge = node.getAttribute("data-fudge"));
        var first = node.firstChild, wrapper = "fdjtadjusted" === first.className ? first : getFirstChild(node, "fdjtadjusted");
        wrapper && wrapper.setAttribute("style", "");
        var geom = getGeometry(node, !1, !0), inside = getInsideBounds(node), avail_width = fudge ? fudge * geom.inner_width : geom.inner_width, avail_height = fudge ? fudge * geom.inner_height : geom.inner_height;
        if (avail_height >= inside.height && avail_width >= inside.width) {
            if (!shrink) return;
            if (avail_height > inside.height && inside.height >= .9 * avail_height || geom.inner_width > inside.width && inside.width >= .9 * avail_height) return;
        }
        if (!wrapper) {
            for (var nodes = [], children = node.childNodes, i = 0, lim = children.length; lim > i; ) nodes.push(children[i++]);
            for (wrapper = fdjtDOM("div.fdjtadjusted"), i = 0, lim = nodes.length; lim > i; ) wrapper.appendChild(nodes[i++]);
            node.appendChild(wrapper);
        }
        var w_scale = avail_width / inside.width, h_scale = avail_height / inside.height, scale = h_scale > w_scale ? w_scale : h_scale;
        wrapper.style[fdjtDOM.transform] = "scale(" + scale + "," + scale + ")", wrapper.style[fdjtDOM.transformOrigin] = origin || "50% 0%";
    }
    function scaleAll() {
        for (var all = fdjtDOM.$(".fdjtadjustfit"), i = 0, lim = all.length; lim > i; ) scale_node(all[i++]);
    }
    function scaleToFit(node, fudge, origin) {
        return fdjtDOM.addClass(node, "fdjtadjustfit"), fudge && "number" != typeof fudge && (fudge = .9), 
        fudge && node.setAttribute("data-fudge", fudge), origin && node.setAttribute("data-origin", origin), 
        scale_node(node, fudge, origin), node;
    }
    function scale_revert(node, wrapper) {
        if (wrapper || (hasClass(node, "fdjtadjusted") ? (wrapper = node, node = wrapper.parentNode) : wrapper = "fdjtadjusted" === node.firstChild.className ? node.firstChild : getFirstChild(node, "fdjtadjusted")), 
        node && wrapper) {
            for (var nodes = [], children = wrapper.childNodes, i = 0, lim = children.length; lim > i; ) nodes.push(children[i++]);
            var frag = document.createDocumentFragment();
            for (i = 0, lim = nodes.length; lim > i; ) frag.appendChild(nodes[i++]);
            return node.replaceChild(frag, wrapper), node;
        }
        return !1;
    }
    function revertAll() {
        for (var all = fdjtDOM.$(".fdjtadjusted"), i = 0, lim = all.length; lim > i; ) {
            var wrapper = all[i++];
            scale_revert(wrapper.parentNode, wrapper);
        }
    }
    function getHTML() {
        for (var children = document.childNodes, i = 0, lim = children.length; lim > i; ) {
            if ("HTML" === children[i].tagName) return children[i];
            i++;
        }
        return !1;
    }
    function getHEAD() {
        for (var children = document.childNodes, i = 0, lim = children.length; lim > i; ) {
            if ("HTML" === children[i].tagName) {
                var grandchildren = children[i].childNodes;
                for (i = 0, lim = grandchildren.length; lim > i; ) {
                    if ("HEAD" === grandchildren[i].tagName) return grandchildren[i];
                    i++;
                }
                return !1;
            }
            i++;
        }
        return !1;
    }
    function getMetaSchemas() {
        for (var links = document.getElementsByTagName && document.getElementsByTagName("link") || document.head.getElementsByTagName && document.head.getElementsByTagName("link") || getChildren(document, "link"), i = 0, lim = links.length; lim > i; ) {
            var link = links[i++];
            if (link.rel && link.href && 0 === link.rel.search("schema.")) {
                var tag = link.rel.slice(7), href = link.href;
                tag2schema[tag] ? fdjtLog.warn("Conflicting schemas for %s", tag) : (schema2tag[href] ? schema2tag[href].push(tag) : schema2tag[href] = [ tag ], 
                tag2schema[tag] = href);
            }
        }
    }
    function getNameRX(name, foldcase) {
        var prefix, schema, prefixes = [];
        if ("string" == typeof name && foldcase === void 0 && ("^" === name[0] ? (foldcase = !1, 
        name = name.slice(1)) : "~" === name[0] && (foldcase = !0, name = name.slice(1))), 
        foldcase === void 0 && (foldcase = !0), "string" != typeof name) return name;
        if ("{" === name[0]) {
            schema = !1;
            var schema_end = name.indexOf("}");
            return schema_end > 2 && (schema = name.slice(1, schema_end)), prefixes = schema && schema2tag[schema] || [], 
            RegExp("\\b(" + escapeRX(schema) + "|" + prefixes.join("|") + ")[.]" + name.slice(schema_end + 1) + "\\b", foldcase ? "i" : "");
        }
        if ("=" === name[0]) return RegExp("\\b" + escapeRX(name = name.slice(1)) + "\\b", foldcase ? "i" : "");
        if ("*" === name[0] && "." === name[1]) return RegExp("\\b([^.]\\.)?" + name.slice(2) + "\\b", foldcase ? "i" : "");
        if (name.indexOf(".") > 0) {
            var dot = name.indexOf(".");
            return prefix = name.slice(0, dot), (schema = app_schemas[prefix]) ? (prefixes = schema && schema2tag[schema] ? schema2tag[schema] : [ prefix ], 
            RegExp("\\b(" + escapeRX(schema) + "|" + prefixes.join("|") + ")\\." + name.slice(dot + 1) + "\\b", foldcase ? "i" : "")) : RegExp("\\b" + escapeRX(name) + "\\b", foldcase ? "i" : "");
        }
        return RegExp("\\b" + name + "\\b", foldcase ? "i" : "");
    }
    function getMeta(name, multiple, foldcase, dom) {
        for (var results = [], elts = document.getElementsByTagName ? document.getElementsByTagName("META") : getChildren(document, "META"), rx = getNameRX(name, foldcase), i = 0; elts.length > i; ) {
            var elt = elts[i++];
            if (elt && elt.name && elt.name.search(rx) >= 0) {
                if (!multiple) return dom ? elt : elt.content;
                dom ? results.push(elt) : results.push(elt.content);
            }
        }
        return multiple ? results : !1;
    }
    function getLink(name, multiple, foldcase, dom, attrib) {
        for (var results = [], elts = document.getElementsByTagName ? document.getElementsByTagName("LINK") : document.body && document.body.getElementsByTagName ? document.body.getElementsByTagName("LINK") : getChildren(document, "LINK"), rx = getNameRX(name, foldcase), i = 0; elts.length > i; ) {
            var elt = elts[i++];
            if (elt && elt.rel && elt.rel.search(rx) >= 0) {
                if (!multiple) return dom ? elt : attrib ? elt.getAttribute("href") : elt.href;
                dom ? results.push(elt) : attrib ? results.push(elt.getAttribute("href")) : results.push(elt.href);
            }
        }
        return multiple ? results : !1;
    }
    function next_node(node) {
        for (;node; ) {
            if (node.nextSibling) return node.nextSibling;
            node = node.parentNode;
        }
        return !1;
    }
    function next_element(node) {
        if (node.nextElementSibling) return node.nextElementSibling;
        for (var scan = node; scan = scan.nextSibling; ) {
            if (!scan) return null;
            if (1 === scan.nodeType) break;
        }
        return scan;
    }
    function scan_next(node, test, justelts) {
        if (!test) return justelts ? havechildren ? node.nextElementSibling : next_element(node) : next_node(node);
        for (var scan = justelts ? havechildren ? node.nextElementSibling : next_element(node) : node.nextSibling || next_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? scan.nextElementSibling || next_element(scan) : scan.nextSibling || next_node(scan);
        }
        return !1;
    }
    function forward_node(node) {
        if (node.childNodes && node.childNodes.length > 0) return node.childNodes[0];
        for (;node; ) {
            if (node.nextSibling) return node.nextSibling;
            node = node.parentNode;
        }
        return !1;
    }
    function forward_element(node, n) {
        var scan, i, lim;
        if (n) {
            for (i = 0, scan = node; n > i; ) scan = forward_element(scan), i++;
            return scan;
        }
        if (havechildren) {
            if (node.children && node.children.length > 0) return node.children[0];
            if (scan = node.nextElementSibling) return scan;
            for (;node = node.parentNode; ) if (scan = node.nextElementSibling) return scan;
            return !1;
        }
        if (node.childNodes) {
            var children = node.childNodes;
            for (i = 0, lim = children.length; lim > i; ) if ((scan = children[i++]) && 1 === scan.nodeType) return scan;
        }
        for (;scan = node.nextSibling; ) if (1 === scan.nodeType) return scan;
        for (;node = node.parentNode; ) if (scan = next_element(node)) return scan;
        return !1;
    }
    function scan_forward(node, test, justelts) {
        if (!test) return justelts ? forward_element(node) : forward_node(node);
        for (var scan = justelts ? forward_element(node) : forward_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? next_element(scan) : next_node(scan);
        }
        return !1;
    }
    function prev_node(node) {
        for (;node; ) {
            if (node.previousSibling) return node.previousSibling;
            node = node.parentNode;
        }
        return !1;
    }
    function previous_element(node) {
        if (havechildren) return node.previousElementSibling;
        for (var scan = node; scan = scan.previousSibling; ) {
            if (!scan) return null;
            if (1 === scan.nodeType) break;
        }
        return scan ? scan : scan.parentNode;
    }
    function scan_previous(node, test, justelts) {
        if (!test) return justelts ? havechildren ? node.previousElementSibling : previous_element(node) : prev_node(node);
        for (var scan = justelts ? havechildren ? node.previousElementSibling : previous_element(node) : prev_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? havechildren ? scan.previousElementSibling : previous_element(scan) : prev_node(scan);
        }
        return !1;
    }
    function backward_node(node) {
        if (node.previousSibling) {
            var scan = node.previousSibling;
            if (1 !== scan.nodeType) return scan;
            for (;scan; ) {
                var children = scan.childNodes;
                if (!children) return scan;
                if (0 === children.length) return scan;
                scan = children[children.length - 1];
            }
            return scan;
        }
        return node.parentNode;
    }
    function backward_element(node) {
        if (havechildren) return node.previousElementSibling ? get_final_child(node.previousElementSibling) : node.parentNode;
        if (node.previousElementSibling || node.previousSibling) {
            var start = node.previousElementSibling || node.previousSibling;
            return 1 === start.nodeType ? get_final_child(start) : start;
        }
        return node.parentNode;
    }
    function get_final_child(node) {
        if (1 === node.nodeType) {
            if (node.childNodes) {
                var children = node.childNodes;
                if (!children.length) return node;
                for (var scan = children.length - 1; scan >= 0; ) {
                    var child = get_final_child(children[scan--]);
                    if (child) return child;
                }
                return node;
            }
            return node;
        }
        return !1;
    }
    function scan_backward(node, test, justelts) {
        if (!test) return justelts ? backward_element(node) : backward_node(node);
        for (var scan = justelts ? backward_element(node) : backward_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? next_element(scan) : next_node(scan);
        }
        return !1;
    }
    function viewHeight(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? (win || (win = window), 
        win.hasOwnProperty("innerHeight") ? win.innerHeight : win.document && window.document.documentElement && window.document.documentElement.clientHeight ? window.document.documentElement.clientHeight : win.offsetHeight) : void 0;
    }
    function viewWidth(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? (win || (win = window), 
        win.hasOwnProperty("innerWidth") ? win.innerWidth : win.document && window.document.documentElement && window.document.documentElement.clientWidth ? window.document.documentElement.clientWidth : win.offsetWidth) : void 0;
    }
    function getOrientation(win) {
        if ("string" != typeof win || (win = document.getElementById(win))) {
            if (win || (win = window), win.hasOwnProperty("orientation")) return 90 === win.orientation || -90 === win.orientation ? "landscape" : "portrait";
            var w = viewWidth(win), h = viewHeight(win);
            return w > h ? "landscape" : "portrait";
        }
    }
    function getNodeID(elt) {
        var nelt, id = elt.id;
        if (id) return id;
        for (id = "TMPID_" + unique + "_" + id_count++; !(nelt = document.getElementById(id)) || nelt === elt; ) id = "TMPID_" + unique + "_" + id_count++, 
        (nelt = document.getElementById(id)) && nelt !== elt || (unique = Math.floor(1e5 * Math.random())), 
        id = "TMPID_" + unique + "_" + id_count++;
        return elt.id = id, id;
    }
    function stripIDs(node, nametoo, moveto) {
        if (nametoo || (nametoo = !1), moveto || (moveto = !1), node.id && (moveto && node.setAttribute(moveto, node.id), 
        node.id = "", node.removeAttribute("id")), nametoo && node.name && (node.name = null), 
        node.childNodes && node.childNodes.length) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
            var child = children[i++];
            1 === child.nodeType && stripIDs(child, nametoo, moveto);
        }
    }
    function getCSSRule(ruleName, deleteFlag) {
        if (ruleName = ruleName.toLowerCase(), document.styleSheets) {
            for (var i = 0; document.styleSheets.length > i; i++) for (var styleSheet = document.styleSheets[i], cssRules = styleSheet.cssRules || styleSheet.rules, n_rules = cssRules && cssRules.length, ii = 0; n_rules > ii; ) {
                if (cssRules[ii]) {
                    var cssRule = cssRules[ii];
                    if (cssRule.selectorText.toLowerCase() === ruleName) return "delete" === deleteFlag ? (styleSheet.cssRules && styleSheet.deleteRule(ii), 
                    !0) : cssRule;
                }
                ii++;
            }
            return !1;
        }
        return !1;
    }
    function dropCSSRule(ruleName) {
        return getCSSRule(ruleName, "delete");
    }
    function addCSSRule(selector, style, sheet) {
        if (!sheet) {
            var styles = fdjtID("FDJTSTYLES");
            if (!styles) {
                var head = document.getElementsByTagName("HEAD");
                if (0 === head.length) return;
                head = head[0], styles = fdjtDOM("style#FDJTSTYLES"), head.appendChild(styles);
            }
            sheet = styles.sheet;
        }
        if (sheet) {
            if (sheet.insertRule || sheet.addRule) {
                var rules = sheet.cssRules || sheet.rules, at = rules.length;
                return sheet.insertRule ? sheet.insertRule(selector + " {" + style + "}", at) : sheet.addRule(selector, style, at), 
                rules[at];
            }
            return !1;
        }
        return !1;
    }
    function checkSVG() {
        var root = document.documentElement || document.body;
        return nosvg === void 0 && (nosvg = document.implementation && document.implementation.hasFeature ? !document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1") : "Microsoft Internet Explorer" === navigator.appName ? !0 : navigator.mimeTypes["image/svg+xml"] ? !1 : !0), 
        nosvg ? (addClass(root, "_NOSVG"), dropClass(root, "_USESVG")) : (dropClass(root, "_NOSVG"), 
        addClass(root, "_USESVG")), !nosvg;
    }
    function checkChildren() {
        havechildren = document && document.body && document.body.childNodes && document.body.children;
    }
    function useBMP() {
        for (var hasSuffix = fdjtString.hasSuffix, images = fdjt.$("IMG"), i = 0, lim = images.length; lim > i; ) {
            var image = images[i++], src = image.src;
            if (src && (hasSuffix(src, ".svg") || hasSuffix(src, ".svgz"))) {
                var bmp = image.getAttribute("bmp");
                bmp && (image.setAttribute("svg", image.src), image.src = bmp);
            }
        }
    }
    function useSVG() {
        for (var hasSuffix = fdjtString.hasSuffix, images = fdjt.$("IMG"), i = 0, lim = images.length; lim > i; ) {
            var image = images[i++], src = image.src;
            if (src && !hasSuffix(src, ".svg") && !hasSuffix(src, ".svgz") && image.getAttribute("svg")) {
                var svg = image.getAttribute("svg");
                image.setAttribute("bmp", image.src), image.src = svg;
            }
        }
    }
    function prefSVG() {
        nosvg || useSVG();
    }
    function node2text(node, accum) {
        var i, lim;
        if (accum || (accum = ""), !node.nodeType && node.length) {
            for (i = 0, lim = node.length; lim > i; ) accum = node2text(node[i++], accum);
            return accum;
        }
        if (3 === node.nodeType) {
            var stringval = node.nodeValue;
            return stringval && (accum += stringval), accum;
        }
        if (1 === node.nodeType) {
            var style = getStyle(node), children = node.childNodes;
            if ("string" == typeof node.className && node.className.search(/\bfdjtskiptext\b/) >= 0) return accum;
            if ("none" === style.display || "hidden" === style.visibility || "static" !== style.position && "" !== style.position) return accum;
            for (i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                if (3 === child.nodeType) {
                    var s = child.nodeValue;
                    s && (accum += s);
                } else accum = node2text(child, accum);
            }
            return accum;
        }
        return accum;
    }
    function get_text_pos(node, pos, cur, starting) {
        var i, lim;
        if (cur > pos) return !1;
        if (!node.nodeType && node.length) {
            for (i = 0, lim = node.length; lim > i; ) if (cur = get_text_pos(node[i++], pos, cur, starting), 
            "number" != typeof cur) return cur;
            return cur;
        }
        if (3 === node.nodeType) {
            var stringval = node.nodeValue;
            return cur + stringval.length > pos ? {
                node: node,
                off: pos - cur
            } : pos === cur + stringval.length ? {
                node: node,
                off: pos - cur,
                atend: !0
            } : cur + stringval.length;
        }
        if (1 === node.nodeType) {
            var style = getStyle(node), children = node.childNodes;
            if ("string" == typeof node.className && node.className.search(/\bfdjtskiptext\b/) >= 0) return cur;
            if ("none" === style.display || "hidden" === style.visibility || "static" !== style.position && "" !== style.position) return cur;
            for (i = 0, lim = children.length; lim > i; ) if (cur = get_text_pos(children[i++], pos, cur, starting), 
            "number" != typeof cur) {
                if (starting && cur.atend) {
                    for (cur = pos; lim > i; ) {
                        var next = get_text_pos(children[i++], cur, pos, starting);
                        if (next && "number" != typeof next) return next;
                    }
                    return cur;
                }
                return cur;
            }
            return cur;
        }
        return cur;
    }
    function textPos(node, pos, sofar) {
        var result = get_text_pos(node, pos, sofar || 0);
        return "number" != typeof result ? result : {
            node: node,
            off: pos
        };
    }
    function get_text_off(scan, upto, sofar) {
        if (sofar || (sofar = 0), scan === upto) return [ sofar ];
        if (3 === scan.nodeType) return sofar + scan.nodeValue.length;
        if (1 === scan.nodeType) {
            for (var children = scan.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                if (sofar = get_text_off(child, upto, sofar), "number" != typeof sofar) return sofar;
            }
            return sofar;
        }
        return sofar;
    }
    function textOff(node, pos) {
        var off = get_text_off(node, pos, 0);
        return off ? off[0] : !1;
    }
    function getIDParent(scan) {
        for (;scan && !scan.id; ) scan = scan.parentNode;
        return scan;
    }
    function getRegexString(needle, shyphens, before, after) {
        return shyphens ? (needle = needle.replace("­", ""), (before || "") + needle.replace(/\S/g, "$&­?").replace(/([()\[\]\.\?\+\*])­\?/gm, "[$1]").replace("­? ", " ").replace(/\s+/g, "(\\s+)") + (after || "")) : (before || "") + needle.replace(/[()\[\]\.\?\+\*]/gm, "[$&]").replace(/\s+/g, "(\\s+)") + (after || "");
    }
    function textRegExp(needle, foldcase, shyphens, before, after) {
        return shyphens === void 0 && (shyphens = !0), RegExp(getRegexString(needle, shyphens, before, after), foldcase ? "igm" : "gm");
    }
    function wordRegExp(needle, foldcase, shyphens) {
        return shyphens === void 0 && (shyphens = !0), RegExp(getRegexString(needle, shyphens, "\\b", "\\b"), foldcase ? "igm" : "gm");
    }
    function findString(node, needle, off, count) {
        off === void 0 && (off = 0), count === void 0 && (count = 1), needle = needle.replace(/­/gm, "");
        for (var match = !1, fulltext = node2text(node), sub = 0 === off ? fulltext : fulltext.slice(off), scan = sub.replace(/­/gm, ""), pat = "string" == typeof needle ? textRegExp(needle, !1, !1) : needle; match = pat.exec(scan); ) {
            if (1 === count) {
                var loc = match.index;
                if (scan !== sub) for (var i = 0; loc > i; ) "­" === sub[i] && loc++, i++;
                var absloc = loc + off, start = get_text_pos(node, absloc, 0, !0), end = get_text_pos(node, absloc + match[0].length, 0);
                if (!start || !end) return !1;
                var range = document.createRange();
                if (start.atend) {
                    var txt = firstText(start.node.nextSibling);
                    txt ? range.setStart(txt, 0) : range.setStart(start.node, start.off);
                } else range.setStart(start.node, start.off);
                return range.setEnd(end.node, end.off), range;
            }
            count--, off = match.index + match[0].length, scan = scan.slice(off);
        }
        return !1;
    }
    function findMatches(node, needle, off, count) {
        off === void 0 && (off = 0), count === void 0 && (count = -1);
        for (var match = !1, results = [], fulltext = node2text(node), scan = 0 === off ? fulltext : fulltext.slice(off), pat = "string" == typeof needle ? textRegExp(needle) : needle; 0 !== count && (match = pat.exec(scan)); ) {
            var loc = match.index + off, start = get_text_pos(node, loc, 0), end = get_text_pos(node, loc + match[0].length, 0);
            if (!start || !end) return !1;
            var range = document.createRange();
            if ("number" == typeof start) range.setStart(node, start); else if (start.atend) {
                var txt = firstText(start.node.nextSibling);
                txt ? range.setStart(txt, 0) : range.setStart(start.node, start.off);
            } else range.setStart(start.node, start.off);
            "number" == typeof end ? range.setEnd(node, end) : range.setEnd(end.node, end.off), 
            results.push(range), count--;
        }
        return results;
    }
    function firstText(node) {
        return node ? 3 === node.nodeType ? node : 1 === node.nodeType ? firstText(node.firstChild) : !1 : !1;
    }
    function checkTransitionEvents() {
        var div = document.createElement("div");
        if (div.removeEventListener) {
            var handler = function(e) {
                fdjtDOM.transitionEnd = e.type;
                for (var i = 0, lim = transition_events.length; lim > i; ) div && div.removeEventListener ? div.removeEventListener(transition_events[i++], handler) : i++;
            };
            div.setAttribute("style", "position:absolute;top:0px;transition:top 1ms ease;-webkit-transition:top 1ms ease;-moz-transition:top 1ms ease;-o-transition:top 1ms ease;-ms-transition:top 1ms ease;");
            for (var i = 0, lim = transition_events.length; lim > i; ) div.addEventListener(transition_events[i++], handler, !1);
            document.documentElement.appendChild(div), setTimeout(function() {
                div.style.top = "100px", setTimeout(function() {
                    div.parentNode.removeChild(div), div = handler = null;
                }, 2e3);
            }, 0);
        }
    }
    function setupCustomInputs(dom) {
        dom || (dom = document.body);
        for (var input_elt = document.createElement("input"), i = 0, ntypes = custom_input_types.length; ntypes > i; ) {
            var typename = custom_input_types[i++];
            try {
                input_elt.type = typename;
            } catch (err) {}
            if (input_elt.type === typename) for (var inputs = getChildren(document.body, ".fdjt" + typename + "input"), j = 0, lim = inputs.length; lim > j; ) {
                var input = inputs[j++];
                "INPUT" === input.tagName && (input.type = typename);
            }
        }
    }
    function checkMedia() {
        var media = "media";
        if (window.matchMedia) {
            var mm = window.matchMedia("handheld");
            mm.match && (media += " handheld"), mm = window.matchMedia("(max-width:500px)"), 
            mm.match && (media += " narrow"), mm = window.matchMedia("(min-width:1000px)"), 
            mm.match && (media += " wide"), mm = window.matchMedia("(-webkit-min-device-pixel-ratio:1.5),(-min-resolution:15dp)"), 
            mm.match && (media += " hires");
        }
        fdjt.media = media;
    }
    function getMediaState() {
        return window.getComputedStyle(document.body, ":before").content;
    }
    function insertText(target, text, off) {
        var pos = target.selectionStart, current = target.value;
        target.value = current && "number" == typeof pos && pos >= 0 ? current.slice(0, pos) + text + current.slice(pos) : text, 
        "number" == typeof off && (target.selectionEnd = target.selectionStart = pos + off);
    }
    function playAudio(id) {
        var elt = document.getElementById(id);
        elt && elt.play && (elt.paused || (elt.pause(), elt.currentTime = 0), elt.play());
    }
    function tweakImage(elt, tw, th) {
        var style = elt.style;
        style.maxHeight = style.minHeight = "inherit", style.maxWidth = style.minWidth = "inherit";
        var w = elt.offsetWidth, h = elt.offsetHeight, sw = tw / w, sh = th / h;
        sh > sw ? (style.width = Math.round(w * sw) + "px", style.height = "auto") : (style.height = Math.round(h * sh) + "px", 
        style.width = "auto");
    }
    function makeBlob(string, type) {
        if ("string" == typeof string && 0 === string.search("data:")) {
            if (!type) {
                var typeinfo = /data:([^;]+);/.exec(string);
                typeinfo && (type = typeinfo[1]);
            }
            var elts = string.split(","), byteString = atob(elts[1]);
            byteString = elts[0].indexOf("base64") >= 0 ? atob(elts[1]) : window.unescape(elts[1]);
            for (var ab = new ArrayBuffer(byteString.length), ia = new Uint8Array(ab), i = 0; byteString.length > i; i++) ia[i] = byteString.charCodeAt(i);
            return new Blob([ ab ], {
                type: type || "application"
            });
        }
        return !1;
    }
    function data2URL(datauri) {
        return URL && URL.createObjectURL ? URL.createObjectURL(makeBlob(datauri)) : datauri;
    }
    function addUXClasses() {
        var device = fdjt.device, prefix = fdjt.cxprefix || "_", html = document.documentElement;
        device.ios && addClass(html, prefix + "IOS"), device.touch && addClass(html, prefix + "TOUCH"), 
        device.mouse && addClass(html, prefix + "MOUSE"), device.android && addClass(html, prefix + "Android");
    }
    function focusElt(id) {
        var elt = document.getElementById(id);
        elt && setTimeout(function() {
            elt.focus();
        }, 10);
    }
    function blurElt(id) {
        var elt = document.getElementById(id);
        elt && setTimeout(function() {
            elt.blur();
        }, 10);
    }
    function windowFocus(evt) {
        evt = evt || window.event, addClass(document.body, "_FOCUS");
    }
    function windowBlur(evt) {
        evt = evt || window.event, dropClass(document.body, "_FOCUS");
    }
    function trackPageFocus() {
        windowFocus(), addListener(window, "focus", windowFocus), addListener(window, "blur", windowBlur);
    }
    var usenative = !0, fdjtString = fdjt.String, fdjtLog = fdjt.Log, aslice = Array.prototype.slice, css_selector_regex = /((^|[.#])[^.#\[\s]+)|(\[[^ \]=]+=[^\]]+\])|(\[[^ \]=]+\])/gi;
    fdjtDOM.useNative = function(flag) {
        return flag === void 0 ? usenative : (usenative = flag, void 0);
    }, fdjtDOM.clone = function(node) {
        return node.cloneNode(!0);
    }, fdjtDOM.ie = getIE(), fdjtDOM.iem = Math.floor(fdjtDOM.ie), fdjt.ID = fdjtID, 
    fdjtDOM.appendArray = domappend, fdjtDOM.toArray = toArray, fdjtDOM.Array = TOA, 
    fdjtDOM.slice = TOA, fdjtDOM.wrapChildren = wrapChildren, fdjtDOM.unwrapChildren = unwrapChildren, 
    fdjtDOM.parsePX = parsePX, fdjtDOM.getLineHeight = getLineHeight;
    var whitespace_pat = /(\s)+/, trimspace_pat = /^(\s)+|(\s)+$/, classpats = {};
    fdjtDOM.nodeString = nodeString, fdjtDOM.make = make, fdjtDOM.getElementValues = getElementValues, 
    fdjtDOM.getElementValue = getElementValue, fdjtDOM.hasClass = hasClass, fdjtDOM.addClass = addClass, 
    fdjtDOM.aC = addClass, fdjtDOM.classAdder = function(elt, classname) {
        return function() {
            elt && addClass(elt, classname);
        };
    }, fdjtDOM.dropClass = dropClass, fdjtDOM.dC = dropClass, fdjtDOM.classDropper = function(elt, classname) {
        return function() {
            elt && dropClass(elt, classname);
        };
    }, fdjtDOM.swapClass = swapClass, fdjtDOM.setClass = setClass, fdjtDOM.toggleClass = toggleClass, 
    fdjtDOM.tC = toggleClass, fdjtDOM.toggleParent = toggleParent, fdjtDOM.tP = toggleParent;
    var text_input_types = fdjtDOM.text_input_types = /text|url|email|search|tel|number|range|password/i;
    fdjtDOM.isTextInput = isTextInput, fdjtDOM.isImage = isImage;
    var selectors = {};
    Selector.prototype.tag = Selector.prototype.classes = Selector.prototype.attribs = Selector.prototype.id = !1, 
    Selector.prototype.match = function(elt) {
        if (elt.matchesSelector) return elt.matchesSelector(this.spec);
        var i, lim;
        if (this.compound) {
            var compound = this.compound;
            for (i = 0, lim = compound.length; lim > i; ) if (compound[i++].match(elt)) return !0;
            return !1;
        }
        if (this.tag && this.tag !== elt.tagName) return !1;
        if (this.id && this.id !== elt.id) return !1;
        if (this.classes) {
            if ("string" != typeof elt.className) return !1;
            var classname = elt.className, classes = this.classes;
            for (i = 0, lim = classes.length; lim > i; ) if (0 > classname.search(classes[i++])) return !1;
        }
        if (this.attribs) {
            var attribs = this.attribs;
            for (var name in attribs) if (attribs.hasOwnProperty(name)) {
                var val = elt.getAttribute(name);
                if (!val) return !1;
                var need = this[name];
                if (need === !0) ; else if ("string" == typeof need) {
                    if (need !== val) return !1;
                } else if (0 > val.search(need)) return !1;
            }
        }
        return !0;
    }, Selector.prototype.find = function(elt, results) {
        var probe, i, lim;
        if (results || (results = []), this.compound) {
            var compound = this.compound;
            for (i = 0, lim = compound.length; lim > i; ) compound[i++].find(elt, results);
            return results;
        }
        if (this.id) return probe = document.getElementById(this.id), probe ? this.match(probe) ? (results.push(probe), 
        results) : results : results;
        var candidates = [], classnames = this.classnames, attribs = this.attribs;
        if (this.classes) elt.getElementsByClassName ? candidates = elt.getElementsByClassName(classnames[0]) : gatherByClass(elt, this.classes[0], candidates); else if (this.tag && elt.getElementsByTagName) candidates = elt.getElementsByTagName(this.tag); else if (this.attribs) {
            attribs = this.attribs;
            for (var name in attribs) if (attribs.hasOwnProperty(name)) {
                gatherByAttrib(elt, name, attribs[name], candidates);
                break;
            }
        } else this.tag && gatherByTag(elt, this.tag, candidates);
        if (0 === candidates.length) return candidates;
        if (this.tag && !this.classes && !this.attribs || !this.tag && this.classes && 1 === this.classes.length && !this.attribs) return results.length ? extendArray(results, candidates) : candidates instanceof Array ? candidates : toArray(candidates);
        for (i = 0, lim = candidates.length; lim > i; ) {
            var candidate = candidates[i++];
            this.match(candidate) && results.push(candidate);
        }
        return results;
    }, fdjtDOM.Selector = Selector, fdjtDOM.sel = function(spec) {
        return spec ? spec instanceof Selector ? spec : spec instanceof Array ? spec.length ? new Selector(spec.join(",")) : !1 : "string" == typeof spec ? new Selector(spec) : (fdjtLog.warn("Non selector spec: %o", spec), 
        !1) : !1;
    }, fdjtDOM.getParent = getParent, fdjtDOM.hasParent = getParent, fdjtDOM.$P = getParent, 
    fdjtDOM.inherits = function(node, spec) {
        var sel = new Selector(spec);
        return sel.match(node) ? node : getParent(node, sel);
    }, fdjtDOM.getParents = function(node, sel) {
        for (var results = [], scan = node, parent = !1; parent = getParent(scan, sel); ) results.push(parent), 
        scan = parent.parentNode;
        return results;
    }, fdjtDOM.getChildNodes = getChildNodes, fdjtDOM.getChildren = getChildren, fdjt.$ = fdjtDOM.$ = function(spec, root) {
        return toArray(getChildren(root || document, spec));
    }, fdjt.$1 = fdjtDOM.$1 = fdjtDOM.getChild = fdjtDOM.getFirstChild = getFirstChild, 
    fdjtDOM.getAttrib = function(elt, attrib, ns) {
        var probe;
        return ns && elt.getAttributeByNS && (probe = elt.getAttributeNS(attrib, ns)), probe ? probe : elt.getAttribute(attrib) || elt.getAttribute("data-" + attrib);
    }, fdjtDOM.findAttrib = function(scan, attrib, ns) {
        for (var dattrib = "data-" + attrib; scan; ) {
            if (ns && scan.getAttributeNS && scan.getAttributeNS(attrib, ns)) return scan.getAttributeNS(attrib, ns);
            if (scan.getAttribute) {
                if (scan.getAttribute(attrib)) return scan.getAttribute(attrib);
                if (scan.getAttribute(dattrib)) return scan.getAttribute(dattrib);
                scan = scan.parentNode;
            } else scan = scan.parentNode;
        }
        return !1;
    }, fdjtDOM.getFirstElement = getFirstElement, fdjtDOM.getLastElement = getLastElement, 
    fdjtDOM.replace = function(existing, replacement, leaveids) {
        var cur = existing;
        "string" == typeof existing && (cur = "#" === existing[0] ? document.getElementById(existing.slice(1)) : document.getElementById(existing)), 
        cur ? (cur.parentNode.replaceChild(replacement, cur), leaveids || cur.id && !replacement.id && (replacement.id = cur.id)) : fdjtLog.uhoh("Can't find %o to replace it with %o", existing, replacement);
    }, fdjtDOM.remove = remove_node, fdjtDOM.removeChildren = removeChildren, fdjtDOM.append = DOMappend, 
    fdjtDOM.prepend = DOMprepend, fdjtDOM.insertBefore = DOMinsertBefore, fdjtDOM.insertAfter = DOMinsertAfter, 
    fdjtDOM.Input = function(spec, name, value, title) {
        0 !== spec.search(/\w/) && (spec = "INPUT" + spec);
        var node = fdjtDOM(spec);
        return node.name = name, value && (node.value = value), title && (node.title = title), 
        node;
    }, fdjtDOM.Checkbox = function(name, value, checked) {
        var node = fdjtDOM("INPUT");
        return node.type = "checkbox", node.name = name, value && (node.value = value), 
        node.checked = checked ? !0 : !1, node;
    }, fdjtDOM.Anchor = function(href, spec) {
        spec = tag_spec(spec, "A");
        var node = fdjtDOM(spec);
        return node.href = href, domappend(node, aslice.call(arguments), 2), node;
    }, fdjtDOM.Image = function(src, spec, alt, title) {
        spec = tag_spec(spec, "IMG");
        var node = fdjtDOM(spec);
        return node.src = src, alt && (node.alt = alt), title && (node.title = title), domappend(node, aslice.call(arguments), 4), 
        node;
    }, fdjtDOM.getInputs = getInputs, fdjtDOM.getInput = function(root, name, type) {
        var results = getInputs(root, name || !1, type || !1);
        return results && 1 === results.length ? results[0] : results && results.length ? (fdjtLog.warn("Ambiguous input reference name=%o type=%o under %o", name, type, root), 
        results[0]) : !1;
    }, fdjtDOM.getInputValues = getInputValues, fdjtDOM.getInputValue = getInputValue, 
    fdjtDOM.getInputsFor = getInputsFor, fdjtDOM.getInputFor = function(root, name, value) {
        var results = getInputsFor(root, name || !1, value || !1);
        return results && 1 === results.length ? results[0] : results && results.length ? (fdjtLog.warn("Ambiguous input reference name=%o name=%o under %o", name, name, root), 
        results[0]) : !1;
    }, fdjtDOM.setInputs = setInputs, fdjtDOM.getStyle = getStyle, fdjtDOM.styleString = styleString;
    var display_styles = {
        DIV: "block",
        P: "block",
        BLOCKQUOTE: "block",
        H1: "block",
        H2: "block",
        H3: "block",
        H4: "block",
        H5: "block",
        H6: "block",
        H7: "block",
        H8: "block",
        UL: "block",
        LI: "list-item",
        DL: "block",
        DT: "list-item",
        DD: "list-item",
        SPAN: "inline",
        EM: "inline",
        STRONG: "inline",
        TT: "inline",
        DEFN: "inline",
        A: "inline",
        TD: "table-cell",
        TR: "table-row",
        TABLE: "table",
        PRE: "preformatted"
    };
    fdjtDOM.getDisplay = getDisplayStyle, fdjtDOM.textify = textify, Geometry.prototype.width = Geometry.prototype.height = Geometry.prototype.left = Geometry.prototype.right = Geometry.prototype.top = Geometry.prototype.bottom = 0, 
    XGeometry.prototype = new Geometry(), XGeometry.top_margin = XGeometry.bottom_margin = XGeometry.left_margin = XGeometry.right_margin = XGeometry.top_border = XGeometry.bottom_border = XGeometry.left_border = XGeometry.right_border = XGeometry.top_padding = XGeometry.bottom_padding = XGeometry.left_padding = XGeometry.right_padding = XGeometry.outer_height = XGeometry.outer_width = XGeometry.inner_height = XGeometry.inner_width = XGeometry.line_height = 0, 
    fdjtDOM.getGeometry = getGeometry, fdjtDOM.XGeometry = XGeometry, fdjtDOM.Geometry = Geometry, 
    fdjtDOM.geomString = geomString, fdjtDOM.isVisible = isVisible, fdjtDOM.isAtTop = isAtTop, 
    fdjtDOM.textWidth = textwidth, fdjtDOM.countBreaks = countBreaks;
    var nontext_content = /(img|object|svg|hr)/i;
    fdjtDOM.hasContent = hasContent, fdjtDOM.hasText = hasText, fdjtDOM.refresh = function(elt) {
        elt.className = elt.className;
    }, fdjtDOM.setAttrib = function(elt, attrib, val) {
        "string" == typeof elt && fdjtID(elt) && (elt = fdjtID(elt)), elt.setAttribute(attrib, val), 
        elt.className = elt.className;
    }, fdjtDOM.dropAttrib = function(elt, attrib) {
        "string" == typeof elt && fdjtID(elt) && (elt = fdjtID(elt)), elt.removeAttribute(attrib), 
        elt.className = elt.className;
    }, fdjtDOM.overflowing = function(node) {
        return node.scrollHeight > node.clientHeight;
    }, fdjtDOM.voverflow = function(node) {
        return node.scrollHeight / node.clientHeight;
    }, fdjtDOM.hoverflow = function(node) {
        return node.scrollWidth / node.clientWidth;
    }, fdjtDOM.addListener = addListener, fdjtDOM.defListeners = defListeners;
    var events_pat = /^([^:]+)$/, spec_events_pat = /^([^: ]+):([^: ]+)$/;
    fdjtDOM.addListeners = addListeners, fdjtDOM.removeListener = removeListener, fdjtDOM.T = eventTarget, 
    fdjtDOM.eventTarget = eventTarget, fdjtDOM.getTarget = eventTarget, fdjtDOM.cancel = cancelEvent, 
    fdjtDOM.triggerClick = triggerClick, fdjtDOM.pageScroll = pageScroll;
    var default_trace_adjust = !1;
    fdjtDOM.getInsideBounds = getInsideBounds, fdjtDOM.applyScale = applyScale, fdjtDOM.adjustToFit = adjustToFit, 
    fdjtDOM.adjustInside = adjustInside, fdjtDOM.insideBounds = getInsideBounds, fdjtDOM.finishScale = function(container) {
        var traced = container.traceadjust || fdjtDOM.trace_adjust || default_trace_adjust;
        return container.bestscale ? (container.scale === container.bestscale || applyScale(container, container.bestscale, traced), 
        traced && fdjtLog("Final scale %o~%o for %o style=%s", container.bestscale, container.bestfit, fdjtDOM.nodeString(container), fdjtDOM.styleString(container)), 
        delete container.bestscale, delete container.bestfit, delete container.goodscale, 
        void 0) : (applyScale(container, !1, traced), fdjtLog("No good scaling for %o style=%s", fdjtDOM.nodeString(container), fdjtDOM.styleString(container)), 
        void 0);
    }, fdjtDOM.scaleToFit = scaleToFit, fdjtDOM.scaleToFit.scaleNode = fdjtDOM.scaleToFit.adjust = scale_node, 
    fdjtDOM.scaleToFit.revert = scale_revert, fdjtDOM.scaleToFit.revertAll = revertAll, 
    fdjt.addInit(scaleAll), fdjtDOM.addListener(window, "resize", scaleAll), fdjtDOM.getHTML = getHTML, 
    fdjtDOM.getHEAD = getHEAD;
    var schema2tag = {}, tag2schema = {}, app_schemas = {};
    fdjtDOM.addAppSchema = function(name, spec) {
        app_schemas[name] = spec;
    };
    var escapeRX = fdjtString.escapeRX;
    fdjtDOM.getMeta = getMeta, fdjtDOM.getMetaElts = function(name) {
        var matchcase;
        return getMeta(name, !0, matchcase, !0);
    }, fdjtDOM.getLink = getLink, fdjtDOM.getLinks = function(name) {
        return getLink(name, !0);
    }, fdjtDOM.getLinkElts = function(name) {
        var matchcase;
        return getLink(name, !0, matchcase, !0);
    };
    var havechildren = document && document.body && document.body.childNodes && document.body.children;
    fdjtDOM.nextElt = next_element, fdjtDOM.forwardElt = forward_element, fdjtDOM.forward = scan_forward, 
    fdjtDOM.next = scan_next, fdjtDOM.prevElt = previous_element, fdjtDOM.backwardElt = backward_element, 
    fdjtDOM.backward = scan_backward, fdjtDOM.prev = scan_previous, fdjtDOM.viewTop = function(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? !win || win === window || window.Window && win instanceof window.Window ? (win = win || window, 
        win.pageYOffset || win.scrollY || win.document.documentElement.scrollTop || 0) : win.scrollTop : void 0;
    }, fdjtDOM.viewLeft = function(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? !win || win === window || window.Window && win instanceof window.Window ? (win = win || window, 
        win.pageXOffset || win.scrollX || win.document.documentElement.scrollLeft || 0) : win.scrollLeft : void 0;
    }, fdjtDOM.viewHeight = viewHeight, fdjtDOM.viewWidth = viewWidth, fdjtDOM.getOrientation = getOrientation;
    var id_count = 0, unique = Math.floor(1e5 * Math.random());
    fdjtDOM.getNodeID = getNodeID, fdjtDOM.stripIDs = stripIDs, fdjtDOM.getCSSRule = getCSSRule, 
    fdjtDOM.dropCSSRule = dropCSSRule, fdjtDOM.addCSSRule = addCSSRule;
    var nosvg;
    fdjtDOM.useSVG = useSVG, fdjtDOM.useBMP = useBMP, fdjtDOM.prefSVG = prefSVG, fdjtDOM.checkSVG = checkSVG, 
    fdjtDOM.init = fdjt.Init, fdjtDOM.addInit = fdjt.addInit, fdjt.addInit(checkChildren, "checkChildren"), 
    fdjt.addInit(checkSVG, "checkSVG"), navigator.userAgent.search("WebKit") >= 0 ? (fdjtDOM.transition || (fdjtDOM.transition = "-webkit-transition"), 
    fdjtDOM.transitionProperty || (fdjtDOM.transitionProperty = "-webkit-transition-property"), 
    fdjtDOM.transitionDuration || (fdjtDOM.transitionDuration = "-webkit-transition-duration"), 
    fdjtDOM.transitionDelay || (fdjtDOM.transitionDelay = "-webkit-transition-delay"), 
    fdjtDOM.transitionTiming || (fdjtDOM.transitionTiming = "-webkit-transition-timing-function"), 
    fdjtDOM.transform || (fdjtDOM.transform = "-webkit-transform"), fdjtDOM.transformOrigin || (fdjtDOM.transformOrigin = "-webkit-transform-origin"), 
    fdjtDOM.columnWidth || (fdjtDOM.columnWidth = "-webkit-column-width"), fdjtDOM.columnGap || (fdjtDOM.columnGap = "-webkit-column-gap")) : navigator.userAgent.search("Mozilla") >= 0 ? (fdjtDOM.transition || (fdjtDOM.transition = "-moz-transition"), 
    fdjtDOM.transitionProperty || (fdjtDOM.transitionProperty = "-moz-transition-property"), 
    fdjtDOM.transitionDuration || (fdjtDOM.transitionDuration = "-moz-transition-duration"), 
    fdjtDOM.transitionDelay || (fdjtDOM.transitionDelay = "-moz-transition-delay"), 
    fdjtDOM.transitionTiming || (fdjtDOM.transitionTiming = "-moz-transition-timing-function"), 
    fdjtDOM.transform || (fdjtDOM.transform = "-moz-transform"), fdjtDOM.transformOrigin || (fdjtDOM.transformOrigin = "-moz-transform-origin"), 
    fdjtDOM.columnWidth || (fdjtDOM.columnWidth = "MozColumnWidth"), fdjtDOM.columnGap || (fdjtDOM.columnGap = "MozColumnGap")) : (fdjtDOM.transition || (fdjtDOM.transition = "transition"), 
    fdjtDOM.transitionProperty || (fdjtDOM.transitionProperty = "transition-property"), 
    fdjtDOM.transitionDuration || (fdjtDOM.transitionDuration = "transition-duration"), 
    fdjtDOM.transitionDelay || (fdjtDOM.transitionDelay = "transition-delay"), fdjtDOM.transitionTiming || (fdjtDOM.transitionTiming = "transition-timing-function"), 
    fdjtDOM.transform || (fdjtDOM.transform = "transform"), fdjtDOM.transformOrigin || (fdjtDOM.transformOrigin = "-moz-transform-origin")), 
    document.hidden !== void 0 ? (fdjtDOM.isHidden = "hidden", fdjtDOM.vischange = "visibilitychange") : document.webkitHidden !== void 0 ? (fdjtDOM.isHidden = "webkitHidden", 
    fdjtDOM.vischange = "webkitvisibilitychange") : document.mozHidden !== void 0 ? (fdjtDOM.isHidden = "mozHidden", 
    fdjtDOM.vischange = "mozvisibilitychange") : document.msHidden !== void 0 ? (fdjtDOM.isHidden = "msHidden", 
    fdjtDOM.vischange = "msvisibilitychange") : (fdjtDOM.isHidden = !1, fdjtDOM.vischange = !1), 
    fdjtDOM.getSelectedRange = function(sel) {
        if (sel) ; else if (window.getSelection) sel = window.getSelection(); else {
            if (!document.selection) return !1;
            sel = document.selection.createRange();
        }
        if (!sel) return !1;
        if (sel.getRangeAt) return sel.rangeCount ? sel.getRangeAt(0) : !1;
        if (document.createRange) {
            var range = document.createRange();
            return range.setStart(sel.anchorNode, sel.anchorOffset), range.setEnd(sel.focusNode, sel.focusOffset), 
            range;
        }
        return !1;
    }, fdjtDOM.rangeIsEmpty = function(range) {
        return range ? range.startContainer === range.endContainer && range.startOffset === range.endOffset ? !0 : !1 : !0;
    }, fdjtDOM.clearSelection = function(sel) {
        sel || (sel = document.selection || window.getSelection()), sel.removeAllRanges ? sel.removeAllRanges() : sel.empty && sel.empty();
    }, fdjtDOM.node2text = node2text, fdjtDOM.textPos = textPos, fdjtDOM.refineRange = function(range) {
        if (3 === range.startContainer.nodeType && 3 === range.endContainer.nodeType) return range;
        var start_info = textPos(range.startContainer, range.startOffset), end_info = textPos(range.endContainer, range.endOffset), newrange = document.createRange();
        return newrange.setStart(start_info.node, start_info.off), newrange.setEnd(end_info.node, end_info.off), 
        newrange;
    }, fdjtDOM.textOff = textOff, fdjtDOM.getRangeInfo = function(range, within) {
        var start = range.startContainer;
        within || (within = getIDParent(start));
        var start_edge = textOff(within, start, 0), end = range.endContainer, ends_in = start === end ? within : getParent(end, within) ? within : getIDParent(end), end_edge = start === end ? start_edge : textOff(ends_in, end, 0);
        return {
            start: start_edge + range.startOffset,
            starts_in: within.id,
            ends_in: ends_in.id,
            end: end_edge + range.endOffset
        };
    }, fdjtDOM.getRegexString = getRegexString, fdjtDOM.textRegExp = textRegExp, fdjtDOM.wordRegExp = wordRegExp, 
    fdjtDOM.findString = findString, fdjtDOM.findMatches = findMatches;
    var transition_events = [ "transitionend", "webkitTransitionEnd", "mozTransitionEnd", "oTransitionEnd", "msTransitionEnd" ];
    fdjt.addInit(checkTransitionEvents, "checkTransitionEvents");
    var custom_input_types = [ "email", "number", "range", "tel", "url", "datetime", "datetime-local", "date", "time", "week", "month" ];
    return fdjtDOM.setupCustomInputs = setupCustomInputs, fdjt.addInit(setupCustomInputs, "CustomInputs"), 
    fdjtDOM.text_types = /\b(text|email|number|range|tel|url|datetime|datetime-local|date|time|week|month)\b/i, 
    fdjt.addInit(checkMedia, "matchMedia"), fdjt.getMediaState = getMediaState, fdjtDOM.insertText = insertText, 
    fdjt.addInit(getMetaSchemas, "MetaSchemas"), fdjt.noinit && void 0 !== _fdjt_init && _fdjt_init || fdjtDOM.addListener(window, "load", fdjtDOM.init), 
    fdjtDOM.playAudio = playAudio, fdjtDOM.tweakImage = tweakImage, fdjtString.makeBlob = makeBlob, 
    fdjtDOM.data2URL = data2URL, fdjtDOM.addUXClasses = addUXClasses, fdjtDOM.addUSClasses = addUXClasses, 
    fdjtDOM.addCXClasses = addUXClasses, fdjt.addInit(addUXClasses, "AddUXClasses"), 
    fdjtDOM.focus = focusElt, fdjtDOM.blur = blurElt, fdjt.addInit(trackPageFocus), 
    fdjtDOM.trace_adjust = !1, fdjtDOM;
}(), function() {
    "use strict";
    function fakeAnimationFrame(callback) {
        var currTime = new Date().getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        return lastTime = currTime + timeToCall, id;
    }
    function cancelFakeAnimationFrame(id) {
        clearTimeout(id);
    }
    for (var lastTime = 0, rAF = window.requestAnimationFrame && function(thunk) {
        window.requestAnimationFrame(thunk);
    }, cAF = window.cancelAnimationFrame && function(thunk) {
        window.cancelAnimationFrame(thunk);
    }, vendors = [ "webkit", "moz", "ms", "o" ], x = 0; vendors.length > x && !window.requestAnimationFrame; ++x) rAF = rAF || window[vendors[x] + "RequestAnimationFrame"], 
    cAF = cAF || window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    rAF || (rAF = fakeAnimationFrame, cAF = cancelFakeAnimationFrame), fdjt.DOM.rAF = fdjt.DOM.requestAnimationFrame = rAF, 
    fdjt.DOM.cAF = fdjt.DOM.cancelAnimationFrame = cAF;
}(), function() {
    "use strict";
    function toArray(arg) {
        return Array.prototype.slice.call(arg);
    }
    function adjustWrapperFont(wrapper, delta, done, size, min, max, w, h, fudge, dolog) {
        var nw, nh, newsize, ow = floor(wrapper.scrollWidth), oh = floor(wrapper.scrollHeight), wstyle = wrapper.style;
        if ("number" != typeof fudge && (fudge = 1), w >= ow && h >= oh && oh >= h - fudge) return size;
        for ((ow > w || oh > h) && (delta = -delta), delta > 0 && (wstyle.maxWidth = floor(w) + "px"), 
        size || (size = 100, wstyle.fontSize = size + "%"), min || (min = 20), max || (max = 150), 
        newsize = size + delta, wstyle.fontSize = newsize + "%", nw = floor(wrapper.scrollWidth), 
        nh = floor(wrapper.scrollHeight); size >= min && max >= size && (delta > 0 ? w > nw && h > nh : nw > w || nh > h); ) size = newsize, 
        newsize += delta, wstyle.fontSize = newsize + "%", dolog && fdjtLog("Adjust %o to %dx%d %o: size=%d=%d+(%d), %dx%d => %dx%d", wrapper.parentNode, w, h, wrapper, newsize, size, delta, ow, oh, nw, nh), 
        nw = floor(wrapper.scrollWidth), nh = floor(wrapper.scrollHeight);
        return wstyle.maxWidth = "", delta > 0 ? (wstyle.fontSize = size + "%", size) : newsize;
    }
    function adjustFontSize(node, min_font, max_font, fudge) {
        var h = node.offsetHeight, w = node.offsetWidth, dolog = hasClass(node, "_fdjtlog"), node_display = "";
        if ((0 === h || 0 === w) && (node_display = node.style.display, node.style.display = "initial", 
        h = node.offsetHeight, w = node.offsetWidth, 0 === h || 0 === w)) return node.style.display = node_display, 
        void 0;
        if (0 === h || 0 === w) return node.style.display = node_display, void 0;
        var wrapper = wrapChildren(node, "div.fdjtfontwrapper"), wstyle = wrapper.style, size = 100;
        if (wstyle.boxSizing = "border-box", wstyle.padding = wstyle.margin = "0px", wstyle.fontSize = size + "%", 
        wstyle.transitionProperty = "none", wstyle.transitionDuration = "0s", wstyle[fdjtDOM.transitionProperty] = "none", 
        wstyle[fdjtDOM.transitionDuration] = "0s", wstyle.visibility = "visible", 0 === h || 0 === w) return node.removeChild(wrapper), 
        fdjtDOM.append(node, toArray(wrapper.childNodes)), node.style.display = node_display, 
        void 0;
        var min = min_font || node.getAttribute("data-minfont") || 20, max = max_font || node.getAttribute("data-maxfont") || 200;
        if ("number" != typeof fudge && (fudge = node.getAttribute("data-fudge")), "string" == typeof min && (min = parseFloat(min, 10)), 
        "string" == typeof max && (max = parseFloat(max, 10)), "string" == typeof fudge && (fudge = parseInt(fudge, 10)), 
        "number" != typeof fudge && (fudge = 2), wstyle.width = wstyle.height = "100%", 
        w = wrapper.offsetWidth, h = wrapper.offsetHeight, wstyle.width = wstyle.height = "100%", 
        wstyle.maxWidth = wstyle.maxHeight = "100%", w = wrapper.offsetWidth, h = wrapper.offsetHeight, 
        wstyle.width = wstyle.height = "", size = adjustWrapperFont(wrapper, 10, !1, size, min, max, w, h, fudge, dolog), 
        size = adjustWrapperFont(wrapper, 5, !1, size, min, max, w, h, fudge, dolog), size = adjustWrapperFont(wrapper, 1, !1, size, min, max, w, h, fudge, dolog), 
        wstyle.maxWidth = wstyle.maxHeight = "", node.style.display = node_display, 100 === size) dolog && fdjtLog("No need to resize %o towards %dx%d", node, w, h), 
        node.removeChild(wrapper), fdjtDOM.append(node, toArray(wrapper.childNodes)); else {
            wstyle.width = "", wstyle.height = "", wstyle.maxWidth = "", wstyle.maxHeight = "", 
            dolog && fdjtLog("Adjusted (%s) %o towards %dx%d, wrapper @ %d,%d", wstyle.fontSize, node, w, h, wrapper.scrollWidth, wrapper.scrollHeight), 
            wstyle.transitionProperty = "", wstyle.transitionDuration = "", wstyle[fdjtDOM.transitionProperty] = "", 
            wstyle[fdjtDOM.transitionDuration] = "";
            var cwstyle = getStyle(wrapper);
            cwstyle[fdjtDOM.transitionProperty] ? (wstyle.fontSize = "", wstyle.visibility = "", 
            wstyle.fontSize = size + "%") : wstyle.visibility = "";
        }
        return size;
    }
    function resetFontSize(node) {
        var wrapper = getFirstChild(node, ".fdjtfontwrapper");
        wrapper && (wrapper.style.fontSize = "100%");
    }
    function adjustFonts(arg, top) {
        var all = [];
        if (arg) if ("string" == typeof arg) document.getElementByID(arg) ? all = [ document.getElementByID(arg) ] : (fdjtDOM.autofont = fdjtDOM.autofont + "," + arg, 
        all = fdjtDOM.$(arg)); else if (1 === arg.nodeType) {
            var sel = new Selector(fdjtDOM.autofont);
            all = sel.match(arg) ? [ arg ] : fdjtDOM.getChildren(arg, fdjtDOM.autofont);
        } else all = fdjtDOM.$(fdjtDOM.autofont); else all = fdjtDOM.$(fdjtDOM.autofont);
        var i = 0, lim = all.length;
        if (lim) for (;lim > i; ) adjustFontSize(all[i++]); else top && adjustFontSize(top);
    }
    function adjustPositionedChildren(node) {
        if (node && 1 === node.nodeType) {
            var style = getStyle(node);
            if (node.childNodes && node.childNodes.length) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                1 === child.nodeType && adjustPositionedChildren(child);
            }
            "block" !== style.display && "inline-block" !== style.display || "absolute" !== style.position && "fixed" !== style.position || adjustFontSize(node);
        }
    }
    function adjustLayoutFonts(node) {
        var marked = fdjtDOM.getChildren(node, fdjtDOM.autofont), i = 0, lim = marked.length;
        if (0 === lim) adjustPositionedChildren(node); else for (;lim > i; ) adjustFontSize(marked[i++]);
    }
    function autoAdjustFonts() {
        fdjtDOM.noautofontadjust || (adjustFonts(), fdjtDOM.addListener(window, "resize", adjustFonts));
    }
    var floor = Math.floor, fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, getFirstChild = fdjtDOM.getFirstChild, wrapChildren = fdjtDOM.wrapChildren, getStyle = fdjtDOM.getStyle, Selector = fdjtDOM.Selector, hasClass = fdjtDOM.hasClass;
    fdjtDOM.adjustFontSize = fdjtDOM.tweakFontSize = adjustFontSize, fdjtDOM.resetFontSize = resetFontSize, 
    fdjtDOM.autofont = ".fdjtadjustfont,.adjustfont", fdjtDOM.tweakFont = fdjtDOM.tweakFonts = fdjtDOM.adjustFont = fdjtDOM.adjustFonts = adjustFonts, 
    fdjtDOM.adjustLayoutFonts = adjustLayoutFonts, fdjt.addInit(autoAdjustFonts, "adjustFonts");
}(), "undefined" == typeof window || window.JSON || (window.JSON = {}), function() {
    "use strict";
    function f(n) {
        return 10 > n ? "0" + n : n;
    }
    function quote(string) {
        return escapable.lastIndex = 0, escapable.test(string) ? '"' + string.replace(escapable, function(a) {
            var c = meta[a];
            return "string" == typeof c ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
        var i, k, v, length, partial, mind = gap, value = holder[key];
        switch (value && "object" == typeof value && "function" == typeof value.toJSON && (value = value.toJSON(key)), 
        "function" == typeof rep && (value = rep.call(holder, key, value)), typeof value) {
          case "string":
            return quote(value);

          case "number":
            return isFinite(value) ? value + "" : "null";

          case "boolean":
          case "null":
            return value + "";

          case "object":
            if (!value) return "null";
            if (gap += indent, partial = [], "[object Array]" === Object.prototype.toString.apply(value)) {
                for (length = value.length, i = 0; length > i; i += 1) partial[i] = str(i, value) || "null";
                return v = 0 === partial.length ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]", 
                gap = mind, v;
            }
            if (rep && "object" == typeof rep) for (length = rep.length, i = 0; length > i; i += 1) k = rep[i], 
            "string" == typeof k && (v = str(k, value), v && partial.push(quote(k) + (gap ? ": " : ":") + v)); else for (k in value) Object.hasOwnProperty.call(value, k) && (v = str(k, value), 
            v && partial.push(quote(k) + (gap ? ": " : ":") + v));
            return v = 0 === partial.length ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}", 
            gap = mind, v;
        }
    }
    "function" != typeof Date.prototype.toJSON && (Date.prototype.toJSON = function() {
        return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
    }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
        return this.valueOf();
    });
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
    }, rep;
    "function" != typeof JSON.stringify && (JSON.stringify = function(value, replacer, space) {
        var i;
        if (gap = "", indent = "", "number" == typeof space) for (i = 0; space > i; i += 1) indent += " "; else "string" == typeof space && (indent = space);
        if (rep = replacer, replacer && "function" != typeof replacer && ("object" != typeof replacer || "number" != typeof replacer.length)) throw Error("JSON.stringify");
        return str("", {
            "": value
        });
    }), "function" != typeof JSON.parse && (JSON.parse = function(text, reviver) {
        function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && "object" == typeof value) for (k in value) Object.hasOwnProperty.call(value, k) && (v = walk(value, k), 
            void 0 !== v ? value[k] = v : delete value[k]);
            return reviver.call(holder, key, value);
        }
        var j;
        if (cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function(a) {
            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), 
        "function" == typeof reviver ? walk({
            "": j
        }, "") : j;
        throw new SyntaxError("JSON.parse");
    });
}(), fdjt.JSON || (fdjt.JSON = JSON), fdjt.RefDB = function() {
    "use strict";
    function RefDB(name, init) {
        var db = this;
        if (refdbs[name] ? (db = refdbs[name], init && db.init ? db.xinits ? db.xinits.push(init) : db.xinits = [ init ] : init ? db.init = init : init = {}) : init && init.aliases && checkAliases(init.aliases) ? (db = checkAliases(init.aliases), 
        db.aliases.indexOf(db.name) >= 0 && (db.name = name), init && db.init ? db.xinits ? db.xinits.push(init) : db.xinits = [ init ] : init ? db.init = init : init = {}) : (init || (init = {}), 
        db.name = name, refdbs[name] = db, all_refdbs.push(db), db.aliases = [], db.complete = !1, 
        db.refs = {}, db.altrefs = {}, db.allrefs = [], db.loaded = [], db.changes = [], 
        db.changed = !1, db.storage = init.storage || !1, db.absrefs = init.absrefs || !1, 
        db.oidrefs = init.oidrefs || !1, db.onload = [], db.onloadnames = {}, db.onadd = {}, 
        db.ondrop = {}, db.indices = {}), init.hasOwnProperty("absrefs") && (db.absrefs = init.absrefs), 
        init.aliases) for (var aliases = init.aliases, i = 0, lim = aliases.length; lim > i; ) {
            var alias = aliases[i++];
            aliases[alias] ? aliases[alias] !== db && warn("Alias %s for %o already associated with %o", alias, db, aliases[alias]) : (aliases[alias] = db, 
            db.aliases.push(alias));
        }
        if (init.onload) {
            var onload = init.onload;
            for (var methname in onload) onload.hasOwnProperty(methname) && db.onLoad(onload[methname], methname);
        }
        if (init.indices) for (var index_specs = init.indices, j = 0, jlim = index_specs.length; jlim > j; ) {
            var ix = index_specs[j++];
            if ("string" != typeof ix) warn("Complex indices not yet handled!"); else {
                var index = db.indices[ix] = new ObjectMap();
                index.fordb = db;
            }
        }
        return db;
    }
    function checkAliases(aliases) {
        for (var i = 0, lim = aliases.length; lim > i; ) {
            var alias = aliases[i++], db = refdbs[alias];
            if (db) return db;
        }
        return !1;
    }
    function refDBProbe(name) {
        return refdbs.hasOwnProperty(name) && refdbs[name] || aliases.hasOwnProperty(name) && aliases[name] || !1;
    }
    function resolveRef(arg, db, DBType, force) {
        if ("function" != typeof DBType && (DBType = RefDB), !arg) return arg;
        if (arg instanceof Ref) return arg;
        if ("object" == typeof arg && arg.id) return object2ref(arg, db);
        if (db && db.refs.hasOwnProperty(arg)) return db.refs[arg];
        if (db && db.probe(arg)) return db.probe(arg);
        if ("string" == typeof arg && refpat.exec(arg)) {
            var at = arg.indexOf("@");
            if (1 === at && ":" === arg[0] && (arg = arg.slice(1), at = 0), at > 0) {
                var origin, usedb = !1, dbname = arg.slice(at + 1);
                (usedb = refDBProbe(dbname)) || (refpat.exec(dbname) ? (origin = resolveRef(dbname), 
                origin ? force = !0 : dbname = arg.slice(at + 1)) : dbname = arg.slice(at + 1)), 
                usedb = db && db.name === dbname ? db : refDBProbe(dbname), arg = arg.slice(0, at), 
                usedb ? db = usedb : force ? (warn("Creating forced RefDB domain %s for reference %s", dbname, arg), 
                db = RefDB.open(dbname, DBType)) : db = refDBProbe(dbname), db && origin && (db.origin = origin, 
                origin.name && (db.fullname = origin.name)), arg = arg.slice(0, at);
            } else if (0 > at) {
                var uuid;
                uuid = 0 === arg.search(":#U") ? arg.slice(3) : 0 === arg.search("#U") ? arg.slice(2) : 0 === arg.search("U") ? arg.slice(1) : arg;
                var type = uuid.indexOf("t"), tail = arg.length - 2;
                type = type > 0 ? "UUID" + uuid.slice(type) : !1, tail = tail > 0 ? "-UUIDTYPE=" + uuid.slice(tail) : !1;
                var known_db = type && (refdbs[type] || aliases[type]) || tail && (refdbs[tail] || aliases[tail]);
                known_db ? db = known_db : force && type && DBType && (warn("Creating forced RefDB domain %s for reference %s", type, arg), 
                db = new DBType(type), type && db.addAlias(type));
            } else if ("@" === arg[1]) {
                var idstart = arg.indexOf("/"), atid = arg.slice(0, idstart), atdb = aliases[atid];
                if (atdb) db = atdb; else {
                    var domain = getLocal(arg.slice(0, idstart), !0);
                    domain ? db = new RefDB(domain, {
                        aliases: [ atid ]
                    }) : (warn("Can't find domain for atid %s when resolving %s", atid, arg), db = !1);
                }
            } else {
                var atprefix, slash;
                "/" === arg[1] ? (slash = arg.slice(2).indexOf("/"), slash > 0 && (slash += 2)) : slash = arg.indexOf("/"), 
                atprefix = arg.slice(at, slash + 1), db = refdbs[atprefix] || aliases[atprefix] || DBType && new DBType(atprefix);
            }
        }
        return db ? db.refs.hasOwnProperty(arg) ? db.refs[arg] : force ? db.ref(arg) : !1 : !1;
    }
    function Ref(id, db, instance) {
        if (0 === arguments.length) return this;
        var at = id.indexOf("@");
        if (at > 1 && "\\" !== id[at - 1]) {
            var domain = id.slice(at + 1);
            domain !== db.name && 0 > db.aliases.indexOf(domain) && warn("Reference to %s being handled by %s", id, db), 
            id = id.slice(0, at);
        }
        return db.refs.hasOwnProperty(id) ? db.refs[id] : instance ? (instance._id = id, 
        instance._db = db, db.absrefs || (instance._domain = db.name), db.refs[id] = instance, 
        db.allrefs.push(instance), instance) : !db.refclass || this instanceof db.refclass ? (this._id = id, 
        this._db = db, db.absrefs || (this._domain = db.name), db.refs[id] = this, db.allrefs.push(this), 
        this) : new db.refclass(id, db);
    }
    function object2ref(value, db, dbtype) {
        var ref, dbref = !1;
        return value._domain && (dbref = RefDB.probe(value._domain) || new RefDB(value._domain)), 
        ref = dbref ? dbref.ref(value._id) : RefDB.resolve(value._id, db, dbtype || RefDB, !0);
    }
    function importValue(value, db, refstrings) {
        if (value === void 0 || "number" == typeof value || null === value) return value;
        if (value instanceof Ref) return value;
        if (value instanceof Array) {
            for (var i = 0, lim = value.length, copied = !1; lim > i; ) {
                var v = value[i++], nv = v;
                if (null === v) nv = void 0; else if (v instanceof Ref) nv = v; else if ("object" == typeof v && v._id) {
                    var ref = object2ref(v, db);
                    if (ref) {
                        for (var slot in v) v.hasOwnProperty(slot) && "_id" !== slot && "_db" !== slot && (ref[slot] = importValue(v[slot], db, refstrings));
                        nv = ref;
                    }
                } else refstrings && "string" == typeof v && refpat.exec(v) && (nv = resolveRef(v, db) || v);
                nv === void 0 ? copied || (copied = value.slice(0, i - 1)) : copied ? copied.push(nv) : nv !== v && (copied = value.slice(0, i - 1), 
                copied.push(nv));
            }
            return copied ? copied : value;
        }
        if ("object" == typeof value && value._id) {
            var refv = object2ref(value, db);
            for (var vslot in value) value.hasOwnProperty(vslot) && "_id" !== vslot && "_db" !== vslot && (refv[vslot] = importValue(value[vslot], db, refstrings));
            return refv;
        }
        return refstrings && "string" == typeof value && refpat.exec(value) ? resolveRef(value, db) || value : value;
    }
    function defImport(item, refs, db, rules, flags) {
        var ref = resolveRef(item._id, item._domain || db, db.constructor, !0);
        ref ? (refs.push(ref), ref.Import(item, rules || !1, flags)) : warn("Couldn't resolve database for %o", item._id);
    }
    function exportValue(value, db) {
        if (value instanceof Ref) return value._db === db ? {
            _id: value._id
        } : value._db.absrefs ? {
            _id: value._id
        } : {
            _id: value._id,
            _domain: value._domain || value._db.name
        };
        if (value instanceof Array) {
            for (var i = 0, lim = value.length, exports = !1; lim > i; ) {
                var elt = value[i++], exported = exportValue(elt, db);
                elt !== exported ? exports ? exports.push(exported) : (exports = value.slice(0, i - 1), 
                exports.push(exported)) : exports && exports.push(elt);
            }
            return exports || value;
        }
        if ("object" == typeof value) {
            var copied = !1, fields = [];
            for (var field in value) if (value.hasOwnProperty(field)) {
                var fieldval = value[field], exportval = exportValue(fieldval, db);
                if (fieldval !== exportval) {
                    if (!copied && (copied = {}, fields.length)) for (var j = 0, jlim = fields.length; jlim > j; ) {
                        var f = fields[j++];
                        copied[f] = value[f];
                    }
                    copied[field] = exportval;
                } else copied ? copied[field] = fieldval : fields.push(field);
            }
            return copied || value;
        }
        return value;
    }
    function getatid(storage, db) {
        if (db.atid) return db.atid;
        var atid = storage["atid(" + db.name + ")"];
        if (atid) return db.atid = atid, atid;
        var count = storage["atid.count"];
        return count ? (count = parseInt(count, 10), atid = db.atid = "@@" + count, storage["atid(" + db.name + ")"] = atid, 
        storage["atid.count"] = count + 1) : (atid = count = 1, storage["atid.count"] = "2"), 
        atid;
    }
    function getKeyString(val, db) {
        return val instanceof Ref ? val._db === db ? "@" + val._id : val._domain ? "@" + val._id + "@" + val._domain : "@" + val._id : "number" == typeof val ? "#" + val : "string" == typeof val ? '"' + val : val.toJSON ? "{" + val.toJSON() : "&" + ("" + val);
    }
    function arr_contains(arr, val, start) {
        return arr.indexOf(val, start || 0) >= 0;
    }
    function arr_position(arr, val, start) {
        return arr.indexOf(val, start || 0);
    }
    function set_sortfn(a, b) {
        return a === b ? 0 : typeof a == typeof b ? "number" == typeof a ? a - b : "string" == typeof a ? b > a ? -1 : 1 : a._qid ? b._qid ? b._qid > a._qid ? -1 : 1 : -1 : b._qid ? 1 : a._fdjtid && b._fdjtid ? b._fdjtid > a._fdjtid ? -1 : 1 : 0 : typeof b > typeof a ? -1 : 1;
    }
    function intersection(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return [];
        if (!set2 || 0 === set2.length) return [];
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var results = [], i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings, new_allstrings = !0; len1 > i && len2 > j; ) set1[i] === set2[j] ? (new_allstrings && "string" != typeof set1[i] && (new_allstrings = !1), 
        results.push(set1[i]), i++, j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? i++ : j++;
        return results._allstrings = new_allstrings, results._sortlen = results.length, 
        results;
    }
    function difference(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return [];
        if (!set2 || 0 === set2.length) return set1;
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var results = [], i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings, new_allstrings = !0; len1 > i && len2 > j; ) set1[i] === set2[j] ? (i++, 
        j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? (new_allstrings && "string" != typeof set1[i] && (new_allstrings = !1), 
        results.push(set1[i]), i++) : j++;
        if (!new_allstrings || set1._allstrings) results = results.concat(set1.slice(i)); else for (;len1 > i; ) {
            var elt = set1[i++];
            new_allstrings && "string" != typeof elt && (new_allstrings = !1), results.push(elt);
        }
        return results._allstrings = new_allstrings, results._sortlen = results.length, 
        results;
    }
    function union(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return set2;
        if (!set2 || 0 === set2.length) return set1;
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var results = [], i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings; len1 > i && len2 > j; ) set1[i] === set2[j] ? (results.push(set1[i]), 
        i++, j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? results.push(set1[i++]) : results.push(set2[j++]);
        for (;len1 > i; ) results.push(set1[i++]);
        for (;len2 > j; ) results.push(set2[j++]);
        return results._allstrings = allstrings, results._sortlen = results.length, results;
    }
    function merge(set1, set2) {
        var merged = [];
        if (merged._sortlen = 0, set1 instanceof Array || (set1 = [ set1 ]), set2 instanceof Array || (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return set2 && 0 !== set2.length ? (merged = merged.concat(set2), 
        set2._sortlen ? (merged._sortlen = set2._sortlen, merged._allstrings = set2._allstrings, 
        merged) : setify(merged)) : merged;
        if (!set2 || 0 === set2.length) return merge(set2, set1);
        set1._sortlen !== set1.length && (set1 = setify(set1)), set2._sortlen !== set2.length && (set2 = setify(set2));
        for (var i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings; len1 > i && len2 > j; ) set1[i] === set2[j] ? (merged.push(set1[i]), 
        i++, j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? merged.push(set1[i++]) : merged.push(set2[j++]);
        for (;len1 > i; ) merged.push(set1[i++]);
        for (;len2 > j; ) merged.push(set2[j++]);
        return merged._allstrings = allstrings, merged._sortlen = merged.length, merged;
    }
    function overlaps(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return !1;
        if (!set2 || 0 === set2.length) return !1;
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings; len1 > i && len2 > j; ) {
            if (set1[i] === set2[j]) return !0;
            (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? i++ : j++;
        }
        return !1;
    }
    function fdjtSet(arg) {
        var result = [];
        if (result._sortlen = 0, 0 === arguments.length) return result;
        if (1 === arguments.length) return arg ? arg instanceof Array ? arg.length && arg._sortlen !== arg.length ? "number" == typeof arg._sortlen ? setify(arg) : setify([].concat(arg)) : arg : (result = [ arg ], 
        "string" == typeof arg && (result._allstrings = !0), result._sortlen = 1, result) : result;
        var i = 0, lim = arguments.length;
        for (result = []; lim > i; ) {
            var each_arg = arguments[i++];
            each_arg && (each_arg instanceof Array ? result = result.concat(each_arg) : result.push(each_arg));
        }
        return setify(result);
    }
    function setify(array) {
        var len;
        if (array._sortlen === (len = array.length)) return array;
        if (0 === len) return array._sortlen = 0, array;
        if (1 === len) {
            var elt1 = array[0];
            return array._sortlen = 1, array._allstrings = "string" == typeof elt1, "object" == typeof elt1 && (elt1._qid || elt1._fdjtid || (elt1.getQID ? elt1._qid = elt1.getQID() : elt1._fdjtid = ++id_counter)), 
            array;
        }
        for (var allstrings = !0, i = 0, lim = array.length; lim > i; ) {
            var elt = array[i++];
            allstrings && "string" != typeof elt && (allstrings = !1, "object" == typeof elt && (elt._qid || elt._fdjtid || (elt.getQID ? elt._qid = elt.getQID() : elt._fdjtid = ++id_counter)));
        }
        if (array._allstrings = allstrings, 1 === lim) return array;
        allstrings ? array.sort() : array.sort(set_sortfn);
        for (var read = 1, write = 1, readlim = array.length, cur = array[0]; readlim > read; ) array[read] !== cur ? array[write++] = cur = array[read++] : read++;
        return array._sortlen = array.length = write, array;
    }
    function set_add(set, val) {
        if (val instanceof Array) {
            var changed = !1;
            for (var elt in val) set_add(set, elt) && (changed = !0);
            return changed;
        }
        if (set.indexOf) {
            var pos = set.indexOf(val);
            return pos >= 0 ? !1 : (set.push(val), !0);
        }
        for (var i = 0, lim = set.length; lim > i; ) {
            if (set[i] === val) return !1;
            i++;
        }
        return "string" != typeof val && (set._allstrings = !1), set.push(val), !0;
    }
    function set_drop(set, val) {
        if (val instanceof Array) {
            var changed = !1;
            for (var elt in val) set_drop(set, elt) && (changed = !0);
            return changed;
        }
        if (set.indexOf) {
            var pos = set.indexOf(val);
            return 0 > pos ? !1 : (set.splice(pos, 1), !0);
        }
        for (var i = 0, lim = set.length; lim > i; ) {
            if (set[i] === val) return set.splice(i, 1), !0;
            i++;
        }
        return !1;
    }
    function setCall(fn, val) {
        return Array.isArray(val) ? val._sortlen && val._sortlen === val.length ? fn(val) : fn(setify(val)) : fn([ val ]);
    }
    function ObjectMap() {
        return this;
    }
    function StringMap() {
        return this;
    }
    function RefMap(db) {
        return this._db = db, this;
    }
    function countKeys(obj) {
        var count = 0;
        for (var key in obj) obj.hasOwnProperty(key) && count++;
        return count;
    }
    function localKeys(obj) {
        var keys = [];
        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
        return keys;
    }
    function Query(dbs, clauses, weights) {
        if (0 === arguments.length) return this;
        dbs && (this.dbs = dbs), clauses && (this.clauses = clauses instanceof Array ? clauses : [ clauses ]), 
        weights && (this.weights = weights);
        var i = 0, n_dbs = dbs.length;
        if (n_dbs > 1) for (;n_dbs > i; ) {
            if (!dbs[i].absrefs) return this;
            i++;
        }
        return this.uniqueids = !0, this;
    }
    function sortbyweight(f1, f2) {
        return f2.weight - f1.weight;
    }
    function useIndexedDB(dbname, version, init, opts) {
        function usingIndexedDB(resolve, reject) {
            if (indexedDB === void 0 || !indexedDB.open) {
                if (fdjtLog.warn("No indexedDB implementation for opening %:", vname), !reject) throw Error("No indexedDB implementation");
                reject(Error("No indexedDB implementation"));
            }
            try {
                var req = indexedDB.open(dbname, version), fail = !1, init_timeout = setTimeout(function() {
                    fail = !0, fdjtLog.warn("Init timeout for indexedDB %s", vname), reject(Error("Init timeout"));
                }, opts.timeout || 15e3);
                req.onerror = function(event) {
                    return fail = !0, warn("Error initializing indexedDB: %o", event.errorCode), init_timeout && clearTimeout(init_timeout), 
                    reject ? reject(event) : event;
                }, req.onsuccess = function(evt) {
                    if (fail) return fdjtLog("Discarding indexedDB %s after failure!", vname), void 0;
                    var db = evt.target.result;
                    return init_timeout && clearTimeout(init_timeout), trace && fdjtLog("Got existing IndexedDB %s %o", vname, db), 
                    resolve ? resolve(db) : db;
                }, req.onupgradeneeded = function(evt) {
                    var db = evt.target.result;
                    if (!init) return resolve(db);
                    if (req.onsuccess = function() {
                        return resolve ? resolve(db) : db;
                    }, req.onerror = function(evt) {
                        if (fdjtLog("Error upgrading %s %o", vname, evt), !reject) throw Error("Error upgrading %s", vname);
                        reject(evt);
                    }, init.call) try {
                        return init(db), resolve ? resolve(db) : db;
                    } catch (ex) {
                        fdjtLog("Error upgrading %s:%d: %o", dbname, version, ex), reject && reject(ex);
                    } else {
                        if (!reject) throw Error("Bad indexDB init: %o", init);
                        reject(Error("Bad indexDB init: %o", init));
                    }
                    return db;
                };
            } catch (ex) {
                fdjtLog("usingIndexedDB failed: %o", ex), reject && reject(ex);
            }
        }
        version && !opts && "number" != typeof version && version.version ? (opts = version, 
        version = opts.version) : opts || (opts = {}), init || (init = opts.init || !1), 
        version || (version = 1);
        var trace = opts.trace, vname = dbname + ":" + version;
        return new Promise(usingIndexedDB);
    }
    var fdjtState = fdjt.State, fdjtTime = fdjt.Time, fdjtAsync = fdjt.Async, fdjtDOM = fdjt.DOM, JSON = fdjt.JSON, fdjtLog = fdjt.Log, warn = fdjtLog.warn, refdbs = {}, all_refdbs = [], changed_dbs = [], aliases = {}, iDB = fdjt.iDB, indexedDB = iDB.indexedDB;
    RefDB.prototype.name = RefDB.prototype.aliases = RefDB.prototype.refs = RefDB.prototype.altrefs = RefDB.prototype.allrefs = RefDB.prototype.loaded = RefDB.prototype.changes = RefDB.prototype.changed = RefDB.prototype.storage = RefDB.prototype.absrefs = RefDB.prototype.oidrefs = RefDB.prototype.onload = RefDB.prototype.onadd = RefDB.prototype.indices = RefDB.prototype.complete = !1;
    var REFINDEX = RefDB.REFINDEX = 2, REFLOAD = RefDB.REFLOAD = 4, REFSTRINGS = RefDB.REFSTRINGS = 8, default_flags = REFINDEX | REFSTRINGS;
    RefDB.open = function(name, DBClass) {
        return DBClass || (DBClass = RefDB), refdbs.hasOwnProperty(name) && refdbs[name] || aliases.hasOwnProperty(name) && aliases[name] || new DBClass(name);
    }, RefDB.probe = refDBProbe, RefDB.prototype.addAlias = function(alias) {
        aliases[alias] ? aliases[alias] !== this && warn("Alias %s for %o already associated with %o", alias, this, aliases[alias]) : (aliases[alias] = this, 
        this.aliases.push(alias));
    }, RefDB.prototype.toString = function() {
        return "RefDB(" + this.name + ")";
    }, RefDB.prototype.ref = function(id) {
        if ("string" != typeof id) {
            if (id instanceof Ref) return id;
            throw Error("Not a reference");
        }
        ":" === id[0] && "@" === id[1] && (id = id.slice(1));
        var refs = this.refs;
        return refs.hasOwnProperty(id) && refs[id] || this.refclass && new this.refclass(id, this) || new Ref(id, this);
    }, RefDB.prototype.probe = function(id) {
        if ("string" != typeof id) return id instanceof Ref ? id : !1;
        ":" === id[0] && "@" === id[1] && (id = id.slice(1));
        var refs = this.refs;
        return refs.hasOwnProperty(id) && refs[id];
    }, RefDB.prototype.drop = function(refset) {
        var count = 0, refs = this.refs, altrefs = this.altrefs;
        refset instanceof Array || (refset = [ refset ]);
        for (var i = 0, nrefs = refset.length; nrefs > i; ) {
            var id, ref = refset[i++];
            if (ref instanceof Ref ? id = ref._id : (id = ref, ref = this.probe(id)), ref) {
                count++;
                var aliases = ref.aliases, pos = this.allrefs.indexOf(ref);
                if (pos >= 0 && this.allrefs.splice(pos, 1), pos = this.changes.indexOf(ref), pos >= 0 && this.changes.splice(pos, 1), 
                pos = this.loaded.indexOf(ref), pos >= 0 && this.loaded.splice(pos, 1), delete refs[id], 
                this.storage instanceof Storage) {
                    var storage = this.storage, key = "allids(" + this.name + ")", allidsval = storage[key], allids = allidsval && JSON.parse(allidsval), idpos = allids.indexOf(id);
                    idpos >= 0 && (allids.splice(idpos, 1), storage.setItem(key, JSON.stringify(allids)), 
                    storage.removeItem(id));
                }
                if (aliases) for (var j = 0, jlim = aliases.length; jlim > j; ) delete altrefs[aliases[j++]];
            }
        }
        return count;
    }, RefDB.prototype.clearOffline = function(callback) {
        if (!this.storage) return !1;
        if (!(Storage && this.storage instanceof Storage)) return this.storage instanceof indexedDB ? void 0 : !1;
        var storage = this.storage, key = "allids(" + this.name + ")", allids = this.storage[key];
        if (allids && (allids = JSON.parse(allids)), allids) for (var i = 0, lim = allids.length; lim > i; ) delete storage[allids[i++]];
        delete storage[key], callback && setTimeout(callback, 5);
    }, RefDB.prototype.onLoad = function(method, name, noupdate) {
        if (name && this.onloadnames[name]) {
            var cur = this.onloadnames[name];
            if (cur === method) return;
            var pos = this.onload.indexOf(cur);
            if (0 > cur) return warn("Couldn't replace named onload method %s for <RefDB %s>", name, this.name), 
            void 0;
            this.onload[pos] = method;
        } else this.onload.push(method);
        if (name && (this.onloadnames[name] = method), !noupdate) {
            var loaded = [].concat(this.loaded);
            fdjtAsync.slowmap(method, loaded);
        }
    }, RefDB.prototype.onAdd = function(name, method) {
        this.onadd[name] = method;
    }, RefDB.prototype.onDrop = function(name, method) {
        this.ondrop[name] = method;
    };
    var refpat = /^(((:|)@(([0-9a-fA-F]+\/[0-9a-fA-F]+)|(\/\w+\/.*)|(@\d+\/.*)))|((U|#U|:#U|)[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12})|((U|#U|:#U|)[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}t[0-9a-zA-Z]+)|([^@]+@.+))$/, getLocal = fdjtState.getLocal;
    RefDB.resolve = resolveRef, RefDB.ref = resolveRef, fdjt.Ref = RefDB.Ref = Ref, 
    Ref.prototype._db = Ref.prototype._domain = Ref.prototype._qid = Ref.prototype._id = !1, 
    Ref.prototype.toString = function() {
        return this._qid ? this._qid : this._domain ? this._id + "@" + this._domain : this._db.absrefs ? this._id : this._id + "@" + this._db.name;
    }, Ref.prototype.getQID = function() {
        var qid;
        return this._qid ? this._qid : qid = this._qid = this._domain ? this._id + "@" + this._domain : this._db.absrefs ? this._id : this._id + "@" + this._db.name;
    }, Ref.prototype.addAlias = function(term) {
        var refs = this._db.refs;
        if (refs.hasOwnProperty(term)) {
            if (refs[term] === this) return !1;
            throw {
                error: "Ref alias conflict"
            };
        }
        if (this._db.altrefs.hasOwnProperty(term)) {
            if (this._db.altrefs[term] === this) return !1;
            throw {
                error: "Ref alias conflict"
            };
        }
        return this._db.altrefs[term] = this, !0;
    }, Ref.prototype.Import = function(data, rules, flags) {
        var db = this._db, live = this._live, indices = db.indices, onload = db.onload, onadd = live && db.onadd, ondrop = live && db.ondrop, aliases = data.aliases;
        flags === void 0 && (flags = default_flags), rules === void 0 && (rules = this.import_rules || db.import_rules);
        var indexing = 0 !== (flags & REFINDEX), loading = 0 !== (flags & REFLOAD), refstrings = 0 !== (flags & REFSTRINGS);
        if (aliases) for (var ai = 0, alim = aliases.length; alim > ai; ) {
            var alias = aliases[ai++], cur = db.refs.hasOwnProperty(alias) && db.refs[alias] || db.altrefs.hasOwnProperty(alias) && db.altrefs[alias];
            cur && cur !== this ? warn("Ambiguous ref %s in %s refers to both %o and %o", alias, db, cur.name, this.name) : aliases[alias] = this;
        }
        var now = fdjtTime();
        loading && !this._live && (this._live = now);
        for (var key in data) if ("aliases" === key || "_id" === key) ; else if (data.hasOwnProperty(key)) {
            var value = data[key], rule = rules && rules[key];
            value !== void 0 && (rule && (value = rule(this, key, value, data, indexing)), value = importValue(value, db, refstrings));
            var oldval = live && this[key];
            if (this[key] = value, oldval) {
                var drops = difference(oldval, value || []), adds = value ? difference(value, oldval) : [];
                if (indexing && indices[key] && (adds.length && this.indexRef(key, adds, indices[key], db), 
                drops.length && this.dropIndexRef(key, drops, indices[key], db)), adds.length && onadd[key]) for (var addfn = onadd[key], addi = 0, addlen = adds.length; addlen > addi; ) addfn(adds[addi++]);
                if (drops.length && ondrop[key]) for (var dropfn = ondrop[key], dropi = 0, droplen = drops.length; droplen > dropi; ) dropfn(drops[dropi++]);
            } else value && indexing && indices[key] && this.indexRef(key, value, indices[key], db);
        }
        if (loading) {
            if (onload) for (var i = 0, lim = onload.length; lim > i; ) {
                var loadfn = onload[i++];
                loadfn(this, now);
            }
            if (this._onload) {
                for (var onloads = this._onload, inits = onloads.fns, j = 0, jlim = inits.length; jlim > j; ) inits[j++](this, now);
                delete this._onload;
            }
        }
        loading || this._changed || (this._changed = now, db.changes.push(this), db.changed || (db.changed = now, 
        db.changes.push(db)));
    }, Ref.prototype.importValue = function(value, refstrings) {
        return importValue(this._db, value, refstrings);
    }, RefDB.prototype.importValue = function(val, refstrings) {
        return importValue(val, this, refstrings);
    }, RefDB.prototype.Import = function(data, rules, flags, callback) {
        var refs = [], db = this;
        if (!(data instanceof Array)) return defImport(data, refs, db, rules, flags), callback ? (callback.call && setTimeout(function() {
            callback(refs[0]);
        }), refs[0]) : refs[0];
        if (!callback || 7 >= data.length) {
            for (var i = 0, lim = data.length; lim > i; ) defImport(data[i++], refs, db, rules, flags);
            return callback && callback.call && setTimeout(function() {
                callback(refs);
            }, 10), refs;
        }
        callback.call ? fdjtAsync.slowmap(function(item) {
            defImport(item, refs, db, rules, flags);
        }, data, {
            done: function() {
                callback(refs);
            }
        }) : fdjtAsync.slowmap(function(item) {
            defImport(item, refs, db, rules, flags);
        }, data);
    }, Ref.prototype.onLoad = function(fn, name) {
        if (this._live) fn(this); else if (this._onload) {
            if (this._onload[name]) return;
            name && (this._onload[name] = fn), this._onload.fns.push(fn);
        } else this._onload = {
            fns: [ fn ]
        }, name && (this._onload[name] = fn);
    }, Ref.Export = Ref.prototype.Export = function(xforms) {
        var db = this._id, exported = {
            _id: this._id
        };
        xforms || (xforms = this.export_rules || db.export_rules), db.absrefs || (this._domain = db.name);
        for (var key in this) if ("_" !== key[0] && this.hasOwnProperty(key)) {
            var value = this[key], xform = xforms && xforms[key];
            xform && (value = xform(value, key, exported)), value === void 0 || (exported[key] = "number" == typeof value || "string" == typeof value ? value : value instanceof Ref ? value._db.absrefs ? {
                _id: value._id
            } : {
                _id: value._id,
                _domain: value._domain || value._db.name
            } : exportValue(value, this._db));
        }
        return exported;
    }, Ref.exportValue = exportValue, RefDB.prototype.exportValue = function(val) {
        return exportValue(val, this);
    }, RefDB.prototype.load = function(refs, callback, args) {
        function docallback() {
            callback && (args ? callback.apply(null, args) : callback());
        }
        function load_ref(arg, loaded, storage) {
            var content, ref = arg;
            return "string" == typeof ref && (ref = db.ref(ref, !1, !0)), ref ? (ref._live || (loaded.push(ref), 
            absrefs ? content = storage[ref._id] : atid ? content = storage[atid + "(" + ref._id + ")"] : (atid = db.atid ? db.atid : db.atid = getatid(storage, db), 
            content = storage[atid + "(" + ref._id + ")"]), content ? ref.Import(JSON.parse(content), !1, REFLOAD | REFINDEX) : warn("No item stored for %s", ref._id)), 
            void 0) : (warn("Couldn't resolve ref to %s", arg), void 0);
        }
        if (this.storage) {
            if (this.storage instanceof Storage) {
                if (refs) if (refs === !0) {
                    var all = this.storage["allids(" + this.name + ")"];
                    refs = all ? JSON.parse(all).concat(this.allrefs) : [].concat(this.allrefs);
                } else refs instanceof Ref ? refs = [ refs ] : "string" == typeof refs ? refs = [ refs ] : refs.length === void 0 && (refs = [ refs ]); else refs = [].concat(this.allrefs);
                for (var storage = this.storage, loaded = this.loaded, db = this, absrefs = this.absrefs, refmap = this.refs, atid = !1, needrefs = [], i = 0, lim = refs.length; lim > i; ) {
                    var refid = refs[i++], ref = refid;
                    "string" == typeof refid && (ref = refmap[refid]), ref instanceof Ref && ref._live || needrefs.push(refid);
                }
                if (needrefs.length) {
                    var opts = callback ? args ? {
                        done: docallback
                    } : {
                        done: callback
                    } : !1;
                    return fdjtAsync.slowmap(function(arg) {
                        load_ref(arg, loaded, storage);
                    }, needrefs, opts);
                }
                return docallback(), new Promise(function(resolve) {
                    resolve(refs);
                });
            }
            this.storage instanceof window.indexedDB;
        }
    }, RefDB.prototype.load = function(refs) {
        return this.storage instanceof Storage ? this.loadFromStorage(refs) : !1;
    }, RefDB.prototype.loadFromStorage = function(refs) {
        function storage_loader(arg, loaded) {
            var content, ref = arg;
            return "string" == typeof ref && (ref = db.ref(ref, !1, !0)), ref ? (ref._live || (content = absrefs ? storage[ref._id] : atid ? storage[atid + "(" + ref._id + ")"] : storage[atid + "(" + ref._id + ")"], 
            content && (loaded.push(ref), ref.Import(JSON.parse(content), !1, REFLOAD | REFINDEX))), 
            void 0) : (warn("Couldn't resolve ref to %s", arg), void 0);
        }
        var db = this, storage = this.storage, loaded = this.loaded, atid = db.atid || (db.atid = getatid(storage, db)), needrefs = [], refmap = db.refs, absrefs = db.absrefs;
        if (refs) if (refs === !0) {
            var all = storage["allids(" + db.name + ")"] || "[]";
            refs = JSON.parse(all).concat(db.allrefs);
        } else Array.isArray(refs) || (refs = [ refs ]); else refs = [].concat(db.allrefs);
        for (var i = 0, lim = refs.length; lim > i; ) {
            var refid = refs[i++], ref = refid;
            "string" == typeof refid && (ref = refmap[refid]), ref instanceof Ref && ref._live || needrefs.push(refid);
        }
        return needrefs.length ? fdjtAsync.slowmap(function(arg) {
            storage_loader(arg, loaded, storage);
        }, needrefs) : new Promise(function(resolve) {
            for (var resolved = [], i = 0, lim = refs.length; lim > i; ) {
                var refid = refs[i++];
                ref = "string" == typeof ref ? refmap[refid] : refid, resolved.push(ref);
            }
            return resolve(resolved);
        });
    }, RefDB.prototype.loadref = function(ref) {
        return "string" == typeof ref && (ref = this.ref(ref)), ref.load();
    }, Ref.prototype.load = function() {
        function loadref(resolve) {
            return ref._live ? resolve(ref) : (db.load(ref).then(function() {
                resolve(ref);
            }), void 0);
        }
        var ref = this, db = this._db;
        return new Promise(loadref);
    }, RefDB.load = function(spec, dbtype, callback, args) {
        if ("string" == typeof spec) {
            var ref = RefDB.resolve(spec, !1, dbtype || RefDB, !0);
            if (ref) return ref.load(callback, args);
            throw {
                error: "Couldn't resolve " + spec
            };
        }
        if (spec instanceof Ref) return spec.load(callback, args);
        if (spec instanceof Array) {
            for (var loads = {}, dbs = [], i = 0, lim = spec.length; lim > i; ) {
                var s = spec[i++], r = !1;
                if ("string" == typeof s ? r = RefDB.resolve(s, !1, dbtype || RefDB, !0) : s instanceof Ref && (r = s), 
                r && !r._live) {
                    var db = r._db, name = db.name;
                    loads[name] ? loads[name].push(r) : (loads[name] = [ r ], dbs.push(db));
                }
            }
            for (i = 0, lim = dbs.length; lim > i; ) {
                var loadfrom = dbs[i++];
                loadfrom.load(loads[loadfrom.name], args);
            }
            return loads;
        }
        return !1;
    }, RefDB.prototype.saveToStorage = function(refs, updatechanges) {
        function savingLocally(resolve) {
            for (var i = 0, lim = refs.length; lim > i; ) {
                var ref = refs[i++];
                if ("string" == typeof ref && (ref = db.ref(ref)), ref._live && (!ref._saved || ref._changed)) {
                    var exported = ref.Export();
                    if (exported._saved = fdjtTime.tick(), db.absrefs) ids.push(ref._id), storage.setItem(ref._id, JSON.stringify(exported)); else {
                        atid || (atid = ref.atid ? ref.atid : ref.atid = getatid(storage, ref));
                        var id = atid + "(" + ref._id + ")";
                        ids.push(id), storage.setItem(id, JSON.stringify(exported));
                    }
                    ref._changed = !1;
                }
            }
            if (updatechanges) {
                for (var changes = db.changes, new_changes = [], j = 0, n_changed = changes.length; n_changed > j; ) {
                    var c = changes[j++];
                    c._changed && new_changes.push(c);
                }
                if (db.changes = new_changes, 0 === new_changes.length) {
                    db.changed = !1;
                    var pos = changed_dbs.indexOf(db);
                    pos >= 0 && changed_dbs.splice(pos, 1);
                }
            }
            var allids = storage["allids(" + db.name + ")"];
            allids = allids ? JSON.parse(allids) : [];
            var n = allids.length;
            allids = merge(allids, ids), allids.length !== n && storage.setItem("allids(" + db.name + ")", JSON.stringify(allids)), 
            resolve && fdjt.ASync(resolve);
        }
        var db = this, storage = this.storage, atid = this.atid, ids = [];
        return new Promise(savingLocally);
    }, RefDB.prototype.save = function(refs, updatechanges) {
        function saving(resolve) {
            if (db.storage instanceof Storage) db.saveToStorage(refs, updatechanges).then(function() {
                db.changed = !1, db.changes = [];
                var pos = changed_dbs.indexOf(db);
                pos >= 0 && changed_dbs.splice(pos, 1), resolve && resolve();
            }); else if (!(db.storage instanceof window.indexedDB)) return resolve();
        }
        var db = this, storage = this.storage;
        return refs === !0 ? refs = this.allrefs : refs || (refs = this.changes), storage ? new Promise(saving) : !1;
    }, Ref.prototype.save = function() {
        function saveref(resolve) {
            return ref._changed ? db.save([ ref ]).then(function() {
                resolve(ref);
            }) : resolve(ref);
        }
        var ref = this, db = this._db;
        return new Promise(saveref);
    }, RefDB.getKeyString = getKeyString, Ref.prototype.indexRef = function(key, val, index, db) {
        var keystrings = [], rdb = this._db, refstring = !db || rdb === db || rdb.absrefs ? this._id : this._qid || this.getQID && this.getQID();
        db || (db = rdb);
        var indices = db.indices;
        if (index || (index = indices.hasOwnProperty(key) && indices[key]), !index) return warn("No index on %s for %o in %o", key, this, db), 
        !1;
        if (val instanceof Ref) keystrings = rdb === val._db ? [ "@" + val._id ] : [ "@" + (val._qid || val.getQID()) ]; else if (val instanceof Array) {
            db = this._db;
            for (var i = 0, lim = val.length; lim > i; ) {
                var elt = val[i++];
                elt instanceof Ref ? keystrings.push("@" + (elt._qid || elt.getQID())) : "number" == typeof elt ? keystrings = [ "#" + elt ] : "string" == typeof elt ? keystrings = [ '"' + elt ] : elt._qid ? keystrings.push("@" + (elt._qid || elt.getQID())) : elt.getQID && keystrings.push("@" + elt.getQID());
            }
        } else keystrings = "number" == typeof val ? [ "#" + val ] : "string" == typeof val ? [ '"' + val ] : [ "?" + ("" + val) ];
        if (keystrings.length) {
            for (var j = 0, jlim = keystrings.length; jlim > j; ) {
                var keystring = keystrings[j++], refs = index[keystring];
                refs ? refs.push(refstring) : index[keystring] = [ refstring ];
            }
            return keystrings.length;
        }
        return !1;
    }, Ref.prototype.dropIndexRef = function(key, val, index, db) {
        if (db || (db = this._db), index || (index = db.indices[key]), !index) return !1;
        var keystrings = [];
        if (val instanceof Ref) keystrings = this._db === val._db ? [ "@" + val._id ] : [ "@" + (val._qid || val.getQID()) ]; else if (val instanceof Array) for (var i = 0, lim = val.length; lim > i; ) {
            var elt = val[i++];
            elt instanceof Ref ? keystrings.push("@" + (elt._qid || elt.getQID())) : "number" == typeof elt ? keystrings = [ "#" + val ] : "string" == typeof elt ? keystrings = [ '"' + val ] : elt._qid ? keystrings.push("@" + (elt._qid || elt.getQID())) : elt.getQID && keystrings.push("@" + elt.getQID());
        } else "number" == typeof val ? keystrings = [ "#" + val ] : "string" == typeof val && (keystrings = [ '"' + val ]);
        if (keystrings.length) {
            for (var deleted = 0, j = 0, jlim = keystrings.length; jlim > j; ) {
                var keystring = keystrings[j++], refs = index[keystring];
                if (refs) {
                    var pos = refs.indexOf(this._id);
                    0 > pos || (refs.splice(pos, 1), 0 === refs.length && delete index[keystring], deleted++);
                }
            }
            return deleted;
        }
        return !1;
    }, RefDB.prototype.find = function(key, value) {
        var index = this.indices[key];
        if (index) {
            var items = index.getItem(value, this);
            return items ? setify(items) : [];
        }
        return [];
    }, RefDB.prototype.findRefs = function(key, value) {
        var index = this.indices[key];
        if (index) {
            var items = index.getItem(value, this), results = [];
            if (items) for (var i = 0, lim = items.length; lim > i; ) {
                var item = items[i++];
                if (item) if ("string" == typeof item) {
                    var ref = this.probe(item);
                    ref && results.push(ref);
                } else results.push(item); else ;
            }
            return fdjtSet(results);
        }
        return [];
    }, RefDB.prototype.count = function(key, value) {
        var index = this.indices[key];
        if (index) {
            var vals = index.getItem(value, this);
            return vals ? vals.length || 0 : 0;
        }
        return 0;
    }, RefDB.prototype.addIndex = function(key, Constructor) {
        if (Constructor || (Constructor = ObjectMap), this.indices.hasOwnProperty(key)) return this.indices[key];
        var index = this.indices[key] = new Constructor();
        return index.fordb = this, index;
    };
    var id_counter = 1;
    return RefDB.compare = set_sortfn, RefDB.intersection = intersection, RefDB.difference = difference, 
    RefDB.union = union, RefDB.merge = merge, RefDB.overlaps = overlaps, RefDB.Set = fdjtSet, 
    fdjt.Set = fdjtSet, RefDB.toSet = fdjtSet, Ref.prototype.get = function(prop) {
        return this.hasOwnProperty(prop) ? this[prop] : this._live ? !1 : void 0;
    }, Ref.prototype.getSet = function(prop) {
        if (this.hasOwnProperty(prop)) {
            var val = this[prop];
            return val instanceof Array ? val._sortlen === val.length ? val : setify(val) : setify([ val ]);
        }
        return this._live ? [] : void 0;
    }, Ref.prototype.getArray = function(prop) {
        if (this.hasOwnProperty(prop)) {
            var val = this[prop];
            return val instanceof Array ? val : [ val ];
        }
        return this._live ? [] : void 0;
    }, Ref.prototype.getValue = function(prop) {
        function getting(resolve, reject) {
            return ref.hasOwnProperty(prop) ? resolve(ref[prop]) : ref._live ? resolve(void 0) : ref._db.storage ? ref.load().then(function(r) {
                return resolve(r[prop]);
            }).catch(reject) : resolve(void 0);
        }
        var ref = this;
        return new Promise(getting);
    }, Ref.prototype.getValues = function(prop) {
        function getting(resolve, reject) {
            ref.getValue(prop).then(function(val) {
                return setCall(resolve, val);
            }).catch(reject);
        }
        var ref = this;
        return new Promise(getting);
    }, Ref.prototype.add = function(prop, val, index) {
        function handle_add(resolved) {
            if (val instanceof Array && "number" == typeof val._sortlen) for (var i = 0, lim = val.length; lim > i; ) ref.add(prop, val[i++], index); else {
                if ("aliases" === prop) return db.refs[val] === ref || db.altrefs[val] === ref ? resolved && resolved(!1) : (db.altrefs[val] = ref, 
                ref.aliases ? ref.aliases.push(val) : ref.aliases = [ val ], resolved && resolved(!0));
                if (ref.hasOwnProperty(prop)) {
                    var cur = ref[prop];
                    if (cur === val) return resolved && resolved(!1);
                    if (cur instanceof Array) {
                        if (!set_add(cur, val)) return resolved && resolved(!1);
                    } else ref[prop] = fdjtSet([ cur, val ]);
                } else ref[prop] = val instanceof Array && "number" != typeof val._sortlen ? fdjtSet([ val ]) : val;
            }
            if (!ref._changed) {
                var now = fdjtTime();
                db.changed || changed_dbs.push(db), db.changed = now, ref._changed = now, db.changes.push(ref);
            }
            db.onadd.hasOwnProperty(prop) && db.onadd[prop](ref, prop, val), index && db.indices[prop] && ref.indexRef(prop, ref[prop], db.indices[prop]), 
            resolved && resolved(!0);
        }
        function add_onload() {
            handle_add(!1);
        }
        var ref = this, db = this._db;
        return index === void 0 ? index = db.indices.hasOwnProperty(prop) ? !0 : !1 : index && !db.indices.hasOwnProperty(prop) && db.addIndex(prop), 
        val instanceof Array && 0 === val._sortlen ? new Promise(function(resolve) {
            return resolve(!1);
        }) : !this._live && this._db.storage ? (this._onload ? this._onload.push(add_onload) : this._onload = [ add_onload ], 
        this.load()) : new Promise(handle_add);
    }, Ref.prototype.drop = function(prop, val, dropindex) {
        function handle_drop(resolved) {
            if (!ref.hasOwnProperty(prop)) return resolved && resolved(!1);
            var cur = ref[prop];
            if (cur === val) delete ref[prop]; else {
                if (!(cur instanceof Array)) return resolved && resolved(!1);
                if (!set_drop(cur, val)) return resolved && resolved(!1);
                0 === cur.length && delete ref[prop];
            }
            if (db.ondrop.hasOwnProperty(prop) && db.ondrop[prop](ref, prop, val), !ref._changed) {
                var now = fdjtTime();
                db.changed && (db.changed = now, changed_dbs.push(db)), ref._changed = now, db.changes.push(ref);
            }
            return dropindex && db.indices[prop] && ref.indexRefDrop(prop, db.indices[prop]), 
            resolved && resolved(!0);
        }
        function drop_onload() {
            handle_drop(!1);
        }
        var ref = this, db = this._db;
        return dropindex === void 0 && (dropindex = !0), "_id" === prop ? new Promise(function(resolved) {
            resolved(!1);
        }) : !this._live && this._db.storage ? (this._onload ? this._onload.push(drop_onload) : this._onload = [ drop_onload ], 
        this.load()) : new Promise(handle_drop);
    }, Ref.prototype.test = function(prop, val) {
        if (this.hasOwnProperty(prop)) {
            if (val === void 0) return !0;
            var cur = this[prop];
            return cur === val ? !0 : cur instanceof Array ? arr_contains(cur, val) ? !0 : this._live ? !1 : void 0 : this._live ? !1 : void 0;
        }
        return this._live ? !1 : void 0;
    }, Ref.prototype.store = function(prop, val) {
        var toadd = [], todrop = [];
        if (this.hasOwnProperty(prop)) {
            var cur = this[prop];
            if (cur === val) return !1;
            toadd = difference(val, cur), todrop = difference(cur, val);
        } else toadd = val instanceof Array ? val : [ val ];
        for (var i = 0, lim = todrop.length; lim > i; ) this.drop(prop, todrop[i++]);
        for (i = 0, lim = toadd.length; lim > i; ) this.add(prop, toadd[i++]);
        return !0;
    }, Ref.prototype.toHTML = function() {
        var dom = !1;
        return this._db.forHTML && this._db.forHTML(this) || this._db.forDOM && (dom = this._db.forDOM(this)) && dom.outerHTML || this._id || this.oid || this.uuid;
    }, Ref.prototype.toDOM = function() {
        return this._db.forDOM && this._db.forDOM(this) || this._db.forHTML && fdjtDOM(this._db.forHTML(this)) || fdjtDOM("span.fdjtref", this._id || this.oid || this.uuid);
    }, ObjectMap.prototype.get = function(key) {
        var keystring = getKeyString(key, this.fordb);
        return this.hasOwnProperty(keystring) ? this[keystring] : "string" == typeof key ? this[key] || this["@" + key] : void 0;
    }, ObjectMap.prototype.getItem = ObjectMap.prototype.get, ObjectMap.prototype.set = function(key, val) {
        var keystring = getKeyString(key, this.fordb);
        this[keystring] = val instanceof Array ? [ val ] : val;
    }, ObjectMap.prototype.setItem = ObjectMap.prototype.set, ObjectMap.prototype.increment = function(key, delta) {
        var next, keystring = getKeyString(key, this.fordb), cur = this[keystring];
        return this[keystring] = next = cur ? cur + delta : delta, next;
    }, ObjectMap.prototype.add = function(key, val) {
        var keystring = getKeyString(key, this.fordb);
        if (this.hasOwnProperty(keystring)) {
            var cur = this[keystring];
            return cur === val ? !1 : cur instanceof Array ? arr_contains(cur, val) ? !1 : (cur.push(val), 
            !0) : val instanceof Array ? (this[keystring] = setify([ cur, val ]), !0) : (this[keystring] = setify([ cur, val ]), 
            !0);
        }
        this[keystring] = val instanceof Array ? setify([ val ]) : val;
    }, ObjectMap.prototype.drop = function(key, val) {
        var keystring = getKeyString(key, this.fordb);
        if (this.hasOwnProperty(keystring)) {
            var cur = this[keystring];
            if (cur === val) return delete this[keystring], !0;
            if (cur instanceof Array) {
                var pos = cur.indexOf(val);
                return 0 > pos ? !1 : (cur.splice(pos, 1), cur._sortlen && cur._sortlen--, 1 === cur.length && (cur[0] instanceof Array || (this[keystring] = cur[0])), 
                !0);
            }
            return !1;
        }
        return !1;
    }, fdjt.Map = ObjectMap, RefDB.ObjectMap = ObjectMap, RefDB.fdjtMap = ObjectMap, 
    StringMap.prototype.get = function(keystring) {
        return "string" != typeof keystring ? void 0 : this.hasOwnProperty(keystring) ? this[keystring] : void 0;
    }, StringMap.prototype.getItem = StringMap.prototype.get, StringMap.prototype.set = function(keystring, val) {
        "string" == typeof keystring && (this[keystring] = val instanceof Array ? [ val ] : val);
    }, StringMap.prototype.setItem = StringMap.prototype.set, StringMap.prototype.increment = function(keystring, delta) {
        if ("string" == typeof keystring) {
            var next, cur = this[keystring];
            return this[keystring] = next = cur ? cur + delta : delta, next;
        }
    }, StringMap.prototype.add = function(keystring, val) {
        if ("string" == typeof keystring) {
            if (this.hasOwnProperty(keystring)) {
                var cur = this[keystring];
                return cur === val ? !1 : cur instanceof Array ? arr_contains(cur, val) ? !1 : (cur.push(val), 
                !0) : val instanceof Array ? (this[keystring] = setify([ cur, val ]), !0) : (this[keystring] = setify([ cur, val ]), 
                !0);
            }
            this[keystring] = val instanceof Array ? setify([ val ]) : val;
        }
    }, StringMap.prototype.drop = function(keystring, val) {
        if ("string" == typeof keystring) {
            if (this.hasOwnProperty(keystring)) {
                var cur = this[keystring];
                if (cur === val) return delete this[keystring], !0;
                if (cur instanceof Array) {
                    var pos = cur.indexOf(val);
                    return 0 > pos ? !1 : (cur.splice(pos, 1), cur._sortlen && cur._sortlen--, 1 === cur.length && (cur[0] instanceof Array || (this[keystring] = cur[0])), 
                    !0);
                }
                return !1;
            }
            return !1;
        }
    }, fdjt.StringMap = StringMap, RefDB.StringMap = StringMap, RefMap.prototype.get = function(key) {
        if ("string" == typeof key) return this.hasOwnProperty(key) ? this[key] : void 0;
        if (key instanceof Ref) {
            var id = this.uniqueids && key._id || key._qid || key.getQID();
            return this[id];
        }
        return void 0;
    }, RefMap.prototype.set = function(key, val) {
        if ("string" == typeof key) this[key] = val; else {
            if (!(key instanceof Ref)) return !1;
            var id = key._qid || this.uniqueid && key._id || key.getQID();
            this[id] = val;
        }
    }, RefMap.prototype.increment = function(key, delta) {
        if ("string" == typeof key) this[key] = this.hasOwnProperty(key) ? this[key] + delta : delta; else {
            if (!(key instanceof Ref)) return !1;
            var id = key._qid || this.uniqueids && key._id || key.getQID();
            this[id] = (this[id] || 0) + delta;
        }
    }, fdjt.RefMap = RefDB.RefMap = RefMap, RefDB.add = function(obj, field, val, nodup) {
        if (2 === arguments.length) return set_add(obj, field);
        if (obj instanceof Ref) return obj.add.apply(obj, arguments);
        if (nodup) if (obj.hasOwnProperty(field)) {
            var vals = obj[field];
            arr_contains(vals, val) || obj[field].push(val);
        } else obj[field] = Array(val); else obj.hasOwnProperty(field) ? obj[field].push(val) : obj[field] = Array(val);
        obj._all && !arr_contains(obj._all, field) && obj._all.push(field);
    }, RefDB.drop = function(obj, field, val) {
        if (2 === arguments.length) return set_drop(obj, field);
        if (obj instanceof Ref) return obj.drop.apply(obj, arguments);
        if (val) {
            if (obj.hasOwnProperty(field)) {
                var vals = obj[field], pos = arr_position(vals, val);
                if (0 > pos) return;
                vals.splice(pos, 1);
            }
        } else obj[field] = [];
    }, RefDB.test = function(obj, field, val) {
        return 2 === arguments.length ? arr_contains(obj, field) : obj instanceof Ref ? obj.test.apply(obj, arguments) : val === void 0 ? (obj.hasOwnProperty ? obj.hasOwnProperty(field) : obj[field]) && obj[field].length > 0 : obj.hasOwnProperty(field) ? 0 > arr_position(obj[field], val) ? !1 : !0 : !1;
    }, RefDB.insert = function(array, value) {
        0 > arr_position(array, value) && array.push(value);
    }, RefDB.remove = function(array, value, count) {
        var pos = arr_position(array, value);
        if (0 > pos) return array;
        if (array.splice(pos, 1), count) for (count--; count > 0 && (pos = arr_position(array, value, pos)) >= 0; ) array.splice(pos, 1), 
        count--;
        return array;
    }, RefDB.indexOf = function(array, elt, pos) {
        return pos ? array.indexOf(elt, pos) : array.indexOf(elt);
    }, RefDB.contains = arr_contains, RefDB.position = arr_position, RefDB.countKeys = countKeys, 
    RefDB.localKeys = localKeys, RefDB.Query = Query, Query.prototype.uniqueids = !1, 
    Query.prototype.execute = function() {
        if (this.scores) return this;
        var dbs = this.dbs, clauses = this.clauses;
        if (!dbs || !dbs.length) {
            var empty_result = this.results = fdjtSet();
            return warn("No dbs for query %o!", this), empty_result;
        }
        if (!clauses || !clauses.length) {
            for (var full_result = fdjtSet(), i = 0, lim = dbs.length; lim > i; ) full_result = merge(full_result, setify(dbs[i++].allrefs));
            return this.results = full_result, full_result;
        }
        var query_weights = this._weights || this.weights, uniqueids = 1 === dbs.length || this.uniqueids, scores = new RefMap(), counts = new RefMap(), matches = fdjtSet(), match_seen = {};
        counts.uniqueids = scores.uniqueids = uniqueids;
        for (var i_clause = 0, n_clauses = clauses.length; n_clauses > i_clause; ) {
            var clause = clauses[i_clause++], fields = clause.fields, values = clause.values, clause_weights = clause.weights, findings = [];
            fields instanceof Array || (fields = [ fields ]), values instanceof Array || (values = [ values ]);
            for (var i_field = 0, n_fields = fields.length; n_fields > i_field; ) for (var field = fields[i_field++], weight = clause_weights && clause_weights[field] || query_weights && query_weights[field] || this.default_weight || 1, i_value = 0, n_values = values.length; n_values > i_value; ) for (var value = values[i_value++], i_db = 0, n_dbs = dbs.length; n_dbs > i_db; ) {
                var db = dbs[i_db++], hits = db.find(field, value);
                hits && hits.length && findings.push({
                    field: field,
                    hits: setify(hits),
                    weight: weight,
                    value: value,
                    db: db
                });
            }
            findings.sort(sortbyweight);
            for (var finding_i = 0, n_findings = findings.length, seen = {}; n_findings > finding_i; ) {
                var hit_id, ref, finding = findings[finding_i++], hit_ids = finding.hits, fdb = finding.db, abs = fdb.absrefs, i_hit = 0, n_hits = hit_ids.length;
                if (uniqueids || abs) for (;n_hits > i_hit; ) hit_id = hit_ids[i_hit++], seen[hit_id] || (seen[hit_id] = hit_id, 
                match_seen[hit_id] || (matches.push(fdb.ref(hit_id)), match_seen[hit_id] = hit_id), 
                counts[hit_id] = (counts[hit_id] || 0) + 1, scores[hit_id] = (scores[hit_id] || 0) + finding.weight); else {
                    hit_id = hit_ids[i_hit++], ref = fdb.ref(hit_id);
                    var fullid = ref._qid || abs && ref._id || ref.getQID();
                    if (seen[fullid]) continue;
                    seen[fullid] = fullid, match_seen[fullid] || (matches.push(ref), match_seen[fullid] = fullid), 
                    counts[fullid] = (counts[fullid] || 0) + 1, scores[fullid] = (scores[fullid] || 0) + finding.weight;
                }
            }
        }
        if (n_clauses > 1) {
            for (var results = this.results = [], new_scores = new RefMap(), new_counts = new RefMap(), i_matches = 0, n_matches = matches.length; n_matches > i_matches; ) {
                var match = matches[i_matches++], count = counts.get(match);
                if (count >= 2) {
                    var score = scores.get(match);
                    new_scores.set(match, score), new_counts.set(match, count), results.push(match);
                }
            }
            results._allstrings = !1, results._sortlen = results.length, this.results = results, 
            this.scores = new_scores, this.counts = new_counts;
        } else this.results = setify(matches), this.scores = scores, this.counts = counts;
        return this;
    }, RefDB.useIndexedDB = useIndexedDB, RefDB;
}(), fdjt.Ajax = function() {
    "use strict";
    function compose_uri(base_uri, args) {
        var uri = base_uri, need_amp = !1;
        if ("&" === base_uri[-1] ? need_amp = !1 : base_uri.indexOf("?") >= 0 ? need_amp = !0 : uri = base_uri + "?", 
        "string" == typeof args) uri = uri + (need_amp ? "&" : "") + args; else if (args.length) for (var i = 0; args.length > i; ) args[i] ? (uri = uri + (need_amp ? "&" : "") + encodeURIComponent(args[i]) + "=" + encodeURIComponent(args[i + 1]), 
        need_amp = !0, i += 2) : i += 2; else for (var key in args) args.hasOwnProperty(key) && (uri = uri + (need_amp ? "&" : "") + encodeURIComponent(key) + "=" + encodeURIComponent(args[key]), 
        need_amp = !0);
        return uri;
    }
    function statusOK(req, test) {
        var status = req.status;
        return test ? test.call ? test(req) : Array.isArray(test) ? test.indexOf(status) >= 0 : status >= 200 && 300 > status || 304 === status : status >= 200 && 300 > status || 304 === status;
    }
    function fdjtAjax(success_callback, base_uri, args, other_callback, headers, opts) {
        var timeout = "number" == typeof opts ? opts : opts && opts.timeout;
        "number" == typeof opts ? opts = {} : opts || (opts = {});
        var req = new XMLHttpRequest(), success = opts.success, uri = args ? compose_uri(base_uri, args) : base_uri;
        if (req.onreadystatechange = function() {
            4 === req.readyState && (statusOK(req, success) ? success_callback(req) : other_callback && other_callback(req));
        }, timeout && (req.timeout = timeout, other_callback && (req.ontimeout = function(evt) {
            evt = evt || window.event, other_callback(req);
        })), req.open("GET", uri), req.withCredentials = opts.hasOwnProperty("credentials") ? opts.credentials : !0, 
        headers) for (var key in headers) headers.hasOwnProperty(key) && req.setRequestHeader(key, headers[key]);
        return req.send(null), req;
    }
    function jsonpCall(uri, id, cleanup) {
        if (id && $ID(id)) return !1;
        var script_elt = fdjt.DOM("SCRIPT");
        id && (script_elt.id = id), cleanup && (script_elt.oncleanup = cleanup), script_elt.language = "javascript", 
        script_elt.src = uri, document.body.appendChild(script_elt);
    }
    function jsonpFinish(id) {
        var script_elt = $ID(id);
        script_elt && (script_elt.oncleanup && script_elt.oncleanup(), fdjtDOM.remove(script_elt));
    }
    function add_query_param(parameters, name, value) {
        return (parameters ? parameters + "&" : "") + name + "=" + encodeURIComponent(value);
    }
    function formParams(form) {
        fdjt.UI.AutoPrompt.cleanup(form);
        for (var parameters = !1, inputs = fdjtDOM.getChildren(form, "INPUT"), i = 0; inputs.length > i; ) {
            var input = inputs[i++];
            input.disabled || (/(radio)|(checkbox)/i.exec(input.type) ? !input.checked : 0) || (parameters = add_query_param(parameters, input.name, input.value));
        }
        var textareas = fdjtDOM.getChildren(form, "TEXTAREA");
        for (i = 0; textareas.length > i; ) {
            var textarea = textareas[i++];
            textarea.disabled || (parameters = add_query_param(parameters, textarea.name, textarea.value));
        }
        var selectboxes = fdjtDOM.getChildren(form, "SELECT");
        for (i = 0; selectboxes.length > i; ) for (var selectbox = selectboxes[i++], name = selectbox.name, options = fdjtDOM.getChildren(selectbox, "OPTION"), j = 0; options.length > j; ) {
            var option = options[j++];
            option.selected && (parameters = add_query_param(parameters, name, option.value));
        }
        return parameters;
    }
    function add_field(result, name, value, downcase) {
        if (downcase && (name = name.toLowerCase()), result.hasOwnProperty(name)) {
            var cur = result[name];
            cur.push ? cur.push(value) : result[name] = [ cur, value ];
        } else result[name] = value;
    }
    function formJSON(form, downcase) {
        fdjt.UI.AutoPrompt.cleanup(form);
        for (var result = {}, inputs = fdjtDOM.getChildren(form, "INPUT"), i = 0; inputs.length > i; ) {
            var input = inputs[i++];
            input.disabled || ("radio" === input.type || "checkbox" === input.type ? !input.checked : 0) || add_field(result, input.name, input.value, downcase || !1);
        }
        var textareas = fdjtDOM.getChildren(form, "TEXTAREA");
        for (i = 0; textareas.length > i; ) {
            var textarea = textareas[i++];
            textarea.disabled || add_field(result, textarea.name, textarea.value, downcase || !1);
        }
        var selectboxes = fdjtDOM.getChildren(form, "SELECT");
        for (i = 0; selectboxes.length > i; ) for (var selectbox = selectboxes[i++], name = selectbox.name, options = fdjtDOM.getChildren(selectbox, "OPTION"), j = 0; options.length > j; ) {
            var option = options[j++];
            option.selected && add_field(result, name, option.value, downcase || !1);
        }
        return result;
    }
    function ajaxSubmit(form, callback, opts) {
        var ajax_uri = form.getAttribute("ajaxaction") || form.action;
        if (!ajax_uri) return !1;
        var syncp = form.getAttribute("synchronous");
        trace_ajax && fdjtLog("Direct %s AJAX submit to %s for %o with callback %o", syncp ? "synchronous" : "asynchronous", ajax_uri, form, callback);
        var success = !1, callback_run = !1, req = new XMLHttpRequest(), params = formParams(form);
        fdjtDOM.addClass(form, "submitting"), syncp ? "GET" === form.method ? req.open("GET", ajax_uri + "?" + params, !1) : "PUT" === form.method ? req.open("PUT", ajax_uri, !1) : req.open("POST", ajax_uri, !1) : "GET" === form.method ? req.open("GET", ajax_uri + "?" + params) : "PUT" === form.method ? req.open("PUT", ajax_uri) : req.open("POST", ajax_uri), 
        req.onreadystatechange = function() {
            trace_ajax && fdjtLog("Ajax (%d,%d) %o for %o, callback=%o", req.readyState, 4 === req.readyState && req.status, req, ajax_uri, callback), 
            4 === req.readyState && req.status >= 200 && 300 > req.status ? (callback && trace_ajax && fdjtLog("Got callback (%d,%d) %o for %o, calling %o", req.readyState, req.status, req, ajax_uri, callback), 
            fdjtDOM.dropClass(form, "submitting"), success = !0, callback && callback(req, form), 
            callback_run = !0) : 4 === req.readyState && (fdjtLog("Failed callback (%d,%d) %o for %o, not calling %o", req.readyState, 4 === req.readyState && req.status, req, ajax_uri, callback), 
            fdjtDOM.dropClass(form, "submitting"), callback && callback(req, form), callback_run = !0);
        }, opts && opts.accept && req.setRequestHeader("Accept", opts.accepts), req.withCredentials = opts && opts.hasOwnProperty("creds") ? opts.creds : !0;
        try {
            "GET" === form.method ? req.send() : (req.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), 
            req.send(params)), success = !0;
        } catch (ex) {}
        return syncp && !callback_run && (trace_ajax && fdjtLog("Running callback (rs=%d,status=%d) %o for %o, calling %o", req.readyState, 4 === req.readyState && req.status, req, ajax_uri, callback), 
        4 === req.readyState && req.status >= 200 && 300 > req.status && (fdjtDOM.dropClass(form, "submitting"), 
        success = !0, callback && callback(req, form))), success;
    }
    function jsonpSubmit(form) {
        var jsonp_uri = form.getAttribute("jsonpuri");
        if (!jsonp_uri) return !1;
        var jsonid = form.id ? "JSONP" + form.id : "FORMJSONP", params = formParams(form);
        fdjtDOM.addClass(form, "submitting");
        try {
            jsonpCall(jsonp_uri + "?" + params, jsonid, function() {
                fdjt.DOM.dropClass(form, "submitting");
            });
        } catch (ex) {
            return jsonpFinish(jsonid), fdjtLog.warn("Attempted JSONP call signalled %o", ex), 
            !1;
        }
        return !0;
    }
    function form_submit(evt, callback) {
        evt = evt || window.event || null;
        var form = evt.nodeType ? evt : fdjt.UI.T(evt);
        return fdjt.UI.AutoPrompt.cleanup(form), fdjtDOM.hasClass(form, "submitting") ? (fdjtDOM.dropClass(form, "submitting"), 
        form.fdjtsubmit = !1, !1) : (form.fdjtsubmit = !0, fdjtDOM.addClass(form, "submitting"), 
        ajaxSubmit(form, callback) ? (fdjt.UI.cancel(evt), !0) : jsonpSubmit(form) ? (fdjt.UI.cancel(evt), 
        !0) : !1);
    }
    function copy_args(args, i) {
        var lim = args.length;
        i || (i = 0);
        for (var copy = Array(lim - i); lim > i; ) copy[i] = args[i], i++;
        return copy;
    }
    function sync_get(callback, base_uri, args) {
        var req = new XMLHttpRequest(), uri = compose_uri(base_uri, args);
        return req.open("GET", uri, !1), req.send(null), callback ? callback(req) : req;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, $ID = fdjt.ID, trace_ajax = !1;
    return fdjtAjax.textCall = function(callback, base_uri) {
        return fdjtAjax(function(req) {
            callback(req.responseText);
        }, base_uri, fdjtDOM.Array(arguments, 2));
    }, fdjtAjax.jsonCall = function(callback, base_uri) {
        return fdjtAjax(function(req) {
            callback(JSON.parse(req.responseText));
        }, base_uri, fdjtDOM.Array(arguments, 2));
    }, fdjtAjax.xmlCall = function(callback, base_uri) {
        return fdjtAjax(function(req) {
            callback(req.responseXML);
        }, base_uri, fdjtDOM.Array(arguments, 2));
    }, fdjtAjax.fetch = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(req);
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.fetchText = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(req.responseText);
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.fetchJSON = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(JSON.parse(req.responseText));
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.fetchXML = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(JSON.parse(req.responseXML));
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.jsonpCall = jsonpCall, fdjtAjax.jsonpFinish = jsonpFinish, fdjtAjax.formParams = formParams, 
    fdjtAjax.formJSON = formJSON, fdjtAjax.formSubmit = ajaxSubmit, fdjtAjax.get = function(base_uri) {
        return sync_get(!1, base_uri, copy_args(arguments, 1));
    }, fdjtAjax.getText = function(base_uri) {
        return sync_get(function(req) {
            return req.responseText;
        }, base_uri, copy_args(arguments, 1));
    }, fdjtAjax.getJSON = function(base_uri) {
        return sync_get(function(req) {
            return JSON.parse(req.responseText);
        }, base_uri, fdjtDOM.Array(arguments, 1));
    }, fdjtAjax.getXML = function(base_uri) {
        return sync_get(function(req) {
            return req.responseXML;
        }, base_uri, fdjtDOM.Array(arguments, 1));
    }, fdjtAjax.onsubmit = form_submit, fdjtAjax;
}();

var WSN = function() {
    "use strict";
    function WSN(arg, sortfn, wordfn, keepdup) {
        if ("" === arg) return arg;
        if (!arg && this instanceof WSN) return sortfn && (this.sortfn = sortfn), wordfn && (this.wordfn = wordfn), 
        keepdup && (this.keepdup = keepdup), this;
        if (!arg) return arg;
        if (sortfn === void 0 && (sortfn = WSN.sortfn || !1), wordfn === void 0 && (wordfn = WSN.wordfn || !1), 
        keepdup === void 0 && (keepdup = WSN.keepdup || !1), "string" == typeof arg) {
            var norm = decodeEntities(arg).toLowerCase().replace(punct_regex, "");
            if (norm.trim ? norm = norm.trim() : (norm.search(/\S/) > 0 && (norm = norm.slice(norm.search(/\S/))), 
            norm.search(/\s+$/) > 0 && (norm = norm.slice(0, norm.search(/\s+$/)))), "" === norm) return "";
            var word, xword, i, lim, words = norm.split(/\W*\s+\W*/g), xwords = [], nwords = words.length;
            if (0 === nwords) return "";
            if (words[0] = words[0].replace(/^\W+/, ""), nwords > 1 && (words[nwords - 1] = words[nwords - 1].replace(/\W+$/, "")), 
            wordfn) if ("number" == typeof wordfn) {
                for (i = 0, lim = words.length; lim > i; ) xword = words[i++], word.length > wordfn && xwords.push(xword);
                xwords.length && (words = xwords);
            } else if (wordfn.call) {
                for (i = 0, lim = words.length; lim > i; ) xword = wordfn(words[i++]), xword && xwords.push(xword), 
                i++;
                xwords.length && (words = xwords);
            } else {
                for (i = 0, lim = words.length; lim > i; ) word = words[i++], xword = wordfn[word], 
                "" === xword || (xword && "string" == typeof xword ? xwords.push(xword) : xwords.push(word));
                xwords.length && (words = xwords);
            }
            var sorter = sortfn;
            return sortfn === !0 ? sorter = lensort : sortfn === nativesort && (sorter = !1), 
            sortfn && keepdup ? words.sort(sorter).join(" ") : sortfn ? dedupfn(words.sort(sorter)).join(" ") : words.join(" ");
        }
        if (arg.nodeType) {
            if (3 === arg.nodeType) return WSN(arg.nodeValue);
            if (1 === arg.nodeType) return WSN(textify(arg));
            throw Error("bad arg to WSN");
        }
        throw Error("bad arg to WSN");
    }
    function dedupfn(arr) {
        var i = 0, lim = arr.length, last = !1;
        if (2 > lim) return arr;
        for (;lim > i; ) {
            if (last && arr[i] === last) return dodedup(arr);
            last = arr[i++];
        }
        return arr;
    }
    function dodedup(arr) {
        for (var last = arr[0], result = [ last ], i = 1, lim = arr.length; lim > i; ) arr[i] === last ? i++ : result.push(last = arr[i++]);
        return result;
    }
    function lensort(x, y) {
        var xl = x.length, yl = y.length;
        return xl === yl ? x > y ? -1 : y > x ? 1 : 0 : xl > yl ? -1 : 1;
    }
    function nativesort(x, y) {
        return x > y ? -1 : y > x ? 1 : 0;
    }
    function textify(arg, text) {
        if (arg.nodeType) {
            if (3 === arg.nodeType) return text ? text + arg.nodeValue : arg.nodeValue;
            if (1 === arg.nodeType) {
                var children = arg.childNodes, style = window.getComputedStyle ? window.getComputedStyle(arg) : {
                    position: "static",
                    display: "block"
                };
                if ("static" !== style.position) return text || "";
                "inline" !== style.display ? text = "\n" + (text || "") : text || (text = "");
                for (var i = 0, lim = children.length; lim > i; ) {
                    var child = children[i++];
                    3 === child.nodeType ? text += child.nodeValue : 1 === child.nodeType && (text = textify(child, text));
                }
                return text;
            }
            return text ? text : "";
        }
        return text || "";
    }
    function fuddle(arg, sortfn) {
        return WSN(arg, sortfn || lensort);
    }
    function md5ID() {
        var wsn = WSN.apply(null, arguments);
        if (wsn) {
            if (WSN.md5) return WSN.md5(wsn);
            if (fdjtHash && fdjtHash.hex_md5) return fdjtHash.hex_md5(wsn);
            throw Error("No MD5 implementation");
        }
        return wsn;
    }
    function sha1ID() {
        var wsn = WSN.apply(null, arguments);
        if (wsn) {
            if (WSN.sha1) return WSN.md5(wsn);
            if (fdjtHash && fdjtHash.hex_sha1) return fdjtHash.hex_sha1(wsn);
            throw Error("No SHA1 implementation");
        }
        return wsn;
    }
    function hash(arg, hashfn, sortfn, wordfn, keepdups) {
        hashfn === void 0 && (hashfn = WSN.hashfn || !1), sortfn === void 0 && (sortfn = WSN.sortfn || !1), 
        wordfn === void 0 && (wordfn = WSN.wordfn || !1), keepdups === void 0 && (keepdups = WSN.keepdup || !1);
        var wsn = WSN(arg, sortfn, wordfn, keepdups);
        return wsn ? hashfn ? hashfn(wsn) : wsn : wsn;
    }
    function maphash(nodes, hashfn, sortfn, wordfn, keepdups) {
        hashfn === void 0 && (hashfn = WSN.hashfn || !1), sortfn === void 0 && (sortfn = WSN.sortfn || !1), 
        wordfn === void 0 && (wordfn = WSN.wordfn || !1), keepdups === void 0 && (keepdups = WSN.keepdup || !1);
        for (var map = {}, i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++], wsn = WSN(node, sortfn, wordfn, keepdups), id = hashfn ? hashfn(wsn) : wsn;
            map[id] = node;
        }
        return map;
    }
    function mapMD5(nodes, sortfn, wordfn, keepdups) {
        var hashfn = WSN.md5 || fdjtHash && fdjtHash.hex_md5;
        return maphash(nodes, hashfn, sortfn, wordfn, keepdups);
    }
    function mapSHA1(nodes, sortfn, wordfn, keepdups) {
        var hashfn = WSN.sha1 || fdjtHash && fdjtHash.hex_sha1;
        return maphash(nodes, hashfn, sortfn, wordfn, keepdups);
    }
    var fdjtHash = fdjt.Hash, fdjtString = fdjt.String, punct_regex = /(\pM)/g, decodeEntities = fdjtString.decodeEntities;
    return WSN.lensort = lensort, WSN.nativesort = nativesort, WSN.prototype.textify = WSN.textify = textify, 
    WSN.fuddle = fuddle, WSN.md5ID = md5ID, WSN.sha1ID = sha1ID, WSN.hash = hash, WSN.prototype.Hash = function(arg) {
        return hash(arg, this.hashfn || WSN.hashfn || !1, this.sortfn || WSN.sortfn || !1, this.wordfn || WSN.wordfn || !1, this.keepdup || WSN.keepdup || !1);
    }, WSN.maphash = maphash, WSN.prototype.maphash = function(arg) {
        return maphash(arg, this.hashfn || WSN.hashfn || !1, this.sortfn || WSN.sortfn || !1, this.wordfn || WSN.wordfn || !1, this.keepdup || WSN.keepdup || !1);
    }, WSN.mapMD5 = mapMD5, WSN.mapSHA1 = mapSHA1, WSN.md5 = fdjtHash && fdjtHash.hex_md5, 
    WSN.sha1 = fdjtHash && fdjtHash.hex_sha1, WSN;
}();

fdjt.WSN = WSN, fdjt.TextIndex = function() {
    "use strict";
    function TextIndex(opts) {
        function _indexer(string, id) {
            for (var stdtext = stdspace(string), words = stdtext.split(/\b/g), termlist = [], i = 0, lim = words.length; lim > i; ) {
                var term = words[i++], iscap = /[A-Z][^A-Z]/.exec(term), next = words[i];
                if (!(0 > term.search(/\w/) || (next && glue.exec(next) && lim > i + 1 && words[i + 1].search(/\w/) >= 0 && (term = term + next + words[i + 1], 
                i += 2), 2 > term.length || stopwords.hasOwnProperty(term) || iscap && stopwords.hasOwnProperty(term.toLowerCase())))) if (stopfns) for (var fn = 0, fns = stopfns.length; fns > fn; ) !stopfns[fn++](term); else {
                    if (termlist.push(term), rootmap.hasOwnProperty(term)) {
                        var roots = rootmap[term];
                        "string" == typeof roots ? termlist.push(roots) : termlist = termlist.concat(roots);
                    }
                    if (rootfns) for (var rootfn = 0, nrootfns = rootfns.length; nrootfns > rootfn; ) {
                        var r = rootfns[rootfn++](term);
                        "string" == typeof r ? termlist.push(r) : termlist = termlist.concat(r);
                    }
                }
            }
            var ti = 0, tlim = termlist.length;
            for (idterms.hasOwnProperty(id) ? idterms[id] = idterms[id].concat(termlist) : (idterms[id] = termlist, 
            allids.push(id)); tlim > ti; ) {
                var t = termlist[ti++];
                termindex.hasOwnProperty(t) ? termindex[t].push(id) : (allterms.push(t), termindex[t] = [ id ]);
            }
        }
        function stopWord(s) {
            if (stopwords.hasOwnProperty(s)) return !0;
            if (stopfns) {
                for (var i = 0, lim = stopfns.length; lim > i; ) if (stopfns[i++](s)) return !0;
                return !1;
            }
            return !1;
        }
        function getRoots(s) {
            for (var roots = rootmap[s] || [], i = 0, lim = rootfns.length; lim > i; ) {
                var r = rootfns[i++](s);
                r && ("string" == typeof r ? roots.push(r) : roots = roots.concat(r));
            }
            return roots;
        }
        function mergeTerms() {
            for (var i = 0, lim = allterms.length; lim > i; ) {
                var term = allterms[i++];
                if (0 === term.search(/[A-Z][a-z]/)) {
                    var lterm = term.toLowerCase();
                    termindex.hasOwnProperty(lterm) && (termindex[lterm] = termindex[lterm].concat(termindex[term]));
                }
            }
        }
        function finishIndex(index) {
            for (var newterms = [], newindex = {}, i = 0, lim = allterms.length, moved = [], capwords = index.capwords; lim > i; ) {
                var term = allterms[i++];
                if (0 === term.search(/[A-Z][a-z]/)) {
                    var lterm = term.toLowerCase();
                    termindex.hasOwnProperty(lterm) ? capwords.hasOwnProperty(term) ? (newindex[term] = termindex[term], 
                    newterms.push(term)) : moved.push(term) : (newindex[term] = termindex[term], newterms.push(term));
                } else newindex[term] = termindex[term], newterms.push(term);
            }
            for (i = 0, lim = moved.length; lim > i; ) {
                var move = moved[i++], l = move.toLowerCase();
                newindex[l] = newindex[l].concat(termindex[move]);
            }
            index.termindex = termindex = newindex, index.allterms = allterms = newterms;
        }
        opts || (opts = {});
        var i, lim, stopfns = opts.stopfns || !1, stopwords = {}, rootfns = opts.rootfns || !1, rootmap = {}, termindex = {}, idterms = {}, allterms = [], allids = [], glue = /^[-'_@.\/]$/;
        if (this instanceof TextIndex) {
            if (this._indexer = _indexer, opts.stopwords) {
                var istops = opts.stopwords;
                for (i = 0, lim = istops.length; lim > i; ) {
                    var stop = istops[i++];
                    stopwords[stop] = stop;
                }
            }
            if (opts.stdstops) for (var is = 0, islim = default_stopwords_init.length; islim > is; ) {
                var stop_word = default_stopwords_init[is++];
                stopwords[stop_word] = stop_word;
            }
            return this.capwords = opts.capwords || {}, this.termindex = termindex, this.idterms = idterms, 
            this.allterms = allterms, this.allids = allids, this.opts = opts, this.stopWord = stopWord, 
            this.getRoots = getRoots, this.mergeTerms = mergeTerms, this.finishIndex = function() {
                finishIndex(this);
            }, this;
        }
        return new TextIndex(opts);
    }
    for (var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, stdspace = fdjtString.stdspace, textify = fdjtDOM.textify, default_stopwords_init = [ "a", "i", "--", "am", "an", "as", "at", "be", "by", "d'", "de", "di", "do", "ex", "he", "if", "in", "is", "it", "me", "my", "no", "o'", "of", "on", "or", "so", "t'", "to", "up", "us", "we", "ya", "ye", "any", "are", "but", "can", "cum", "des", "did", "ere", "fer", "few", "for", "had", "has", "her", "him", "his", "hoo", "how", "i'd", "i'm", "its", "lot", "may", "nor", "not", "off", "our", "qua", "s/p", "she", "ten", "the", "via", "was", "who", "why", "yet", "you", "'tis", "amid", "atop", "been", "both", "does", "doth", "down", "d’", "each", "even", "from", "haec", "hast", "hath", "have", "he'd", "he's", "here", "hers", "i'll", "i're", "i've", "into", "it'd", "it's", "last", "less", "like", "many", "mine", "miss", "more", "most", "must", "near", "nigh", "none", "o'er", "once", "only", "onto", "ours", "over", "o’", "past", "port", "reg.", "sans", "says", "some", "such", "thae", "than", "that", "thee", "them", "then", "they", "thir", "this", "thou", "thro", "thru", "thus", "till", "unto", "upon", "upto", "we'd", "were", "what", "when", "whom", "will", "wilt", "with", "your", "yous", "zero", "abaft", "aboon", "about", "above", "adown", "afore", "after", "ain't", "along", "among", "anear", "anent", "aught", "baith", "being", "below", "can't", "circa", "could", "didst", "doest", "doeth", "don't", "every", "fewer", "fifty", "forty", "gonna", "he'll", "he're", "he've", "her'n", "his'n", "isn't", "it'll", "maybe", "might", "neath", "never", "noone", "one's", "other", "our'n", "round", "shall", "shalt", "she'd", "she's", "since", "their", "there", "these", "those", "thro'", "today", "under", "until", "we'll", "we're", "we've", "where", "which", "while", "who'd", "who's", "whose", "whoso", "won't", "would", "you'd", "yours", "youse", "aboard", "across", "allyou", "amidst", "anyone", "aren't", "around", "before", "behind", "beside", "beyond", "cannot", "contra", "couple", "didn't", "during", "either", "eleven", "except", "google", "hadn't", "hasn't", "having", "inside", "itself", "myriad", "myself", "no-one", "nobody", "o’er", "quibus", "she'll", "she're", "she've", "should", "sundry", "that'd", "that's", "theirs", "they'd", "thirty", "this'd", "thwart", "tother", "toward", "twelve", "twenty", "unless", "unlike", "versus", "wasn't", "what's", "whence", "whilst", "withal", "within", "you'll", "you're", "you've", "your'n", "against", "ain’t", "amongst", "another", "anybody", "astride", "athwart", "because", "beneath", "besides", "between", "betwixt", "can’t", "despite", "doesn't", "don’t", "haven't", "herself", "himself", "hisself", "however", "hundred", "isn’t", "neither", "nothing", "oneself", "ourself", "outside", "outwith", "pending", "perhaps", "several", "someone", "that'll", "there's", "they'll", "they're", "they've", "this'll", "through", "thro’", "thyself", "towards", "weren't", "whereby", "wherein", "whereof", "whereon", "whereto", "whether", "whoever", "without", "won’t", "you-all", "aren’t", "didn’t", "hadn’t", "hasn’t", "wasn’t", "doesn’t", "haven’t", "weren’t" ], default_stopwords = {}, is = 0, islim = default_stopwords_init.length; islim > is; ) {
        var stop_word = default_stopwords_init[is++];
        0 > stop_word.indexOf("'") && (default_stopwords[stop_word] = stop_word);
    }
    return TextIndex.default_stops = default_stopwords, TextIndex.prototype.indexText = function(arg, id) {
        var indexer = this._indexer;
        if ("string" == typeof arg) id && indexer(arg, id); else if (arg.nodeType) id || (id = arg.id), 
        id && indexer(textify(arg), id); else if (arg.length) for (var i = 0, lim = arg.length; lim > i; ) {
            var node = arg[i++];
            1 === node.nodeType && node.id && indexer(textify(node), node.id);
        }
    }, TextIndex.prototype.prefixTree = function() {
        if (this.prefixtree) return this.prefixtree;
        for (var ptree = this.prefixtree = {
            strings: []
        }, prefixAdd = fdjtString.prefixAdd, allterms = this.allterms, i = 0, lim = allterms.length; lim > i; ) {
            var term = allterms[i++];
            prefixAdd(ptree, term, 0);
        }
        return ptree;
    }, TextIndex;
}(), fdjt.UI || (fdjt.UI = {}), fdjt.UI.CoHi || (fdjt.UI.CoHi = {
    classname: "cohi"
}), fdjt.UI.AutoPrompt || (fdjt.UI.AutoPrompt = {}), fdjt.UI.InputHelp || (fdjt.UI.InputHelp = {}), 
fdjt.UI.Ellipsis || (fdjt.UI.Ellipsis = {}), fdjt.UI.Expansion || (fdjt.UI.Expansion = {}), 
fdjt.UI.Collapsible || (fdjt.UI.Collapsible = {}), fdjt.UI.Tabs || (fdjt.UI.Tabs = {}), 
fdjt.UI.MultiText || (fdjt.UI.MultiText = {}), fdjt.UI.Reticle || (fdjt.UI.Reticle = {}), 
fdjt.UI.FocusBox || (fdjt.UI.FocusBox = {}), function() {
    "use strict";
    function highlight(namearg, classname_arg) {
        var i, n, classname = classname_arg || fdjtUI.CoHi.classname, newname = namearg.name || namearg, cur = highlights[classname];
        if (cur !== newname) {
            if (cur) {
                var drop = document.getElementsByName(cur);
                for (i = 0, n = drop.length; n > i; ) fdjtDOM.dropClass(drop[i++], classname);
            }
            if (highlights[classname] = newname || !1, newname) {
                var elts = document.getElementsByName(newname);
                for (n = elts.length, i = 0; n > i; ) fdjtDOM.addClass(elts[i++], classname);
            }
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, highlights = {};
    fdjtUI.CoHi.highlight = highlight, fdjtUI.CoHi.onmouseover = function(evt, classname_arg) {
        for (var target = fdjtDOM.T(evt); target; ) {
            if (3 === target.nodeType) target = target.parentNode; else if (1 !== target.nodeType) {
                target = !1;
                break;
            }
            if ("INPUT" === target.tagName || "TEXTAREA" === target.tagName || "A" === target.tagName && target.href) return;
            if (target.name || target.getAttribute("name")) break;
            target = target.parentNode;
        }
        target && highlight(target.name || target.getAttribute("name"), classname_arg);
    }, fdjtUI.CoHi.onmouseout = function(evt, classname_arg) {
        highlight(!1, classname_arg || fdjtUI.CoHi.classname);
    };
}(), fdjt.UI.Highlight = function() {
    "use strict";
    function textnode(s) {
        return document.createTextNode(s);
    }
    function gatherHighlights(node, classpat, into) {
        if (1 === node.nodeType) {
            if (node.childNodes) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) gatherHighlights(children[i++], classpat, into);
            node.className && node.className.search && node.className.search(classpat) >= 0 && into.push(node);
        }
    }
    function unwrap_hnode(hnode) {
        var ch = hnode.childNodes;
        if (ch) {
            for (var frag = document.createDocumentFragment(), tomove = [], j = 0, n = ch && ch.length; n > j; ) tomove.push(ch[j++]);
            for (j = 0, n = tomove.length; n > j; ) frag.appendChild(tomove[j++]);
            fdjtDOM.replace(hnode, frag);
        } else fdjtDOM.remove(hnode);
    }
    function clear_highlights(node, hclass) {
        var h = [];
        node === hclass || hasClass(node, hclass) ? h = [ node ] : gatherHighlights(node, RegExp("\\b" + hclass + "\\b", "g"), h);
        for (var i = 0, lim = h.length; lim > i; ) unwrap_hnode(h[i++]);
    }
    function highlight_node(node, hclass, htitle, hattribs) {
        hclass || (hclass = highlight_class);
        var hispan = !1;
        if (3 === node.nodeType) {
            var text = node.nodeValue;
            if (text.search(/\S/g) >= 0) hispan = fdjtDOM("span." + hclass); else {
                var parent = node.parentNode, style = getStyle(parent), next = node.nextSibling, prev = node.prevSibling, nstyle = next && 1 === next.nodeType && getStyle(next), pstyle = prev && 1 === prev.nodeType && getStyle(prev), ndisplay = nstyle && nstyle.display, pdisplay = pstyle && pstyle.display;
                hispan = "normal" !== style.whiteSpace ? fdjtDOM("span." + hclass) : next || prev ? "inline" !== ndisplay && "table-cell" !== ndisplay && "inline" !== pdisplay && "table-cell" !== pdisplay ? !1 : fdjtDOM("span." + hclass) : fdjtDOM("span." + hclass);
            }
        } else {
            if (1 !== node.nodeType || hasClass(node, hclass)) return node;
            if (hasClass(node, "fdjtskiptext")) ; else {
                var nodestyle = getStyle(node), display = nodestyle.display, position = nodestyle.position;
                "static" !== position && "" !== position || ("block" === display ? hispan = fdjtDOM("div." + hclass) : "inline" === display && (hispan = fdjtDOM("span." + hclass)));
            }
        }
        if (!hispan) return node;
        if (htitle && (hispan.title = htitle), hattribs) for (var attrib in hattribs) hattribs.hasOwnProperty(attrib) && hispan.setAttribute(attrib, hattribs[attrib]);
        return fdjtDOM.replace(node, hispan), hispan.appendChild(node), hispan;
    }
    function highlight_text(text, hclass, htitle, hattribs) {
        var tnode = fdjtDOM("span." + (hclass || highlight_class), text);
        if (htitle && (tnode.title = htitle), hattribs) for (var attrib in hattribs) hattribs.hasOwnProperty(attrib) && tnode.setAttribute(attrib, hattribs[attrib]);
        return tnode;
    }
    function highlight_node_range(node, start, end, hclass, htitle, hattribs) {
        var stringval = node.nodeValue, parent = node.parentNode;
        if ((end === !1 || end === void 0) && (end = stringval.length), start !== end) {
            var beginning = start > 0 && textnode(stringval.slice(0, start)), middle = highlight_text(stringval.slice(start, end), hclass, htitle, hattribs), ending = stringval.length > end && textnode(stringval.slice(end));
            return beginning && ending ? (parent.replaceChild(ending, node), parent.insertBefore(middle, ending), 
            parent.insertBefore(beginning, middle)) : beginning ? (parent.replaceChild(middle, node), 
            parent.insertBefore(beginning, middle)) : ending ? (parent.replaceChild(ending, node), 
            parent.insertBefore(middle, ending)) : parent.replaceChild(middle, node), middle;
        }
    }
    function highlight_range(range, hclass, htitle, hattribs) {
        range = fdjtDOM.refineRange(range);
        var starts_in = range.startContainer, ends_in = range.endContainer;
        if (starts_in === ends_in) return [ highlight_node_range(starts_in, range.startOffset, range.endOffset, hclass, htitle, hattribs) ];
        for (var highlights = [], scan = starts_in; scan && !scan.nextSibling; ) scan = scan.parentNode;
        for (scan = scan.nextSibling; scan && scan !== ends_in; ) if (hasParent(ends_in, scan)) scan = scan.firstChild; else {
            for (var next = scan; next && !next.nextSibling; ) next = next.parentNode;
            next = next.nextSibling, highlights.push(highlight_node(scan, hclass, htitle, hattribs)), 
            scan = next;
        }
        return highlights.push(highlight_node_range(starts_in, range.startOffset, !1, hclass, htitle, hattribs)), 
        highlights.push(highlight_node_range(ends_in, 0, range.endOffset, hclass, htitle, hattribs)), 
        highlights;
    }
    var fdjtDOM = fdjt.DOM, highlight_class = "fdjthighlight", hasClass = fdjtDOM.hasClass, hasParent = fdjtDOM.getParent, getStyle = fdjtDOM.getStyle;
    return highlight_range.clear = clear_highlights, highlight_range.remove = unwrap_hnode, 
    highlight_range.highlight = highlight_range, highlight_range;
}(), function() {
    "use strict";
    function CheckSpan(spec, varname, val, checked) {
        var input = fdjtDOM.Input("input[type=checkbox]", varname, val), span = fdjtDOM(spec || "span.checkspan", input);
        return checked ? (input.checked = !0, fdjtDOM.addClass(span, "ischecked")) : input.checked = !1, 
        arguments.length > 4 && fdjtDOM.appendArray(span, arguments, 4), span;
    }
    function checkable(elt) {
        return 1 === elt.nodeType && "INPUT" === elt.tagName && ("checkbox" === elt.type || "radio" === elt.type);
    }
    function getcheckable(elt) {
        if (checkable(elt)) return elt;
        var cb = getParent(elt, checkable);
        if (cb) return cb;
        if (cb = getChildren(elt, "input"), cb.length) {
            for (var i = 0, lim = cb.length; lim > i; ) {
                if (checkable(cb[i])) return cb[i];
                i++;
            }
            return !1;
        }
        return !1;
    }
    function checkspan_set(target, checked) {
        var i, lim;
        if ("string" == typeof target) target = fdjtID(target); else if (target.length) {
            for (i = 0, lim = target.length; lim > i; ) checkspan_set(target[i++], checked);
            return;
        }
        if (target && target.nodeType) {
            var checkspan = hasClass(target, "checkspan") ? target : getParent(target, ".checkspan");
            if (!checkspan) return !1;
            var checkbox = checkable(target) && target || getcheckable(target) || getcheckable(checkspan);
            if (!checkbox) return !1;
            if (hasClass(checkspan, "isdisabled")) {
                if (checkbox.disabled) return !1;
                dropClass(checkspan, "isdisabled");
            } else if (checkbox.disabled) return addClass(checkspan, "isdisabled"), !1;
            var ischecked = hasClass(checkspan, "ischecked"), changed = !1, unchecked = [];
            if (checked === void 0 && (checked = ischecked), checkbox.checked !== checked ? (checkbox.checked = checked, 
            changed = !0) : ischecked !== checkbox.checked && (changed = !0), checked ? addClass(checkspan, "ischecked") : dropClass(checkspan, "ischecked"), 
            changed && "radio" === checkbox.type) {
                var form = checkbox.form;
                form || (form = getParent(checkbox, ".fdjtinputs")), form || (form = checkspan.parentNode);
                var name = checkbox.name, tosync = getChildren(form, "input");
                for (i = 0, lim = tosync.length; lim > i; ) {
                    var input = tosync[i++];
                    if (input !== checkbox && "radio" === input.type && input.name === name) {
                        var cspan = getParent(input, ".checkspan");
                        if (cspan === checkspan) continue;
                        hasClass(cspan, "ischecked") && (input.checked || unchecked.push(input));
                    }
                }
            }
            var evt;
            if (changed && (evt = document.createEvent("HTMLEvents"), evt.initEvent("change", !1, !0), 
            checkbox.dispatchEvent(evt)), unchecked.length) for (i = 0, lim = unchecked.length; lim > i; ) {
                var uncheck = unchecked[i++], altspan = getParent(uncheck, ".checkspan");
                dropClass(altspan, "ischecked"), evt = document.createEvent("HTMLEvents"), evt.initEvent("change", !1, !0), 
                uncheck.dispatchEvent(evt);
            }
        }
    }
    function checkspan_onclick(evt) {
        evt = evt || window.event;
        var target = evt.target || evt.srcTarget;
        if ("TEXTAREA" !== target.tagName && "SELECT" !== target.tagName && "OPTION" !== target.tagName && ("INPUT" !== target.tagName || "checkbox" === target.type || "radio" === target.type)) {
            var anchor = "A" === target.tagName ? target : getParent(target, "A");
            if (!anchor || !anchor.href) {
                var checkspan = getParent(target, ".checkspan");
                if (checkspan) {
                    var checked = hasClass(checkspan, "ischecked");
                    return checkspan_set(target, !checked), !1;
                }
            }
        }
    }
    function changed(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if ("radio" === target.type || "checkbox" === target.type) {
            var checkspan = getParent(target, ".checkspan");
            checkspan && (target.checked ? addClass : dropClass)(checkspan, "ischecked");
        }
        if ("radio" === target.type) for (var form = target.form, others = document.getElementsByName(target.name), i = 0, lim = others.length; lim > i; ) {
            var other = others[i++];
            if (other !== target && other.form === form && "radio" === other.type) {
                var ocs = fdjtDOM.getParent(other, ".checkspan");
                dropClass(ocs, "ischecked");
            }
        }
    }
    function initCheckspans() {
        for (var checkspans = fdjt.$(".checkspan"), i = 0, lim = checkspans.length; lim > i; ) for (var checkspan = checkspans[i++], inputs = fdjtDOM.getInputs(checkspan), j = 0, jlim = inputs.length; jlim > j; ) {
            var input = inputs[j++];
            if ("radio" === input.type || "checkspan" === input.type) {
                input.checked && addClass(checkspan, "ischecked"), input.disabled && addClass(checkspan, "isdisabled");
                break;
            }
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getParent = fdjtDOM.getParent, getChildren = fdjtDOM.getChildren;
    fdjtUI.CheckSpan = CheckSpan, fdjtUI.CheckSpan.set = checkspan_set, fdjtUI.CheckSpan.onclick = checkspan_onclick, 
    fdjtUI.CheckSpan.changed = changed, fdjtUI.CheckSpan.initCheckspans = initCheckspans, 
    fdjt.addInit(initCheckspans, "CheckSpans", !1);
}(), fdjt.UI.ProgressBar = function() {
    "use strict";
    function ProgressBar(arg) {
        return arg === void 0 ? arg = fdjtDOM("div.fdjtprogress", fdjtDOM("div.indicator"), fdjtDOM("div.message")) : "string" == typeof arg && (arg = fdjtDOM("div.fdjtprogress", fdjtDOM("HR"), fdjtDOM("div.message", arg))), 
        this.dom = arg, this;
    }
    function setProgress(pb, progress, total) {
        if ("string" == typeof pb && (pb = document.getElementById(pb)), "number" == typeof total && (progress = 100 * (progress / total)), 
        pb) {
            var dom = pb.dom || pb;
            if (dom.nodeType) {
                var rule = fdjtDOM.getChildren(dom, "div.indicator")[0];
                rule.style.width = progress + "%";
            }
        }
    }
    function setMessage(pb) {
        if ("string" == typeof pb && (pb = document.getElementById(pb)), pb) {
            var dom = pb.dom || pb;
            if (dom.nodeType) {
                var oldmsg = fdjtDOM.getChildren(dom, ".message")[0], newmsg = fdjtDOM("div.message");
                fdjtDOM.appendArray(newmsg, fdjtDOM.Array(arguments, 1)), dom.replaceChild(newmsg, oldmsg);
            }
        }
    }
    var fdjtDOM = fdjt.DOM;
    return ProgressBar.setProgress = setProgress, ProgressBar.setMessage = setMessage, 
    ProgressBar.prototype.setProgress = function(progress, total) {
        setProgress(this.dom, progress, total);
    }, ProgressBar.prototype.setMessage = function() {
        var dom = this.dom, oldmsg = fdjtDOM.getChildren(dom, ".message")[0], newmsg = fdjtDOM("div.message");
        fdjtDOM.appendArray(newmsg, fdjtDOM.Array(arguments)), dom.replaceChild(newmsg, oldmsg);
    }, ProgressBar;
}(), function() {
    "use strict";
    function show_help_onfocus(evt) {
        for (var target = fdjtDOM.T(evt); target; ) {
            if (1 === target.nodeType && ("INPUT" === target.tagName || "TEXTAREA" === target.tagName) && target.getAttribute("helptext")) {
                var helptext = fdjtID(target.getAttribute("helptext"));
                return helptext && fdjtDOM.addClass(helptext, "showhelp"), void 0;
            }
            target = target.parentNode;
        }
    }
    function autoprompt_onfocus(evt) {
        evt = evt || window.event || null;
        var elt = fdjtDOM.T(evt);
        elt && hasClass(elt, "isempty") && (elt.value = "", dropClass(elt, "isempty")), 
        show_help_onfocus(evt);
    }
    function hide_help_onblur(evt) {
        for (var target = fdjtDOM.T(evt); target; ) {
            if (1 === target.nodeType && ("INPUT" === target.tagName || "TEXTAREA" === target.tagName) && target.getAttribute("HELPTEXT")) {
                var helptext = fdjtID(target.getAttribute("HELPTEXT"));
                return helptext && dropClass(helptext, "showhelp"), void 0;
            }
            target = target.parentNode;
        }
    }
    function autoprompt_onblur(evt) {
        var elt = fdjtDOM.T(evt);
        if ("" === elt.value) {
            addClass(elt, "isempty");
            var prompt = elt.prompt || elt.getAttribute("prompt") || elt.title;
            prompt && (elt.value = prompt);
        } else dropClass(elt, "isempty");
        hide_help_onblur(evt);
    }
    function autoprompt_cleanup(form) {
        var elements = fdjtDOM.getChildren(form, ".isempty");
        if (elements) for (var i = 0, lim = elements.length; lim > i; ) elements[i++].value = "";
    }
    function autoprompt_onsubmit(evt) {
        var form = fdjtDOM.T(evt);
        autoprompt_cleanup(form);
    }
    function autoprompt_setup(arg, nohandlers) {
        for (var forms = "FORM" === arg.tagName ? [ arg ] : fdjtDOM.getChildren(arg || document.body, "FORM"), i = 0, lim = forms.length; lim > i; ) {
            var form = forms[i++], inputs = fdjtDOM.getChildren(form, "INPUT.autoprompt,TEXTAREA.autoprompt");
            if (inputs.length) {
                for (var j = 0, jlim = inputs.length; jlim > j; ) {
                    var input = inputs[j++];
                    if (input.blur(), isEmpty(input.value)) {
                        addClass(input, "isempty");
                        var prompt = input.prompt || input.getAttribute("prompt") || input.title;
                        prompt && (input.value = prompt);
                    }
                    nohandlers || (fdjtDOM.addListener(input, "focus", autoprompt_onfocus), fdjtDOM.addListener(input, "blur", autoprompt_onblur));
                }
                nohandlers || fdjtDOM.addListener(form, "submit", autoprompt_onsubmit);
            }
        }
    }
    var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, isEmpty = fdjtString.isEmpty;
    fdjt.UI.AutoPrompt.setup = autoprompt_setup, fdjt.UI.AutoPrompt.onfocus = autoprompt_onfocus, 
    fdjt.UI.AutoPrompt.onblur = autoprompt_onblur, fdjt.UI.AutoPrompt.onsubmit = autoprompt_onsubmit, 
    fdjt.UI.AutoPrompt.cleanup = autoprompt_cleanup, fdjt.UI.InputHelp.onfocus = show_help_onfocus, 
    fdjt.UI.InputHelp.onblur = hide_help_onblur;
}(), function() {
    "use strict";
    function fdjt_focusin(evt) {
        var scan = fdjtUI.T(evt), add = [];
        if ("TEXTAREA" === scan.tagName || "INPUT" === scan.tagName && /text|email/i.exec(scan.type)) {
            for (;scan; ) {
                var classname = scan.className;
                classname && "string" == typeof classname && classname.search(/\bfdjtfoci\b/) >= 0 && 0 > classname.search(/\bfdjtfocus\b/) && add.push(scan), 
                scan = scan.parentNode;
            }
            add.length && setTimeout(function() {
                for (var i = 0; add.length > i; ) {
                    var elt = add[i++], classname = elt.className;
                    elt.className = classname + " fdjtfocus";
                }
            }, 300);
        }
    }
    function fdjt_focusout(evt) {
        var scan = fdjtUI.T(evt), drop = [];
        if ("TEXTAREA" === scan.tagName || "INPUT" === scan.tagName && /text|email/i.exec(scan.type)) {
            for (;scan; ) {
                var classname = scan.className;
                classname && "string" == typeof classname && classname.search(/\bfdjtfocus\b/) >= 0 && drop.push(scan), 
                scan = scan.parentNode;
            }
            drop.length && setTimeout(function() {
                for (var i = 0; drop.length > i; ) {
                    var elt = drop[i++], classname = elt.className;
                    elt.className = classname.replace(/ fdjtfocus\b/, "");
                }
            }, 300);
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, addListener = fdjtDOM.addListener;
    fdjtUI.focusin = fdjt_focusin, addListener(window, "focusin", fdjt_focusin), fdjtUI.focusout = fdjt_focusout, 
    addListener(window, "focusout", fdjt_focusout);
}(), function() {
    "use strict";
    function multitext_keypress(evt, sepchars, sepexp, fn) {
        evt = evt || event;
        var chcode = evt.charCode, ch = String.fromCharCode(chcode), target = fdjtUI.T(evt);
        if (sepchars instanceof RegExp ? (sepexp = sepchars, sepchars = !1) : sepchars && sepchars.call && (fn = sepchars, 
        sepchars = !1), !sepchars && target.getAttribute("data-sepchars") && (sepchars = target.getAttribute("data-sepchars")), 
        13 === chcode && isEmpty(target.value) && hasClass(target, "fdjtentersubmit")) return fdjt.UI.cancel(evt), 
        target.form.submit(), void 0;
        if (13 === chcode || sepchars && sepchars.indexOf(ch) >= 0) {
            !sepexp && target.getAttribute("data-separator") && (sepexp = RegExp(target.getAttribute("data-separator"), "g"));
            for (var checkspec = target.getAttribute("data-checkspec") || "div.checkspan", values = sepexp ? target.value.split(sepexp) : [ target.value ], i = 0, lim = values.length; lim > i; ) {
                var value = values[i++];
                if (fn) fdjtDOM(target.parentNode, "\n", fn(target.name, value)); else {
                    var checkbox = fdjtDOM.Input("[type='checkbox']", target.name, value), checkelt = fdjtDOM(checkspec, checkbox, value);
                    checkbox.checked = !0, fdjtDOM.addClass(checkelt, "ischecked"), fdjtDOM(target.parentNode, "\n", checkelt);
                }
            }
            fdjtUI.cancel(evt), target.value = "";
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtString = fdjt.String, isEmpty = fdjtString.isEmpty, hasClass = fdjtDOM.hasClass;
    fdjtUI.MultiText.keypress = multitext_keypress;
}(), function() {
    "use strict";
    function tab_onclick(evt, shownclass) {
        var elt = fdjtUI.T(evt);
        if (shownclass || (shownclass = fdjtDOM.findAttrib(elt, "shownclass", "http://fdjt.org/") || "fdjtshown"), 
        elt) {
            for (var content_id = !1; elt.parentNode && !(content_id = fdjtDOM.getAttrib(elt, "contentid")); ) elt = elt.parentNode;
            if (!content_id) return;
            var content = document.getElementById(content_id), parent = fdjtDOM.getParent(elt, ".tabs") || elt.parentNode, sibs = fdjtDOM.getChildren(parent, ".tab") || parent.childNodes;
            if (null === content) return fdjtLog("No content for " + content_id), void 0;
            for (var i = 0; sibs.length > i; ) {
                var cid, node = sibs[i++];
                if (1 === node.nodeType && (cid = fdjtDOM.getAttrib(node, "contentid"))) {
                    if (!cid) continue;
                    var cdoc = document.getElementById(cid);
                    node === elt || hasClass(node, shownclass) && (dropClass(node, shownclass), cdoc && dropClass(cdoc, shownclass));
                }
            }
            hasClass(elt, shownclass) ? (dropClass(elt, shownclass), dropClass(content, shownclass)) : (addClass(elt, shownclass), 
            addClass(content, shownclass));
            var tabstate = fdjtDOM.findAttrib(elt, "tabstate");
            if (tabstate) if ("#" === tabstate) {
                var scrollstate = {};
                fdjtUI.scrollSave(scrollstate), document.location.hash = tabstate + content_id, 
                fdjtUI.scrollRestore(scrollstate);
            } else fdjtState.setCookie(tabstate, content_id); else ;
            return !1;
        }
    }
    function select_tab(tabbar, contentid, shownclass) {
        shownclass || (shownclass = fdjtDOM.findAttrib(tabbar, "shownclass", "http://fdjt.org/") || "fdjtshown");
        for (var tabseen = !1, tabs = fdjtDOM.getChildren(tabbar, ".tab"), i = 0; tabs.length > i; ) {
            var tab = tabs[i++];
            if (tab.getAttribute("contentid") === contentid) addClass(tab, shownclass), tabseen = !0; else if (hasClass(tab, shownclass)) {
                dropClass(tab, shownclass);
                var cid = fdjtDOM.getAttrib(tab, "contentid"), content = cid && fdjtID(cid);
                content ? dropClass(content, shownclass) : fdjtLog.warn("No reference for tab content %o", cid);
            } else dropClass(tab, shownclass);
        }
        fdjtID(contentid) ? tabseen ? addClass(contentid, shownclass) : fdjtLog.warn("a tab for %s was not found in %o", contentid, tabbar) : fdjtLog.warn("No reference for tab content %o", contentid);
    }
    function setupTabs(elt) {
        if (elt ? "string" == typeof elt && (elt = fdjtID(elt)) : elt = fdjtDOM.$(".tabs[tabstate]"), 
        elt && elt.getAttribute("tabstate")) {
            var tabstate = elt.getAttribute("tabstate"), content_id = !1;
            if ("#" === tabstate) {
                content_id = document.location.hash, "#" === content_id[0] && (content_id = content_id.slice(1));
                var content = content_id && fdjtID(content_id);
                if (!content) return;
                var ss = {};
                fdjtUI.scrollSave(ss), window.scrollTo(0, 0), fdjtDOM.isVisible(content) || fdjtUI.scrollRestore(ss);
            } else content_id = fdjtState.getQuery(tabstate) || fdjtState.getCookie(tabstate);
            content_id && ("#" === content_id[0] && (content_id = content_id.slice(1)), content_id && select_tab(elt, content_id));
        }
    }
    function selected_tab(tabbar) {
        for (var tabs = fdjtDOM.getChildren(tabbar, ".tab"), i = 0; tabs.length > i; ) {
            var tab = tabs[i++];
            if (hasClass(tab, "shown")) return tab.getAttribute("contentid");
        }
        return !1;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtState = fdjt.State, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass;
    fdjtUI.Tabs.click = tab_onclick, fdjtUI.Tabs.selectTab = select_tab, fdjtUI.Tabs.setup = setupTabs, 
    fdjtUI.Tabs.getSelected = selected_tab;
}(), function() {
    "use strict";
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjtUI.Expansion.toggle = function(evt, spec, exspec) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), wrapper = fdjtDOM.getParent(target, spec || ".fdjtexpands");
        wrapper && fdjtDOM.toggleClass(wrapper, exspec || "fdjtexpanded");
    }, fdjtUI.Expansion.onclick = fdjtUI.Expansion.toggle, fdjtUI.Collapsible.click = function(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if (!fdjtUI.isDefaultClickable(target)) {
            var wrapper = fdjtDOM.getParent(target, ".collapsible");
            wrapper && (fdjtUI.cancel(evt), fdjtDOM.toggleClass(wrapper, "expanded"));
        }
    }, fdjtUI.Collapsible.focus = function(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), wrapper = fdjtDOM.getParent(target, ".collapsible");
        wrapper && fdjtDOM.toggleClass(wrapper, "expanded");
    }, fdjtUI.toggleParent = function(evt, spec, classname) {
        var target = fdjtUI.T(evt), parent = fdjtDOM.getParent(target, spec);
        parent && fdjtDOM.toggleClass(parent, classname);
    };
}(), function() {
    "use strict";
    function scroll_discard(ss) {
        ss ? (ss.scrollX = !1, ss.scrollY = !1) : saved_scroll = !1;
    }
    function scroll_save(ss) {
        ss ? (ss.scrollX = window.scrollX, ss.scrollY = window.scrollY) : (saved_scroll || (saved_scroll = {}), 
        saved_scroll.scrollX = window.scrollX, saved_scroll.scrollY = window.scrollY);
    }
    function scroll_into_view(elt, topedge) {
        if (0 === topedge || topedge || !fdjtDOM.isVisible(elt)) if (use_native_scroll && elt.scrollIntoView) {
            if (elt.scrollIntoView(topedge), 0 !== topedge && !topedge && fdjtDOM.isVisible(elt, !0)) return;
        } else {
            for (var top = elt.offsetTop, left = elt.offsetLeft, height = elt.offsetHeight; elt.offsetParent; ) elt = elt.offsetParent, 
            top += elt.offsetTop, left += elt.offsetLeft;
            var y, vh = fdjtDOM.viewHeight(), x = 0, y_target = top + height / 3;
            y = vh / 2 - 50 > 2 * (height / 3) ? y_target - vh / 2 : vh - 100 > height ? top - (50 + height / 2) : top - 50, 
            window.scrollTo(x, y);
        }
    }
    function scroll_preview(target, context, delta) {
        return target ? (target !== preview_elt && (saved_scroll || scroll_save(), "number" == typeof target ? window.scrollTo("number" == typeof context && context || 0, target) : scroll_into_view(target, delta), 
        preview_elt = target), void 0) : (stop_preview(), void 0);
    }
    function scroll_restore(ss) {
        return preview_elt && (preview_elt = !1), ss && "number" == typeof ss.scrollX ? (window.scrollTo(ss.scrollX, ss.scrollY), 
        !0) : !saved_scroll || "number" != typeof saved_scroll.scrollY && "number" != typeof saved_scroll.scrollX ? !1 : (window.scrollTo(saved_scroll.scrollX, saved_scroll.scrollY), 
        saved_scroll = !1, !0);
    }
    function stop_preview() {
        fdjtDOM.dropClass(document.body, "preview"), preview_elt && preview_elt.className && fdjtDOM.dropClass(preview_elt, "previewing"), 
        preview_elt = !1;
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, saved_scroll = !1, use_native_scroll = !1, preview_elt = !1;
    fdjtUI.scrollTo = function(target, id, context, discard, topedge) {
        scroll_discard(discard), id && (document.location.hash = id), context ? setTimeout(function() {
            scroll_into_view(context, topedge), fdjtDOM.isVisible(target) || scroll_into_view(target, topedge);
        }, 100) : setTimeout(function() {
            scroll_into_view(target, topedge);
        }, 100);
    }, fdjtUI.scrollSave = scroll_save, fdjtUI.scrollRestore = scroll_restore, fdjtUI.scrollIntoView = scroll_into_view, 
    fdjtUI.scrollPreview = scroll_preview, fdjtUI.scrollRestore = scroll_restore;
}(), function() {
    "use strict";
    function smartScroll(win, off, content) {
        if (content === void 0 && (content = win), 0 >= off) return win.scrollTop = 0, void 0;
        var block = findBreak(content, off, content);
        if (!block) return win.scrollTop = off, void 0;
        var geom = getGeometry(block, content || win);
        win.scrollTop = win.offsetTop / 4 > geom - top - off ? geom.top : off;
    }
    function findBreak(node, off, container) {
        var style = getStyle(node), display = style.display;
        if ("block" === display || "table-row" === display || "list-item" === display || "preformatted" === display) {
            var geom = getGeometry(node, container);
            if (geom.top > off) return node;
            if (geom.bottom > off) {
                if ("avoid" === style.pageBreakInside) return node;
                for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                    var child = children[i++], bk = 1 === child.nodeType && findBreak(child, off, container);
                    if (bk) return bk;
                }
                return node;
            }
            return !1;
        }
        return !1;
    }
    var fdjtDOM = fdjt.DOM, getGeometry = fdjtDOM.getGeometry, getStyle = fdjtDOM.getStyle;
    fdjt.UI.smartScroll = smartScroll;
}(), function() {
    "use strict";
    fdjt.UI.Delay = function(interval, name, fcn) {
        setTimeout(fcn, interval);
    }, fdjt.UI.Delayed = function(fcn, interval) {
        interval || (interval = 25), setTimeout(fcn, interval);
    };
}(), function() {
    "use strict";
    function dosubmit(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), form = fdjtDOM.getParent(target, "FORM"), submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent("submit", !1, !0), form.dispatchEvent(submit_event), form.submit();
    }
    function forceSubmit(form) {
        var submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent("submit", !1, !0), form.dispatchEvent(submit_event);
    }
    function submitOnEnter(evt) {
        evt = evt || window.event;
        var kc = evt.keyCode || evt.charCode;
        if (13 === kc) {
            var target = fdjtUI.T(evt), form = fdjtDOM.getParent(target, "FORM"), submit_event = document.createEvent("HTMLEvents");
            submit_event.initEvent("submit", !1, !0), fdjtUI.cancel(evt), form.dispatchEvent(submit_event), 
            form.submit();
        }
    }
    function checkFileInputs(evt) {
        evt = evt || window.event;
        for (var form = fdjtUI.T(evt), file_inputs = fdjtDOM.getInputs(form, !1, "file"), i = 0, lim = file_inputs.length; lim > i; ) {
            var input = file_inputs[i++];
            input.value && "" !== input.value || (fdjtUI.cancel(evt), (fdjt.UI.alert || window.alert)("You need to specify a file!"));
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjtUI.dosubmit = dosubmit, fdjtUI.forceSubmit = forceSubmit, fdjtUI.submitOnEnter = submitOnEnter, 
    fdjtUI.checkFileInputs = checkFileInputs;
}(), function() {
    "use strict";
    function checkOverflow(node) {
        var geom = getGeometry(node), inside = getInsideBounds(node);
        inside.bottom > geom.bottom ? addClass(node, "overflow") : dropClass(node, "overflow");
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getGeometry = fdjtDOM.getGeometry, getInsideBounds = fdjtDOM.getInsideBounds;
    fdjtUI.Overflow = checkOverflow;
}(), function() {
    "use strict";
    function setXY(x, y) {
        vreticle && (vreticle.style.left = x + "px"), hreticle && (hreticle.style.top = y + "px");
    }
    function setupReticle() {
        vreticle || (vreticle = fdjtDOM("div.reticle.vertical#VRETICLE", " "), fdjtDOM.prepend(document.body, vreticle)), 
        hreticle || (hreticle = fdjtDOM("div.reticle.horizontal#HRETICLE", " "), fdjtDOM.prepend(document.body, hreticle)), 
        fdjtLog("Setting up reticle"), device.touch ? fdjtDOM.addListener(document.body, "touchmove", touchmove) : fdjtDOM.addListener(document, "mousemove", mousemove), 
        fdjtDOM.addListener(document.body, "touchmove", touchmove), fdjtDOM.addListener(document, "click", doflash), 
        fdjtUI.Reticle.live = !0;
    }
    function doflash() {
        flash();
    }
    function mousemove(evt, x, y) {
        setXY(x || evt.clientX, y || evt.clientY);
    }
    function touchmove(evt, x, y, touch) {
        touch = evt.touches ? evt.touches[0] : evt, setXY(x || touch.clientX, y || touch.clientY);
    }
    function highlight(flag) {
        flag === void 0 && (flag = !highlighted), flag ? (vreticle && fdjtDOM.addClass(vreticle, "highlight"), 
        hreticle && fdjtDOM.addClass(hreticle, "highlight"), highlighted = !0) : (vreticle && fdjtDOM.dropClass(vreticle, "highlight"), 
        hreticle && fdjtDOM.dropClass(hreticle, "highlight"), highlighted = !1);
    }
    function flash(howlong) {
        howlong === void 0 && (howlong = 1500), highlighted || (highlight(!0), setTimeout(function() {
            highlight(!1);
        }, howlong));
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, device = fdjt.device, vreticle = !1, hreticle = !1, highlighted = !1;
    fdjtUI.Reticle.setup = setupReticle, fdjtUI.Reticle.highlight = highlight, fdjtUI.Reticle.flash = flash, 
    fdjtUI.Reticle.onmousemove = mousemove, fdjtUI.Reticle.ontouchmove = touchmove, 
    fdjtUI.Reticle.onmove = device.touch ? touchmove : mousemove, fdjtUI.Reticle.setXY = setXY, 
    fdjtUI.Reticle.visible = !1, fdjtUI.Reticle.live = !1;
}(), function() {
    "use strict";
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjtUI.uploadSpecified = function(evt) {
        evt = evt || window.event;
        var parent = fdjtDOM.getParent(fdjtUI.T(evt), ".fileuploader");
        parent && fdjtDOM.addClass(parent, "inuse");
    };
}(), function() {
    "use strict";
    function ImageSwap(img, interval) {
        if ("string" == typeof img && (img = fdjtID(img)), !img) return !1;
        interval || (interval = img.getAttribute("data-interval") ? parseInt(img.getAttribute("data-interval"), 10) : ImageSwap.interval), 
        img.getAttribute("data-images") || img.setAttribute("data-images", img.src), img.defaultsrc || (img.defaultsrc = img.src);
        var images = img.getAttribute("data-images").split("|");
        if (0 === images.length) return !1;
        var counter = 0;
        return setInterval(function() {
            img.src === images[counter] ? counter++ : img.src = images[counter++], counter >= images.length && (counter = 0);
        }, interval);
    }
    var fdjtUI = fdjt.UI, fdjtID = fdjt.ID;
    ImageSwap.reset = function(img) {
        img.defaultsrc && (img.src = img.defaultsrc);
    }, ImageSwap.interval = 1e3, fdjtUI.ImageSwap = ImageSwap;
}(), function() {
    "use strict";
    function submitEvent(arg) {
        for (var form = arg.nodeType ? arg : fdjtUI.T(arg); form && "FORM" !== form.tagName; ) form = form.parentNode;
        if (form) {
            var submit_evt = document.createEvent("HTMLEvents");
            submit_evt.initEvent("submit", !0, !0), form.dispatchEvent(submit_evt);
        }
    }
    function focusEvent(arg) {
        var elt = arg.nodeType ? arg : fdjtUI.T(arg), focus_evt = document.createEvent("HTMLEvents");
        focus_evt.initEvent("focus", !0, !0), elt.dispatchEvent(focus_evt);
    }
    function disableForm(form) {
        if ("string" == typeof form && (form = fdjtID(form)), form) for (var elements = fdjtDOM.getChildren(form, "button,input,optgroup,option,select,textarea"), i = 0, lim = elements.length; lim > i; ) elements[i++].disabled = !0;
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass;
    fdjtUI.T = function(evt) {
        return evt = evt || window.event, evt.target || evt.srcElement;
    }, fdjtUI.noDefault = function(evt) {
        return evt = evt || window.event, evt.preventDefault ? evt.preventDefault() : evt.returnValue = !1, 
        !1;
    }, fdjtUI.cancelBubble = fdjtUI.noBubble = function(evt) {
        evt = evt || window.event, evt.stopPropagation ? evt.stopPropagation() : evt.canceBubble = !0;
    }, fdjtUI.cancel = function(evt) {
        return evt = evt || window.event, evt.preventDefault ? evt.preventDefault() : evt.returnValue = !1, 
        evt.stopPropagation ? evt.stopPropagation() : evt.cancelBubble = !0, !1;
    }, fdjtUI.isClickable = function(target) {
        for (window.Event && target instanceof window.Event && (target = fdjtUI.T(target)); target; ) {
            if ("A" === target.tagName && target.href || "INPUT" === target.tagName || "BUTTON" === target.tagName || "TEXTAREA" === target.tagName || "SELECT" === target.tagName || "OPTION" === target.tagName || hasClass(target, "checkspan") || hasClass(target, "clickable") || hasClass(target, "isclickable")) return !0;
            if (target.onclick) return !0;
            target = target.parentNode;
        }
        return !1;
    }, fdjtUI.isDefaultClickable = function(target) {
        for (window.Event && target instanceof window.Event && (target = fdjtUI.T(target)); target; ) {
            if ("A" === target.tagName && target.href || "INPUT" === target.tagName || "TEXTAREA" === target.tagName || "SELECT" === target.tagName || "OPTION" === target.tagName || hasClass(target, "isclickable")) return !0;
            target = target.parentNode;
        }
        return !1;
    }, fdjtUI.submitEvent = submitEvent, fdjtUI.focusEvent = focusEvent, fdjtUI.disableForm = disableForm;
}(), function() {
    "use strict";
    function Ellipsis(spec, string, lim, thresh, handler) {
        var content = ellipsize(string, lim, thresh || .2), split = "string" != typeof content, len = string.length;
        if (handler || (handler = toggle), "string" == typeof content && content.length === len) return spec ? fdjtDOM(spec, string) : document.createTextNode(string);
        var before = split ? content[0] : content, after = split ? content[1] : "", clen = before.length + after.length, pct = Math.round(100 * clen / len);
        spec && addClass(elt, "ellipsis");
        var remaining = split ? string.slice(before.length, len - after.length) : string.slice(before.length), elided = fdjtDOM("span.elided", remaining), elision = fdjtDOM("span.elision", fdjtString(" …←%d%% more→…", 100 - pct)), delision = fdjtDOM("span.delision", fdjtString(" →…hide %d%%…← ", 100 - pct));
        elision.title = "show elided text", delision.title = "hide elided text", elision.onclick = handler, 
        delision.onclick = handler;
        var elt = fdjtDOM(spec || "span.ellipsis", before, " ", elision, delision, elided, " ", after);
        return spec && addClass(elt, "ellipsis"), elt.title = fdjtString.stdspace(string), 
        elt;
    }
    function expand(node) {
        "string" == typeof node && (node = fdjtID(node));
        var ellipsis = getParent(node, ".ellipsis");
        addClass(ellipsis, "expanded"), dropClass(ellipsis, "compact");
    }
    function contract(node) {
        "string" == typeof node && (node = fdjtID(node));
        var ellipsis = getParent(node, ".ellipsis");
        addClass(ellipsis, "compact"), dropClass(ellipsis, "expanded");
    }
    function toggle(arg) {
        var evt = !1;
        if (arg) "string" == typeof arg ? arg = fdjtID(arg) : arg.nodeType || (evt = arg, 
        arg = fdjtUI.T(arg)); else {
            if (evt = window.event || !1, !evt) return;
            arg = fdjtUI.T(evt);
        }
        var ellipsis = getParent(arg, ".ellipsis");
        ellipsis && (evt && fdjtUI.cancel(evt), hasClass(ellipsis, "expanded") ? (addClass(ellipsis, "compact"), 
        dropClass(ellipsis, "expanded")) : (addClass(ellipsis, "expanded"), dropClass(ellipsis, "compact")));
    }
    var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, ellipsize = fdjtString.ellipsize, getParent = fdjtDOM.getParent, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass;
    fdjtUI.Ellipsis = Ellipsis, Ellipsis.expand = expand, Ellipsis.contract = contract, 
    Ellipsis.toggle = toggle;
}(), function() {
    "use strict";
    function selectSubmit(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if ("" !== target.value) {
            var form = fdjtDOM.getParent(target, "FORM");
            form && form.submit();
        }
    }
    function setupSelectSubmit() {
        for (var setup = fdjtDOM.$(".fdjtselectsubmit"), i = 0, lim = setup.length; lim > i; ) fdjtDOM.addListener(setup[i++], "change", selectSubmit);
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjt.addInit(setupSelectSubmit, "selectsubmit");
}(), function() {
    "use strict";
    function updatePasswordVisibility(evt, input, visible) {
        if (evt = evt || window.event, "string" == typeof input && (input = document.getElementById(input)), 
        input) {
            var target = fdjtUI.T(evt);
            input.type = visible ? target.checked ? "PASSWORD" : "TEXT" : target.checked ? "TEXT" : "PASSWORD", 
            setTimeout(function() {
                input.focus();
            }, 1e3);
        }
    }
    function uploadSelected(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), tbody = fdjtDOM.getParent(target, ".upload");
        tbody && fdjtDOM.addClass(tbody, "uploading");
    }
    function focusBox_onfocus(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), box = getParent(target, ".focusbox");
        box && addClass(box, "focused");
    }
    function focusBox_onblur(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), box = getParent(target, ".focusbox");
        box && setTimeout(function() {
            dropClass(box, "focused");
        }, 200);
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, getParent = fdjtDOM.getParent, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass;
    fdjtUI.updatePasswordVisibility = updatePasswordVisibility, fdjtUI.uploadSelected = uploadSelected, 
    fdjtUI.FocusBox.focus = focusBox_onfocus, fdjtUI.FocusBox.blur = focusBox_onblur;
}(), function() {
    "use strict";
    function fixTimeElement(elt) {
        var tstring = elt.getAttribute("datetime") || elt.getAttribute("data-datetime") || elt.getAttribute("data-time"), parsed = tstring && new Date(tstring), good = parsed && "nogood" !== (parsed.getYear() || "nogood");
        tstring || (tstring = elt.innerText, parsed = new Date(tstring), good = parsed && "nogood" !== (parsed.getYear() || "nogood"), 
        good && ("TIME" === elt.tagName ? elt.setAttribute("datetime", tstring) : elt.setAttribute("data-datetime", tstring))), 
        good && (elt.title || (elt.title = parsed.toGMTString()), hasClass(elt, "fdjtkeeptext") || (hasClass(elt, "fdjtisotime") ? parsed.toISOString && (elt.innerHTML = parsed.toISOString()) : hasClass(elt, "fdjtutctime") ? parsed.toUTCString && (elt.innerHTML = parsed.toUTCString()) : hasClass(elt, "fdjtdate") ? parsed.toDateString && (elt.innerHTML = parsed.toDateString()) : hasClass(elt, "fdjtdateortime") ? parsed.toDateString && parsed.toTimeString && (elt.innerHTML = parsed.toDateString() === new Date().toDateString ? parsed.toTimeString() : parsed.toDateString()) : hasClass(elt, "fdjtlocaletime") ? parsed.toLocaleString && (elt.innerHTML = parsed.toLocaleString()) : hasClass(elt, "fdjtlocaledate") ? parsed.toLocaleDate && (elt.innerHTML = parsed.toLocaleDate()) : hasClass(elt, "fdjtlocaledateortime") ? (parsed.toLocaleDateString && parsed.toTimeString && (elt.innerHTML = parsed.toDateString() === new Date().toDateString ? parsed.toLocaleTimeString() : parsed.toLocaleDateString()), 
        parsed.toLocaleDate && (elt.innerHTML = parsed.toLocaleDate())) : elt.innerHTML = hasClass(elt, "fdjthumantime") ? parsed.toDateString && parsed.toLocaleTimeString ? parsed.toDateString() + " (" + parsed.toLocaleTimeString() + ")" : parsed.toLocaleString ? parsed.toLocaleString() : "" + parsed : parsed.toDateString && parsed.toLocaleTimeString ? parsed.toDateString() + " (" + parsed.toLocaleTimeString() + ")" : parsed.toLocaleString ? parsed.toLocaleString() : "" + parsed));
    }
    function initTimeElements(node) {
        for (var elts = node ? fdjt.keeptime ? fdjtDOM.getChildren(node, ".fdjtime") : fdjtDOM.getChildren(node, "time,.fdjtime") : fdjt.keeptime ? fdjtDOM.$(".fdjtime") : fdjtDOM.$("time,.fdjtime"), i = 0, lim = elts.length; lim > i; ) fixTimeElement(elts[i++]);
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, hasClass = fdjtDOM.hasClass;
    fdjt.initTimeElements = initTimeElements, fdjt.autoInitTimeElements = function() {
        fdjtDOM.addListener(document.body, "DOMNodeInserted", function(evt) {
            evt = evt || window.event, initTimeElements(fdjtUI.T(evt));
        });
    }, fdjt.addInit(initTimeElements, "TimeElements", !1);
}(), function() {
    "use strict";
    var vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
    fdjt.UI.vibrate = function(args) {
        return vibrate ? (vibrate(args), !0) : !1;
    };
}(), fdjt.disenableInputs = fdjt.UI.disenableInputs = function() {
    "use strict";
    function disenableInputs(under) {
        for (var inputs = $("input,select,button,textarea", under), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            if (!hasClass(input, "fdjtignore")) {
                for (var scan = input, disable = !1; scan && scan !== under; ) {
                    var style = getStyle(scan);
                    if ("none" === style.display) {
                        disable = !0;
                        break;
                    }
                    scan = scan.parentNode;
                }
                input.disabled = disable;
            }
        }
    }
    var fdjtDOM = fdjt.DOM, getStyle = fdjtDOM.getStyle, hasClass = fdjtDOM.hasClass, $ = fdjtDOM.$;
    return disenableInputs;
}(), fdjt.showPage = fdjt.UI.showPage = function() {
    "use strict";
    function getContainer(arg) {
        var container;
        return container = "string" == typeof arg ? document.getElementById(arg) : arg.nodeType ? arg : fdjt.UI.T(arg) ? fdjt.UI.T(arg) : !1, 
        container ? container = fdjtDOM.getParent(container, ".fdjtpage") || container : fdjtLog.warn("Bad showPage container arg %s", arg), 
        container;
    }
    function istootall(container, height, padding) {
        return height || (height = container.offsetHeight), padding ? container.scrollHeight > height - padding : container.scrollHeight > height;
    }
    function isOversize(elt, w, h) {
        return w === void 0 && (w = !0), h === void 0 && (h = !0), h && elt.scrollHeight > elt.offsetHeight || w && elt.scrollWidth > elt.offsetWidth;
    }
    function showPage(container, start, dir) {
        if (container = getContainer(container)) {
            dir = "number" != typeof dir ? 1 : 0 > dir ? -1 : 1;
            var startpos, h, shown = toArray(getChildren(container, ".fdjtshow")), curstart = getChild(container, ".fdjtstartofpage"), curend = getChild(container, ".fdjtendofpage"), info = getChild(container, ".fdjtpageinfo"), children = getNodes(container), lim = children.length, caboose = 0 > dir ? "fdjtstartofpage" : "fdjtendofpage", padding = getGeometry(container, !1, !0).bottom_padding, tap_event_name = fdjt.device.touch ? "touchstart" : "click";
            if (0 !== children.length && (start ? "number" == typeof start && start > 0 && 1 > start ? (startpos = Math.round(start * children.length), 
            start = children[startpos]) : "number" == typeof start ? (startpos = start - 1, 
            start = children[startpos]) : start.nodeType && (start = getPageElt(container, start), 
            startpos = children.indexOf(start)) : (startpos = 0, start = children[0]), !(!start || 0 > startpos || startpos >= lim || 0 === startpos && 0 > dir))) {
                if (addClass(container, "fdjtpage"), h = container.offsetHeight, addClass(container, "formatting"), 
                info || (info = getProgressIndicator(container, startpos, lim)), shown.length && (dropClass(shown, "fdjtshow"), 
                dropClass(shown, "fdjtoversize")), curstart && dropClass(curstart, "fdjtstartofpage"), 
                curend && dropClass(curend, "fdjtendofpage"), addClass(start, "fdjtshow"), addClass(start, 0 > dir ? "fdjtendofpage" : "fdjtstartofpage"), 
                start.offsetHeight > h && addClass(start, "fdjtoversize"), 0 > dir && hasClass(start, /fdjtpagebreak(auto)?/) || istootall(container, h, padding)) return dropClass(container, "formatting"), 
                startpos;
                var endpos = showchildren(container, children, startpos, dir, h, padding), end = children[endpos];
                if (dir > 0 && hasClass(end, "fdjtpagehead")) for (;endpos > startpos && hasClass(end, "fdjtpagehead"); ) dropClass(end, "fdjtshow"), 
                dropClass(end, caboose), endpos--, end = children[endpos], addClass(end, caboose);
                if (dir > 0 && hasClass(end, "fdjtpagekeep")) for (;startpos > endpos && hasClass(end, "fdjtpagekeep"); ) dropClass(end, "fdjtshow"), 
                dropClass(end, caboose), endpos++, end = children[endpos], addClass(end, caboose);
                var at_start = !1, at_end = !1;
                if (0 === startpos ? (addClass(container, "fdjtfirstpage"), at_start = !0) : dropClass(container, "fdjtfirstpage"), 
                endpos >= lim - 1 ? (addClass(container, "fdjtlastpage"), at_end = !0) : dropClass(container, "fdjtlastpage"), 
                0 > dir && 0 === endpos) return dropClass(container, "formatting"), showPage(container, 0, 1);
                var minpos = endpos >= startpos ? startpos : endpos, maxpos = startpos > endpos ? startpos : endpos, countdom = fdjtDOM("span.count", fdjtDOM("strong", "/"), lim), txtdom = fdjtDOM("span.value", Math.floor(100 * (minpos / lim))), pctdom = fdjtDOM("span.pct", txtdom, "%", countdom), forward_button = fdjtDOM("span.button.forward", " 》"), backward_button = fdjtDOM("span.button.backward", "《 ");
                return info.innerHTML = "", fdjtDOM.append(info, backward_button, pctdom, forward_button), 
                info.title = fdjtString("Items %d through %d of %d", minpos, maxpos, lim), txtdom.setAttribute("contentEditable", "true"), 
                addListener(txtdom, "blur", pageInputBlur), addListener(txtdom, "keyup", cancelBubble), 
                addListener(txtdom, "keypress", cancelBubble), addListener(txtdom, "keydown", pageInputKeydown), 
                addListener(pctdom, tap_event_name, pageInputTapped), at_start ? backward_button.innerHTML = "· " : addListener(backward_button, tap_event_name, backwardButton), 
                at_end ? forward_button.innerHTML = "· " : addListener(forward_button, tap_event_name, forwardButton), 
                addClass(container, "fdjtpagechange"), setTimeout(function() {
                    dropClass(container, "fdjtpagechange");
                }, 1e3), dropClass(container, "formatting"), endpos;
            }
        }
    }
    function pageInputKeydown(evt) {
        var target = fdjtUI.T(evt), container = getParent(target, ".fdjtpage");
        if (container) {
            var kc = evt.keyCode;
            if (target._savedHTML || (target._savedHTML = target.innerHTML), 13 === kc) {
                try {
                    var s = fdjtDOM.textify(target), pct = parseFloat(s) / 100;
                    "number" != typeof pct || Number.isNaN(pct) ? (target.innerHTML = target._savedHTML, 
                    target._savedHTML = !1) : showPage(container, pct, 1), target.blur();
                } catch (ex) {
                    target._savedHTML && (target.innerHTML = target._savedHTML, target._savedHTML = !1), 
                    target.blur();
                }
                cancel(evt);
            } else 27 === kc && (target._savedHTML && (target.innerHTML = target._savedHTML, 
            target._savedHTML = !1), target.blur(), cancel(evt));
        }
    }
    function pageInputBlur(evt) {
        var target = fdjtUI.T(evt), info = getParent(target, ".fdjtpageinfo");
        info && dropClass(info, "fdjteditpageinfo"), target._savedHTML && (target.innerHTML = target._savedHTML, 
        target._savedHTML = !1);
    }
    function pageInputTapped(evt) {
        var target = fdjtUI.T(evt), input = fdjtDOM.getChild(target, "span.value"), info = getParent(target, ".fdjtpageinfo");
        info && addClass(info, "fdjteditpageinfo"), input && input.focus();
        var selection = window.getSelection && window.getSelection();
        if (selection && selection.anchorNode && getParent(selection.anchorNode, input)) {
            var anchor = selection.anchorNode;
            3 === anchor.nodeType && selection.extend(anchor, anchor.nodeValue.length);
        }
        cancel(evt);
    }
    function forwardButton(evt) {
        fdjt.UI.cancel(evt), forwardPage(evt);
    }
    function backwardButton(evt) {
        fdjt.UI.cancel(evt), backwardPage(evt);
    }
    function getProgressIndicator(container, startpos, lim) {
        var info = fdjtDOM("div.fdjtpageinfo", startpos + 1, "/", lim);
        return container.appendChild(info), info;
    }
    function getPageElt(container, node) {
        for (var scan = node, parent = scan.parentNode; parent && parent !== container; ) scan = parent, 
        parent = scan.parentNode;
        return parent === container ? scan : !1;
    }
    function getNodes(container) {
        var children = [], nodes = container.childNodes;
        addClass(container, "getvisible");
        for (var i = 0, lim = nodes.length, prev = !1; lim > i; ) {
            var node = nodes[i++];
            if (1 === node.nodeType) {
                var style = getStyle(node);
                if ("none" === style.display) continue;
                if (style.position && "static" !== style.position) continue;
                "always" === style.pageBreakBefore ? addClass(node, "fdjtpagebreakauto") : dropClass(node, "fdjtpagebreakauto"), 
                prev && hasClass(prev, "fdjtpagekeep") && addClass(node, "fdjtpagekeep"), prev && hasClass(node, "fdjtpagekeep") && addClass(prev, "fdjtpagehead"), 
                children.push(node);
            }
        }
        return dropClass(container, "getvisible"), children;
    }
    function showchildren(container, children, i, dir, h, padding) {
        var lim = children.length, scan = children[i + dir], last = children[i], caboose = 0 > dir ? "fdjtstartofpage" : "fdjtendofpage";
        for (i += dir, addClass(last, caboose); i >= 0 && lim > i; ) {
            if (dir > 0 && hasClass(scan, /fdjtpagebreak(auto)?/)) return i - dir;
            if (dropClass(last, caboose), addClass(scan, "fdjtshow"), addClass(scan, caboose), 
            scan.offsetHeight > h && addClass(scan, "fdjtoversize"), istootall(container, h, padding)) return addClass(last, caboose), 
            dropClass(scan, "fdjtshow"), scan.style.display = "", dropClass(scan, caboose), 
            i - dir;
            if (0 > dir && hasClass(scan, /fdjtpagebreak(auto)?/)) return i;
            i += dir, last = scan, scan = children[i];
        }
        return i - dir;
    }
    function checkOversize(scan) {
        var saved = scan.style.overflow || "";
        scan.style.overflow = "auto", isOversize(scan) && (addClass(scan, "fdjtoversize"), 
        isOversize(scan) && adjustFonts(scan)), scan.style.overflow = saved;
    }
    function forwardPage(container) {
        if (container = getContainer(container)) {
            dropClass(container, "fdjtpagechange");
            var foot = getChild(container, ".fdjtendofpage");
            return foot ? hasClass(container, "fdjtlastpage") ? !1 : foot.nextSibling ? showPage(container, foot.nextSibling) : !1 : showPage(container);
        }
    }
    function fastForwardPage(container) {
        if (container = getContainer(container)) {
            var foot = getChild(container, ".fdjtendofpage");
            if (!foot) return showPage(container);
            if (hasClass(container, "fdjtlastpage")) return !1;
            if (foot.nextSibling) {
                var children = getNodes(container), off = children.indexOf(foot), len = children.length, next_off = Math.floor(off + (len - off) / 2);
                return showPage(container, children[next_off], 1);
            }
            return !1;
        }
    }
    function backwardPage(container) {
        if (container = getContainer(container)) {
            dropClass(container, "fdjtpagechange");
            var head = getChild(container, ".fdjtstartofpage");
            return head ? hasClass(container, "fdjtfirstpage") ? !1 : head.previousSibling ? showPage(container, head.previousSibling, -1) : !1 : showPage(container);
        }
    }
    function fastBackwardPage(container) {
        if (container = getContainer(container)) {
            var head = getChild(container, ".fdjtstartofpage");
            if (!head) return showPage(container);
            if (hasClass(container, "fdjtfirstpage")) return !1;
            if (head.previousSibling) {
                var children = getNodes(container), off = children.indexOf(head), next_off = Math.floor(off / 2);
                return showPage(container, children[next_off], -1);
            }
            return !1;
        }
    }
    function updatePage(container) {
        if (container = getContainer(container)) {
            var head = getChild(container, ".fdjtstartofpage");
            if (head.hidden) {
                for (var scan = head; scan; ) if (1 !== scan.nodeType) scan = scan.nextSibling; else {
                    if (!scan.hidden) return showPage(container, scan);
                    scan = scan.nextSibling;
                }
                showPage(container);
            } else showPage(container, head);
        }
    }
    function checkPage(container) {
        if (container = getContainer(container)) if (hasClass(container, "fdjtpage")) {
            if (!container.offsetHeight || !hasClass(container, "needsresize")) return;
            dropClass(container, "needsresize"), updatePage(container);
        } else container.offsetHeight && showPage(container);
    }
    function showNode(container, node) {
        if (container = getContainer(container)) {
            if (!hasClass(container, "fdjtpage")) {
                if (!container.offsetHeight) return !1;
                showPage(container);
            }
            for (var parent = node.parentNode; parent && parent !== container; ) node = parent, 
            parent = node.parentNode;
            return parent ? hasClass(node, "fdjtshown") ? !1 : showPage(container, node) : void 0;
        }
    }
    var fdjtUI = fdjt.UI, fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtString = fdjt.String, getStyle = fdjtDOM.getStyle, getChild = fdjtDOM.getChild, getChildren = fdjtDOM.getChildren, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, hasClass = fdjtDOM.hasClass, addListener = fdjtDOM.addListener, toArray = fdjtDOM.toArray, getGeometry = fdjtDOM.getGeometry, getParent = fdjtDOM.getParent, cancelBubble = fdjtUI.cancelBubble, cancel = fdjtUI.cancel, adjustFonts = fdjtDOM.adjustFonts;
    return showPage.isOversize = isOversize, showPage.checkOversize = checkOversize, 
    showPage.forward = forwardPage, showPage.fastForward = fastForwardPage, showPage.backward = backwardPage, 
    showPage.fastBackward = fastBackwardPage, showPage.update = updatePage, showPage.check = checkPage, 
    showPage.showNode = showNode, showPage;
}(), fdjt.Dialog = function() {
    "use strict";
    function Dialog(spec) {
        spec ? "string" == typeof spec && (spec = {
            spec: spec
        }) : spec = {};
        var box = fdjtDOM(spec.spec || "div.fdjtdialog");
        if (spec.classes && (box.className = (box.className || "") + (box.className ? " " : "") + spec.classes), 
        spec.style && box.setAttribute("style", spec.style), !(spec.modal || spec.keep || hasClass(box, "fdjtmodal") || hasClass(box, "fdjtkeep"))) {
            var countdown = fdjtDOM("div.countdown", "Closing…");
            countdown.id = "FDJTCOUNTDOWN" + countdown_serial++, box.appendChild(countdown);
        }
        if (!(spec.modal || spec.noclose || hasClass(box, "fdjtmodal"))) {
            var close_button = fdjtDOM.Image(redx_png, "closebutton", "Close");
            addListener(close_button, "click", close_dialog_handler), addListener(close_button, "touchend", close_dialog_handler), 
            addListener(close_button, "touchstart", fdjtUI.cancel), close_button.title = "click to close", 
            box.appendChild(close_button);
        }
        if (spec.title) if (spec.title.nodeType) elts.push(spec.title); else {
            var title_text = template(spec.title, spec, spec.data);
            box.title = title_text, box.appendChild(fdjtDOM("div.title", title_text));
        }
        for (var content, elts = [], i = 1, lim = arguments.length, wrap = !0; lim > i; ) {
            var e = arguments[i++];
            if (e.nodeType) {
                wrap = !1;
                break;
            }
            if ("string" == typeof e && e.indexOf("<") >= 0) {
                wrap = !1;
                break;
            }
        }
        for (wrap ? (content = fdjtDOM("P"), box.appendChild(content)) : content = box, 
        i = 1; lim > i; ) {
            var arg = arguments[i++];
            if (arg) if (arg.nodeType) content.appendChild(arg); else if ("string" == typeof arg) {
                arg = Templates[arg] || arg;
                var ishtml = arg.indexOf("<") >= 0, istemplate = arg.search("{{") >= 0;
                ishtml && istemplate ? content.appendChild(Template.toDOM(arg, spec)) : ishtml ? fdjtDOM.append(content, arg) : istemplate ? content.appendChild(document.createTextNode(template(arg, spec))) : content.appendChild(document.createTextNode(arg));
            } else content.appendChild(document.createTextNode(arg.toString)); else ;
        }
        return spec.id && !box.id && (box.id = spec.id), fdjtDOM.addListeners(box, spec), 
        box;
    }
    function remove_dialog(evt) {
        evt = evt || window.event;
        var target = evt ? evt.nodeType ? evt : fdjtUI.T(evt) : fdjtID("FDJTALERT") || fdjtID("FDJTDIALOG"), box = fdjtDOM.getParent(target, ".fdjtdialog");
        if (box) {
            var countdown = fdjtDOM.getChild(box, ".countdown");
            if (countdown && countdown.id) {
                var ticker = countdown_tickers[countdown.id];
                ticker && clearInterval(ticker), delete countdown_tickers[countdown.id];
            }
            clear_countdown(box), fdjtDOM.remove(box);
        }
    }
    function close_dialog(evt, fast) {
        evt = evt || window.event;
        var target = evt ? evt.nodeType ? evt : fdjtUI.T(evt) : fdjtID("FDJTALERT") || fdjtID("FDJTDIALOG");
        evt && !evt.nodeType && fdjtUI.cancel(evt);
        var box = fdjtDOM.getParent(target, ".fdjtdialog");
        box && (clear_countdown(box), fast ? fdjtDOM.remove(box) : fdjtDOM.transitionEnd && !fdjtDOM.hasClass(box, "closing") ? (fdjtDOM.addListener(box, fdjtDOM.transitionEnd, function() {
            fdjtDOM.remove(box);
        }), fdjtDOM.addClass(box, "closing")) : fdjtDOM.remove(box));
    }
    function clear_countdown(box) {
        var countdown = fdjtDOM.getChild(box, ".countdown");
        if (countdown) {
            var ticker = countdown_tickers[countdown.id];
            delete countdown_tickers[countdown.id], ticker && clearInterval(ticker);
        }
    }
    function close_dialog_handler(evt) {
        evt = evt || window.event, fdjtUI.cancel(evt), close_dialog(evt);
    }
    function stop_countdown_onclick(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), box = fdjtDOM.getParent(target, ".fdjtdialog");
        clear_countdown(box), box.style[fdjtDOM.transitionDelay] = "", box.style[fdjtDOM.transitionDuration] = "", 
        fdjtDOM.dropClass(box, "countdown"), fdjtDOM.dropClass(box, "closing"), fdjtUI.cancel(evt);
    }
    function alertBox() {
        var args = fdjtDOM.toArray(arguments), box = Dialog.apply(null, [ {} ].concat(args));
        addClass(box, "fdjtalert");
    }
    function alertfn() {
        var curbox = fdjtID("FDJTALERT");
        curbox && (curbox.id = "", fdjtDOM.dropClass(curbox, "closing"), remove_dialog(curbox));
        var args = fdjtDOM.toArray(arguments), box = Dialog.apply(null, [ {} ].concat(args));
        return box.id = "FDJTALERT", fdjtDOM.prepend(document.body, box), box;
    }
    function setCountdown(box, timeout, whendone) {
        var countdown = fdjtDOM.getChild(box, ".countdown");
        countdown.innerHTML = "…" + timeout + "…";
        var n = timeout;
        box.style[fdjtDOM.transitionDelay] = n / 2 + "s", box.style[fdjtDOM.transitionDuration] = n / 2 + "s";
        var ticker = setInterval(function() {
            0 >= n ? (clearInterval(ticker), ticker = !1, delete countdown_tickers[countdown.id], 
            whendone && whendone(), fdjtDOM.remove(box)) : countdown.innerHTML = "…" + n-- + "…";
        }, 1e3);
        return countdown_tickers[countdown.id] = ticker, countdown.onclick = stop_countdown_onclick, 
        addListener(countdown, "touchend", stop_countdown_onclick), addListener(countdown, "touchstart", fdjtUI.cancel), 
        setTimeout(function() {
            fdjtDOM.addClass(box, "closing");
        }, 10), box;
    }
    function alertFor(timeout) {
        var curbox = fdjtID("FDJTALERT");
        curbox && (curbox.id = "", fdjtDOM.dropClass(curbox, "closing"), remove_dialog(curbox));
        var args = [ {
            timeout: timeout
        } ].concat(fdjtDOM.slice(arguments, 1)), box = Dialog.apply(null, args);
        return box.id = "FDJTALERT", fdjtDOM.prepend(document.body, box), setCountdown(box, timeout), 
        box;
    }
    function message(spec) {
        var curbox = fdjtID("FDJTMESSAGE");
        curbox && (curbox.id = "", fdjtDOM.dropClass(curbox, "closing"), remove_dialog(curbox));
        var args = fdjtDOM.toArray(arguments), box = Dialog.apply(null, args);
        return spec.timeout && setCountdown(box, spec.timeout), box.id = "FDJTMESSAGE", 
        fdjtDOM.prepend(document.body, box), box;
    }
    function makeChoice(spec, close_choice, i) {
        var dom = spec.dom;
        return dom || (dom = fdjtDOM("button"), spec.label.nodeType ? dom.appendChild(spec.label.cloneNode(!0)) : dom.innerHTML = spec.label ? spec.label : "Choice " + i), 
        spec.name && (dom.name = spec.name), spec.value && (dom.value = spec.value), dom.onmousedown = fdjtUI.cancel, 
        dom.onmouseup = fdjtUI.cancel, dom.tabIndex = i, spec.title && (dom.title = spec.title), 
        spec.classname && addClass(dom, spec.classname), dom.onclick = function(evt) {
            evt = evt || window.event;
            var target = fdjtUI.T(evt), choices = fdjtDOM.getParent(target, ".choices"), cursel = fdjtDOM.getChild(choices, ".selected");
            cursel === dom || (cursel && (fdjtDOM.dropClass(cursel, "selected"), cursel.blur()), 
            fdjtDOM.addClass(dom, "selected"), dom.focus()), spec.handler && spec.handler(), 
            fdjtUI.cancel(evt), close_choice();
        }, addListener(dom, "touchstart", fdjtUI.cancel), addListener(dom, "touchend", dom.onclick), 
        dom;
    }
    function choose(spec) {
        function close_choice() {
            for (var i = 0, lim = buttons.length; lim > i; ) {
                var button = buttons[i++];
                button.onclick && removeListener(button, "touchend", button.onclick), removeListener(button, "touchstart", fdjtUI.cancel), 
                button.onclick = null, button.onmousedown = null, button.onmouseup = null;
            }
            if (close_button && (removeListener(close_button, "touchend", close_button.onclick), 
            removeListener(close_button, "touchstart", fdjtUI.cancel), close_button.onclick = null), 
            box && (box.onclick = null), box && (box.onkeydown = null), box) var timeout = setTimeout(function() {
                spec.onclose && spec.onclose(box), remove_dialog(box), clearTimeout(timeout), timeout = !1;
            }, 500);
        }
        var choices, box = !1, selection = -1, buttons = [], close_button = !1, onchoose = !1;
        if ("function" == typeof spec) choices = [ {
            label: "Cancel"
        }, {
            label: "OK",
            handler: spec,
            isdefault: !0
        } ]; else if (spec.constructor === Array) choices = spec; else if (spec.choices) choices = spec.choices; else if (spec.label && spec.handler) choices = [ {
            label: "Cancel"
        }, spec ]; else if (spec.handler) choices = [ {
            label: "Cancel"
        }, {
            label: "OK",
            handler: spec.handler,
            isdefault: spec.isdefault
        } ]; else {
            if (!choices.length) return fdjtLog.warn("Bad spec %o to fdjtUI.choose"), void 0;
            choices = spec;
        }
        spec.onchoose && (onchoose = spec.onchoose);
        for (var i = 0, lim = choices.length; lim > i; ) {
            var choice = choices[i], button = makeChoice(choice, close_choice, i);
            buttons.push(button), 0 > selection && choice.isdefault && (button.setAttribute("autofocus", "autofocus"), 
            fdjtDOM.addClass(button, "selected"), selection = i), i++;
        }
        0 > selection && !spec.nodefault && (fdjtDOM.addClass(buttons[i], "selected"), selection = 0), 
        box = makeDialog(spec, fdjtDOM("div.message", fdjtDOM.slice(arguments, 1)), fdjtDOM("div.choices", buttons)), 
        close_button = fdjtDOM.getChild(box, ".closebutton"), spec.cancel ? (removeListener(close_button, "touchend", close_button.onclick), 
        close_button.onclick = close_choice, addListener(close_button, "touchend", close_button.onclick)) : fdjtDOM.remove(close_button);
        var cancel = spec.cancel || !1;
        return box.onkeydown = function(evt) {
            evt = evt || window.event;
            var kc = evt.keyCode;
            9 === kc ? (evt.shiftKey ? selection-- : selection++, 0 > selection ? selection = buttons.length - 1 : selection >= buttons.length && (selection = 0), 
            selection >= 0 && buttons[selection].focus(), fdjtUI.cancel(evt)) : 13 === kc ? (selection >= 0 && choices[selection] && choices[selection].handler && choices[selection].handler(), 
            onchoose && selection >= 0 && choices[selection] && onchoose(choices[selection], box), 
            close_choice(), fdjtUI.cancel(evt)) : cancel && 27 === kc && (close_choice(), fdjtUI.cancel(evt));
        }, fdjtDOM.addClass(box, "fdjtconfirm"), box.id = "FDJTDIALOG", fdjtDOM.prepend(document.body, box), 
        spec.timeout && setCountdown(box, spec.timeout, function() {
            return spec.noauto ? (close_choice(), void 0) : (selection >= 0 && choices[selection] && choices[selection].handler && choices[selection].handler(), 
            onchoose && selection >= 0 && choices[selection] && onchoose(choices[selection], box), 
            void 0);
        }), selection >= 0 && buttons[selection].focus(), box;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, Template = fdjt.Template, template = fdjt.Template, Templates = fdjt.Templates, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, addListener = fdjtDOM.addListener, removeListener = fdjtDOM.removeListener, countdown_serial = 1, countdown_tickers = {}, redx_png = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyEAYAAAE5qGRkAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAASAAAAEgARslrPgAAEXpJREFUeNrdXGl4VEW6fqv3bCT0SQjhVADpCggMuywiUTbZAoRNFlkER8SZwUdnrtuMy+idcUZFwHEYERdAkR1kcxRkXwVBWYSw5DSE5DQQyOmsnd677o9Ah5vcvt2ns3Cf+/7Jw6n63u99vzpL1anTALeh5NH2rNPGKQgBe6f0NhmW+D8HDygLxRKmG3JQUShljHPlEjWzjmszgwGt6Xi2Mfb5YLuTprM2xU2rGS20NWudNSPYIV+0sfYrtwX/XUgtLK304VCKoNhpf7ZoohIMUGgy6+QvqdlPEwy4JE5kIwwzwCHhg7VmuOCHt3IjABOcmkQlIJayQZ+uqc7wmliZodO/FMxQSpuyLg570EJb0cnaTj4bbK+k/ZjlozHVBCW0NUt33heyqhm0M5s1fR2iBbmT+s4BQZBlSSIkqKBGe8iGmqhJhJqBoQhUZ1DtIXrU1K6coxms5dq+Ecd/Tw+xdxNoqBoETzXSE4/xE1m7gpHN4YRh4uFgYDEdwB5buS9IvE7cw9bGvRwk7IHJ+LSsIBgfByCmeGmtItdSuI9qWVr2RHRCGuI2rw1ryQ0/tKUJQgv5unQxqaJmsyZUHPk1/4ov3fFJxLUvBkX++t2hmquv0s30T2ypccGdUvAfyYvkWWdisKcfgLdiU/D0aY9byJi88K5SX4f4VK+7Lspx7LGP+9QqXa3TygsvnI7rQnO5ULLFtwhnyN6eWlj6tKf5IbhhXLHkzvFaV47SXcxkC0yeiEsVAsp+ms7EL14JOrE/Rxey38VM4m9gPnZUBm9cIa/dUMQ1K2FCIZKWyiTqm0Qo4hqI+m4U8b1FraJwqCkkauuRljLsINZ1jBrfQYONQYOdRQ19HWjg5meQMC5JLXHYfn744Sv1Visppc0YHWeLtvZBnmtUYOnloYUpbUW3ZWPMu7UeuaU0kbH14R9M9QTlFn2Z2ROSaumwiXb2q+WtavYnxUnp/dhU4/aAlefhmGtopIlIKlqhybonzT75sPTzpGV1FW5/QpTZo3F/5gtIH1ypeDPiQC8CSF72QHBo7DqabKkcfoQXwkQ6f/ugaiU6JCF9tSwkymelvY+nhxX+Cn3QsjbuU/4iCsirFU+pzueFBw57QGgu35SuC9qQ55id0Cw2O+sEL8Jp7P2mh+pEJ1CB/JVDhKFyieSZtlOZKPZik2Pfw2JyDSccL6rm8yMOvOSk0Ey+KFmbdq/ZHPnz+JxYxjQj3WhOOqDNNoNqIWqhgw6a0m5CopwnXUo6Fa57xEZqGZMos+RnT0JTuMjAzWui5QlCCx08ZR8ISXKelJ/4e7XhGrUBwQr8k8fh4R11ntIFkQc3+Mb2UeuJtKN9NBUsM01JfBliyCFncRS53Lf/GiMSxtAB2s+mmIvl76WLs8OOeOhH6As03rLKmIY/Iom84bqmWrYHDjgrDglpcrFkS8hUXDSWJTxWCQfMSF0Xo5aOiEhD/CfHzC75uHRqTp9a7UHhs8T5ll+M/fE+WUjGuvaqFk7ghc+RKZjlQikv/lC47koubcs0kz+DGZVos/rXqtM1hxEtF6ebvbJV2vNbmSgBmsj0oy6iGAlotbVtxEw+EAQqVwupcoF0Oe5x1cZrGjsmVlicU4aDkftJp1XfRhzohgvashu1Ti27nvZjxrFX+Q3kIf3rlnc1VYBXrhcEuUSyxk2sq/Cwxs6JlZaC6WY0J23JgC+VYIMWfpCyDUKSfF3KTXwsPNFZamDp32YrT9IKy1/19Xd3UmuomGayfvu2FS1JT2Vm7dnIA/OpkTXZtq/mZM3+gVjIsoz3N5oBP23DHtxTPWksoiJjvMw+TJzHSnQna/avfnlxlqaz9ltLEIcUNBv5SM2OfDrpgYuuc8okOs1y1nClwQyU0p5M3J2KEnhwa0D1bZ6AAEjgq8g/0NPbXHlafN+yQHfXKwU97cS6bJ3Fb6AYjlFLI8wXINuQiymGs+aZcoz0F2+XOhsopqlswC6GAPQoGJQbNoAAILjFd6EQTt1TGp6HEngHd1aZV8NHIQOrPZ2VvmI3yzDd36I2cI22Yxm7ScQG7oAD4EjRrATh53vs1AiiXCDlxP4eWujgrjyjWsk2cotYvS/a19KW7Gl9XqRh9kTagXXe2QxGOMAHBlTnLebf8w/7fG7eInusCT86g9eIkCTnSQVxXWBADAKVR1WRcuj4YHDs9TS3d6GnLJ8b0kKOgI1msAe2/5tfRhkqBxeq1U/m4iHM6btMYLYO1hHHguuY0FOUCtqSdXBmwY0APKZvVJji4KjkbszjX+r1yaL8uPUhn0G5KLrZwO1bkUwsyB86SrWBf0CD9L7Pmv9Tzpf2/rCoVns4AqWStmAZrmw4oQE3blaZ3wcXbuLajn/BhGZoMfQ51QY6Ygw/+WCh+Ya8yJpwtHnIfpESKvk0hbV0jkccjDCYNqgVpBpOCLje7zWByqclx+G3wxpWy69cpxaW7uwEA9wwmtTfHMIJSuX56Jc53+yzaaTlh16IOC7ahEohbc/SXDHQoRxxxso6O4jDRBQ+vEowyQuk8oNTVRegrvmVIprOMnglCDg41K8z2oFC0/8Jc5F8VLq0/8todUS91FUCopdptr4RrYE74BchI7DvoyIvPWiZpmJSWLMgqg2U0kQmbvbBhwTEZGujTVzbEQiAHNIaE3gr/QxzhbzQutv3U70bURTahrHNBIAHyFb/JI5cEQFwiozFy6jQlZv3y3OlG/6Hw4eFM1BERZaxSQYBAR8jqhamBaD1OuEH4NerOQU5gIKAggS+Vdsvpa18wdohkB+qc8hrRLlCzUzY9ETUBq7xDXzXoHZCkixLFw2x0MAPv6dIBQMBkK4RUEFG+88Xj0nvn0E0IU+1WkaUG5SxzhtGogli0XTMctUGfuGn+f5HM4VOtj7W1nsu3TksNJWvS1eMKVVvED3DVLLGBj7nVm7xe+zvpP+c8bP2vf/JdZWBC5Qx8/plSIEL5gkzVRvI5+f5yiGPCt1sCdbeO3eF664U03TW2pOKADh0+hsR56lSvAk+tMcx3fNCM3mnJPjzieKnqazH+hMogR6lE9S/rNbwFWj56LtCU9sAac+uVyINu73ppLGX0RYsw7sVPmjAdVmqchP8wPPJ25q+GosGpdDBNWqPagMBaKAb2k2tgaCGqsoGzE3ka1KufhT80MHvtasi4XhQ0y3QM3DroV537wKKjDlzARDAxEIKuI8fR96wcnOZLU3y7WiiugChNFWNkN5eRluyDM9M+BAA14f+suIAjDznkSbCWNlqNRwor15YCbJNkmIyoIUGenft23I+v4KYEdn1bSBYoKqMXnMTOV/KNayAHxx+b611ELkfduj6f3fHQFhixU5bsDbuJfZYGmspHN67voWHw+0RMiiltAVr55ulHBZzLe5H/qPOxEqWuM2SHdNDuUqTWNI3e2ttUp6nSSxlw0dKX3ED0xm2Nrbxxoa9Ge3FlsavV/xUZJ32dr/r/RtljDsVq1jKWi3Pt38tGtjjulcj5Q05Qyly0YEsNmYRuYpfkLJuPpJhhH7k5YgVO8DRct1xbIAdy6b3FP4gO6VWnjqvGu4VFCudxwYmDEQLfIHA5g6oRAnkgf8MG8jBAdih5QVgy+JwCB3Jiae/EUbZzucW+SbU7F69OX2A7mErTJd5L8zF4nUmOFCGm6PSwiaMDAFcRTKwrgOZgz8iZvp483F5kvSLJ+rXeg0NZR59yzIufi1mYjfZu2UWNLgMYaCjzsRV70evIwAnYpaW4gG+ma+Y01nIs2Vau/i8RHHRrsy8djUcKIJ54uRG8svRBCa0WjeevM1nkwtT3zC/aXs51+br1kj5a0Fx089Yq9jRcOFN+Lbq4AMQM2hjoyQnKEM5NCj/sEv19KRYPMpaDfsRnIyA9utnwBELTUzEy8w6guMS9Ehccw2P8I04M+M5wWPrLnm9DVYQew79OEMb14vH4RPedcsVxOMmSgfdbCS/VV/Eeoqfwg3+C982bLbQ3ZZs7fJjn9CfoTShyZb8EWO4DIH0WT8NXjgQGzu+EaQSEHgQgzS0X92bvISH8NbMMvMieaHUzRP5M6wGlNz0zmxI3HtoyhOR9/UKEFxBYEi9v1sMCSMI4ounws838/dGXBUSbT2sQ44erm0+Qtg70ydY5xG7+CHshmPDFngBkJgPG8EKAYEbF3CTn1k5E1MwDG/N6irky1us73hDroCUt0UTK49ri6kkBVkbX0ACOK4Nnd0IequQAB90JSnkBbREnxHLzB/KP0rLfwi7/xD1rMeeQnuzzKyZ/CpsKNx4DU4AAeOOBjdaNWtx4iA0KF+5lN8ibnhn/otYeQ9+Td8V07GdtNv8M9IgQj/kQoPruQM/YuErPUpa4LfQDEs1++TnpctH26ilqbdpqFJITYxkWeFDIlpt2AAT9NCZXmq0gjQ2tDBAX/odLuBB/smIdUIfeaU188jyutI22LpA+VosYv1GX0Rv0ha2tYNgQiy0poK6M98jGEDAS0rhB/ipUR2EJLnAmnBI/VdfYdBoCzXlNBUtzux3kAo9saypgB4+xJr+0lj5VYPDiECpFev5OXQceVX4jc0kbTs0qKHT3rOVs3KFTrV4sx9BDI6R7uuSoIcLTsPme6UHOmjgLH+eNMdD/HTWEbNTXm1NPni8sWVEvW9YV5Cdgfn85PZxiIcV5p2NN/sJBRuKkbJxBucYzHceabz1SM26NFYi+0DxRcsrpoP8W/IBWbw2Bw6kImX00/fKeBjcwAU0hWbpFvIGfIHtc54z75bPX27jc9ed+n9Hwz3UC2gM6206BAMEONachA6AK3tuQxuqd1RtlJ+GCW1Q+tkm8lfM40t+87n5HbmXdZxPru909Tft9dBVLMY4Gm78DYlrUuFBCeLHRP6b1/rDndtNswZhJ+AAzpEWcCD1s0Vwk3gMfuaAmRfI0lv+nLrTRwllmbiJ7TMMxxAyBS+sc8OEZJRk746WTzXccMHjeB05PAf2UT+RoaQb7hd685sAilcxAAREr/qroihRiTIkwPvpV9oZOI7Jz7yUdFCOl94NlKolivzTkzzahWUas6HHTUirJsAELeLGTWskw4AfZSivmA4X/4pvGLNWaGkbbc3c7Q3V3W4Uyy0lE228kGSQ7isWwA8dNIb3G0ntJSShIyxL3OQK6U6Sf/eqmRX8PXelf1u4wNDflL5H/826GOdhIl5F4leDkYAiXJvQtZEMAQEE4K44jjOo4CfHPS0MksusyTtPRUtnN9OHWedJhTwHeXB8+Tr0CIAYlkTLpwIEBLuQgPvAPj5GWuEosuaeM1+XPdJc/+rane8IXiXmsIcMa3gv0gu2lQKaIgm6CYMbQXAVNHDB6yhGCT+M1mPThfts7aT9O+u+IVQDd74TKU6lTZlhSn9+CXFo88Vr8APw6Qc0uM+qin+LJkhB18Wz8Hd8QqbMfV94Xe6ZOz4wgyiXaDv2q5VzIMAB1+OL/1tYQ8IFDfzOM0jhhxGbPVAw2NKlczuVuhOrw+0BIvYfRCvTTy5DRzIArb/qX/W5iPZEI8mwIYAHoFswuHqDKoca2JgxfdEMAnLWcBBoETAeqbeUfnD4KkXSjBeAjGtnhk0jXdmh/od0DYzgFURodxY/tTkvgR3isoXwwwe/vv5+RuZBJVA2DN/wlfCNrBRm24ZLeQcPhn6GVNLxzDx2KVz4CUmrOoDDB40p8s9onAhA63BgNd/OD0yYLbxo62xN3b464vj/I7g9QCa7m2otFdNdKEUa6fL5M9ABIPrFkRPBDWepA6eQyn8YPV8YLJ+1tjzw55rdIt+gEmhbNmHsJZ4LJ06vvlL1gxDjkGAHLfTwOkcilm/FzfHjBYOtk+T87sl7XdD6xu0BMtpt4hXLkWlOGElfMmXZYGighV5XPe2vhBeB8q44z3NgH7VBGGITpJL9GQ0mTLlFm7DYcX+yC/QPlpzhYf8LhP+v4IEe3Xt0h95uoZls2rRnlSPiQcupR6Iu/H8B7AjpZA9bJIMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMTItMzFUMTI6NDQ6NTYtMDU6MDBEL5TZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTEyLTMxVDEyOjQ0OjU2LTA1OjAwNXIsZQAAADh0RVh0c3ZnOmJhc2UtdXJpAGZpbGU6Ly8vc3JjL2dyYXBoaWNzL3RhcmdldHMvZmRqdC9yZWR4LnN2Z3qXB16JAAAAAElFTkSuQmCC", makeDialog = Dialog;
    return Dialog.close = close_dialog, Dialog.alertBox = alertBox, fdjtUI.alertBox = alertBox, 
    Dialog.alert = alertfn, fdjtUI.alert = alertfn, fdjt.alert = alertfn, Dialog.setCountdown = setCountdown, 
    fdjtUI.setCountdown = setCountdown, Dialog.alertFor = alertFor, fdjtUI.alertFor = alertFor, 
    Dialog.message = message, fdjt.message = message, Dialog.Choice = choose, Dialog.choose = choose, 
    fdjtUI.choose = choose, fdjt.Choice = choose, fdjt.UI.Dialog = Dialog, Dialog;
}(), fdjt.UI || (fdjt.UI = {}), function() {
    "use strict";
    function Completions(dom, input, options) {
        return this.dom = dom || !1, this.input = input || !1, this.options = options || default_options, 
        this.nodes = [], this.values = [], this.serial = ++serial, this.cues = [], this.displayed = [], 
        this.known = {}, this.prefixtree = {
            strings: []
        }, this.bykey = {}, this.byvalue = new ValueMap(), this.selected = !1, this.selclass = !1, 
        options & FDJT_COMPLETE_MATCHCASE || (this.stringmap = {}), this.initialized = !1, 
        this;
    }
    function getKey(node) {
        return node.key || node.getAttribute("data-key") || node.getAttribute("key") || hasClass(node, "variation") && fdjtDOM.textify(node) || hasClass(node, "completion") && completionText(node, "");
    }
    function completionText(node, sofar) {
        if (3 === node.nodeType) return sofar + node.nodeValue;
        if (hasClass(node, "variation")) return sofar;
        if (hasClass(node, "fdjtskiptext")) return sofar;
        if (1 === node.nodeType && node.childNodes) {
            for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                3 === child.nodeType ? sofar += child.nodeValue : 1 === child.nodeType && (sofar = completionText(child, sofar));
            }
            return sofar;
        }
        return sofar;
    }
    function addNodeKey(node, keystring, ptree, bykey, anywhere) {
        for (var keys = (anywhere ? keystring.split(/\W/g) : []).concat(keystring), i = 0, lim = keys.length; lim > i; ) {
            var key = keys[i++];
            prefixAdd(ptree, key, 0), bykey[key] && bykey.hasOwnProperty(key) ? bykey[key].push(node) : bykey[key] = Array(node), 
            bykey._count++;
        }
    }
    function getNodes(string, ptree, bykey, matchcase) {
        var result = [], direct = [], variations = [], keystring = stdspace(string);
        if (isEmpty(keystring)) return [];
        matchcase || (keystring = string.toLowerCase());
        for (var strings = prefixFind(ptree, keystring, 0), prefix = !1, exact = [], exactheads = [], keys = [], i = 0, lim = strings.length; lim > i; ) {
            var s = strings[i++], isexact = s === keystring;
            prefix = prefix ? commonPrefix(prefix, s, !1, !matchcase) : s;
            var completions = bykey[s];
            if (completions) for (var j = 0, jlim = completions.length; jlim > j; ) {
                var c = completions[j++];
                if (hasClass(c, "hidden")) ; else if (result.indexOf(c) >= 0) ; else if (hasClass(c, "completion")) isexact && (exactheads.push(c), 
                exact.push(c)), result.push(c), keys.push(s), direct.push(c); else {
                    var head = getParent(c, ".completion");
                    head && hasClass(head, "hidden") || head && (isexact && exact.push(head), result.push(head), 
                    keys.push(s), variations.push(c));
                }
            }
        }
        return exact.length && (result.exact = exact), exactheads.length && (result.exactheads = exactheads), 
        result.prefix = prefix, result.strings = strings, result.matches = direct.concat(variations), 
        result;
    }
    function addCompletion(c, completion, key, value) {
        key === void 0 && (key = completion.key || getKey(completion)), value || (value = completion.value || completion.getAttribute("value") || key), 
        completion._seen || (c.nodes.push(completion), completion._seen = !0, value && (c.values.push(value), 
        c.byvalue.add(value, completion)), c.curstring = c.maxstring = !1, key && addCompletionKeys(c, completion, key));
    }
    function addCompletionKeys(c, completion, key) {
        key || (key = completion.key || getKey(completion));
        var lower, opts = c.options, container = c.dom, ptree = c.prefixtree, bykey = c.bykey, smap = c.stringmap, stdkey = stdspace(key), matchcase = opts & FDJT_COMPLETE_MATCHCASE, anyword = opts & FDJT_COMPLETE_ANYWORD;
        matchcase || (lower = stdkey.toLowerCase(), smap[lower] = stdkey, stdkey = lower), 
        getParent(completion, container) || fdjtDOM.append(container, completion, " "), 
        addNodeKey(completion, stdkey, ptree, bykey, anyword), hasClass(completion, "cue") && c.cues.push(completion);
        for (var variations = getChildren(completion, ".variation"), i = 0, lim = variations.length; lim > i; ) {
            var variation = variations[i++], vkey = stdspace(variation.key || getKey(variation));
            matchcase || (lower = vkey.toLowerCase(), smap[lower] = vkey, vkey = lower), addNodeKey(variation, vkey, ptree, bykey, anyword);
        }
    }
    function initCompletions(c) {
        for (var completions = getChildren(c.dom, ".completion"), i = 0, lim = completions.length; lim > i; ) addCompletion(c, completions[i++]);
        c.initialized = !0;
    }
    function updateDisplay(c, todisplay) {
        var i, lim, displayed = c.displayed;
        if (displayed) {
            for (i = 0, lim = displayed.length; lim > i; ) dropClass(displayed[i++], "displayed");
            c.displayed = displayed = [];
        } else c.displayed = displayed = [];
        if (todisplay) for (i = 0, lim = todisplay.length; lim > i; ) {
            var node = todisplay[i++];
            if (hasClass(node, "completion")) addClass(node, "displayed"), displayed.push(node); else {
                var head = getParent(node, ".completion");
                head && !hasClass(head, "displayed") && (displayed.push(node), displayed.push(head), 
                addClass(head, "displayed"), addClass(node, "displayed"));
            }
        }
        c.visible = !1, c.selection && !hasClass(c.selection, "displayed") && (c.selectNext() || c.selectPrevious() || c.clearSelection()), 
        c.updated && c.updated.call(c);
    }
    function stdspace(string) {
        return string.replace(/\s+/, " ").replace(/(^\s)|(\s$)/, "");
    }
    function gatherVisible(root) {
        for (var scan = root.firstChild, displayed = []; scan !== root; ) {
            if (1 === scan.nodeType) {
                var iscompletion = hasClass(scan, "completion");
                if (iscompletion && "none" !== getStyle(scan).display && displayed.push(scan), scan.firstChild && !iscompletion) {
                    scan = scan.firstChild;
                    continue;
                }
            }
            for (;scan !== root && !scan.nextSibling; ) scan = scan.parentNode;
            scan !== root && (scan = scan.nextSibling);
        }
        return displayed;
    }
    function onkey(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), name = target.name, completions = cached_completions[name], compid = fdjtDOM.getAttrib(target, "completions"), dom = compid && fdjtID(compid);
        dom && (completions && completions.dom === dom || (completions = new Completions(dom, target, default_options), 
        cached_completions[name] = completions), completions && completions.docomplete(target));
    }
    function update(evt) {
        if (evt = evt || window.event, "string" == typeof evt && (evt = fdjtID(evt)), evt) {
            var target = evt.nodeType ? evt : fdjtUI.T(evt), name = target.name, completions = cached_completions[name], compid = fdjtDOM.getAttrib(target, "completions"), dom = compid && fdjtID(compid);
            dom && (completions && completions.dom === dom || (completions = new Completions(dom, target, default_options), 
            cached_completions[name] = completions), completions && completions.docomplete(target));
        }
    }
    var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, RefDB = fdjt.RefDB, fdjtID = fdjt.ID, rAF = fdjtDOM.requestAnimationFrame, async = fdjt.async, serial = 0, FDJT_COMPLETE_OPTIONS = 1, FDJT_COMPLETE_CLOUD = 2, FDJT_COMPLETE_ANYWORD = 4, FDJT_COMPLETE_MATCHCASE = 8, FDJT_COMPLETE_EAGER = 16, default_options = FDJT_COMPLETE_OPTIONS | FDJT_COMPLETE_CLOUD | FDJT_COMPLETE_ANYWORD, complete_delay = 100, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getChildren = fdjtDOM.getChildren, getParent = fdjtDOM.getParent, getStyle = fdjtDOM.getStyle, position = RefDB.position, isEmpty = fdjtString.isEmpty, hasPrefix = fdjtString.hasPrefix, prefixAdd = fdjtString.prefixAdd, prefixFind = fdjtString.prefixFind, commonPrefix = fdjtString.commonPrefix;
    fdjtUI.FDJT_COMPLETE_OPTIONS = FDJT_COMPLETE_OPTIONS, fdjtUI.FDJT_COMPLETE_CLOUD = FDJT_COMPLETE_CLOUD, 
    fdjtUI.FDJT_COMPLETE_ANYWORD = FDJT_COMPLETE_ANYWORD, fdjtUI.FDJT_COMPLETE_MATCHCASE = FDJT_COMPLETE_MATCHCASE, 
    fdjtUI.FDJT_COMPLETE_EAGER = FDJT_COMPLETE_EAGER;
    var ValueMap = fdjt.Map || RefDB.Map;
    Completions.getKey = getKey, Completions.prototype.addCompletion = function(completion, key, value) {
        this.initialized || initCompletions(this), addCompletion(this, completion, key, value), 
        this.visible && (this.visible = !1);
    }, Completions.prototype.addKeys = function(completion, key) {
        this.initialized ? addCompletionKeys(this, completion, key) : (initCompletions(this), 
        addCompletion(this, completion, key)), this.visible && (this.visible = !1);
    }, Completions.prototype.getCompletions = function(string) {
        if (string === this.curstring || string === this.maxstring || this.curstring && this.maxstring && hasPrefix(string, this.curstring) && hasPrefix(this.maxstring, string)) return this.result;
        var result, that = this;
        if (this.initialized || initCompletions(this), isEmpty(string) ? (result = [], result.prefix = "", 
        result.matches = [], this.dom && addClass(this.dom, "noinput")) : (result = getNodes(string, this.prefixtree, this.bykey, this.options & FDJT_COMPLETE_MATCHCASE), 
        this.dom && dropClass(this.dom, "noinput"), rAF(function() {
            updateDisplay(that, result.matches);
        })), this.stringmap && this.strings) for (var stringmap = this.stringmap, strings = this.strings, i = 0, lim = strings.length; lim > i; ) {
            var s = strings[i], m = stringmap[s];
            m ? strings[i++] = m : i++;
        }
        return this.curstring = string, this.maxstring = result.prefix || string, this.result = result, 
        result;
    }, Completions.prototype.getValue = function(completion) {
        if (completion.value) return completion.value;
        if (completion.getAttribute("data-value")) return completion.getAttribute("data-value");
        if (completion.getAttribute("value")) return completion.getAttribute("value");
        var pos = position(this.nodes, completion);
        return 0 > pos ? !1 : this.values[pos];
    }, Completions.prototype.getKey = function(completion) {
        return completion.key ? completion.key : completion.getAttribute("data-key") ? completion.getAttribute("data-key") : completion.getAttribute("key") ? completion.getAttribute("key") : getKey(completion);
    }, Completions.prototype.complete = function(string, callback) {
        var that = this;
        if (this.initialized || initCompletions(this), string || "" === string || (string = this.getText ? this.getText(this.input) : hasClass(this.input, "isempty") ? "" : this.input.value), 
        isEmpty(string)) return rAF(function() {
            that.displayed && updateDisplay(that, !1), addClass(that.dom, "noinput"), dropClass(that.dom, "nomatches"), 
            callback && async(function() {
                callback([]);
            });
        }), [];
        var result = this.getCompletions(string);
        return result && 0 !== result.length ? (rAF(function() {
            updateDisplay(that, result.matches), dropClass(that.dom, "noinput"), dropClass(that.dom, "nomatches"), 
            callback && async(function() {
                callback(result);
            });
        }), result) : (rAF(function() {
            updateDisplay(that, !1), dropClass(that.dom, "noinput"), addClass(that.dom, "nomatches"), 
            callback && async(function() {
                callback(result);
            });
        }), []);
    }, Completions.prototype.getByValue = function(values, spec) {
        this.initialized || initCompletions(this);
        var result = [], byvalue = this.byvalue;
        spec && (spec = new fdjtDOM.Selector(spec)), values instanceof Array || (values = [ values ]);
        for (var i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) if (completions instanceof Array || (completions = [ completions ]), 
            spec) for (var j = 0, jlim = completions.length; jlim > j; ) spec.match(completions[j]) ? result.push(completions[j++]) : j++; else result = result.concat(completions);
        }
        return result;
    }, Completions.prototype.getByKey = function(keys, spec) {
        this.initialized || initCompletions(this);
        var result = [], bykey = this.bykey;
        spec && (spec = new fdjtDOM.Selector(spec)), keys instanceof Array || (keys = [ keys ]);
        for (var i = 0, lim = keys.length; lim > i; ) {
            var key = keys[i++], completions = bykey[key];
            if (completions) if (completions instanceof Array || (completions = [ completions ]), 
            spec) for (var j = 0, jlim = completions.length; jlim > j; ) spec.match(completions[j]) ? result.push(completions[j++]) : j++; else result = result.concat(completions);
        }
        return result;
    }, Completions.prototype.setCues = function(values, cueclass) {
        this.initialized || initCompletions(this), cueclass || (cueclass = "cue");
        for (var cues = [], byvalue = this.byvalue, i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) {
                completions instanceof Array || (completions = [ completions ]);
                for (var j = 0, jlim = completions.length; jlim > j; ) {
                    var c = completions[j++];
                    hasClass(c, cueclass) || (addClass(c, cueclass), cues.push(c));
                }
            }
        }
        return cues;
    }, Completions.prototype.setClass = function(values, classname) {
        this.initialized || initCompletions(this);
        var drop = fdjtDOM.getChildren(this.dom, ".completion." + classname);
        drop && drop.length && dropClass(fdjtDOM.Array(drop), "hidden");
        for (var changed = [], byvalue = this.byvalue, i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) {
                completions instanceof Array || (completions = [ completions ]);
                for (var j = 0, jlim = completions.length; jlim > j; ) {
                    var c = completions[j++];
                    hasClass(c, classname) || (addClass(c, classname), changed.push(c));
                }
            }
        }
        return changed;
    }, Completions.prototype.extendClass = function(values, classname) {
        this.initialized || initCompletions(this);
        for (var changed = [], byvalue = this.byvalue, i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) {
                completions instanceof Array || (completions = [ completions ]);
                for (var j = 0, jlim = completions.length; jlim > j; ) {
                    var c = completions[j++];
                    hasClass(c, classname) || (addClass(c, classname), changed.push(c));
                }
            }
        }
        return changed;
    }, Completions.prototype.dropClass = function(classname) {
        var drop = fdjtDOM.getChildren(this.dom, ".completion." + classname);
        drop && drop.length && dropClass(fdjtDOM.Array(drop), classname);
    }, Completions.prototype.docomplete = function(input, callback) {
        this.initialized || initCompletions(this), input || (input = this.input);
        var delay = this.complete_delay || complete_delay, that = this;
        this.timer && (clearTimeout(that.timer), that.timer = !1), this.timer = setTimeout(function() {
            input || (input = that.input);
            var completions = that.complete(input.value);
            callback && callback(completions);
        }, delay);
    }, fdjtUI.Completions = Completions;
    var Selector = fdjtDOM.Selector;
    Completions.prototype.getVisible = function() {
        if (this.visible) return this.visible;
        var visible = this.visible = gatherVisible(this.dom);
        return visible;
    }, Completions.prototype.select = function(completion) {
        var pref = !1, displayed = this.getVisible();
        if (completion instanceof Selector && (pref = completion, completion = !1), !completion && pref) for (var nodes = displayed, i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++];
            if (hasClass(node, pref)) {
                completion = node;
                break;
            }
        }
        return !completion && displayed.length && (completion = displayed[0]), this.selection && dropClass(this.selection, "selected"), 
        addClass(completion, "selected"), this.selection = completion, completion;
    }, Completions.prototype.selectNext = function(selection) {
        selection || (selection = this.selection ? this.selection : !1);
        for (var nodes = this.getVisible(), dflt = !1, found = !1, i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++];
            if (dflt || (dflt = node), !selection) {
                selection = node;
                break;
            }
            node === selection && (selection = !1, found = !0);
        }
        return this.selection && dropClass(this.selection, "selected"), found || (selection = dflt), 
        addClass(selection, "selected"), this.selection = selection, selection;
    }, Completions.prototype.selectPrevious = function(selection) {
        selection || (selection = this.selection ? this.selection : !1);
        for (var nodes = this.getVisible(), dflt = !1, found = !1, i = nodes.length - 1; i >= 0; ) {
            var node = nodes[i--];
            if (dflt || (dflt = node), !selection) {
                selection = node;
                break;
            }
            node === selection && (selection = !1, found = !0);
        }
        return this.selection && dropClass(this.selection, "selected"), found || (selection = dflt), 
        selection && addClass(selection, "selected"), this.selection = selection, selection;
    }, Completions.prototype.clearSelection = function(selection) {
        if (selection && this.selection && selection !== this.selection) return !1;
        if (this.selection) return dropClass(this.selection, "selected"), this.selection = !1, 
        !0;
    };
    var cached_completions = {};
    fdjtUI.Completions.onkey = onkey, fdjtUI.Completions.update = update;
}(), fdjt.UI || (fdjt.UI = {}), fdjt.TapHold = fdjt.UI.TapHold = function() {
    "use strict";
    function xyd(x0, y0, x1, y1) {
        return "number" == typeof x0 && "number" == typeof y0 && "number" == typeof x1 && "number" == typeof y1 ? sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1)) : !1;
    }
    function getClientX(evt, x, y) {
        if ("number" == typeof evt.clientX) return evt.clientX;
        var touches = evt.changedTouches && evt.changedTouches.length && evt.changedTouches || evt.touches && evt.touches.length && evt.touches, winxoff = window.pageXOffset, winyoff = window.pageYOffset;
        if (touches && touches.length) {
            if (1 === touches.length || "number" != typeof x || "number" != typeof y) return touches[0].pageX - winxoff;
            for (var i = 1, lim = touches.length, tch = touches[0], d = xyd(Math.abs(tch.pageX - winxoff), Math.abs(tch.pageY - winyoff), x, y), d_min = d, touch = tch; lim > i; ) tch = touches[i++], 
            d = xyd(Math.abs(tch.pageX - winxoff), Math.abs(tch.pageY - winyoff), x, y), d_min > d && (touch = tch, 
            d_min = d);
            return touch.pageX - winxoff;
        }
        return !1;
    }
    function getClientY(evt, x, y) {
        if ("number" == typeof evt.clientY) return evt.clientY;
        var touches = evt.changedTouches && evt.changedTouches.length && evt.changedTouches || evt.touches && evt.touches.length && evt.touches, winxoff = window.pageXOffset, winyoff = window.pageYOffset;
        if (touches && touches.length) {
            if (1 === touches.length || "number" != typeof x || "number" != typeof y) return touches[0].pageY - winyoff;
            for (var i = 1, lim = touches.length, tch = touches[0], d = Math.abs(Math.abs(tch.pageX - winxoff) - x) + Math.abs(Math.abs(tch.pageY - winyoff) - y), d_min = d, touch = tch; lim > i; ) tch = touches[i++], 
            d = Math.abs(Math.abs(tch.pageX - winxoff) - x) + Math.abs(Math.abs(tch.pageY - winyoff) - y), 
            d_min > d && (touch = tch, d_min = d);
            return touch.pageY - winyoff;
        }
        return !1;
    }
    function synthesizeEvent(target, etype, th, orig, tx, ty, tn, also) {
        var thid = th.id || typeof th, trace = th.traced, handlers = th.handlers, orig_target = orig && eTarget(orig);
        target || (target = orig_target);
        var evt = document.createEvent("UIEvent"), event_arg = orig && orig.touches && orig.touches.length || orig && orig.button || 0;
        if (evt.initUIEvent(etype, !0, !0, window, event_arg), evt.clientX = tx, evt.clientY = ty, 
        evt.ntouches = tn || 1, also) for (var prop in also) also.hasOwnProperty(prop) && (evt[prop] = also[prop]);
        (trace || traceall) && (also && "number" == typeof also.startX ? fdjtLog("TapHold/%s(%s) on %o @%d,%d/%d,%d from %o given %j", etype, thid, target, tx, ty, also.startX, also.startY, orig || "scratch", also) : also ? fdjtLog("TapHold/%s(%s) on %o @%d,%d from %o given %j", etype, thid, target, tx, ty, orig || "scratch", also) : fdjtLog("TapHold/%s(%s) on %o @%d,%d from %j", etype, thid, target, tx, ty, orig || "scratch")), 
        target && hasParent(target, document.body) || (target = document.elementFromPoint(tx, ty)), 
        handlers && handlers.hasOwnProperty(etype) ? (evt.target = target, handlers[etype](evt, target)) : target.dispatchEvent(evt);
    }
    function getRealTarget(holder, touchable, x, y) {
        for (var children = getChildren(holder, touchable), i = 0, lim = children.length; lim > i; ) {
            var child = children[i++], left = child.offsetLeft, top = child.offsetTop, right = child.offsetRight, bot = child.offsetBottom;
            if ("number" == typeof left && (1 >= right - left ? x >= left && right >= y : x >= left && right > y) && (1 >= bot - top ? y >= top && bot >= y : x >= top && bot > y)) return child;
        }
        return !1;
    }
    function global_mouseup(evt) {
        evt = evt || window.event, traceall && fdjtLog("TapHold/global/mouseup %o", evt), 
        1 === evt.button && (mouse_down = !1);
    }
    function global_mousedown(evt) {
        evt = evt || window.event, traceall && fdjtLog("TapHold/global/mousedown %o", evt), 
        1 === evt.button && (mouse_down = !0);
    }
    function global_mouseout(evt) {
        evt = evt || window.event;
        var target = eTarget(evt), rel = evt.relatedTarget || evt.toElement;
        traceall > 2 && fdjtLog("TapHold/global/mouseout %o %o==>%o", evt, target, rel), 
        target === document.documentElement && (mouse_down = !1);
    }
    function traceValue(classname) {
        var parsed = /\bfdjtlog(\d*)/.exec(classname);
        if (parsed && parsed.length) {
            var level = "string" == typeof parsed[1] && parseInt(parsed[1], 10);
            return level && !isNaN(level) ? level : 1;
        }
        return 0;
    }
    function initSound(name, th, opts, elt) {
        var found = th[name] || opts && opts[name] || elt.getAttribute("data-" + name) || TapHold[name];
        return found && (th[name] = found), found;
    }
    function playSound(name, evt, th) {
        var target = evt.nodeType && evt || fdjtUI.T(evt);
        if (th.mute || TapHold.mute || hasClass(target, "fdjtmute") || hasClass(th.container, "fdjtmute")) return !1;
        var sound = target.getAttribute("data-" + name) || th[name];
        "string" == typeof sound && (sound = document.getElementById(sound)), sound && sound.play();
    }
    function TapHold(elt, opts) {
        function start_holding() {
            var parents = getParents(elt, ".tapholdcontext");
            parents && parents.length && (addClass(parents, holdclass), drop_holding = parents), 
            addClass(elt, holdclass);
        }
        function stop_holding() {
            drop_holding && drop_holding.length && (dropClass(drop_holding, holdclass), drop_holding = !1), 
            dropClass(elt, holdclass);
        }
        function check_holding() {
            th_target || dropClass(elt, holdclass);
        }
        function cleartouch(all) {
            th_timer && (clearTimeout(th_timer), th_timer = !1), all && tt_timer && (clearTimeout(tt_timer), 
            tt_timer = !1), th_target && touchclass && dropClass(th_target, touchclass), th_target = th_target_t = !1, 
            th_targets = [], swipe_t = start_x = start_y = start_t = touch_x = touch_y = touch_t = touch_n = target_x = target_y = target_t = !1, 
            no_swipe = !1, touched = pressed = pressed_at = !1;
        }
        function synthEvent(target, etype, th, orig, tx, ty, also) {
            return synthesizeEvent(target, etype, th, orig, tx, ty, touch_n, also);
        }
        function setTarget(t) {
            (trace > 2 || traceall > 2 || t !== th_target && (trace || traceall)) && fdjtLog("TapHold/setTarget(%s) %o cur=%o", thid, t, th_target), 
            th_target && th_target !== t && touchclass && dropClass(th_target, "tapholdtarget"), 
            t && touchclass && addClass(t, "tapholdtarget"), t && th_target && t !== th_target && (target_x = touch_x, 
            target_y = touch_y, target_t = touch_t), th_last = th_target, th_target = t, th_target_t = fdjtET();
        }
        function tapped(target, evt, x, y) {
            return x === void 0 && (x = touch_x), y === void 0 && (y = touch_y), playSound("tapsound", target, th), 
            synthEvent(target, "tap", th, evt, x, y, !1);
        }
        function held(target, evt, x, y) {
            return x === void 0 && (x = touch_x), y === void 0 && (y = touch_y), no_swipe = !0, 
            playSound("holdsound", target, th), holdclass && setTimeout(start_holding, 20), 
            synthEvent(target, "hold", th, evt, x, y, !1);
        }
        function released(target, evt, x, y) {
            var target_time = th_target_t && th_last && fdjtET() - th_target_t;
            x === void 0 && (x = touch_x), y === void 0 && (y = touch_y), playSound("releasesound", target, th);
            var point_target = document.elementFromPoint(x, y);
            return point_target && (point_target = getParent(point_target, touchable)), point_target && point_target !== target && hasParent(point_target, target) && (target = point_target), 
            holdclass && setTimeout(check_holding, 50), target_time && 200 > target_time && (trace && fdjtLog("TapHold(%s) %d=i<200ms, target=%o not %o", thid, target_time, th_last, target), 
            target = th_last), synthEvent(target, "release", th, evt, x, y, {
                startX: start_x,
                startY: start_y
            });
        }
        function slipped(target, evt, also) {
            if (also ? (also.startX = start_x, also.startY = start_y) : also = {
                startX: start_x,
                startY: start_y
            }, evt && !also.hasOwnProperty("relatedTarget")) {
                var rel = evt.relatedTarget;
                rel !== target && (also.relatedTarget = rel);
            }
            return playSound("slipsound", target, th), holdclass && setTimeout(check_holding, 50), 
            synthEvent(target, "slip", th, evt, touch_x, touch_y, also);
        }
        function taptapped(target, evt) {
            return playSound("taptapsound", target, th), synthEvent(target, "taptap", th, evt, touch_x, touch_y, !1, trace);
        }
        function swiped(target, evt, sx, sy, cx, cy) {
            var dx = cx - sx, dy = cy - sy;
            return swipe_t = fdjtET(), playSound("swipesound", target, th), synthEvent(target, "swipe", th, evt, cx, cy, {
                startX: sx,
                startY: sy,
                endX: cx,
                endY: cy,
                deltaX: dx,
                deltaY: dy
            });
        }
        function startpress(evt, to) {
            if (to || (to = holdmsecs || TapHold.interval || 100), evt = evt || window.event, 
            (trace > 1 || traceall > 1) && fdjtLog("TapHold/startpress(%s) %o tht=%o timer=%o tt=%o touched=%o pressed=%o@%o timeout=%oms", thid, evt, th_target, th_timer, tap_target, touched, pressed, pressed_at, to), 
            tap_target && th_timer && (clearTimeout(th_timer), th_timer = !1), tap_target && tt_timer) return clearTimeout(tt_timer), 
            tt_timer = !1, taptapped(tap_target, evt), cleartouch(!0), void 0;
            if (!(touched || pressed || th_timer)) {
                if (!th_target) return swipe_t = !1, void 0;
                touched = th_target, pressed = !1, swipe_t = !1, reticle.live && reticle.highlight(!0), 
                pressed_at = fdjtET(), th_timer && clearTimeout(th_timer), th_timer = setTimeout(function() {
                    if ((trace > 1 || traceall > 1) && fdjtLog("TapHold/startpress/timeout(%s) (%dms) %o", thid, to, evt), 
                    th_targets.length > 0) for (var targets = th_targets, i = 0, lim = targets.length; lim > i; ) {
                        var elt = targets[i++];
                        if (i === lim && elt === th_target) break;
                        held(elt), noslip || (lim > i ? slipped(elt, evt, {
                            relatedTarget: targets[i]
                        }) : slipped(elt, evt));
                    }
                    pressed = th_target, th_targets = [], pressed_at = th_target ? fdjtET() : !1, held(th_target, evt), 
                    th_timer && clearTimeout(th_timer), th_timer = !1, touched = !1;
                }, to);
            }
        }
        function endpress(evt) {
            if ((trace > 1 || traceall > 1) && fdjtLog("TapHold/endpress(%s) %o t=%o p=%o tch=%o tm=%o ttt=%o/%o, start=%d,%d,%d/%d", thid, evt, th_target, pressed, touched, th_timer, tap_target, taptapmsecs, start_x, start_y, start_t, fdjtET()), 
            !pressed && !touched && !th_timer) return cleartouch(!0), void 0;
            var x = touch_x, y = touch_y;
            if (th_timer) clearTimeout(th_timer), th_timer = !1, reticle.live && setTimeout(function() {
                reticle.highlight(!1);
            }, 1500), th_target === touched || holdmsecs / 1e3 > fdjtET() - start_t ? (tap_target = th_target, 
            taptapmsecs && taptapmsecs > 0 ? tt_timer = setTimeout(function() {
                tt_timer = !1, tapped(tap_target, evt, x, y);
            }, taptapmsecs) : tapped(th_target, evt, x, y)) : noslip || slipped(th_target, evt); else if (pressed) {
                var geom = fdjtDOM.getGeometry(elt);
                0 === x && 0 === y || x >= geom.left && geom.right >= x && y >= geom.top && geom.bottom >= y ? released(pressed, evt, x, y) : noslip ? released(pressed, evt, x, y) : slipped(th_target, evt, {
                    touch_x: x,
                    touch_y: y
                });
            }
            reticle.live && reticle.highlight(!1), cleartouch(), setTarget(!1), holdclass && setTimeout(stop_holding, 20), 
            th_targets = [];
        }
        function abortpress(evt, why) {
            (trace || traceall) && fdjtLog("TapHold/abort%s(%s) %o: th=%o t=%o p=%o", why ? "(" + why + ")" : "", thid, evt, th_target, touched, pressed), 
            th_timer ? (clearTimeout(th_timer), th_timer = !1) : noslip || pressed && slipped(pressed, evt, {
                relatedTarget: !1
            }), reticle.live && reticle.highlight(!1), pressed_at = touched = pressed = tap_target = !1, 
            holdclass && setTimeout(stop_holding, 20), th_targets = [], setTarget(!1);
        }
        function taphold_mouseout(evt) {
            evt = evt || window.event;
            var to = evt.toElement || evt.relatedTarget;
            wander_timer || th_target && pressed && !hasParent(to, elt) && (wander_timer = setTimeout(wandered, wanderthresh, evt, to));
        }
        function wandered(evt, to) {
            noslip || slipped(pressed, evt, {
                relatedTarget: to
            }), abortpress(evt, "taphold_mouseout");
        }
        function taphold_mouseover(evt) {
            evt = evt || window.event, wander_timer && (clearTimeout(wander_timer), wander_timer = !1);
        }
        function taphold_move(evt) {
            evt = evt || window.event;
            var target, n_touches = evt.touches && evt.touches.length || 1;
            if (bubble || noBubble(evt), override && noDefault(evt), scrolling && evt.touches && maxtouches >= evt.touches.length && (scroll_x >= 0 && (scrolling.scrollLeft = scroll_x - (evt.touches[0].pageX - window.pageXOffset)), 
            scroll_y >= 0 && (scrolling.scrollTop = scroll_y - (evt.touches[0].pageY - window.pageYOffset))), 
            pressed && cleared > start_t) return abortpress(evt, "move/cleared"), void 0;
            if ((touched || pressed) && !mouse_down) return abortpress(evt, "move/up"), void 0;
            var x = evt.clientX || getClientX(evt, touch_x, touch_y), y = evt.clientY || getClientY(evt, touch_x, touch_y);
            reticle.live && reticle.onmove(evt, x, y);
            var distance = pressed ? xyd(x, y, target_x, target_y) : xyd(x, y, start_x, start_y);
            if (evt.touches || hot_xoff || hot_yoff ? (x += hot_xoff, y += hot_yoff, target = document.elementFromPoint(x, y)) : target = eTarget(evt), 
            !target || !isTextInput(target)) {
                var delta = Math.abs(x - touch_x) + Math.abs(y - touch_y), dt = fdjtET() - touch_t;
                if ((trace > 2 || traceall > 2) && fdjtLog("TapHold/move(%s) s=%d,%d tt=%d,%d t=%d,%d c=%d,%d d=%d thresh=%o, dt=%o md=%o, pressed=%o, touched=%o, event=%o target=%o", thid, start_x, start_y, target_x, target_y, touch_x, touch_y, x, y, distance, movethresh, dt, mouse_down, pressed, touched, evt, target), 
                !target) return touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                var holder = getParent(target, ".tapholder");
                if (holder !== elt) return (trace > 2 || traceall > 2) && trace_ignore_move(evt, thid, elt, holder, th_target, target, start_x, start_y, target_x, target_y, touch_x, touch_y), 
                th_target && ((trace || traceall) && fdjtLog("setWanderTimeout(%s): h=%o!=elt=%o", thid, holder, elt), 
                wander_timer = setTimeout(function() {
                    abortpress(evt, "taphold_wander_timeout");
                }, wanderthresh), pressed && (noslip || slipped(pressed, evt, {
                    relatedTarget: !1
                }), setTarget(!1))), void 0;
                if (wander_timer && (clearTimeout(wander_timer), wander_timer = !1, (trace > 2 || traceall > 2) && fdjtLog("Wander return(%s) %o pressed=%o, target=%o", thid, evt, pressed, th_target), 
                pressed && !th_target && (setTarget(pressed), held(pressed, evt))), !touched && !pressed) return !swipe_t && !no_swipe && min_swipe > 0 && xyd(start_x, start_y, x, y) > min_swipe && swiped(target, evt, start_x, start_y, x, y), 
                touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                if (movethresh && th_timer && distance > movethresh) return (trace > 1 || traceall > 1) && fdjtLog("TapHold/move/cancel(%s) s=%d,%d tt=%d,%d t=%d,%d c=%d,%d d=%d thresh=%o, dt=%o md=%o, event=%o", thid, start_x, start_y, target_x, target_y, touch_x, touch_y, x, y, distance, movethresh, dt, mouse_down, evt), 
                abortpress(evt, "movefar"), th_timer && clearTimeout(th_timer), pressed_at = touched = th_timer = pressed = !1, 
                th_targets = [], !swipe_t && !no_swipe && min_swipe > 0 && xyd(start_x, start_y, x, y) > min_swipe && swiped(target, evt, start_x, start_y, x, y), 
                setTarget(!1), touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                if (10 * minmove > delta && dt > 0 && minmove > delta / dt) return (trace > 2 || traceall > 2) && fdjtLog("TapHold/move/ignore(%s) s=%d,%d t=%d,%d c=%d,%d dt=%o total=%d/%o, local=%d/%o/%o, thresh=%o md=%o", thid, start_x, start_y, touch_x, touch_y, x, y, dt, distance, movethresh, delta, delta / dt, minmove, mouse_down), 
                touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                (trace > 2 || traceall > 2) && fdjtLog("TapHold/move(%s) s=%d,%d t=%d,%d c=%d,%d dt=%o total=%d/%o, local=%d/%o/%o, md=%o", thid, start_x, start_y, touch_x, touch_y, x, y, dt, distance, movethresh, delta, minmove, delta / dt, mouse_down), 
                touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                target = getParent(target, touchable), evt.touches && evt.touches.length && evt.touches.length > maxtouches || (target || (target = getRealTarget(elt, touchable, touch_x, touch_y)), 
                target && (hasParent(target, ".tapholder") && !noslip && setTarget(target), evt.touches && touched && !pressed && th_targets[th_targets.length - 1] !== th_target && th_targets.push(th_target), 
                mouse_down ? pressed && th_target !== pressed && !hasParent(th_target, pressed) && !hasParent(pressed, th_target) && noslip ? ((trace > 1 || traceall > 1) && fdjtLog("TapHold/move(%s) endpress pressed=%o tt=%o %o", thid, pressed, th_target, evt), 
                endpress(evt)) : pressed && th_target !== pressed && (noslip || slipped(pressed, evt, {
                    relatedTarget: target
                }), pressed = th_target, pressed_at = pressed ? fdjtET() : !1, held(pressed)) : (noslip || slipped(pressed, evt, {
                    relatedTarget: target
                }), pressed_at = pressed = !1)));
            }
        }
        function trace_ignore_move(evt, thid, elt, holder, th_target, target, start_x, start_y, target_x, target_y, touch_x, touch_y) {
            fdjtLog("TapHold/move%s/farout(%s) %o %o -> %o s=%d,%d tt=%d,%d t=%d,%d", mouse_down ? "/md" : "", thid, evt, th_target, target, start_x, start_y, target_x, target_y, touch_x, touch_y), 
            fdjtLog("TapHold/move/farout(%s) target in %o, elt is %o", thid, holder, elt);
        }
        function taphold_down(evt, holdmsecs) {
            if (evt = evt || window.event, !(evt.ctrlKey || evt.altKey || evt.metaKey || evt.button || evt.which && evt.which > 1)) {
                var n_touches = evt.touches && evt.touches.length || 1;
                mouse_down = !0, cleared = 0, touch_x = (evt.clientX || getClientX(evt) || touch_x) + hot_xoff, 
                touch_y = (evt.clientY || getClientY(evt) || touch_y) + hot_yoff, start_x = target_x = touch_x, 
                start_y = target_y = touch_y, target_t = touch_t = fdjtET();
                var target = hot_xoff || hot_yoff ? document.elementFromPoint(touch_x, touch_y) : eTarget(evt);
                if (!target || !isTextInput(target)) {
                    touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, bubble || noBubble(evt), 
                    override && noDefault(evt);
                    var new_event = !1, holder = getParent(target, ".tapholder");
                    if ((trace > 1 || traceall > 1) && fdjtLog("TapHold/down(%s) %o tht=%o target=%o holder=%o elt=%o", thid, evt, th_target, target, holder, elt), 
                    holder !== elt) return (trace > 1 || traceall > 1) && fdjtLog("TapHold/ignore(%s) %o tht=%o t=%o h=%o elt=%o", thid, evt, th_target, target, holder, elt), 
                    void 0;
                    if (target && (target = getParent(target, touchable)), scrolling && evt.touches && maxtouches >= evt.touches.length && (scroll_x >= 0 && (scroll_x = scrolling.scrollLeft + (evt.touches[0].pageX - window.pageXOffset)), 
                    scroll_y >= 0 && (scroll_y = scrolling.scrollLeft + (evt.touches[0].pageY - window.pageYOffset))), 
                    evt.touches && (target = document.elementFromPoint(touch_x, touch_y)), (trace > 1 || traceall > 1) && fdjtLog("TapHold/down2(%s) %o tht=%o trg=%o s=%o,%o,%o t=%o,%o m=%o tch=%o prs=%o ttt=%o", thid, evt, th_target, target, start_x, start_y, start_t, touch_x, touch_y, mouse_down, touched, pressed, taptapmsecs || !1), 
                    evt.touches && th_target) {
                        var cur_holder = getParent(elt, ".tapholder"), touch = evt.changedTouches[0];
                        if ((trace > 1 || traceall > 1) && fdjtLog("TapHold(%s) second touch on %o (in %o) after %o (in %o)", thid, target, holder, th_target, cur_holder, cur_holder === holder), 
                        touchtoo && cur_holder === holder) return (trace > 1 || traceall > 1) && fdjtLog("TapHold(%s) touchtoo with touchtoo on %o after %o: %o", thid, target, th_target, evt), 
                        touchtoo.call ? (touchtoo.call(th, evt), void 0) : (new_event = document.createEvent("UIEvent"), 
                        new_event.initUIEvent("touchtoo", !0, !0, window, 0), new_event.screenX = touch.screenX, 
                        new_event.screenY = touch.screenY, new_event.clientX = touch.clientX, new_event.clientY = touch.clientY, 
                        new_event.ctrlKey = evt.ctrlKey, new_event.altKey = evt.altKey, new_event.shiftKey = evt.shiftKey, 
                        new_event.metaKey = evt.metaKey, new_event.touches = document.createTouchList(touch), 
                        new_event.targetTouches = document.createTouchList(touch), new_event.changedTouches = document.createTouchList(touch), 
                        target.dispatchEvent(new_event), void 0);
                        cur_holder && holder && cur_holder !== holder && ((trace > 1 || traceall > 1) && fdjtLog("TapHold(%s) Clearing on %o, moving %o to %o", thid, th_target, evt, target), 
                        new_event = document.createEvent("TouchEvent"), new_event.initTouchEvent(evt.type, !0, !0, window, null, touch.screenX, touch.screenY, touch.clientX, touch.clientY, evt.ctrlKey, evt.altKey, evt.shiftKey, evt.metaKey, document.createTouchList(touch), document.createTouchList(touch), document.createTouchList(touch)));
                    }
                    if (new_event) return abortpress(evt, "down/touch2"), target.dispatchEvent(new_event), 
                    void 0;
                    setTarget(target), th_targets = [], start_t = fdjtET(), (trace > 1 || traceall > 1) && fdjtLog("TapHold/down3(%s) %o t=%o x=%o y=%o t=%o touched=%o", thid, evt, th_target, start_x, start_y, start_t, touched), 
                    untouchable && untouchable(evt) || touched || startpress(evt, holdmsecs);
                }
            }
        }
        function taphold_up(evt) {
            if (evt = evt || window.event, mouse_down = !1, cleared > start_t) return abortpress(evt, "up"), 
            void 0;
            var target = eTarget(evt);
            if (!target || !isTextInput(target)) {
                bubble || noBubble(evt), override && noDefault(evt);
                var holder = getParent(target, ".tapholder");
                if (holder !== elt) return (trace > 1 || traceall > 1) && fdjtLog("TapHold/up/ignore(%s) %o tht=%o target=%o holder=%o elt=%o", thid, evt, th_target, target, holder, elt), 
                void 0;
                if (target && (target = getParent(target, touchable)), touch_x = (evt.clientX || getClientX(evt) || touch_x) + hot_xoff, 
                touch_y = (evt.clientY || getClientY(evt) || touch_y) + hot_yoff, touch_t = fdjtET(), 
                (!target || hot_xoff || hot_yoff) && (target = getRealTarget(elt, touchable, touch_x, touch_y)), 
                (trace > 1 || traceall > 1) && fdjtLog("TapHold/up(%s) %o tht=%o d=%o s=%o,%o,%o t=%o,%o m=%o touched=%o pressed=%o ttt=%o swipe_t=%o", thid, evt, th_target, xyd(start_x, start_y, touch_x, touch_y), start_x, start_y, start_t, touch_x, touch_y, mouse_down, touched, pressed, taptapmsecs, swipe_t), 
                !(evt.changedTouches && evt.changedTouches.length && evt.changedTouches.length > maxtouches)) {
                    var swipe_len = swipe_t ? 0 : xyd(start_x, start_y, touch_x, touch_y);
                    if (touched || pressed) {
                        if (untouchable && untouchable(evt)) return;
                        endpress(evt);
                    } else !(min_swipe > 0 && swipe_len > min_swipe) || no_swipe || touched && touched === elt || pressed && pressed === elt ? (touched || pressed) && (untouchable && untouchable(evt) || endpress(evt)) : swiped(target, evt, start_x, start_y, touch_x, touch_y);
                    cleartouch();
                }
            }
        }
        function taphold_cancel(evt) {
            (trace || traceall) && fdjtLog("TapHold/cancel(%s) %o: th=%o t=%o p=%o", thid, evt, th_target, touched, pressed), 
            th_timer ? (clearTimeout(th_timer), th_timer = !1) : pressed && released(pressed, evt), 
            reticle.live && reticle.highlight(!1), pressed_at = touched = pressed = tap_target = !1, 
            holdclass && setTimeout(stop_holding, 20), th_targets = [], setTarget(!1);
        }
        if (!elt) return fdjtLog.warn("TapHold with no argument!"), void 0;
        if (!(this instanceof TapHold)) return new TapHold(elt, opts);
        var th = this, holdclass = "tapholding", touchclass = "tapholdtarget", touched = !1, pressed = !1, pressed_at = !1, th_timer = !1, tt_timer = !1, th_target = !1, th_targets = [], tap_target = !1, th_target_t = !1, th_last = !1, fortouch = !1, noslip = !1, bubble = !1, override = !1, maxtouches = 1, touchtoo = !1, holdmsecs = !1, taptapmsecs = !1, movethresh = !1, wanderthresh = !1, min_swipe = 30, no_swipe = !1, scrolling = !1, scroll_x = 0, scroll_y = 0, start_x = !1, start_y = !1, start_t = !1, touch_x = !1, touch_y = !1, touch_t = 0, touch_n = !1, target_x = !1, target_y = !1, target_t = !1, swipe_t = !1, minmove = 2, hot_xoff = 0, hot_yoff = 0, trace = 0, serial = serial_count++, thid = opts && opts.id ? opts.id + ":" + serial : elt.id ? "#" + elt.id + ":" + serial : "" + serial;
        th.id = thid;
        var drop_holding = [], getParents = fdjtDOM.getParents;
        initSound("tapsound", th, opts, elt), initSound("holdsound", th, opts, elt), initSound("releasesound", th, opts, elt), 
        initSound("slipsound", th, opts, elt), initSound("taptapsound", th, opts, elt), 
        initSound("swipesound", th, opts, elt);
        var touchable = elt.getAttribute("data-touchable");
        touchable = opts && opts.hasOwnProperty("touchable") ? "string" == typeof opts.touchable ? fdjtDOM.Selector(opts.touchable) : opts.touchable : touchable ? fdjtDOM.Selector(touchable) : function(e) {
            return hasParent(e, elt);
        };
        var untouchable, isClickable = fdjtUI.isClickable;
        if (opts && opts.hasOwnProperty("untouchable")) if ("string" == typeof opts.untouchable) {
            var notouch = fdjtDOM.Selector(opts.untouchable);
            untouchable = function(e) {
                return e.nodeType ? notouch.match(e) : notouch.match(eTarget(e));
            };
        } else untouchable = opts.untouchable; else untouchable = function(e) {
            return isClickable(e);
        };
        if (opts && opts.noslip && (noslip = opts.noslip), opts && opts.touch_xoff && (hot_xoff = opts.touch_xoff), 
        opts && opts.touch_yoff && (hot_yoff = opts.touch_yoff), opts && opts.hasOwnProperty("trace")) {
            var opt_val = opts.trace;
            trace = "number" == typeof opt_val ? opt_val : opt_val ? 2 : 0;
        } else trace = hasClass(elt, /\bfdjtlog\d*/g) ? traceValue(elt.className) : 0;
        var wander_timer = !1;
        return opts ? opts.hasOwnProperty || (opts = {
            touch: !0
        }) : opts = {}, fortouch = opts.hasOwnProperty("fortouch") ? opts.fortouch : default_opts.hasOwnProperty("fortouch") ? default_opts.fortouch : !1, 
        holdmsecs = opts.hasOwnProperty("holdmsecs") ? opts.holdmsecs : default_opts.hasOwnProperty("holdmsecs") ? default_opts.holdmsecs : 150, 
        movethresh = opts.hasOwnProperty("movethresh") ? opts.movethresh : default_opts.hasOwnProperty("movethresh") ? default_opts.movethresh : 20, 
        taptapmsecs = opts.hasOwnProperty("taptapmsecs") && opts.taptapmsecs, wanderthresh = opts.hasOwnProperty("wanderthresh") ? opts.wanderthresh : default_opts.hasOwnProperty("wanderthresh") ? default_opts.wanderthresh : 2e3, 
        override = opts.hasOwnProperty("override") ? opts.override : default_opts.hasOwnProperty("override") ? default_opts.override : !1, 
        touchtoo = opts.hasOwnProperty("touchtoo") ? opts.touchtoo : default_opts.hasOwnProperty("touchtoo") ? default_opts.touchtoo : !1, 
        min_swipe = opts.hasOwnProperty("minswipe") ? opts.minswipe : default_opts.hasOwnProperty("minswipe") ? default_opts.minswipe : 30, 
        bubble = opts.hasOwnProperty("bubble") ? opts.bubble : default_opts.hasOwnProperty("bubble") ? default_opts.bubble : !1, 
        maxtouches = opts.hasOwnProperty("maxtouches") ? opts.maxtouches : default_opts.hasOwnProperty("maxtouches") ? default_opts.maxtouches : 1, 
        taptapmsecs && "number" != typeof taptapmsecs && (taptapmsecs = default_opts.taptapmsecs || 200), 
        scrolling = opts.hasOwnProperty("scrolling") ? opts.touch : !1, scrolling && (scrolling.nodeType || (scrolling = elt), 
        scroll_x = (opts.hasOwProperty("scrollx") ? opts.scrollx : !1) ? 0 : -1, scroll_y = (opts.hasOwProperty("scrolly") ? opts.scrolly : !0) ? 0 : -1), 
        opts.hasOwnProperty("holdclass") ? holdclass = opts.holdclass : default_opts.hasOwnProperty("holdclass") && (holdclass = default_opts.holdclass), 
        opts.hasOwnProperty("touchclass") ? touchclass = opts.touchclass : default_opts.hasOwnProperty("touchclass") && (touchclass = default_opts.touchclass), 
        minmove = opts.hasOwnProperty("minmove") ? opts.minmove : default_opts.hasOwnProperty("minmove") ? default_opts.minmove : fortouch ? 2 : 0, 
        opts.hasOwnProperty("handlers") && (this.handlers = opts.handlers), addClass(elt, "tapholder"), 
        fortouch || fdjtDOM.addListener(elt, "mousemove", taphold_move), fdjtDOM.addListener(elt, "touchmove", taphold_move), 
        fortouch || fdjtDOM.addListener(elt, "mousedown", taphold_down), fortouch || fdjtDOM.addListener(elt, "mouseout", taphold_mouseout), 
        fortouch || fdjtDOM.addListener(elt, "mouseover", taphold_mouseover), fdjtDOM.addListener(elt, "touchstart", taphold_down), 
        fortouch || fdjtDOM.addListener(elt, "mouseup", taphold_up), fdjtDOM.addListener(elt, "touchend", taphold_up), 
        fdjtDOM.addListener(elt, "touchcancel", taphold_cancel), window_setup || (default_opts.fortouch || (fdjtDOM.addListener(window, "mousedown", global_mousedown), 
        fdjtDOM.addListener(window, "mouseup", global_mouseup), fdjtDOM.addListener(window, "mouseout", global_mouseout)), 
        window_setup = window), this.elt = elt, this.serial = serial, this.opts = {
            bubble: bubble,
            override: override,
            movethresh: movethresh,
            holdmsecs: holdmsecs,
            taptapmsecs: taptapmsecs
        }, this.istouched = function() {
            return touched;
        }, this.ispressed = function() {
            return pressed;
        }, this.clear = function() {
            (trace || traceall) && fdjtLog("TapHold/clear(%s) th=%o t=%o p=%o", thid, th_target, touched, pressed), 
            pressed && !noslip && slipped(pressed), pressed_at = touched = pressed = tap_target = !1, 
            cleartouch(!0), setTarget(!1), th_targets = [];
        }, this.fakePress = function(evt, holdmsecs) {
            start_x = target_x = touch_x = evt.clientX || getClientX(evt), start_y = target_y = touch_y = evt.clientY || getClientY(evt), 
            touch_t = start_t = fdjtET();
            var target = document.elementFromPoint(start_x, start_y);
            target || fdjtLog("TapHold(%s): No target from %o,%o", thid, start_x, start_y), 
            setTarget(target), th_targets = [ target ], (trace || traceall) && fdjtLog("TapHold/fakePress(%s) t=%o x=%o y=%o t=%o", thid, th_target, start_x, start_y, start_t), 
            startpress(evt, holdmsecs);
        }, this.abort = abortpress, this.getState = function() {
            return {
                thid: thid,
                elt: elt,
                pressed: pressed,
                touched: touched,
                th_target: th_target,
                th_last: th_last,
                start_x: start_x,
                start_y: start_y,
                start_t: start_t,
                touch_x: touch_x,
                touch_y: touch_y,
                touch_t: touch_t,
                target_x: target_x,
                target_y: target_y,
                th_target_t: th_target_t,
                trace: trace
            };
        }, this.trace = function(flag) {
            var cur = trace;
            return trace = flag === void 0 ? 1 : "number" == typeof flag ? flag : flag ? 2 : 0, 
            cur;
        }, this.debug = function() {}, (trace || traceall) && fdjtLog("New TapHold(%s) for %o: %o opts %j, trace=%o/%o", thid, elt, th, opts || !1, trace, traceall), 
        this;
    }
    function traceTapHold(flag) {
        if (flag === void 0) return traceall;
        var cur = traceall;
        return "number" == typeof flag ? traceall = flag : flag && (traceall = default_opts.traceall || 2), 
        cur;
    }
    var fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtET = fdjt.ET, traceall = 0, window_setup = !1, default_opts = {}, getChildren = fdjtDOM.getChildren, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, hasClass = fdjtDOM.hasClass, getParent = fdjtDOM.getParent, hasParent = fdjtDOM.hasParent, reticle = fdjtUI.Reticle, noBubble = fdjtUI.noBubble, noDefault = fdjtUI.noDefault, eTarget = fdjtUI.T, isTextInput = fdjtDOM.isTextInput, cleared = 0, serial_count = 1, keynums = {
        shift: 16,
        alt: 18,
        control: 17,
        meta: 224,
        os: 91,
        altgr: 225,
        fn: -1,
        numlock: 144,
        capslock: 20,
        scrolllock: 145
    }, keynames = {};
    for (var akeyname in keynums) if (keynums.hasOwnProperty(akeyname)) {
        var akeynum = keynums[akeyname];
        "number" == typeof akeynum && akeynum > 0 && (keynames[akeynum] = akeyname);
    }
    var sqrt = Math.sqrt, mouse_down = !1;
    return TapHold.prototype.id = TapHold.prototype.elt = TapHold.prototype.opts = TapHold.prototype.handlers = !1, 
    TapHold.prototype.serial = 0, TapHold.prototype.istouched = TapHold.prototype.ispressed = TapHold.prototype.fakepress = TapHold.prototype.clear = TapHold.prototype.getState = TapHold.prototype.trace = TapHold.prototype.abort = TapHold.prototype.debug = !1, 
    TapHold.clear = function() {
        traceall && fdjtLog("TapHold.clear()"), cleared = fdjtET();
    }, TapHold.trace = traceTapHold, TapHold.default_opts = default_opts, TapHold;
}(), fdjt.UI || (fdjt.UI = {}), fdjt.TextSelect = fdjt.UI.Selecting = fdjt.UI.TextSelect = function() {
    "use strict";
    function position(elt, arr) {
        if (arr.indexOf) return arr.indexOf(elt);
        for (var i = 0, lim = arr.length; lim > i; ) {
            if (arr[i] === elt) return i;
            i++;
        }
        return -1;
    }
    function TextSelect(nodes, opts) {
        if (!(this instanceof TextSelect)) return new TextSelect(nodes, opts);
        if (this.serial = ++serialnum, "string" == typeof nodes) {
            var elt = document.getElementById(nodes);
            if (!elt) return !1;
            this.nodes = nodes = [ elt ];
        } else if (nodes.nodeType) this.nodes = nodes = [ nodes ]; else {
            if (!nodes.length) return !1;
            this.nodes = nodes;
        }
        var sel = this, trace = 0, orig = this.orig = [], wrapped = this.wrapped = [], words = this.words = [], wrappers = this.wrappers = [], tapholds = this.tapholds = [];
        if (opts && opts.hasOwnProperty("trace")) {
            var trace_val = opts.trace;
            trace = "number" == typeof trace_val ? trace_val : trace_val ? 1 : 0;
        }
        this.traced = trace, opts.onstart && (sel.onstart = opts.onstart), opts.onstop && (sel.onstop = opts.onstop);
        var prefix = this.prefix = "fdjtSel0" + this.serial;
        if (opts.loupe || TextSelect.loupe) {
            var spec = opts.loupe || TextSelect.loupe;
            this.loupe = spec.nodeType ? spec : fdjtDOM("span.fdjtselectloupe");
        }
        this.adjust = !1, selectors[prefix] = sel;
        for (var stripid = prefix.length + 1, k = 0, n = nodes.length; n > k; ) {
            var node = nodes[k++], style = getStyle(node), wrapper = "inline" === style.display ? fdjtDOM("span.fdjtselecting") : fdjtDOM("div.fdjtselecting");
            this.loupe && !this.loupe.parentNode && wrapper.appendChild(this.loupe), wrapper.id = prefix + "w" + k, 
            wrapper.title = opts && opts.title || "Tap or hold/drag to move the ends of the text range", 
            selectors[wrapper.id] = sel, wrappers.push(wrapper);
            var th = addHandlers(wrapper, sel, opts);
            alltapholds[wrapper.id] = th, tapholds.push(th), (trace || traceall) && fdjtLog("Created TapHold handler (#%d) for wrapper %s around %o", th.serial, wrapper.id, node), 
            node.parentNode.replaceChild(wrapper, node), orig.push(node), wrapped.push(wrapper), 
            wrapText(node, orig, wrapped, words, prefix), wrapper.appendChild(node);
        }
        return this.start = !1, this.end = !1, this.min = -1, this.max = -1, this.n_words = 0, 
        this.onchange = opts && opts.onchange || !1, this.wordnum = function(target) {
            for (var id = !1; target && 1 !== target.nodeType; ) target = target.parentNode;
            return target && (id = target.id) && "SPAN" === target.tagName && 0 === id.search(prefix) ? parseInt(id.slice(stripid), 10) : !1;
        }, this.startEvent = function(evt, holdmsecs) {
            var target = fdjtUI.T(evt);
            traceall && fdjtLog("startEvent %o, target=%o, wrappers=%o", evt, target, wrappers);
            for (var j = 0, n_wrappers = wrappers.length; n_wrappers > j; ) {
                var wrapper = wrappers[j++];
                if (hasParent(wrapper, target) || hasParent(target, wrapper)) {
                    var taphold = alltapholds[wrapper.id];
                    return (trace || traceall) && fdjtLog("Using TapHold handler @%d for wrapper %s (#%d)", j - 1, wrapper.id, taphold.serial), 
                    taphold.fakePress(evt, holdmsecs), void 0;
                }
            }
        }, this;
    }
    function wrapText(node, orig, wrapped, words, prefix) {
        var i, lim;
        if (3 === node.nodeType) {
            var span, text = node.nodeValue, sliced = mergeSoftHyphens(text.split(/\b/)), wordspans = [];
            for (i = 0, lim = sliced.length; lim > i; ) {
                var word = sliced[i++];
                if (0 !== word.length) if (word.search(/\S/) >= 0 && word.search(/\s/) >= 0) for (var scan = word; scan.length; ) {
                    var space = scan.search(/\s/), notspace = scan.search(/\S/), split = 0 >= space ? notspace : 0 >= notspace ? space : notspace > space ? space : notspace;
                    if (0 >= split && (split = scan.length), split > 0) {
                        var txt = scan.slice(0, split);
                        span = fdjtDOM("span.fdjtword", txt), span.id = prefix + "_" + words.length, words.push(span), 
                        wordspans.push(span);
                    }
                    scan = scan.slice(split);
                } else span = fdjtDOM("span.fdjtword", word), span.id = prefix + "_" + words.length, 
                words.push(span), wordspans.push(span);
            }
            return fdjtDOM("span.fdjtselectwrap", wordspans);
        }
        if (1 !== node.nodeType) return node;
        var classname = node.className;
        if (classname && "string" == typeof classname && ("fdjtselectwrap" === classname || "fdjtskiptext" === node.className || node.className.search(/\bfdjtskiptext\b/) >= 0)) return node;
        var style = getStyle(node);
        if ("" !== style.position && "static" !== style.position) return node;
        var children = node.childNodes;
        if (children) {
            if (0 === children.length) return node;
            if ("fdjtselectwrap" === node.className) return node;
            for (i = 0, lim = children.length; lim > i; ) {
                var child = children[i++], wrap = wrapText(child, orig, wrapped, words, prefix);
                child !== wrap && (orig.push(child), wrapped.push(wrap), node.replaceChild(wrap, child));
            }
            return node;
        }
        return node;
    }
    function mergeSoftHyphens(vec) {
        for (var i = 0, lim = vec.length, out = [], word = !1; lim > i; ) {
            var wd = vec[i++];
            if ("­" === wd) if (word) {
                var nxt = vec[i];
                nxt ? (word = word + wd + nxt, i++) : word += wd;
            } else word = wd; else word && out.push(word), word = wd;
        }
        return word && out.push(word), out;
    }
    function selectWords(words, start, end) {
        for (var i = start; end >= i; ) words[i++].className = "fdjtselected";
    }
    function deselectWords(words, start, end) {
        for (var i = start; end >= i; ) words[i++].className = "fdjtword";
    }
    function startSelection(sel) {
        sel.active || (sel.active = !0, sel.onstart && sel.onstart());
    }
    function stopSelection(sel) {
        sel.active && (sel.active = !1, sel.onstop && sel.onstop());
    }
    function overWord(word, tapped, sel) {
        for (var id = !1; word && 1 !== word.nodeType; ) word = word.parentNode;
        if (!hasParent(word, ".fdjtselectloupe")) {
            if (sel.active || startSelection(sel), !sel && word && (id = word.id) && "SPAN" === word.tagName && 0 === id.search("fdjtSel")) {
                var split = id.indexOf("_");
                split && (sel = selectors[id.slice(0, split)]);
            }
            if (!sel) {
                for (var container = word; container && !(container.className && container.id && "string" == typeof container.className && container.className.search(/\bfdjtselecting\b/) >= 0); ) container = container.parentNode;
                if (!container) return !1;
                sel = selectors[container.id];
            }
            if (!sel) return !1;
            if ((traceall || sel.traced) && fdjtLog("overWord %o, sel=%o, tapped=%o, adjust=%o, anchor=%o", word, sel, tapped, sel.adjust, sel.anchor), 
            tapped) useWord(word, sel, !0); else if (sel.word) useWord(word, sel); else if (hasClass(word, "fdjtselectstart") || hasClass(word, "fdjtselectend")) sel.timeout && (clearTimeout(sel.timeout), 
            sel.timeout = !1), sel.pending = !1, sel.word = word, useWord(word, sel); else {
                if (sel.pending === word) return !0;
                if (!word.offsetParent) return !1;
                sel.timeout && clearTimeout(sel.timeout), updateLoupe(word, sel, !1), sel.word = !1, 
                sel.pending = word, sel.timeout = setTimeout(function() {
                    sel.pending === word && (sel.timeout && clearTimeout(sel.timeout), sel.word = word, 
                    sel.pending = !1, useWord(word, sel));
                }, 100);
            }
            return !0;
        }
    }
    function useWord(word, sel, tapped) {
        var start = sel.start, end = sel.end;
        if (word.offsetParent) {
            if (sel.start) if (sel.anchor) start = sel.anchor, end = word; else if (sel.start === sel.end) start = sel.start, 
            end = word; else {
                var off = sel.wordnum(word);
                if ("start" === sel.adjust && off > sel.max) return;
                if ("end" === sel.adjust && sel.min > off) return;
                if ("start" === sel.adjust) start = word; else if ("end" === sel.adjust) end = word; else if (start === word) sel.setAdjust("start"); else if (end === word) sel.setAdjust("end"); else if (sel.min >= off) start = word, 
                sel.setAdjust("start"); else if (off >= sel.max) end = word, sel.setAdjust("end"); else if (6 > off - sel.min) start = word, 
                sel.setAdjust("start"); else if (6 > sel.max - off) end = word, sel.setAdjust("end"); else {
                    if (tapped) return;
                    off - sel.min > (sel.max - sel.min) / 2 ? (end = word, sel.setAdjust("end")) : (start = word, 
                    sel.setAdjust("start"));
                }
            } else {
                var initial = initSelect(word);
                start = initial.start, end = initial.end;
            }
            rAF(function() {
                sel.setRange(start, end), sel.loupe && updateLoupe(word, sel, tapped);
            });
        }
    }
    function nodeSearch(node, pat) {
        if (3 === node.nodeType) return node.nodeValue.search(pat) >= 0;
        if (1 === node.nodeType) {
            for (var children = node.childNodes, i = 0, lim = children ? children.length : 0; lim > i; ) {
                var child = children[i++];
                if (3 === child.nodeType) {
                    if (child.nodeValue.search(pat) >= 0) return child;
                } else if (1 === child.nodeType && nodeSearch(child, pat)) return child;
            }
            return !1;
        }
        return !1;
    }
    function initSelect(word) {
        var scan, last, begin = word, end = word;
        if (!nodeSearch(word, /"\(\[\{/)) {
            for (last = begin, scan = begin.previousSibling; scan; ) if (1 === scan.nodeType && hasClass(scan, "fdjtword")) {
                if (nodeSearch(scan, /["\(\[\{]/)) {
                    begin = scan;
                    break;
                }
                if (nodeSearch(scan, /[.;!?]/)) {
                    begin = last;
                    break;
                }
                last = scan, scan = scan.previousSibling;
            } else scan = scan.previousSibling;
            scan || (begin = last);
        }
        if (nodeSearch(word, /[.;!?]/)) end = word; else {
            for (last = end, scan = end.nextSibling; scan; ) if (1 === scan.nodeType && hasClass(scan, "fdjtword")) {
                if (nodeSearch(scan, /[".;!?]/)) {
                    end = scan;
                    break;
                }
                last = scan, scan = scan.nextSibling;
            } else scan = scan.nextSibling;
            scan || (end = last);
        }
        return {
            start: begin,
            end: end
        };
    }
    function updateLoupe(word, sel, tapped) {
        var parent = word.parentNode, loupe = sel.loupe;
        if (loupe) {
            var inline_loupe = hasParent(loupe, ".fdjtselecting");
            if (sel.loupe_timeout && (clearTimeout(sel.loupe_timeout), sel.loupe_timeout = !1), 
            word.offsetParent) {
                for (var block = word.parentNode; block && "inline" === getStyle(block).display; ) block = block.parentNode;
                (traceall || sel.traced) && fdjtLog("updateLoupe(%d) over %o for %o%s", sel.serial, word, sel, tapped ? " (tapped)" : "");
                var context = hasClass(word, "fdjtselectend") ? gatherContext(word, 7, 3, block) : gatherContext(word, 3, 7, block), words = fdjtDOM("span.fdjtloupetext");
                loupe.innerHTML = "", fdjtDOM.append(words, context.words), fdjtDOM.append(loupe, words), 
                inline_loupe && parent.insertBefore(loupe, word), loupe.style.display = "", tapped && setTimeout(function() {
                    sel.active && stopSelection(sel), sel.loupe.style.display = "none";
                }, 1e3);
            }
        }
    }
    function gatherContext(node, back, forward, parent) {
        var id = node.id, parsed = id && /(fdjtSel\d+_)(\d+)/.exec(id);
        if (parsed && 3 === parsed.length) {
            var prefix = parsed[1], count = parseInt(parsed[2], 10), start = count - back, end = count + forward;
            0 > start && (start = 0);
            for (var wordstart, wordend, context = [], width = 0, start_geom = getGeometry(node), i = start; end > i; ) {
                var elt = document.getElementById(prefix + i);
                if (!elt || parent && !hasParent(elt, parent)) i++; else {
                    if (1 === elt.nodeType) {
                        var geom = getGeometry(elt);
                        if (start_geom.top > geom.bottom || geom.top >= start_geom.bottom) {
                            i++;
                            continue;
                        }
                        var clone = elt.cloneNode(!0);
                        stripIDs(clone), count > i ? width += elt.offsetWidth : i === count ? (wordstart = width, 
                        width = wordend = width + elt.offsetWidth) : width += elt.offsetWidth, elt === node && fdjtDOM.addClass(clone, "fdjtselected"), 
                        context.push(clone);
                    } else context.push(elt.cloneNode(!0));
                    i++;
                }
            }
            return {
                words: context,
                width: width,
                wordstart: wordstart,
                wordend: wordend
            };
        }
    }
    function getSelector(word) {
        var id = !1;
        if (word && (id = word.id) && "SPAN" === word.tagName && 0 === id.search("fdjtSel")) {
            var split = id.indexOf("_");
            return split ? selectors[id.slice(0, split)] || !1 : !1;
        }
        return !1;
    }
    function hold_handler(evt) {
        evt = evt || window.event;
        for (var target = fdjtUI.T(evt); target && 1 !== target.nodeType; ) target = target.parentNode;
        for (;target; ) {
            if (target && target.id && "SPAN" === target.tagName && 0 === target.id.search("fdjtSel")) {
                var sel = getSelector(target);
                !sel || sel.anchor || sel.start || (sel.anchor = target), (traceall || sel && sel.traced) && fdjtLog("TextSelect/hold %o t=%o sel=%o", evt, target, sel), 
                overWord(target, !1, sel), fdjtUI.cancel(evt);
                break;
            }
            if (1 !== target.nodeType) break;
            target = target.parentNode;
        }
    }
    function tap_handler(evt) {
        evt = evt || window.event;
        for (var target = fdjtUI.T(evt); target && 1 !== target.nodeType; ) target = target.parentNode;
        for (;target; ) {
            if (target && target.id && "SPAN" === target.tagName && 0 === target.id.search("fdjtSel")) {
                var sel = getSelector(target);
                (traceall || sel && sel.traced) && fdjtLog("TextSelect/tap %o t=%o sel=%o", evt, target, sel), 
                1 === sel.n_words ? sel.setRange(!1) : "fdjtselectstart" === target.className || "fdjtselectend" === target.className ? (fdjtUI.cancel(evt), 
                sel.setRange(target, target)) : overWord(target, !0, sel) ? (sel.adjust = "fdjtselectstart" === target.className ? "start" : "fdjtselectend" === target.className ? "end" : !1, 
                fdjtUI.cancel(evt)) : sel && (sel.adjust = !1);
                break;
            }
            if (1 !== target.nodeType) break;
            target = target.parentNode;
        }
    }
    function release_handler(evt, sel) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        (traceall || sel && sel.traced) && fdjtLog("TextSelect/release %o t=%o sel=%o", evt, target, sel), 
        sel && (sel.anchor = !1, sel.word = !1, sel.pending = !1, sel.timeout && (clearTimeout(sel.timeout), 
        sel.timeout = !1), sel.setAdjust(!1), sel.loupe && (sel.loupe.style.display = "none"), 
        sel.active && stopSelection(sel));
    }
    function slip_handler(evt, sel) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        (traceall || sel && sel.traced) && fdjtLog("TextSelect/slip %o t=%o sel=%o", evt, target, sel), 
        sel && sel.loupe && (sel.loupe_timeout = setTimeout(get_loupe_timeout(sel), 2e3));
    }
    function get_release_handler(sel, also) {
        return function(evt) {
            release_handler(evt, sel), also && also(evt, sel);
        };
    }
    function get_slip_handler(sel, also) {
        return function(evt) {
            slip_handler(evt, sel), also && also(evt, sel);
        };
    }
    function get_loupe_timeout(sel) {
        return function() {
            sel.loupe_timeout = !1, sel.active && stopSelection(sel), sel.loupe.style.display = "none";
        };
    }
    function addHandlers(container, sel, opts) {
        opts || (opts = {}), opts.override = !0, opts.touchable = ".fdjtword,.fdjtselected,.fdjtselectstart,.fdjtselectend";
        var taphold = new fdjtUI.TapHold(container, opts);
        return fdjtDOM.addListener(container, "tap", opts && opts.ontap || tap_handler), 
        fdjtDOM.addListener(container, "hold", opts && opts.onhold || hold_handler), fdjtDOM.addListener(container, "release", get_release_handler(sel, opts.onrelease || !1)), 
        fdjtDOM.addListener(container, "slip", get_slip_handler(sel, opts.onslip || !1)), 
        taphold;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, hasParent = fdjtDOM.hasParent, stripIDs = fdjtDOM.stripIDs, getStyle = fdjtDOM.getStyle, textify = fdjtDOM.textify, hasClass = fdjtDOM.hasClass, swapClass = fdjtDOM.swapClass, dropClass = fdjtDOM.dropClass, rAF = fdjtDOM.requestAnimationFrame, selectors = {}, alltapholds = {}, serialnum = 0, traceall = 0;
    TextSelect.prototype.serial = TextSelect.prototype.traced = TextSelect.prototype.adjust = TextSelect.prototype.n_words = TextSelect.prototype.start = TextSelect.prototype.end = TextSelect.prototype.min = TextSelect.prototype.max = 0, 
    TextSelect.prototype.prefix = TextSelect.prototype.traced = 0, TextSelect.prototype.nodes = TextSelect.prototype.orig = TextSelect.prototype.wrapped = TextSelect.prototype.wrappers = TextSelect.prototype.words = TextSelect.prototype.tapholds = TextSelect.prototype.loupe = [], 
    TextSelect.prototype.onchange = TextSelect.prototype.wordnum = TextSelect.prototype.startEvent = !1, 
    TextSelect.prototype.toString = function() {
        for (var wrappers = this.wrappers, output = "TextSelect([" + this.min + ("start" === this.adjust ? "*" : "") + "," + this.max + ("end" === this.adjust ? "*" : "") + "],", i = 0, lim = wrappers.length; lim > i; ) {
            var id = wrappers[i].id;
            id && (output = output + (i > 0 ? "," : "") + "'" + wrappers[i].id + "'"), i++;
        }
        return output += ")";
    }, TextSelect.prototype.setRange = function(start, end) {
        var trace = this.trace;
        if ((trace || traceall) && fdjtLog("TextSelect.setRange %o %o for %o", start, end, this), 
        !start) return this.start && this.end && deselectWords(this.words, this.min, this.max), 
        this.start = this.end = !1, this.min = this.max = -1, this.n_words = 0, this.onchange && this.onchange(), 
        void 0;
        var words = this.words, min = this.wordnum(start), max = this.wordnum(end);
        if (min > max) {
            var tmp = start;
            start = end, end = tmp, tmp = min, min = max, max = tmp;
        }
        if (this.start) {
            if (this.start === start && this.end === end) return;
            var cur_min = this.wordnum(this.start), cur_max = this.wordnum(this.end);
            min > cur_max || cur_min > max ? (deselectWords(words, cur_min, cur_max), selectWords(words, min, max)) : (cur_min > min ? selectWords(words, min, cur_min) : min > cur_min && deselectWords(words, cur_min, min), 
            max > cur_max ? selectWords(words, cur_max, max) : cur_max > max && deselectWords(words, max, cur_max)), 
            words[max].className = "fdjtselectend", words[min].className = "fdjtselectstart";
        } else selectWords(words, min, max), words[max].className = "fdjtselectend", words[min].className = "fdjtselectstart";
        this.min = min, this.max = max, this.start = start, this.end = end, this.n_words = max - min + 1, 
        this.onchange && this.onchange();
    };
    var getGeometry = fdjtDOM.getGeometry;
    return TextSelect.getSelector = getSelector, TextSelect.prototype.setString = function(string) {
        var wrappers = this.wrappers, whole = 1 === wrappers.length && wrappers[0];
        if (!whole) {
            whole = fdjtDOM("div");
            for (var i = 0, lim = wrappers.length; lim > i; ) {
                var wrapper = wrappers[i++];
                whole.appendChild(wrapper.cloneNode(!0));
            }
        }
        var found = fdjtDOM.findMatches(whole, string, 0, 1);
        if (found && 0 !== found.length) {
            found = found[0];
            for (var start = found.startContainer, end = found.endContainer; start && 1 !== start.nodeType; ) start = start.parentNode;
            for (;end && 1 !== end.nodeType; ) end = end.parentNode;
            start && end && start.id && end.id && 0 === start.id.search(this.prefix) && 0 === end.id.search(this.prefix) && (start = document.getElementById(start.id), 
            end = document.getElementById(end.id), start && end && this.setRange(start, end));
        }
    }, TextSelect.prototype.getString = function(start, end, rawtext) {
        start || (start = this.start), end || (end = this.end);
        for (var wrappers = this.wrappers, combine = [], prefix = this.prefix, wpos = -1, scan = start; scan; ) {
            if (rawtext) ; else if (1 === scan.nodeType) {
                var style = getStyle(scan);
                "static" === style.position && "inline" !== style.display && "none" !== style.display && combine.push("\n");
            }
            if (1 === scan.nodeType && "SPAN" === scan.tagName && scan.id && 0 === scan.id.search(prefix)) {
                var txt = scan.innerText || textify(scan);
                if (combine.push(txt.replace("­", "")), scan === end) break;
            }
            if (scan.firstChild && "fdjtselectloupe" !== scan.className && 3 !== scan.firstChild.nodeType) scan = scan.firstChild; else if (scan.nextSibling) scan = scan.nextSibling; else {
                for (;scan && !((wpos = position(scan, wrappers)) >= 0); ) {
                    if (scan.nextSibling) {
                        scan = scan.nextSibling;
                        break;
                    }
                    scan = scan.parentNode;
                }
                wpos >= 0 && wrappers.length > wpos + 1 && (scan = wrappers[wpos + 1]);
            }
            if (!scan) break;
        }
        return combine.join("");
    }, TextSelect.prototype.getOffset = function(under) {
        if (!this.start) return !1;
        var first_word = this.words[0];
        if (under) {
            var words = this.words, i = 0, lim = words.length;
            if (!hasParent(this.start, under) || !hasParent(this.end, under)) return !1;
            for (;lim > i && !hasParent(first_word, under); ) first_word = words[i++];
        }
        var selected = this.getString(!1, !1, !0), preselected = this.getString(first_word, this.end, !0);
        return preselected.length - selected.length;
    }, TextSelect.prototype.getInfo = function(under) {
        var trace = this.traced;
        if (!this.start) return !1;
        var selected = this.getString(), first_word = this.words[0];
        if (under) {
            var words = this.words, i = 0, lim = words.length;
            if (!hasParent(this.start, under) || !hasParent(this.end, under)) return !1;
            for (;lim > i && !hasParent(first_word, under); ) first_word = words[i++];
        }
        var rawselect = this.getString(!1, !1, !0), preselected = this.getString(first_word, this.end, !0);
        return (trace || traceall) && fdjtLog("GetInfo %o: start=%o, end=%o, off=%o, string=%o", this, this.start, this.end, preselected.length - rawselect.length, selected), 
        {
            start: this.start,
            end: this.end,
            off: preselected.length - rawselect.length,
            string: selected
        };
    }, TextSelect.prototype.setAdjust = function(val) {
        var trace = this.traced;
        (traceall || trace) && fdjtLog("TextSelect.setAdjust %o for %o", val, this), val ? (this.adjust = val, 
        swapClass(this.nodes, /\b(fdjtadjuststart|fdjtadjustend)\b/, "fdjtadjust" + val)) : (this.adjust = !1, 
        dropClass(this.nodes, /\b(fdjtadjuststart|fdjtadjustend)\b/));
    }, TextSelect.prototype.clear = function() {
        var wrappers = this.wrappers, orig = this.orig, wrapped = this.wrapped;
        if (orig) {
            for (var i = orig.length - 1; i >= 0; ) {
                var o = orig[i], w = wrapped[i];
                i--, w.parentNode.replaceChild(o, w);
            }
            for (var j = 0, lim = wrappers.length; lim > j; ) {
                var wrapper = wrappers[j++];
                delete alltapholds[wrapper.id], delete selectors[wrapper.id];
            }
            if (this.onclear) {
                var onclear = this.onclear;
                for (this.onclear = !1, Array.isArray(onclear) || (onclear = [ onclear ]), i = 0, 
                lim = onclear.length; lim > i; ) onclear[i++]();
            }
            delete selectors[this.prefix], delete this.wrapped, delete this.orig, delete this.wrappers, 
            delete this.nodes, delete this.words, delete this.wrappers, delete this.start, delete this.end;
        }
    }, TextSelect.hold_handler = hold_handler, TextSelect.handler = hold_handler, TextSelect.tap_handler = tap_handler, 
    TextSelect.release_handler = release_handler, TextSelect.trace = function(flag, thtoo) {
        return flag === void 0 ? traceall : (traceall = "number" == typeof flag ? flag : flag ? 1 : 0, 
        thtoo && fdjt.TapHold.trace(thtoo), void 0);
    }, TextSelect;
}(), function() {
    "use strict";
    fdjt.useGlobals = fdjt.dbg = function(cxt) {
        var names = [ "fdjtDOM", "fdjtUI", "fdjtTime", "fdjtString", "fdjtState", "fdjtLog", "fdjtHash", "fdjtAjax", "fdjtAsync", "fdjtInit", "fdjtDialog", "fdjtTemplate", "fdjtID", "fdjtRef", "fdjtTapHold", "fdjtSelecting", "fdjtTextIndex", "fdjtRefDB", "TextIndex", "RefDB", "CodexLayout", "pageShow" ];
        if (cxt || (cxt = window), !cxt) return fdjt.Log("Nowhere to put globals"), void 0;
        for (var i = 0, n = names.length; n > i; ) {
            var name = names[i++], fname = 0 === name.search("fdjt") ? name.slice(4) : name;
            fdjt[fname] && !cxt[name] && (fdjt.Log("%s = fdjt.%s", name, fname), cxt[name] = fdjt[fname]);
        }
        return n;
    };
}();

var Knodule = function() {
    "use strict";
    function Knodule(id, inits) {
        if (0 === arguments.length) return this;
        inits || (inits = {}), inits.indices = inits.indices ? inits.indices.concat([ "terms", "hooks", "genls", "specls", "allgenls" ]) : [ "terms", "hooks", "genls", "specls", "allgenls" ];
        var lang = inits.language, knodule = RefDB.call(this, id, inits);
        if (lang && knodule.language !== lang) throw {
            error: "language mismatch"
        };
        if (inits.language && knodule.language && inits.language !== knodule.language) throw {
            error: "language mismatch"
        };
        return knodule.language = inits.language ? inits.language : "EN", knodule.dterms = {}, 
        knodule.alldterms = [], knodule.prime = [], knodule.primescores = {}, knodule.validate = !0, 
        knodule.strict = !1, knodule.finished = !1, knodule.assumed_dterms = [], knodule.xdterms = {}, 
        knodule.allxdterms = [], knodule.allwaysIndex = new ObjectMap(), knodule.oidmap = {}, 
        knodule.drules = {}, knodule;
    }
    function KNode(string, knodule, lang) {
        if (0 === arguments.length) return this;
        var weak = !1, prime = "*" === string[0] && string.search(/[^*]/), newprime = !1, knode = this, notword = !1;
        "~" === string[0] ? (weak = !0, string = string.slice(1)) : prime && (string = string.slice(prime), 
        knodule.primescores[string] || (prime > knodule.primescores[string] && (knodule.primescores[string] = prime), 
        newprime = !0));
        var atpos = string.indexOf("@");
        if (0 === atpos || 1 === atpos && ":" === string[0]) notword = !0; else if (atpos > 2 && "\\" !== string[atpos - 1]) {
            var domain = string.slice(atpos + 1);
            domain !== knodule.name && 0 > knodule.aliases.indexOf(domain) && warn("Reference %s in %s is being handled by %s", string, domain, knodule), 
            string = string.slice(0, atpos);
        }
        if (notword) ; else if (0 === string.search(lang_pat)) {
            var dollar = string.indexOf("$");
            lang = string.slice(0, dollar).toUpperCase(), string = string.slice(dollar + 1);
        } else lang = lang ? lang.toUpperCase() : knodule.language || "EN";
        string = stdcap(string);
        var refterm = lang === knodule.language ? string : lang + "$" + string;
        return knode = Ref.call(this, refterm, knodule), knode === this && (knode.dterm || (knode.dterm = refterm), 
        knode.add("dterms", refterm), knodule.dterms.hasOwnProperty(refterm) || (knodule.dterms[refterm] = knode, 
        knodule.alldterms.push(refterm)), knode.allways = fdjt.Set(), lang && knode.add(lang, string), 
        knode._live = fdjtTime()), weak && (knode.weak = !0), prime && (knode.prime = prime), 
        prime && newprime && knodule.prime.push(knode), lang && lang !== knodule.language && (knode.language = lang), 
        knode;
    }
    function findBreak(string, brk, start) {
        for (var pos = string.indexOf(brk, start || 0); pos > 0; ) {
            if ("\\" !== string[pos - 1]) return pos;
            pos = string.indexOf(brk, pos + 1);
        }
        return pos;
    }
    function getSubject(knodule, clauses) {
        var ref = stdcap(clauses[0]), probe = knodule.probe(ref);
        if (probe) return probe;
        for (var i = 1, lim = clauses.length; lim > i; ) {
            var clause = clauses[i++];
            if ("=" === clause[0] && (probe = knodule.probe(stdcap(clause.slice(1))))) return probe;
        }
        return knodule.KNode(clauses[0]);
    }
    function stripComments(string) {
        return string.replace(/^\s*#.*$/g, "").replace(/^\s*\/\/.*$/g, "");
    }
    var fdjtString = fdjt.String, fdjtTime = fdjt.Time, fdjtLog = fdjt.Log, RefDB = fdjt.RefDB, Ref = fdjt.Ref, warn = fdjtLog.warn, ObjectMap = RefDB.ObjectMap, trace_parsing = 0, lang_pat = /^(([A-Za-z]{2,3}\$)|([A-Za-z]{2,3}_[A-Za-z]{2,3}\$))/;
    Knodule.prototype = new RefDB(), Knodule.prototype.language = Knodule.prototype.dterms = Knodule.prototype.alldterms = Knodule.prototype.prime = Knodule.prototype.primescores = Knodule.prototype.validate = Knodule.prototype.strict = Knodule.prototype.finished = Knodule.prototype.assumed_dterms = Knodule.prototype.xdterms = Knodule.prototype.allxdterms = Knodule.prototype.allwaysIndex = Knodule.prototype.oidmap = Knodule.prototype.drules = !1, 
    Knodule.prototype.toString = function() {
        return "Knodule(" + this.name + ")";
    };
    var stdcap = fdjtString.stdcap;
    KNode.prototype = new RefDB.Ref(), KNode.prototype.dterms = !1, Knodule.refclass = Knodule.prototype.refclass = KNode, 
    Knodule.KNode = KNode, Knodule.Knode = KNode, Knodule.prototype.KNode = Knodule.prototype.Knode = function(arg, inits) {
        return arg instanceof KNode ? arg._db === this ? arg : arg : new KNode(arg, this, inits);
    }, Knodule.prototype.cons = function(string, lang) {
        return new KNode(string, this, lang);
    }, Knodule.prototype.probe = function(string, langid) {
        var refs = this.refs, aliases = this.aliases;
        return string = stdcap(string), this.language !== langid && langid ? (string = langid.toUpperCase() + "$" + string, 
        this.dterms[langid + "$" + string] || !1) : refs.hasOwnProperty(string) && refs[string] || aliases.hasOwnProperty(string) && aliases[string] || !1;
    }, KNode.prototype.add = function(prop, val) {
        var ai = this._db.allwaysIndex;
        if (Ref.prototype.add.call(this, prop, val) && "genls" === prop) {
            this.allways.push(val), this.allways = RefDB.merge(this.allways, val.allways);
            for (var allways = this.allways, i = 0, lim = allways.length; lim > i; ) ai.add(allways[i++], this);
            var examples = ai.get(this);
            if (examples) for (var e = 0, n_examples = examples.length; n_examples > e; ) {
                var example = examples[e++];
                example.allways = RefDB.merge(example.allways, this.allways);
                for (var j = 0, jlim = allways.length; jlim > j; ) ai.add(allways[j++], example);
            }
            return !0;
        }
        return !1;
    }, KNode.prototype.addTerm = function(val, field, inlang) {
        if ("string" == typeof val && 0 === val.search(lang_pat)) {
            var dollar = val.indexOf("$"), langspec = val.slice(0, dollar).toUpperCase(), term = val.slice(dollar + 1);
            langspec === this._db.language ? field ? this.add(field, term) : (this.add(langspec, term), 
            this.add("terms", term)) : field ? this.add(field, langspec + "$" + term) : (this.add(langspec, term), 
            this.add("terms", val));
        } else inlang ? (inlang = inlang.toUpperCase(), inlang === this._db.language ? field ? this.add(field, val) : this.add("terms", val) : field ? this.add(field, inlang + "$" + val) : this.add("terms", inlang + "$" + val)) : field ? this.add(field, val) : (this.add(this._db.language, val), 
        this.add("terms", val));
    }, KNode.prototype.tagString = function(kno) {
        return this.oid ? this.oid : this.uuid ? this.uuid : this._qid ? this._qid : (kno || (kno = Knodule.current || !1), 
        kno === this._db ? this._id : this._db.absrefs ? this._id : this._domain ? this._id + "@" + this._domain : this._id + "@" + this._db.name);
    }, KNode.prototype.toPlaintext = function() {
        var result = "", variants = this[this._db.language || "EN"], n = 0;
        "string" == typeof variants && (variants = [ variants ]);
        for (var i = 0; variants.length > i; ) result = result + (n > 0 ? "|" : "") + variants[i++], 
        n++;
        var genls = this.genls;
        if ("string" == typeof genls && (genls = [ genls ]), genls && genls.length) for (i = 0; genls.length > i; ) result = result + (n > 0 ? "|^" : "^") + genls[i++].dterm, 
        n++;
        var specls = this.specls;
        if ("string" == typeof specls && (specls = [ specls ]), specls && specls.length) for (i = 0; specls.length > i; ) result = result + (n > 0 ? "|_" : "_") + specls[i++].dterm, 
        n++;
        return result;
    };
    var segment = fdjtString.segment;
    return Knodule.prototype.handleClause = function(clause, subject) {
        var object = !1, role = !1, value = !1;
        if (clause.indexOf("\\") >= 0 && (clause = fdjtString.unEscape(clause)), trace_parsing > 2 && fdjtLog("Handling clause '%s' for %o", clause, subject), 
        !(0 === clause.length || 0 > clause.search(/[^\n\t ]/g))) {
            switch (clause[0]) {
              case "^":
                if ("~" === clause[1]) subject.add("sometimes", this.KNode(clause.slice(2))); else if ("*" === clause[2]) subject.add("commonly", this.KNode(clause.slice(2))); else {
                    var pstart = findBreak(clause, "(");
                    if (pstart > 0) {
                        var pend = findBreak(clause, ")", pstart);
                        0 > pend ? fdjtLog.warn("Invalid Knodule clause '%s' for %o (%s)", clause, subject, subject.dterm) : (role = this.KNode(clause.slice(1, pstart)), 
                        object = this.KNode(clause.slice(pstart + 1, pend)), object.add(role.dterm, subject), 
                        subject.add("genls", role));
                    } else subject.add("genls", this.KNode(clause.slice(1)));
                }
                break;

              case "_":
                object = this.KNode(clause.slice(1)), subject.add("examples", object), object.add("genls", subject);
                break;

              case "-":
                subject.add("never", this.KNode(clause.slice(1)));
                break;

              case "&":
                value = clause.slice("-" === clause[1] ? 2 : 1);
                var assoc = this.KNode(value);
                "-" === clause[1] ? subject.add("antiassocs", assoc) : subject.add("assocs", assoc);
                break;

              case "@":
                "#" === clause[1] ? subject.add("tags", clause.slice(2)) : subject.add("uri", clause.slice(1));
                break;

              case "=":
                if ("@" === clause[1]) subject.oid = clause.slice(1); else if ("*" === clause[1]) subject.add("equiv", this.KNode(clause.slice(2))); else if ("~" === clause[1]) subject.add("kinda", this.KNode(clause.slice(2))); else if ("=" === clause[1]) subject.add("identical", this.KNode(clause.slice(1))); else {
                    var term = clause.slice(1), db = subject._db;
                    db.dterms.hasOwnProperty(term) || (subject.add("dterms", term), db.alldterms.push(term), 
                    db.dterms[term] = subject);
                }
                break;

              case "+":
                "*" === clause[1] ? (subject.gloss = clause.slice(2), subject.addTerm(subject.gloss, "glosses")) : "~" === clause[1] ? (subject.gloss = clause.slice(2), 
                subject.addTerm(subject.gloss, "glosses")) : (subject.gloss = clause.slice(1), subject.addTerm(subject.gloss, "glosses"));
                break;

              case "%":
                var omirror, mirror = this.KNode(clause.slice(1));
                if (subject.mirror === mirror) break;
                if (omirror = subject.mirror, fdjtLog.warn("Inconsistent mirrors for %s: +%s and -%s", subject, mirror, omirror), 
                omirror.mirror = !1, mirror.mirror) {
                    var oinvmirror = mirror.mirror;
                    fdjtLog.warn("Inconsistent mirrors for %s: +%s and -%s", mirror, subject, oinvmirror), 
                    omirror.mirror = !1;
                }
                subject.mirror = mirror, mirror.mirror = subject;
                break;

              case ".":
                var brk = findBreak(clause, "=");
                if (!brk) throw {
                    name: "InvalidClause",
                    irritant: clause
                };
                role = this.KNode(clause.slice(1, brk)), object = this.KNode(clause.slice(brk + 1)), 
                subject.add(role.dterm, object), object.add("genls", role);
                break;

              case "~":
                var hook = clause.slice(1);
                subject.addTerm(hook, "hooks");
                break;

              case ":":
                var equals = findBreak(clause, "=");
                if (equals > 0) {
                    var field = clause.slice(1, equals), multi = "+" === clause[equals + 1];
                    if (value = multi ? clause.slice(equals + 2) : clause.slice(equals + 1), "\\" === value[0]) value = value.slice(1); else if (/\d/.exec(value[0])) {
                        var number = parseFloat(value);
                        "number" != typeof number || !number && 0 !== number || (value = number);
                    }
                    multi ? subject.add(field, value) : subject.store(field, value);
                }
                subject.add("flags", clause.slice(1));
                break;

              default:
                var eqbrk = findBreak(clause, "=");
                eqbrk > 0 ? (role = this.KNode(clause.slice(0, eqbrk)), object = this.KNode(clause.slice(eqbrk + 1)), 
                subject.add(role.dterm, object), object.add("genls", role)) : subject.addTerm(clause);
            }
            return subject;
        }
    }, Knodule.prototype.handleSubjectEntry = function(entry) {
        var clauses = segment(entry, /[|]/g), subject = getSubject(this, clauses);
        this.trace_parsing > 2 && fdjtLog("Processing subject entry %s %o %o", entry, subject, clauses);
        for (var i = 1; clauses.length > i; ) this.handleClause(clauses[i++], subject);
        return this.trace_parsing > 2 && fdjtLog("Processed subject entry %o", subject), 
        subject;
    }, Knodule.prototype.handleEntry = function(entry) {
        if (entry = entry.trim(), 0 === entry.length) return !1;
        var starpower = entry.search(/[^*]/);
        starpower > 0 && (entry = entry.slice(starpower));
        var subject, bar = fdjtString.findSplit(entry, "|"), atsign = fdjtString.findSplit(entry, "@");
        if (atsign > 0 && (0 > bar || bar > atsign)) {
            var term = entry.slice(0, atsign), knostring = 0 > bar ? entry.slice(atsign + 1) : entry.slice(atsign + 1, bar), knodule = new Knodule(knostring);
            knodule instanceof Knodule ? subject = 0 > bar ? knodule.KNode(term) : knodule.handleEntry(term + entry.slice(bar)) : (warn("Resolved %s to non-knodule %o", entry, knodule), 
            subject = knodule.ref(term));
        } else subject = this.handleSubjectEntry(entry);
        if (starpower) {
            var id = subject._id, prime = this.prime, scores = this.primescores, score = scores[id];
            score ? starpower > score && (scores[id] = starpower, subject.prime = starpower) : (prime.push(id), 
            scores[id] = starpower, subject.prime = starpower);
        }
        return subject;
    }, Knodule.prototype.handleEntries = function(block) {
        if ("string" == typeof block) {
            var nocomment = stripComments(block), segmented = segment(nocomment, /(?:\s*[\n;]\s*)+/g);
            return this.trace_parsing > 1 && fdjtLog("Handling %d entries", segmented.length), 
            this.handleEntries(segmented);
        }
        if (block instanceof Array) {
            for (var results = [], i = 0; block.length > i; ) {
                var entry = block[i++], len = entry.length;
                ";" === entry[len - 1] && (entry = entry.slice(0, len - 1)), results[i] = this.handleEntry(entry);
            }
            return results;
        }
        throw {
            name: "TypeError",
            irritant: block
        };
    }, Knodule.prototype.def = Knodule.prototype.handleSubjectEntry, Knodule.def = function(string, kno) {
        return kno || (kno = Knodule.knodule), kno.def(string);
    }, Knodule.ref = RefDB.ref, Knodule.prototype.trace_parsing = 0, Knodule;
}(), KNode = Knodule.KNode, Knode = KNode;

KNode !== Knode && fdjt.Log("Weird stuff"), function() {
    "use strict";
    function exportTagSlot(tags, slotid, exported) {
        tags instanceof Array || (tags = [ tags ]);
        var extags = exported.tags || (exported.tags = []), start = slotid.search(/[^*~]+/), end = slotid.search(/[*]*$/), prefix = start && slotid.slice(0, start);
        end ? slotid = slotid.slice(start, end) : start && (slotid = slotid.slice(start));
        for (var i = 0, lim = tags.length; lim > i; ) {
            var tag = tags[i++];
            if (tag) {
                var tagstring = "string" == typeof tag ? tag : tag._qid || tag.getQID();
                start ? extags.push(prefix + tagstring) : extags.push(tagstring);
            }
        }
        return void 0;
    }
    function importTagSlot(ref, slotid, tags, data, indexing) {
        var tagref, keep = [], alltags = [], knodule = ref.tag_knodule || ref._db.tag_knodule || Knodule.tag_knodule || Knodule.current;
        tags instanceof Array || (tags = [ tags ]);
        for (var i = 0, lim = tags.length; lim > i; ) {
            var tag = tags[i++];
            if (tag) if (tag instanceof Ref) keep.push(tag); else if ("object" == typeof tag && tag._id) tagref = ref.resolve(tag, knodule, Knodule, !0) || tag._id, 
            keep.push(tagref); else if ("string" == typeof tag) {
                var tag_start = tag.search(/[^*~]/), tagstring = tag, slot = slotid, tagterm = tag;
                tag_start > 0 && (slot = tag.slice(0, tag_start) + slotid, tagstring = tag.slice(tag_start));
                var bar = tagstring.indexOf("|");
                tagterm = bar > 0 ? tagstring.slice(0, bar) : tagstring, tagref = RefDB.resolve(tagterm, knodule, Knodule, !0) || knodule && knodule.ref(tagterm) || tagterm, 
                bar > 0 && (tagref instanceof KNode ? tagref._db.handleEntry(tagstring) : warn("No knodule for %s", tagstring)), 
                alltags.push(tagref), tagref instanceof KNode && ref.add("knodes", tagref, indexing), 
                slot !== slotid ? ref.add(slot, tagref, indexing) : keep.push(tagref);
            } else keep.push(tag);
        }
        return ref["all" + slotid] = fdjtSet(alltags.concat(keep)), keep.length ? keep : void 0;
    }
    function TagQuery(tags, dbs, weights) {
        if (0 === arguments.length) return this;
        var clauses = [], slots = this.slots = [];
        dbs || (dbs = TagQuery.default_dbs || !1), weights || (weights = this.weights || {
            tags: 1
        }), tags instanceof Array || (tags = [ tags ]);
        for (var sl in weights) weights.hasOwnProperty(sl) && slots.push(sl);
        for (var i_tag = 0, n_tags = tags.length; n_tags > i_tag; ) {
            var tagval = tags[i_tag++];
            "string" == typeof tagval ? clauses.push({
                fields: "strings",
                values: [ tagval ]
            }) : tagval._db && tagval._db.slots ? clauses.push({
                fields: tagval._db.slots,
                values: [ tagval ]
            }) : clauses.push({
                fields: slots,
                values: [ tagval ]
            });
        }
        return this.tags = tags, Query.call(this, dbs, clauses, weights);
    }
    var RefDB = fdjt.RefDB, Ref = fdjt.Ref, Query = RefDB.Query, KNode = Knodule.KNode, fdjtLog = fdjt.Log, warn = fdjtLog.warn, fdjtSet = fdjt.Set, slotpat_weights = {
        "~%": 1,
        "~%*": 1,
        "%": 4,
        "%*": 4,
        "^%": 2,
        "^%*": 2,
        "*%": 8,
        "*%*": 6,
        "**%": 12,
        "**%*": 8
    };
    Knodule.addTags = function(refs, tags, refdb, tagdb, base_slot, tagscores) {
        base_slot || (base_slot = "tags"), "string" == typeof tags ? tags = [ tags ] : tags instanceof Ref ? tags = [ tags ] : tags.length ? tags instanceof Array || (tags = [].concat(tags)) : tags = [ tags ], 
        "string" == typeof refs ? refs = [ refs ] : refs instanceof Ref ? refs = [ refs ] : refs instanceof Array || (refs = refs.length ? [].concat(refs) : [ refs ]);
        for (var tag, slot, ref, slots = Array(tags.length), i = 0, ntags = tags.length; ntags > i; ) {
            tag = tags[i], slot = base_slot;
            var weak = !1;
            if ("string" == typeof tag) {
                if ("*" === tag[0]) {
                    var tagstart = tag.search(/[^*]/);
                    slot = tag.slice(0, tagstart) + base_slot, tag = tag.slice(tagstart);
                } else "~" === tag[0] && (slot = "~" + base_slot, tag = tag.slice(1), weak = !0);
                tag.indexOf("|") > 0 ? tagdb ? tag = tagdb.handleEntry(tag) : Knodule.current && (tag = Knodule.current.handleEntry(tag)) : weak && tagdb ? tag = tagdb.probe(tag) || tag : weak || tagdb && (tag = tagdb.ref(tag));
            }
            slots[i] = slot, tags[i] = tag, i++;
        }
        for (var j = 0, nrefs = refs.length; nrefs > j; ) {
            var refstring = refs[j];
            ref = !1, ref = refdb && "string" == typeof refstring ? refdb.ref(refstring) : RefDB.resolve(refstring, !1, Knodule, !0), 
            ref ? refs[j++] = ref : (warn("Couldn't resolve %s to a reference", refstring), 
            j++);
        }
        for (i = 0; ntags > i; ) {
            if (tag = tags[i], slot = slots[i], tagscores) {
                var slotpat = slot.replace(base_slot, "%"), slotweight = slotpat_weights[slotpat];
                slotweight || (slotweight = 3), tagscores.increment(tag, nrefs * slotweight);
            }
            for (j = 0; nrefs > j; ) ref = refs[j++], ref && (ref.add(slot, tag, !0), ref.alltags ? ref.alltags.push(tag) : ref.alltags = [ tag ], 
            tag instanceof KNode && (ref.add("knodes", tag), ref.add(slot + "*", tag, !0)), 
            tag instanceof KNode && tag.allways && ref.add(slot + "*", tag.allways, !0));
            i++;
        }
    }, Knodule.exportTagSlot = exportTagSlot, Knodule.importTagSlot = importTagSlot, 
    TagQuery.prototype = new Query();
    var TagMap = fdjt.Map;
    TagQuery.prototype.getCoTags = function(results) {
        if (this.cotags) return this.cotags;
        if (this.execute()) {
            results || (results = this.results);
            for (var scores = this.scores, slots = this.slots, n_slots = slots.length, alltags = this.cotags = [], tagscores = this.tagscores = new TagMap(), tagfreqs = this.tagfreqs = new TagMap(), weights = this._weights || this.weights, max_score = 0, max_freq = 0, r = 0, n_results = results.length; n_results > r; ) for (var result = results[r++], seen = {}, score = scores && scores[result._id] || 1, s = 0; n_slots > s; ) {
                var slot = slots[s];
                if (result.hasOwnProperty(slot)) {
                    var tags = result[slot], weight = weights[slot] || 1;
                    tags ? tags instanceof Array || (tags = [ tags ]) : tags = [];
                    for (var v = 0, n_tags = tags.length; n_tags > v; ) {
                        var tag = tags[v++];
                        if (tagscores.get(tag) || alltags.push(tag), !seen[tag]) {
                            var new_freq = tagfreqs.increment(tag, 1);
                            new_freq > max_freq && (max_freq = new_freq), seen[tag] = !0;
                        }
                        var new_score = tagscores.increment(tag, weight * score);
                        new_score > max_score && (max_score = new_score);
                    }
                }
                s++;
            }
            return this.max_tagfreq = max_freq, this.max_tagscore = max_score, alltags;
        }
        return !1;
    }, TagQuery.prototype.getString = function() {
        for (var tags = fdjt.Set(this.tags), qstring = "", i = 0, lim = tags.length; lim > i; ) {
            i > 0 && (qstring += ";");
            var tag = tags[i++];
            qstring += "string" == typeof tag ? tag : tag._qid || tag.getQID();
        }
        return qstring;
    }, Knodule.TagQuery = TagQuery;
}(), function() {
    "use strict";
    function KNode2HTML(arg, knodule, varname, cloud, lang) {
        function init() {
            if (arg instanceof KNode) {
                var knode = arg, dterm = knode.dterm;
                if (text.innerHTML = dterm, span.setAttribute("data-key", dterm), span.setAttribute("data-dterm", knode), 
                lang || cloud) {
                    var synonyms = knode[lang];
                    if (synonyms && "string" == typeof synonyms && (synonyms = [ synonyms ]), synonyms) for (var i = 0; synonyms.length > i; ) {
                        var synonym = synonyms[i++];
                        if (synonym !== dterm) {
                            var variation = fdjtDOM("span.variation", synonym, "=");
                            variation.setAttribute("data-key", synonym), variations.appendChild(variation);
                        }
                    }
                    knode.about && (span.title = knode.about), span.setAttribute("data-key", knode.dterm);
                } else span.setAttribute("data-key", knode.dterm);
            } else arg.name && (span.setAttribute("data-key", arg.name), span.innerHTML = arg.name);
            cloud && cloud.addCompletion(span);
        }
        cloud === !0 ? ("string" != typeof lang && (lang = Knodule.language || "EN"), cloud = !1) : cloud && "string" != typeof lang && (lang = Knodule.language || "EN");
        var valstring = "string" == typeof arg && arg || arg._qid || arg.getQID && arg.getQID() || "" + arg, checkbox = varname && fdjtDOM({
            tagName: "INPUT",
            type: "CHECKBOX",
            name: varname,
            value: valstring
        }), text = "string" == typeof arg && arg || fdjtDOM("span.term", valstring), variations = arg instanceof KNode && fdjtDOM("span.variations"), israw = "string" == typeof arg, span = fdjtDOM(israw ? "span.rawterm" : "span.dterm", checkbox, " ", variations, israw ? fdjtDOM("span.termtext", "“" + text + "”") : text);
        return (lang || cloud) && (addClass(span, "completion"), span.setAttribute("data-value", valstring)), 
        "string" == typeof arg ? (span.setAttribute("data-key", arg), cloud && cloud.addCompletion(span), 
        span) : arg._live ? (init(), span) : (arg.onLoad(init), span);
    }
    function knodeToOption(arg) {
        var option;
        if ("string" == typeof arg) return option = fdjtDOM("OPTION", arg), option.setAttribute("value", arg), 
        option;
        var dterm = arg.dterm, valstring = "string" == typeof arg && arg || arg._qid || arg.getQID && arg.getQID() || "" + arg, options = document.createDocumentFragment();
        return option = fdjtDOM("option", dterm), option.setAttribute("value", valstring), 
        options.appendChild(option), options;
    }
    function knoduleLoad(elt, knodule) {
        var src = "string" == typeof elt ? elt : elt.src, text = fdjtAjax.getText(src), knowdes = knodule.handleEntries(text);
        (knodule.trace_load || Knodule.trace_load) && fdjtLog("Parsed %d entries from %s", knowdes.length, elt.src);
    }
    function knoduleSetupHTML(knodule) {
        knodule || (knodule = new Knodule(document.location.href));
        var lim, elt, start = new Date(), elts = fdjtDOM.getLinks("{http://knodules.org/}knodule", !0, !0), i = 0;
        for (elts && elts.length || (elts = fdjtDOM.getLinks("knodule", !0, !0)), elts && elts.length || (elts = fdjtDOM.getLinks("*.knodule", !0, !0)), 
        i = 0, lim = elts.length; lim > i; ) knoduleLoad(elts[i++], knodule);
        for (elts = fdjtDOM.getMeta("knodef"), i = 0, lim = elts.length; elts.length > i; ) knodule.handleEntry(elts[i++].content);
        for (elts = document.getElementsByTagName("META"), i = 0, lim = elts.length; lim > i; ) elt = elts[i++], 
        "KNODEF" === elt.name && knodule.handleEntry(elt.content);
        for (elts = document.getElementsByTagName("SCRIPT"), i = 0, lim = elts.length; lim > i; ) {
            elt = elts[i++];
            var lang = elt.getAttribute("language"), type = elt.type;
            if ("text/knodule" === type || "application/knodule" === type || lang && ("knodule" === lang || "KNODULE" === lang || "knowlet" === lang || "KNOWLET" === lang)) if (elt.src) knoduleLoad(elt, knodule); else if (elt.text) {
                var txt = elt.text, cdata = txt.search("<!\\[CDATA\\[");
                if (cdata >= 0) {
                    var cdend = txt.search("]]>");
                    txt = txt.slice(cdata + 9, cdend);
                }
                var dterms = knodule.handleEntries(txt);
                (knodule.trace_load || Knodule.trace_load) && fdjtLog("Parsed %d inline knodule entries", dterms.length);
            }
        }
        var finished = new Date();
        (knodule.trace_load || Knodule.trace_load) && fdjtLog("Processed knodules in %fs", (finished.getTime() - start.getTime()) / 1e3);
    }
    var fdjtString = fdjt.String, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtAjax = fdjt.Ajax, addClass = fdjtDOM.addClass, KNode = Knodule.KNode;
    Knodule.KNode.prototype.toDOM = Knodule.KNode.prototype.toHTML = function() {
        var spec = this.prime ? "span.dterm.prime" : this.weak ? "span.dterm.weak" : "span.dterm", span = fdjtDOM(spec, this.dterm);
        return this.gloss && (span.title = fdjtString.strip_markup(this.gloss)), span.dterm = this.dterm, 
        span;
    }, Knodule.HTML = KNode2HTML, Knodule.KNode2HTML = KNode2HTML, Knodule.Knode2HTML = KNode2HTML, 
    Knodule.knode2HTML = KNode2HTML, Knodule.knodeToOption = knodeToOption, Knodule.HTML.Setup = knoduleSetupHTML;
}();

var idbModules = {};

(function(idbModules) {
    function callback(fn, context, event, func) {
        event.target = context, "function" == typeof context[fn] && context[fn].apply(context, [ event ]), 
        "function" == typeof func && func();
    }
    function throwDOMException(name, message, error) {
        var e = new DOMException.constructor(0, message);
        throw e.name = name, e.message = message, e.stack = arguments.callee.caller, idbModules.DEBUG && console.log(name, message, error, e), 
        e;
    }
    var StringList = function() {
        this.length = 0, this._items = [];
    };
    StringList.prototype = {
        contains: function(str) {
            return -1 !== this._items.indexOf(str);
        },
        item: function(key) {
            return this._items[key];
        },
        indexOf: function(str) {
            return this._items.indexOf(str);
        },
        push: function(item) {
            this._items.push(item), this.length += 1;
        },
        splice: function() {
            this._items.splice.apply(this._items, arguments), this.length = this._items.length;
        }
    }, idbModules.util = {
        throwDOMException: throwDOMException,
        callback: callback,
        quote: function(arg) {
            return "'" + arg + "'";
        },
        StringList: StringList
    };
})(idbModules), function(idbModules) {
    var Sca = function() {
        return {
            encode: function(val) {
                return JSON.stringify(val);
            },
            decode: function(val) {
                return JSON.parse(val);
            }
        };
    }();
    idbModules.Sca = Sca;
}(idbModules), function(idbModules) {
    var collations = [ "", "number", "string", "boolean", "object", "undefined" ], getGenericEncoder = function() {
        return {
            encode: function(key) {
                return collations.indexOf(typeof key) + "-" + JSON.stringify(key);
            },
            decode: function(key) {
                return key === void 0 ? void 0 : JSON.parse(key.substring(2));
            }
        };
    }, types = {
        number: getGenericEncoder("number"),
        "boolean": getGenericEncoder(),
        object: getGenericEncoder(),
        string: {
            encode: function(key) {
                return collations.indexOf("string") + "-" + key;
            },
            decode: function(key) {
                return "" + key.substring(2);
            }
        },
        undefined: {
            encode: function() {
                return collations.indexOf("undefined") + "-undefined";
            },
            decode: function() {
                return void 0;
            }
        }
    }, Key = function() {
        return {
            encode: function(key) {
                return types[typeof key].encode(key);
            },
            decode: function(key) {
                return types[collations[key.substring(0, 1)]].decode(key);
            }
        };
    }();
    idbModules.Key = Key;
}(idbModules), function(idbModules) {
    var Event = function(type, debug) {
        return {
            type: type,
            debug: debug,
            bubbles: !1,
            cancelable: !1,
            eventPhase: 0,
            timeStamp: new Date()
        };
    };
    idbModules.Event = Event;
}(idbModules), function(idbModules) {
    var IDBRequest = function() {
        this.onsuccess = this.onerror = this.result = this.error = this.source = this.transaction = null, 
        this.readyState = "pending";
    }, IDBOpenRequest = function() {
        this.onblocked = this.onupgradeneeded = null;
    };
    IDBOpenRequest.prototype = IDBRequest, idbModules.IDBRequest = IDBRequest, idbModules.IDBOpenRequest = IDBOpenRequest;
}(idbModules), function(idbModules, undefined) {
    var IDBKeyRange = function(lower, upper, lowerOpen, upperOpen) {
        this.lower = lower, this.upper = upper, this.lowerOpen = lowerOpen, this.upperOpen = upperOpen;
    };
    IDBKeyRange.only = function(value) {
        return new IDBKeyRange(value, value, !0, !0);
    }, IDBKeyRange.lowerBound = function(value, open) {
        return new IDBKeyRange(value, undefined, open, undefined);
    }, IDBKeyRange.upperBound = function(value) {
        return new IDBKeyRange(undefined, value, undefined, open);
    }, IDBKeyRange.bound = function(lower, upper, lowerOpen, upperOpen) {
        return new IDBKeyRange(lower, upper, lowerOpen, upperOpen);
    }, idbModules.IDBKeyRange = IDBKeyRange;
}(idbModules), function(idbModules, undefined) {
    function IDBCursor(range, direction, idbObjectStore, cursorRequest, keyColumnName, valueColumnName) {
        this.__range = range, this.source = this.__idbObjectStore = idbObjectStore, this.__req = cursorRequest, 
        this.key = undefined, this.direction = direction, this.__keyColumnName = keyColumnName, 
        this.__valueColumnName = valueColumnName, this.source.transaction.__active || idbModules.util.throwDOMException("TransactionInactiveError - The transaction this IDBObjectStore belongs to is not active."), 
        this.__offset = -1, this.__lastKeyContinued = undefined, this["continue"]();
    }
    IDBCursor.prototype.__find = function(key, tx, success, error) {
        var me = this, sql = [ "SELECT * FROM ", idbModules.util.quote(me.__idbObjectStore.name) ], sqlValues = [];
        sql.push("WHERE ", me.__keyColumnName, " NOT NULL"), me.__range && (me.__range.lower || me.__range.upper) && (sql.push("AND"), 
        me.__range.lower && (sql.push(me.__keyColumnName + (me.__range.lowerOpen ? " >=" : " >") + " ?"), 
        sqlValues.push(idbModules.Key.encode(me.__range.lower))), me.__range.lower && me.__range.upper && sql.push("AND"), 
        me.__range.upper && (sql.push(me.__keyColumnName + (me.__range.upperOpen ? " <= " : " < ") + " ?"), 
        sqlValues.push(idbModules.Key.encode(me.__range.upper)))), key !== undefined && (me.__lastKeyContinued = key, 
        me.__offset = 0), me.__lastKeyContinued !== undefined && (sql.push("AND " + me.__keyColumnName + " >= ?"), 
        sqlValues.push(idbModules.Key.encode(me.__lastKeyContinued))), sql.push("ORDER BY ", me.__keyColumnName), 
        sql.push("LIMIT 1 OFFSET " + me.__offset), idbModules.DEBUG && console.log(sql.join(" "), sqlValues), 
        tx.executeSql(sql.join(" "), sqlValues, function(tx, data) {
            if (1 === data.rows.length) {
                var key = idbModules.Key.decode(data.rows.item(0)[me.__keyColumnName]), val = "value" === me.__valueColumnName ? idbModules.Sca.decode(data.rows.item(0)[me.__valueColumnName]) : idbModules.Key.decode(data.rows.item(0)[me.__valueColumnName]);
                success(key, val);
            } else idbModules.DEBUG && console.log("Reached end of cursors"), success(undefined, undefined);
        }, function(tx, data) {
            idbModules.DEBUG && console.log("Could not execute Cursor.continue"), error(data);
        });
    }, IDBCursor.prototype["continue"] = function(key) {
        var me = this;
        this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__offset++, me.__find(key, tx, function(key, val) {
                me.key = key, me.value = val, success(me.key !== undefined ? me : undefined, me.__req);
            }, function(data) {
                error(data);
            });
        });
    }, IDBCursor.prototype.advance = function(count) {
        0 >= count && idbModules.util.throwDOMException("Type Error - Count is invalid - 0 or negative", count);
        var me = this;
        this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__offset += count, me.__find(undefined, tx, function(key, value) {
                me.key = key, me.value = value, success(me.key !== undefined ? me : undefined, me.__req);
            }, function(data) {
                error(data);
            });
        });
    }, IDBCursor.prototype.update = function(valueToUpdate) {
        var me = this;
        return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__find(undefined, tx, function(key) {
                var sql = "UPDATE " + idbModules.util.quote(me.__idbObjectStore.name) + " SET value = ? WHERE key = ?";
                idbModules.DEBUG && console.log(sql, valueToUpdate, key), tx.executeSql(sql, [ idbModules.Sca.encode(valueToUpdate), idbModules.Key.encode(key) ], function(tx, data) {
                    1 === data.rowsAffected ? success(key) : error("No rowns with key found" + key);
                }, function(tx, data) {
                    error(data);
                });
            }, function(data) {
                error(data);
            });
        });
    }, IDBCursor.prototype["delete"] = function() {
        var me = this;
        return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__find(undefined, tx, function(key) {
                var sql = "DELETE FROM  " + idbModules.util.quote(me.__idbObjectStore.name) + " WHERE key = ?";
                idbModules.DEBUG && console.log(sql, key), tx.executeSql(sql, [ idbModules.Key.encode(key) ], function(tx, data) {
                    1 === data.rowsAffected ? success(undefined) : error("No rowns with key found" + key);
                }, function(tx, data) {
                    error(data);
                });
            }, function(data) {
                error(data);
            });
        });
    }, idbModules.IDBCursor = IDBCursor;
}(idbModules), function(idbModules, undefined) {
    function IDBIndex(indexName, idbObjectStore) {
        this.indexName = indexName, this.__idbObjectStore = this.source = idbObjectStore;
    }
    IDBIndex.prototype.__createIndex = function(indexName, keyPath, optionalParameters) {
        var me = this, transaction = me.__idbObjectStore.transaction;
        transaction.__addToTransactionQueue(function(tx, args, success, failure) {
            me.__idbObjectStore.__getStoreProps(tx, function() {
                function error() {
                    idbModules.util.throwDOMException(0, "Could not create new index", arguments);
                }
                2 !== transaction.mode && idbModules.util.throwDOMException(0, "Invalid State error, not a version transaction", me.transaction);
                var idxList = JSON.parse(me.__idbObjectStore.__storeProps.indexList);
                idxList[indexName] !== undefined && idbModules.util.throwDOMException(0, "Index already exists on store", idxList);
                var columnName = indexName;
                idxList[indexName] = {
                    columnName: columnName,
                    keyPath: keyPath,
                    optionalParams: optionalParameters
                }, me.__idbObjectStore.__storeProps.indexList = JSON.stringify(idxList);
                var sql = [ "ALTER TABLE", idbModules.util.quote(me.__idbObjectStore.name), "ADD", columnName, "BLOB" ].join(" ");
                idbModules.DEBUG && console.log(sql), tx.executeSql(sql, [], function(tx, data) {
                    tx.executeSql("SELECT * FROM " + idbModules.util.quote(me.__idbObjectStore.name), [], function(tx, data) {
                        (function initIndexForRow(i) {
                            if (data.rows.length > i) try {
                                var value = idbModules.Sca.decode(data.rows.item(i).value), indexKey = eval("value['" + keyPath + "']");
                                tx.executeSql("UPDATE " + idbModules.util.quote(me.__idbObjectStore.name) + " set " + columnName + " = ? where key = ?", [ idbModules.Key.encode(indexKey), data.rows.item(i).key ], function() {
                                    initIndexForRow(i + 1);
                                }, error);
                            } catch (e) {
                                initIndexForRow(i + 1);
                            } else idbModules.DEBUG && console.log("Updating the indexes in table", me.__idbObjectStore.__storeProps), 
                            tx.executeSql("UPDATE __sys__ set indexList = ? where name = ?", [ me.__idbObjectStore.__storeProps.indexList, me.__idbObjectStore.name ], function() {
                                me.__idbObjectStore.__setReadyState("createIndex", !0), success(me);
                            }, error);
                        })(0);
                    }, error);
                }, error);
            }, "createObjectStore");
        });
    }, IDBIndex.prototype.openCursor = function(range, direction) {
        var cursorRequest = new idbModules.IDBRequest();
        return new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, "value"), 
        cursorRequest;
    }, IDBIndex.prototype.openKeyCursor = function(range, direction) {
        var cursorRequest = new idbModules.IDBRequest();
        return new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, "key"), 
        cursorRequest;
    }, IDBIndex.prototype.__fetchIndexData = function(key, opType) {
        var me = this;
        return me.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            var sql = [ "SELECT * FROM ", idbModules.util.quote(me.__idbObjectStore.name), " WHERE", me.indexName, "NOT NULL" ], sqlValues = [];
            key !== undefined && (sql.push("AND", me.indexName, " = ?"), sqlValues.push(idbModules.Key.encode(key))), 
            idbModules.DEBUG && console.log("Trying to fetch data for Index", sql.join(" "), sqlValues), 
            tx.executeSql(sql.join(" "), sqlValues, function(tx, data) {
                var d;
                d = "count" == typeof opType ? data.rows.length : 0 === data.rows.length ? undefined : "key" === opType ? idbModules.Key.decode(data.rows.item(0).key) : idbModules.Sca.decode(data.rows.item(0).value), 
                success(d);
            }, error);
        });
    }, IDBIndex.prototype.get = function(key) {
        return this.__fetchIndexData(key, "value");
    }, IDBIndex.prototype.getKey = function(key) {
        return this.__fetchIndexData(key, "key");
    }, IDBIndex.prototype.count = function(key) {
        return this.__fetchIndexData(key, "count");
    }, idbModules.IDBIndex = IDBIndex;
}(idbModules), function(idbModules) {
    var IDBObjectStore = function(name, idbTransaction, ready) {
        this.name = name, this.transaction = idbTransaction, this.__ready = {}, this.__setReadyState("createObjectStore", ready === void 0 ? !0 : ready), 
        this.indexNames = new idbModules.util.StringList();
    };
    IDBObjectStore.prototype.__setReadyState = function(key, val) {
        this.__ready[key] = val;
    }, IDBObjectStore.prototype.__waitForReady = function(callback, key) {
        var ready = !0;
        if (key !== void 0) ready = this.__ready[key] === void 0 ? !0 : this.__ready[key]; else for (var x in this.__ready) this.__ready[x] || (ready = !1);
        if (ready) callback(); else {
            idbModules.DEBUG && console.log("Waiting for to be ready", key);
            var me = this;
            window.setTimeout(function() {
                me.__waitForReady(callback, key);
            }, 100);
        }
    }, IDBObjectStore.prototype.__getStoreProps = function(tx, callback, waitOnProperty) {
        var me = this;
        this.__waitForReady(function() {
            me.__storeProps ? (idbModules.DEBUG && console.log("Store properties - cached", me.__storeProps), 
            callback(me.__storeProps)) : tx.executeSql("SELECT * FROM __sys__ where name = ?", [ me.name ], function(tx, data) {
                1 !== data.rows.length ? callback() : (me.__storeProps = {
                    name: data.rows.item(0).name,
                    indexList: data.rows.item(0).indexList,
                    autoInc: data.rows.item(0).autoInc,
                    keyPath: data.rows.item(0).keyPath
                }, idbModules.DEBUG && console.log("Store properties", me.__storeProps), callback(me.__storeProps));
            }, function() {
                callback();
            });
        }, waitOnProperty);
    }, IDBObjectStore.prototype.__deriveKey = function(tx, value, key, callback) {
        function getNextAutoIncKey() {
            tx.executeSql("SELECT * FROM sqlite_sequence where name like ?", [ me.name ], function(tx, data) {
                1 !== data.rows.length ? callback(0) : callback(data.rows.item(0).seq);
            }, function(tx, error) {
                idbModules.util.throwDOMException(0, "Data Error - Could not get the auto increment value for key", error);
            });
        }
        var me = this;
        me.__getStoreProps(tx, function(props) {
            if (props || idbModules.util.throwDOMException(0, "Data Error - Could not locate defination for this table", props), 
            props.keyPath) if (key !== void 0 && idbModules.util.throwDOMException(0, "Data Error - The object store uses in-line keys and the key parameter was provided", props), 
            value) try {
                var primaryKey = eval("value['" + props.keyPath + "']");
                primaryKey ? callback(primaryKey) : "true" === props.autoInc ? getNextAutoIncKey() : idbModules.util.throwDOMException(0, "Data Error - Could not eval key from keyPath");
            } catch (e) {
                idbModules.util.throwDOMException(0, "Data Error - Could not eval key from keyPath", e);
            } else idbModules.util.throwDOMException(0, "Data Error - KeyPath was specified, but value was not"); else key !== void 0 ? callback(key) : "false" === props.autoInc ? idbModules.util.throwDOMException(0, "Data Error - The object store uses out-of-line keys and has no key generator and the key parameter was not provided. ", props) : getNextAutoIncKey();
        });
    }, IDBObjectStore.prototype.__insertData = function(tx, value, primaryKey, success, error) {
        var paramMap = {};
        primaryKey !== void 0 && (paramMap.key = idbModules.Key.encode(primaryKey));
        var indexes = JSON.parse(this.__storeProps.indexList);
        for (var key in indexes) try {
            paramMap[indexes[key].columnName] = idbModules.Key.encode(eval("value['" + indexes[key].keyPath + "']"));
        } catch (e) {
            error(e);
        }
        var sqlStart = [ "INSERT INTO ", idbModules.util.quote(this.name), "(" ], sqlEnd = [ " VALUES (" ], sqlValues = [];
        for (key in paramMap) sqlStart.push(key + ","), sqlEnd.push("?,"), sqlValues.push(paramMap[key]);
        sqlStart.push("value )"), sqlEnd.push("?)"), sqlValues.push(idbModules.Sca.encode(value));
        var sql = sqlStart.join(" ") + sqlEnd.join(" ");
        idbModules.DEBUG && console.log("SQL for adding", sql, sqlValues), tx.executeSql(sql, sqlValues, function() {
            success(primaryKey);
        }, function(tx, err) {
            error(err);
        });
    }, IDBObjectStore.prototype.add = function(value, key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__deriveKey(tx, value, key, function(primaryKey) {
                me.__insertData(tx, value, primaryKey, success, error);
            });
        });
    }, IDBObjectStore.prototype.put = function(value, key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__deriveKey(tx, value, key, function(primaryKey) {
                var sql = "DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?";
                tx.executeSql(sql, [ idbModules.Key.encode(primaryKey) ], function(tx, data) {
                    idbModules.DEBUG && console.log("Did the row with the", primaryKey, "exist? ", data.rowsAffected), 
                    me.__insertData(tx, value, primaryKey, success, error);
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.get = function(key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                var primaryKey = idbModules.Key.encode(key);
                idbModules.DEBUG && console.log("Fetching", me.name, primaryKey), tx.executeSql("SELECT * FROM " + idbModules.util.quote(me.name) + " where key = ?", [ primaryKey ], function(tx, data) {
                    idbModules.DEBUG && console.log("Fetched data", data);
                    try {
                        if (0 === data.rows.length) return success();
                        success(idbModules.Sca.decode(data.rows.item(0).value));
                    } catch (e) {
                        idbModules.DEBUG && console.log(e), success(void 0);
                    }
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype["delete"] = function(key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                var primaryKey = idbModules.Key.encode(key);
                idbModules.DEBUG && console.log("Fetching", me.name, primaryKey), tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?", [ primaryKey ], function(tx, data) {
                    idbModules.DEBUG && console.log("Deleted from database", data.rowsAffected), success();
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.clear = function() {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name), [], function(tx, data) {
                    idbModules.DEBUG && console.log("Cleared all records from database", data.rowsAffected), 
                    success();
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.count = function(key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                var sql = "SELECT * FROM " + idbModules.util.quote(me.name) + (key !== void 0 ? " WHERE key = ?" : ""), sqlValues = [];
                key !== void 0 && sqlValues.push(idbModules.Key.encode(key)), tx.executeSql(sql, sqlValues, function(tx, data) {
                    success(data.rows.length);
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.openCursor = function(range, direction) {
        var cursorRequest = new idbModules.IDBRequest();
        return new idbModules.IDBCursor(range, direction, this, cursorRequest, "key", "value"), 
        cursorRequest;
    }, IDBObjectStore.prototype.index = function(indexName) {
        var index = new idbModules.IDBIndex(indexName, this);
        return index;
    }, IDBObjectStore.prototype.createIndex = function(indexName, keyPath, optionalParameters) {
        var me = this;
        optionalParameters = optionalParameters || {}, me.__setReadyState("createIndex", !1);
        var result = new idbModules.IDBIndex(indexName, me);
        return me.__waitForReady(function() {
            result.__createIndex(indexName, keyPath, optionalParameters);
        }, "createObjectStore"), me.indexNames.push(indexName), result;
    }, IDBObjectStore.prototype.deleteIndex = function(indexName) {
        var result = new idbModules.IDBIndex(indexName, this, !1);
        return result.__deleteIndex(indexName), result;
    }, idbModules.IDBObjectStore = IDBObjectStore;
}(idbModules), function(idbModules) {
    var READ = 0, READ_WRITE = 1, VERSION_TRANSACTION = 2, IDBTransaction = function(storeNames, mode, db) {
        if ("number" == typeof mode) this.mode = mode, 2 !== mode && idbModules.DEBUG && console.log("Mode should be a string, but was specified as ", mode); else if ("string" == typeof mode) switch (mode) {
          case "readonly":
            this.mode = READ_WRITE;
            break;

          case "readwrite":
            this.mode = READ;
            break;

          default:
            this.mode = READ;
        }
        this.storeNames = "string" == typeof storeNames ? [ storeNames ] : storeNames;
        for (var i = 0; this.storeNames.length > i; i++) db.objectStoreNames.contains(this.storeNames[i]) || idbModules.util.throwDOMException(0, "The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.", this.storeNames[i]);
        this.__active = !0, this.__running = !1, this.__requests = [], this.__aborted = !1, 
        this.db = db, this.error = null, this.onabort = this.onerror = this.oncomplete = null;
    };
    IDBTransaction.prototype.__executeRequests = function() {
        if (this.__running && this.mode !== VERSION_TRANSACTION) return idbModules.DEBUG && console.log("Looks like the request set is already running", this.mode), 
        void 0;
        this.__running = !0;
        var me = this;
        window.setTimeout(function() {
            2 === me.mode || me.__active || idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished", me.__active), 
            me.db.__db.transaction(function(tx) {
                function success(result, req) {
                    req && (q.req = req), q.req.readyState = "done", q.req.result = result, delete q.req.error;
                    var e = idbModules.Event("success");
                    idbModules.util.callback("onsuccess", q.req, e), i++, executeRequest();
                }
                function error() {
                    q.req.readyState = "done", q.req.error = "DOMError";
                    var e = idbModules.Event("error", arguments);
                    idbModules.util.callback("onerror", q.req, e), i++, executeRequest();
                }
                function executeRequest() {
                    return i >= me.__requests.length ? (me.__active = !1, me.__requests = [], void 0) : (q = me.__requests[i], 
                    q.op(tx, q.args, success, error), void 0);
                }
                me.__tx = tx;
                var q = null, i = 0;
                try {
                    executeRequest();
                } catch (e) {
                    idbModules.DEBUG && console.log("An exception occured in transaction", arguments), 
                    "function" == typeof me.onerror && me.onerror();
                }
            }, function() {
                idbModules.DEBUG && console.log("An error in transaction", arguments), "function" == typeof me.onerror && me.onerror();
            }, function() {
                idbModules.DEBUG && console.log("Transaction completed", arguments), "function" == typeof me.oncomplete && me.oncomplete();
            });
        }, 1);
    }, IDBTransaction.prototype.__addToTransactionQueue = function(callback, args) {
        this.__active || this.mode === VERSION_TRANSACTION || idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished.", this.__mode);
        var request = new idbModules.IDBRequest();
        return request.source = this.db, this.__requests.push({
            op: callback,
            args: args,
            req: request
        }), this.__executeRequests(), request;
    }, IDBTransaction.prototype.objectStore = function(objectStoreName) {
        return new idbModules.IDBObjectStore(objectStoreName, this);
    }, IDBTransaction.prototype.abort = function() {
        !this.__active && idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished", this.__active);
    }, IDBTransaction.prototype.READ_ONLY = 0, IDBTransaction.prototype.READ_WRITE = 1, 
    IDBTransaction.prototype.VERSION_CHANGE = 2, idbModules.IDBTransaction = IDBTransaction;
}(idbModules), function(idbModules) {
    var IDBDatabase = function(db, name, version, storeProperties) {
        this.__db = db, this.version = version, this.__storeProperties = storeProperties, 
        this.objectStoreNames = new idbModules.util.StringList();
        for (var i = 0; storeProperties.rows.length > i; i++) this.objectStoreNames.push(storeProperties.rows.item(i).name);
        this.name = name, this.onabort = this.onerror = this.onversionchange = null;
    };
    IDBDatabase.prototype.createObjectStore = function(storeName, createOptions) {
        var me = this;
        createOptions = createOptions || {}, createOptions.keyPath = createOptions.keyPath || null;
        var result = new idbModules.IDBObjectStore(storeName, me.__versionTransaction, !1), transaction = me.__versionTransaction;
        return transaction.__addToTransactionQueue(function(tx, args, success) {
            function error() {
                idbModules.util.throwDOMException(0, "Could not create new object store", arguments);
            }
            me.__versionTransaction || idbModules.util.throwDOMException(0, "Invalid State error", me.transaction);
            var sql = [ "CREATE TABLE", idbModules.util.quote(storeName), "(key BLOB", createOptions.autoIncrement ? ", inc INTEGER PRIMARY KEY AUTOINCREMENT" : "PRIMARY KEY", ", value BLOB)" ].join(" ");
            idbModules.DEBUG && console.log(sql), tx.executeSql(sql, [], function(tx) {
                tx.executeSql("INSERT INTO __sys__ VALUES (?,?,?,?)", [ storeName, createOptions.keyPath, createOptions.autoIncrement ? !0 : !1, "{}" ], function() {
                    result.__setReadyState("createObjectStore", !0), success(result);
                }, error);
            }, error);
        }), me.objectStoreNames.push(storeName), result;
    }, IDBDatabase.prototype.deleteObjectStore = function(storeName) {
        var error = function() {
            idbModules.util.throwDOMException(0, "Could not delete ObjectStore", arguments);
        }, me = this;
        !me.objectStoreNames.contains(storeName) && error("Object Store does not exist"), 
        me.objectStoreNames.splice(me.objectStoreNames.indexOf(storeName), 1);
        var transaction = me.__versionTransaction;
        transaction.__addToTransactionQueue(function() {
            me.__versionTransaction || idbModules.util.throwDOMException(0, "Invalid State error", me.transaction), 
            me.__db.transaction(function(tx) {
                tx.executeSql("SELECT * FROM __sys__ where name = ?", [ storeName ], function(tx, data) {
                    data.rows.length > 0 && tx.executeSql("DROP TABLE " + idbModules.util.quote(storeName), [], function() {
                        tx.executeSql("DELETE FROM __sys__ WHERE name = ?", [ storeName ], function() {}, error);
                    }, error);
                });
            });
        });
    }, IDBDatabase.prototype.close = function() {}, IDBDatabase.prototype.transaction = function(storeNames, mode) {
        var transaction = new idbModules.IDBTransaction(storeNames, mode || 1, this);
        return transaction;
    }, idbModules.IDBDatabase = IDBDatabase;
}(idbModules), function(idbModules) {
    var DEFAULT_DB_SIZE = 4194304;
    if (window.openDatabase) {
        var sysdb = window.openDatabase("__sysdb__", 1, "System Database", DEFAULT_DB_SIZE);
        sysdb.transaction(function(tx) {
            tx.executeSql("SELECT * FROM dbVersions", [], function() {}, function() {
                sysdb.transaction(function(tx) {
                    tx.executeSql("CREATE TABLE IF NOT EXISTS dbVersions (name VARCHAR(255), version INT);", [], function() {}, function() {
                        idbModules.util.throwDOMException("Could not create table __sysdb__ to save DB versions");
                    });
                });
            });
        }, function() {
            idbModules.DEBUG && console.log("Error in sysdb transaction - when selecting from dbVersions", arguments);
        });
        var shimIndexedDB = {
            open: function(name, version) {
                function dbCreateError() {
                    if (!calledDbCreateError) {
                        var e = idbModules.Event("error", arguments);
                        req.readyState = "done", req.error = "DOMError", idbModules.util.callback("onerror", req, e), 
                        calledDbCreateError = !0;
                    }
                }
                function openDB(oldVersion) {
                    var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
                    req.readyState = "done", version === void 0 && (version = oldVersion || 1), (0 >= version || oldVersion > version) && idbModules.util.throwDOMException(0, "An attempt was made to open a database using a lower version than the existing version.", version), 
                    db.transaction(function(tx) {
                        tx.executeSql("CREATE TABLE IF NOT EXISTS __sys__ (name VARCHAR(255), keyPath VARCHAR(255), autoInc BOOLEAN, indexList BLOB)", [], function() {
                            tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
                                var e = idbModules.Event("success");
                                req.source = req.result = new idbModules.IDBDatabase(db, name, version, data), version > oldVersion ? sysdb.transaction(function(systx) {
                                    systx.executeSql("UPDATE dbVersions set version = ? where name = ?", [ version, name ], function() {
                                        var e = idbModules.Event("upgradeneeded");
                                        e.oldVersion = oldVersion, e.newVersion = version, req.transaction = req.result.__versionTransaction = new idbModules.IDBTransaction([], 2, req.source), 
                                        idbModules.util.callback("onupgradeneeded", req, e, function() {
                                            var e = idbModules.Event("success");
                                            idbModules.util.callback("onsuccess", req, e);
                                        });
                                    }, dbCreateError);
                                }, dbCreateError) : idbModules.util.callback("onsuccess", req, e);
                            }, dbCreateError);
                        }, dbCreateError);
                    }, dbCreateError);
                }
                var req = new idbModules.IDBOpenRequest(), calledDbCreateError = !1;
                return sysdb.transaction(function(tx) {
                    tx.executeSql("SELECT * FROM dbVersions where name = ?", [ name ], function(tx, data) {
                        0 === data.rows.length ? tx.executeSql("INSERT INTO dbVersions VALUES (?,?)", [ name, version || 1 ], function() {
                            openDB(0);
                        }, dbCreateError) : openDB(data.rows.item(0).version);
                    }, dbCreateError);
                }, dbCreateError), req;
            },
            deleteDatabase: function(name) {
                function dbError(msg) {
                    if (!calledDBError) {
                        req.readyState = "done", req.error = "DOMError";
                        var e = idbModules.Event("error");
                        e.message = msg, e.debug = arguments, idbModules.util.callback("onerror", req, e), 
                        calledDBError = !0;
                    }
                }
                function deleteFromDbVersions() {
                    sysdb.transaction(function(systx) {
                        systx.executeSql("DELETE FROM dbVersions where name = ? ", [ name ], function() {
                            req.result = void 0;
                            var e = idbModules.Event("success");
                            e.newVersion = null, e.oldVersion = version, idbModules.util.callback("onsuccess", req, e);
                        }, dbError);
                    }, dbError);
                }
                var req = new idbModules.IDBOpenRequest(), calledDBError = !1, version = null;
                return sysdb.transaction(function(systx) {
                    systx.executeSql("SELECT * FROM dbVersions where name = ?", [ name ], function(tx, data) {
                        if (0 === data.rows.length) {
                            req.result = void 0;
                            var e = idbModules.Event("success");
                            return e.newVersion = null, e.oldVersion = version, idbModules.util.callback("onsuccess", req, e), 
                            void 0;
                        }
                        version = data.rows.item(0).version;
                        var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
                        db.transaction(function(tx) {
                            tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
                                var tables = data.rows;
                                (function deleteTables(i) {
                                    i >= tables.length ? tx.executeSql("DROP TABLE __sys__", [], function() {
                                        deleteFromDbVersions();
                                    }, dbError) : tx.executeSql("DROP TABLE " + idbModules.util.quote(tables.item(i).name), [], function() {
                                        deleteTables(i + 1);
                                    }, function() {
                                        deleteTables(i + 1);
                                    });
                                })(0);
                            }, function() {
                                deleteFromDbVersions();
                            });
                        }, dbError);
                    });
                }, dbError), req;
            },
            cmp: function(key1, key2) {
                return idbModules.Key.encode(key1) > idbModules.Key.encode(key2) ? 1 : key1 === key2 ? 0 : -1;
            }
        };
        idbModules.shimIndexedDB = shimIndexedDB;
    }
}(idbModules), function(window, idbModules) {
    window.openDatabase !== void 0 && (window.shimIndexedDB = idbModules.shimIndexedDB, 
    window.shimIndexedDB && (window.shimIndexedDB.__useShim = function() {
        window.indexedDB = idbModules.shimIndexedDB, window.IDBDatabase = idbModules.IDBDatabase, 
        window.IDBTransaction = idbModules.IDBTransaction, window.IDBCursor = idbModules.IDBCursor, 
        window.IDBKeyRange = idbModules.IDBKeyRange;
    }, window.shimIndexedDB.__debug = function(val) {
        idbModules.DEBUG = val;
    })), window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB, 
    window.indexedDB === void 0 && window.openDatabase !== void 0 ? window.shimIndexedDB.__useShim() : (window.IDBDatabase = window.IDBDatabase || window.webkitIDBDatabase, 
    window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction, window.IDBCursor = window.IDBCursor || window.webkitIDBCursor, 
    window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange, window.IDBTransaction.READ_ONLY = window.IDBTransaction.READ_ONLY || "readonly", 
    window.IDBTransaction.READ_WRITE = window.IDBTransaction.READ_WRITE || "readwrite");
}(window, idbModules), fdjt.CodexLayout = function() {
    "use strict";
    function appendChildren(node, children, start, end) {
        for (var lim = end || children.length, i = start || 0, frag = document.createDocumentFragment(); lim > i; ) {
            var child = children[i++];
            child ? 3 === child.nodeType && 0 === child.nodeValue.length || frag.appendChild(child) : i++;
        }
        node.appendChild(frag);
    }
    function isEmpty(string) {
        if ("string" == typeof string) {
            var pt;
            return 0 === string.length ? !0 : (pt = string.search(notspace), 0 > pt ? !0 : "&" !== string[pt] ? !1 : (string = string.replace(/&nbsp;/g, " "), 
            pt = string.search(notspace), 0 > pt));
        }
        return !1;
    }
    function inFlow(node) {
        var style = getStyle(node);
        return "none" === style.display || "static" !== style.position && "" !== style.position ? !1 : node;
    }
    function optimizeLayoutRule(rule) {
        if (rule) {
            if ("string" == typeof rule) return "." === rule[0] && 0 > rule.slice(1).search(/\.|#|\[/) ? RegExp("\\b" + rule.slice(1) + "\\b") : new fdjtDOM.Selector(rule);
            if (rule instanceof RegExp) return rule;
            if (rule.match) return rule;
            if (rule.length) {
                for (var newrules = [], firstrules = [], classes = [], selectors = [], i = 0, lim = rule.length; lim > i; ) {
                    var r = rule[i++];
                    "string" != typeof r ? newrules.push(r) : "." === r[0] ? r.slice(1).search(/\.|#|\[/) >= 0 ? selectors.push(r) : classes.push(r.slice(1)) : "#" === r[0] || "[" === r[0] ? selectors.push(r) : classes.push(r);
                }
                return classes.length && firstrules.push(RegExp("\\b(" + classes.join("|") + ")\\b")), 
                selectors.length && firstrules.push(new fdjtDOM.Selector(selectors.join(", "))), 
                firstrules.concat(newrules);
            }
            return rule;
        }
        return rule;
    }
    function testNode(node, test) {
        var tests;
        if (!test) return !0;
        tests = "string" == typeof test ? [ test ] : test instanceof Array ? test : [ test ];
        for (var i = 0, lim = tests.length; lim > i; ) {
            var atest = tests[i++];
            if (node === test) return !0;
            if (atest instanceof RegExp) {
                if (!node.className) continue;
                if (!node.className.search) continue;
                if (node.className.search(atest) >= 0) return !0;
            } else if ("string" == typeof atest) {
                if (!node.className) continue;
                if (!node.className.search) continue;
                "." === atest[0] && (atest = atest.slice(1));
                var classrx = RegExp("\\b" + atest + "\\b");
                if (node.className.search(classrx) >= 0) return !0;
            } else if (atest.match && atest.match(node)) return !0;
        }
        return !1;
    }
    function scaleToPage(elt, width, height, leavefont) {
        if ("string" == typeof elt && (elt = fdjtID(elt)), elt && 0 !== elt.length) if (elt.nodeType) {
            if (1 !== elt.nodeType) return;
            if (hasClass(elt, "_pagescaled") || elt.getAttribute("style")) return;
            var ps = elt.getAttribute("data-pagescale") || elt.getAttribute("pagescale") || getElementValue(elt, "xdatapagescale"), psw = 1, psh = 1, style = elt.style, cstyle = getStyle(elt);
            if (style[fdjtDOM.transform] && "none" !== style[fdjtDOM.transform] && "" !== style[fdjtDOM.transform]) return;
            if (ps) {
                var psv = ps.split(/ |,|x/g);
                2 === psv.length ? (psw = parseScale(psv[0]), psh = parseScale(psv[1])) : psh = psw = parseScale(psv[0]);
            }
            var tw = width * psw, th = height * psh, w = elt.offsetWidth, h = elt.offsetHeight, sw = tw / w, sh = th / h;
            if ("IMG" === elt.tagName) style.maxHeight = style.minHeight = "inherit", style.maxWidth = style.minWidth = "inherit", 
            w = elt.offsetWidth, h = elt.offsetHeight, sw = tw / w, sh = th / h, sh > sw ? (style.width = Math.round(w * sw) + "px", 
            style.height = "auto") : (style.height = Math.round(h * sh) + "px", style.width = "auto"); else if (leavefont) {
                var wrapper = "inline" === cstyle.display ? fdjtDOM("span.codexscalewrapper") : fdjtDOM("div.codexscalewrapper");
                "inline" === cstyle.display && (style.display = "inline-block", wrapper.display = "inline-block"), 
                wrapper.style.width = tw + "px", wrapper.style.height = th + "px", elt.style[fdjtDOM.transform] = "scale(" + sw + "," + sh + ")", 
                elt.style[fdjtDOM.transformOrigin] = "left" === cstyle.textAlign ? "top left" : "right" === cstyle.textAlign ? "top right" : "top center", 
                elt.parentNode.replaceChild(wrapper, elt);
            } else adjustFontSize(elt), "inline" === cstyle.display && (style.display = "inline-block"), 
            style.width = tw + "px", style.height = th + "px";
            addClass(elt, "_pagescaled");
        } else if (elt.length) for (var i = 0, lim = elt.length; lim > i; ) scaleToPage(elt[i++], width, height, leavefont || !1);
    }
    function parseScale(s) {
        if (s.search(/%$/g) > 0) {
            var pct = parseFloat(s.slice(0, s.length - 1));
            return pct / 100;
        }
        return parseFloat(s);
    }
    function atPageTop(node, page, body) {
        body || (body = document.body);
        for (var scan = node; scan; ) {
            if (scan === page) return !0;
            if (scan === body) return !1;
            if (scan.previousSibling) if (3 === scan.previousSibling.nodeType && isEmpty(scan.previousSibling.nodeValue)) scan = scan.previousSibling; else {
                if (1 !== scan.previousSibling.nodeType || inFlow(scan.previousSibling)) break;
                scan = scan.previousSibling;
            } else scan = scan.parentNode;
        }
        return 1 === scan.nodeType && scan.className && scan.className.search && scan.className.search(/\bcodexpage\b/g) >= 0;
    }
    function dupClass(classname, dupclass, pat) {
        return pat || (pat = dupstate), classname ? 0 > classname.search(dupstate) ? classname + " " + dupclass : classname.replace(dupstate, "") + " " + dupclass : dupclass;
    }
    function dupContext(node, page, dups, crumbs) {
        if (node === document.body || "CODEXCONTENT" === node.id || hasClass(node, "codexroot") || hasClass(node, "codexpage")) return !1;
        if (hasParent(node, page)) return node;
        if (node.className && node.className.search && node.className.search(/\bcodexwraptext\b/) >= 0) return dupContext(node.parentNode, page, dups, crumbs);
        var id = node.id, baseid = node.getAttribute("data-baseid");
        id || (id = baseid);
        var duplist = dups[id], last_dup = duplist && duplist.length && duplist[duplist.length - 1];
        if (id) {
            if (duplist) for (var d = duplist.length - 1; d >= 0; ) {
                if (hasParent(duplist[d], page)) return duplist[d];
                d--;
            }
        } else id = node.id = "CODEXTMPID" + tmpid_count++;
        var copy = node.cloneNode(!1), parent = dupContext(node.parentNode, page, dups, crumbs), nodeclass = node.className && node.className.search && node.className || "", lastclass = last_dup && last_dup.className && last_dup.className.search && last_dup.className;
        return baseid && (copy.codexbaseid = baseid), duplist ? copy.className = dupClass(nodeclass, "codexdupend") : (node.className = dupClass(nodeclass, "codexdupstart", codexstate), 
        stripBottomStyles(node, !0), stripTopStyles(copy, !0), copy.className = dupClass(nodeclass, "codexdupend")), 
        nodeclass.search(/\bcodexdupend\b/g) >= 0 && (node.className = dupClass(nodeclass, "codexdup"), 
        stripBottomStyles(node, !0)), lastclass && lastclass.search(/\bcodexdupend\b/g) >= 0 && (last_dup.className = lastclass.replace(/\bcodexdupend\b/g, "codexdup"), 
        stripBottomStyles(last_dup, !0)), id && (copy.codexbaseid = id, copy.setAttribute("data-baseid", id), 
        copy.removeAttribute("id")), duplist ? duplist.push(copy) : dups[id] = [ copy ], 
        parent ? parent.appendChild(copy) : page.appendChild(copy), copy;
    }
    function stripBottomStyles(node, keep) {
        var style = node.style;
        keep && !node.hasAttribute("data-savedstyle") && node.setAttribute("data-savedstyle", style.cssText), 
        style.paddingBottom = "0px", style.borderBottomWidth = "0px", style.marginBottom = "0px";
    }
    function stripTopStyles(node, keep) {
        var style = node.style;
        keep && !node.hasAttribute("data-savedstyle") && node.setAttribute("data-savedstyle", style.cssText), 
        style.textIndent = "0px", style.paddingTop = "0px", style.borderTopWidth = "0px", 
        style.marginTop = "0px";
    }
    function getFirstContent(node) {
        for (var child = node.firstChild; child; ) {
            if (3 === child.nodeType && !isEmpty(child.nodeValue) || 1 === child.nodeType && inFlow(child)) return child;
            child = child.nextSibling;
        }
        return !1;
    }
    function moveNodeInto(arg, into, blockp, crumbs) {
        var baseclass, node = arg, weird = !1;
        if (hasParent(node, into)) return node;
        if (1 === node.nodeType) baseclass = node.className, baseclass && "string" != typeof baseclass && (weird = !0); else if (3 === node.nodeType) if (node.nodeValue.search(/\w/g) >= 0) {
            var wrapnode = fdjtDOM(blockp ? "div.codexwraptext" : "span.codexwraptext");
            node.parentNode && node.parentNode.replaceChild(wrapnode, node), wrapnode.appendChild(node), 
            baseclass = "codexwraptext", node = wrapnode;
        } else node = node.cloneNode(!0);
        if (weird) ; else if (1 === node.nodeType && hasClass(node, "codextextsplit")) ; else if (node.parentNode && (!node.id || !crumbs[node.id])) {
            node.id || (node.id = "CODEXTMPID" + tmpid_count++);
            var crumb = document.createTextNode("");
            crumbs[node.id] = crumb, node.className = baseclass ? baseclass + " codexrelocated" : "codexrelocated", 
            node.parentNode.replaceChild(crumb, node);
        }
        return into.appendChild(node), node;
    }
    function moveNode(arg, into, blockp, crumbs) {
        var node = moveNodeInto(arg, into, blockp, crumbs);
        if (into) {
            for (var dragged = [], scan = node.nextSibling; scan && !(1 === scan.nodeType && "string" == typeof scan.className && scan.className.search(/\bcodexblock\b/g) >= 0); ) dragged.push(scan), 
            scan = scan.nextSibling;
            if (into.appendChild(node), dragged.length) for (var d = 0, ndrags = dragged.length; ndrags > d; ) moveNodeInto(dragged[d++], node, !1, crumbs);
        }
        return node;
    }
    function markPageTop(node, force) {
        if (!(!force && hasClass(node, "codexpagetop") || node.namespaceURI && node.namespaceURI !== root_namespace)) {
            var nodestyle = node.getAttribute("style") || "", newstyle = nodestyle + (nodestyle ? "; " : "") + "margin-top: 0px !important;";
            if (node.hasAttribute("data-savedstyle") || node.setAttribute("data-savedstyle", nodestyle), 
            node.setAttribute("style", newstyle), addClass(node, "codexpagetop"), node.childNodes) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                if (1 === child.nodeType) {
                    var style = getStyle(child);
                    if ("static" !== style.position && "" !== style.position) ; else if (!(child.classname && child.classname.search && child.className.search(/\bfdjtskiptext\b/g) >= 0)) return markPageTop(child);
                } else if (3 === child.nodeType && !isEmpty(child.nodeValue)) return;
            }
        }
    }
    function moveNodeToPage(node, page, dups, crumbs) {
        if (hasParent(node, page)) return 1 !== node.nodeType || hasContent(page, !0, !1, node) || markPageTop(node), 
        node;
        for (var move = node, parent = move.parentNode; parent && parent !== document.body && "CODEXCONTENT" !== parent.id && !hasClass(parent, "codexroot") && !hasClass(parent, "codexpage") && move === getFirstContent(parent); ) move = parent, 
        parent = move.parentNode;
        if (!parent || parent === document.body || "CODEXCONTENT" === parent.id || hasClass(parent, "codexroot") || hasClass(parent, "codexpage")) move === node ? node = move = moveNode(node, page, !1, crumbs) : move = moveNode(move, page, !1, crumbs); else {
            var dup_parent = dupContext(parent, page, dups, crumbs);
            move === node ? node = move = moveNode(node, dup_parent || page, !1, crumbs) : move = moveNode(move, dup_parent || page, !1, crumbs);
        }
        return node && 1 === node.nodeType && !hasContent(page, !0, !1, move) && markPageTop(move), 
        node;
    }
    function restoreNode(node, info, crumbs) {
        var id = node.id;
        if (id) {
            var origin = crumbs[id];
            if (origin) {
                var parent = origin.parentNode;
                hasClass(node, /\bcodexwraptext\b/g) ? parent.replaceChild(node.childNodes[0], origin) : origin.parentNode.replaceChild(node, origin);
            }
            dropClass(node, "codexrelocated");
        }
    }
    function revertLayout(layout) {
        var lim, crumbs = layout.crumbs, now = fdjtTime(), i = 0;
        if (!(layout.reverting && 1e4 > now - layout.reverting)) {
            layout.reverting = now;
            var node, textsplits = layout.textsplits, pagescaled = toArray(layout.container.getElementsByClassName("_pagescaled"));
            for (i = 0, lim = pagescaled.length; lim > i; ) {
                var elt = pagescaled[i++], wrapper = getParent(elt, ".codexscalewrapper"), saved = elt.getAttribute("data-savedstyle");
                dropClass(elt, "_pagescaled"), saved ? elt.setAttribute("style", saved) : elt.setAttribute("style", ""), 
                wrapper && wrapper.parentNode.replaceChild(elt, wrapper);
            }
            var cantsplit = toArray(layout.container.getElementsByClassName("codexcantsplit"));
            dropClass(cantsplit, "codexcantsplit");
            var split = toArray(layout.container.getElementsByClassName("codexsplitstart"));
            for (i = 0, lim = split.length; lim > i; ) {
                node = split[i++];
                var nodeid = node.id, text = textsplits[nodeid];
                node.parentNode.replaceChild(text, node);
            }
            var shards = toArray(layout.container.getElementsByClassName("codextextsplit"));
            for (i = 0, lim = shards.length; lim > i; ) node = shards[i++], node.parentNode.removeChild(node);
            var ragged = toArray(layout.container.getElementsByClassName("codexraggedsplit"));
            dropClass(ragged, "codexraggedsplit");
            var leading = toArray(layout.container.getElementsByClassName("codexdupleading"));
            leading && leading.length && fdjtDOM.remove(leading);
            var moved = toArray(layout.container.getElementsByClassName("codexrelocated")), dupstarts = toArray(layout.container.getElementsByClassName("codexdupstart")), dupends = toArray(layout.container.getElementsByClassName("codexdupend")), dupmiddle = toArray(layout.container.getElementsByClassName("codexdup")), pagetops = toArray(layout.container.getElementsByClassName("codexpagetop"));
            if (dropClass(dupstarts, "codexdupstart"), dropClass(dupends, "codexdupend"), dropClass(dupmiddle, "codexdup"), 
            dropClass(pagetops, "codexpagetop"), moved && moved.length) for (layout.logfn("Reverting layout of %d nodes and %d split texts", moved.length, RefDB.countKeys(textsplits)), 
            i = 0, lim = moved.length; lim > i; ) restoreNode(moved[i++], layout, crumbs);
            var restyled = fdjtDOM.$("[data-savedstyle]");
            for (i = 0, lim = restyled.length; lim > i; ) {
                var rs = restyled[i++];
                if (rs.hasAttribute("data-savedstyle")) {
                    var os = rs.getAttribute("data-savedstyle");
                    os ? rs.setAttribute("style", os) : rs.removeAttribute("style"), rs.removeAttribute("data-savedstyle");
                }
            }
            fdjtDOM.unwrapChildren("div.fdjtfontwrapper", layout.container), layout.textsplits = {}, 
            layout.crumbs = {};
        }
    }
    function CodexLayout(init) {
        function noop() {}
        function moveUp(node) {
            return trace && (trace > 3 || track && track.match(node)) && logfn("Moving node %o to page %o", node, page), 
            moveNodeToPage(node, page, dups, crumbs);
        }
        function moveChildren(into, children, start, end) {
            var tomove = [];
            for (start || (start = 0), end || (end = children.length); end > start; ) tomove.push(children[start++]);
            for (start = 0, end = tomove.length; end > start; ) moveNode(tomove[start++], into, !1, crumbs);
        }
        function addContent(root, timeslice, timeskip, trace, progressfn, donefn) {
            function step() {
                var block = blocks[block_i], style = styles[block_i], info = blockinfo[block_i], terminal = info.terminal || !1, next = blocks[block_i + 1], nextinfo = blockinfo[block_i + 1], tracing = !1;
                if (block.id && (layout.lastid = block.id), block_hidden >= block_i) {
                    var show_i = block_i;
                    for (block.style.display = ""; n_blocks > show_i; ) {
                        var show_block = blocks[show_i];
                        if (!hasParent(show_block, block)) break;
                        show_block.style.display = "", show_i++;
                    }
                    block_hidden = show_i;
                }
                if (trace && block && (trace > 3 || track && track.match(block)) && (logfn("Considering block %o (#%d from %o); page=%o", block, block_i, root, page), 
                tracing = !0), handle_dragging(block, terminal, info, style), block && (block = handle_standalone(block, info, style)), 
                !block) return block_i++, void 0;
                var geom = new Geometry(block, page), lh = getLineHeight(block, style), padding_bottom = parsePX(style.paddingBottom);
                if (trace && (trace > 3 || track && track.match(block)) && logfn("Layout/geom %o %j", block, geom), 
                geom.bottom - padding_bottom > page_height || next && geom.height > 3 * lh && (page_height - geom.bottom) / page_height > .9 && geom.bottom + new Geometry(next).height > page_height && !info.avoidbreakinside && nextinfo.avoidbreakinside && nextinfo.avoidbreakinside) {
                    var use_height = page_height;
                    if (page_height >= geom.bottom - padding_bottom && (use_height = geom.bottom - padding_bottom - 2 * lh), 
                    !terminal) return tracing && logfn("Oversize non-terminal %o, continuing", block), 
                    block_i++, void 0;
                    if ((short_page_height ? geom.top > short_page_height : geom.top > use_height - 1.2 * lh) && 0 === drag.length && !info.avoidbreakbefore) block = newPage(block, info); else if (info.floating) floating.push(block), 
                    block_i++; else if (!break_blocks || info.atomic || info.avoidbreakinside || hasClass(block, "codexcantsplit")) {
                        var broken = handle_unbreakable(block, info, style, geom, tracing);
                        broken ? block = broken : block_i++;
                    } else {
                        tracing && logfn("Splitting block %o @ %o", block, page);
                        var split = splitBlock(block, info, style, use_height);
                        if (split && split !== block) return layout.prev = prev = block, layout.prevstyle = prevstyle = style, 
                        layout.previnfo = previnfo = info, blocks[block_i] = split, styles[block_i] = style = getStyle(split), 
                        blockinfo[block_i] = new BlockInfo(split, style), blockinfo[block_i].terminal = terminal, 
                        void 0;
                        geom = new Geometry(block, page), geom.bottom > page_height && (addClass(page, "codexoversize"), 
                        layout.drag = drag = [], newPage()), block_i++, layout.drag = drag = [];
                    }
                } else info.avoidbreakafter && !atPageTop(block, page) ? ((0 === drag.length || 0 > drag.indexOf(block)) && (tracing && logfn("Possibly dragging %o", block), 
                drag.push(block)), block_i++) : (layout.drag = drag = [], block_i++);
                terminal && (layout.prev = prev = block, layout.prevstyle = prevstyle = style, layout.previnfo = previnfo = info);
            }
            function gatherBlocks(root, node, blocks, info, styles, style) {
                var nodeinfo = !1;
                if (1 === node.nodeType && !(node.codexui || (style || (style = getStyle(node)), 
                "static" !== style.position && "" !== style.position || style.float && "none" !== style.float))) {
                    if (atomic && atomic.match(node) || "table-row" === style.display || "BR" !== node.tagName && "HR" !== node.tagName && avoidBreakInside(node, style)) {
                        if (node.offsetWidth > page_width) {
                            var w = node.offsetWidth, sw = w / page_width;
                            scaleToPage(node, page_width, sw * node.offsetHeight, !0);
                        }
                        if (0 === node.offsetHeight || node.offsetHeight && 1.5 * page_height > node.offsetHeight) return nodeinfo = new BlockInfo(node, style), 
                        addClass(node, "codexblock"), info.push(nodeinfo), blocks.push(node), styles.push(style), 
                        nodeinfo.terminal = node, moveUp(node), checkTerminal(node, root, info), void 0;
                        node.childNodes && node.childNodes.length && (fdjtLog.warn("Allowing split of huge (%d) block %o", node.offsetHeight, node), 
                        node.style.pageBreakInside = "auto", style = getStyle(node));
                    }
                    var disp = style.display;
                    if ("BR" !== node.tagName && "inline" !== disp && "table-cell" !== disp) {
                        if (addClass(node, "codexblock"), nodeinfo = new BlockInfo(node, style), blocks.push(node), 
                        styles.push(style), info.push(nodeinfo), "block" === disp || "table" === disp || "list-item" === disp || "table-row-group" === disp) {
                            for (var children = node.childNodes, total_blocks = blocks.length, i = 0, len = children.length; len > i; ) {
                                var ch = children[i++];
                                1 === ch.nodeType && gatherBlocks(root, ch, blocks, info, styles);
                            }
                            blocks.length === total_blocks && (nodeinfo.terminal = node);
                        } else nodeinfo.terminal = node;
                        nodeinfo.terminal && checkTerminal(node, root, info), moveUp(node);
                    } else if ("static" === style.position && "A" === node.tagName) {
                        for (var anchor_elts = node.childNodes, j = 0, n_elts = anchor_elts.length; n_elts > j; ) {
                            var child = anchor_elts[j++];
                            if (1 === child.nodeType) {
                                var cstyle = getStyle(child);
                                "inline" !== cstyle.display && gatherBlocks(root, child, blocks, styles, info, cstyle);
                            }
                        }
                        moveUp(node);
                    }
                }
            }
            function BlockInfo(node, style) {
                return this.avoidbreakinside = avoidBreakInside(node, style), this.forcebreakbefore = forcedBreakBefore(node, style), 
                this.forcebreakafter = forcedBreakAfter(node, style), this.avoidbreakbefore = avoidBreakBefore(node, style), 
                this.avoidbreakafter = avoidBreakAfter(node, style), this.fullpage = hasClass(node, /\bcodexfullpage\b/) || fullpages && testNode(node, fullpages), 
                this.singlepage = checkSinglePage(node, style), this.atomic = atomic && atomic.match(node), 
                this.floatpage = floatpages && testNode(node, floatpages), this.floating = hasClass(node, "codexfloat") || floatblocks && floatblocks.match(node), 
                this;
            }
            function handle_dragging(block, terminal, info, style, tracing) {
                block && (prev && 0 > drag.indexOf(prev) ? drag.length && (layout.drag = drag = []) : prev && atPageTop(prev) ? drag.length && (layout.drag = drag = []) : prev && terminal && info.avoidbreakbefore ? (tracing && logfn("Possibly dragging %o", prev), 
                0 > drag.indexOf(prev) && drag.push(prev)) : prev && info.avoidbreakafter && (tracing && logfn("Possibly dragging %o", prev), 
                0 > drag.indexOf(prev) && drag.push(prev)));
            }
            function handle_standalone(block, info, style, tracing) {
                return info.floatpage || info.floating && info.singlepage ? (tracing && logfn("Pushing float page %o", block), 
                floating.push(block), !1) : info.singlepage ? (tracing && logfn("Full single page for %o", block), 
                block = newPage(block, info), newPage(), !1) : page.childNodes.length && (info.forcebreakbefore || previnfo && previnfo.forcebreakafter || previnfo && (previnfo.fullpage || previnfo.fullpage)) ? (tracing && logfn("Forced new page for %o", block), 
                layout.drag = drag = [], newPage(block, info) || block) : moveUp(block);
            }
            function handle_unbreakable(block, info, style, geom, tracing) {
                var curpage = page;
                tracing = !1;
                var newblock = !1;
                if (drag.length && atPageTop(drag[0], page)) {
                    var oversize_limit = .2;
                    return !info.avoidbreakafter && (geom.bottom - page_height) / page_height > 1 && oversize_limit > (geom.bottom - page_height) / page_height ? (addClass(page, "codexoversize"), 
                    layout.drag = drag = [], newPage(), !1) : (layout.drag = drag = [], newblock = newPage(block, info), 
                    page === curpage ? !1 : (block !== newblock && (info = new BlockInfo(newblock)), 
                    !break_blocks || info.atomic || info.avoidbreakinside || hasClass(newblock, "codexcantsplit") ? !1 : newblock));
                }
                return newblock = newPage(block, info), block !== newblock && (info = new BlockInfo(newblock)), 
                page === curpage ? !1 : (block !== newblock && (info = new BlockInfo(newblock)), 
                !break_blocks || info.atomic || info.avoidbreakinside || hasClass(newblock, "codexcantsplit") ? !1 : newblock);
            }
            function isLastChild(node) {
                for (var scan = node.nextSibling; scan; ) {
                    if (3 === scan.nodeType && !isEmpty(scan.nodeValue)) return !1;
                    if (1 === scan.nodeType && inFlow(scan)) return !1;
                    scan = scan.nextSibling;
                }
                return !0;
            }
            function isFirstChild(node) {
                for (var scan = node.previousSibling; scan; ) {
                    if (3 === scan.nodeType || !isEmpty(scan.nodeValue)) return !1;
                    if (1 === scan.nodeType && inFlow(scan)) return !1;
                    scan = scan.previousSibling;
                }
                return !0;
            }
            function getFrontEdge(node, root) {
                for (var body = document.body, edge = [ node ], parent = node.parentNode; parent && parent !== body && node !== root && isLastChild(node); ) edge.push(parent), 
                node = parent, parent = node.parentNode;
                return edge;
            }
            function getBackEdge(node, root) {
                for (var body = document.body, edge = [ node ], parent = node.parentNode; parent && parent !== body && node !== root && isFirstChild(node); ) edge.push(parent), 
                node = parent, parent = node.parentNode;
                return edge;
            }
            function findInfo(node, info) {
                for (var i = info.length - 1; i >= 0; ) {
                    var nodeinfo = info[i--];
                    if (nodeinfo.node === node) return info;
                }
                return !1;
            }
            function checkTerminal(node, root, info) {
                if (!hasClass(node, "codexterminal")) {
                    var front_edge = getFrontEdge(node, root), back_edge = getBackEdge(node, root), avoid_before = !1, force_before = !1, avoid_after = !1, force_after = !1, front_info = front_edge && findInfo(front_edge, info), back_info = back_edge && findInfo(back_edge, info), i = 0, lim = front_edge.length;
                    if (lim > 1) for (;lim > i; ) avoidBreakAfter(front_edge[i]) && (avoid_after = !0), 
                    forcedBreakAfter(front_edge[i]) && (force_after = !0), i++;
                    if (i = 0, lim = back_edge.length, lim > 1) for (;lim > i; ) avoidBreakBefore(back_edge[i]) && (avoid_before = !0), 
                    forcedBreakBefore(back_edge[i]) && (force_before = !0), i++;
                    avoid_after && force_after || (avoid_after ? (front_info && (front_info.avoidbreakafter = !0), 
                    addClass(front_edge, "AVOIDBREAKAFTER")) : force_after && (front_info && (front_info.forcebreakafter = !0), 
                    addClass(front_edge, "FORCEBREAKAFTER"))), avoid_before && force_before || (avoid_before ? (back_info && (back_info.avoidbreakbefore = !0), 
                    addClass(back_edge, "AVOIDBREAKBEFORE")) : force_before && (back_info && (back_info.forcebreakbefore = !0), 
                    addClass(back_edge, "FORCEBREAKBEFORE"))), addClass(node, "codexterminal");
                }
            }
            function emptyNode(node) {
                if (3 === node.nodeType) return 0 > node.nodeValue.search(/\S/);
                if (1 === node.nodeType) {
                    if (node.offsetHeight) return !1;
                    if (node.childNodes && 0 !== node.childNodes.length) {
                        for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) if (!emptyNode(children[i++])) return !1;
                        return !0;
                    }
                    return node.offsetHeight ? !1 : !0;
                }
                return !1;
            }
            function firstGChild(ancestor, descendant) {
                for (var scan = descendant; scan; ) {
                    if (scan === ancestor) return !0;
                    if (scan.previousSibling) {
                        for (var prev = scan.previousSibling; prev; ) {
                            if (!emptyNode(prev) && (1 !== prev.nodeType || inFlow(prev))) return !1;
                            scan = prev, prev = scan.previousSibling;
                        }
                        scan = scan.parentNode;
                    } else scan = scan.parentNode;
                }
                return !1;
            }
            function needNewPage(node) {
                return page ? node && hasParent(node, page) ? page.firstChild === node || firstGChild(page, node) ? !1 : 1 === node.nodeType && 0 === new Geometry(node, page).top && "BR" !== node.tagName ? !1 : !0 : hasContent(page, !0) : !0;
            }
            function newPage(node, info, forcepage) {
                var i, lim;
                if (drag && drag.length && drag.length && atPageTop(drag[0])) return logfn("Ignored call for new page @%d due to excessive drag", pagenum), 
                node && (node = moveUp(node)), !1;
                if (!node && !forcepage && page && 0 === page.childNodes.length) return node ? logfn("Ignored call for new page for %o on empty page %d", node, pagenum) : logfn("Ignored call for new page on empty page %d", node, pagenum), 
                !1;
                if (node && 3 === node.nodeType) {
                    var parent = node.parentNode;
                    parent && 1 === parent.childNodes.length && parent !== document.body && parent !== root && !hasClass(parent, "codexpage") && (node = parent);
                }
                if (node && !forcepage && !needNewPage(node)) return moveUp(node);
                if (floating && floating.length) {
                    var floaters = floating;
                    floating = [];
                    var closed_page = page;
                    for (i = 0, lim = floaters.length; lim > i; ) {
                        var floater = floaters[i++], fg = !1;
                        checkSinglePage(floater) ? (newPage(floater), closed_page = page, forcepage = !0) : closed_page === page ? (newPage(floater), 
                        fg = new Geometry(floater, page), fg.bottom > page_height && (addClass(page, "codexoversize"), 
                        closed_page = page)) : (moveNodeToPage(floater, page), fg = new Geometry(floater, newpage), 
                        fg.bottom >= page_height && newPage(floater));
                    }
                }
                if (!node || forcepage || needNewPage(node)) {
                    var trailing = page && getTrailingText(page);
                    if (page && (pagefn && pagefn.call(layout, page, layout), page.style.height = "", 
                    dropClass(page, "codexworkpage")), layout.page = page = fdjtDOM("div.codexpage.codexworkpage"), 
                    newpages.push(page), trailing) {
                        var text = trailing.nodeValue, break_at = text.search(/[\(\[\"\“\‘]+$/), keep = fdjtDOM("span.codexsplitstart", text.slice(0, break_at)), push = fdjtDOM("span.codextextsplit", text.slice(break_at)), frag = document.createDocumentFragment();
                        frag.appendChild(keep), frag.appendChild(push), fdjtDOM.replace(trailing, frag), 
                        drag.push(push);
                    }
                    pagerule || (page.style.height = page_height + "px", page.style.width = page_width + "px"), 
                    page.style.height = "inherit", pagenum++, layout.pagenum = pagenum, page.id = pageprefix + pagenum, 
                    page.setAttribute("data-pagenum", pagenum), fdjtDOM(container, page), layout.prev = prev = !1, 
                    pages.push(page);
                }
                if (trace && (trace > 2 || track && node && track.match(node)) && (node ? logfn("Layout/newpage %o at %o", page, node) : logfn("Layout/newpage %o", page)), 
                drag && drag.length) {
                    for (i = 0, lim = drag.length; lim > i; ) moveUp(drag[i++]);
                    if (node) {
                        var block = node, terminal = info && info.terminal;
                        block && drag.length && terminal && (1 === drag.length || avoidBreakBefore(block) || avoidBreakAfter(drag[drag.length - 1]) ? 0 > drag.indexOf(block) && drag.push(block) : layout.drag = drag = []);
                    } else layout.prev = prev = drag[drag.length - 1], layout.drag = drag = [];
                }
                return node ? moveUp(node) : !1;
            }
            function getTrailingText(node) {
                if (3 === node.nodeType) return node.nodeValue.search(/[\(\[\"\“\‘]+$/) > 0 ? node : !1;
                if (1 === node.nodeType) {
                    var children = node.childNodes, len = children.length;
                    return 3 === children[len - 1].nodeType ? getTrailingText(children[len - 1]) : !1;
                }
                return !1;
            }
            function splitBlock(node, info, style, use_height) {
                if (use_height || (use_height = page_height), style || (style = getStyle(node)), 
                !break_blocks || info.avoidbreakinside || !node.childNodes || 0 === node.childNodes.length) return addClass(node, "codexcantsplit"), 
                newPage(node), node;
                node.id && 0 !== node.id.search("CODEXTMP") && (splits[node.id] || (splits[node.id] = node.cloneNode(!0)));
                var init_geom = new XGeometry(node, page, !0), line_height = init_geom.line_height || 12;
                if (use_height === page_height && init_geom.top + init_geom.top_margin + 1.2 * line_height > page_height) {
                    var cpage = page, newblock = newPage(node);
                    if (cpage !== page) return newblock;
                    use_height = page_height + floor(1.2 * line_height);
                }
                var children = nodeChildren(node);
                node.innerHTML = "";
                var geom = new Geometry(node, page);
                if (geom.bottom > use_height) return appendChildren(node, children), addClass(node, "codexcantsplit"), 
                newPage(node), node;
                use_height === page_height && 1.2 * line_height > init_geom.bottom - page_height && init_geom.height > 3 * line_height && (use_height = page_height - floor(line_height));
                var push = splitChildren(node, children, init_geom, use_height);
                if (push) {
                    if (push === node) return appendChildren(node, children), addClass(node, "codexcantsplit"), 
                    newPage(node), node;
                    var page_break = push[0];
                    layout.drag = drag = [], page_break = newPage(page_break);
                    var dup = page_break.parentNode;
                    return moveChildren(dup, push, 1), trace > 1 && logfn("Layout/splitBlock %o @ %o into %o on %o", node, page_break, dup, page), 
                    dup;
                }
                return fdjtLog("Tried to break %o which didn't need breaking", node), appendChildren(node, children), 
                node;
            }
            function nodeChildren(node) {
                return toArray(node.childNodes);
            }
            function splitChildren(node, children, init_geom, use_page_height) {
                var page_break = !1, breaktype = !1, breakpos = -1, textsplit = !1, text_parent = !1;
                use_page_height || (use_page_height = page_height);
                var geom = init_geom || new Geometry(node, page);
                if (1 === children.length) page_break = children[0], breakpos = 0, breaktype = page_break.nodeType, 
                node.appendChild(page_break); else for (var i = 0, n = children.length; n > i; ) {
                    var child = children[i++];
                    if (node.appendChild(child), geom = new Geometry(node, page), geom.bottom > use_page_height) {
                        page_break = child, breaktype = child.nodeType, breakpos = i - 1;
                        break;
                    }
                }
                if (0 > breakpos) return !1;
                if (3 === breaktype) textsplit = page_break, text_parent = node; else {
                    if (1 !== breaktype) return 0 === breakpos ? node : children.slice(breakpos);
                    if (1 !== page_break.childNodes.length || 3 !== page_break.childNodes[0].nodeType) return 0 !== breakpos && hasContent(node, !0, !1, page_break) ? page_break.childNodes && 0 !== page_break.childNodes.length ? children.slice(breakpos) : children.slice(breakpos) : (appendChildren(node, children, breakpos + 1), 
                    node);
                    textsplit = page_break.childNodes[0], text_parent = page_break;
                }
                var probenode = textsplit, original = textsplit, text = textsplit.nodeValue, words = attachWhitespace(text.split(/(\s+)/gm));
                if (2 > words.length) return 0 === breakpos ? node : children.slice(breakpos);
                var wprobe = document.createTextNode(words[0]);
                if (text_parent.replaceChild(wprobe, probenode), probenode = wprobe, geom = new Geometry(node, page), 
                geom.bottom > use_page_height) return text_parent.replaceChild(original, probenode), 
                0 === breakpos ? node : 0 === words[0].search(/^[.,;~?!:"'”’)\]-]/) ? 1 === breakpos ? node : (text_parent.removeChild(original), 
                children.slice(breakpos - 1)) : children.slice(breakpos);
                text_parent.replaceChild(textsplit, wprobe), probenode = textsplit;
                var foundbreak = splitWords(text_parent, probenode, words, node, use_page_height);
                if (0 === foundbreak || foundbreak === words.length - 1) return text_parent.replaceChild(textsplit, probenode), 
                0 === breakpos ? node : children.slice(breakpos);
                var keepnode, pushnode, keeptext = words.slice(0, foundbreak).join(""), pushtext = words.slice(foundbreak).join(""), id = !1;
                3 === breaktype ? (keepnode = fdjtDOM("span.codexsplitstart.codexraggedsplit"), 
                id = keepnode.id = "CODEXTMPID" + tmpid_count++, pushnode = fdjtDOM("span.codextextsplit")) : hasClass(page_break, "codextextsplit") ? (probenode = keepnode = page_break, 
                keepnode.innerHTML = "", text_parent = node, pushnode = page_break.cloneNode(!0), 
                addClass(page_break, "codexraggedsplit"), pushnode.id = "") : (keepnode = fdjtDOM("span.codexsplitstart"), 
                pushnode = page_break.cloneNode(!0), keepnode.id ? pushnode.id = "" : id = keepnode.id = "CODEXTMPID" + tmpid_count++), 
                keepnode.appendChild(document.createTextNode(keeptext)), pushnode.innerHTML = "", 
                pushnode.appendChild(document.createTextNode(pushtext)), keepnode !== probenode && text_parent.replaceChild(keepnode, probenode);
                var push_children = children.slice(breakpos);
                return push_children[0] = pushnode, appendChildren(node, push_children), id && (textsplits[id] = original), 
                push_children;
            }
            function splitWords(text_parent, probestart, words, node, use_page_height) {
                for (var wlen = words.length, wtop = wlen, wbot = 0, foundbreak = !1, probenode = probestart, geom = !1; wtop > wbot; ) {
                    var wmid = wbot + floor((wtop - wbot) / 2), newprobe = document.createTextNode(words.slice(0, wmid).join(""));
                    if (text_parent.replaceChild(newprobe, probenode), probenode = newprobe, geom = new Geometry(node, page), 
                    geom.bottom > use_page_height) wtop = wmid - 1; else {
                        var nextw = document.createTextNode(words[wmid]);
                        text_parent.appendChild(nextw);
                        var ngeom = new Geometry(node, page);
                        if (text_parent.removeChild(nextw), ngeom.bottom > use_page_height) {
                            foundbreak = wmid;
                            break;
                        }
                        wbot = wmid + 1;
                    }
                }
                return foundbreak === !1 && (foundbreak = wbot), probestart !== probenode && text_parent.replaceChild(probestart, probenode), 
                foundbreak;
            }
            function attachWhitespace(breaks) {
                for (var words = [], word = !1, bi = 0, blen = breaks.length; blen > bi; ) {
                    var ws, s = breaks[bi++];
                    (ws = s.search(/\s/)) >= 0 ? 0 === ws ? bi >= blen ? word = s : word && / +/.exec(s) ? word = word + s + breaks[bi++] : word ? (words.push(word), 
                    word = s) : word = s : (word ? words.push(word + s) : words.push(s), word = !1) : word ? word += s : word = s;
                }
                return word && words.push(word), words;
            }
            function loop() {
                function layoutLoopDone() {
                    donefn(layout);
                }
                var wait_for = timeskip || timeslice;
                if (!timeslice || serialize) for (;n_blocks > block_i; ) step(); else if (use_raf && n_blocks > block_i) window.requestAnimationFrame(function() {
                    for (var loop_start = fdjtTime(); n_blocks > block_i && !serialize && timeslice > fdjtTime() - loop_start; ) step();
                    progressfn && progressfn(layout), layout.timer = setTimeout(loop, wait_for);
                }); else if (n_blocks > block_i) {
                    for (var loop_start = fdjtTime(); n_blocks > block_i && !serialize && timeslice > fdjtTime() - loop_start; ) step();
                    if (progressfn && progressfn(layout), serialize) return loop();
                    layout.timer = setTimeout(loop, wait_for);
                }
                if (block_i >= n_blocks) {
                    var last_block = blocks[n_blocks - 1];
                    (forcedBreakAfter(last_block) || hasClass(last_block, /\bcodexfullpage\b/) || fullpages && testNode(last_block, fullpages)) && newPage(), 
                    layout.timer && clearTimeout(layout.timer), layout.timer = !1, layout.root = cur_root = !1, 
                    pagesDone(newpages), newpages = [], donefn && (timeslice ? setTimeout(layoutLoopDone, 10) : donefn(layout));
                }
            }
            var newpage = !1, newpages = page ? [ page ] : [], start = fdjtTime();
            if (page || (newPage(), newpage = !0), timeslice && "number" != typeof timeslice && (timeslice = layout.timeslice), 
            timeskip && "number" != typeof timeskip && (timeskip = layout.timeskip), trace === void 0 && (trace = layout.tracelevel), 
            progressfn === void 0 && (progressfn = layout.progressfn || !1), layout.started || (layout.started = start), 
            getParent(root, ".codexpage")) return pagesDone(newpages), newpages = [], donefn && donefn(layout), 
            !1;
            layout.roots.push(root), layout.root_count++;
            var fullpage = hasClass(root, "codexfullpage") || fullpages && testNode(root, fullpages), singlepage = fullpage || hasClass(root, "codexsinglepage") || checkSinglePage(root);
            (fullpage || singlepage) && (avoidBreakInside(root) || (fullpage = singlepage = !1)), 
            newpage ? root = moveUp(root) : singlepage ? newPage(root) : root = mustBreakBefore(root) || prev && mustBreakAfter(prev) ? newPage(root) : moveUp(root);
            var scale_elts = getChildren(root, "[data-pagescale],[pagescale]");
            if (scaleToPage(scale_elts, page_width, page_height), "IMG" === root.tagName && (fullpage || singlepage) && tweakImage(root, page_width, page_height), 
            singlepage) {
                var pw = page.scrollWidth, ph = page.scrollHeight;
                return pw > page_width || ph > page_height ? addClass(page, "codexoversize") : fullpage && .9 * page_width > pw && .9 * page_height > ph && addClass(page, "codexundersize"), 
                newPage(), prev = layout.prev = root, prevstyle = layout.prevstyle = getStyle(root), 
                previnfo = layout.previnfo = new BlockInfo(root, prevstyle), pagesDone(newpages), 
                newpages = [], drag = [], donefn && donefn(layout), void 0;
            }
            var geom = new Geometry(root, page), done = !1;
            if (mustBreakInside(root) || (page_height >= geom.bottom ? (cantBreakBefore(root) ? drag.push(root) : drag = cantBreakAfter(root) ? [ root ] : [], 
            done = !0) : (atomic && atomic.match(root) || avoidBreakInside(root)) && (newpage || (newPage(root), 
            geom = new Geometry(root, page)), page_height >= geom.bottom && (drag = cantBreakAfter(root) ? [ root ] : [], 
            done = !0))), done) return prev = layout.prev = root, prevstyle = layout.prevstyle = getStyle(root), 
            previnfo = layout.previnfo = new BlockInfo(root, prevstyle), pagesDone(newpages), 
            newpages = [], donefn && donefn(layout), void 0;
            var blocks = [], blockinfo = [], styles = [];
            if (gatherBlocks(root, root, blocks, blockinfo, styles), layout.block_count = layout.block_count + blocks.length, 
            trace > 1 && logfn("Laying out %d blocks from %o; page=%o", blocks.length, root, page), 
            0 === blocks.length) return newpage || newPage(root), layout.root = cur_root = !1, 
            pagesDone(newpages), newpages = [], donefn && donefn(layout), void 0;
            layout.root = cur_root = root;
            for (var block_i = 0, n_blocks = blocks.length, block_hidden = 0, hide_i = 0; n_blocks > hide_i; ) {
                var hide_block = blocks[hide_i++];
                hide_block.style.display = "none";
            }
            if (BlockInfo.prototype.avoidbreakinside = BlockInfo.prototype.forcebreakbefore = BlockInfo.prototype.forcebreakafter = BlockInfo.prototype.avoidbreakbefore = BlockInfo.prototype.avoidbreakafter = BlockInfo.prototype.fullpage = BlockInfo.prototype.singlepage = BlockInfo.prototype.floatpage = BlockInfo.prototype.floating = BlockInfo.prototype.atomic = !1, 
            timeslice) loop(); else {
                for (;n_blocks > block_i; ) step();
                pagesDone(newpages), donefn && donefn(layout);
            }
            return layout;
        }
        function pagesDone(pages) {
            for (var i = 0, lim = pages.length; lim > i; ) {
                var page = pages[i++], ph = page.style.height;
                if (!(ph && "" !== ph && "inherit" !== ph && "initial" !== ph && "auto" !== ph || hasClass(page, "codexoversize"))) {
                    page.style.height = "auto", page.style.display = "block";
                    var content_height = page.scrollHeight;
                    if (page_height > content_height) ; else {
                        var pagestyle = getStyle(page), use_height = page_height + parsePX(pagestyle.paddingTop) + parsePX(pagestyle.paddingBottom);
                        content_height > use_height && addClass(page, "codexoversize");
                    }
                    page.style.height = "", page.style.display = "";
                    var ragged = getChild(page, ".codexraggedsplit");
                    ragged && ragged.appendChild(fdjtDOM("span.codexdupleading.fdjtskiptext", "leading"));
                    for (var blocks = getChildren(page, ".codexblock"), j = 0, n_blocks = blocks.length; n_blocks > j; ) {
                        var block = blocks[j++];
                        dropClass(block, "codexblock"), dropClass(block, "codexterminal");
                    }
                }
            }
        }
        function gatherLayoutInfo(node, ids, dups, dupids, dupstarts, restoremap) {
            if (1 === node.nodeType) {
                var classname = node.className;
                if ("string" == typeof classname) {
                    if (classname.search(/\bcodexdupstart\b/) >= 0) dupstarts[node.id] || (dupstarts[node.id] = node, 
                    dupids.push(node.id), ids.push(node.id)); else if (classname.search(/\b(codexdup|codexdupend)\b/) >= 0) {
                        var baseid = node.getAttribute("data-baseid");
                        baseid && (node.codexbaseid = baseid, dups[baseid] ? dups[baseid].push(node) : dups[baseid] = [ node ]);
                    } else node.id && classname.search(/\bcodexrestore\b/) >= 0 && (restoremap[node.id] || (ids.push(node.id), 
                    restoremap[node.id] = node));
                    if (node.childNodes && node.childNodes.length) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                        var child = children[i++];
                        1 === child.nodeType && gatherLayoutInfo(child, ids, dups, dupids, dupstarts, restoremap);
                    }
                }
            }
        }
        function setSimpleLayout(content) {
            function setting_layout(resolve, reject) {
                try {
                    var frag = document.createElement("div"), all_ids = [], saved_ids = {}, dupids = [], dupstarts = {}, restoremap = {}, curnodes = [], newdups = {}, pagescales = [];
                    trace && fdjtLog("Setting layout to %d characters of HTML", content.length), frag.innerHTML = content;
                    var newpages = frag.childNodes, addpages = [];
                    trace && fdjtLog("Gathering layout info");
                    for (var i = 0, lim = newpages.length; lim > i; ) {
                        var page = newpages[i++];
                        addpages.push(page), 1 === page.nodeType && (page.className && page.className.search && page.className.search(/\bcurpage\b/) >= 0 && dropClass(page, "curpage"), 
                        gatherLayoutInfo(page, all_ids, newdups, dupids, dupstarts, restoremap));
                    }
                    var idmap = {};
                    for (trace && fdjtLog("Getting originals by ID"), i = 0, lim = all_ids.length; lim > i; ) {
                        var idkey = all_ids[i++];
                        idmap[idkey] = document.getElementById(idkey);
                    }
                    var bcrumb = !1, ccrumb = !1;
                    for (trace && fdjtLog("Moving body and container out of document"), origin && origin.parentNode && (bcrumb = document.createTextNode(""), 
                    origin.parentNode.replaceChild(bcrumb, origin)), container.parentNode && (ccrumb = document.createTextNode(""), 
                    container.parentNode.replaceChild(ccrumb, container)), trace && fdjtLog("Moving originals into layout"), 
                    i = 0, lim = all_ids.length; lim > i; ) {
                        var id = all_ids[i++], original = idmap[id], restore = restoremap[id];
                        if (restore && original) {
                            var classname = restore.className, style = restore.getAttribute("style"), ostyle = original.getAttribute("style"), oclass = original.className, crumb = document.createTextNode("");
                            classname = classname.replace(/\bcodexrestore\b/, ""), replaceNode(original, crumb), 
                            crumbs[id] = crumb, replaceNode(restore, original), classname && classname !== oclass && (oclass && "string" == typeof oclass && original.setAttribute("data-savedclass", oclass), 
                            original.className = classname), style !== ostyle && (ostyle && original.setAttribute("data-savedstyle", ostyle), 
                            original.setAttribute("style", style)), classname.search && classname.search(/\bcodexpagetop\b/) >= 0 && markPageTop(original, !0);
                        } else original && (saved_ids[id] = original, original.id && original.removeAttribute("id"));
                    }
                    trace && fdjtLog("Gathering lostids");
                    var lostids = layout.lostids = {}, really_lost = lostids._all_ids = [];
                    for (i = 0, lim = dupids.length; lim > i; ) {
                        var dupid = dupids[i++], orig = idmap[dupid];
                        orig && (lostids[dupid] = orig, really_lost.push(dupid), orig.id && orig.removeAttribute("id"));
                    }
                    trace && fdjtLog("Moving nodes around");
                    var cur = container.childNodes;
                    for (i = 0, lim = cur.length; lim > i; ) curnodes.push(cur[i++]);
                    for (i = 0; lim > i; ) container.removeChild(curnodes[i++]);
                    for (i = 0, lim = addpages.length; lim > i; ) {
                        var addpage = addpages[i++], scale_elts = getChildren(addpage, "[pagescale],[data-pagescale]");
                        scale_elts.length && pagescales.push({
                            page: addpage,
                            toscale: scale_elts
                        }), container.appendChild(addpage);
                    }
                    layout.pages = addpages, dups = layout.dups = newdups, saved_ids._all_ids = all_ids, 
                    layout.saved_ids = saved_ids, layout.page = addpages[0], layout.pagenum = parseInt(layout.page.getAttribute("data-pagenum"), 10), 
                    trace && fdjtLog("Moving origin/container back to document"), ccrumb && ccrumb.parentNode.replaceChild(container, ccrumb), 
                    bcrumb && bcrumb.parentNode.replaceChild(origin, bcrumb);
                    for (var splits = getChildren(container, ".codexsplitstart"), s = 0, n_splits = splits.length; n_splits > s; ) {
                        var split = splits[s++], splitid = split.id, text = split.getAttribute("data-textsplit");
                        splitid && text && (textsplits[splitid] = document.createTextNode(text), split.removeAttribute("data-textsplit"));
                    }
                    for (i = 0, lim = pagescales.length; lim > i; ) {
                        var ps = pagescales[i++], pg = ps.page;
                        pg.style.opacity = 0, pg.style.display = "block", scaleToPage(ps.toscale, page_width, page_height), 
                        pg.style.display = "", pg.style.opacity = "";
                    }
                } catch (ex) {
                    return reject && reject(ex), void 0;
                }
                return trace && fdjtLog("Done restoring layout"), resolve ? resolve(layout) : layout;
            }
            return new Promise(setting_layout);
        }
        function setLayout(content) {
            function restorePageNode(pagenode) {
                restorePage(pagenode, content);
            }
            if ("string" == typeof content) return setSimpleLayout(content);
            if (content.hasOwnProperty("npages")) {
                container.innerHTML = content.layout;
                var pagenodes = container.childNodes;
                return fdjtAsync.slowmap(restorePageNode, pagenodes, {
                    slice: layout.timeslice,
                    space: layout.timeskip
                });
            }
            return setSimpleLayout(content.layout);
        }
        function restorePage(pagenode, content) {
            function restorePageData(pagedata) {
                pagenode.innerHTML = pagedata.content;
            }
            fetchLayout(content.layout_id, pagenode.id).then(restorePageData);
        }
        function dropSelected(node, dropsel) {
            if (dropsel && 1 === node.nodeType) {
                var children = node.childNodes, todrop = [];
                if (children) {
                    for (var i = 0, lim = children.length; lim > i; ) {
                        var child = children[i++];
                        1 === child.nodeType && dropsel.match(child) && todrop.push(child);
                    }
                    for (i = 0, lim = todrop.length; lim > i; ) node.removeChild(todrop[i++]);
                }
            }
        }
        function prepForRestore(node, dropsel) {
            if (1 === node.nodeType) {
                if (node.id) {
                    var classname = node.className;
                    if (!(classname && "string" == typeof classname && classname.search(/\bcodexdup/g) >= 0) && node.id && 0 !== node.id.search("CODEXTMP")) {
                        var justref = document.createElement(node.tagName);
                        return node.id && (justref.id = node.id), justref.className = "string" == typeof node.className ? node.className + " codexrestore" : "codexrestore", 
                        node.getAttribute("style") && justref.setAttribute("style", node.getAttribute("style")), 
                        node.parentNode.replaceChild(justref, node), dropsel ? dropSelected(node, dropsel) : void 0;
                    }
                }
                for (var children = node.childNodes, todrop = [], i = 0, n = children.length; n > i; ) {
                    var child = children[i++];
                    1 === child.nodeType && (dropsel && dropsel.match(child) ? todrop.push(child) : prepForRestore(child, dropsel));
                }
                for (i = 0, n = todrop.length; n > i; ) node.removeChild(todrop[i++]);
            }
        }
        function saveLayout(callback, layout_id) {
            var href = window.location.href, qpos = href.indexOf("?"), hashpos = href.indexOf("#"), endpos = qpos >= hashpos ? qpos : hashpos;
            if (endpos > 0 && (href = href.slice(0, endpos)), layout_id || (layout_id = layout.layout_id || (layout.layout_id = layout.width + "x" + layout.height + "(" + href + ")")), 
            CodexLayout.cache) {
                for (var copy = container.cloneNode(!0), pages = copy.childNodes, i = 0, npages = pages.length; npages > i; ) {
                    var page = pages[i++];
                    if (1 === page.nodeType) for (var content = page.childNodes, j = 0, n = content.length; n > j; ) {
                        var node = content[j++];
                        1 === node.nodeType && prepForRestore(node, layout.dontsave || !1);
                    }
                }
                for (var splits = getChildren(copy, ".codexsplitstart"), s = 0, n_splits = splits.length; n_splits > s; ) {
                    var split = splits[s++], splitid = split.id, text = splitid && textsplits[splitid];
                    text && split.setAttribute("data-textsplit", text.nodeValue);
                }
                var html = copy.innerHTML;
                return cacheLayout(layout_id, html, !1, !1).then(function() {
                    cachedLayout(layout_id), callback(layout);
                }).catch(function(ex) {
                    return fdjtLog.warn("Couldn't save layout %s: %s", layout_id, ex), !1;
                }), layout_id;
            }
        }
        function restoreLayout(arg, donefn, failfn) {
            function whendone() {
                if (layout.done = fdjtTime(), donefn && donefn(layout), layout.thenfns && layout.thenfns.length) for (var thenfns = layout.thenfns, f = 0, nfns = thenfns.length; nfns > f; ) thenfns[f++](layout);
                return layout;
            }
            var setting = !1;
            if (!arg) return fdjtLog.warn("Falsy arg %s to restoreLayout", arg), failfn(Error("Falsy arg to restoreLayout")), 
            layout;
            if (arg.hasOwnProperty("npages")) setting = layout.setLayout(arg); else if (arg.hasOwnProperty("layout")) setting = layout.setLayout(arg.layout); else {
                if (!(arg.indexOf("<") >= 0)) {
                    var saved_layout = fdjtState.getLocal(arg);
                    return layout ? layout.setLayout(saved_layout, whendone) : !1;
                }
                setting = layout.setLayout(arg);
            }
            return setting.then(whendone).catch(failfn);
        }
        function finishPage(completed) {
            completed.style.display = "block";
            var undersize = hasClass(completed, "codexundersize"), oversize = hasClass(completed, "codexoversize");
            if ((oversize || undersize) && (adjustFonts(completed), scale_pages)) {
                var iw = completed.scrollWidth, ih = completed.scrollHeight, ow = completed.offsetWidth, oh = completed.offsetHeight, noscale = oversize ? oh >= ih && ow >= iw : ih >= oh && iw >= ow && oh > .9 * ih || ow > .9 * iw;
                noscale || (completed.style.height = "", adjust_node(completed));
            }
            layout.pagedone && layout.pagedone(completed), dropClass(completed, "codexworkpage"), 
            completed.style.display = "", completed.style.height = "";
        }
        function Finish() {
            for (var dupid in dups) if (dups.hasOwnProperty(dupid)) {
                var alldups = dups[dupid], lastdup = alldups[alldups.length - 1], dupstart = document.getElementById(dupid);
                if ("OL" === dupstart.tagName && fixOrderedList([ dupstart ].concat(alldups)), "LI" === dupstart.tagName) for (var dupi = 0, ndups = alldups.length; ndups > dupi; ) {
                    var dup = alldups[dupi++];
                    dup.hasAttribute(dup, "data-savedstyle") || dup.setAttribute("data-savedstyle", dup.getAttribute("style") || ""), 
                    dup.style.listStyleType = "none";
                }
                lastdup.className = lastdup.className.replace(/\bcodexdup\b/, "codexdupend");
            }
            var middle_dups = getChildren(page, ".codexdup");
            if (middle_dups && middle_dups.length) for (var j = 0, dl = middle_dups.length; dl > j; ) {
                var mdup = middle_dups[j++];
                stripBottomStyles(mdup);
            }
            page && (pagefn && pagefn.call(layout, page, layout), page.style.height = "", dropClass(page, "codexworkpage"));
            for (var i = 0, lim = pages.length; lim > i; ) {
                var p = pages[i++];
                this.finishPage(p);
            }
            if (layout.done = fdjtTime(), layout.thenfns && layout.thenfns.length) for (var thenfns = layout.thenfns, f = 0, nfns = thenfns.length; nfns > f; ) thenfns[f++](layout);
        }
        function fixOrderedList(ol) {
            if (!(2 > ol.length)) {
                for (var olpage = [], i = 0, lim = ol.length, ntotal = 0; lim > i; ) {
                    var dup = ol[i++], page = getParent(dup, ".codexpage"), pageno = page && parseInt(page.getAttribute("data-pagenum"), 10);
                    olpage.push({
                        list: dup,
                        pageno: pageno
                    });
                }
                olpage.sort(function(x, y) {
                    return x.pageno > y.pageno ? 1 : y.pageno > x.pageno ? -1 : 0;
                });
                var start_at = olpage[0].list.getAttribute("start");
                for (start_at = start_at ? parseInt(start_at) : 0, i = 0, lim = olpage.length; lim > i; ) {
                    var olist = olpage[i++].list, new_items = countListItems(olist);
                    ntotal && olist.setAttribute("start", start_at + ntotal), ntotal += new_items;
                }
            }
        }
        function countListItems(root, count) {
            count || (count = 0);
            for (var children = root.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                if (1 === child.nodeType) {
                    if ("OL" === child.tagName || "UL" === child.tagName) return count;
                    "LI" === child.tagName ? hasClass(child, /\bcodexdup(end)?\b/) || count++ : count = countListItems(child, count);
                }
            }
            return count;
        }
        function forcedBreakBefore(elt, style) {
            return elt && 1 === elt.nodeType ? (style || (style = getStyle(elt)), "always" === style.pageBreakBefore) : !1;
        }
        function mustBreakBefore(elt) {
            if (forcedBreakBefore(elt)) return !0;
            if (elt.childNodes && elt.childNodes.length) {
                for (var children = elt.childNodes, i = 0, lim = children.length; lim > i; ) {
                    var child = children[i];
                    if (3 === child.nodeType) {
                        if (!isEmpty(child.nodeValue)) return !1;
                        i++;
                    } else {
                        if (1 === child.nodeType) return mustBreakBefore(child);
                        i++;
                    }
                }
                return !1;
            }
        }
        function forcedBreakAfter(elt, style) {
            return elt && 1 === elt.nodeType ? (style || (style = getStyle(elt)), "always" === style.pageBreakAfter) : !1;
        }
        function mustBreakAfter(elt) {
            if (forcedBreakAfter(elt)) return !0;
            if (elt.childNodes && elt.childNodes.length) {
                for (var children = elt.childNodes, i = children.length - 1; i >= 0; ) {
                    var child = children[i];
                    if (3 === child.nodeType) {
                        if (!isEmpty(child.nodeValue)) return !1;
                        i--;
                    } else {
                        if (1 === child.nodeType) return mustBreakAfter(child);
                        i--;
                    }
                }
                return !1;
            }
        }
        function avoidBreakInside(elt, style) {
            var lh = getLineHeight(elt, style);
            return elt && 1 === elt.nodeType ? "IMG" === elt.tagName ? !0 : (style || (style = getStyle(elt)), 
            "avoid" === style.pageBreakInside || "table-row" === style.display || "block" === style.display && elt.childNodes && elt.childNodes.length && lh && 2.5 * lh > elt.offsetHeight) : !1;
        }
        function mustBreakInside(elt) {
            if (avoidBreakInside(elt)) return !1;
            if (elt.childNodes && elt.childNodes.length) {
                for (var children = elt.childNodes, i = 0, lim = children.length; lim > i; ) {
                    var child = children[i];
                    if (1 !== child.nodeType) i++; else {
                        if (forcedBreakBefore(child)) return !0;
                        if (forcedBreakAfter(child)) return !0;
                        if (mustBreakInside(child)) return !0;
                        i++;
                    }
                }
                return !1;
            }
            return !1;
        }
        function avoidBreakBefore(elt, style) {
            return elt && 1 === elt.nodeType ? (style || (style = getStyle(elt)), "avoid" === style.pageBreakBefore) : !1;
        }
        function cantBreakBefore(elt) {
            if (avoidBreakBefore(elt)) return !0;
            if (elt.childNodes && elt.childNodes.length) {
                for (var children = elt.childNodes, i = 0, lim = children.length; lim > i; ) {
                    var child = children[i];
                    if (3 === child.nodeType) {
                        if (!isEmpty(child.nodeValue)) return !1;
                        i++;
                    } else {
                        if (1 === child.nodeType) return cantBreakBefore(child);
                        i++;
                    }
                }
                return !1;
            }
        }
        function avoidBreakAfter(elt, style) {
            return elt && 1 === elt.nodeType ? /H\d/.exec(elt.tagName) ? !0 : (style || (style = getStyle(elt)), 
            "avoid" === style.pageBreakAfter ? !0 : style.pageBreakAfter && "auto" !== style.pageBreakAfter ? !1 : !1) : !1;
        }
        function cantBreakAfter(elt) {
            if (avoidBreakAfter(elt)) return !0;
            if (elt.childNodes && elt.childNodes.length) {
                for (var children = elt.childNodes, i = children.length - 1; i >= 0; ) {
                    var child = children[i];
                    if (3 === child.nodeType) {
                        if (!isEmpty(child.nodeValue)) return !1;
                        i--;
                    } else {
                        if (1 === child.nodeType) return cantBreakAfter(child);
                        i--;
                    }
                }
                return !1;
            }
        }
        function checkSinglePage(elt, style) {
            return elt && 1 === elt.nodeType ? hasClass("codexsinglepage") || hasClass("codexfullpage") ? !0 : singlepages && singlepages.match(elt) ? !0 : (style || (style = getStyle(elt)), 
            "always" === style.pageBreakBefore && "always" === style.pageBreakAfter && "avoid" === style.pageBreakInside) : !1;
        }
        function getPage(spec) {
            return spec ? "number" == typeof spec ? fdjtID(pageprefix + spec) : spec.nodeType ? hasClass(spec, "codexpage") ? spec : getParent(spec, ".codexpage") : "string" == typeof spec ? getPage(fdjtID(spec)) : (logfn("Can't determine page from %o", spec), 
            !1) : !1;
        }
        function getDup(node, page) {
            if ("string" == typeof node && (node = document.getElementById(node)), !node) return !1;
            if (hasParent(node, page)) return node;
            for (var nodeid = node.id, duptable = layout.dups, dups = duptable[nodeid], i = 0, lim = dups.length; lim > i; ) {
                if (hasParent(dups[i], page)) return dups[i];
                i++;
            }
            return !1;
        }
        function gotoPage(spec) {
            var newpage = !1;
            if (!spec) return !1;
            if ("number" == typeof spec) newpage = document.getElementById(pageprefix + spec); else if (spec.nodeType) newpage = hasClass(spec, "codexpage") ? spec : getParent(spec, ".codexpage"); else {
                if ("string" != typeof spec) return logfn("Can't determine page from %o", spec), 
                !1;
                newpage = getPage(document.getElementById(spec));
            }
            if (newpage) {
                var curpages = container.getElementsByClassName("curpage");
                curpages.length && dropClass(toArray(curpages), "curpage"), addClass(newpage, "curpage");
            }
        }
        init || (init = {});
        var layout = this;
        this.init = init, this.thenfns = [];
        var fullpages = this.fullpages = optimizeLayoutRule(init.fullpages || !1), singlepages = this.singlepages = optimizeLayoutRule(init.singlepages || !1), floatpages = this.floatpages = optimizeLayoutRule(init.floatpages || !1), floatblocks = this.floatblocks = optimizeLayoutRule(init.floatblocks || !1), pageprefix = this.pageprefix = init.pageprefix || "CODEXPAGE", page_height = this.height = init.page_height || fdjtDOM.viewHeight(), page_width = this.width = init.page_width || fdjtDOM.viewWidth(), orientation = init.orientation || (page_width > page_height ? "landscape" : "portrait");
        this.orientation = orientation;
        var pagefn = init.pagefn || !1, serialize = !1;
        this.serialize = function(val) {
            serialize = val === void 0 ? !0 : val;
        };
        var short_page_height = init.hasOwnProperty("short_page_height") && init.short_page_height && (1 >= init.short_page_height ? page_height * init.short_page_height : init.short_page_height), break_blocks = this.break_blocks = init.break_blocks === void 0 ? !0 : init.break_blocks, atomic = init.atomic || !1;
        "string" == typeof atomic ? atomic = fdjtDOM.selector(atomic) : atomic.length && atomic.join && (atomic = fdjtDOM.selector(atomic.join(","))), 
        this.atomic = atomic, this.dontsave = init.dontsave || !1;
        var use_raf = !CodexLayout.dont_rAF && (window.requestAnimationFrame ? !0 : !1), use_scaling = init.use_scaling === void 0 ? !0 : init.use_scaling, scale_pages = this.scale_pages = use_scaling && (init.scale_pages === void 0 ? !0 : init.scale_pages), container = this.container = init.container || fdjtDOM("div.codexpages"), origin = this.origin = init.origin || !1, logfn = this.logfn = init.logfn || CodexLayout.logfn || (fdjtLog !== void 0 ? fdjtLog : noop), pagenum = this.pagenum = 0, pages = this.pages = [], dups = this.dups = {}, crumbs = this.crumbs = {}, cur_root = this.root = !1, textsplits = this.textsplits = {}, splits = this.splits = {}, page = this.page = init.page, prev = this.prev = !1, prevstyle = this.prevstyle = !1, previnfo = this.previnfo = !1, drag = this.drag = [], floating = this.floating = [];
        init.layout_id && (this.layout_id = init.layout_id), this.started = !1;
        var trace = this.tracelevel = init.tracelevel || CodexLayout.tracelevel || fdjtState.getLocal("codexlayout.trace", !0) || 0, track = init.track || CodexLayout.track || fdjtState.getLocal("codexlayout.track") || !1, debug_match = init.debug || CodexLayout.debug || fdjtState.getLocal("codexlayout.debug") || !1;
        track && (this.track = track = fdjtDOM.Selector(track), trace || (trace = this.tracelevel = 1)), 
        debug_match ? (this.debug = debug_match = fdjtDOM.Selector(debug_match), trace || (trace = this.tracelevel = 1)) : this.debug = !1, 
        trace && addClass(document.body, "debugcodexlayout"), this.roots = init.roots || [], 
        this.root_count = 0, this.block_count = 0, this.lastid = !1, this.timeslice = init.hasOwnProperty("timeslice") ? init.timeslice : CodexLayout.timeslice, 
        this.timeskip = init.hasOwnProperty("timeskip") ? init.timeskip : CodexLayout.timeskip;
        var pagerule = this.pagerule = init.pagerule || !1;
        this.addContent = addContent;
        var replaceNode = fdjtDOM.replace;
        layout.setLayout = setLayout, this.saveLayout = saveLayout, this.restoreLayout = function(arg) {
            function restoring_layout(resolve, reject) {
                restoreLayout(arg, resolve, reject);
            }
            return new Promise(restoring_layout);
        };
        var adjust_node = fdjtDOM.scaleToFit.adjust;
        return this.finishPage = finishPage, this.Finish = Finish, this.forcedBreakBefore = forcedBreakBefore, 
        this.mustBreakBefore = mustBreakBefore, this.forcedBreakAfter = forcedBreakAfter, 
        this.mustBreakAfter = mustBreakAfter, this.avoidBreakInside = avoidBreakInside, 
        this.mustBreakInside = mustBreakInside, this.avoidBreakBefore = avoidBreakBefore, 
        this.cantBreakBefore = cantBreakBefore, this.avoidBreakAfter = avoidBreakAfter, 
        this.cantBreakAfter = cantBreakAfter, this.checkSinglePage = checkSinglePage, this.getPage = getPage, 
        this.getDup = getDup, this.gotoPage = gotoPage, this.Revert = function() {
            var i, lim;
            if (this.saved_ids) {
                var saved = this.saved_ids, allids = saved._all_ids, crumbs = this.crumbs;
                for (i = 0, lim = allids.length; lim > i; ) {
                    var original, id = allids[i++];
                    if (crumbs[id]) {
                        original = document.getElementById(id);
                        var oclass = original.getAttribute("data-savedclass"), ostyle = original.getAttribute("data-savedstyle"), crumb = crumbs[id];
                        oclass && (original.className = oclass, original.removeAttribute("data-savedclass")), 
                        ostyle && (original.setAttribute("style", ostyle), original.removeAttribute("data-savedstyle")), 
                        crumb.parentNode.replaceChild(original, crumb);
                    } else saved[id] && (original = saved[id], id && (original.id = id));
                }
                var lost = this.lostids, lostids = lost._all_ids;
                for (i = 0, lim = lostids.length; lim > i; ) {
                    var lostid = lostids[i++];
                    lostid && (lost[lostid].id = lostid);
                }
                return this.saved_ids = {}, this.dups = {}, this.lostids = {}, void 0;
            }
            fdjtDOM.scaleToFit.revertAll(), revertLayout(this);
        }, this;
    }
    function useIndexedDB(dbname) {
        function getting(resolve, reject) {
            if (layoutDB) return resolve(layoutDB);
            if (indexedDB && dbname) try {
                RefDB.useIndexedDB(dbname, 1, function(db) {
                    db.createObjectStore("layouts", {
                        keyPath: "layout_id"
                    });
                }).then(function(db) {
                    CodexLayout.layoutDB = layoutDB = db, CodexLayout.cache = 7, resolve(db);
                }).catch(function(trouble) {
                    fdjtLog("indexedDB failed: %o", trouble), CodexLayout.layoutDB = layoutDB = window.localStorage, 
                    resolve(layoutDB);
                });
            } catch (ex) {
                reject(ex);
            } else CodexLayout.layoutDB = layoutDB = window.localStorage, resolve(layoutDB);
        }
        return dbname === void 0 ? dbname = CodexLayout.dbname : CodexLayout.dbname = dbname, 
        new Promise(getting);
    }
    function cacheLayoutIDB(db, layout_id, content, ondone, onfail) {
        var req, txn = db.transaction([ "layouts" ], "readwrite"), storage = txn.objectStore("layouts");
        req = storage.put({
            layout_id: layout_id,
            layout: content
        }), req.onerror = function(event) {
            fdjtLog("Error saving layout %s: %o", layout_id, event.target.errorCode), onfail && onfail(event);
        }, req.onsuccess = function(event) {
            event = !1, fdjtLog("Layout %s cached", layout_id), ondone && ondone();
        };
    }
    function cacheLayout(layout_id, content) {
        function caching(resolve, reject) {
            return layoutDB ? cacheLayoutIDB(layoutDB, layout_id, content, resolve, reject) : useIndexedDB().then(function(db) {
                layoutDB = CodexLayout.layoutDB = window.LocalStorage, cacheLayoutIDB(db, layout_id, content, resolve, reject);
            }).catch(function() {
                layoutDB = CodexLayout.layoutDB = window.LocalStorage, setLocal(layout_id, content), 
                resolve && resolve(layoutDB);
            });
        }
        return new Promise(caching);
    }
    function dropLayout(layout_id) {
        var layout = !1;
        if (layoutDB) if (window.Storage && layoutDB instanceof window.Storage) {
            var dropLocal = fdjtState.dropLocal;
            dropLocal(layout_id), droppedLayout(layout_id);
        } else {
            var txn = layoutDB.transaction([ "layouts" ], "readwrite"), storage = txn.objectStore("layouts"), req = storage.get(layout_id), allDone = function allDone(event) {
                event = !1, droppedLayout(layout_id);
            }, whoops = function whoops(event) {
                event = !1, fdjtLog("Error removing laytout %s", layout_id);
            }, dropRoot = function dropRoot() {
                req = storage["delete"](layout_id), req.onerror = whoops, req.onsuccess = allDone;
            };
            req.onerror = whoops, req.onsuccess = function(evt) {
                layout = evt.target && evt.target.result, dropRoot();
            };
        } else ;
    }
    function fetchLayout(db, layout_id, callback, onerr) {
        var getLocal = fdjtState.getLocal, content = !1, layout_key = layout_id;
        if (window.Storage && db instanceof window.Storage) content = getLocal(layout_id) || !1, 
        content && cachedLayout(layout_id), setTimeout(function() {
            callback(content);
        }, 1); else if (db) {
            var txn = layoutDB.transaction([ "layouts" ]), storage = txn.objectStore("layouts"), req = storage && storage.get(layout_key);
            req || onerr("DB error"), req.onsuccess = function(evt) {
                var target = evt.target, result = target && target.result;
                target || onerr(!1), result && cachedLayout(layout_id), result ? callback(result.layout) : callback(!1);
            }, req.onerror = function(event) {
                onerr(event);
            };
        } else {
            if (!window.localStorage) return onerr ? onerr(!1) : callback ? callback(!1) : !1;
            content = fdjtState.getLocal(layout_key) || !1, content && cachedLayout(layout_id), 
            setTimeout(function() {
                callback(content);
            }, 0);
        }
    }
    function fetchLayoutFrom(db, layout_id) {
        function fetching_layout(resolve, reject) {
            return fetchLayout(db, layout_id, resolve, reject);
        }
        return new Promise(fetching_layout);
    }
    function fetchLayoutHandler(layout_id) {
        return useIndexedDB().then(function(db) {
            return fetchLayoutFrom(db, layout_id);
        }).catch(function(ex) {
            return fdjtLog("Layout DB init failed: %o", ex), fetchLayoutFrom(!1, layout_id);
        });
    }
    function clearLayoutsHandler() {
        var layouts = fdjtState.getLocal("fdjtCodex.layouts", !0), i = 0, lim = layouts && layouts.length;
        if (layouts) {
            for (;lim > i; ) dropLayout(layouts[i++]);
            fdjtState.dropLocal("fdjtCodex.layouts");
        }
    }
    function fetchAll(callback) {
        if (!layoutDB) return !1;
        var txn = layoutDB.transaction([ "layouts" ], "read"), storage = txn.objectStore("layouts"), layout_ids = [];
        storage.openCursor().onsuccess = function(evt) {
            var cursor = evt.target.result;
            cursor ? (layout_ids.push(cursor.key), cursor["continue"]()) : callback(layout_ids);
        };
    }
    function clearAllLayouts(spec) {
        fetchAll(function(layout_ids) {
            var todrop = [], i = 0, lim = layout_ids.length;
            if (!lim) return fdjtLog.warn("No layouts"), void 0;
            if (spec) for (;lim > i; ) {
                var id = layout_ids[i++];
                id.search(spec) >= 0 && todrop.push(id);
            } else todrop = layout_ids;
            if (0 === todrop.length) return fdjtLog.warn("No layouts match %s", spec), void 0;
            for (spec ? fdjtLog.warn("Dropping %d layouts matching %s", todrop.length, spec) : fdjtLog.warn("Dropping %d layouts", todrop.length), 
            i = 0, lim = todrop.length; lim > i; ) fdjtLog.warn("Dropping layout %s", todrop[i]), 
            dropLayout(todrop[i++]);
        });
    }
    function cachedLayout(layout_id) {
        setLocal("fdjtCodex.layout(" + layout_id + ")", layout_id), pushLocal("fdjtCodex.layouts", layout_id);
    }
    function droppedLayout(layout_id) {
        dropLocal("fdjtCodex.layout(" + layout_id + ")", layout_id), removeLocal("fdjtCodex.layouts", layout_id), 
        CodexLayout.trace && fdjtLog("Layout %s removed", layout_id);
    }
    var root_namespace, fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtAsync = fdjt.Async, fdjtTime = fdjt.Time, fdjtState = fdjt.State, RefDB = fdjt.RefDB, fdjtID = fdjt.ID, hasContent = fdjtDOM.hasContent, hasParent = fdjtDOM.hasParent, getParent = fdjtDOM.getParent, getStyle = fdjtDOM.getStyle, parsePX = fdjtDOM.parsePX, getLineHeight = fdjtDOM.getLineHeight, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, toArray = fdjtDOM.toArray, getElementValue = fdjtDOM.getElementValue, setLocal = fdjtState.setLocal, pushLocal = fdjtState.pushLocal, dropLocal = fdjtState.dropLocal, removeLocal = fdjtState.removeLocal, floor = Math.floor, iDB = fdjt.iDB, indexedDB = iDB.indexedDB;
    document.body ? root_namespace = document.body.namespaceURI : fdjtDOM.addListener(window, "load", function() {
        root_namespace = document.body.namespaceURI;
    });
    var layoutDB, getChildren = fdjtDOM.getChildren, getChild = fdjtDOM.getChild, Geometry = fdjtDOM.Geometry, XGeometry = fdjtDOM.XGeometry, notspace = /[^ \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff]/g, adjustFontSize = fdjt.DOM.adjustFontSize, adjustFonts = fdjt.DOM.adjustFonts, tweakImage = fdjt.DOM.tweakImage, tmpid_count = 1, dupstate = /\bcodexdup(start|end)?\b/g, codexstate = /\bcodex(dupstart|dup|dupend|relocated)\b/g;
    return CodexLayout.timeslice = 50, CodexLayout.timeskip = 5, CodexLayout.tracelevel = 0, 
    CodexLayout.prototype.getDups = function(id) {
        if (!id) return [];
        id.nodeType && (id = id.id);
        var base = fdjtID(id), dups = this.dups[id];
        return dups ? [ base ].concat(dups) : !1;
    }, CodexLayout.prototype.getLayoutInfo = function() {
        for (var allblocks = this.allmoves, npages = this.pages.length, pages = Array(npages + 1), pn = 0; npages >= pn; ) pages[pn++] = [];
        for (var bn = 0, blim = allblocks.length; blim > bn; ) {
            var block = allblocks[bn++], page = getParent(block, ".codexpage");
            if (page) {
                var num = parseInt(page.getAttribute("data-pagenum"), 10);
                if (pages[num]) {
                    var info = {
                        block: block
                    };
                    block.id && (info.id = block.id), block.className && (info.className = block.className), 
                    block.getAttribute("data-baseid") && (info.baseid = block.getAttribute("data-baseid")), 
                    pages[num].push(info);
                } else fdjtLog.warn("weird page number: %o", num);
            } else fdjtLog.warn("Can't find page for %o", block);
        }
        return pages;
    }, CodexLayout.prototype.getLayoutBlocks = function() {
        for (var allblocks = this.allblocks, blockinfo = [], i = 0, lim = allblocks.length; lim > i; ) {
            var block = allblocks[i++], page = getParent(block, ".codexpage"), num = parseInt(page.getAttribute("data-pagenum"), 10), info = {
                pagenum: num
            }, classname = block.className;
            block.id && (info.id = block.id), "string" != typeof classname || (classname.search(/\bcodexdup/g) >= 0 ? info.html = block.outerHTML : (block.id && (info.id = block.id), 
            classname.search(/\bcodexpagetop\b/) >= 0 && (info.pagetop = !0), classname.search(/\bcodexcantsplit\b/) >= 0 && (info.cantsplit = !0))), 
            blockinfo.push(info);
        }
        return {
            blocks: blockinfo,
            npages: this.pages.length,
            height: this.height,
            width: this.width,
            break_blocks: this.break_blocks
        };
    }, CodexLayout.cache = 2, CodexLayout.useIndexedDB = useIndexedDB, CodexLayout.cacheLayout = cacheLayout, 
    CodexLayout.dropLayout = dropLayout, CodexLayout.fetchLayout = fetchLayoutHandler, 
    CodexLayout.clearLayouts = clearLayoutsHandler, CodexLayout.fetchAll = fetchAll, 
    CodexLayout.clearAll = clearAllLayouts, CodexLayout.dbname = "codexlayout", CodexLayout;
}(), "undefined" != typeof window && window.fdjt && (window.CodexLayout = fdjt.CodexLayout);

var Markdown;

Markdown = "object" == typeof exports && "function" == typeof require ? exports : {}, 
function() {
    function identity(x) {
        return x;
    }
    function returnFalse() {
        return !1;
    }
    function HookCollection() {}
    function SaveHash() {}
    HookCollection.prototype = {
        chain: function(hookname, func) {
            var original = this[hookname];
            if (!original) throw Error("unknown hook " + hookname);
            this[hookname] = original === identity ? func : function() {
                var args = Array.prototype.slice.call(arguments, 0);
                return args[0] = original.apply(null, args), func.apply(null, args);
            };
        },
        set: function(hookname, func) {
            if (!this[hookname]) throw Error("unknown hook " + hookname);
            this[hookname] = func;
        },
        addNoop: function(hookname) {
            this[hookname] = identity;
        },
        addFalse: function(hookname) {
            this[hookname] = returnFalse;
        }
    }, Markdown.HookCollection = HookCollection, SaveHash.prototype = {
        set: function(key, value) {
            this["s_" + key] = value;
        },
        get: function(key) {
            return this["s_" + key];
        }
    }, Markdown.Converter = function() {
        function _StripLinkDefinitions(text) {
            return text = text.replace(/^[ ]{0,3}\[(.+)\]:[ \t]*\n?[ \t]*<?(\S+?)>?(?=\s|$)[ \t]*\n?[ \t]*((\n*)["(](.+?)[")][ \t]*)?(?:\n+)/gm, function(wholeMatch, m1, m2, m3, m4, m5) {
                return m1 = m1.toLowerCase(), g_urls.set(m1, _EncodeAmpsAndAngles(m2)), m4 ? m3 : (m5 && g_titles.set(m1, m5.replace(/"/g, "&quot;")), 
                "");
            });
        }
        function _HashHTMLBlocks(text) {
            return text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm, hashElement), 
            text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\b[^\r]*?.*<\/\2>[ \t]*(?=\n+)\n)/gm, hashElement), 
            text = text.replace(/\n[ ]{0,3}((<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g, hashElement), 
            text = text.replace(/\n\n[ ]{0,3}(<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>[ \t]*(?=\n{2,}))/g, hashElement), 
            text = text.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g, hashElement);
        }
        function hashElement(wholeMatch, m1) {
            var blockText = m1;
            return blockText = blockText.replace(/^\n+/, ""), blockText = blockText.replace(/\n+$/g, ""), 
            blockText = "\n\n~K" + (g_html_blocks.push(blockText) - 1) + "K\n\n";
        }
        function _RunBlockGamut(text, doNotUnhash) {
            text = pluginHooks.preBlockGamut(text, blockGamutHookCallback), text = _DoHeaders(text);
            var replacement = "<hr />\n";
            return text = text.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm, replacement), text = text.replace(/^[ ]{0,2}([ ]?-[ ]?){3,}[ \t]*$/gm, replacement), 
            text = text.replace(/^[ ]{0,2}([ ]?_[ ]?){3,}[ \t]*$/gm, replacement), text = _DoLists(text), 
            text = _DoCodeBlocks(text), text = _DoBlockQuotes(text), text = pluginHooks.postBlockGamut(text, blockGamutHookCallback), 
            text = _HashHTMLBlocks(text), text = _FormParagraphs(text, doNotUnhash);
        }
        function _RunSpanGamut(text) {
            return text = pluginHooks.preSpanGamut(text), text = _DoCodeSpans(text), text = _EscapeSpecialCharsWithinTagAttributes(text), 
            text = _EncodeBackslashEscapes(text), text = _DoImages(text), text = _DoAnchors(text), 
            text = _DoAutoLinks(text), text = text.replace(/~P/g, "://"), text = _EncodeAmpsAndAngles(text), 
            text = _DoItalicsAndBold(text), text = text.replace(/  +\n/g, " <br>\n"), text = pluginHooks.postSpanGamut(text);
        }
        function _EscapeSpecialCharsWithinTagAttributes(text) {
            var regex = /(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>)/gi;
            return text = text.replace(regex, function(wholeMatch) {
                var tag = wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`");
                return tag = escapeCharacters(tag, "!" == wholeMatch.charAt(1) ? "\\`*_/" : "\\`*_");
            });
        }
        function _DoAnchors(text) {
            return text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeAnchorTag), 
            text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?((?:\([^)]*\)|[^()\s])*?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeAnchorTag), 
            text = text.replace(/(\[([^\[\]]+)\])()()()()()/g, writeAnchorTag);
        }
        function writeAnchorTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
            void 0 == m7 && (m7 = "");
            var whole_match = m1, link_text = m2.replace(/:\/\//g, "~P"), link_id = m3.toLowerCase(), url = m4, title = m7;
            if ("" == url) if ("" == link_id && (link_id = link_text.toLowerCase().replace(/ ?\n/g, " ")), 
            url = "#" + link_id, void 0 != g_urls.get(link_id)) url = g_urls.get(link_id), void 0 != g_titles.get(link_id) && (title = g_titles.get(link_id)); else {
                if (!(whole_match.search(/\(\s*\)$/m) > -1)) return whole_match;
                url = "";
            }
            url = encodeProblemUrlChars(url), url = escapeCharacters(url, "*_");
            var result = '<a href="' + url + '"';
            return "" != title && (title = attributeEncode(title), title = escapeCharacters(title, "*_"), 
            result += ' title="' + title + '"'), result += ">" + link_text + "</a>";
        }
        function _DoImages(text) {
            return text = text.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeImageTag), 
            text = text.replace(/(!\[(.*?)\]\s?\([ \t]*()<?(\S+?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeImageTag);
        }
        function attributeEncode(text) {
            return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
        }
        function writeImageTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
            var whole_match = m1, alt_text = m2, link_id = m3.toLowerCase(), url = m4, title = m7;
            if (title || (title = ""), "" == url) {
                if ("" == link_id && (link_id = alt_text.toLowerCase().replace(/ ?\n/g, " ")), url = "#" + link_id, 
                void 0 == g_urls.get(link_id)) return whole_match;
                url = g_urls.get(link_id), void 0 != g_titles.get(link_id) && (title = g_titles.get(link_id));
            }
            alt_text = escapeCharacters(attributeEncode(alt_text), "*_[]()"), url = escapeCharacters(url, "*_");
            var result = '<img src="' + url + '" alt="' + alt_text + '"';
            return title = attributeEncode(title), title = escapeCharacters(title, "*_"), result += ' title="' + title + '"', 
            result += " />";
        }
        function _DoHeaders(text) {
            return text = text.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm, function(wholeMatch, m1) {
                return "<h1>" + _RunSpanGamut(m1) + "</h1>\n\n";
            }), text = text.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm, function(matchFound, m1) {
                return "<h2>" + _RunSpanGamut(m1) + "</h2>\n\n";
            }), text = text.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm, function(wholeMatch, m1, m2) {
                var h_level = m1.length;
                return "<h" + h_level + ">" + _RunSpanGamut(m2) + "</h" + h_level + ">\n\n";
            });
        }
        function _DoLists(text, isInsideParagraphlessListItem) {
            text += "~0";
            var whole_list = /^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;
            return g_list_level ? text = text.replace(whole_list, function(wholeMatch, m1, m2) {
                var list = m1, list_type = m2.search(/[*+-]/g) > -1 ? "ul" : "ol", result = _ProcessListItems(list, list_type, isInsideParagraphlessListItem);
                return result = result.replace(/\s+$/, ""), result = "<" + list_type + ">" + result + "</" + list_type + ">\n";
            }) : (whole_list = /(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/g, 
            text = text.replace(whole_list, function(wholeMatch, m1, m2, m3) {
                var runup = m1, list = m2, list_type = m3.search(/[*+-]/g) > -1 ? "ul" : "ol", result = _ProcessListItems(list, list_type);
                return result = runup + "<" + list_type + ">\n" + result + "</" + list_type + ">\n";
            })), text = text.replace(/~0/, "");
        }
        function _ProcessListItems(list_str, list_type, isInsideParagraphlessListItem) {
            g_list_level++, list_str = list_str.replace(/\n{2,}$/, "\n"), list_str += "~0";
            var marker = _listItemMarkers[list_type], re = RegExp("(^[ \\t]*)(" + marker + ")[ \\t]+([^\\r]+?(\\n+))(?=(~0|\\1(" + marker + ")[ \\t]+))", "gm"), last_item_had_a_double_newline = !1;
            return list_str = list_str.replace(re, function(wholeMatch, m1, m2, m3) {
                var item = m3, ends_with_double_newline = /\n\n$/.test(item), contains_double_newline = ends_with_double_newline || item.search(/\n{2,}/) > -1;
                return contains_double_newline || last_item_had_a_double_newline ? item = _RunBlockGamut(_Outdent(item), !0) : (item = _DoLists(_Outdent(item), !0), 
                item = item.replace(/\n$/, ""), isInsideParagraphlessListItem || (item = _RunSpanGamut(item))), 
                last_item_had_a_double_newline = ends_with_double_newline, "<li>" + item + "</li>\n";
            }), list_str = list_str.replace(/~0/g, ""), g_list_level--, list_str;
        }
        function _DoCodeBlocks(text) {
            return text += "~0", text = text.replace(/(?:\n\n|^\n?)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g, function(wholeMatch, m1, m2) {
                var codeblock = m1, nextChar = m2;
                return codeblock = _EncodeCode(_Outdent(codeblock)), codeblock = _Detab(codeblock), 
                codeblock = codeblock.replace(/^\n+/g, ""), codeblock = codeblock.replace(/\n+$/g, ""), 
                codeblock = "<pre><code>" + codeblock + "\n</code></pre>", "\n\n" + codeblock + "\n\n" + nextChar;
            }), text = text.replace(/~0/, "");
        }
        function hashBlock(text) {
            return text = text.replace(/(^\n+|\n+$)/g, ""), "\n\n~K" + (g_html_blocks.push(text) - 1) + "K\n\n";
        }
        function _DoCodeSpans(text) {
            return text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm, function(wholeMatch, m1, m2, m3) {
                var c = m3;
                return c = c.replace(/^([ \t]*)/g, ""), c = c.replace(/[ \t]*$/g, ""), c = _EncodeCode(c), 
                c = c.replace(/:\/\//g, "~P"), m1 + "<code>" + c + "</code>";
            });
        }
        function _EncodeCode(text) {
            return text = text.replace(/&/g, "&amp;"), text = text.replace(/</g, "&lt;"), text = text.replace(/>/g, "&gt;"), 
            text = escapeCharacters(text, "*_{}[]\\", !1);
        }
        function _DoItalicsAndBold(text) {
            return text = text.replace(/([\W_]|^)(\*\*|__)(?=\S)([^\r]*?\S[\*_]*)\2([\W_]|$)/g, "$1<strong>$3</strong>$4"), 
            text = text.replace(/([\W_]|^)(\*|_)(?=\S)([^\r\*_]*?\S)\2([\W_]|$)/g, "$1<em>$3</em>$4");
        }
        function _DoBlockQuotes(text) {
            return text = text.replace(/((^[ \t]*>[ \t]?.+\n(.+\n)*\n*)+)/gm, function(wholeMatch, m1) {
                var bq = m1;
                return bq = bq.replace(/^[ \t]*>[ \t]?/gm, "~0"), bq = bq.replace(/~0/g, ""), bq = bq.replace(/^[ \t]+$/gm, ""), 
                bq = _RunBlockGamut(bq), bq = bq.replace(/(^|\n)/g, "$1  "), bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function(wholeMatch, m1) {
                    var pre = m1;
                    return pre = pre.replace(/^  /gm, "~0"), pre = pre.replace(/~0/g, "");
                }), hashBlock("<blockquote>\n" + bq + "\n</blockquote>");
            });
        }
        function _FormParagraphs(text, doNotUnhash) {
            text = text.replace(/^\n+/g, ""), text = text.replace(/\n+$/g, "");
            for (var grafs = text.split(/\n{2,}/g), grafsOut = [], markerRe = /~K(\d+)K/, end = grafs.length, i = 0; end > i; i++) {
                var str = grafs[i];
                markerRe.test(str) ? grafsOut.push(str) : /\S/.test(str) && (str = _RunSpanGamut(str), 
                str = str.replace(/^([ \t]*)/g, "<p>"), str += "</p>", grafsOut.push(str));
            }
            if (!doNotUnhash) {
                end = grafsOut.length;
                for (var i = 0; end > i; i++) for (var foundAny = !0; foundAny; ) foundAny = !1, 
                grafsOut[i] = grafsOut[i].replace(/~K(\d+)K/g, function(wholeMatch, id) {
                    return foundAny = !0, g_html_blocks[id];
                });
            }
            return grafsOut.join("\n\n");
        }
        function _EncodeAmpsAndAngles(text) {
            return text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;"), text = text.replace(/<(?![a-z\/?!]|~D)/gi, "&lt;");
        }
        function _EncodeBackslashEscapes(text) {
            return text = text.replace(/\\(\\)/g, escapeCharacters_callback), text = text.replace(/\\([`*_{}\[\]()>#+-.!])/g, escapeCharacters_callback);
        }
        function handleTrailingParens(wholeMatch, lookbehind, protocol, link) {
            if (lookbehind) return wholeMatch;
            if (")" !== link.charAt(link.length - 1)) return "<" + protocol + link + ">";
            for (var parens = link.match(/[()]/g), level = 0, i = 0; parens.length > i; i++) "(" === parens[i] ? 0 >= level ? level = 1 : level++ : level--;
            var tail = "";
            if (0 > level) {
                var re = RegExp("\\){1," + -level + "}$");
                link = link.replace(re, function(trailingParens) {
                    return tail = trailingParens, "";
                });
            }
            if (tail) {
                var lastChar = link.charAt(link.length - 1);
                endCharRegex.test(lastChar) || (tail = lastChar + tail, link = link.substr(0, link.length - 1));
            }
            return "<" + protocol + link + ">" + tail;
        }
        function _DoAutoLinks(text) {
            text = text.replace(autoLinkRegex, handleTrailingParens);
            var replacer = function(wholematch, m1) {
                return '<a href="' + m1 + '">' + pluginHooks.plainLinkText(m1) + "</a>";
            };
            return text = text.replace(/<((https?|ftp):[^'">\s]+)>/gi, replacer);
        }
        function _UnescapeSpecialChars(text) {
            return text = text.replace(/~E(\d+)E/g, function(wholeMatch, m1) {
                var charCodeToReplace = parseInt(m1);
                return String.fromCharCode(charCodeToReplace);
            });
        }
        function _Outdent(text) {
            return text = text.replace(/^(\t|[ ]{1,4})/gm, "~0"), text = text.replace(/~0/g, "");
        }
        function _Detab(text) {
            if (!/\t/.test(text)) return text;
            var v, spaces = [ "    ", "   ", "  ", " " ], skew = 0;
            return text.replace(/[\n\t]/g, function(match, offset) {
                return "\n" === match ? (skew = offset + 1, match) : (v = (offset - skew) % 4, skew = offset + 1, 
                spaces[v]);
            });
        }
        function encodeProblemUrlChars(url) {
            if (!url) return "";
            var len = url.length;
            return url.replace(_problemUrlChars, function(match, offset) {
                return "~D" == match ? "%24" : ":" != match || offset != len - 1 && !/[0-9\/]/.test(url.charAt(offset + 1)) ? "%" + match.charCodeAt(0).toString(16) : ":";
            });
        }
        function escapeCharacters(text, charsToEscape, afterBackslash) {
            var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";
            afterBackslash && (regexString = "\\\\" + regexString);
            var regex = RegExp(regexString, "g");
            return text = text.replace(regex, escapeCharacters_callback);
        }
        function escapeCharacters_callback(wholeMatch, m1) {
            var charCodeToEscape = m1.charCodeAt(0);
            return "~E" + charCodeToEscape + "E";
        }
        var pluginHooks = this.hooks = new HookCollection();
        pluginHooks.addNoop("plainLinkText"), pluginHooks.addNoop("preConversion"), pluginHooks.addNoop("postNormalization"), 
        pluginHooks.addNoop("preBlockGamut"), pluginHooks.addNoop("postBlockGamut"), pluginHooks.addNoop("preSpanGamut"), 
        pluginHooks.addNoop("postSpanGamut"), pluginHooks.addNoop("postConversion");
        var g_urls, g_titles, g_html_blocks, g_list_level;
        this.makeHtml = function(text) {
            if (g_urls) throw Error("Recursive call to converter.makeHtml");
            return g_urls = new SaveHash(), g_titles = new SaveHash(), g_html_blocks = [], g_list_level = 0, 
            text = pluginHooks.preConversion(text), text = text.replace(/~/g, "~T"), text = text.replace(/\$/g, "~D"), 
            text = text.replace(/\r\n/g, "\n"), text = text.replace(/\r/g, "\n"), text = "\n\n" + text + "\n\n", 
            text = _Detab(text), text = text.replace(/^[ \t]+$/gm, ""), text = pluginHooks.postNormalization(text), 
            text = _HashHTMLBlocks(text), text = _StripLinkDefinitions(text), text = _RunBlockGamut(text), 
            text = _UnescapeSpecialChars(text), text = text.replace(/~D/g, "$$"), text = text.replace(/~T/g, "~"), 
            text = pluginHooks.postConversion(text), g_html_blocks = g_titles = g_urls = null, 
            text;
        };
        var blockGamutHookCallback = function(t) {
            return _RunBlockGamut(t);
        }, _listItemMarkers = {
            ol: "\\d+[.]",
            ul: "[*+-]"
        }, charInsideUrl = "[-A-Z0-9+&@#/%?=~_|[\\]()!:,.;]", charEndingUrl = "[-A-Z0-9+&@#/%=~_|[\\])]", autoLinkRegex = RegExp('(="|<)?\\b(https?|ftp)(://' + charInsideUrl + "*" + charEndingUrl + ")(?=$|\\W)", "gi"), endCharRegex = RegExp(charEndingUrl, "i"), _problemUrlChars = /(?:["'*()[\]:]|~D)/g;
    };
}();

var metaBook = {
    mode: !1,
    hudup: !1,
    scrolling: !1,
    query: !1,
    head: !1,
    target: !1,
    glosstarget: !1,
    location: !1,
    root: !1,
    start: !1,
    HUD: !1,
    locsync: !1,
    useidb: !1,
    noidb: !1,
    user: !1,
    loggedin: !1,
    cxthelp: !1,
    _setup: !1,
    _user_setup: !1,
    _gloss_setup: !1,
    _social_setup: !1,
    delay_startup: !1,
    connected: !1,
    curpage: !1,
    curoff: !1,
    curinfo: !1,
    curbottom: !1,
    last_mode: !1,
    last_heartmode: "about",
    demo: !1,
    taptapmsecs: 200,
    holdmsecs: 300,
    edgeclick: 50,
    pagesize: 250,
    dontanimate: !1,
    nativeselect: !1,
    minswipe: 7,
    uisound: !1,
    readsound: !1,
    glossmodes: /(addtag)|(addoutlet)|(editdetail)|(hamburger)|(attach)/,
    fullheight: !1,
    fullwidth: !1,
    handheld: !1,
    updatehash: !0,
    missing_nodes: [],
    cache_layout_thresh: 2500,
    long_layout_thresh: 5e3,
    resize_wait: 500,
    forcelayout: !1,
    freezelayout: !1,
    persist: !1,
    cacheglosses: !1,
    saveprops: [ "sources", "outlets", "layers", "sync", "nodeid", "state" ],
    keepdata: !1,
    mouse: !0,
    touch: !1,
    kbd: !1,
    keyboard: !0,
    pagers: {
        allglosses: "METABOOKALLGLOSSES",
        searchresults: "METABOOKSEARCHRESULTS",
        statictoc: "METABOOKSTATICTOC"
    },
    min_excerpt: 3,
    max_excerpt: !1,
    queued: [],
    tagweights: !1,
    tagmaxweight: 0,
    tagminweight: 2e8,
    refuri: !1,
    refuris: [],
    docuri: !1,
    mycopyid: !1,
    syncstamp: !1,
    update_interval: 3e4,
    update_timeout: 3e4,
    update_pause: 18e5,
    sync_interval: 18e4,
    sync_min: 1e4,
    sync_timeout: 15e3,
    sync_pause: 3e5,
    UI: {
        handlers: {
            mouse: {},
            touch: {},
            kbd: {},
            ios: {}
        }
    },
    Debug: {},
    HTML: {},
    DOM: {},
    CSS: {},
    TapHold: {},
    slices: {},
    xtargets: {},
    xrules: [],
    Timeline: {},
    allterms: [],
    prefixes: {},
    openinbook: [ "https://www.youtube.com/" ],
    srcloading: {},
    glossdata: {},
    inits: {
        local: [],
        app: [],
        head: [],
        body: [],
        dom: []
    },
    default_config: {
        layout: "bypage",
        bodysize: "normal",
        bodyfamily: "serif",
        bodycontrast: "high",
        textjustify: !1,
        linespacing: "normal",
        uisize: "normal",
        dyslexical: !1,
        animatecontent: !0,
        animatehud: !0,
        hidesplash: !1,
        keyboardhelp: !0,
        holdmsecs: 300,
        wandermsecs: 1500,
        taptapmsecs: 200,
        locsync: !0,
        syncinterval: 60,
        checksync: 900,
        glossupdate: 300,
        cacheglosses: !0,
        soundeffects: !1,
        buzzeffects: !1,
        showconsole: !1,
        devmode: !1,
        controlc: !1
    },
    Trace: {
        startup: 1,
        config: 0,
        mode: !1,
        nav: !1,
        creds: !1,
        domscan: 0,
        search: 0,
        clouds: 0,
        target: !1,
        toc: !1,
        storage: 0,
        network: 0,
        state: 0,
        savegloss: 0,
        glosses: 0,
        addgloss: 0,
        glossdata: 0,
        slices: 0,
        pagers: 0,
        layout: 0,
        knodules: 0,
        preview: !1,
        flips: !1,
        skimming: !1,
        resize: !1,
        messages: !1,
        glossing: !1,
        selection: !1,
        highlight: 0,
        indexing: 0,
        zoom: 0,
        gestures: 0
    }
};

"undefined" == typeof mB && (mB = metaBook), fdjt.DOM.noautofontadjust = !0, function() {
    "use strict";
    function hasLocal(key) {
        return mB.persist ? existsLocal(key) : fdjtState.existsSession(key);
    }
    function elt_unparser(arg) {
        return "string" == typeof arg ? arg : arg._qid ? arg._qid : arg.getQID ? (arg._qid = arg.getQID()) || "" + arg : JSON.stringify(arg);
    }
    function unparser(arg) {
        if ("string" == typeof arg) return arg;
        if (Array.isArray(arg)) {
            for (var i = 0, lim = arg.length, result = []; lim > i; ) {
                var elt = arg[i++];
                result.push(elt_unparser(elt));
            }
            return JSON.stringify(result);
        }
        return elt_unparser(arg);
    }
    function saveLocal(key, value, unparse) {
        unparse && (value = unparser(value)), mB.persist ? setLocal(key, value, !1) : fdjtState.setSession(key, value, !1);
    }
    function readLocal(key, parse) {
        return mB.persist ? existsLocal(key) ? getLocal(key, parse) : fdjtState.existsSession(key) ? (setLocal(key, fdjtState.getSession(key)), 
        getLocal(key, parse)) : !1 : fdjtState.getSession(key, parse) || getLocal(key, parse);
    }
    function clearLocal(key) {
        fdjtState.dropLocal(key), fdjtState.dropSession(key);
    }
    function dropVal(key, val) {
        var local = fdjtState.getLocal(key, !0), session = fdjtState.getSession(key, !0);
        local && (val ? local.indexOf(val) >= 0 && (local = RefDB.remove(local, val), local.length ? fdjtState.setLocal(key, local) : fdjtState.dropLocal(key, local)) : fdjtState.dropLocal(key)), 
        session && (val ? session.indexOf(val) >= 0 && (session = RefDB.remove(session, val), 
        session.length ? fdjtState.setSession(key, session) : fdjtState.dropSession(key)) : fdjtState.dropSession(key));
    }
    function getDB() {
        function gettingdb(resolve, reject) {
            if (metaBookDB) resolve(metaBookDB); else if (indexedDB && !mB.noidb) dbwait.push(resolve), 
            reject && dbfail.push(reject); else {
                if (!reject) return;
                reject(!1);
            }
        }
        return new Promise(gettingdb);
    }
    function gotDB(db) {
        metaBook.metaBookDB = metaBookDB = db, fdjtAsync(function() {
            fdjt.CodexLayout.useIndexedDB(db.name);
        });
        var waiting = dbwait;
        dbwait = [], dbfail = [];
        for (var i = 0, len = waiting.length; len > i; ) waiting[i++](db);
    }
    function notDB(action, name, ex) {
        var waiting = dbfail;
        dbwait = [], dbfail = [], fdjtLog("Error %s database %s: %o", action, name, ex);
        for (var i = 0, len = waiting.length; len > i; ) waiting[i++](ex);
    }
    function createDatabases(refuri) {
        function Gloss() {
            return Ref.apply(this, arguments);
        }
        if (!databases_created) {
            databases_created = !0, metaBook.docdb = new RefDB(refuri + "#", {
                indices: [ "frag", "head", "heads", "tags", "tags*", "*tags", "**tags", "~tags", "*tags", "**tags", "~tags", "*tags*", "**tags*", "~tags*", "^tags", "~^tags", "*^tags", "**^tags", "^tags*", "~^tags*", "*^tags*", "**^tags*" ]
            }), metaBook.docdb.slots = [ "head", "heads" ], metaBook.BRICO = new Knodule("BRICO"), 
            metaBook.BRICO.addAlias(":@1/"), metaBook.BRICO.addAlias("@1/");
            var glosses_init = {
                indices: [ "frag", "maker", "outlets", "tags", "*tags", "**tags", "tags*", "*tags*", "**tags*" ]
            }, glossdbname = "glosses@" + refuri, glossdb = metaBook.glossdb = new RefDB(glossdbname, glosses_init);
            glossdb.absrefs = !0, glossdb.dbname = "glosses", glossdb.addAlias("glossdb"), glossdb.addAlias("-UUIDTYPE=61"), 
            glossdb.addAlias(":@31055/"), glossdb.addAlias("@31055/"), Gloss.prototype = new Ref();
            var exportTagSlot = Knodule.exportTagSlot, tag_export_rules = {
                "*tags": exportTagSlot,
                "**tags": exportTagSlot,
                "~tags": exportTagSlot,
                "~~tags": exportTagSlot,
                tags: exportTagSlot,
                "*tags*": exportTagSlot,
                "**tags*": exportTagSlot,
                "~tags*": exportTagSlot,
                "~~tags*": exportTagSlot,
                "tags*": exportTagSlot,
                "*tags**": exportTagSlot,
                "**tags**": exportTagSlot,
                "~tags**": exportTagSlot,
                "~~tags**": exportTagSlot,
                "tags**": exportTagSlot
            };
            metaBook.tag_export_rules = tag_export_rules, metaBook.tag_import_rules = tag_export_rules, 
            Gloss.prototype.ExportExternal = function() {
                return Ref.Export.call(this, tag_export_rules);
            }, metaBook.glossdb.refclass = Gloss;
            var sourcedbname = "sources@" + refuri, sourcedb = metaBook.sourcedb = new RefDB(sourcedbname);
            sourcedb.absrefs = !0, sourcedb.dbname = "sources", sourcedb.oidrefs = !0, sourcedb.addAlias("@1961/"), 
            sourcedb.addAlias(":@1961/"), sourcedb.addAlias("@acc/"), sourcedb.addAlias(":@acc/"), 
            sourcedb.onLoad(function(item) {
                item.pic && "string" == typeof item.pic && 0 === item.pic.search("data:") && (item._pic = fdjtDOM.data2URL(item.pic));
            }), sourcedb.forDOM = function(source) {
                var spec = "span.source" + (source.kind ? "." : "") + (source.kind ? source.kind.slice(1).toLowerCase() : ""), name = source.name || source.oid || source.uuid || source.uuid, span = fdjtDOM(spec, name);
                return source.about && (span.title = source.about), span;
            };
        }
    }
    function initDB() {
        function setCacheGlosses(value) {
            var saveprops = metaBook.saveprops, docid = mB.docid;
            if (value) {
                if (metaBook.user) {
                    if (mB.useidb && !mB.noidb) getDB().then(function(db) {
                        metaBook.sourcedb.storage = db, metaBook.glossdb.storage = db;
                    }); else {
                        var storage = mB.persist ? window.localStorage : window.sessionStorage;
                        metaBook.sourcedb.storage || (metaBook.sourcedb.storage = storage), metaBook.glossdb.storage || (metaBook.glossdb.storage = storage);
                    }
                    for (var props = metaBook.saveprops, i = 0, lim = props.length; lim > i; ) {
                        var prop = saveprops[i++];
                        metaBook[prop] && saveLocal("mB(" + docid + ")." + prop, metaBook[prop], !0);
                    }
                    metaBook.glossdb.save(!0), metaBook.sourcedb.save(!0), metaBook.queued = metaBook.queued && metaBook.queued.length ? metaBook.queued.concat(getLocal("mB(" + docid + ").queued", !0) || []) : getLocal("mB(" + docid + ").queued", !0) || [];
                }
                metaBook.cacheglosses = !0;
            } else clearOffline(metaBook.docuri), docid && fdjtState.dropLocal("mB(" + docid + ").queued"), 
            metaBook.queued = [], metaBook.cacheglosses = !1;
        }
        function saveProps(props_arg) {
            for (var docid = mB.docid, props = props_arg ? Array.isArray(props_arg) ? props_arg : [ props ] : metaBook.saveprops, i = 0, lim = props.length; lim > i; ) {
                var prop = props[i++];
                metaBook[prop] && saveLocal("mB(" + docid + ")." + prop, metaBook[prop], !0);
            }
        }
        function setPersist() {
            metaBook.persist = !0;
            var refuri = mB.refuri, docuri = mB.docuri, docid = mB.docid;
            saveLocal("mB(" + docid + ")", docuri);
            var refuris = readLocal("mB.refuris", !0), docuris = readLocal("mB.docuris", !0), docids = readLocal("mB.docids", !0);
            refuris ? 0 > refuris.indexOf(refuri) && (refuris.push(refuri), saveLocal("mB.refuris", refuris, !0)) : saveLocal("mB.refuris", [ refuri ], !0), 
            docuris ? 0 > docuris.indexOf(docuri) && (docuris.push(docuri), saveLocal("mB.docuris", docuris, !0)) : saveLocal("mB.docuris", [ docuri ], !0), 
            docids ? 0 > docids.indexOf(docid) && (docids.push(docid), saveLocal("mB.docids", docids, !0)) : saveLocal("mB.docids", [ docid ], !0), 
            mB.sourceid && saveLocal("mB(" + mB.docid + ").sourceid", mB.sourceid);
        }
        function clearOffline(docid) {
            var dropLocal = fdjtState.dropLocal;
            if (docid) {
                "string" != typeof docid && (docid = metaBook.docid), docid === mB.docid && (location.hash = "");
                var sourceid = getLocal("mB(" + docid + ").sourceid");
                sourceid && metaBook.clearLayouts(sourceid);
                for (var refuri = getLocal("mB(" + docid + ").refuri") || docid === mB.docid && mB.refuri, docuri = getLocal("mB(" + docid + ").docuri") || docid === mB.docid && mB.docuri, refuris = mB.refuris, r = 0, n_refs = refuris.length; n_refs > r; ) clearLocal("allids(sources@" + refuris[r] + ")"), 
                clearLocal("allids(glosses@" + refuris[r] + ")"), r++;
                dropVal("mB.docids", docid), dropVal("mB.refuris", refuri), dropVal("mB.docuris", docuri), 
                metaBook.sync = !1, metaBook.glossdb.clearOffline(function() {
                    clearLocal("mB(" + docid + ").sync");
                }), metaBook.clearGlossData(docid), dropVal(RegExp("mB\\(" + docid + "\\).*"));
            } else {
                var books = readLocal("mB.docids", !0);
                if (books) for (var i = 0, lim = books.length; lim > i; ) clearOffline(books[i++]);
                dropLocal("mB.user"), dropLocal("mB.docuris"), dropLocal("mB.docids"), fdjt.CodexLayout.clearLayouts(), 
                fdjtState.clearLocal(), fdjtState.clearSession(), window.location.hash = "";
            }
        }
        function refreshOffline() {
            var docid = metaBook.docid;
            metaBook.sync = !1, clearLocal("mB(" + docid + ").sources"), clearLocal("mB(" + docid + ").outlets"), 
            clearLocal("mB(" + docid + ").layers"), clearLocal("mB(" + docid + ").etc"), metaBook.glossdb.clearOffline(function() {
                clearLocal("mB(" + docid + ").sync"), setTimeout(metaBook.updateInfo, 25);
            });
        }
        if (!db_initialized) {
            db_initialized = !0, Trace.start > 1 && fdjtLog("Initializing DB");
            var refuri = metaBook.refuri || document.location.href;
            refuri.indexOf("#") > 0 && (refuri = refuri.slice(0, refuri.indexOf("#"))), createDatabases(refuri), 
            metaBook.setupGlossData();
            var taglist = metaBook.taglist || $ID("METABOOKTAGLIST");
            taglist || (taglist = metaBook.taglist = fdjt.DOM("datalist#METABOOKTAGLIST"), document.body.appendChild(taglist));
            var knodeToOption = Knodule.knodeToOption, cachelink = /^https:\/\/glossdata.(sbooks\.net|metabooks\.net|beingmeta\.com|bookhub\.io)\//;
            mB.cachelink = cachelink;
            var knodule_name = fdjtDOM.getMeta("METABOOK.knodule") || fdjtDOM.getMeta("PUBTOOL.knodule") || fdjtDOM.getMeta("~KNODULE") || refuri;
            metaBook.knodule = new Knodule(knodule_name), Knodule.current = metaBook.knodule;
            var stdspace = fdjtString.stdspace, glossdb = metaBook.glossdb;
            glossdb.onLoad(function(item) {
                var info = metaBook.docinfo[item.frag];
                if (!info) return fdjtLog("Gloss (onload) refers to nonexistent '%s': %o", item.frag, item), 
                void 0;
                info && info.starts_at && (item.starts_at = info.starts_at + (item.exoff || 0)), 
                info && info.ends_at && (item.ends_at = item.excerpt ? info.ends_at + (item.exoff || 0) + stdspace(item.excerpt).length : info.ends_at), 
                !item.maker && metaBook.user && (item.maker = metaBook.user);
                var addTags = metaBook.addTags, addTag2Cloud = metaBook.addTag2Cloud, empty_cloud = metaBook.empty_cloud, maker = item.maker && metaBook.sourcedb.ref(item.maker);
                if (item.links) {
                    var links = item.links;
                    for (var link in links) if (links.hasOwnProperty(link) && links[link]) {
                        if (cachelink.exec(link)) {
                            var newlink = link.replace("//glossdata.sbooks.net/", "//glossdata.bookhub.io/");
                            link !== newlink && (links[newlink] = links[link], delete links[link], link = newlink);
                        }
                        links.hasOwnProperty(link) && cachelink.exec(link) && metaBook.needGlossData(link);
                    }
                }
                maker && (metaBook.addTag2Cloud(maker, metaBook.empty_cloud), metaBook.UI.addGlossSource(maker, !0));
                var i, lim, maker_knodule = metaBook.getMakerKnodule(item.maker), sources = item.sources;
                if (sources && ("string" == typeof sources && (sources = [ sources ]), sources && sources.length)) for (i = 0, 
                lim = sources.length; lim > i; ) {
                    var source = sources[i++], ref = metaBook.sourcedb.ref(source);
                    metaBook.UI.addGlossSource(ref, !0);
                }
                var alltags = item.alltags;
                if (alltags && alltags.length) {
                    for (i = 0, lim = alltags.length; lim > i; ) {
                        var entry, each_tag = alltags[i++];
                        entry = addTag2Cloud(each_tag, empty_cloud), entry = addTag2Cloud(each_tag, metaBook.gloss_cloud), 
                        taglist.appendChild(knodeToOption(each_tag));
                    }
                    for (var tag_slots = [ "tags", "*tags", "**tags" ], s = 0, n_slots = tag_slots.length; n_slots > s; ) {
                        var tagslot = tag_slots[s++], tags = item[tagslot];
                        if (tags && tags.length) {
                            var fragslot = "+" + tagslot;
                            item.thread && (addTags(item.thread, tags, fragslot), item.replyto !== item.thread && addTags(item.replyto, tags, fragslot)), 
                            info && addTags(info, tags, fragslot, maker_knodule);
                        }
                    }
                }
            }, "initgloss"), metaBook.user && mB.persist && metaBook.cacheglosses && (mB.useidb && !mB.noidb ? getDB().then(function(db) {
                glossdb.storage = db;
            }) : glossdb.storage = localStorage), metaBook.queued = metaBook.cacheglosses && getLocal("mB(" + metaBook.docid + ").queued", !0) || [], 
            metaBook.setCacheGlosses = setCacheGlosses, metaBook.saveProps = saveProps, metaBook.setPersist = setPersist, 
            metaBook.clearOffline = clearOffline, metaBook.refreshOffline = refreshOffline, 
            Query.prototype.dbs = [ metaBook.glossdb, metaBook.docdb ], Query.prototype.weights = {
                "+tags": 8,
                tags: 4,
                "+tags*": 2,
                "tags*": 2,
                "^+tags": 2,
                strings: 1,
                head: 2,
                heads: 1
            }, Query.prototype.uniqueids = !0, metaBook.query = metaBook.empty_query = new Query([]), 
            Trace.start > 1 && fdjtLog("Initialized DB");
        }
    }
    function Query(tags, base_query) {
        if (this instanceof Query) {
            if (0 === arguments.length) return this;
            var query = Knodule.TagQuery.call(this, tags);
            return Trace.search && (query.log = {}), query;
        }
        return new Query(tags, base_query);
    }
    function reduce_tags(query) {
        for (var cotags = query.getCoTags(), tagfreqs = query.tagfreqs, n = query.results.length, termindex = metaBook.textindex.termindex, global_n = metaBook.textindex.allids.length, i = 0, lim = cotags.length, results = []; lim > i; ) {
            var t = cotags[i++];
            if ("string" != typeof t) results.push(t); else {
                var f = tagfreqs.getItem(t);
                if (f > .9 * n || 3 > f || .1 > f / n) continue;
                var gl = termindex[t], gf = gl ? gl.length : 0;
                if (0 === gf && results.push(t), gf / global_n > .4) continue;
                f / n > 5 * (gf / global_n) && results.push(t);
            }
        }
        return results;
    }
    function getMakerKnodule(arg) {
        var result;
        if (arg || (arg = metaBook.user), !arg) return metaBook.knodule;
        if ("string" == typeof arg) return getMakerKnodule(metaBook.sourcedb.probe(arg));
        if (arg.maker && arg.maker instanceof Ref) result = new Knodule(arg.maker.getQID()); else {
            if (arg.maker && "string" == typeof arg.maker) return getMakerKnodule(metaBook.sourcedb.probe(arg.maker));
            result = arg._qid ? new Knodule(arg._qid) : arg._id ? new Knodule(arg._i) : metaBook.knodule;
        }
        return result.description = arg.name, result;
    }
    function metabook_trace(handler, cxt) {
        var target = cxt.nodeType ? cxt : fdjtUI.T(cxt);
        target ? fdjtLog(trace1, handler, cxt, target, metaBook.skimpoint ? "(skimming)" : "", metaBook.mode, metaBook.target, metaBook.head, metaBook.skimpoint) : fdjtLog(trace2, handler, cxt, metaBook.skimpoint ? "(skimming)" : "", metaBook.mode, metaBook.target, metaBook.head, metaBook.skimpoint);
    }
    function getRefURI(target) {
        for (var scan = target; scan && scan !== document; ) {
            if (scan.getAttribute("data-refuri")) return scan.getAttribute("data-refuri");
            if (scan.getAttribute("refuri")) return scan.getAttribute("refuri");
            scan = scan.parentNode;
        }
        return metaBook.refuri;
    }
    function getDocURI(target) {
        for (var scan = target; scan && scan !== document; ) {
            if (scan.getAttribute("data-docuri")) return scan.getAttribute("data-docuri");
            if (scan.getAttribute("docuri")) return scan.getAttribute("docuri");
            scan = scan.parentNode;
        }
        return metaBook.docuri;
    }
    function getTarget(scan, closest) {
        scan = scan.nodeType ? scan : scan.target || scan.srcElement || scan;
        var target = !1, id = !1, info = !1, targetids = metaBook.targetids, wsn_target = !1;
        if (hasParent(scan, metaBook.HUD)) return !1;
        for (;scan; ) {
            if (scan.metabookui) return !1;
            if (scan === metaBook.docroot || scan === document.body) return target;
            if ((id = scan.codexbaseid || scan.id) && (info = metaBook.docinfo[id])) if (id = info.frag || id, 
            scan.codexbaseid || 0 !== id.search("METABOOKTMP")) if (target && 0 === id.search("WSN_")) ; else if (0 === id.search("WSN_")) wsn_target = scan; else if (targetids && 0 !== id.search(targetids)) ; else if (hasClass(scan, "sbooknofocus")) ; else if (metaBook.nofocus && metaBook.nofocus.match(scan)) ; else {
                if (hasClass(scan, "sbookfocus")) return scan;
                if (metaBook.focus && metaBook.focus.match(scan)) return scan;
                if (closest) return scan;
                if (target && ("SECTION" === scan.tagName || scan.className && scan.className.search && scan.className.search(/\bhtml5section\b/i) >= 0)) return target;
                if (target && !fdjt.DOM.isVisible(scan)) return target;
                target || (target = scan);
            } else ;
            scan = scan.parentNode;
        }
        return target || wsn_target;
    }
    function getHead(target) {
        var targetid = target.codexbaseid || target.id;
        if (targetid && metaBook.docinfo[targetid]) target = metaBook.docinfo[targetid]; else if (targetid) for (;target; ) {
            if (target.id && metaBook.docinfo[targetid]) {
                target = metaBook.docinfo[targetid];
                break;
            }
            target = target.parentNode;
        } else {
            for (var scan = target.firstChild, scanid = !1, next = target.nextNode; scan && scan !== next && !scan.id && !scan.codexbaseid && (3 !== scan.nodeType || fdjtString.isEmpty(scan.nodeValue)); ) scan = fdjtDOM.forward(scan);
            if (scan && scan.id && scan !== next) target = metaBook.docinfo[scanid]; else for (;target; ) {
                if ((targetid = target.codexbaseid || target.id) && metaBook.docinfo[targetid]) {
                    target = metaBook.docinfo[targetid];
                    break;
                }
                target = target.parentNode;
            }
        }
        return target ? target.level ? mbID(target.frag) : target.head ? mbID(target.head.frag) : !1 : !1;
    }
    function iosAuthKludge() {
        if (metaBook.user && !fdjt.device.standalone && fdjt.device.mobilesafari) {
            var auth = mB.mycopyid;
            if (auth && mB.iOSKludge !== auth) {
                mB.iOSKludge = auth;
                var eauth = encodeURIComponent(auth), url = location.href, qmark = url.indexOf("?"), hashmark = url.indexOf("#"), base = 0 > qmark ? 0 > hashmark ? url : url.slice(0, hashmark) : url.slice(0, qmark), query = 0 > qmark ? "" : 0 > hashmark ? url.slice(qmark) : url.slice(qmark + 1, hashmark), hash = 0 > hashmark ? "" : url.slice(hashmark), old_query = !1, new_query = "MYCOPYID=" + eauth;
                if (2 >= query.length) query = "?" + new_query; else if (query.search("MYCOPYID=") >= 0) {
                    var auth_start = query.search("MYCOPYID="), before = query.slice(0, auth_start), auth_len = query.slice(auth_start).search("&"), after = 0 > auth_len ? "" : query.slice(auth_start + auth_len);
                    old_query = 0 > auth_len ? query.slice(auth_start) : query.slice(auth_start, auth_start + auth_len), 
                    query = before + new_query + after;
                } else query = query + "&" + new_query;
                old_query && old_query === new_query || history.replaceState(history.state, window.title, base + qstring(query) + hashstring(hash));
            }
        }
    }
    function qstring(s) {
        return "?" === s[0] ? s : "?" + s;
    }
    function hashstring(s) {
        return "#" === s[0] ? s : "#" + s;
    }
    function updateKludgeTimer() {
        document[fdjtDOM.isHidden] ? ios_kludge_timer && (clearInterval(ios_kludge_timer), 
        ios_kludge_timer = !1) : ios_kludge_timer || (ios_kludge_timer = setInterval(function() {
            metaBook.user && !fdjt.device.standalone && !document[fdjtDOM.isHidden] && fdjt.device.mobilesafari && iosAuthKludge();
        }, 3e5));
    }
    function setupKludgeTimer() {
        updateKludgeTimer(), fdjtDOM.isHidden && fdjtDOM.addListener(document, fdjtDOM.vischange, updateKludgeTimer), 
        metaBook.iosAuthKludge = iosAuthKludge, updateKludgeTimer();
    }
    function notEmpty(arg) {
        return "string" == typeof arg ? isEmpty(arg) ? !1 : arg : !1;
    }
    function mbID(id) {
        var info, elts;
        id && "string" == typeof id && "#" === id[0] && (id = id.slice(1)), metabook_docinfo || (metabook_docinfo = metaBook.docinfo);
        var elt = metabook_docinfo && (info = metabook_docinfo[id]) && info.elt;
        return elt && elt.id ? elt : (elt = document.getElementById(id)) ? elt : (elts = document.getElementsByName(id), 
        1 === elts.length ? elts[0] : elts.length > 1 ? !1 : (elts = fdjtDOM.$("[data-tocid='" + id + "']"), 
        1 === elts.length ? elts[0] : elts.length ? (elts = fdjtDOM.$(".codexdupstart[data-tocid='" + id + "']"), 
        1 === elts.length ? elts[0] : !1) : !1));
    }
    function getinfo(arg) {
        return arg ? "string" == typeof arg ? metaBook.docinfo[arg] || metaBook.glossdb.probe(arg) || RefDB.resolve(arg) : arg._id ? arg : arg.codexbaseid ? metaBook.docinfo[arg.codexbaseid] : arg.id ? metaBook.docinfo[arg.id] : !1 : !1;
    }
    function getGlossTags(gloss) {
        for (var results = [], i = 0, lim = tag_prefixes.length; lim > i; ) {
            var prefix = tag_prefixes[i++], tags = gloss[prefix + "tags"];
            if (tags) {
                tags instanceof Array || (tags = [ tags ]);
                for (var j = 0, ntags = tags.length; ntags > j; ) {
                    var tag = tags[j++];
                    "" === prefix ? results.push(tag) : results.push({
                        prefix: prefix,
                        tag: tag
                    });
                }
            }
        }
        return results;
    }
    function parseTag(tag, kno) {
        var slot = "tags", usekno = kno || metaBook.knodule;
        "~" === tag[0] ? (slot = "~tags", tag = tag.slice(1)) : "*" === tag[0] && "*" === tag[1] ? (slot = "**tags", 
        tag = tag.slice(2)) : "*" === tag[0] && (slot = "*tags", tag = tag.slice(1));
        var knode = tag.indexOf("|") >= 0 ? usekno.handleSubjectEntry(tag) : "~tags" === slot ? kno && kno.probe(tag) || tag : usekno.handleSubjectEntry(tag);
        return "tags" !== slot ? {
            slot: slot,
            tag: knode
        } : knode;
    }
    function addTags(nodes, tags, slotid, tagdb) {
        slotid || (slotid = "tags"), tagdb || (tagdb = metaBook.knodule);
        var docdb = metaBook.docdb;
        nodes instanceof Array || (nodes = [ nodes ]), knoduleAddTags(nodes, tags, docdb, tagdb, slotid, metaBook.tagscores);
        for (var i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++];
            if (node.toclevel) {
                var passages = docdb.find("head", node);
                passages.length && (passages = [].concat(passages)), passages && passages.length && knoduleAddTags(passages, tags, docdb, tagdb, "^" + slotid, metaBook.tagscores);
                var subheads = docdb.find("heads", node);
                subheads.length && (subheads = [].concat(subheads)), subheads && subheads.length && addTags(subheads, tags, "^" + slotid, tagdb);
            }
        }
    }
    function setConnected(val) {
        var root = document.documentElement || document.body;
        if (val && !metaBook.connected) {
            var onconnect = metaBook._onconnect;
            if (metaBook._onconnect = !1, onconnect && onconnect.length) for (var i = 0, lim = onconnect.length; lim > i; ) onconnect[i++]();
            fdjtState.getLocal("mB(" + mB.docid + ").queued") && metaBook.writeQueuedGlosses();
        }
        (val && !metaBook.connected || !val && metaBook.connected) && fdjtDOM.swapClass(root, /\b(_|cx)(CONN|DISCONN)\b/, val ? "_CONN" : "_DISCONN"), 
        metaBook.connected = val;
    }
    function getLevel(elt, rel) {
        if (elt.toclevel) return "none" === elt.toclevel ? (elt.toclevel = !1, !1) : elt.toclevel;
        var attrval = elt.getAttribute("toclevel") || elt.getAttribute("data-toclevel");
        if (attrval) return "none" === attrval ? !1 : parseInt(attrval, 10);
        if (elt.className) {
            var cname = elt.className;
            if (cname.search(/\b(sbook|metabook|sb|mb)notoc\b/) >= 0) return 0;
            if (cname.search(/\b(sbook|metabook|sb|mb)ignore\b/) >= 0) return 0;
            var tocloc = cname.search(/\b(sbook|metabook|sb|mb)\d+(head|sect)\b/);
            if (tocloc >= 0) return parseInt(cname.slice(tocloc + 5), 10);
            if ("number" == typeof rel && cname.search(/\b(sbook|metabook|sb|mb)subhead\b/) >= 0) return rel + 1;
        }
        return mB.notoc && mB.notoc.match(elt) ? 0 : mB.ignore && mB.ignore.match(elt) ? 0 : void 0 === metaBook.autotoc || metaBook.autotoc ? 0 === elt.tagName.search(/H\d/) ? parseInt(elt.tagName.slice(1, 2), 10) : !1 : !1;
    }
    function getCoverPage() {
        if (metaBook.coverpage) return metaBook.coverpage;
        var coverpage = $ID("METABOOKCOVERPAGE") || $ID("SBOOKCOVERPAGE") || $ID("COVERPAGE");
        return coverpage && (metaBook.coverpage = coverpage), coverpage;
    }
    function fixStaticRefs(string) {
        return fillIn(expand(string).replace(/http(s)?:\/\/static.beingmeta.com\//g, metaBook.root), {
            bmg: metaBook.root + "g/",
            coverimage: metaBook.coverimage
        });
    }
    function urlType(url) {
        return url.search(/\.(jpg|jpeg)$/g) > 0 ? "image/jpeg" : url.search(/\.png$/g) > 0 ? "image/png" : url.search(/\.gif$/g) > 0 ? "image/gif" : url.search(/\.wav$/g) > 0 ? "audio/wav" : url.search(/\.ogg$/g) > 0 ? "audio/ogg" : url.search(/\.mp3$/g) > 0 ? "audio/mpeg" : url.search(/\.mp4$/g) > 0 ? "video/mp4" : !1;
    }
    function typeIcon(type, w) {
        return w || (w = 64), type ? "audio/mpeg" === type ? mbicon("music", w, w) : "image/" === type.slice(0, 6) ? mbicon("photo", w, w) : "audio/" === type.slice(0, 6) ? mbicon("sound", w, w) : mbicon("diaglink", w, w) : mbicon("diaglink", w, w);
    }
    function mediaTypeClass(type) {
        return type ? "audio/mpeg" === type ? "musiclink" : "image/" === type.slice(0, 6) ? "imagelink" : "audio/" === type.slice(0, 6) ? "audiolink" : !1 : !1;
    }
    var fdjtString = fdjt.String, fdjtState = fdjt.State, fdjtAsync = fdjt.Async, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, $ID = fdjt.ID, RefDB = fdjt.RefDB, Ref = fdjt.Ref, ObjectMap = fdjt.Map || RefDB.Map, hasClass = fdjtDOM.hasClass, hasParent = fdjtDOM.hasParent, getLocal = fdjtState.getLocal, setLocal = fdjtState.setLocal, existsLocal = fdjtState.existsLocal, mB = metaBook, Trace = metaBook.Trace, iDB = fdjt.iDB, indexedDB = iDB.indexedDB;
    metaBook.tagweights = new ObjectMap(), metaBook.tagscores = new ObjectMap(), metaBook.hasLocal = hasLocal, 
    metaBook.saveLocal = saveLocal, metaBook.readLocal = readLocal, metaBook.clearLocal = clearLocal, 
    metaBook.focusBody = function() {};
    var metaBookDB = !1, dbwait = [], dbfail = [];
    if (metaBook.getDB = getDB, indexedDB && !mB.noidb) {
        var req = indexedDB.open("metaBook", 1);
        req.onerror = function(event) {
            notDB("opening", "metaBook", event.errorCode);
        }, req.onsuccess = function(event) {
            var db = event.target.result;
            fdjtLog("Using existing metaBook IndexedDB"), gotDB(db);
        }, req.onupgradeneeded = function(event) {
            var db = event.target.result;
            db.onerror = function(event) {
                notDB("upgrading", "metaBook", event.target.errorCode), event = !1;
            }, db.onsuccess = function(event) {
                var db = event.target.result;
                fdjtLog("Initialized metaBook indexedDB"), gotDB(db);
            }, db.createObjectStore("glossdata", {
                keyPath: "url"
            }), db.createObjectStore("layouts", {
                keyPath: "layout_id"
            }), db.createObjectStore("sources", {
                keyPath: "_id"
            }), db.createObjectStore("docs", {
                keyPath: "_id"
            }), db.createObjectStore("glosses", {
                keyPath: "glossid"
            });
        };
    } else fdjt.CodexLayout.useIndexedDB(!1);
    var databases_created = !1;
    mB.createDatabases = createDatabases;
    var db_initialized = !1;
    metaBook.initDB = initDB, Query.prototype = new Knodule.TagQuery(), metaBook.Query = Query, 
    metaBook.Query.prototype.getRefiners = function() {
        if (this._refiners) return this._refiners;
        var r = reduce_tags(this);
        return this._refiners = r, r;
    }, metaBook.getMakerKnodule = getMakerKnodule;
    var trace1 = "%s %o in %o: mode%s=%o, target=%o, head=%o skimming=%o", trace2 = "%s %o: mode%s=%o, target=%o, head=%o skimming=%o";
    metaBook.trace = metabook_trace;
    var uroot_pat = /https?:\/\/[^\/]+\/([^\/]+\/)*/, mbama = window._metabook_amalgam;
    metaBook.server = !1, metaBook.servers = [], metaBook.default_server = "glosses.bookhub.io", 
    metaBook.root = mbama && uroot_pat.exec(mbama) && uroot_pat.exec(mbama)[0] || fdjtDOM.getLink("METABOOK.staticroot") || "http://static.beingmeta.com/", 
    "/" !== metaBook.root[metaBook.root.length - 1] && (metaBook.root = metaBook.root + "/"), 
    metaBook.withsvg = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1") || navigator.mimeTypes["image/svg+xml"], 
    metaBook.svg = fdjt.DOM.checkSVG(), fdjtState.getQuery("nosvg") ? metaBook.svg = !1 : fdjtState.getQuery("withsvg") && (metaBook.svg = !0), 
    metaBook.icon = function(base, width, height) {
        return metaBook.root + "g/metabook/" + base + (metaBook.svg ? ".svgz" : (width && height ? width + "x" + height : width ? width + "w" : height ? height + "h" : "") + ".png");
    };
    var mbicon = metaBook.icon;
    metaBook.getRefURI = getRefURI, metaBook.getDocURI = getDocURI, metaBook.getRefID = function(target) {
        return target.getAttributeNS ? target.getAttributeNS("bookid") || target.getAttributeNS("data-bookid") || target.codexbaseid || target.id : target.id;
    }, metaBook.getTarget = getTarget, metaBook.getHead = getHead, metaBook.getRef = function(target) {
        for (;!(!target || target.about || target.getAttribute && target.getAttribute("about")); ) target = target.parentNode;
        if (target) {
            var ref = target.about || target.getAttribute("about");
            return target.about || (target.about = ref), "#" === ref[0] ? mbID(ref.slice(1)) : mbID(ref);
        }
        return !1;
    }, metaBook.getRefElt = function(target) {
        for (;target && !(target.about || target.getAttribute && target.getAttribute("about")); ) target = target.parentNode;
        return target || !1;
    }, metaBook.checkTarget = function() {
        metaBook.target && "openglossmark" === metaBook.mode && (fdjtDOM.isVisible(metaBook.target) || (metaBook.setMode(!1), 
        metaBook.setMode(!0)));
    };
    var ios_kludge_timer = !1;
    !fdjt.device.standalone && fdjt.device.mobilesafari && fdjt.addInit(setupKludgeTimer, "setupKludgeTimer");
    var isEmpty = fdjtString.isEmpty, metabook_docinfo = !1;
    metaBook.ID = mbID, metaBook.getTitle = function(target, tryhard) {
        var targetid;
        return target.sbooktitle || ((targetid = target.codexbaseid || target.id) && metaBook.docinfo[targetid] ? notEmpty(metaBook.docinfo[targetid].title) : notEmpty(target.title)) || tryhard && fdjtDOM.textify(target).replace(/\n(\s*\n)+/g, "\n").replace(/^\n+/, "").replace(/\n+$/, "").replace(/\n\n+/g, " // ").replace(/\n/g, " ").replace(/^\s*\/\//, "");
    }, metaBook.Info = getinfo;
    var tag_prefixes = [ "", "*", "**", "~", "~~" ];
    metaBook.getGlossTags = getGlossTags, metaBook.parseTag = parseTag;
    var knoduleAddTags = Knodule.addTags;
    metaBook.addTags = addTags, metaBook.setConnected = setConnected, metaBook.getTOCLevel = getLevel, 
    metaBook.getCoverPage = getCoverPage;
    var fillIn = fdjtString.fillIn, expand = fdjtString.expandEntities;
    metaBook.fixStaticRefs = fixStaticRefs, fdjtString.entities.beingmeta = "<span class='beingmeta'>being<span class='bmm'>m<span class='bme'>e<span class='bmt'>t<span class='bma'>a</span></span></span></span></span>", 
    fdjtString.entities.sBooks = "<span class='sbooks'><em>s</em>Books</span>", fdjtString.entities.sBook = "<span class='sbooks'><em>s</em>Book</span>", 
    fdjtString.entities.metaBooks = "<span class='metabook'><span class='bmm'>m<span class='bme'>e<span class='bmt'>t<span class='bma'>a</span></span></span></span>Books</span>", 
    fdjtString.entities.metaBook = "<span class='metabook'><span class='bmm'>m<span class='bme'>e<span class='bmt'>t<span class='bma'>a</span></span></span></span>Book</span>", 
    metaBook.urlType = urlType, metaBook.typeIcon = typeIcon, metaBook.mediaTypeClass = mediaTypeClass;
}(), fdjt.DOM.noautofontadjust = !0, fdjt.CodexLayout.dbname = "metaBook", function() {
    "use strict";
    function addConfig(name, handler) {
        Trace.config > 1 && fdjtLog("Adding config handler for %s: %s", name, handler), 
        config_handlers[name] = handler, current_config.hasOwnProperty(name) && (Trace.config > 1 && fdjtLog("Applying config handler to current %s=%s", name, current_config[name]), 
        handler(name, current_config[name]));
    }
    function getConfig(name) {
        return name ? current_config[name] : current_config;
    }
    function setConfig(name, value, save, cxt) {
        if (cxt = cxt ? " (" + cxt + ")" : "", 1 !== arguments.length) Trace.config && fdjtLog("setConfig%s %o=%o", cxt, name, value), 
        current_config.hasOwnProperty(name) && current_config[name] === value ? Trace.config && fdjtLog("Redundant setConfig%s %o=%o", cxt, name, value) : (config_handlers[name] ? (Trace.config && fdjtLog("setConfig%s (handler=%s) %o=%o", cxt, config_handlers[name], name, value), 
        config_handlers[name](name, value)) : Trace.config && fdjtLog("setConfig%s (no handler) %o=%o", cxt, name, value), 
        current_config[name] = value), save && saved_config[name] !== value && (saved_config[name] = value, 
        saveConfig(saved_config)); else {
            var config = name;
            metaBook.postconfig = [], Trace.config && fdjtLog("batch setConfig %s: %s", cxt, config);
            for (var setting in config) config.hasOwnProperty(setting) && setConfig(setting, config[setting]);
            var dopost = metaBook.postconfig;
            metaBook.postconfig = !1, Trace.config > 1 && !dopost && 0 !== dopost.length && fdjtLog("batch setConfig, no post processing %s", config, cxt);
            for (var post_i = 0, post_lim = dopost.length; post_lim > post_i; ) Trace.config > 1 && fdjtLog("batch setConfig%s, post processing %s", dopost[post_i]), 
            dopost[post_i++]();
        }
    }
    function saveConfig(config) {
        Trace.config && (fdjtLog("saveConfig %o", config), fdjtLog("saved_config=%o", saved_config)), 
        config ? setConfig(config) : config = saved_config;
        var saved = {};
        for (var setting in config) default_config.hasOwnProperty(setting) && config[setting] !== default_config[setting] && !getQuery(setting) && (saved[setting] = config[setting]);
        Trace.config && fdjtLog("Saving config %o", saved), saveLocal("mB(" + mB.docid + ").config", JSON.stringify(saved)), 
        saved_config = saved;
    }
    function initConfig() {
        if (!config_initialized) {
            config_initialized = !0;
            var setting, value, source, started = fdjtTime(), config = getLocal("mB(" + mB.docid + ").config", !0) || fdjtState.getSession("mB(" + mB.docid + ").config", !0);
            if (metaBook.postconfig = [], config) {
                Trace.config && fdjtLog("initConfig local=%j", config);
                for (setting in config) config.hasOwnProperty(setting) && (getQuery(setting) ? (value = getQuery(setting), 
                source = "initConfig/QUERY") : (value = config[setting], source = "initConfig/local"), 
                setConfig(setting, value, !1, source), metaBook.updateSettings(setting, value));
            } else config = {};
            Trace.config && fdjtLog("initConfig default=%j", default_config);
            var devicename = current_config.devicename;
            devicename && !isEmpty(devicename) && (metaBook.deviceName = devicename), Trace.startup > 1 && fdjtLog("initConfig took %dms", fdjtTime() - started);
        }
    }
    function bookConfig() {
        var started = fdjtTime(), config = current_config;
        for (var setting in default_config) {
            var value, source;
            !default_config.hasOwnProperty(setting) || config.hasOwnProperty(setting) || getQuery(setting) || (getMeta("METABOOK." + setting) ? (value = getMeta("METABOOK." + setting), 
            source = "initConfig/HTML") : (value = default_config[setting], source = "initConfig/appdefaults"), 
            setConfig(setting, value, !1, "initConfig/HTML"), setConfig(setting, value, !1, source), 
            metaBook.updateSettings(setting, value));
        }
        var dopost = metaBook.postconfig;
        metaBook.postconfig = !1;
        for (var i = 0, lim = dopost.length; lim > i; ) dopost[i++]();
        Trace.config && fdjtLog("bookConfig took %dms", fdjtTime() - started);
    }
    function updateConfig(name, id, save) {
        save === void 0 && (save = !1);
        var elt = "string" == typeof id && document.getElementById(id) || id.nodeType && getParent(id, "input") || id.nodeType && getChild(id, "input") || id.nodeType && getChild(id, "textarea") || id.nodeType && getChild(id, "select") || id;
        Trace.config && fdjtLog("Update config %s", name), "radio" === elt.type || "checkbox" === elt.type ? setConfig(name, elt.checked || !1, save, "updateConfig/checked") : setConfig(name, elt.value, save, "updateConfig/input");
    }
    function metabookPropConfig(name, value) {
        metaBook[name] = value;
    }
    function configChange(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), setting = target.name, val = target.value, cur = current_config[setting];
        target.checked && cur === val || (target.checked ? setConfig(setting, val, !0, "configChange") : "checkbox" === target.type && setConfig(setting, "", !0, "configChange"));
    }
    function applyMetaClass(name, metaname) {
        metaname || (metaname = name);
        for (var meta = getMeta(metaname, !0), i = 0, lim = meta.length; lim > i; ) fdjtDOM.addClass(fdjtDOM.$(meta[i++]), name);
    }
    function updateSettings(setting, value) {
        for (var forms = fdjtDOM.$(".metabooksettings"), i = 0, n_forms = forms.length; n_forms > i; ) {
            for (var form = forms[i++], inputs = getChildren(form, "input[type='CHECKBOX'],input[type='RADIO']"), toset = [], toclear = [], j = 0, n_inputs = inputs.length, input = !1; n_inputs > j; ) input = inputs[j++], 
            input.name === setting && ((value === !0 ? /(yes|on|true)/i.exec(input.value) : input.value === value) ? toset.push(input) : toclear.push(input));
            for (j = 0, n_inputs = toset.length; n_inputs > j; ) input = toset[j++], input.checked || (getParent(input, ".checkspan") ? fdjt.UI.CheckSpan.set(input, !0) : input.checked = !0);
            for (j = 0, n_inputs = toclear.length; n_inputs > j; ) input = toclear[j++], (input.checked || void 0 === input.checked) && (getParent(input, ".checkspan") ? fdjt.UI.CheckSpan.set(input, !1) : input.checked = !1);
            for (j = 0, n_inputs = toset.length; n_inputs > j; ) input = toset[j++], input.checked || (getParent(input, ".checkspan") ? fdjt.UI.CheckSpan.set(input, !0) : input.checked = !0);
        }
    }
    function initSettings() {
        var started = fdjtTime();
        for (var setting in current_config) current_config.hasOwnProperty(setting) && updateSettings(setting, current_config[setting]);
        Trace.startup > 1 && fdjtLog("Finished initSettings in %dms", fdjtTime() - started);
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, fdjtState = fdjt.State, fdjtTime = fdjt.Time, fdjtString = fdjt.String, getChildren = fdjtDOM.getChildren, getMeta = fdjtDOM.getMeta, isEmpty = fdjtString.isEmpty, getLocal = fdjtState.getLocal, getQuery = fdjtState.getQuery, mB = metaBook, Trace = metaBook.Trace, saveLocal = mB.saveLocal, config_handlers = {}, default_config = metaBook.default_config, current_config = {}, saved_config = {};
    metaBook.addConfig = addConfig, metaBook.getConfig = getConfig, metaBook.setConfig = setConfig, 
    metaBook.resetConfig = function() {
        setConfig(saved_config);
    }, metaBook.saveConfig = saveConfig;
    var config_initialized = !1;
    metaBook.initConfig = initConfig, metaBook.bookConfig = bookConfig;
    var getParent = fdjtDOM.getParent, getChild = fdjtDOM.getChild;
    metaBook.updateConfig = updateConfig, metaBook.propConfig = metabookPropConfig, 
    metaBook.addConfig("keyboardhelp", function(name, value) {
        metaBook.keyboardhelp = value, fdjtUI.CheckSpan.set(document.getElementsByName("METABOOKKEYBOARDHELP"), value);
    }), metaBook.addConfig("devicename", function(name, value) {
        metaBook.deviceName = isEmpty(value) ? !1 : value;
    }), metaBook.addConfig("holdmsecs", function(name, value) {
        metaBook.holdmsecs = value, fdjtUI.TapHold.default_opts.holdmsecs = value;
    }), metaBook.addConfig("wandermsecs", function(name, value) {
        metaBook.wandermsecs = value, fdjtUI.TapHold.default_opts.wanderthresh = value;
    }), metaBook.addConfig("taptapmsecs", function(name, value) {
        metaBook.taptapmsecs = value, fdjtUI.TapHold.default_opts.taptapmsecs = value;
    }), metaBook.addConfig("dont_rAF", function(name, value) {
        fdjt.CodexLayout.dont_rAF = value;
    }), metaBook.addConfig("checksync", function(name, value) {
        metaBook.sync_interval = value, metaBook.synctock && (clearInterval(metaBook.synctock), 
        metaBook.synctock = !1), value && metaBook.locsync && (metaBook.synctock = setInterval(metaBook.syncState, 1e3 * value));
    }), metaBook.addConfig("synctimeout", function(name, value) {
        metaBook.sync_timeout = value;
    }), metaBook.addConfig("syncpause", function(name, value) {
        metaBook.sunc_pause = value;
    }), metaBook.addConfig("locsync", function(name, value) {
        !value && metaBook.synctock ? (clearInterval(metaBook.synctock), metaBook.synctock = !1) : value && !metaBook.synctock && metaBook.sync_interval && (metaBook.synctock = setInterval(metaBook.syncState, 1e3 * metaBook.sync_interval)), 
        metaBook.locsync = value, fdjt.Async(function() {
            metaBook.updateSettings(name, value);
        });
    }), metaBook.configChange = configChange, metaBook.applyMetaClass = applyMetaClass, 
    metaBook.updateSettings = updateSettings, metaBook.initSettings = initSettings;
}(), function() {
    "use strict";
    function init_local() {
        getDups = metaBook.getDups, saveState = metaBook.saveState, setHistory = metaBook.setHistory;
    }
    function setHead(arg) {
        var head;
        if (arg) {
            head = "string" == typeof arg ? getHead(mbID(head)) || metaBook.content : arg;
            for (var headid = head.codexbaseid || head.id, headinfo = mB.docinfo && mB.docinfo[headid]; headinfo && !headinfo.level; ) headinfo = headinfo.head, 
            headid = headinfo.frag, head = mbID(headid);
            return Trace.nav > 1 && headinfo ? fdjtLog("metaBook.setHead #%s %o from %o info=%o:\n%j", headid || "none", head, arg, headinfo, headinfo) : Trace.nav && fdjtLog("metaBook.setHead #%s %o from %o", headid || "none", head, arg), 
            head === metaBook.head ? (Trace.target && fdjtLog("Redundant SetHead"), void 0) : (headinfo ? (Trace.target && metaBook.trace("metaBook.setHead", head), 
            window.title = headinfo.title + " (" + document.title + ")", metaBook.head && dropClass(metaBook.head, "bookhead"), 
            addClass(head, "bookhead"), metaBook.setLocation(metaBook.location), metaBook.head = mbID(headid), 
            metaBook.TOC.setHead(headinfo)) : (Trace.target && metaBook.trace("metaBook.setFalseHead", head), 
            metaBook.TOC.setHead(!1), metaBook.head = !1), void 0);
        }
    }
    function setLocation(location, force) {
        if (force || metaBook.location !== location) {
            Trace.toc && fdjtLog("Setting location to %o", location);
            for (var info = metaBook.Info(metaBook.head); info; ) {
                var tocelt = document.getElementById("MBTOC4" + info.frag), hinfo = info.head, hhlen = hinfo && hinfo.ends_at - hinfo.starts_at, start = info.starts_at, end = info.ends_at, progress = 100 * (location - start) / hhlen, bar = !1, appbar = !1;
                tocelt && (bar = fdjtDOM.getFirstChild(tocelt, ".mbtoc_posbar")), Trace.toc && fdjtLog("For tocbar %o/%o loc=%o start=%o end=%o progress=%o", bar, appbar, location, start, end, progress), 
                progress >= 0 && 100 >= progress && (bar && (bar.style.width = progress + "%"), 
                appbar && (appbar.style.width = progress + "%")), info = info.head;
            }
            metaBook.location = location;
        }
    }
    function location2pct(location, loclen) {
        loclen || (loclen = metaBook.ends_at);
        var pct = 100 * location / loclen;
        pct > 100 && (pct = 100);
        var prec = Math.round(Math.log(loclen / 40) / Math.log(10)) - 2;
        return 0 > prec && (prec = 0), Math.floor(pct) === pct ? Math.floor(pct) + "%" : fdjtString.precString(pct, prec) + "%";
    }
    function setTarget(target) {
        if (Trace.target && metaBook.trace("metaBook.setTarget", target), target !== metaBook.target && (!metaBook.target || metaBook.target.id !== target.codexbaseid)) {
            if (metaBook.target) {
                var old_target = metaBook.target, oldid = old_target.id, old_targets = getDups(oldid);
                dropClass(old_target, "mbtarget"), dropClass(old_target, "mbnewtarget"), dropClass(old_targets, "mbtarget"), 
                dropClass(old_targets, "mbnewtarget"), hasParent(old_target, target) || clearHighlights(old_targets), 
                metaBook.target = !1;
            }
            if (!target) return metaBook.UI.setTarget && metaBook.UI.setTarget(!1), void 0;
            if (!inUI(target) && (target.id || target.codexbaseid)) {
                var targetid = target.codexbaseid || target.id, primary = targetid && mbID(targetid) || target, targets = getDups(targetid);
                addClass(target, "mbtarget"), addClass(target, "mbnewtarget"), addClass(targets, "mbtarget"), 
                addClass(targets, "mbnewtarget"), setTimeout(function() {
                    dropClass(target, "mbnewtarget"), dropClass(targets, "mbnewtarget");
                }, 3e3), fdjtState.setCookie("MB:TARGET", targetid || target.getAttribute("data-bookid"), !1, !1, 0 === location.href.search("https:")), 
                metaBook.target = primary, metaBook.UI.setTarget && metaBook.UI.setTarget(primary), 
                mB.docinfo && metaBook.empty_cloud && metaBook.setCloudCuesFromTarget(metaBook.empty_cloud, primary);
            }
        }
    }
    function clearHighlights(target) {
        if ("string" == typeof target && (target = mbID(target)), target) if (target.length) {
            dropClass(target, "mbhighlightpassage");
            for (var i = 0, lim = target.length; lim > i; ) {
                var node = target[i++];
                fdjtUI.Highlight.clear(node, "mbhighlightexcerpt"), fdjtUI.Highlight.clear(node, "mbhighlightsearch");
            }
        } else dropClass(target, "mbhighlightpassage"), fdjtUI.Highlight.clear(target, "mbhighlightexcerpt"), 
        fdjtUI.Highlight.clear(target, "mbhighlightsearch");
    }
    function findExcerpt(node, excerpt, off) {
        if ("string" == typeof node && (node = mbID(node)), !node) return !1;
        node.nodeType && (node = getDups(node));
        var trimmed = fdjtString.trim(excerpt), before = 0 === trimmed.search(/[.,"']/) ? "(^|\\s)" : "\\b", after = trimmed.search(/[.,"']$/) > 0 ? "($|\\s)" : "\\b", pattern = fdjtDOM.textRegExp(trimmed, !1, !0, before, after), matches = fdjtDOM.findMatches(node, pattern, off || 0, 1);
        if (matches && 0 !== matches.length || (pattern = fdjtDOM.textRegExp(trimmed, !0, !0, before, after), 
        matches = fdjtDOM.findMatches(node, pattern, off || 0, 1)), matches && matches.length) return matches[0];
        var result = !1, roff = -1;
        for (matches = fdjtDOM.findMatches(node, pattern, 0, 1); matches.length > 0; ) {
            var first = matches[0];
            if (first.start_offset > off) return 0 > roff ? result : result.start_offset - off > off - roff ? result : first;
            result = first, roff = first.start_offset, matches = fdjtDOM.findMatches(node, pattern, first.endOffset + 1, 1);
        }
        return matches && matches.length ? matches[0] : result;
    }
    function inUI(elt) {
        if (elt.metabookui) return !0;
        if (hasParent(elt, metaBook.HUD)) return !0;
        for (;elt; ) {
            if (elt.metabookui) return !0;
            if (hasClass(elt, sbookUIclasses)) return !0;
            elt = elt.parentNode;
        }
        return !1;
    }
    function setHashID(target) {
        var targetid = target.codexbaseid || target.id;
        !targetid || window.location.hash === targetid || "#" === window.location.hash[0] && window.location.hash.slice(1) === targetid || target !== metaBook.body && target !== document.body && targetid && (window.location.hash = targetid);
    }
    function getLocInfo(elt) {
        for (var eltid = !1, counter = 0, lim = 200, forward = fdjtDOM.forward; elt && lim > counter && (eltid = elt.codexbaseid || elt.id, 
        !eltid || !metaBook.docinfo[eltid]); ) counter++, elt = forward(elt);
        if (eltid && metaBook.docinfo[eltid]) {
            var info = metaBook.docinfo[eltid];
            return {
                start: info.starts_at,
                end: info.ends_at,
                len: info.ends_at - info.starts_at
            };
        }
        return !1;
    }
    function resolveLocation(loc) {
        for (var allinfo = metaBook.docinfo._allinfo, i = 0, lim = allinfo.length; lim > i && loc > allinfo[i].starts_at; ) i++;
        for (;lim > i && !(allinfo[i].starts_at > loc); ) i++;
        return mbID(allinfo[i - 1].frag);
    }
    function metabookGoTo(arg, caller, istarget, savestate, skiphist) {
        istarget === void 0 && (istarget = !0), savestate === void 0 && (savestate = !0);
        var target, location, locinfo;
        if (savestate && metaBook.clearStateDialog(), !arg && 0 !== arg) return fdjtLog.warn("falsy arg (%s) to metabookGoTo from %s", arg, caller), 
        void 0;
        if ("string" == typeof arg) target = mbID(arg), locinfo = getLocInfo(target), location = locinfo.start; else if ("number" == typeof arg) location = arg, 
        target = istarget && (istarget.nodeType && istarget.id ? istarget : resolveLocation(arg)); else if (arg.target && (arg.location || arg.offset)) target = getTarget(arg.target), 
        arg.location ? location = arg.location : (locinfo = getLocInfo(arg.target), location = locinfo.start + arg.offset); else {
            if (!arg.nodeType) return fdjtLog.warn("Bad metabookGoTo %o", arg), void 0;
            target = getTarget(arg), locinfo = getLocInfo(arg), location = locinfo.start;
        }
        istarget && istarget.nodeType ? target = istarget : "string" == typeof istarget && mbID(istarget) && (target = mbID(istarget));
        var info = target && mB.docinfo && mB.docinfo[target.getAttribute("data-baseid") || target.id];
        location && info && info.ends_at && info.starts_at && (location > info.ends_at || info.starts_at > location) && (location = !1);
        var page = metaBook.bypage && metaBook.layout && metaBook.getPage(target, location), pageno = page && parseInt(page.getAttribute("data-pagenum"), 10), targetid = target && (target.codexbaseid || target.id);
        if (mB.Trace.nav && fdjtLog("mB.GoTo(%s%s%s%s%s) %o location=%o page=%o pageno=%d arg=%o", caller || "", caller ? ":" : "", istarget ? "t" : "", savestate ? "s" : "", skiphist ? "" : "h", target, location ? location : "none", page, pageno, arg), 
        !target) {
            if (mB.bypage) page && metaBook.layout instanceof fdjt.CodexLayout && metaBook.GoToPage(page || arg, caller, savestate); else if (arg.nodeType) {
                for (var scan = arg; scan && !scan.offsetTop; ) scan = scan.parentNode;
                scan && (metaBook.content.style.offsetTop = -scan.offsetTop);
            }
            return metaBook.curpage ? saveState({
                location: metaBook.location,
                page: metaBook.curpage,
                npages: metaBook.pagecount
            }, !0) : saveState({
                location: metaBook.location
            }, !0), void 0;
        }
        if (Trace.nav && fdjtLog("metaBook.GoTo%s() #%o@P%o/L%o %o", caller ? "/" + caller : "", targetid, pageno, info && info.starts_at, target), 
        info && (metaBook.point = target, metaBook.hudup || metaBook.mode || (metaBook.skimpoint = !1)), 
        target && mB.docinfo && setHead(target), location && setLocation(location), istarget && targetid && !inUI(target) && setTarget(target), 
        savestate && istarget && target ? metaBook.saveState({
            target: target.getAttribute("data-baseid") || target.id,
            location: location,
            page: pageno,
            npages: metaBook.pagecount
        }, skiphist) : savestate && metaBook.saveState({
            location: location,
            page: pageno,
            npages: metaBook.pagecount
        }, skiphist), skiphist || (istarget ? setHistory({
            target: target.getAttribute("data-baseid") || target.id,
            location: location,
            page: pageno,
            npages: metaBook.pagecount
        }) : target && setHistory({
            target: target.getAttribute("data-baseid") || target.id,
            location: location,
            page: pageno,
            npages: metaBook.pagecount
        })), page) metaBook.GoToPage(page, caller || "metabookGoTo", !1, !0); else {
            metaBook.previewing && metaBook.stopPreview(caller ? "goto/" + caller : "goto", target);
            var offinfo = fdjtDOM.getGeometry(target, metaBook.content), use_top = offinfo.top - (fdjtDOM.viewHeight() - 50) / 2;
            0 > use_top && (use_top = 0), window.scrollTo(0, use_top);
        }
        metaBook.clearGlossmark && metaBook.clearGlossmark(), metaBook.location = location;
    }
    function anchorFn(evt) {
        for (var target = fdjtUI.T(evt); target && !target.href; ) target = target.parentNode;
        if (target && target.href && "#" === target.href[0]) {
            var elt = mbID(target.href.slice(1));
            elt && (metaBook.GoTo(elt, "anchorFn"), fdjtUI.cancel(evt));
        }
    }
    function metaBookJumpTo(target) {
        metaBook.hudup && metaBook.setMode(!1), metaBook.GoTo(target, "JumpTo");
    }
    function metaBookGoTOC(target) {
        target && metaBook.GoTo(target, "GoTOC");
    }
    var getDups, saveState, setHistory, fdjtDOM = fdjt.DOM, fdjtString = fdjt.String, fdjtState = fdjt.State, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, hasClass = fdjtDOM.hasClass, hasParent = fdjtDOM.hasParent, mB = metaBook, mbID = mB.ID, getHead = mB.getHead, getTarget = mB.getTarget, Trace = metaBook.Trace;
    metaBook.inits.local.push(init_local), metaBook.setHead = setHead, metaBook.setLocation = setLocation, 
    metaBook.location2pct = location2pct, metaBook.setTarget = setTarget, metaBook.clearHighlights = clearHighlights, 
    metaBook.findExcerpt = findExcerpt;
    var sbookUIclasses = /(\bhud\b)|(\bglossmark\b)|(\bleading\b)/;
    metaBook.inUI = inUI, metaBook.setHashID = setHashID, metaBook.getLocInfo = getLocInfo, 
    metaBook.resolveLocation = resolveLocation, metaBook.GoTo = metabookGoTo, metaBook.anchorFn = anchorFn, 
    metaBook.JumpTo = metaBookJumpTo, metaBook.GoTOC = metaBookGoTOC;
}(), metaBook.DOMScan = function() {
    "use strict";
    function MetaBookDOMScan(root, dbid, docinfo) {
        function ScanInfo(id, scanstate) {
            if (docinfo[id]) return docinfo[id];
            Ref.call(this, id, docdb);
            var now = fdjtTime();
            return this._live = this._changed = now, docdb.changes.push(this), docdb.changed = now, 
            this.frag = id, docinfo[id] = this, scanstate.allinfo.push(this), scanstate.locinfo.push(scanstate.location), 
            this;
        }
        function getTitle(head) {
            var title = head.toctitle || head.getAttribute("toctitle") || head.getAttribute("data-toctitle") || head.title;
            if (!title) {
                var head1 = fdjtDOM.getFirstChild(head, "H1,H2,H3,H4,H5,H6");
                head1 && (title = head1.toctitle || head1.getAttribute("toctitle") || head1.getAttribute("data-toctitle") || head1.title), 
                title = !title && head1 ? gatherText(head1) : gatherText(head);
            }
            if ("string" == typeof title) {
                var std = stdspace(title);
                return "" === std ? !1 : std;
            }
            return title = fdjtDOM.textify(title, !0);
        }
        function gatherText(head, s) {
            var root = s === void 0;
            if (s || (s = ""), 3 === head.nodeType) return s + head.nodeValue;
            if (1 !== head.nodeType) return s;
            var style = getStyle(head), position = style.position;
            if (root || "" === position || "static" === position) {
                for (var children = head.childNodes, i = 0, len = children.length; len > i; ) {
                    var child = children[i++];
                    3 === child.nodeType ? s += child.nodeValue : 1 === child.nodeType && (s = gatherText(child, s));
                }
                return s;
            }
            return s;
        }
        function textWidth(elt) {
            if (3 === elt.nodeType) return elt.nodeValue.length;
            if (1 !== elt.nodeType) return 0;
            if (elt.getAttribute("data-loclen")) return parseInt(elt.getAttribute("data-loclen"), 10);
            for (var children = elt.childNodes, width = 0, i = 0, len = children.length; len > i; ) {
                var child = children[i++];
                3 === child.nodeType ? width += child.nodeValue.length : 1 === child.nodeType && (width += textWidth(child));
            }
            return width;
        }
        function handleHead(head, headid, docinfo, scanstate, level, curhead, curinfo, curlevel) {
            var headinfo = docinfo[headid] || (docinfo[headid] = new ScanInfo(headid, scanstate));
            if (scanstate.headcount++, allheads.push(headid), Trace.domscan > 1 && fdjtLog("Scanning head item %o under %o at level %d w/id=#%s ", head, curhead, level, headid), 
            headinfo.starts_at = scanstate.location, headinfo.level = level, headinfo.elt = head, 
            headinfo.sub = [], headinfo.frag = headid, headinfo.title = getTitle(head), headinfo.next = !1, 
            headinfo.prev = !1, headinfo.sectag = headinfo.title ? "§" + stdspace(headinfo.title) : "§Anonymous Section", 
            level > curlevel) headinfo.head = curinfo, headinfo.indexRef("head", curinfo), curinfo.intro_ends_at || (curinfo.intro_ends_at = scanstate.location), 
            curinfo.sub.push(headinfo), scanstate.lastlevel === level && (headinfo.prev = scanstate.lastinfo, 
            scanstate.lastinfo.next = headinfo, delete scanstate.lastlevel, delete scanstate.lasthead, 
            delete scanstate.lastinfo); else {
                for (var scan = curhead, scaninfo = curinfo, scanlevel = curinfo.level; scaninfo && (Trace.domscan > 2 && fdjtLog("Finding head@%d: s=%o, i=%j, sh=%o, cmp=%o", scanlevel, scan || !1, scaninfo, level > scanlevel), 
                scanlevel && !(level > scanlevel)) && scaninfo !== rootinfo; ) {
                    if (scaninfo.head && scaninfo.head.level && scaninfo.head.level >= scanlevel) {
                        fdjtLog.warn("Corrupted TOCINFO at %o", head);
                        break;
                    }
                    level === scanlevel && (headinfo.prev = scaninfo, scaninfo.next = headinfo), scaninfo.ends_at = scanstate.location, 
                    scanstate.tagstack = scanstate.tagstack.slice(0, -1), scaninfo = scaninfo.head, 
                    scan = scaninfo.elt || document.getElementById(scaninfo.frag), scanlevel = scaninfo ? scaninfo.level : 0;
                }
                Trace.domscan > 2 && fdjtLog("Found parent: up=%o, info=%o, leel=%d, sh=%o", scan || !1, scaninfo, scaninfo.level, scaninfo.head), 
                headinfo.head = scaninfo, headinfo.indexRef("head", scaninfo), scaninfo.sub.push(headinfo);
            }
            var supinfo = headinfo.head, newheads = [];
            supinfo.heads && (newheads = newheads.concat(supinfo.heads)), supinfo && newheads.push(supinfo), 
            headinfo.heads = newheads, headinfo.indexRef("heads", newheads), Trace.domscan > 2 && fdjtLog("@%d: Found head=%o, headinfo=%o, book_head=%o", scanstate.location, head, headinfo, headinfo.head), 
            scanstate.curhead = head, scanstate.curinfo = headinfo, scanstate.curlevel = level, 
            headinfo && (headinfo.ends_at = scanstate.location + textWidth(head)), scanstate.location = scanstate.location + textWidth(head);
        }
        function assignWSN(child) {
            var wsn = !1, tag = child.tagName;
            if ((0 === tag.search(/p|h\d|blockquote|li/i) || 0 === getStyle(child).display.search(/block|list-item|table|table-row/)) && child.childNodes && child.childNodes.length && (wsn = md5ID(child))) {
                var wbaseid = "WSN_" + wsn, wsnid = wbaseid, count = 1;
                if ("WSN_" !== wbaseid) {
                    for (;idmap[wsnid] || document.getElementById(wsnid); ) wsnid = wbaseid + "_" + count++;
                    if (wbaseid !== wsnid) {
                        var text = fdjtDOM.textify(child);
                        fdjtLog.warn("Duplicate WSN ID %s: %s", wsnid, text);
                    }
                    return child.id = wsnid, idmap[wsnid] = child, wsnid;
                }
            }
        }
        function scanner(child, scanstate, docinfo) {
            var location = scanstate.location, curhead = scanstate.curhead, curinfo = scanstate.curinfo, curlevel = scanstate.curlevel;
            if (baseid || (baseid = mB.baseid), scanstate.nodecount++, 3 === child.nodeType) {
                var stdcontent = stdspace(child.nodeValue), width = stdcontent.length;
                return scanstate.location = scanstate.location + width, 0;
            }
            if (1 !== child.nodeType) return 0;
            var tag = child.tagName, classname = child.className, id = child.id;
            if (id && 0 === id.search(baseid) || (id = child.getAttribute("data-tocid") || child.id), 
            !(metaBook.ignore && metaBook.ignore.match(child) || rootns && child.namespaceURI !== rootns || classname && ("string" != typeof classname || classname.search(/\b(metabookignore)\b/) >= 0) || child.metabookui || id && 0 === id.search("METABOOK"))) {
                if (Trace.domscan > 3 && fdjtLog("Scanning %o level=%o, loc=%o, head=%o: %j", child, curlevel, location, curhead, curinfo), 
                id || baseid) if (id) if (idmap[id]) if (idmap[id] !== child) {
                    var newid = id + "x" + scanstate.location;
                    if (idmap[id]) {
                        for (var u = 1, xid = newid + "x" + u; idmap[xid]; ) u++, xid = newid + "x" + u;
                        newid = xid;
                    }
                    fdjtLog.warn("Duplicate ID=%o newid=%o", id, newid), id = child.id = newid, docinfo[newid] || (docinfo[newid] = new ScanInfo(newid, scanstate)), 
                    idmap[newid] = child;
                } else idmap[id] = child; else idmap[id] = child; else ; else need_ids.push(child);
                var lim, i = 0, tocloc = child.metabooktocloc || child.getAttribute("data-tocloc");
                if (tocloc && docinfo[tocloc]) {
                    var tocinfo = docinfo[tocloc];
                    curlevel = scanstate.curlevel, curhead = scanstate.curhead, curinfo = scanstate.curinfo;
                    var notoc = scanstate.notoc, headinfo = tocinfo.head;
                    scanstate.curinfo = headinfo, scanstate.curhead = headinfo.elt || document.getElementById(headinfo.frag), 
                    scanstate.curlevel = headinfo.level, scanstate.notoc = !0;
                    var toc_children = child.childNodes;
                    for (i = 0, lim = toc_children.length; lim > i; ) {
                        var toc_child = toc_children[i++];
                        1 === toc_child.nodeType && scanner(toc_child, scanstate, docinfo);
                    }
                    return scanstate.curlevel = curlevel, scanstate.notoc = notoc, scanstate.curhead = curhead, 
                    scanstate.curinfo = curinfo, void 0;
                }
                var toclevel = getLevel(child, curlevel), info = !1;
                if (toclevel && !id && need_ids.push(child), id && ((info = docinfo[id]) || (allids.push(id), 
                info = new ScanInfo(id, scanstate), docinfo[id] !== info && window.alert("Wrong"), 
                docinfo[id] = info, info.elt = child)), (scanstate.notoc || "header" === tag) && (scanstate.notoc = !0, 
                toclevel = 0), scanstate.eltcount++, info && id && child.id && child.id !== id && (info.addAlias(child.id), 
                docinfo[child.id] = info), info && (info.starts_at = scanstate.location, info.bookhead = curhead.getAttribute("data-tocid") || curhead.id, 
                info.headstart = curinfo.starts_at), id && info && !start && (metaBook.start = start = child), 
                info && toclevel && !info.toclevel && (info.toclevel = toclevel), id && info) {
                    var tags = child.getAttribute("tags") || child.getAttribute("data-tags");
                    tags && (info.atags = tags.split(","));
                }
                if (!(classname && classname.search && classname.search(/\b(sbook|pubtool)ignore\b/) >= 0 || metaBook.ignore && metaBook.ignore.match(child))) {
                    if (id && toclevel ? handleHead(child, id, docinfo, scanstate, toclevel, curhead, curinfo, curlevel) : info && (info.head = curinfo, 
                    info.indexRef("head", curinfo)), info) {
                        var altids = child.getAttribute("data-altid");
                        if (altids) {
                            altids = altids.split(" ");
                            for (var alti = 0, altlen = altids.length; altlen > alti; ) {
                                var altid = altids[alti++];
                                docinfo[altid] || (info.addAlias(altid), docinfo[altid] = info);
                            }
                        }
                    }
                    if (classname && classname.search && classname.search(/\b(sbook|pubtool)terminal\b/) >= 0 || classname && metaBook.terminals && metaBook.terminals.match(child)) scanstate.location = scanstate.location + textWidth(child); else {
                        var grandchildren = child.childNodes;
                        for (i = 0, lim = grandchildren.length; lim > i; ) {
                            var grandchild = grandchildren[i++];
                            if (3 === grandchild.nodeType) {
                                var content = stdspace(grandchild.nodeValue);
                                scanstate.location = scanstate.location + content.length;
                            } else 1 === grandchild.nodeType && scanner(grandchild, scanstate, docinfo);
                        }
                    }
                    info && (info.ends_at = scanstate.location), toclevel && (scanstate.lasthead = child, 
                    scanstate.lastinfo = info, scanstate.lastlevel = toclevel);
                }
            }
        }
        var md5ID = fdjt.WSN.md5ID, stdspace = fdjtString.stdspace, getStyle = fdjtDOM.getStyle, rootns = root.namespaceURI, baseid = mB.baseid, idmap = {}, need_ids = [];
        if (root === void 0) return this;
        docinfo || (docinfo = this instanceof MetaBookDOMScan ? this : new MetaBookDOMScan()), 
        root || (root = metaBook.docroot || document.body);
        var start = new Date(), allheads = [], allids = [];
        docinfo._root = root, docinfo._heads = allheads, docinfo._ids = allids, root.id || (root.id = "METABOOKROOT"), 
        (Trace.startup > 1 || Trace.domscan) && (root.id ? fdjtLog("Scanning %s#%s for structure and metadata", root.tagName, root.id) : fdjtLog("Scanning DOM for structure and metadata: %o", root));
        var children = root.childNodes, scanstate = {
            curlevel: 0,
            idserial: 0,
            location: 0,
            nodecount: 0,
            eltcount: 0,
            headcount: 0,
            tagstack: [],
            taggings: [],
            allinfo: [],
            locinfo: [],
            idmap: idmap,
            idstate: {
                prefix: !1,
                count: 0
            },
            idstack: [ {
                prefix: !1,
                count: 0
            } ],
            pool: metaBook.docdb
        }, docdb = new RefDB(dbid);
        ScanInfo.prototype = new Ref(), ScanInfo.prototype._id = ScanInfo.prototype._domain = ScanInfo.prototype._db = ScanInfo.prototype.frag = ScanInfo.prototype._live = ScanInfo.prototype._changed = ScanInfo.prototype.starts_at = ScanInfo.prototype.ends_at = ScanInfo.prototype.head = ScanInfo.prototype.headstart = ScanInfo.prototype.elt = ScanInfo.prototype.title = ScanInfo.prototype.bookhead = !1, 
        docdb.refclass = ScanInfo, docinfo._docdb = docdb;
        var rootinfo = docinfo[root.id] || (docinfo[root.id] = new ScanInfo(root.id, scanstate));
        scanstate.curhead = root, scanstate.curinfo = rootinfo, rootinfo.title = root.title || document.title, 
        rootinfo.starts_at = 0, rootinfo.level = 0, rootinfo.sub = [], rootinfo.head = !1, 
        rootinfo.heads = [], rootinfo.frag = root.id, rootinfo.elt = root, scanstate.allinfo.push(rootinfo), 
        scanstate.allinfo.push(0);
        for (var i = 0; children.length > i; ) {
            var child = children[i++];
            child.sbookskip || child.metabookui || scanner(child, scanstate, docinfo);
        }
        docinfo._nodecount = scanstate.nodecount, docinfo._headcount = scanstate.headcount, 
        docinfo._eltcount = scanstate.eltcount, docinfo._maxloc = scanstate.location, docinfo._allinfo = scanstate.allinfo, 
        docinfo._locinfo = scanstate.locinfo;
        for (var scaninfo = scanstate.curinfo; scaninfo; ) scaninfo.ends_at = scanstate.location, 
        scaninfo = scaninfo.head;
        var done = new Date();
        return (Trace.startup || Trace.domscan) && fdjtLog("Gathered metadata in %f secs over %d heads, %d nodes", (done.getTime() - start.getTime()) / 1e3, scanstate.headcount, scanstate.eltcount), 
        docinfo.addContent = function(node) {
            scanner(node, scanstate, docinfo), docinfo._nodecount = scanstate.nodecount, docinfo._headcount = scanstate.headcount, 
            docinfo._eltcount = scanstate.eltcount, docinfo._maxloc = scanstate.location, docinfo._allinfo = scanstate.allinfo, 
            docinfo._locinfo = scanstate.locinfo;
            for (var scaninfo = scanstate.curinfo; scaninfo; ) scaninfo.ends_at = scanstate.location, 
            scaninfo = scaninfo.head;
        }, need_ids.length && fdjtAsync.slowmap(assignWSN, need_ids), docinfo._rootinfo = docinfo[root.id], 
        docinfo;
    }
    var mB = metaBook, Trace = mB.Trace, fdjtString = fdjt.String, fdjtAsync = fdjt.Async, fdjtTime = fdjt.Time, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, RefDB = fdjt.RefDB, Ref = RefDB.Ref, getLevel = metaBook.getTOCLevel;
    return MetaBookDOMScan.prototype.toJSON = function() {
        var rep = {
            constructor: "metaBook.DOMScan",
            frag: this.frag,
            head: this.bookhead,
            start: this.starts_at,
            end: this.ends_at
        };
        return this.WSNID && (rep.WSNID = this.WSNID), this.headstart && (rep.headstart = this.headstart), 
        this.toclevel && (rep.toclevel = this.toclevel), this.title && (rep.title = this.title), 
        JSON.stringify(rep);
    }, MetaBookDOMScan.getTOCLevel = getLevel, MetaBookDOMScan;
}(), function() {
    "use strict";
    function setupGlossData() {
        for (var cached = getLocal("mB(" + mB.docid + ").glossdata", !0), i = 0, len = cached.length; len > i; ) glossdata_state[cached[i++]] = "cached";
    }
    function cacheGlossData(uri) {
        function caching(resolved, rejected) {
            if (0 === uri.search(mB.cachelink)) {
                if (glossdata[uri]) return resolved(glossdata[uri]);
                if ("cached" !== glossdata_state[uri]) {
                    if (glossdata_state[uri]) return glossdata_waiting[uri] ? glossdata_waiting[uri].push(resolved) : glossdata_waiting[uri] = [ resolved ], 
                    void 0;
                    glossdata_state[uri] = "fetching";
                    var endpoint, rtype, req = new XMLHttpRequest();
                    Blob && createObjectURL ? (endpoint = uri, rtype = "blob") : (endpoint = "https://glossdata.bookhub.io/U/" + uri.slice("https://glossdata.bookhub.io/".length), 
                    rtype = "");
                    var mycopyid = mB.mycopyid;
                    mycopyid && (endpoint = endpoint + "?MYCOPYID=" + encodeURIComponent(mycopyid) + "&DOC=" + encodeURIComponent(mB.docref)), 
                    Trace.glossdata && fdjtLog("Fetching glossdata %s (%s) to cache locally", uri, rtype), 
                    req.onreadystatechange = function() {
                        if (4 === req.readyState && 200 === req.status) try {
                            var local_uri = !1, data_uri = !1;
                            if (Trace.glossdata && fdjtLog("Glossdata from %s (%s) status %d", endpoint, rtype || "any", req.status), 
                            "blob" !== rtype ? data_uri = local_uri = req.responseText : local_uri = createObjectURL ? createObjectURL(req.response) : !1, 
                            local_uri && gotLocalURL(uri, local_uri, resolved), data_uri) glossdata_state[uri] = "caching", 
                            cacheDataURI(uri, data_uri); else {
                                var reader = new FileReader(req.response);
                                glossdata_state[uri] = "reading", reader.onload = function() {
                                    try {
                                        local_uri || gotLocalURL(uri, reader.result, resolved), glossdata_state[uri] = "caching", 
                                        cacheDataURI(uri, reader.result);
                                    } catch (ex) {
                                        fdjtLog.warn("Error encoding %s from %s: %s", uri, endpoint, ex), glossdata_state[uri] = !1;
                                    }
                                }, reader.readAsDataURL(req.response);
                            }
                        } catch (ex) {
                            fdjtLog.warn("Error fetching %s via %s: %s", uri, endpoint, ex), glossdata_state[uri] = !1, 
                            rejected && rejected(ex);
                        } else 4 === req.readyState && (fdjtLog.warn("Error (%d) fetching %s via %s", req.status, uri, endpoint), 
                        glossdata_state[uri] = !1, rejected && rejected(req));
                    }, req.open("GET", endpoint), req.responseType = rtype, req.send(null);
                }
            }
        }
        return new Promise(caching);
    }
    function needGlossData(uri) {
        if (!glossdata[uri] && "cached" !== glossdata_state[uri]) {
            if (!navigator.onLine) return 0 === need_glossdata.length && fdjt.DOM.addListener(window, "online", load_glossdata), 
            0 > need_glossdata.indexOf(uri) && need_glossdata.push(uri), void 0;
            if (mB.mycopyid && new Date() > mB.mycopyid_expires) return cacheGlossData(uri).catch(function() {
                delay_glossdata(uri);
            });
            var req = mB.getMyCopyId();
            return req.then(function(mycopyid) {
                return mycopyid ? cacheGlossData(uri).catch(function(trouble) {
                    fdjtLog("Couldn't cache %s: %o", uri, trouble), delay_glossdata(uri);
                }) : (delay_glossdata(uri), void 0);
            }).catch(function() {
                delay_glossdata(uri);
            });
        }
    }
    function delay_glossdata(uri) {
        need_glossdata.push(uri), glossdata_timer || (glossdata_timer = setTimeout(load_glossdata, glossdata_wait));
    }
    function load_glossdata() {
        if (navigator.onLine && need_glossdata.length) {
            glossdata_timer && (clearTimeout(glossdata_timer), glossdata_timer = !1);
            var needed = need_glossdata;
            need_glossdata = [];
            for (var i = 0, lim = needed.length; lim > i; ) needGlossData(needed[i++]);
        }
    }
    function getGlossData(uri) {
        function getting(resolved, failed) {
            return glossdata[uri] ? (resolved(glossdata[uri]), void 0) : "cached" === glossdata_state[uri] ? metaBook.getDB().then(function(db) {
                var txn = db.transaction([ "glossdata" ], "readwrite"), storage = txn.objectStore("glossdata"), req = storage.get(uri);
                req.onsuccess = function(event) {
                    var object = event.target.result;
                    return object ? (gotLocalURL(uri, object.datauri, resolved), void 0) : (fdjtLog("Corrupted local glossdata cache for %s", uri), 
                    glossdata_state[uri] = !1, fillCache(resolved, failed));
                }, req.onerror = function(ex) {
                    return fdjtLog("Error getting %s from glossdata cache: %s", uri, ex), glossdata_state[uri] = !1, 
                    fillCache(resolved, failed);
                };
            }).catch(failed) : fillCache(resolved, failed);
        }
        function fillCache(resolved, failed) {
            mB.mycopyid && new Date() > mB.mycopyid_expires ? setTimeout(function() {
                cacheGlossData(uri).then(resolved).catch(failed);
            }, 2e3) : mB.getMyCopyId().then(function(mycopyid) {
                mycopyid ? setTimeout(function() {
                    cacheGlossData(uri).then(resolved).catch(failed);
                }, 2e3) : failed(Error("Couldn't get MYCOPYID"));
            }).catch(failed);
        }
        return new Promise(getting);
    }
    function gotLocalURL(uri, local_url, resolved) {
        var i, lim, waiting_elts = mB.srcloading[uri], waiting = glossdata_waiting[uri];
        if (mB.srcloading[uri] = !1, glossdata_waiting[uri] = !1, glossdata[uri] = local_url, 
        resolved && resolved(local_url), waiting_elts) for (i = 0, lim = waiting_elts.length, 
        Trace.glossdata && fdjtLog("Setting glossdata src for %d element(s)", lim); lim > i; ) waiting_elts[i++].src = local_url;
        if (waiting) {
            for (i = 0, lim = waiting.length; lim > i; ) waiting[i++](local_url);
            mB.srcloading[uri] = !1;
        }
    }
    function cacheDataURI(url, datauri) {
        var key = "gD(" + url + ").glossdata";
        metaBook.getDB().then(function(db) {
            var txn = db.transaction([ "glossdata" ], "readwrite"), storage = txn.objectStore("glossdata"), req = storage.put({
                url: url,
                datauri: datauri
            }), completed = !1;
            req.onerror = function(event) {
                glossdata_state[url] = !1, completed = !0, fdjtLog("Error saving %s in indexedDB: %o", url, event.target.errorCode);
            }, req.onsuccess = function() {
                glossdata_state[url] = "cached", completed = !0, Trace.glossdata && fdjtLog("Saved glossdata for %s in IndexedDB", url), 
                glossDataSaved(url);
            }, "done" !== req.status || completed || req.onsuccess();
        }).catch(function() {
            setLocal(key, datauri);
        });
    }
    function glossDataSaved(url) {
        Trace.glossdata && fdjtLog("GlossData cached for %s", url), pushLocal("mB(" + mB.docid + ").glossdata", url);
    }
    function clearGlossData(docid) {
        var key = "mB(" + docid + ").glossdata", urls = getLocal(key, !0);
        urls && urls.length ? clearGlossDataCache(urls, key) : dropLocal(key);
    }
    function clearGlossDataCache(urls, key) {
        function clearing(resolve) {
            metaBook.getDB().then(function(db) {
                var txn = db.transaction([ "glossdata" ], "readwrite"), storage = txn.objectStore("glossdata");
                storage.openCursor().onsuccess = function(event) {
                    var cursor = event.target.result;
                    if (cursor) if (urls.indexOf(cursor.key) >= 0) {
                        var req = cursor["delete"]();
                        req.onsuccess = function() {
                            removeLocal(key, cursor.key), cursor["continue"]();
                        }, req.onerror = function() {
                            cursor["continue"]();
                        };
                    } else cursor["continue"](); else resolve();
                };
            });
        }
        return new Promise(clearing);
    }
    var fdjtLog = fdjt.Log, fdjtState = fdjt.State, setLocal = fdjtState.setLocal, getLocal = fdjtState.getLocal, dropLocal = fdjtState.dropLocal, pushLocal = fdjtState.pushLocal, removeLocal = fdjtState.removeLocal, mB = metaBook, Trace = metaBook.Trace, glossdata = metaBook.glossdata, glossdata_state = {}, glossdata_waiting = {}, createObjectURL = window.URL && window.URL.createObjectURL || window.webkitURL && window.webkitURL.createObjectURL, Blob = window.Blob;
    metaBook.setupGlossData = setupGlossData;
    var glossdata_wait = 6e4, glossdata_timer = !1, need_glossdata = [];
    metaBook.needGlossData = needGlossData, metaBook.getGlossData = getGlossData, metaBook.clearGlossData = clearGlossData;
}(), function() {
    "use strict";
    function hasAnyContent(n) {
        return hasContent(n, !0);
    }
    function console_eval() {
        fdjtLog("Executing %s", input_console.value);
        var result = eval(input_console.value), string_result = result.nodeType ? fdjtString("%o", result) : fdjtString("%j", result);
        fdjtLog("Result is %s", string_result);
    }
    function consolebutton_click(evt) {
        Trace.gesture > 1 && fdjtLog("consolebutton_click %o", evt), console_eval();
    }
    function consoleinput_keypress(evt) {
        evt = evt || window.event, 13 === evt.keyCode && (evt.ctrlKey || (fdjtUI.cancel(evt), 
        console_eval(), evt.shiftKey && (input_console.value = "")));
    }
    function stripExplicitStyles(root) {
        if (root.id && 0 === root.id.search("METABOOK") && root.removeAttribute("style"), 
        root.childNodes) for (var children = root.childNodes, i = 0, lim = children.length; lim > i; ) {
            var child = children[i++];
            1 === child.nodeType && stripExplicitStyles(child);
        }
    }
    function setupCover() {
        var frame = $ID("METABOOKFRAME"), started = fdjtTime(), cover = fdjtDOM("div#METABOOKCOVER.metabookcover"), existing_cover = $ID("METABOOKCOVER");
        Trace.startup > 2 && fdjtLog("Setting up cover"), frame || (frame = fdjtDOM("div#METABOOKFRAME"), 
        fdjtDOM.prepend(document.body, frame)), metaBook.Frame = frame, metaBook.cover = cover, 
        cover.innerHTML = fixStaticRefs(metaBook.HTML.cover);
        var coverpage = $ID("METABOOKCOVERPAGE");
        if (coverpage) hasAnyContent(coverpage) || (coverpage.removeAttribute("style"), 
        coverpage = !1); else if (metaBook.coverimage) {
            var coverimage = fdjtDOM.Image(metaBook.coverimage);
            coverimage.id = "METABOOKCOVERIMAGE", coverpage = fdjtDOM("div.flap#METABOOKCOVERPAGE", coverimage);
        } else coverpage = !1;
        if (coverpage) cover.setAttribute("data-defaultclass", "coverpage"), addClass(cover, "coverpage"), 
        addToCover(cover, coverpage); else {
            var controls = fdjt.DOM.getChild(cover, "#METABOOKCOVERCONTROLS");
            cover.setAttribute("data-defaultclass", "titlepage"), addClass(cover, "titlepage"), 
            addClass(controls, "nocoverpage");
        }
        var titlepage = $ID("METABOOKTITLE");
        if (titlepage && hasAnyContent(titlepage)) titlepage = titlepage.cloneNode(!0), 
        titlepage.removeAttribute("style"), titlepage.id = "METABOOKTITLE"; else if (titlepage = $ID("METABOOKTITLEPAGE") || $ID("PUBTOOLTITLEPAGE") || $ID("TITLEPAGE")) titlepage = titlepage.cloneNode(!0), 
        fdjtDOM.dropClass(titlepage, /\b(codex|metabook)[A-Za-z0-9]+\b/), fdjtDOM.addClass(titlepage, "sbooktitlepage"), 
        fdjtDOM.stripIDs(titlepage), titlepage.setAttribute("style", ""), titlepage.id = "METABOOKTITLE"; else {
            var info = metaBook.getBookInfo();
            titlepage = fdjtDOM("div#METABOOKTITLE.flap", fdjtDOM("DIV.title", info.title), fdjtDOM("DIV.credits", info.byline ? fdjtDOM("DIV.byline", info.byline) : info.authors && info.authors.length ? fdjtDOM("DIV.author", info.authors[0]) : !1), fdjtDOM("DIV.pubinfo", info.publisher && fdjtDOM("P", info.publisher)));
        }
        titlepage && addToCover(cover, titlepage);
        var creditspage = $ID("METABOOKCREDITS");
        if (creditspage ? creditspage = creditspage.cloneNode(!0) : (creditspage = $ID("METABOOKCREDITS") || $ID("SBOOKSCREDITSPAGE") || $ID("CREDITSPAGE"), 
        creditspage && (creditspage = creditspage.cloneNode(!0), fdjtDOM.stripIDs(creditspage), 
        creditspage.removeAttribute("style"))), creditspage && hasAnyContent(creditspage)) {
            var curcredits = cover.getElementById("METABOOKCREDITS");
            curcredits ? curcredits.parentNode.replaceChild(creditspage, curcredits) : cover.appendChild(creditspage);
        } else creditspage = !1;
        creditspage && addToCover(cover, creditspage);
        var blurb = $ID("METABOOKBLURB") || $ID("METABOOKABOUTPAGE");
        if (blurb && hasAnyContent(blurb)) blurb = blurb.cloneNode(!0), blurb.id = "METABOOKBLURB", 
        blurb.removeAttribute("style"); else {
            var about_book = $ID("METABOOKABOUTPAGE") || $ID("METABOOKABOUTBOOK") || $ID("PUBTOOLABOUTBOOK"), about_author = $ID("METABOOKABOUTAUTHOR") || $ID("PUBTOOLABOUTAUTHOR");
            blurb = about_book || about_author ? fdjtDOM("div#METABOOKBLURB.flap.metabookblurb.scrolling", "\n", about_book, "\n", about_author, "\n") : !1;
        }
        blurb && addToCover(cover, blurb);
        var settings = fdjtDOM("div#METABOOKSETTINGS.flap.scrolling");
        settings.innerHTML = fixStaticRefs(metaBook.HTML.settings), metaBook.DOM.settings = settings, 
        settings && addToCover(cover, settings);
        var cover_help = fdjtDOM("div#METABOOKAPPHELP.flap.metabookhelp.scrolling");
        cover_help.innerHTML = fixStaticRefs(metaBook.HTML.help), cover_help && addToCover(cover, cover_help);
        var console = metaBook.DOM.console = fdjtDOM("div#METABOOKCONSOLE.flap.metabookconsole.scrolling");
        Trace.startup > 2 && fdjtLog("Setting up console %o", console), console.innerHTML = fixStaticRefs(metaBook.HTML.console), 
        metaBook.DOM.input_console = input_console = fdjtDOM.getChild(console, "TEXTAREA"), 
        metaBook.DOM.input_button = input_button = fdjtDOM.getChild(console, "span.button"), 
        input_button.onclick = consolebutton_click, input_console.onkeypress = consoleinput_keypress, 
        console && addToCover(cover, console);
        var layers = fdjtDOM("div#METABOOKLAYERS.flap"), sbooksapp = fdjtDOM("iframe#BOOKHUBAPP");
        sbooksapp.setAttribute("frameborder", 0), sbooksapp.setAttribute("scrolling", "auto"), 
        layers.appendChild(sbooksapp), metaBook.DOM.sbooksapp = sbooksapp, layers && addToCover(cover, layers);
        var cc = getChildren(cover, "#METABOOKCOVERCONTROLS");
        cc && (coverpage || addClass(cc, "nobookcover"), creditspage || addClass(cc, "nocredits"), 
        blurb || addClass(cc, "noblurb")), metaBook.touch ? fdjtDOM.addListener(cover, "touchstart", cover_clicked) : fdjtDOM.addListener(cover, "click", cover_clicked), 
        stripExplicitStyles(cover), existing_cover && existing_cover.parentNode === frame ? frame.replaceChild(cover, existing_cover) : (frame.appendChild(cover), 
        existing_cover && existing_cover.parentNode.removeChild(existing_cover));
        var hidden_refuri = fdjt.ID("BHLOGIN_REFURI"), hidden_docid = fdjt.ID("BHLOGIN_DOCID"), hidden_origin = fdjt.ID("BHLOGIN_ORIGIN");
        return hidden_refuri && mB.refuri && (hidden_refuri.value = mB.refuri), hidden_docid && mB.docid && (hidden_docid.value = mB.docid), 
        hidden_origin && (hidden_origin.value = location.origin), metaBook.showCover(), 
        Trace.startup > 1 && fdjtLog("Cover setup done in %dms", fdjtTime() - started), 
        cover;
    }
    function addToCover(cover, item) {
        for (var children = toArray(cover.childNodes), i = 0, lim = children.length; lim > i; ) {
            var child = children[i++];
            if (1 === child.nodeType && (child.id === item.id || child.id === item.id + "HOLDER")) return cover.replaceChild(item, child), 
            void 0;
        }
        cover.appendChild(item);
    }
    function resizeCover(cover) {
        if (cover || (cover = $ID("METABOOKCOVER")), cover) {
            var frame = $ID("METABOOKFRAME"), style = cover.style, framestyle = frame.style, restore = 0;
            cover.offsetHeight || (restore = 1, style.zIndex = -500, style.visibility = "hidden", 
            style.opacity = 0, style.display = "block", style.height = "100%", style.width = "100%", 
            framestyle.display = "block");
            var controls = $ID("METABOOKCOVERCONTROLS"), userbox = $ID("METABOOKUSERBOX");
            fdjtDOM.adjustFontSize(controls), fdjtDOM.adjustFontSize(userbox);
            var covertitle = $ID("METABOOKTITLE");
            covertitle && !hasClass(covertitle, /\b(adjustfont|fdjtadjustfont)\b/) && fdjtDOM.adjustFontSize(covertitle), 
            restore && (style.zIndex = "", style.display = "", style.opacity = "", style.visibility = "", 
            framestyle.display = "");
        }
    }
    function cover_clicked(evt) {
        var target = fdjtUI.T(evt), cover = $ID("METABOOKCOVER");
        return metaBook.statedialog && (fdjt.Dialog.close(metaBook.statedialog), metaBook.statedialog = !1), 
        fdjt.UI.isClickable(target) ? void 0 : hasParent(target, $ID("METABOOKCOVERCONTROLS")) ? controls_clicked(evt, target, cover) : hasParent(target, ".scrolling") ? void 0 : (metaBook.clearStateDialog(), 
        metaBook.hideCover(), fdjtUI.cancel(evt), void 0);
    }
    function controls_clicked(evt, target, cover) {
        for (var scan = target; scan && scan !== document.body && !scan.getAttribute("data-mode"); ) scan = scan.parentNode;
        var mode = scan.getAttribute("data-mode");
        "layers" !== mode || $ID("BOOKHUBAPP").src || metaBook.appinit || metaBook.initIFrameApp();
        var curclass = cover.className, cur = curclass && coverids[curclass] && $ID(coverids[curclass]), nxt = mode && coverids[mode] && $ID(coverids[mode]);
        return cur && nxt && (cur.style.display = "block", nxt.style.display = "block", 
        setTimeout(function() {
            cur.style.display = "", nxt.style.display = "";
        }, 3e3)), setTimeout(function() {
            Trace.mode && fdjtLog("On %o, switching cover mode to %s from %s", evt, mode, curclass), 
            "console" === mode && fdjtLog.update(), cover.className = mode, metaBook.mode = mode;
        }, 20), fdjt.UI.cancel(evt), !1;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtString = fdjt.String, fdjtUI = fdjt.UI, fdjtTime = fdjt.Time, $ID = fdjt.ID, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, hasClass = fdjtDOM.hasClass, hasParent = fdjtDOM.hasParent, getChildren = fdjtDOM.getChildren, mB = metaBook, Trace = mB.Trace, fixStaticRefs = metaBook.fixStaticRefs, hasContent = fdjtDOM.hasContent, input_console = !1, input_button = !1;
    metaBook.setupCover = setupCover;
    var toArray = fdjtDOM.toArray;
    metaBook.resizeCover = resizeCover;
    var coverids = {
        coverpage: "METABOOKCOVERPAGE",
        titlepage: "METABOOKTITLE",
        creditspage: "METABOOKCREDITS",
        blurb: "METABOOKBLURB",
        help: "METABOOKAPPHELP",
        settings: "METABOOKSETTINGS",
        layers: "METABOOKLAYERS"
    };
    metaBook.addConfig("showconsole", function(name, value) {
        var root = document.documentElement || document.body;
        value ? addClass(root, "_SHOWCONSOLE") : dropClass(root, "_SHOWCONSOLE");
        var controls = $ID("METABOOKCOVERCONTROLS");
        controls && fdjtDOM.adjustFontSize(controls), fdjt.Async(function() {
            metaBook.updateSettings(name, value);
        });
    });
}(), function() {
    "use strict";
    function addHandlers(node, type) {
        var mode = metaBook.ui;
        fdjtDOM.addListeners(node, mB.UI.handlers[mode][type]);
    }
    function initBody() {
        var i, lim, body = document.body, started = fdjtTime(), init_content = $ID("CODEXCONTENT"), content = init_content || fdjtDOM("div#CODEXCONTENT");
        Trace.startup > 2 && fdjtLog("Starting initBody"), addClass(content, "metabookcontent"), 
        addClass(content, "codexroot"), body.setAttribute("tabindex", 1), body.style.fontSize = "", 
        body.style.width = "", metaBook.content = content;
        var notesblock = $ID("METABOOKNOTES") || fdjtDOM("div.metabookbackmatter#METABOOKNOTES");
        applyMetaClass("htmlbooknote"), applyMetaClass("htmlbooknote", "METABOOK.booknotes"), 
        addClass(fdjtDOM.$("span[data-type='footnote']"), "htmlbooknote");
        var allnotes = getChildren(content, ".htmlbooknote");
        for (i = 0, lim = allnotes.length; lim > i; ) {
            var notable = allnotes[i++], counter = note_counter++, noteid = "METABOOKNOTE" + counter, refid = "METABOOKNOTE" + counter + "_ref", label_text = notable.getAttribute("data-label") || "" + counter, label_node = getChild(notable, "label") || getChild(notable, "summary") || getChild(notable, ".html5label") || getChild(notable, ".html5summary"), anchor = fdjtDOM.Anchor("#" + noteid, "A.mbnoteref.htmlnoteref", label_node ? label_node.cloneNode(!0) : label_text), backlink = fdjtDOM.Anchor("#" + refid, "A.htmlackref", label_node ? label_node.cloneNode(!0) : label_text);
            anchor.id = refid, fdjtDOM.replace(notable, anchor), dropClass(notable, "booknote");
            var noteblock = "SPAN" === notable.tagName ? fdjtDOM("div.booknotebody", backlink, toArray(notable.childNodes)) : fdjtDOM("div.booknotebody", backlink, notable);
            noteblock.id = noteid, fdjtDOM.append(notesblock, noteblock, "\n");
        }
        if (!init_content) {
            var children = [], childnodes = body.childNodes;
            for (i = 0, lim = childnodes.length; lim > i; ) children.push(childnodes[i++]);
            for (i = 0; lim > i; ) {
                var child = children[i++];
                1 !== child.nodeType ? content.appendChild(child) : child.id && 0 === child.id.search("METABOOK") || /(META|LINK|SCRIPT)/gi.test(child.tagName) || content.appendChild(child);
            }
        }
        for (var wikiref_pat = /^http(s)?:\/\/([a-z]+.)?wikipedia.org\//, anchors = content.getElementsByTagName("A"), ai = 0, alimit = anchors.length; alimit > ai; ) {
            var a = anchors[ai++], href = a.getAttribute("href");
            if (href && "#" !== href[0] && 0 === href.search(/^[a-zA-Z][a-zA-Z][a-zA-Z]+:/)) {
                var aclass = a.className, extclass = "extref";
                if (0 === href.search(wikiref_pat)) {
                    var text = fdjt.DOM.textify(a);
                    isEmpty(text) || (a.title ? a.title.search(/wikipedia/i) >= 0 || (a.title = "Wikipedia: " + a.title) : a.title = "From Wikipedia", 
                    extclass += " wikiref");
                }
                a.className = aclass ? aclass + " " + extclass : extclass, a.target = "_blank";
            }
        }
        var notelinks = getChildren(content, "a[rel='sbooknote'],a[rel='footnote'],a[rel='endnote']");
        for (i = 0, lim = notelinks.length; lim > i; ) {
            var ref = notelinks[i++], nref = ref.href;
            hasText(ref) || (ref.innerHTML = "Note"), nref && "#" === nref[0] && addClass($ID(nref.slice(1)), "sbooknote");
        }
        notesblock.childNodes.length && fdjtDOM.append(content, "\n", notesblock, "\n"), 
        metaBook.coverpage = metaBook.getCoverPage(), metaBook.titlepage = $ID("SBOOKTITLEPAGE");
        var pages = metaBook.pages = $ID("METABOOKPAGES") || fdjtDOM("div#METABOOKPAGES"), page = metaBook.page = fdjtDOM("div#CODEXPAGE.metabookcontent", pages);
        if (metaBook.body = $ID("METABOOKBODY"), metaBook.body) metaBook.body.appendChild(page); else {
            var cxbody = metaBook.body = fdjtDOM("div#METABOOKBODY.metabookbody", content, page);
            metaBook.textjustify && addClass(cxbody, "metabookjustify"), metaBook.bodycontrast && addClass(cxbody, "metabookcontrast" + metaBook.bodycontrast), 
            metaBook.bodysize && addClass(cxbody, "metabookbodysize" + metaBook.bodysize), metaBook.bodyfamily && addClass(cxbody, "metabookbodyfamily" + metaBook.bodyfamily), 
            metaBook.bodyspacing && addClass(cxbody, "metabookbodyspacing" + metaBook.bodyspacing), 
            body.appendChild(cxbody);
        }
        var menu = metaBook.menu = fdjtDOM("div.metabookui#METABOOKMENU");
        menu.innerHTML = fixStaticRefs(metaBook.HTML.menu), fdjtDOM.prepend($ID("METABOOKBODY"), menu);
        var layout_wait = metaBook.menu = fdjtDOM("div.metabookui#MBLAYOUTWAIT");
        layout_wait.innerHTML = fixStaticRefs(metaBook.HTML.layoutwait), fdjtDOM.prepend($ID("METABOOKBODY"), layout_wait), 
        initMargins(), addHandlers($ID("METABOOKBODY"), "content"), metaBook.TapHold.body = fdjtUI.TapHold($ID("METABOOKBODY"), {
            override: !0,
            noslip: !0,
            id: "METABOOKBODY",
            maxtouches: 3,
            taptapmsecs: !0,
            movethresh: 10,
            untouchable: !1
        }), metaBook.TapHold.menu = fdjtUI.TapHold($ID("METABOOKMENU"), {
            override: !0,
            noslip: !1,
            id: "METABOOKMENU",
            maxtouches: 3,
            taptapmsecs: !1,
            movethresh: 10,
            untouchable: !1
        }), Trace.startup > 1 && fdjtLog("initBody took %dms", fdjtTime() - started), metaBook.Timeline.initBody = fdjtTime();
    }
    function sizeContent() {
        var started = metaBook.sized = fdjtTime(), content = metaBook.content, page = metaBook.page, body = document.body, view_height = fdjtDOM.viewHeight(), view_width = fdjtDOM.viewWidth();
        content.style.left = page.style.left = "", content.style.right = page.style.right = "", 
        body.style.overflow = "hidden", metaBook.sizeCodexPage();
        var geom = getGeometry(page, page.offsetParent, !0), fakepage = fdjtDOM("DIV.codexpage.curpage");
        page.appendChild(fakepage);
        var fakepage_geom = getGeometry(fakepage, page, !0), inner_width = geom.inner_width, inner_height = geom.inner_height, page_margin = view_width - inner_width, glossmark_offset = Math.floor(page_margin / 2) + fakepage_geom.right_border;
        fdjtDOM.remove(fakepage), metaBook.CSS.pagerule ? (metaBook.CSS.pagerule.style.width = inner_width + "px", 
        metaBook.CSS.pagerule.style.height = inner_height + "px") : metaBook.CSS.pagerule = fdjtDOM.addCSSRule("div.codexpage", "width: " + inner_width + "px; " + "height: " + inner_height + "px;"), 
        metaBook.CSS.glossmark_rule ? metaBook.CSS.glossmark_rule.style.marginRight = -glossmark_offset + "px" : metaBook.CSS.glossmark_rule = fdjtDOM.addCSSRule("#CODEXPAGE .glossmark", "margin-right: " + -glossmark_offset + "px;");
        var shrinkrule = metaBook.CSS.shrinkrule;
        shrinkrule || (shrinkrule = fdjtDOM.addCSSRule("body.mbSHRINK #CODEXPAGE,body.mbPREVIEW #CODEXPAGE,body.mbSKIMMING #CODEXPAGE", ""), 
        metaBook.CSS.shrinkrule = shrinkrule);
        var sh = view_height - 150, vs = sh / geom.height;
        vs > 1 && (vs = 1), shrinkrule.style[fdjtDOM.transform] = "scale(" + vs + "," + vs + ") translateZ(0)", 
        document.body.style.overflow = "", Trace.startup > 1 && fdjtLog("Content sizing took %dms", fdjtTime() - started);
    }
    function initMargins() {
        var page_right = fdjtDOM("div.mbpagecontrol#MBPAGERIGHT"), page_left = fdjtDOM("div.mbpagecontrol#MBPAGELEFT"), controls = fdjtDOM("div#METABOOKPAGECONTROLS", page_left, page_right);
        page_left.setAttribute("data-tapsound", "METABOOKPAGEBACKWARDAUDIO"), page_right.setAttribute("data-tapsound", "METABOOKPAGEFORWARDAUDIO"), 
        fdjtDOM.prepend(document.body, controls), window.scrollTo(0, 0);
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, $ID = fdjt.ID, fdjtTime = fdjt.Time, fdjtString = fdjt.String, fdjtUI = fdjt.UI, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, getGeometry = fdjtDOM.getGeometry, getChildren = fdjtDOM.getChildren, getChild = fdjtDOM.getChild, toArray = fdjtDOM.toArray, isEmpty = fdjtString.isEmpty, hasText = fdjtDOM.hasText, mB = metaBook, Trace = metaBook.Trace, applyMetaClass = mB.applyMetaClass, note_counter = 1, fixStaticRefs = metaBook.fixStaticRefs;
    metaBook.initBody = initBody, metaBook.sizeContent = sizeContent;
}(), function() {
    "use strict";
    function publisherIndex(pubindex) {
        mB._publisher_index = pubindex, Timeline.metadata_done && indexReady();
    }
    function indexReady() {
        var pubindex = metaBook._publisher_index || window._pubtool_autoindex;
        return metaBook._publisher_index && (metaBook._publisher_index = !1), window._pubtool_autoindex && (window._pubtool_autoindex = !1), 
        Timeline.index_done ? void 0 : (Timeline.index_done = fdjtTime(), (Trace.startup > 1 || Trace.indexing) && pubindex && (pubindex._nkeys ? fdjtLog("Processing provided index of %d keys and %d refs", pubindex._nkeys, pubindex._nrefs) : fdjtLog("Processing provided index")), 
        mB.useIndexData(pubindex, metaBook.knodule, !1, indexingDone));
    }
    function indexingDone() {
        (Trace.indexing || Trace.startup > 1) && fdjtLog("Content indexing is completed"), 
        metaBook._started ? setupClouds() : metaBook.onsetup = setupClouds;
    }
    function setupClouds() {
        var tracelevel = Math.max(Trace.startup, Trace.clouds), addTag2Cloud = metaBook.addTag2Cloud, empty_cloud = metaBook.empty_cloud, gloss_cloud = metaBook.gloss_cloud, taglist = metaBook.taglist || $ID("METABOOKTAGLIST");
        taglist || (taglist = metaBook.taglist = fdjt.DOM("datalist#METABOOKTAGLIST"), document.body.appendChild(taglist));
        var searchlist = metaBook.searchlist || $ID("METABOOKSEARCHLIST");
        searchlist || (searchlist = metaBook.searchlist = fdjt.DOM("datalist#METABOOKSEARCHLIST"), 
        document.body.appendChild(searchlist));
        var knodeToOption = Knodule.knodeToOption;
        cloud_setup_start = fdjtTime(), metaBook.empty_query.results = [].concat(metaBook.glossdb.allrefs).concat(metaBook.docdb.allrefs);
        var searchtags = metaBook.searchtags = metaBook.empty_query.getCoTags(), empty_query = metaBook.empty_query, tagfreqs = empty_query.tagfreqs;
        tracelevel && fdjtLog("Setting up initial tag clouds for %d tags", searchtags.length), 
        addClass(document.body, "mbINDEXING"), fdjtDOM(empty_cloud.dom, fdjtDOM("div.cloudprogress", "Cloud Shaping in Progress")), 
        addClass(empty_cloud.dom, "working"), fdjtDOM(gloss_cloud.dom, fdjtDOM("div.cloudprogress", "Cloud Shaping in Progress")), 
        addClass(gloss_cloud.dom, "working"), fdjtAsync.slowmap(function(tag) {
            if (tag instanceof KNode) {
                var elt = addTag2Cloud(tag, empty_cloud, metaBook.knodule, tagfreqs, tagfreqs, !1);
                "§" !== tag._id[0] && (taglist.appendChild(knodeToOption(tag)), searchlist.appendChild(knodeToOption(tag)), 
                tag.weak || (addClass(elt, "cue"), addTag2Cloud(tag, gloss_cloud)));
            } else if ("string" == typeof tag && !isEmpty(tag)) {
                var option = fdjtDOM("OPTION", tag);
                option.value = tag, searchlist.appendChild(option);
            }
        }, searchtags, {
            watchfn: tagindex_progress,
            slice: 200,
            space: 20
        }).then(tagindex_done);
    }
    function tagindex_done(searchtags) {
        var eq = metaBook.empty_query, knodule = metaBook.knodule, empty_cloud = metaBook.empty_cloud, gloss_cloud = metaBook.gloss_cloud, searchlist = $ID("METABOOKSEARCHLIST"), knodeToOption = Knodule.knodeToOption, tracelevel = Math.max(Trace.startup, Trace.clouds);
        metaBook.knodule.alldterms.slice(0, 7).map(function(dterm) {
            var ref = knodule.ref(dterm), elts = empty_cloud.getByValue(ref);
            elts.map(function(elt) {
                addClass(elt, "cue");
            });
        }), tracelevel && fdjtLog("Done populating clouds with %d tags", searchtags.length), 
        dropClass(document.body, "mbINDEXING"), eq.cloud = empty_cloud, fdjtDOM.getChild(empty_cloud.dom, ".showall") || fdjtDOM.prepend(empty_cloud.dom, metaBook.UI.getShowAll(!0, empty_cloud.values.length)), 
        fdjtAsync.slowmap(function(string) {
            searchlist.appendChild(knodeToOption(string));
        }, metaBook.textindex.allterms, {
            slice: 100,
            space: 20
        }), metaBook.sortCloud(empty_cloud), metaBook.sortCloud(gloss_cloud), metaBook.sizeCloud(empty_cloud, metaBook.tagfreqs, []), 
        metaBook.sizeCloud(gloss_cloud, metaBook.tagfreqs, []);
    }
    function tagindex_progress(state, i, lim) {
        var tracelevel = Math.max(Trace.startup, Trace.clouds), pct = 100 * i / lim;
        "after" === state && (tracelevel > 1 && fdjtLog("Added %d (%d%% of %d tags) to clouds", i, Math.floor(pct), lim), 
        fdjtUI.ProgressBar.setProgress("METABOOKINDEXMESSAGE", pct), fdjtUI.ProgressBar.setMessage("METABOOKINDEXMESSAGE", fdjtString("Added %d tags (%d%% of %d) to clouds", i, Math.floor(pct), lim)));
    }
    function useIndexData(autoindex, knodule, baseweight, whendone) {
        function handleIndexEntry(tag) {
            var ids = autoindex[tag];
            ntags++;
            var occurrences = [], bar = tag.indexOf("|"), tagstart = tag.search(/[^*~]/), taghead = tag, tagterm = tag, knode = !1, weight = !1;
            if (bar > 0 ? (taghead = tag.slice(0, bar), tagterm = tag.slice(tagstart, bar)) : tagterm = taghead = tag.slice(tagstart), 
            knode = handle_weak || "~" !== tag[0] ? metaBook.knodule.handleSubjectEntry(tag) : metaBook.knodule.probe(taghead) || metaBook.knodule.probe(tagterm)) weight = knode.weight, 
            tagweights.set(knode, weight); else if (bar > 0) {
                var body = tag.slice(bar), field_at = body.search("|:weight=");
                if (field_at >= 0) {
                    var end = body.indexOf("|", field_at + 1);
                    weight = end >= 0 ? parseFloat(body.slice(field_at + 9, end)) : parseFloat(body.slice(field_at + 9)), 
                    tagweights.set(tagterm, weight);
                }
            }
            if (weight > maxweight && (maxweight = weight), minweight > weight && (minweight = weight), 
            !knode) {
                var prefix = 3 > tagterm.length ? tagterm : tagterm.slice(0, 3);
                allterms.push(tagterm), prefixes.hasOwnProperty(prefix) ? prefixes[prefix].push(tagterm) : prefixes[prefix] = [ tagterm ];
            }
            var i = 0, lim = ids.length;
            for (nitems += lim; lim > i; ) {
                var idinfo = ids[i++], frag = "string" == typeof idinfo ? idinfo : idinfo[0], info = metaBook.docinfo[frag];
                if (info) {
                    if ("string" != typeof idinfo) {
                        var terms, knodeterms = info.knodeterms, tagid = knode ? knode._qid || knode.getQID() : tagterm;
                        info.knodeterms ? (terms = knodeterms[tagid]) || (knodeterms[tagid] = terms = []) : (knodeterms = info.knodeterms = {}, 
                        knodeterms[tagid] = terms = []);
                        for (var j = 1, jlim = idinfo.length; jlim > j; ) terms.push(idinfo[j++]);
                    }
                    occurrences.push(info);
                } else metaBook.missing_nodes.push(frag);
            }
            addTags(occurrences, knode || taghead);
        }
        var ntags = 0, nitems = 0, handle_weak = !1, allterms = metaBook.allterms, prefixes = metaBook.prefixes, tagweights = metaBook.tagweights, maxweight = metaBook.tagmaxweight, minweight = metaBook.tagminweight, tracelevel = Math.max(Trace.startup, Trace.indexing), alltags = [];
        if (!autoindex) return whendone && whendone(), void 0;
        for (var tag in autoindex) "_" !== tag[0] && autoindex.hasOwnProperty(tag) && alltags.push(tag);
        1e3 > alltags.length && (handle_weak = !0), addClass(document.body, "mbINDEXING"), 
        fdjtAsync.slowmap(handleIndexEntry, alltags, {
            watchfn: alltags.length > 100 && tracelevel > 1 && indexProgress,
            slice: 200,
            space: 10
        }).then(function(state) {
            return fdjtLog("Book index links %d keys to %d refs", ntags, nitems), dropClass(document.body, "mbINDEXING"), 
            metaBook.tagmaxweight = maxweight, metaBook.tagminweight = minweight, whendone ? whendone() : state;
        });
    }
    function indexProgress(state, i, lim) {
        if ("suspend" === state) {
            var pct = 100 * i / lim;
            fdjtLog("Processed %d/%d (%d%%) of provided tags", i, lim, Math.floor(pct));
        }
    }
    function applyMultiTagSpans() {
        for (var tags = fdjtDOM.$(".metabooktags,.mbtags"), i = 0, lim = tags.length; lim > i; ) {
            var elt = tags[i++], target = metaBook.getTarget(elt), info = metaBook.docinfo[target.id], tagtext = fdjtDOM.textify(elt), tagsep = elt.getAttribute("tagsep") || ";", tagstrings = tagtext.split(tagsep);
            if (tagstrings.length) for (var j = 0, jlim = tagstrings.length; jlim > j; ) addTags(info, tagstrings[j++]);
        }
    }
    function applyTagSpans() {
        for (var tags = fdjtDOM.$(".metabooktag,.mbtag"), i = 0, lim = tags.length; lim > i; ) {
            var tagelt = tags[i++], target = metaBook.getTarget(tagelt), info = metaBook.docinfo[target.id], tagtext = fdjtDOM.textify(tagelt);
            addTags(info, tagtext);
        }
    }
    function applyAnchorTags() {
        var docinfo = metaBook.docinfo, anchors = document.getElementsByTagName("A");
        if (anchors) for (var i = 0, len = anchors.length; len > i; ) if ("tag" === anchors[i].rel) {
            for (var elt = anchors[i++], cxt = elt; cxt && !cxt.id; ) cxt = cxt.parentNode;
            if (!cxt) return;
            var href = elt.href, name = elt.name, tag = !1;
            if (name) {
                var def = elt.getAttribute("data-def") || elt.getAttribute("data-def"), title = elt.title;
                def ? "|" === def[0] ? tag += def : tag = tag + "|" + def : tag = title ? "|" === title[0] ? name + title : title.indexOf("|") > 0 ? name + "|" + title : name + "|~" + title : name;
            } else if (href) {
                var tagstart = href.search(/[^\/]+$/);
                tag = 0 > tagstart ? href : href.slice(tagstart);
            }
            if (tag) {
                var info = docinfo[cxt.id];
                addTags(info, tag);
            }
        } else i++;
    }
    function applyTagAttributes(docinfo, whendone) {
        function index_progress(state, i, lim) {
            if ("suspend" === state || "finishing" === state) {
                var pct = 100 * i / lim;
                tracelevel > 1 && fdjtLog("Processed %d/%d (%d%%) inline tags", i, lim, Math.floor(pct)), 
                fdjtUI.ProgressBar.setProgress("METABOOKINDEXMESSAGE", pct), fdjtUI.ProgressBar.setMessage("METABOOKINDEXMESSAGE", fdjtString("Assimilated %d (%d%% of %d) inline tags", i, Math.floor(pct), lim));
            }
        }
        function index_done() {
            (Trace.indexing > 1 && tohandle.length || tohandle.length > 24) && fdjtLog("Finished indexing tag attributes for %d nodes", tohandle.length), 
            whendone && whendone();
        }
        var tracelevel = Math.max(Trace.startup, Trace.clouds), tohandle = [], tagged = 0;
        (Trace.startup > 1 || Trace.indexing > 1) && fdjtLog("Applying inline tag attributes from content");
        for (var eltid in docinfo) {
            var info = docinfo[eltid];
            info.atags && (tagged++, tohandle.push(info));
        }
        (Trace.indexing && tohandle.length || Trace.indexing > 1 || Trace.startup > 1) && fdjtLog("Indexing tag attributes for %d nodes", tohandle.length), 
        fdjtAsync.slowmap(handle_inline_tags, tohandle, {
            watchfn: tohandle.length > 100 && index_progress,
            done: index_done,
            slice: 200,
            space: 5
        });
    }
    function handle_inline_tags(info) {
        if (info.atags && addTags(info, info.atags), info.sectag) {
            addTags(info, info.sectag, "tags", metaBook.knodule);
            var knode = metaBook.knodule.ref(info.sectag);
            metaBook.tagweights.set(knode, metaBook.docdb.find("head", info).length);
        }
    }
    function setupIndex(metadata) {
        (Trace.startup > 1 || Trace.indexing > 1) && fdjtLog("Finding and applying Technorati-style tags"), 
        applyAnchorTags(), (Trace.startup > 1 || Trace.indexing > 1) && fdjtLog("Finding and applying tag elements from body"), 
        applyTagSpans(), applyMultiTagSpans(), applyTagAttributes(metadata);
        var pubindex = metaBook._publisher_index || window._pubtool_autoindex;
        if (pubindex) indexReady(); else if ($ID("PUTBOOLAUTOINDEX")) {
            var elt = $ID("PUBTOOLAUTOINDEX");
            fdjtDOM.addListener(elt, "load", indexReady);
        } else {
            var indexref = getLink("PUBTOOL.bookindex");
            if (indexref) {
                var script_elt = document.createElement("SCRIPT");
                script_elt.setAttribute("src", indexref), script_elt.setAttribute("language", "javascript"), 
                script_elt.setAttribute("async", "async"), fdjtDOM.addListener(script_elt, "load", indexReady), 
                fdjtDOM.addListener(script_elt, "error", indexReady), document.body.appendChild(script_elt);
            } else "complete" === document.readyState ? indexReady() : addListener(window, "load", indexReady);
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, $ID = fdjt.ID, fdjtTime = fdjt.Time, fdjtString = fdjt.String, fdjtUI = fdjt.UI, fdjtAsync = fdjt.Async, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, getLink = fdjtDOM.getLink, isEmpty = fdjtString.isEmpty, addListener = fdjtDOM.addListener, mB = metaBook, Trace = mB.Trace, Timeline = mB.Timeline;
    metaBook.publisherIndex = publisherIndex, metaBook.indexReady = indexReady;
    var cloud_setup_start = !1, addTags = metaBook.addTags;
    metaBook.useIndexData = useIndexData, metaBook.applyTagAttributes = applyTagAttributes, 
    metaBook.setupIndex = setupIndex;
}(), function() {
    "use strict";
    function init_local() {
        setTarget = metaBook.setTarget, setConnected = metaBook.setConnected, setConfig = metaBook.setConfig;
    }
    function saveState(state, skiphist, force) {
        if (force || !state || !(metaBook.state === state || metaBook.state && metaBook.state.target === state.target && metaBook.state.location === state.location && metaBook.state.page === state.page)) {
            state || (state = metaBook.state), state.changed || (state.changed = fdjtTime.tick()), 
            state.refuri || (state.refuri = metaBook.refuri), state.docuri || (state.docuri = metaBook.docuri);
            var title = state.title, frag = state.target;
            if (!title && frag && metaBook.docinfo && metaBook.docinfo[frag] && (state.title = title = metaBook.docinfo[frag].title || metaBook.docinfo[frag].head.title), 
            Trace.state && fdjtLog("Setting state to %j", state), state.maxloc && state.location > state.maxloc ? state.maxloc = state.location : state.maxloc || (state.maxloc = state.location), 
            window && window.location && window.location.hash) {
                var hash = window.location.hash;
                "#" === hash[0] && (hash = hash.slice(1)), state.hash = hash;
            }
            Trace.state && fdjtLog("saveState skiphist=%o force=%o state=%j", skiphist, force, state), 
            metaBook.state = state;
            var statestring = JSON.stringify(state);
            saveLocal("mB(" + mB.docid + ").state", statestring), !syncing && metaBook.locsync && metaBook.user && (!metaBook.xstate || state.changed > metaBook.xstate.changed) && syncState(!0), 
            !skiphist && frag && window.history && window.history.pushState && setHistory(state, frag, title);
        }
    }
    function setHistory(state, hash, title) {
        if (Trace.state && (title ? fdjtLog("setHistory %s (%s) state=%j", hash, title, state) : fdjtLog("setHistory %s state=%j", hash, state)), 
        window.history && window.history.pushState) {
            hash || (hash = state.target), title || (title = state.title);
            var href = fdjtState.getURL();
            !title && hash && metaBook.docinfo && metaBook.docinfo[hash] && (state.title = title = metaBook.docinfo[hash].title || metaBook.docinfo[hash].head.title), 
            !hash && state.location && "number" == typeof state.location && (hash = "SBOOKLOC" + state.location), 
            Trace.state && fdjtLog("Pushing history %j %s (%s) '%s'", state, href, title), window.history.state && window.history.state.target === state.target && window.history.state.location === state.location || window.history.pushState(state, title, href + "#" + hash);
        }
    }
    function restoreState(state, reason, savehist) {
        Trace.state && fdjtLog("Restoring (%s) state %j", reason, state), state.location ? metaBook.GoTo(state.location, reason || "restoreState", state.target ? mbID(state.target) : !1, !1, !savehist) : state.page && metaBook.layout ? (metaBook.GoToPage(state.page, reason || "restoreState", !1, !savehist), 
        state.target && mbID(state.target) && setTarget(mbID(state.target))) : state.target && (metaBook.GoTo(state.target, reason || "restoreState", !0, !1, !savehist), 
        state.target && mbID(state.target) && setTarget(mbID(state.target))), state.refuri || (state.refuri = metaBook.refuri), 
        state.docuri || (state.docuri = metaBook.docuri), saveState(state);
    }
    function clearState() {
        metaBook.state = !1, clearLocal("mB(" + mB.docid + ").state"), metaBook.xstate = !1;
    }
    function resetState() {
        var state = metaBook.state;
        state.location && (state.maxloc = location), state.reset = !0;
        var statestring = JSON.stringify(state);
        saveLocal("mB(" + mB.docid + ").state", statestring), syncState(!0);
    }
    function syncState(force) {
        var mycopyid = mB.mycopyid || mB.readMyCopyId(), elapsed = last_sync ? fdjtTime.tick() - last_sync : 31536e4;
        if (!syncing && (force || metaBook.locsync) && metaBook.user) {
            if (sync_req) return fdjtLog("Skipping state sync because one is already in process"), 
            sync_wait && clearTimeout(sync_wait), setTimeout(force ? forceSyncState : syncState, 15e3), 
            void 0;
            if (!force && metaBook.sync_interval > elapsed) return Trace.state && fdjtLog("Skipping state sync because it's too soon"), 
            void 0;
            if (!force && metaBook.state && (!fdjtDOM.isHidden || document[fdjtDOM.isHidden]) && 5 * metaBook.sync_interval > elapsed) return Trace.state && fdjtLog("Skipping state sync because page is hidden"), 
            void 0;
            if (!force && metaBook.sync_min > elapsed) return sync_wait = setTimeout(force ? forceSyncState : syncState, metaBook.sync_min), 
            void 0;
            if (sync_wait && (clearTimeout(sync_wait), sync_wait = !1), (force || metaBook.locsync) && navigator.onLine) {
                var uri = metaBook.docuri, traced = Trace.state || Trace.network, state = metaBook.state, refuri = metaBook.target && metaBook.getRefURI(metaBook.target) || metaBook.refuri, sync_uri = "https://sync.bookhub.io/v1/sync?";
                sync_uri = mB.docref ? sync_uri + "DOC=" + encodeURIComponent(mB.docref) : sync_uri + "REFURI=" + encodeURIComponent(refuri), 
                mB.docuri !== refuri && (sync_uri = sync_uri + "&DOCURI=" + encodeURIComponent(metaBook.docuri)), 
                sync_uri = sync_uri + "&NOW=" + fdjtTime.tick(), metaBook.last_sync = last_sync = fdjtTime.tick(), 
                syncing = state, metaBook.user && (sync_uri = sync_uri + "&SYNCUSER=" + encodeURIComponent(metaBook.user._id)), 
                mycopyid && (sync_uri = sync_uri + "&MYCOPYID=" + encodeURIComponent(mycopyid)), 
                metaBook.deviceName && (sync_uri = sync_uri + "&DEVICE=" + encodeURIComponent(metaBook.deviceName)), 
                metaBook.ends_at && (sync_uri = sync_uri + "&LOCLEN=" + encodeURIComponent(metaBook.ends_at)), 
                state && (state.target && (sync_uri = sync_uri + "&TARGET=" + encodeURIComponent(state.target)), 
                (state.location || state.hasOwnProperty("location")) && (sync_uri = sync_uri + "&LOCATION=" + encodeURIComponent(state.location)), 
                state.changed && (sync_uri = sync_uri + "&CHANGED=" + encodeURIComponent(state.changed)), 
                state.reset && (sync_uri += "&RESET=true"));
                var req = new XMLHttpRequest();
                syncing = state, req.onreadystatechange = freshState, req.ontimeout = syncTimeout, 
                req.withCredentials = !0, req.timeout = metaBook.sync_timeout, traced && fdjtLog("syncState(call) %s", sync_uri);
                try {
                    req.open("GET", sync_uri, !0), req.send(), sync_req = req;
                } catch (ex) {
                    try {
                        fdjtLog.warn("Sync request %s returned status %d %j, pausing for %ds", uri, req.status, JSON.parse(req.responseText), metaBook.sync_pause);
                    } catch (err) {
                        fdjtLog.warn("Sync request %s returned status %d, pausing for %ds", uri, req.status, metaBook.sync_pause / 1e3);
                    }
                    metaBook.locsync = !1, setTimeout(startLocSync, metaBook.sync_pause);
                }
            }
        }
    }
    function forceSyncState() {
        syncState(!0);
    }
    function startLocSync() {
        metaBook.locsync = !0;
    }
    function syncTimeout(evt) {
        evt = evt || window.event, fdjtLog.warn("Sync request timed out, pausing for %ds", metaBook.sync_pause / 1e3), 
        metaBook.locsync = !1, setTimeout(startLocSync, metaBook.sync_pause);
    }
    function freshState(evt) {
        var req = fdjtUI.T(evt);
        sync_req = !1;
        var traced = Trace.state || Trace.network || Trace.startup && 1 > sync_count;
        if (4 === req.readyState) {
            if (req.status >= 200 && 300 > req.status) {
                var rtext = req.responseText;
                if (!rtext) return;
                var xstate = JSON.parse(rtext), tick = fdjtTime.tick();
                xstate.changed && (traced && fdjtLog("freshState %o %j\n	%j", evt, xstate, metaBook.state), 
                xstate.changed > tick + 300 ? fdjtLog.warn("Beware of oracles (future state date): %j %s", xstate, new Date(1e3 * xstate.changed)) : metaBook.state ? metaBook.state.changed > xstate.changed ? metaBook.xstate = xstate : prompted && prompted > xstate.changed || (document[fdjtDOM.isHidden] ? metaBook.freshstate = xstate : (metaBook.xstate = xstate, 
                prompted = fdjtTime.tick(), metaBook.resolveXState(xstate))) : (metaBook.xstate = xstate, 
                restoreState(xstate))), sync_count++;
            } else traced && fdjtLog("syncState(callback/error) %o %d %s", evt, req.status, req.responseText);
            navigator.onLine && setConnected(!0), syncing = !1;
        }
    }
    function forceSync() {
        metaBook.connected ? metaBook.update() : metaBook._onconnect ? metaBook._onconnect.push(mBUpdate) : metaBook._onconnect = [ mBUpdate ], 
        metaBook.syncstart ? syncState() : metaBook.syncLocation();
    }
    function mBUpdate() {
        metaBook.update();
    }
    function getLoc(x) {
        var info = metaBook.getLocInfo(x);
        return info && info.start;
    }
    function initLocation() {
        var state = metaBook.state;
        if (state && (state.location || state.target)) ; else {
            var target = $ID("METABOOKSTART") || fdjt.$1(".metabookstart") || $ID("SBOOKSTART") || fdjt.$1(".sbookstart") || $ID("SBOOKTITLEPAGE");
            state = target ? {
                location: getLoc(target),
                changed: 978307200
            } : {
                location: 1,
                changed: 978307200
            };
        }
        var goto_arg = state.location === void 0 ? state.target : state.location;
        mB.GoTo(goto_arg, "initLocation", !1, !1, !1), mB.saveState(state, !0, !0);
    }
    function resolveXState(xstate) {
        var state = metaBook.state;
        if (metaBook.sync_interval) {
            if (metaBook.statedialog) return Trace.state && fdjtLog("resolveXState dialog exists: %o", metaBook.statedialog), 
            void 0;
            if (Trace.state && fdjtLog("resolveXState state=%j, xstate=%j", state, xstate), 
            !state) return metaBook.restoreState(xstate), void 0;
            if (xstate.maxloc > state.maxloc) {
                state.maxloc = xstate.maxloc;
                var statestring = JSON.stringify(state);
                saveLocal("mB(" + mB.docid + ").state", statestring);
            }
            if (!(state.changed >= xstate.changed)) {
                var now = fdjtTime.tick();
                if (!(3e3 > now - state.changed)) {
                    Trace.state && fdjtLog("Resolving local state %j with remote state %j", state, xstate);
                    var msg1 = "Start at", choices = [], latest = xstate.location, farthest = xstate.maxloc, loclen = xstate.loclen, prefer_current = state.location > 17 && 86400 > now - state.changed, prefer_latest = 80 > farthest - loclen;
                    farthest > state.location && choices.push({
                        label: "farthest @" + loc2pct(farthest, loclen),
                        title: "your farthest location on any device/app",
                        isdefault: !prefer_latest && !prefer_current,
                        handler: function() {
                            metaBook.GoTo(xstate.maxloc, "sync"), state = metaBook.state, state.changed = fdjtTime.tick(), 
                            metaBook.saveState(state, !0, !0), metaBook.hideCover();
                        }
                    }), latest !== state.location && latest !== farthest && choices.push({
                        label: "latest @" + loc2pct(latest, loclen),
                        title: "the most recent location on any device/app",
                        isdefault: prefer_latest && !prefer_current,
                        handler: function() {
                            metaBook.restoreState(xstate), state = metaBook.state, state.changed = fdjtTime.tick(), 
                            metaBook.saveState(state, !0, !0), metaBook.hideCover();
                        }
                    }), choices.length && state.location > 17 && choices.push({
                        label: "current @" + (42 > state.location ? "start" : loc2pct(state.location, loclen)),
                        title: "the most recent location on this device",
                        isdefault: prefer_current,
                        handler: function() {
                            state.changed = fdjtTime.tick(), metaBook.saveState(state, !0, !0), metaBook.hideCover();
                        }
                    }), choices.length && choices.push({
                        label: "stop syncing",
                        title: "stop syncing this book on this device",
                        handler: function() {
                            setConfig("locsync", !1, !0);
                        }
                    }), Trace.state && fdjtLog("resolveXState choices=%j", choices), choices.length && (metaBook.statedialog = fdjtUI.choose({
                        choices: choices,
                        cancel: !0,
                        timeout: 7,
                        onclose: function() {
                            metaBook.statedialog = !1;
                        },
                        spec: "div.fdjtdialog.resolvestate#METABOOKRESOLVESTATE"
                    }, fdjtDOM("div", msg1)));
                }
            }
        }
    }
    function clearStateDialog() {
        metaBook.statedialog && (fdjt.Dialog.close(metaBook.statedialog), metaBook.statedialog = !1);
    }
    var setTarget, setConnected, setConfig, fdjtDOM = fdjt.DOM, fdjtState = fdjt.State, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, fdjtTime = fdjt.Time, $ID = fdjt.ID, mB = metaBook, mbID = mB.ID, saveLocal = mB.saveLocal, readLocal = mB.readLocal, clearLocal = mB.clearLocal, Trace = metaBook.Trace, loc2pct = metaBook.location2pct, sync_count = 0;
    metaBook.inits.local.push(init_local);
    var syncing = !1;
    metaBook.initState = function() {
        var state = readLocal("mB(" + mB.docid + ").state", !0), hash = metaBook.inithash;
        hash ? "#" === hash[0] && (hash = hash.slice(1)) : hash = !1;
        var elt = hash && mbID(hash);
        elt && (!state || state.hash && state.hash !== hash || !state.hash && state.target && state.target !== hash) && (state || (state = {}), 
        state.refuri = mB.refuri, state.docuri = mB.docuri, state.target = hash, state.location = !1, 
        state.changed = fdjtTime.tick(), saveLocal("mB(" + mB.docid + ").state", state, !0)), 
        state && (metaBook.state = state);
    }, metaBook.saveState = saveState, metaBook.setHistory = setHistory, metaBook.restoreState = restoreState, 
    metaBook.clearState = clearState, metaBook.resetState = resetState;
    var sync_req = !1, sync_wait = !1, last_sync = !1;
    metaBook.syncState = syncState;
    var prompted = !1, last_hidden = !1;
    metaBook.visibilityChange = function() {
        if (document[fdjtDOM.isHidden]) last_hidden = fdjtTime.tick(); else if (last_hidden && 300 > fdjtTime.tick() - last_hidden) ; else if (navigator.onLine) last_hidden = !1, 
        syncState(!0); else if (metaBook.freshstate) {
            var freshstate = metaBook.freshstate;
            last_hidden = !1, metaBook.freshstate = !1, metaBook.xstate = freshstate, prompted = fdjtTime.tick(), 
            metaBook.resolveXState(freshstate);
        }
    }, metaBook.forceSync = forceSync, metaBook.initLocation = initLocation, metaBook.resolveXState = resolveXState, 
    metaBook.clearStateDialog = clearStateDialog;
}(), function() {
    "use strict";
    function setMyCopyId(string) {
        if (string) {
            if (mB.mycopyid === string) return string;
            var doc, parts = string.split("."), payload = !1;
            try {
                payload = JSON.parse(atob(parts[1]));
            } catch (ex) {
                payload = !1;
            }
            if (!payload) return fdjtLog.warn("Bad mycopyid JWT %s", string), !1;
            if ((doc = payload.doc) && (doc = doc.replace(/^:/, "").toLowerCase(), doc !== mB.docid)) return fdjtLog.warn("mycopyid for wrong title %s; doc=%s, payload=%j", doc, mB.docid, payload), 
            !1;
            var now = new Date(), expstring = payload.exp, expires = expstring && new Date(expstring);
            if (now > expires) return fdjtLog.warn("Expired (%s) mycopyid %j", expires, payload), 
            !1;
            (Trace.startup > 1 || Trace.creds) && fdjtLog("Setting myCopyID to %s payload=%j", string, payload), 
            mB.mycopyid = string, mB.mycopyid_payload = payload, mB.mycopyid_expires = expires, 
            mB.saveLocal("mB(" + mB.refuri + ").mycopyid", string), mB.saveLocal("mB(" + mB.docid + ").mycopyid", string);
            var waiting = need_mycopyid;
            need_mycopyid = [];
            for (var i = 0, lim = waiting.length; lim > i; ) waiting[i++](string);
            return string;
        }
    }
    function myCopyMessage(evt) {
        var origin = evt.origin, data = evt.data;
        if ((Trace.messages || Trace.creds) && fdjtLog("Got a message from %s with payload %s", origin, data), 
        0 !== origin.search(good_origin)) return fdjtLog.warn("Rejecting insecure message from %s: %s", origin, evt.data), 
        void 0;
        if (0 === data.search(/^mycopyid=/)) {
            var mycopyid = data.slice(9);
            return setMyCopyId(mycopyid), void 0;
        }
    }
    function getMyCopyId() {
        var now = new Date();
        return mB.mycopyid && (!mB.mycopyid_expires || now > mB.mycopyid_expires) ? Promise.resolve(mB.mycopyid) : fetchMyCopyId();
    }
    function readMyCopyId() {
        var mycopyid = fdjtState.getQuery("MYCOPYID") || fdjtState.getCookie("MYCOPYID") || mB.docid && getSession("mycopyid(" + mB.docid + ")") || mB.refuri && getSession("mycopyid(" + mB.refuri + ")") || mB.docid && getSession("mB(" + mB.docid + ").mycopyid") || mB.refuri && getSession("mB(" + mB.refuri + ").mycopyid") || mB.docid && getLocal("mycopyid(" + mB.docid + ")") || mB.refuri && getLocal("mycopyid(" + mB.refuri + ")") || mB.docid && getLocal("mB(" + mB.docid + ").mycopyid") || mB.refuri && getLocal("mB(" + mB.refuri + ").mycopyid");
        return mycopyid && (Trace.startup || Trace.creds) && fdjtLog("Read local myCopyID %s", mycopyid), 
        mycopyid ? mB.setMyCopyId(mycopyid) : !1;
    }
    function fetchMyCopyId() {
        function fetching_mycopyid(resolve, reject) {
            need_mycopyid.push(resolve), getting_mycopyid || (getting_mycopyid = fdjtTime(), 
            fdjtAjax.fetchText("https://auth.bookhub.io/getmycopyid?DOC=" + mB.docref).then(function(mycopyid, alt) {
                return mycopyid === void 0 ? (Trace.creds && fdjtLog("Failed call to fetch remote creds"), 
                reject(alt)) : (getting_mycopyid = !1, Trace.creds && fdjtLog("Fetched myCopyId from network"), 
                setMyCopyId(mycopyid), void 0);
            }));
        }
        return new Promise(fetching_mycopyid);
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtTime = fdjt.Time, fdjtAjax = fdjt.Ajax, fdjtState = fdjt.State, mB = metaBook, Trace = mB.Trace, getSession = fdjtState.getSession, getLocal = fdjtState.getLocal, need_mycopyid = [];
    metaBook.setMyCopyId = setMyCopyId;
    var good_origin = /https:\/\/[^\/]+.(bookhub\.io|metabooks\.net)/;
    fdjtDOM.addListener(window, "message", myCopyMessage);
    var getting_mycopyid = !1;
    metaBook.getMyCopyId = getMyCopyId, metaBook.readMyCopyId = readMyCopyId;
}(), function() {
    "use strict";
    function sourceref(arg) {
        return arg instanceof Ref ? arg : "string" == typeof arg ? mB.sourcedb.ref(arg) : !1;
    }
    function setUser(userinfo, outlets, layers, sync) {
        var started = fdjtTime(), root = document.documentElement || document.body;
        if (Trace.startup > 1 && fdjtLog("Setting up user %s (%s)", userinfo._id, userinfo.name || userinfo.email), 
        userinfo && (fdjtDOM.dropClass(root, "_NOUSER"), fdjtDOM.addClass(root, "_USER")), 
        metaBook.user && userinfo._id !== metaBook.user._id) throw {
            error: "Can't change user"
        };
        var cursync = metaBook.sync;
        if (cursync && cursync > sync && fdjtLog.warn("Cached user information is newer (%o) than loaded (%o)", cursync, sync), 
        navigator.onLine && getLocal("mB(" + mB.docid + ").queued") && metaBook.writeQueuedGlosses(), 
        metaBook.user = metaBook.sourcedb.Import(userinfo, !1, RefDB.REFLOAD | RefDB.REFSTRINGS | RefDB.REFINDEX), 
        outlets && (metaBook.outlets = outlets.map(sourceref)), layers && (metaBook.layers = layers.map(sourceref)), 
        metaBook.user.save(), saveLocal("mB.user", metaBook.user._id), saveLocal(metaBook.user._id, metaBook.user.Export(), !0), 
        metaBook.locsync && metaBook.setConfig("locsync", !0), metaBook.saveProps(), Trace.startup) {
            var now = fdjtTime();
            fdjtLog("setUser %s (%s) done in %dms", userinfo._id, userinfo.name || userinfo.email, now - started);
        }
        return metaBook._user_setup = fdjtTime(), metaBook.cacheglosses && metaBook.setCacheGlosses(!0), 
        metaBook._ui_setup && setupUI4User(), metaBook.user;
    }
    function setNodeID(nodeid) {
        metaBook.nodeid || (metaBook.nodeid = nodeid, nodeid && metaBook.persist && setLocal("mB(" + mB.docid + ").nodeid", nodeid, !0));
    }
    function setupUI4User() {
        if (!metaBook._user_ui_setup) {
            var lim, i = 0, root = document.documentElement || document.body;
            Trace.startup > 1 && fdjtLog("Starting UI setup for user");
            var startui = fdjtTime();
            if (!metaBook.user) return fdjtDOM.addClass(root, "_NOUSER"), void 0;
            fdjtDOM.addClass(root, "_NOUSER"), fdjtDOM.dropClass(root, "_NOUSER");
            var username = metaBook.user.name || metaBook.user.handle || metaBook.user.email;
            if (username) {
                $ID("METABOOKUSERNAME") && ($ID("METABOOKUSERNAME").innerHTML = username), $ID("CODEXUSERNAME") && ($ID("CODEXUSERNAME").innerHTML = username);
                var names = document.getElementsByName("METABOOKUSERNAME");
                if (names && names.length) for (i = 0, lim = names.length; lim > i; ) names[i++].innerHTML = username;
                if (names = document.getElementsByName("CODEXUSERNAME"), names && names.length) for (i = 0, 
                lim = names.length; lim > i; ) names[i++].innerHTML = username;
                if (names = fdjtDOM.$(".metabookusername"), names && names.length) for (i = 0, lim = names.length; lim > i; ) names[i++].innerHTML = username;
                if (names = fdjtDOM.$(".codexusername"), names && names.length) for (i = 0, lim = names.length; lim > i; ) names[i++].innerHTML = username;
            }
            $ID("SBOOKMARKUSER") && ($ID("SBOOKMARKUSER").value = metaBook.user._id);
            var ss = metaBook.stylesheet, form = $ID("METABOOKADDGLOSSPROTOTYPE");
            metaBook.user.fbid && ss.insertRule("#METABOOKHUD span.facebook_share { display: inline;}", ss.cssRules.length), 
            metaBook.user.twitterid && ss.insertRule("#METABOOKHUD span.twitter_share { display: inline;}", ss.cssRules.length), 
            metaBook.user.linkedinid && ss.insertRule("#METABOOKHUD span.linkedin_share { display: inline;}", ss.cssRules.length), 
            metaBook.user.googleid && ss.insertRule("#METABOOKHUD span.google_share { display: inline;}", ss.cssRules.length);
            var maker = fdjtDOM.getInput(form, "MAKER");
            maker && (maker.value = metaBook.user._id);
            var pic = metaBook.user._pic || metaBook.user.pic || metaBook.user.fbid && "https://graph.facebook.com/" + metaBook.user.fbid + "/picture?type=square";
            if (pic) {
                $ID("SBOOKMARKIMAGE") && ($ID("SBOOKMARKIMAGE").src = pic), $ID("METABOOKUSERPIC") && ($ID("METABOOKUSERPIC").src = pic);
                var byname = document.getElementsByName("METABOOKUSERPIC");
                if (byname) for (i = 0, lim = byname.length; lim > i; ) byname[i++].src = pic;
            }
            var idlinks = document.getElementsByName("IDLINK");
            if (idlinks) for (i = 0, lim = idlinks.length; lim > i; ) {
                var idlink = idlinks[i++];
                idlink.target = "_blank", idlink.title = "click to edit your personal information", 
                idlink.href = "https://my.bookhub.io/profile";
            }
            if (metaBook.user.friends) {
                var friends = metaBook.user.friends, sourcedb = metaBook.sourcedb;
                for (i = 0, lim = friends.length; lim > i; ) {
                    var friend = RefDB.resolve(friends[i++], sourcedb);
                    metaBook.addTag2Cloud(friend, metaBook.gloss_cloud), metaBook.addTag2Cloud(friend, metaBook.share_cloud);
                }
            }
            if (metaBook.outlets && metaBook.addOutlets2UI(metaBook.outlets), Trace.startup) {
                var now = fdjtTime();
                fdjtLog("Setup UI for %s (%s) in %dms", metaBook.user._id, metaBook.user.name || metaBook.user.email, now - startui);
            }
            metaBook._user_ui_setup = !0;
        }
    }
    function loginUser(info) {
        metaBook.user = metaBook.sourcedb.Import(info, !1, RefDB.REFLOAD | RefDB.REFSTRINGS | RefDB.REFINDEX), 
        setupUI4User(), metaBook._user_setup = !1;
    }
    function userSetup() {
        var sync = metaBook.sync = getLocal("mB(" + mB.docid + ").sync", !0) || 0, started = fdjtTime(), loadinfo = !1, userinfo = !1;
        return metaBook.sync && !metaBook.persist && metaBook.clearOffline(), metaBook.nologin || metaBook.persist && getLocal("mB.user") && (initUserOffline(), 
        Trace.storage && fdjtLog("Local info for %o (%s) from %o", metaBook.user._id, metaBook.user.name, metaBook.sync), 
        metaBook.user && metaBook.sync && metaBook.cacheglosses && window._metabook_loadinfo && (window._metabook_loadinfo = !1)), 
        metaBook.nologin || (window._metabook_loadinfo && window._metabook_loadinfo.userinfo ? (loadinfo = window._metabook_loadinfo, 
        userinfo = loadinfo.userinfo, window._metabook_loadinfo = !1, Trace.storage && fdjtLog("Have window._metabook_loadinfo for %o (%s) dated %o: %j", userinfo._id, userinfo.name || userinfo.email, loadinfo.sync, userinfo), 
        setUser(userinfo, loadinfo.outlets, loadinfo.layers, loadinfo.sync), loadinfo.nodeid && setNodeID(loadinfo.nodeid)) : (metaBook.userinfo || window._userinfo) && (userinfo = metaBook.userinfo || window._userinfo, 
        (Trace.storage || Trace.startup) && fdjtLog("Have %s for %o (%s) dated %o: %j", metaBook.userinfo ? "metaBook.userinfo" : "window._userinfo", userinfo._id, userinfo.name || userinfo.email, userinfo.sync || userinfo.modified, userinfo), 
        setUser(userinfo, userinfo.outlets, userinfo.layers, userinfo.sync || userinfo.modified))), 
        Trace.startup > 1 && fdjtLog("userSetup done in %dms", fdjtTime() - started), !metaBook.nologin && metaBook.refuri ? window.navigator.onLine ? (metaBook.user && sync ? fdjtLog("Requesting additional glosses (> %s (%d)) on %s from %s for %s", fdjtTime.timeString(metaBook.sync), metaBook.sync, metaBook.refuri, metaBook.server, metaBook.user._id, metaBook.user.name) : metaBook.user ? fdjtLog("Requesting all glosses on %s from %s for %s (%s)", metaBook.refuri, metaBook.server, metaBook.user._id, metaBook.user.name) : fdjtLog("No user, requesting user info and glosses from %s", metaBook.server), 
        metaBook.updateInfo(), void 0) : void 0 : void 0;
    }
    function initUserOffline() {
        var user = getLocal("mB.user"), sync = metaBook.sync;
        if (user) {
            var nodeid = getLocal("mB(" + mB.docid + ").nodeid", !0), userinfo = user && getLocal(user, !0);
            Trace.storage && fdjtLog("initOffline user=%s sync=%s nodeid=%s info=%j", user, sync, nodeid, userinfo), 
            Trace.startup > 1 && fdjtLog("initOffline userinfo=%j", userinfo);
            var outlets = metaBook.outlets = (getLocal("mB(" + mB.docid + ").outlets", !0) || []).map(sourceref), layers = metaBook.layers = (getLocal("mB(" + mB.docid + ").layers", !0) || []).map(sourceref);
            userinfo && setUser(userinfo, outlets, layers, sync), nodeid && setNodeID(nodeid);
        }
    }
    function addOutlets2UI(outlet) {
        function init() {
            outlet._inui = completion, completion.id = "mbOUTLET" + outlet.humid, completion.setAttribute("data-value", outlet._id), 
            completion.setAttribute("data-key", outlet.name), completion.innerHTML = outlet.name, 
            outlet.description && outlet.nick ? completion.title = outlet.name + ": " + outlet.description : outlet.description ? completion.title = outlet.description : outlet.nick && (completion.title = outlet.name), 
            fdjtDOM("#METABOOKSHARECLOUD", completion, " "), metaBook.share_cloud.addCompletion(completion);
        }
        if ("string" == typeof outlet && (outlet = metaBook.sourcedb.ref(outlet)), outlet) if (outlet instanceof Array) for (var outlets = outlet, i = 0, lim = outlets.length; lim > i; ) addOutlets2UI(outlets[i++]); else if (outlet instanceof Ref && !outlet._inui) {
            var completion = fdjtDOM("span.completion.cue.source", outlet._id);
            outlet.onLoad(init, "addoutlet2cloud");
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtTime = fdjt.Time, $ID = fdjt.ID, RefDB = fdjt.RefDB, Ref = fdjt.Ref, fdjtState = fdjt.State, mB = metaBook, Trace = mB.Trace, getLocal = fdjtState.getLocal, setLocal = fdjtState.setLocal, saveLocal = mB.saveLocal;
    metaBook.setUser = setUser, metaBook.setNodeID = setNodeID, metaBook.setupUI4User = setupUI4User, 
    metaBook.loginUser = loginUser, metaBook.userSetup = userSetup, metaBook.initUserOffline = initUserOffline, 
    metaBook.addOutlets2UI = addOutlets2UI;
}(), function() {
    "use strict";
    function loadInfo(info) {
        if (metaBook.nouser) return metaBook.setConnected(!1), void 0;
        if (window._metabook_loadinfo !== info && metaBook.setConnected(!0), info.sticky && metaBook.setPersist(!0), 
        info.mycopyid ? setMyCopyId(info.mycopyid) : info.mycopy && setMyCopyId(info.mycopy), 
        metaBook.user) {
            if (info.wronguser) return metaBook.clearOffline(), window.location = window.location.href, 
            void 0;
            info.userinfo && metaBook.user && (metaBook.user.importValue(info.userinfo), metaBook.user.save(), 
            metaBook.setupUI4User());
        } else info.userinfo ? metaBook.setUser(info.userinfo, info.outlets, info.layers, info.sync) : (getLocal("mB(" + mB.docid + ").queued") && metaBook.glossdb.load(getLocal("mB(" + mB.docid + ").queued", !0)), 
        $ID("METABOOKCOVER").className = "bookcover", addClass(document.documentElement || document.body, "_NOUSER")), 
        info.nodeid && metaBook.setNodeID(info.nodeid);
        if (info.mycopyid && (metaBook.mycopyid && info.mycopyid !== metaBook.mycopyid && fdjtLog.warn("Mismatched mycopyids"), 
        info.mycopyid !== metaBook.mycopyid && (setMyCopyId(info.mycopyid), mB.iosAuthKludge && mB.iosAuthKludge())), 
        !metaBook.docinfo) return metaBook.scandone = function() {
            loadInfo(info);
        }, void 0;
        if (!info.loaded) {
            if (window._metabook_loadinfo && window._metabook_loadinfo !== info) return window._metabook_newinfo = info, 
            void 0;
            metaBook.persist && metaBook.cacheglosses && info && info.userinfo && metaBook.user && info.userinfo._id !== metaBook.user._id && metaBook.clearOffline(), 
            info.loaded = fdjtTime(), metaBook.localglosses || !getLocal("mB(" + mB.docid + ").sync") && !getLocal("mB(" + mB.docid + ").queued") || initGlossesOffline(), 
            Trace.glosses && (fdjtLog("loadInfo for %d %sglosses and %d refs (sync=%d)", info.glosses ? info.glosses.length : 0, metaBook.sync ? "updated " : "", info.etc ? info.etc.length : 0, info.sync), 
            fdjtLog("loadInfo got %d sources, %d outlets, and %d layers", info.sources ? info.sources.length : 0, info.outlets ? info.outlets.length : 0, info.layers ? info.layers.length : 0)), 
            (info.glosses || info.etc) && initGlosses(info.glosses || [], info.etc || [], function() {
                infoLoaded(info);
            });
        }
    }
    function infoLoaded(info) {
        var keepdata = metaBook.cacheglosses;
        if (info.etc && gotInfo("etc", info.etc, keepdata), info.sources && gotInfo("sources", info.sources, keepdata), 
        info.outlets && gotInfo("outlets", info.outlets, keepdata), info.layers && gotInfo("layers", info.layers, keepdata), 
        info.mycopyid && setMyCopyId(info.mycopyid), metaBook.addOutlets2UI(info.outlets), 
        info.sync && (!metaBook.sync || info.sync >= metaBook.sync) && metaBook.setSync(info.sync), 
        metaBook.loaded = info.loaded = fdjtTime(), metaBook.slices.allglosses && metaBook.slices.allglosses.update(), 
        metaBook.whenloaded) {
            var whenloaded = metaBook.whenloaded;
            metaBook.whenloaded = !1, setTimeout(whenloaded, 10);
        }
        keepdata && (metaBook.glossdb.save(!0), metaBook.sourcedb.save(!0)), metaBook.glosshash && metaBook.showGloss(metaBook.glosshash) && (metaBook.glosshash = !1);
    }
    function updatedInfo(data, source, start) {
        var user = metaBook.user;
        (Trace.network || Trace.glosses && data.glosses && data.glosses.length || Trace.startup && (!user || metaBook.update_interval && !metaBook.ticktock && Trace.startup)) && (start ? fdjtLog("Response (%dms) from %s", fdjtTime() - start, source || metaBook.server) : fdjtLog("Response from %s", source || metaBook.server)), 
        updating = !1, loadInfo(data), !user && metaBook.user ? metaBook.userSetup() : metaBook._ui_setup && metaBook.setupUI4User();
    }
    function updateInfo(callback, jsonp) {
        function gotInfo(req) {
            updating = !1;
            var response = JSON.parse(req.responseText);
            response.glosses && response.glosses.length && fdjtLog("Received %d glosses from the server", response.glosses.length), 
            metaBook.updatedInfo(response, uri + (user ? "&SYNCUSER=" + user._id : "&JUSTUSER=yes"), start), 
            user ? !metaBook.ticktock && metaBook.update_interval && (metaBook.ticktock = setInterval(updateInfo, 1e3 * metaBook.update_interval)) : metaBook.user ? setTimeout(updateInfo, 50) : fdjtLog.warn("Couldn't determine user!");
        }
        function ajaxFailed(req) {
            if (4 === req.readyState && 500 > req.status) fdjtLog.warn("Ajax to %s callback failed, falling back to JSONP", uri), 
            updateInfoJSONP(uri + (user ? "" : "&JUSTUSER=yes"), jsonp), noajax = !0; else if (4 === req.readyState) {
                try {
                    fdjtLog.warn("Ajax to %s returned %d %j, taking a break", uri, req.status, JSON.parse(req.responseText));
                } catch (ex) {
                    fdjtLog.warn("Ajax to %s returned %d, taking a break", uri, req.status);
                }
                metaBook.ticktock && (clearInterval(metaBook.ticktock), metaBook.ticktock = !1), 
                setTimeout(updateInfo, metaBook.update_pause);
            }
        }
        var user = metaBook.user, start = fdjtTime(), uri = "https://" + metaBook.server + "/v1/loadinfo.js?", ajax_headers = metaBook.sync ? {} : !1;
        if (uri = mB.docref ? uri + "DOC=" + encodeURIComponent(mB.docref) : uri + "REFURI=" + encodeURIComponent(mB.refuri), 
        mB.sync && (ajax_headers["If-Modified-Since"] = "" + new Date(1e3 * metaBook.sync)), 
        !updating && navigator.onLine) {
            updating = !0;
            var lim, i = 0, glosses = getQuery("GLOSS", !0);
            for (i = 0, lim = glosses.length; lim > i; ) uri = uri + "&GLOSS=" + glosses[i++];
            for (glosses = getHash("GLOSS"), i = 0, lim = glosses.length; lim > i; ) uri = uri + "&GLOSS=" + glosses[i++];
            if (metaBook.mycopyid && (uri = uri + "&MYCOPYID=" + encodeURIComponent(metaBook.mycopyid)), 
            metaBook.sync && (uri = uri + "&SYNC=" + (metaBook.sync + 1)), user && (uri = uri + "&SYNCUSER=" + user._id), 
            !user && Trace.startup && fdjtLog("Requesting initial user info with %s using %s", noajax ? "JSONP" : "Ajax", uri), 
            noajax) return updateInfoJSONP(uri + (user ? "" : "&JUSTUSER=yes"), jsonp), void 0;
            try {
                fdjtAjax(gotInfo, uri + "&CALLBACK=return" + (user ? "" : "&JUSTUSER=yes"), [], ajaxFailed, ajax_headers, {
                    timeout: metaBook.update_timeout
                });
            } catch (ex) {
                fdjtLog.warn("Ajax call to %s failed, falling back to JSONP", uri), updateInfoJSONP(uri);
            }
        }
    }
    function updatedInfoJSONP(data) {
        var elt = $ID("METABOOKUPDATEINFO");
        metaBook.updatedInfo(data, elt && elt.src || "JSON");
    }
    function updateInfoJSONP(uri, callback) {
        if (navigator.onLine) {
            callback || (callback = "metaBook.updatedInfoJSONP");
            var elt = $ID("METABOOKUPDATEINFO");
            uri.indexOf("?") > 0 ? "&" !== uri[uri.length - 1] && (uri += "&") : uri += "?", 
            uri = uri + "CALLBACK=" + callback;
            var update_script = fdjtDOM("script#METABOOKUPDATEINFO");
            update_script.language = "javascript", update_script.type = "text/javascript", update_script.setAttribute("charset", "utf-8"), 
            update_script.setAttribute("async", "async"), metaBook.mycopyid ? update_script.setAttribute("crossorigin", "anonymous") : update_script.setAttribute("crossorigin", "use-credentials"), 
            update_script.src = uri, elt ? fdjtDOM.replace(elt, update_script) : document.body.appendChild(update_script);
        }
    }
    function gotItem(item, qids) {
        if ("string" == typeof item) {
            var load_ref = metaBook.sourcedb.ref(item);
            metaBook.persist && load_ref.load(), qids.push(load_ref._id);
        } else {
            var import_ref = metaBook.sourcedb.Import(item, !1, RefDB.REFLOAD | RefDB.REFSTRINGS | RefDB.REFINDEX);
            import_ref.save(), qids.push(import_ref._id);
        }
    }
    function saveItems(qids, name) {
        metaBook[name] = qids, metaBook.cacheglosses && saveLocal("mB(" + mB.docid + ")." + name, qids, !0);
    }
    function gotInfo(name, info, persist) {
        if (info) if (info instanceof Array) {
            var qids = [];
            if (7 > info.length) {
                for (var i = 0, lim = info.length; lim > i; ) gotItem(info[i++], qids);
                saveItems(qids, name);
            } else fdjtAsync.slowmap(function(item) {
                gotItem(item, qids);
            }, info, {
                done: function() {
                    saveItems(qids, name);
                }
            });
        } else {
            var ref = metaBook.sourcedb.Import(info, !1, RefDB.REFLOAD | RefDB.REFSTRINGS | RefDB.REFINDEX);
            persist && ref.save(), metaBook[name] = ref._id, persist && saveLocal("mB(" + mB.docid + ")." + name, ref._id, !0);
        }
    }
    function initGlosses(glosses, etc, callback) {
        if (callback === void 0 && (callback = !0), 0 !== glosses.length || 0 !== etc.length) {
            var msg = $ID("METABOOKNEWGLOSSES"), start = fdjtTime();
            msg && (msg.innerHTML = fdjtString("Assimilating %d new glosses", glosses.length), 
            addClass(msg, "running")), etc ? glosses.length && fdjtLog("Assimilating %d new glosses/%d sources...", glosses.length, etc.length) : glosses.length && Trace.glosses && fdjtLog("Assimilating %d new glosses...", glosses.length), 
            metaBook.sourcedb.Import(etc, !1, RefDB.REFLOAD | RefDB.REFSTRINGS | RefDB.REFINDEX, !0), 
            metaBook.glossdb.Import(glosses, {
                tags: Knodule.importTagSlot
            }, RefDB.REFLOAD | RefDB.REFSTRINGS | RefDB.REFINDEX, callback);
            for (var i = 0, lim = glosses.length, latest = metaBook.syncstamp || 0; lim > i; ) {
                var gloss = glosses[i++], tstamp = gloss.syncstamp || gloss.tstamp;
                tstamp > latest && (latest = tstamp);
            }
            metaBook.syncstamp = latest, glosses.length && fdjtLog("Assimilated %d new glosses in %dms...", glosses.length, fdjtTime() - start), 
            dropClass(msg, "running");
        }
    }
    function go_online() {
        return offline_update();
    }
    function offline_update() {
        metaBook.writeQueuedGlosses(), updateInfo();
    }
    function initGlossesOffline() {
        if (offline_init) return !1;
        offline_init = !0;
        var sync = metaBook.sync;
        if (sync) {
            (Trace.glosses || Trace.startup) && fdjtLog("Starting initializing glosses from local storage"), 
            metaBook.sourcedb.load(!0);
            var loading = metaBook.glossdb.load(!0);
            loading && loading.then(function() {
                (metaBook.glossdb.allrefs.length || metaBook.sourcedb.allrefs.length) && fdjtLog("Initialized %d glosses (%d sources) from local storage", metaBook.glossdb.allrefs.length, metaBook.sourcedb.allrefs.length);
            });
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtString = fdjt.String, fdjtTime = fdjt.Time, $ID = fdjt.ID, fdjtAsync = fdjt.Async, RefDB = fdjt.RefDB, fdjtState = fdjt.State, fdjtAjax = fdjt.Ajax, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, mB = metaBook, Trace = mB.Trace, getQuery = fdjtState.getQuery, getHash = fdjtState.getHash, getLocal = fdjtState.getLocal, saveLocal = metaBook.saveLocal, setMyCopyId = mB.setMyCopyId;
    metaBook.loadInfo = loadInfo;
    var updating = !1, noajax = !1;
    metaBook.updatedInfo = updatedInfo, metaBook.updateInfo = updateInfo, metaBook.updatedInfoJSONP = updatedInfoJSONP, 
    metaBook.initGlosses = initGlosses, metaBook.update = offline_update, fdjtDOM.addListener(window, "online", go_online), 
    metaBook.addConfig("glossupdate", function(name, value) {
        metaBook.update_interval = value, metaBook.ticktock && (clearInterval(metaBook.ticktock), 
        metaBook.ticktock = !1, value && (metaBook.ticktock = setInterval(updateInfo, 1e3 * value)));
    }), metaBook.addConfig("updatetimeout", function(name, value) {
        metaBook.update_timeout = value;
    }), metaBook.addConfig("updatepause", function(name, value) {
        metaBook.update_pause = value;
    });
    var offline_init = !1;
    metaBook.initGlossesOffline = initGlossesOffline;
}(), metaBook.Startup = function doStartup() {
    "use strict";
    function startupMessage() {
        Trace.startup && "number" == typeof Trace.startup && Trace.startup > 1 && fdjtLog.apply(null, arguments);
    }
    function dropSplashPage() {
        var splash = $ID("METABOOKSPLASHPAGE");
        splash && splash.parentNode && splash.parentNode.removeChild(splash);
    }
    function setupWait(tprop, fcn) {
        function waitingForSetup() {
            Timeline[tprop] && (clearInterval(waiting), waiting = !1, fcn());
        }
        var waiting = !1;
        Timeline[tprop] ? fcn() : waiting = setInterval(waitingForSetup, 50);
    }
    function run_inits(phase) {
        for (var inits = metaBook.inits[phase], i = 0, lim = inits.length; lim > i; ) inits[i++]();
    }
    function appInit() {
        var now = new Date(), started = fdjtTime();
        run_inits("local"), metaBook.appsource = getSourceRef(), fdjtLog("This is metaBook %s, built %s on %s, launched %s, from %s", mB.version, mB.buildtime, mB.buildhost, "" + now, mB.root || metaBook.appsource || "somewhere"), 
        fdjtLog("Copyright © 2010-2016 beingmeta, inc"), getLocal("mbtrace") && useTraceSettings([ getLocal("mbtrace") ]), 
        getSession("mbtrace") && useTraceSettings([ getSession("mbtrace") ]), getQuery("mbtrace") && useTraceSettings(getQuery("mbtrace", !0)), 
        (getLocal("mB.nologin") || getQuery("nologin")) && (metaBook.nologin = !0), fdjtState.getLocal("mB.devmode") && (addClass(document.documentElement, "_DEVMODE"), 
        metaBook.devmode = !0);
        try {
            document.domain = "bookhub.io";
        } catch (ex) {
            fdjtLog.warn("Error setting document.domain");
        }
        metaBook.devinfo = fdjtState.versionInfo();
        var docid = fdjtState.getCookie("MB:DOCID", !1), refuri = fdjtState.getCookie("MB:REFURI", !1);
        docid && (metaBook.docid = docid), refuri && (metaBook.refuri = refuri, mB.createDatabases(refuri));
        var done = Timeline.app_init_done = app_init_done = fdjtTime();
        Trace.startup > 1 && fdjtLog("appInit done in %dms", done - started);
    }
    function syncStartup() {
        if (app_init_done || appInit(), fdjtLog.console = "METABOOKCONSOLELOG", fdjtLog.consoletoo = !0, 
        run_inits("app"), metaBook._setup_started || (metaBook._setup_started = new Date()), 
        $ID("METABOOKBODY") && (metaBook.body = $ID("METABOOKBODY")), readBookSettings(), 
        fdjtLog("Book %s (%s) %s (%s%s)", mB.docref || "@??", mB.bookbuild || "", mB.refuri, mB.sourceid, mB.sourcetime ? ": " + ("" + mB.sourcetime) : ""), 
        mB.initDB(), mB.initConfig(), mB.bookConfig(), readEnvSettings(), mB.readMyCopyId(), 
        getLocal("mB.user") && (metaBook.setPersist(!0), metaBook.userSetup()), metaBook.initState(), 
        metaBook.syncState(), metaBook.user || window._metabook_loadinfo || metaBook.userinfo || window._userinfo || getLocal("mB.user") || (Trace.startup && fdjtLog("No local user info, requesting from bookhub server %s", mB.server), 
        metaBook.updateInfo()), fdjt.Init(), setupBook(), setupDevice(), setupApp(), metaBook._ui_setup = fdjtTime(), 
        showMessage(), metaBook._user_setup && metaBook.setupUI4User(), metaBook.setConfig(metaBook.getConfig()), 
        Trace.startup > 1 && fdjtLog("Initializing markup converter"), Timeline.sync_startup = new Date(), 
        metaBook.onsyncstartup) {
            var delayed = metaBook.onsyncstartup;
            if (delete metaBook.onsyncstartup, Array.isArray(delayed)) for (var i = 0, lim = delayed.length; lim > i; ) delayed[i](), 
            i++; else delayed();
        }
        Trace.startup > 1 && fdjtLog("Done with sync startup");
    }
    function initMarkdown() {
        function md2DOM(mdstring, inline) {
            var div = fdjtDOM("div"), root = div, frag = document.createDocumentFragment();
            div.innerHTML = markdown_converter.makeHtml(mdstring);
            var children = root.childNodes, nodes = [];
            inline && 1 === children.length && 1 === children[0].nodeType && "P" === children[0].tagName && (root = children[0], 
            children = root.childNodes);
            for (var i = 0, lim = children.length; lim > i; ) nodes.push(children[i++]);
            for (i = 0; lim > i; ) frag.appendChild(nodes[i++]);
            return frag;
        }
        var markdown_converter = new Markdown.Converter();
        metaBook.markdown_converter = markdown_converter, metaBook.md2HTML = function(mdstring) {
            return markdown_converter.makeHtml(mdstring);
        }, metaBook.md2DOM = md2DOM;
    }
    function getSourceRef() {
        for (var scripts = fdjtDOM.$("SCRIPT"), i = 0, len = scripts.length; len > i; ) {
            var elt = scripts[i++];
            if (elt.src && "string" == typeof elt.src && elt.src.search(/metabook.js(#|\?|$)/) >= 0) return elt.src;
        }
        return !1;
    }
    function showMessage() {
        var message = fdjt.State.getCookie("APPMESSAGE");
        message && fdjt.UI.alertFor(10, message), fdjt.State.clearCookie("APPMESSAGE", "/", "bookhub.io");
    }
    function readEnvSettings() {
        fdjtDOM.addAppSchema("METABOOK", "http://metabook.bookhub.io/"), fdjtDOM.addAppSchema("BOOKHUB", "http://bookhub.io/"), 
        fdjtDOM.addAppSchema("PUBTOOL", "http://pubtool.bookhub.io/"), fdjtDOM.addAppSchema("DC", "http://purl.org/dc/elements/1.1/"), 
        fdjtDOM.addAppSchema("DCTERMS", "http://purl.org/dc/terms/"), fdjtDOM.addAppSchema("OLIB", "http://openlibrary.org/"), 
        fdjtDOM.addAppSchema("TOC", "http://beingmeta.com/TOC/"), fdjtDOM.addAppSchema("INDEX", "http://beingmeta.com/INDEX/"), 
        fdjtDOM.addAppSchema("BM", "http://beingmeta.com/"), "http://static.beingmeta.com/" === metaBook.root && "https:" === window.location.protocol && (metaBook.root = https_root);
        var glosshost = getMeta("BOOKHUB.server") || getMeta("GLOSSDB");
        metaBook.server = glosshost ? glosshost : fdjtState.getCookie("METABOOKSERVER") ? fdjtState.getCookie("METABOOKSERVER") : fdjtState.getCookie("GLOSSDB") ? fdjtState.getCookie("GLOSSDB") : lookupServer(document.domain), 
        metaBook.server || (metaBook.server = metaBook.default_server), updateServerInfo(metaBook.server), 
        getScanSettings();
    }
    function setupApp() {
        var body = document.body, started = fdjtTime();
        Trace.startup > 2 && fdjtLog("Starting app setup");
        var style = fdjtDOM("STYLE");
        if (fdjtDOM(document.head, style), metaBook.stylesheet = style.sheet, metaBook.initHUD(), 
        metaBook.setupCover(), setupBookInfo(), setupZoom(), setupMedia(), metaBook.initSettings(), 
        metaBook.refuri) {
            var refuris = document.getElementsByName("REFURI");
            if (refuris) for (var j = 0, len = refuris.length; len > j; ) "fillin" === refuris[j].value ? refuris[j++].value = metaBook.refuri : j++;
        }
        metaBook.addConfig("cacheglosses", function(name, value) {
            metaBook.setCacheGlosses(value), fdjt.Async(function() {
                metaBook.updateSettings(name, value);
            });
        }), imageSetup(), body.style["pointer-events"] !== void 0 && (metaBook.demo || fdjtState.getLocal("mB.demo") || fdjtState.getCookie("crosshair") || getQuery("crosshair")) && fdjtUI.Reticle.setup(), 
        Trace.startup > 1 && (fdjtLog("App setup took %dms", fdjtTime() - started), fdjtLog("Body: class='%s'", document.body.className));
    }
    function goodString(s) {
        return "string" != typeof s || isEmpty(s) ? !1 : s;
    }
    function imageSetup() {
        var i, lim, started = fdjtTime(), uri = goodString(metaBook.coverimage) || goodString(metaBook.bookimage) || goodString(metaBook.bookcover) || goodString(metaBook.coverpage);
        if (uri) {
            var bookimages = fdjtDOM.$("img.metabookbookimage");
            for (i = 0, lim = bookimages.length; lim > i; ) bookimages[i].src ? i++ : bookimages[i++].src = uri;
        }
        var thumb_uri = "string" == typeof metaBook.thumbnail && metaBook.thumbnail;
        if (thumb_uri) {
            var thumbimages = fdjtDOM.$("img.metabookbookthumb");
            for (i = 0, lim = thumbimages.length; lim > i; ) thumbimages[i].src ? i++ : thumbimages[i++].src = thumb_uri;
        }
        var icon_uri = "string" == typeof metaBook.icon && metaBook.icon;
        if (icon_uri) {
            var iconimages = fdjtDOM.$("img.metabookbookicon");
            for (i = 0, lim = iconimages.length; lim > i; ) iconimages[i].src ? i++ : iconimages[i++].src = icon_uri;
        }
        Trace.startup > 1 && fdjtLog("Image setup took %dms", fdjtTime() - started);
    }
    function useTraceSettings(tracing) {
        "string" == typeof tracing && (tracing = tracing.split(";"));
        for (var i = 0, lim = tracing.length; lim > i; ) {
            var trace_spec = tracing[i++], colon = trace_spec.indexOf(":");
            if (0 > colon) Trace[trace_spec] = "number" == typeof Trace[trace_spec] ? 1 : !0; else {
                var trace_name = trace_spec.substr(0, colon), trace_val = trace_spec.substr(colon + 1);
                Trace[trace_name] = "number" == typeof Trace[trace_name] ? parseInt(trace_val, 10) : trace_val;
            }
        }
    }
    function metaBookStartup() {
        metaBook._started || (_head_ready = Timeline.head_ready = fdjtTime(), _body_ready = Timeline.body_ready = fdjtTime(), 
        processHead());
    }
    function processHead() {
        if (!_head_processed && !_head_processing && _head_ready) {
            if (metaBook._starting = _head_processing = fdjtTime(), ("null" === location.hash || "#null" === location.hash) && (location.hash = ""), 
            location.hash && "#" !== location.hash) {
                var hash = location.hash;
                "#" === hash[0] && (hash = hash.slice(1)), glosshash_pat.exec(location.hash) ? metaBook.glosshash = hash : metaBook.inithash = location.hash;
            }
            addClass(document.body, "mbSTARTUP"), syncStartup(), metaBook.resizeUI(), headProcessed();
        }
    }
    function headReady() {
        return _head_processed || _head_processing ? void 0 : (Timeline.head_ready = _head_ready = fdjtTime(), 
        Trace.startup > 1 && fdjtLog("Head ready"), run_inits("head"), processHead());
    }
    function headProcessed() {
        if (!_head_processed) {
            if (Timeline.head_processed = _head_processed = fdjtTime(), Trace.startup > 1 && fdjtLog("Head processed in %dms", _head_processed - _head_processing), 
            _head_processing = !1, mB.docid) {
                var opened = readLocal("mB(" + mB.docid + ").opened", !0);
                (!opened || opened + keep_open_msecs > fdjtTime()) && (mB.showCover(), dropSplashPage());
            }
            return !_body_ready || _body_processed || _body_processing ? void 0 : processBody();
        }
    }
    function processBody() {
        var metadata = !1;
        if (!_body_processed && !_body_processing && _body_ready) {
            if (!_head_processed) return _head_ready ? processHead() : void 0;
            _body_processing = fdjtTime(), metaBook.initBody(), metaBook.setupGestures(), fdjtAsync.timeslice([ function() {
                applyTOCRules(), metadata = scanDOM(), metaBook.setupTOC(metadata[metaBook.content.id]), 
                mB.target && mB.setTarget(mB.target), fdjt.Async(metadataDone, metadata);
            }, function() {
                fdjtAsync(startLayout);
            }, function() {
                var hasText = fdjtDOM.hasText, rules = fdjtDOM.getMeta("METABOOK.index", !0).concat(fdjtDOM.getMeta("PUBTOOL.index", !0)).concat(fdjtDOM.getMeta("INDEX.include", !0)).concat(fdjtDOM.getMeta("textindex", !0)), content = $ID("CODEXCONTENT");
                rules.push("p,li,ul,blockquote,div"), rules.push("h1,h2,h3,h4,h5,h6,h7,hgroup,.sbookindex");
                for (var nodes = fdjtDOM.getChildren(content, rules.join(",")), index = metaBook.textindex = new fdjt.TextIndex(), i = 0, lim = nodes.length; lim > i; ) {
                    var node = nodes[i++];
                    hasText(node) && index.indexText(node);
                }
                index.finishIndex();
            }, function() {
                for (var toSet = RefDB.toSet, docdb = metaBook.docdb, index = metaBook.textindex, docinfo = metaBook.docinfo, allids = index.allids, idterms = index.idterms, allterms = index.allterms, termindex = index.termindex, wix = docdb.addIndex("strings", RefDB.StringMap), t = 0, nterms = allterms.length; nterms > t; ) {
                    var term = allterms[t++];
                    wix[term] = toSet(termindex[term]);
                }
                for (var n = 0, nids = allids.length; nids > n; ) {
                    var id = allids[n++], doc = docinfo[id];
                    doc && (doc.strings = toSet(idterms[id]));
                }
            }, bodyProcessed ], {
                slice: 100,
                space: 25
            });
        }
    }
    function metadataDone(metadata) {
        if (Trace.startup > 1 && fdjtLog("Processing metadata"), Knodule && Knodule.HTML && Knodule.HTML.Setup && metaBook.knodule) {
            var knomsg = $ID("METABOOKSTARTUPKNO"), knodetails = $ID("METABOOKSTARTUPKNODETAILS");
            knodetails && (knodetails.innerHTML = fdjtString("Processing knodule %s", metaBook.knodule.name)), 
            addClass(knomsg, "running"), (Trace.startup > 1 || Trace.indexing) && fdjtLog("Processing knodule %s", metaBook.knodule.name), 
            Knodule.HTML.Setup(metaBook.knodule), dropClass(knomsg, "running");
        }
        return Timeline.metadata_done = fdjtTime(), fdjtAsync(function() {
            metaBook.setupIndex(metadata);
        }), fdjtAsync.timeslice([ function() {
            Trace.startup > 1 && fdjtLog("Loading sourcedb"), metaBook.sourcedb.load(!0);
        }, function() {
            if (metaBook.sync) {
                if (metaBook.cacheglosses) return metaBook.initGlossesOffline();
            } else window._metabook_loadinfo && (metaBook.loadInfo(window._metabook_loadinfo), 
            window._metabook_loadinfo = !1);
        }, window._metabook_newinfo && function() {
            metaBook.loadInfo(window._metabook_newinfo), window._metabook_newinfo = !1;
        }, function() {
            Trace.startup > 1 && fdjtLog("Metadata processed");
        } ], {
            slice: 100,
            space: 25
        });
    }
    function bodyReady() {
        return _body_processed || _body_processing ? void 0 : (Timeline.body_ready = _body_ready = fdjtTime(), 
        _head_ready ? (Trace.startup > 1 && fdjtLog("Body ready"), run_inits("body"), processBody()) : headReady());
    }
    function bodyProcessed() {
        _body_processed || (Timeline.body_processed = _body_processed = fdjtTime(), Trace.startup > 1 && fdjtLog("Body processed in %dms", _body_processed - _body_processing), 
        _body_processing = !1, startLayout(), startupDone());
    }
    function domReady() {
        _dom_processed || (Timeline.dom_ready = _dom_ready = fdjtTime(), headReady(), bodyReady(), 
        run_inits("dom"), Trace.startup > 1 && fdjtLog("DOM ready"));
    }
    function startLayout() {
        metaBook.sizeContent(), metaBook.bypage ? metaBook.Paginate("initial") : addClass(document.body, "_SCROLL");
    }
    function addTOCLevel(specs, level) {
        for (var j = 0, nspecs = specs.length; nspecs > j; ) for (var nodes = fdjtDOM.$(specs[j++]), i = 0, lim = nodes.length; lim > i; ) nodes[i++].setAttribute("data-toclevel", level);
    }
    function applyTOCRules() {
        var h1 = getMeta("TOC.head1", !0, !0).concat(getMeta("TOC.sect1", !0, !0)).concat(getMeta("sbook1head", !0));
        h1.length && addTOCLevel(h1, "1");
        var h2 = getMeta("TOC.head2", !0, !0).concat(getMeta("TOC.sect2", !0, !0)).concat(getMeta("sbook2head", !0, !0));
        h2.length && addTOCLevel(h2, "2");
        var h3 = getMeta("TOC.head3", !0, !0).concat(getMeta("TOC.sect3", !0, !0)).concat(getMeta("sbook3head", !0));
        h3.length && addTOCLevel(h3, "3");
        var h4 = getMeta("TOC.head4", !0, !0).concat(getMeta("TOC.sect4", !0, !0)).concat(getMeta("sbook4head", !0, !0));
        h4.length && addTOCLevel(h4, "4");
        var h5 = getMeta("TOC.head5", !0, !0).concat(getMeta("TOC.sect5", !0, !0)).concat(getMeta("sbook5head", !0, !0));
        h5.length && addTOCLevel(h5, "5");
        var h6 = getMeta("TOC.head6", !0, !0).concat(getMeta("TOC.sect6", !0, !0)).concat(getMeta("sbook6head", !0, !0));
        h6.length && addTOCLevel(h6, "6");
        var h7 = getMeta("TOC.head7", !0, !0).concat(getMeta("TOC.sect7", !0, !0)).concat(getMeta("sbook7head", !0, !0));
        h7.length && addTOCLevel(h7, "7");
    }
    function scanDOM() {
        (Trace.startup > 1 || Trace.domscan) && fdjtLog("Starting DOM scan with %o", metaBook.content);
        var scanmsg = $ID("METABOOKSTARTUPSCAN");
        addClass(scanmsg, "running");
        var metadata = new metaBook.DOMScan(metaBook.content, metaBook.refuri + "#");
        if (metaBook.docinfo = metadata, metaBook.ends_at = metaBook.docinfo._maxloc, (Trace.startup > 1 || Trace.domscan) && fdjtLog("Done with DOM scan yielding %o", metadata), 
        dropClass(scanmsg, "running"), metaBook.state && metaBook.state.target && !metaBook.state.location) {
            var info = metaBook.docinfo[metaBook.state.target];
            info && info.starts_at && (metaBook.state.location = info.starts_at, metaBook.saveState(!1, !0, !0));
        }
        if (metaBook.scandone) {
            var donefn = metaBook.scandone;
            delete metaBook.scandone, donefn();
        }
        return metadata;
    }
    function startupDone(mode) {
        metaBook.glosshash && metaBook.glossdb.ref(metaBook.glosshash) ? metaBook.showGloss(metaBook.glosshash) ? (metaBook.glosshash = !1, 
        Timeline.initLocation = fdjtTime()) : metaBook.initLocation() : metaBook.initLocation(), 
        window.onpopstate = function(evt) {
            evt.state && metaBook.restoreState(evt.state, "popstate");
        }, Trace.startup > 1 && fdjtLog("metaBook startup done"), metaBook.resizeUI(), metaBook.displaySync(), 
        fdjtDOM.dropClass(document.body, "mbSTARTUP"), fdjtDOM.addClass(document.body, "mbREADY"), 
        $ID("METABOOKSPLASHPAGE") && setTimeout(function() {
            addClass("METABOOKSPLASHPAGE", "startupdone");
        }, 3e3);
        var rmsg = $ID("METABOOKREADYMESSAGE");
        if (rmsg && ($ID("METABOOKOPENTAB") ? rmsg.style.display = "none" : (rmsg.innerHTML = "Open", 
        rmsg.id = "METABOOKOPENTAB")), mode || getQuery("startmode") && (mode = getQuery("startmode")), 
        mode ? metaBook.setMode(mode) : mode = metaBook.mode, metaBook._started = new Date(), 
        metaBook._starting = !1, metaBook.onsetup) {
            var onsetup = metaBook.onsetup;
            metaBook.onsetup = !1, setTimeout(onsetup, 10);
        }
        var msg = !1, uuid_end = !1, msgid = !1;
        if ((msg = getQuery("APPMESSAGE")) && ("#{" === msg.slice(0, 2) && (uuid_end = msg.indexOf("}")) > 0 ? (msgid = "MSG_" + msg.slice(2, uuid_end), 
        getLocal(msgid) || (saveLocal(msgid, "seen"), fdjtUI.alertFor(10, msg.slice(uuid_end + 1)))) : fdjtUI.alertFor(10, msg)), 
        (msg = getCookie("APPMESSAGE")) && (fdjtUI.alertFor(10, msg), fdjtState.clearCookie("APPMESSAGE", "bookhub.io", "/")), 
        !mode && mB.user && location.hash && metaBook.state && location.hash.slice(1) !== metaBook.state.target) mB.layoutReady(metaBook.hideCover); else if (!mode && metaBook.user) {
            var opened = readLocal("mB(" + mB.docid + ").opened", !0);
            opened && opened + keep_open_msecs > fdjtTime() && mB.layoutReady(metaBook.hideCover);
        }
        fdjtDOM.vischange && fdjtDOM.addListener(document, fdjtDOM.vischange, metaBook.visibilityChange), 
        fdjtDOM.addListener(window, "resize", metaBook.resizeHandler), metaBook.state && mB.restoreState(metaBook.state);
    }
    function getRelLink(relname) {
        return getLink(relname, !1, !0, !1, !0);
    }
    function readBookSettings() {
        var refuri = _getsbookrefuri(), docuri = _getsbookdocuri(), locuri = window.location.href, hashpos = locuri.indexOf("#");
        metaBook.locuri = hashpos > 0 ? locuri.slice(0, hashpos) : locuri, document.body.refuri = metaBook.refuri = refuri, 
        metaBook.topuri = document.location.href, metaBook.docuri = docuri;
        var refuris = getLocal("mB.refuris", !0) || [], docuris = getLocal("mB.docuris", !0) || [], docids = getLocal("mB.docids", !0) || [], html = document.documentElement || document.querySelector && document.querySelector("HTML");
        metaBook.sourceid = html.getAttribute("data-sourceid") || getMeta("PUBTOOL.sourceid") || getMeta("PUBTOOL.fileid") || metaBook.docuri;
        var sourcetime = html.getAttribute("data-sourcetime") || getMeta("PUBTOOL.sourcetime");
        sourcetime && (metaBook.sourcetime = fdjtTime.parse(sourcetime));
        var oldid = getLocal("mB(" + mB.docid + ").sourceid");
        if (oldid && oldid !== metaBook.sourceid) {
            var layouts = getLocal("mB(" + oldid + ").layouts");
            if (layouts && layouts.length) for (var i = 0, lim = layouts.length; lim > i; ) CodexLayout.dropLayout(layouts[i++]);
        } else saveLocal("mB(" + mB.docid + ").sourceid", metaBook.sourceid);
        var bookbuild = html.getAttribute("data-buildstamp");
        if (bookbuild) {
            var brk = bookbuild.indexOf(" ");
            metaBook.buildstamp = bookbuild, brk > 0 && (metaBook.bookbuildhost = bookbuild.slice(0, brk), 
            metaBook.bookbuildtime = fdjtTime.parse(bookbuild.slice(brk + 1)));
        }
        metaBook.bypage = "bypage" === metaBook.page_style, metaBook.max_excerpt = getMeta("METABOOK.maxexcerpt") || metaBook.max_excerpt, 
        metaBook.min_excerpt = getMeta("METABOOK.minexcerpt") || metaBook.min_excerpt;
        var notespecs = getMeta("booknote", !0).concat(getMeta("METABOOK.booknote", !0)), noterefspecs = getMeta("booknoteref", !0).concat(getMeta("METABOOK.booknoteref", !0));
        metaBook.booknotes = notespecs && notespecs.length ? fdjtDOM.sel(notespecs) : !1, 
        metaBook.booknoterefs = noterefspecs && noterefspecs.length ? fdjtDOM.sel(noterefspecs) : !1, 
        0 > refuris.indexOf(refuri) && (refuris.push(refuri), saveLocal("mB.refuris", refuris, !0)), 
        0 > docuris.indexOf(docuri) && (docuris.push(docuri), saveLocal("mB.docuris", docuris, !0));
        var docid, docref = getMeta("BOOKHUB.docref");
        metaBook.docid = docref ? metaBook.docref = docid = docref : docid = docuri, fdjtState.setCookie("MB:DOCID", docid, 3628800, !1, !1, !0), 
        fdjtState.setCookie("MB:REFURI", refuri, 3628800, !1, !1, !0), saveLocal("mB(" + docid + ")", docuri), 
        0 > docids.indexOf(docid) && (docuris.push(docuri), saveLocal("mB.docuris", docuris, !0));
        var coverpage = getRelLink("PUBTOOL.coverpage") || getRelLink("coverpage") || getRelLink("*.coverpage");
        coverpage && (metaBook.coverpage = coverpage);
        var coverimage = getRelLink("PUBTOOL.coverimage") || getRelLink("coverimage") || getRelLink("*.coverimage");
        coverimage && (metaBook.coverimage = coverimage);
        var thumbnail = getRelLink("PUBTOOL.thumbnail") || getRelLink("thumbnail") || getRelLink("*.thumbnail");
        thumbnail && (metaBook.thumbnail = thumbnail);
        var icon = getRelLink("PUBTOOL.icon") || getRelLink("icon") || getRelLink("*.icon");
        icon && (metaBook.icon = icon);
        var baseid = getMeta("BOOKHUB.id") || getMeta("*.prefix") || getMeta("*.baseid");
        baseid && (metaBook.baseid = baseid);
        var prefix = getMeta("BOOKHUB.idprefix") || getMeta("*.prefix") || getMeta("*.idprefix") || baseid;
        prefix && (metaBook.prefix = prefix);
        var targetprefix = getMeta("METABOOK.targetprefix");
        metaBook.targetids = targetprefix && "*" === targetprefix ? !1 : targetprefix && "/" === targetprefix[0] ? RegExp(targetprefix.slice(1, targetprefix.length - 1)) : targetprefix ? RegExp("^" + targetprefix) : prefix ? RegExp("^" + prefix) : !1;
        var autofonts = fdjtDOM.getMeta("METABOOK.adjustfont", !0);
        autofonts.length && (fdjt.DOM.autofont = fdjt.DOM.autofont + "," + autofonts.join(",")), 
        (getMeta("METABOOK.forcelayout") || getQuery("mbFORCELAYOUT") || getLocal("mbFORCELAYOUT") || getSession("mbFORCELAYOUT")) && (mB.forcelayout = !0);
        var autotoc = getMeta("METABOOK.autotoc");
        if (autotoc && (metaBook.autotoc = "y" === autotoc[0] || "Y" === autotoc[0] || "ON" === autotoc || "on" === autotoc || "1" === autotoc || "enable" === autotoc ? !0 : !1), 
        !metaBook.nologin) {
            var mycopyid = mB.readMyCopyId();
            mycopyid && mycopyid !== mB.mycopid && mB.iosAuthKludge && mB.iosAuthKludge(), mB.mycopyid = mycopyid;
        }
    }
    function setupDevice() {
        var root = document.documentElement || document.body, useragent = navigator.userAgent, device = fdjtDevice;
        Trace.startup > 2 && fdjtLog("Starting device setup for %s", useragent);
        var started = fdjtTime();
        !device.touch && getQuery("touch") && (device.touch = getQuery("touch")), fdjt.TapHold.default_opts.bubble = !1, 
        device.touch && (fdjtDOM.addClass(root, "_TOUCH"), fdjt.TapHold.default_opts.fortouch = !0, 
        metaBook.ui = "touch", metaBook.touch = !0, metaBook.keyboard = !1, viewportSetup()), 
        device.android ? (default_config.keyboardhelp = !1, metaBook.updatehash = !1) : useragent.search("Safari/") > 0 && useragent.search("Mobile/") > 0 ? (hide_mobile_safari_address_bar(), 
        metaBook.updatehash = !1, default_config.keyboardhelp = !1, fdjtLog.doformat = !0) : device.touch ? (fdjtDOM.addClass(root, "_TOUCH"), 
        metaBook.ui = "touch") : metaBook.ui || (fdjtDOM.addClass(root, "_MOUSE"), metaBook.ui = "mouse"), 
        Trace.startup > 1 && fdjtLog("setupDevice done in %dms: %s/%dx%d %s", fdjtTime() - started, metaBook.ui, fdjtDOM.viewWidth(), fdjtDOM.viewHeight(), device.string);
    }
    function setupBook() {
        if (!metaBook.bookinfo) {
            var bookinfo = metaBook.bookinfo = {}, started = fdjtTime();
            Trace.startup > 2 && fdjtLog("Book setup started"), bookinfo.title = getMeta("METABOOK.title") || getMeta("PUBTOOL.title") || getMeta("DC.title") || getMeta("~TITLE") || document.title || "untitled";
            var authors = getMeta("METABOOK.author", !0).concat(getMeta("PUBTOOL.author", !0)).concat(getMeta("DC.creator", !0)).concat(getMeta("AUTHOR")).concat(getMeta("~AUTHOR"));
            authors && authors.length && (bookinfo.authors = authors), bookinfo.byline = getMeta("METABOOK.byline") || getMeta("PUBTOOL.byline") || getMeta("BYLINE") || authors && authors.length && authors[0], 
            bookinfo.copyright = getMeta("PUBTOOL.copyright") || getMeta("BOOKHUB.copyright") || getMeta("DC.rights") || getMeta("COPYRIGHT") || getMeta("RIGHTS"), 
            bookinfo.publisher = getMeta("PUBTOOL.pubname") || getMeta("BOOKHUB.pubname") || getMeta("DC.publisher") || getMeta("PUBLISHER"), 
            bookinfo.pubyear = getMeta("PUBTOOL.pubyear") || getMeta("BOOKHUB.pubyear") || getMeta("DC.date"), 
            bookinfo.description = getMeta("METABOOK.description") || getMeta("BOOKHUB.description") || getMeta("PUBTOOL.description") || getMeta("DC.description") || getMeta("DESCRIPTION"), 
            bookinfo.digitized = getMeta("PUBTOOL.digitized") || getMeta("DIGITIZED"), bookinfo.converted = getMeta("PUBTOOL.converted"), 
            Trace.startup > 1 && fdjtLog("setupBook done in %dms", fdjtTime() - started);
        }
    }
    function getBookInfo() {
        return metaBook.bookinfo ? metaBook.bookinfo : (setupBook(), metaBook.bookinfo);
    }
    function viewportSetup() {
        var head = fdjtDOM.getHEAD(), viewport = getMeta("viewport", !1, !1, !0);
        viewport || (viewport = document.createElement("META"), viewport.setAttribute("name", "viewport"), 
        viewport.setAttribute("content", viewport_spec), head.appendChild(viewport));
        var isapp = getMeta("apple-mobile-web-app-capable", !1, !1, !0);
        isapp || (isapp = document.createElement("META"), isapp.setAttribute("name", "apple-mobile-web-app-capable"), 
        isapp.setAttribute("content", "yes"), head.appendChild(isapp));
    }
    function hide_mobile_safari_address_bar() {
        window.scrollTo(0, 1), setTimeout(function() {
            window.scrollTo(0, 0);
        }, 0);
    }
    function _getsbookrefuri() {
        var refuri = getLink("refuri", !1, !0) || getLink("METABOOK.refuri", !1, !0) || getLink("BOOKHUB.refuri", !1, !0) || getLink("PUBTOOL.refuri", !1, !0) || getMeta("refuri", !1, !0) || getLink("canonical", !1, !0);
        if (refuri) return decodeURI(refuri);
        var locref = document.location.href, qstart = locref.indexOf("?");
        qstart >= 0 && (locref = locref.slice(0, qstart));
        var hstart = locref.indexOf("#");
        return hstart >= 0 && (locref = locref.slice(0, hstart)), decodeURI(locref);
    }
    function _getsbookdocuri() {
        return getLink("docuri", !1) || getLink("METABOOK.docuri", !1) || getLink("BOOKHUB.docuri", !1) || getLink("PUBTOOL.docuri", !1) || getLink("canonical", !1) || _getsbookrefuri();
    }
    function lookupServer(string) {
        for (var sbook_servers = metaBook.servers, i = 0; sbook_servers.length > i; ) {
            if (sbook_servers[i][0] === string) return sbook_servers[i][1];
            if (string.search(sbook_servers[i][0]) >= 0) return sbook_servers[i][1];
            if (sbook_servers[i][0].call && sbook_servers[i][0].call(string)) return sbook_servers[i][1];
            i++;
        }
        return !1;
    }
    function gotServerInfo(data) {
        var host_spec = "<span class='host'>" + metaBook.server + "</span>";
        metaBook.server_info && metaBook.server_info.serverip !== data.serverip && fdjtLog.warn("Server %s IP change from %s to %s:\n	%j\n	%j", metaBook.server, metaBook.server_info.serverip, data.serverip, metaBook.server_info, data), 
        data.servername !== metaBook.server && (host_spec = host_spec + " / " + "<span class='host'>" + data.servername + "</span>"), 
        data.hostname !== data.servername && (host_spec = host_spec + " / " + "<span class='host'>" + data.hostname + "</span>"), 
        data.serverip && (host_spec = host_spec + " / " + "<span class='host'>" + data.serverip + "</span>"), 
        metaBook.server_info = data;
        for (var info = fdjt.DOM.$(".metabookserverinfo"), i = 0, lim = info.length; lim > i; ) info[i++].innerHTML = "<strong>Glosses</strong> from " + host_spec;
    }
    function fetchServerInfo() {
        var servername = metaBook.server;
        fdjtDOM.removeListener(window, "online", fetchServerInfo), fdjtAjax.jsonCall(gotServerInfo, "https://" + servername + "/_info");
    }
    function updateServerInfo() {
        navigator.onLine ? fetchServerInfo() : fdjtDOM.addListener(window, "online", fetchServerInfo);
    }
    function hasTOCLevel(elt) {
        return elt.toclevel || elt.getAttributeNS && elt.getAttributeNS("toclevel", "http://beingmeta.com/TOC/") || elt.getAttribute("toclevel") || elt.getAttribute("data-toclevel") || elt.className && elt.className.search && (elt.className.search(/\b(sbook|pubtool)\dhead\b/) >= 0 || elt.className.search(/\b(sbook|pubtool)notoc\b/) >= 0 || elt.className.search(/\b(sbook|pubtool)ignore\b/) >= 0) ? !0 : !1;
    }
    function getScanSettings() {
        !metaBook.docroot && getMeta("METABOOK.rootid") && (metaBook.docroot = mbID(getMeta("METABOOK.rootid"))), 
        metaBook.docroot = metaBook.docroot || $ID("METABOOKROOT") || $ID("CODEXCONTENT") || document.body, 
        !metaBook.start && getMeta("METABOOK.startid") && (metaBook.start = mbID(getMeta("METABOOK.startid"))), 
        metaBook.start = metaBook.start || $ID("METABOOKSTART") || $ID("BOOKSTART");
        for (var i = 0; 9 > i; ) {
            var body = document.body, rules = getMeta("TOC.head" + i, !0).concat(getMeta("TOC.sect" + i, !0)).concat(getMeta("tochead" + i, !0));
            if (rules && rules.length) for (var j = 0, lim = rules.length; lim > j; ) for (var elements = fdjtDOM.getChildren(body, rules[j++]), k = 0, n = elements.length; n > k; ) {
                var elt = elements[k++];
                hasTOCLevel(elt) || (elt.toclevel = i);
            }
            i++;
        }
        var ignore = getMeta("htmlbookignore", !0).concat(getMeta("METABOOK.ignore", !0)).concat(getMeta("PUBTOOL.ignore", !0));
        ignore.length && (metaBook.ignore = new fdjtDOM.Selector(ignore));
        var notoc = getMeta("tocheadnone", !0).concat(getMeta("TOC.ignore", !0)).concat(getMeta("PUBTOOL.nothead", !0));
        notoc.length && (metaBook.notoc = new fdjtDOM.Selector(notoc));
        var terminal = getMeta("htmlbookterminal", !0).concat(getMeta("METABOOK.terminal", !0)).concat(getMeta("PUBTOOL.terminal", !0));
        terminal.length && (metaBook.terminals = new fdjtDOM.Selector(terminal.length));
        var focus = getMeta("htmlbooktarget", !0).concat(getMeta("METABOOK.target", !0)).concat(getMeta("METABOOK.idify", !0)).concat(getMeta("PUBTOOL.idify", !0));
        focus.length && (metaBook.focus = new fdjtDOM.Selector(focus));
        var nofocus = getMeta("htmlbooknotarget", !0).concat(getMeta("METABOOK.notarget", !0));
        nofocus.length && (metaBook.nofocus = new fdjtDOM.Selector(nofocus));
    }
    function setupBookInfo() {
        for (var elt, info = fdjt.DOM.$(".metabookrefinfo"), started = fdjtTime(), i = 0, lim = info.length; lim > i; ) elt = info[i++], 
        elt.innerHTML = "<strong>Ref:</strong> ", fdjtDOM.append(elt, fdjtDOM("span.refuri", metaBook.refuri), " ", fdjtDOM("span.oidref", metaBook.docref));
        for (info = fdjt.DOM.$(".metabooksourceinfo"), i = 0, lim = info.length; lim > i; ) elt = info[i++], 
        elt.innerHTML = "<strong>Source:</strong> ", metaBook.sourcetime && elt.appendChild(timeDOM(metaBook.sourcetime)), 
        fdjtDOM.append(elt, " ", fdjtDOM("span.uuid", metaBook.sourceid));
        for (info = fdjt.DOM.$(".metabookbuildinfo"), i = 0, lim = info.length; lim > i; ) elt = info[i++], 
        elt.innerHTML = "<strong>Book Build:</strong> ", metaBook.bookbuild && !metaBook.bookbuildhost ? elt.appendChild(metaBook.bookbuild) : (metaBook.bookbuildtime && elt.appendChild(timeDOM(metaBook.bookbuildtime)), 
        fdjtDOM.append(elt, " on ", fdjtDOM("span.host", metaBook.bookbuildhost)));
        for (info = fdjt.DOM.$(".metabookappinfo"), i = 0, lim = info.length; lim > i; ) elt = info[i++], 
        elt.innerHTML = "", fdjtDOM(elt, fdjtDOM("strong", "App:"), " ", "metaBook version ", metaBook.version, " built on ", fdjtDOM("span.host", metaBook.buildhost), metaBook.buildtime && " at ", timeDOM(metaBook.buildtime), " loaded from ", fdjtDOM("span.host", metaBook.appsource));
        for (info = fdjt.DOM.$(".metabookcopyrightinfo"), i = 0, lim = info.length; lim > i; ) info[i++].innerHTML = "Program and Interface <span class='inlinesymbol'>©</span> beingmeta, inc 2008-2015";
        Trace.startup > 1 && fdjtLog("Book info setup done in %dms", fdjtTime() - started);
    }
    function timeDOM(x) {
        var elt;
        try {
            return elt = "string" == typeof x ? fdjtDOM("time", x) : fdjtDOM("time", "" + x), 
            "string" == typeof x ? elt.setAttribute("datetime", x) : elt.setAttribute("datetime", x.toISOString()), 
            elt;
        } catch (ex) {
            return document.createTextNode("??time??");
        }
    }
    function setupZoom() {
        var started = fdjtTime(), zoom = metaBook.Zoom = fdjtDOM("div#METABOOKZOOM.metabookzoom.metabookcontent", fdjtDOM("div#METABOOKZOOMBOX", fdjtDOM("div#METABOOKZOOMTARGET")), fdjtDOM("div#METABOOKZOOMCONTROLS", fdjtDOM("div#METABOOKZOOMCLOSE"), fdjtDOM("div#METABOOKUNZOOM"), fdjtDOM("div#METABOOKZOOMIN"), fdjtDOM("div#METABOOKZOOMOUT"), fdjtDOM("div#METABOOKZOOMHELP"), fdjtDOM("div#METABOOKZOOMHELPTEXT", "Drag to pan, use two fingers to zoom")));
        zoom.metabookui = !0, document.body.appendChild(zoom), Trace.startup > 1 && fdjtLog("Zoom setup done in %dms", fdjtTime() - started);
    }
    function setupMedia() {
        var started = fdjtTime(), media = metaBook.Media = fdjtDOM("div#METABOOKMEDIA.metabookmedia.metabookcontent", fdjtDOM("div#METABOOKMEDIATARGET"), fdjtDOM("div#METABOOKCLOSEMEDIA"));
        media.metabookui = !0, document.body.appendChild(media), Trace.startup > 1 && fdjtLog("Zoom setup done in %dms", fdjtTime() - started);
    }
    function enableOpenSans() {
        var frame = $ID("METABOOKFRAME");
        frame && (frame.style.fontFamily = open_sans_stack, metaBook.resizeUI());
    }
    function startupHandler() {
        mB._starting || mB._started || (mB.delay_startup ? "number" == typeof mB.delay_startup ? setTimeout(mB.Startup, mB.delay_startup) : setTimeout(startupHandler, 1e3) : metaBook.Startup());
    }
    var fdjtString = fdjt.String, fdjtDevice = fdjt.device, fdjtState = fdjt.State, fdjtAsync = fdjt.Async, fdjtAjax = fdjt.Ajax, fdjtTime = fdjt.Time, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, $ID = fdjt.ID, RefDB = fdjt.RefDB, mbID = metaBook.ID, CodexLayout = fdjt.CodexLayout, https_root = "https://s3.amazonaws.com/beingmeta/static/", getLocal = fdjtState.getLocal, getSession = fdjtState.getSession, getQuery = fdjtState.getQuery, getCookie = fdjtState.getCookie, getMeta = fdjtDOM.getMeta, getLink = fdjtDOM.getLink, addClass = fdjtDOM.addClass, swapClass = fdjtDOM.swapClass, dropClass = fdjtDOM.dropClass, mB = metaBook, Trace = metaBook.Trace, Timeline = metaBook.Timeline, readLocal = metaBook.readLocal, saveLocal = metaBook.saveLocal, keep_open_msecs = 54e5;
    metaBook.startupMessage = startupMessage, metaBook.dropSplashPage = dropSplashPage, 
    metaBook.setupWait = setupWait;
    var app_init_done = !1;
    metaBook.appInit = appInit, mB.inits.local.push(initMarkdown);
    var isEmpty = fdjtString.isEmpty;
    metaBook.setSync = function(val) {
        if (!val) return !1;
        var cur = metaBook.sync;
        return cur && cur > val ? cur : (metaBook.sync = val, metaBook.persist && saveLocal("mB(" + mB.docid + ").sync", val), 
        val);
    }, metaBook.useTraceSettings = useTraceSettings;
    var glosshash_pat = /G[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;
    metaBook.Startup = metaBookStartup;
    var _head_ready = !1, _head_processing = !1, _head_processed = !1, _body_ready = !1, _body_processing = !1, _body_processed = !1, _dom_ready = !1, _dom_processed = !1;
    metaBook.processHead = processHead, metaBook.headReady = function() {
        setTimeout(headReady, 5);
    }, metaBook.bodyReady = function() {
        setTimeout(bodyReady, 5);
    }, metaBook.domReady = function() {
        setTimeout(domReady, 5);
    };
    var default_config = metaBook.default_config;
    metaBook.getBookInfo = getBookInfo;
    var viewport_spec = "width=device-width,initial-scale=1.0,user-scalable=no";
    metaBook.updateServerInfo = updateServerInfo, metaBook.hasTOCLevel = hasTOCLevel, 
    metaBook.setupZoom = setupZoom, metaBook.setupMedia = setupMedia, metaBook.addConfig("uisound", function(name, value) {
        metaBook.uisound = value && !0;
    }), metaBook.addConfig("readsound", function(name, value) {
        metaBook.readsound = value && !0;
    }), metaBook.addConfig("bodycontrast", function(name, value) {
        var mbody = $ID("METABOOKBODY");
        value ? swapClass(mbody, /\bmetabookcontrast[a-z]+\b/g, "metabookcontrast" + value) : dropClass(mbody, /\bmetabookcontrast[a-z]+\b/g), 
        fdjt.Async(function() {
            metaBook.updateSettings(name, value);
        });
    });
    var open_sans_stack = "'Open Sans',Verdana, Tahoma, Arial, Helvetica, sans-serif, sans";
    return metaBook.enableOpenSans = enableOpenSans, metaBook.Setup = metaBook.StartupHandler = startupHandler, 
    metaBookStartup;
}(), metaBook.Slice = function() {
    "use strict";
    function getTargetDup(scan, target) {
        for (var targetid = target.id; scan; ) {
            if (hasClass(scan, "codexpage")) return scan;
            if (scan.getAttribute && (scan.id === targetid || scan.getAttribute("data-baseid") === targetid)) return scan;
            scan = scan.parentNode;
        }
        return target;
    }
    function generic_cancel(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        fdjtUI.isClickable(target) || cancel(evt);
    }
    function renderCard(info, query, idprefix, standalone) {
        var target_id = info.frag || info.id, target_info = metaBook.docinfo[target_id];
        if (!target_info) return !1;
        var head_info = target_info.level ? target_info : target_info.head, head = head_info && mbID(head_info.frag), score = query && query.scores.get(info), excerpt_len = info.excerpt ? info.excerpt.length : 0, note = info.note && info.note.trim(), note_len = note && note.length, overlay = getoverlay(info), shared = info.shared || [], sample = query && !standalone && !info.maker && sampletext(mbID(target_id));
        "string" == typeof shared && (shared = [ shared ]), overlay && (shared = RefDB.remove(shared, overlay._qid || overlay._id));
        var body = fdjtDOM("div.mbcard_body", score && showscore(info, score, query), info.maker || info.tstamp ? showglossinfo(info) : showdocinfo(info), sample, note_len > 0 && info.maker && showmaker(info), note_len > 0 && shownote(info), " ", info.detail && fdjtDOM("span.showdetail", "More"), " ", (info.alltags || info.tags) && showtags(info, query), " ", info.links && showlinks(info.links), " ", info.attachments && showlinks(info.attachments, "span.attachments"), " ", shared && shared.length > 0 && showaudience(shared), excerpt_len > 0 && showexcerpts(info.excerpt), " "), card = fdjtDOM(info.maker ? "div.mbcard.gloss" : "div.mbcard.passage", head && makeTOCHead(head, info.level && info), standalone && makelocbar(target_info), body, fdjtDOM("div.fdjtclearfloats"));
        return info.maker && info.maker.load().then(function(makerinfo) {
            var tstamp = info.tstamp || info.modified || info.created;
            makerinfo._live && ":PERSON" === makerinfo.kind && (body.title = tstamp ? "gloss from " + (makerinfo.name || "someone") + " at " + fdjtTime.shortString(tstamp) : "gloss from " + (makerinfo.name || "someone"), 
            addClass(card, "personal"));
        }), card.about = "#" + info.frag, card.setAttribute("data-passage", target_id), 
        card.setAttribute("data-location", target_info.starts_at), head_info && card.setAttribute("data-tochead", head_info.frag), 
        (info.maker || info.tstamp) && (card.setAttribute("data-gloss", info._id), info.tstamp && card.setAttribute("data-timestamp", info.tstamp)), 
        score && card.setAttribute("data-searchscore", score), idprefix && (card.id = idprefix + info.id), 
        info._id && (card.name = card.qref = info._id, card.setAttribute("name", info._id)), 
        card;
    }
    function sampletext(para, len) {
        if (len || (len = 80), !para) return !1;
        var fulltext = fdjtDOM.textify(para), sample = para.title || para.getAttribute("data-summary") || (len > fulltext.length ? fulltext : fulltext.slice(0, len)), span = fdjtDOM("span.sample", sample);
        return span.title = fulltext, span;
    }
    function convertNote(note) {
        if (0 === note.search(/^{(md|markdown)}/)) {
            var close = note.indexOf("}");
            return metaBook.md2DOM(note.slice(close + 1), !0);
        }
        return note;
    }
    function shownote(gloss) {
        return fdjtDOM("span.note", convertNote(gloss.note));
    }
    function showmaker(gloss) {
        var maker = gloss.maker;
        if (maker._live) return fdjtDOM("span.maker", maker.name || "From");
        var temp = fdjtDOM("span.maker", "From");
        return maker.load().then(function(m) {
            m.name && (temp.innerHTML = m.name);
        }), temp;
    }
    function showtags(info, query) {
        for (var tagicon = fdjtDOM.Image(mbicon("tagicon", 64, 64), "img.tagicon", "tags"), matches = query && fdjtDOM("span.matches"), toptags = fdjtDOM("span.top"), sectags = fdjtDOM("span.sectags"), othertags = fdjtDOM("span.other"), count = 0, seen = {}, tagslots = [ "**tags", "*tags", "+tags", "+tags*", "knodes", "tags", "**tags*", "*tags*", "tags*", "^tags", "^tags*" ], j = 0, nslots = tagslots.length, ntags = 0; nslots > j; ) {
            var slot = tagslots[j++], tags = info[slot];
            if (tags) {
                if (isArray(tags)) {
                    if (0 === tags.length) continue;
                } else tags = [ tags ];
                var i = 0, lim = tags.length;
                for (ntags += lim; lim > i; ) {
                    var tag = tags[i++];
                    if (tag) {
                        var tagstring = "string" == typeof tag ? tag : tag._qid || tag.getQID();
                        if (!seen[tagstring]) {
                            count++, seen[tagstring] = tag;
                            var sectag = tag._qid && "§" === tag._qid[0], elt = sectag ? sectag2HTML(tag) : Knodule.HTML(tag, metaBook.knodule);
                            matches && tag_matchp(tag, query) ? fdjtDOM(matches, " ", elt) : sectag ? fdjtDOM(sectags, " ", elt) : 4 > count ? fdjtDOM(toptags, " ", elt) : fdjtDOM(othertags, " ", elt);
                        }
                    }
                }
            }
        }
        return ntags ? fdjtDOM("span.mbcard_tags.tags", tagicon, matches, toptags, othertags, sectags) : !1;
    }
    function tag_matchp(tag, query) {
        for (var qtags = query.tags, i = 0, lim = qtags.length; lim > i; ) {
            var qtag = qtags[i++];
            if (qtag === tag) return !0;
            if (tag.allways && tag.allways.indexOf(qtag) >= 0) return !0;
        }
        return !1;
    }
    function sectag2HTML(sectag) {
        var name = sectag._id, span = fdjtDOM("span.sectname", name);
        return span.setAttribute("data-value", sectag._qid), name.length > 20 && addClass(span, "longterm"), 
        span;
    }
    function showaudience(outlets, spec) {
        if (outlets instanceof Array || (outlets = [ outlets ]), 0 === outlets.length) return !1;
        for (var span = fdjtDOM(spec || (outlets.length > 1 ? "div.mbcard_audience" : "span.mbcard_audience"), outlets.length > 1 && fdjtDOM("span.count", outlets.length, " outlets"), " "), i = 0, lim = outlets.length; lim > i; ) {
            var outlet = outlets[i], info = metaBook.sourcedb.ref(outlet), outlet_span = fdjtDOM("span.outlet");
            info._live ? (fdjtDOM(outlet_span, info.name), outlet_span.title = info.about ? "Shared with “" + info.name + "” — " + info.about : "Shared with “" + info.name + "”") : (outlet_span.setAttribute("NAME", "OUTLETSPAN" + info._id), 
            info.load().then(fill_outlet_spans)), fdjtDOM.append(span, " ", outlet_span), i++;
        }
        return span;
    }
    function fill_outlet_spans(info) {
        for (var outlet_spans = TOA(document.getElementsByName("OUTLETSPAN" + info._id)), i = 0, len = outlet_spans.length; len > i; ) {
            var outlet_span = outlet_spans[i++];
            outlet_span.removeAttribute("NAME"), fdjtDOM(outlet_span, info.name), outlet_span.title = info.about ? "Shared with “" + info.name + "” — " + info.about : "Shared with “" + info.name + "”";
        }
    }
    function showlinks(refs, spec) {
        var count = 0;
        for (var url in refs) {
            if ("_" === url[0]) continue;
            count++;
        }
        if (0 === count) return !1;
        var span = fdjtDOM(spec || (count > 4 ? "div.mbcard_links" : "span.mbcard_links"), count > 1 && fdjtDOM("span.count", count, " links"), " ");
        for (url in refs) if ("_" !== url[0]) {
            var title, urlinfo = refs[url], elt = !1, openinbook = 0 === url.search("https://glossdata.bookhub.io/") || 0 === url.search("https://glossdata.sbooks.net/") || 0 === url.search("resources/"), icon = !1, type = !1, useclass = !1;
            if (!openinbook) for (var inbookurls = metaBook.inbookurls, i = 0, lim = inbookurls; lim > i; ) {
                var pat = inbookurls[i++];
                if ("string" == typeof pat) {
                    if (0 === url.search(pat)) {
                        openinbook = !0;
                        break;
                    }
                } else if (pat.exec(url)) {
                    openinbook = !0;
                    break;
                }
            }
            "string" == typeof urlinfo ? title = urlinfo : (title = urlinfo.title, icon = urlinfo.icon, 
            type = urlinfo.type), type || (type = metaBook.urlType(url)), icon || (icon = metaBook.typeIcon(type)), 
            useclass || (useclass = metaBook.mediaTypeClass(type));
            var image = fdjtDOM.Image(icon);
            openinbook ? (elt = fdjtDOM("span.mbmedia", image, title), elt.setAttribute("data-src", url), 
            type && elt.setAttribute("data-type", type), elt.title = "Reveal " + title) : elt = fdjtDOM.Anchor(url, {
                title: "Link to " + url,
                target: "_blank"
            }, image, title), useclass && addClass(elt, useclass), fdjtDOM(span, elt, "\n");
        }
        return span;
    }
    function showexcerpts(excerpts) {
        if ("string" == typeof excerpts) return fdjtUI.Ellipsis("span.excerpt", excerpts, 40);
        if (1 === excerpts.length) return fdjtUI.Ellipsis("span.excerpt", excerpts[0], 40);
        for (var ediv = fdjtDOM("div.excerpts"), i = 0, lim = excerpts.length; lim > i; ) fdjtDOM(ediv, i > 0 && " ", fdjtUI.Ellipsis("span.excerpt", excerpts[i++], 40));
        return ediv;
    }
    function showscore(elt, score, query) {
        var staricon = fdjtDOM.Image(mbicon("goldstar", 24, 24), "img.inline"), tagicon = fdjtDOM.Image(mbicon("tagicon", 24, 24), "img.inline"), count = query && query.counts && query.counts.get(elt), partial = count && query.tags.length > 1 && (count !== query.tags.length ? fdjtDOM("span.note", count, tagicon) : fdjtDOM("span.note", "all", tagicon));
        return count && (count += ":"), query && query.max_score ? fdjtDOM("span.score", partial, "(", score, "/", query.max_score, staricon, ")") : fdjtDOM("span.score", partial, "(", score, staricon, ")");
    }
    function showglossinfo(info) {
        var maker = info.maker, makerid = info.maker._id || info.maker, can_edit = maker === metaBook.user || maker === metaBook.user._id || mB.outlets && mB.outlets.indexOf(maker) >= 0 || mB.outlets && mB.outlets.indexOf(makerid) >= 0, agestring = timestring(info.modified || info.created || info.tstamp), age = fdjtDOM("span.age", agestring);
        age.title = fdjtTime.timeString(info.modified || info.created || info.tstamp);
        var tool = fdjtDOM("span.tool", age, " ", fdjtDOM("span.label", can_edit ? "modify" : "respond"), can_edit ? fdjtDOM.Image(mbicon("gloss_edit_titled", 64, 64), "img.button", "edit", "tap to edit this gloss, hold to reply") : fdjtDOM.Image(mbicon("gloss_respond_titled", 64, 64), "img.button", "reply", "relay/reply to this gloss"), info.private && fdjtDOM("span.private", "Private"));
        addListener(tool, "tap", glossaction), addListener(tool, "release", glossaction);
        var pic = getglosspic(info);
        return pic && fdjtDOM.addListener(pic, "touchstart", fdjt.UI.noDefault), [ pic, tool ];
    }
    function showdocinfo(info) {
        return info ? !1 : !1;
    }
    function getoverlay(info) {
        if (info.sources) {
            var sources = info.sources;
            "string" == typeof sources && (sources = [ sources ]);
            for (var i = 0, lim = sources.length; lim > i; ) {
                var source = metaBook.sourcedb.loadref(sources[i++]);
                if (source && ":OVERLAY" === source.kind) return source;
            }
            return !1;
        }
        return !1;
    }
    function getglosspic(gloss) {
        if (gloss._pic || gloss.pic) return IMG(gloss._pic || gloss.pic, "img.glosspic.glossicon", gloss.note || gloss.name);
        if (gloss.links && gloss.links.icon) return IMG(gloss.links.icon, "img.glosspic.glossicon");
        var maker = gloss.maker && ("string" == typeof gloss.maker ? gloss.maker = mB.sourcedb.ref(gloss.maker) : gloss.maker);
        if (maker && maker._live && (maker._pic || maker.pic)) return IMG(maker._pic || maker.pic, "img.glosspic.userpic", maker.name);
        if (maker && maker._live && maker.fbid) return IMG("https://graph.facebook.com/" + gloss.maker.fbid + "/picture?type=square", "img.glosspic.userpic.fbpic", gloss.maker.name);
        if (maker && maker._live) return fdjtDOM("div.glosspic.userpic.sbooknopic", gloss.maker.name ? getInitials(gloss.maker.name, 1) : "?");
        if (maker) {
            var temp = fdjtDOM("div.glosspic.userpic.sbooknopic", gloss.maker.name ? fdjtString.getInitials(gloss.maker.name, 1) : "?");
            return maker.load().then(function(maker) {
                var usepic = !1;
                maker._live ? maker._pic || maker.pic ? usepic = IMG(maker._pic || maker.pic, "img.glosspic.userpic", getInitials(gloss.maker.name, 1), maker.about ? maker.name + ": " + maker.about : maker.name) : maker.fbid && (usepic = IMG("https://graph.facebook.com/" + maker.fbid + "/picture?type=square", "img.glosspic.userpic.fbpic", getInitials(gloss.maker.name, 1), maker.about ? maker.name + ": " + maker.about : maker.name)) : usepic = !1, 
                usepic && fdjtDOM.replace(temp, usepic);
            }), temp;
        }
        return !1;
    }
    function timestring(tick) {
        var now = fdjtTime.tick(), date = new Date(1e3 * tick);
        if (43200 > now - tick) {
            var hour = date.getHours(), minute = date.getMinutes();
            return "" + hour + ":" + (10 > minute ? "0" : "") + minute;
        }
        var year = date.getFullYear(), month = date.getMonth(), datenum = date.getDate();
        return 10 > year ? "" + datenum + "/" + months[month] + "/0" + year : "" + datenum + "/" + months[month] + "/" + year;
    }
    function makelocbar(target_info, cxt_info) {
        var locrule = fdjtDOM("HR"), locbar = fdjtDOM("DIV.locbar", locrule), target_start = target_info.starts_at, target_end = target_info.ends_at, target_len = target_end - target_start;
        cxt_info || (cxt_info = metaBook.docinfo[document.body.id]);
        var cxt_start = cxt_info.starts_at, cxt_end = cxt_info.ends_at, cxt_len = cxt_end - cxt_start;
        locrule.style.width = 100 * (target_len / cxt_len) + "%", locrule.style.left = 100 * ((target_start - cxt_start) / cxt_len) + "%";
        var id = target_info.id || target_info.frag;
        return id && (locbar.about = "#" + id, locbar.title = sumText(mbID(id))), locbar;
    }
    function makelocrule(target_info, cxtinfo, spec) {
        var tocrule = !cxtinfo;
        cxtinfo || (cxtinfo = metaBook.docinfo[metaBook.content.id]);
        var locrule = fdjtDOM(spec || "hr.locrule"), cxt_start = cxtinfo.starts_at, cxt_end = cxtinfo.ends_at, cxt_len = cxt_end - cxt_start, target_start = target_info.starts_at - cxt_start, target_len = target_info.ends_at - target_info.starts_at, locstring = "~" + Math.ceil(target_len / 5) + " words long ~" + Math.ceil(100 * (target_start / cxt_len)) + "% along";
        return locrule.setAttribute("about", "#" + (target_info.id || target_info.frag)), 
        locrule.locstring = locstring + ".", locrule.title = (tocrule ? "this section in the book" : "this passage in the section, ") + locstring + ": click or hold to glimpse", 
        locrule.style.width = 100 * (target_len / cxt_len) + "%", locrule.style.left = 100 * (target_start / cxt_len) + "%", 
        locrule;
    }
    function makelocstring(target_info, cxtinfo) {
        var tocrule = !cxtinfo;
        cxtinfo || (cxtinfo = metaBook.docinfo[metaBook.content.id]);
        var cxt_start = cxtinfo.starts_at, cxt_end = cxtinfo.ends_at, cxt_len = cxt_end - cxt_start, target_start = target_info.starts_at - cxt_start, target_len = target_info.ends_at - target_info.starts_at;
        return tocrule ? "this section is ~" + Math.ceil(target_len / 7) + " words long and ~" + Math.ceil(100 * (target_start / cxt_len)) + "% into the book" : "this passage is ~" + Math.ceil(target_len / 7) + " words long and ~" + Math.ceil(100 * (target_start / cxt_len)) + "% into the section";
    }
    function glossaction(evt) {
        var target = fdjtUI.T(evt), scan = target;
        for (fdjtUI.cancel(evt); scan && !scan.qref; ) scan = scan.parentNode;
        if (scan) {
            var qref = scan.qref, gloss = metaBook.glossdb.ref(qref), form = metaBook.setGlossTarget(gloss, "hold" === evt.type);
            form && metaBook.setMode("addgloss");
        }
    }
    function sumText(target) {
        var title = metaBook.getTitle(target, !0);
        return 40 > title.length ? title : title;
    }
    function makeTOCHead(target, head) {
        head || (head = metaBook.getHead(target));
        var basespan = fdjtDOM("span");
        basespan.title = "this location in the structure of the book";
        var info = metaBook.docinfo[target.id];
        if (head) {
            var text = sumText(head), headtext = fdjtDOM("span.headtext.tocref", fdjtDOM("span.spacer", "§"), text);
            headtext.setAttribute("data-tocref", head.id);
            var curspan = fdjtDOM("span.head", headtext);
            headtext.title = "jump to the section: " + text, fdjtDOM.append(basespan, " ", curspan);
            var heads = metaBook.Info(head).heads;
            if (heads) for (var j = heads.length - 1; j > 0; ) {
                var hinfo = heads[j--], elt = mbID(hinfo.frag);
                if (elt && hinfo.title && elt !== metaBook.docroot && elt !== document.body) {
                    var anchor = fdjtDOM("span.tocref.headtext", fdjtDOM("span.spacer", "§"), hinfo.title);
                    anchor.setAttribute("data-tocref", hinfo.frag);
                    var newspan = fdjtDOM("span.head", " ", anchor);
                    newspan.setAttribute("data-href", hinfo.frag), anchor.title = hinfo.title ? "jump to the section: " + hinfo.title : "(jump to this section)", 
                    target === head ? fdjtDOM(curspan, newspan) : fdjtDOM(curspan, " ⋯ ", newspan), 
                    curspan = newspan;
                }
            }
        }
        var tochead = fdjtDOM("div.mbcard_tochead", makelocrule(info, !1), basespan);
        return tochead.title = makelocstring(info, !1), tochead;
    }
    function selectSources(slice, sources) {
        var sourcerefs = [], sourcedb = metaBook.sourcedb;
        if (!sources || 0 === sources.length) return slice.filter(!1), void 0;
        for (var i = 0, lim = sources.length; lim > i; ) {
            var source = sourcedb.ref(sources[i++]);
            source && sourcerefs.push(source);
        }
        slice.filter(function(card) {
            var gloss = card.gloss;
            return gloss && (RefDB.contains(sourcerefs, gloss.maker) || RefDB.overlaps(sourcerefs, gloss.sources) || RefDB.overlaps(sourcerefs, gloss.shared));
        });
    }
    function MetaBookSlice(container, cards, sortfn, opts) {
        if (opts || (opts = {}), container === void 0) return !1;
        if (!(this instanceof MetaBookSlice)) return new MetaBookSlice(container, cards, sortfn, opts);
        if (container) {
            if ("string" == typeof container) {
                if (named_slices.hasOwnProperty(container)) return named_slices[container];
                if (!document.getElementById(container)) return !1;
                container = document.getElementById(container);
            } else if (container.nodeType && 1 === container.nodeType && container.id) {
                if (named_slices.hasOwnProperty(container.id)) return named_slices[container.id];
                named_slices[container.id] = container;
            } else if (!container.nodeType || 1 !== container.nodeType) return !1;
        } else container = fdjtDOM("div.metabookslice");
        return opts.hasOwnProperty("initlayout") || (opts.initLayout = !1), opts.hasOwnProperty("noslip") || (opts.noslip = !1), 
        opts.hasOwnProperty("id") || (opts.id = container.id), opts.hasOwnProperty("holdmsecs") || (opts.holdmsecs = 400), 
        opts.hasOwnProperty("holdclass") && (opts.holdclass = !1), opts.hasOwnProperty("touchtoo") && (opts.touchtoo = function(evt) {
            evt = evt || window.event, metaBook.previewing && metaBook.stopPreview("touchtoo", !0), 
            this.abort(evt, "touchtoo");
        }), container.id ? metaBook.TapHold[container.id] = new fdjtUI.TapHold(container, opts) : fdjtUI.TapHold(container, opts), 
        metaBook.UI.addHandlers(container, "summary"), this.container = container, this.cards = [], 
        sortfn && (this.sortfn = sortfn), this.byid = new fdjt.StringMap(), this.byfrag = new fdjt.RefMap(mB.docinfo), 
        this.live = !1, this.needupdate = !1, this.addCards(cards), metaBook.touch && (opts.packthresh = 40), 
        cards && cards.length && container.parentNode && this.update(), this;
    }
    function getFirstID(node) {
        if (node.id) return node;
        if (node.childNodes) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) if (1 === children[i].nodeType) {
            var found = getFirstID(children[i++]);
            if (found) return found;
        } else i++;
        return !1;
    }
    function slice_update(slice) {
        slice.refresh_timer = !1, slice.needupdate = !1, slice.update(), slice.needupdate && slice.refresh();
    }
    function getCard(target) {
        return hasClass(target, "mbcard") || hasClass(target, "mbtoc") ? target : getParent(target, ".mbcard,.mbtoc") || getChild(target, ".mbcard,.mbtoc");
    }
    function slice_tapped(evt) {
        var target = fdjtUI.T(evt);
        if (Trace.gestures && fdjtLog("slice_tapped %o: %o", evt, target), metaBook.previewing) return metaBook.stopPreview("slice_tapped", !0), 
        fdjtUI.cancel(evt), void 0;
        if (getParent(target, ".ellipsis") && (getParent(target, ".elision") || getParent(target, ".delision"))) return fdjtUI.Ellipsis.toggle(target), 
        fdjtUI.cancel(evt), void 0;
        if (getParent(target, ".tochead")) {
            var anchor = getParent(target, ".tocref"), href = anchor && anchor.getAttribute("data-tocref");
            return metaBook.SkimTo(href, 0, !1), fdjtUI.cancel(evt), void 0;
        }
        if (getParent(target, ".mbmedia")) {
            var link = getParent(target, ".mbmedia"), src = link.getAttribute("data-src"), cancel = !1, type = link.getAttribute("data-type");
            if (hasClass(link, "imagelink") ? (metaBook.showMedia(src, type), cancel = !0) : (hasClass(link, "audiolink") || hasClass(link, "musiclink")) && (metaBook.showMedia(src, type), 
            cancel = !0), cancel) return fdjtUI.cancel(evt), void 0;
        }
        var card;
        if (card = target.name && document.getElementById(target.name) ? getCard(document.getElementById(target.name)) || getCard(target) : getCard(target)) {
            var slice = getParent(card, ".metabookslice");
            addClass(slice, "mbsyncslice");
            var passage = mbID(card.getAttribute("data-passage")), glossid = card.getAttribute("data-gloss"), gloss = glossid && metaBook.glossdb.ref(glossid);
            if (passage) {
                if (!gloss && passage) return metaBook.SkimTo(card, 0, !1), fdjtUI.cancel(evt);
                if (getParent(target, ".tool")) {
                    var form = metaBook.setGlossTarget(gloss);
                    if (!form) return;
                    return metaBook.setMode("addgloss"), fdjtUI.cancel(evt);
                }
                if ("openglossmark" === mB.mode) return mB.clearGlossmark(), goToGloss(card), fdjtUI.cancel(evt);
                if (getParent(target, ".showdetail")) {
                    var detail = gloss && gloss.detail;
                    if (!detail) return;
                    if ("<" === detail[0]) $ID("METABOOKGLOSSDETAIL").innerHTML = gloss.detail; else if (0 === detail.search(/^{(md|markdown)}/)) {
                        var close = detail.indexOf("}");
                        $ID("METABOOKGLOSSDETAIL").innerHTML = metaBook.md2HTML(detail.slice(close + 1));
                    } else $ID("METABOOKGLOSSDETAIL").innerHTML = metaBook.md2HTML(detail);
                    return metaBook.setMode("glossdetail"), fdjtUI.cancel(evt);
                }
                return metaBook.SkimTo(card, 0, !1), fdjtUI.cancel(evt);
            }
        }
    }
    function slice_held(evt) {
        evt = evt || window.event, mB.slipTimeout(!1);
        var slice_target = fdjtUI.T(evt), card = getCard(slice_target);
        if (Trace.gestures && fdjtLog("slice_held %o: %o, skimming=%o", evt, card, metaBook.skimpoint), 
        card) {
            if (card.getAttribute("data-gloss") && "openglossmark" === mB.mode) return goToGloss(card), 
            fdjtUI.cancel(evt);
            var slice = mB.getSlice(card);
            slice && slice.setSkim(card);
            var clone = card.cloneNode(!0);
            if (clone.id = "METABOOKSKIM", fdjtDOM.replace("METABOOKSKIM", clone), metaBook.previewTarget) {
                var drop = metaBook.getDups(metaBook.previewTarget);
                dropClass(drop, "mbpreviewing"), metaBook.clearHighlights(drop), metaBook.previewTarget = !1;
            }
            var passageid = card.getAttribute("data-passage"), glossid = card.getAttribute("data-gloss"), gloss = glossid && metaBook.glossdb.ref(glossid), passage = mbID(passageid), show_target = !1, dups = metaBook.getDups(passageid);
            if (metaBook.previewTarget = passage, addClass(dups, "mbpreviewing"), gloss && gloss.excerpt) {
                var range = metaBook.findExcerpt(dups, gloss.excerpt, gloss.exoff);
                if (range) {
                    var starts = range.startContainer;
                    getParent(starts, passage) || (show_target = getTargetDup(starts, passage)), fdjtUI.Highlight(range, "mbhighlightexcerpt");
                }
            }
            if (getParent(card, ".searchslice")) for (var terms = metaBook.query.tags, info = metaBook.docinfo[passageid], spellings = info.knodeterms, i = 0, lim = terms.length; lim > i; ) {
                var term = terms[i++], highlights = metaBook.highlightTerm(term, passage, info, spellings);
                show_target || highlights && highlights.length && !getParent(highlights[0], passage) && (show_target = getTargetDup(highlights[0], passage));
            }
            return metaBook.startPreview(show_target || passage, "slice_held"), fdjtUI.cancel(evt);
        }
    }
    function slice_released(evt) {
        var card = getCard(fdjtUI.T(evt || window.event)), glossid = card && card.getAttribute("data-gloss");
        Trace.gestures && fdjtLog("slice_released %o: %o, skimming=%o", evt, card), metaBook.previewing && metaBook.stopPreview("slice_released"), 
        glossid && "openglossmark" === mB.mode && goToGloss(card), fdjtUI.cancel(evt);
    }
    function slice_slipped(evt) {
        evt = evt || window.event;
        var rel = evt.relatedTarget;
        Trace.gestures && fdjtLog("slice_slipped %o to %o", evt, rel), rel && hasParent(rel, ".metabookslice") || mB.slipTimeout(function() {
            Trace.gestures && fdjtLog("slice_slipped/timeout %o", evt), metaBook.stopPreview("slice_slipped");
        });
    }
    function slice_touchtoo(evt) {
        evt = evt || window.event, metaBook.previewTimeout(!1), metaBook.previewing && (Trace.gestures ? (fdjtLog("slice_touchtoo %o noabout", evt), 
        metaBook.stopPreview("toc_touchtoo", !0)) : metaBook.stopPreview("toc_touchtoo", !0), 
        fdjtUI.cancel(evt));
    }
    function slice_swiped(evt) {
        var dx = evt.deltaX, dy = evt.deltaY, vw = fdjtDOM.viewWidth(), adx = 0 > dx ? -dx : dx, ady = 0 > dy ? -dy : dy, target = fdjtUI.T(evt), slice = getParent(target, ".metabookslice");
        if (Trace.gestures && fdjtLog("slice_swiped d=%o,%o, ad=%o,%o, s=%o,%o vw=%o, n=%o", dx, dy, adx, ady, evt.startX, evt.startY, vw, evt.ntouches), 
        adx > 2 * ady) -(metaBook.minswipe || 10) > dx ? metaBook.skimming ? metaBook.skimForward() : (dropClass(slice, "myslicesync"), 
        showPage.forward(slice)) : dx > (metaBook.minswipe || 10) && (metaBook.skimming ? metaBook.skimBackward() : (dropClass(slice, "mbyslicesync"), 
        showPage.backward(slice))); else if (ady > 2 * adx) if (metaBook.hudup) -(metaBook.minswipe || 10) > dy ? metaBook.setMode("allglosses") : dy > (metaBook.minswipe || 10) && metaBook.setMode("search"); else {
            if ((metaBook.minswipe || 10) >= ady) return;
            vw / 5 > evt.startX && 0 > dy ? metaBook.setMode("help") : vw / 5 > evt.startX && dy > 0 ? metaBook.setMode("statictoc") : evt.startX > .8 * vw && dy > 0 ? metaBook.setMode("search") : evt.startX > .8 * vw && 0 > dy ? metaBook.setMode("allglosses") : dy > 0 ? (metaBook.clearStateDialog(), 
            metaBook.showCover()) : metaBook.setHUD(!0);
        }
    }
    function goToGloss(card) {
        var glossid = card.getAttribute("data-gloss"), glosscard = glossid && mB.slices.allglosses.byid[glossid];
        glosscard && (metaBook.setMode("allglosses"), fdjt.Async(function() {
            mB.slices.allglosses.setSkim(glosscard);
        }));
    }
    var fdjtString = fdjt.String, fdjtTime = fdjt.Time, fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, showPage = fdjt.showPage, RefDB = fdjt.RefDB, Ref = RefDB.Ref, $ = fdjtDOM.$, $ID = fdjt.ID, mB = metaBook, mbID = mB.ID, Trace = mB.Trace, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, mbicon = metaBook.icon, addListener = fdjtDOM.addListener, getParent = fdjtDOM.getParent, hasParent = fdjtDOM.hasParent, getChild = fdjtDOM.getChild, getInitials = fdjtString.getInitials, cancel = fdjtUI.cancel, TOA = fdjtDOM.toArray;
    metaBook.renderCard = renderCard;
    var isArray = Array.isArray, IMG = fdjtDOM.Image, months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], hasClass = fdjtDOM.hasClass;
    metaBook.UI.selectSources = selectSources;
    var named_slices = {};
    return MetaBookSlice.prototype.setLive = function(flag) {
        return flag ? this.live ? !1 : (this.needupdate && this.update(), this.live = !0, 
        !0) : this.live ? (this.live = !1, !0) : !1;
    }, MetaBookSlice.prototype.renderCard = function(about) {
        return renderCard(about);
    }, MetaBookSlice.prototype.sortfn = function(x, y) {
        return x.hasOwnProperty("location") ? y.hasOwnProperty("location") ? x.location === y.location ? x.timestamp ? y.timestamp ? x.timestamp - y.timestamp : -1 : 1 : x.location - y.location : -1 : 1;
    }, MetaBookSlice.prototype.getCard = function getCard(ref) {
        if (1 === ref.nodeType && (hasClass(ref, "mbcard") || hasClass(ref, "mbtoc"))) {
            var id = ref.getAttribute("data-gloss") || ref.getAttribute("data-passage");
            return this.byid.get(id);
        }
        return 1 !== ref.nodeType ? ref._qid && this.byid.get(ref._qid) || ref._id && this.byid.get(ref._id) : (ref.id || (ref = getFirstID(ref)), 
        ref ? this.byid.get(ref.id) || this.byfrag.get(ref.id) : void 0);
    }, MetaBookSlice.prototype.update = function() {
        metaBook.Trace.slices && fdjtLog("Updating slice %o over %o", this, this.container);
        var cards = this.cards, visible = [], shown = [], byfrag = this.byfrag, container = this.container;
        cards.sort(this.sortfn), dropClass($(".slicenewpassage", container), "slicenewpassage"), 
        dropClass($(".slicenewhead", container), "slicenewhead"), this.container.innerHTML = "";
        for (var head = !1, passage = !1, frag = document.createDocumentFragment() || this.container, i = 0, lim = cards.length; lim > i; ) {
            var card = cards[i++];
            card.hidden || (card.passage !== passage && (passage = card.passage, byfrag[passage] = card, 
            addClass(card.dom, "slicenewpassage")), card.head !== head && (head = card.head, 
            addClass(card.dom, "slicenewhead")), frag.appendChild(card.dom), visible.push(card), 
            shown.push(card.dom));
        }
        frag !== this.container && this.container.appendChild(frag), showPage.update(container), 
        this.visible = visible, this.shown = shown, this.needupdate = !1;
    }, MetaBookSlice.prototype.refresh = function(force) {
        var slice = this;
        (this.needupdate || force) && (this.refresh_timer && (clearTimeout(this.refresh_timer), 
        this.refresh_timer = !1), this.refresh_timer = setTimeout(function() {
            slice_update(slice);
        }, 2e3));
    }, MetaBookSlice.prototype.filter = function(fn) {
        var cards = this.cards, i = 0, n = cards.length;
        if (metaBook.Trace.slices && (fn ? fdjtLog("Filtering slice %o by %o", this.container, fn) : fdjtLog("Restoring filtered slice %o", this.container)), 
        fn) for (;n > i; ) {
            var card = cards[i++];
            card.hidden = fn(card) ? !1 : !0;
        } else for (;n > i; ) delete cards[i++].hidden;
        this.filterfn = fn, this.needupdate = !0, this.update();
    }, MetaBookSlice.prototype.addCards = function(adds, scores) {
        if (adds && (adds instanceof Array || (adds = [ adds ]), 0 !== adds.length)) {
            scores || (scores = this.scores || !1), metaBook.Trace.slices && fdjtLog("Adding %d cards to slice %o with scores %o", adds.length, this.container, scores);
            for (var byid = this.byid, cards = this.cards, i = 0, lim = adds.length; lim > i; ) {
                var card, id, add = adds[i++], info = !1, about = !1, push = !0, replace = !1;
                if (add.about && add.dom && (info = add, card = add.dom), add.nodeType && 1 === add.nodeType && hasClass(add, "mbcard")) {
                    if (card = add, id = add.name || add.getAttribute("name"), !id) continue;
                    (info = byid[id]) ? (info.dom !== add && (replace = byid[id].dom), card = add, info.dom = add) : card = add;
                } else add instanceof Ref && (id = add._qid || add.getQID(), about = add, byid[id] ? (info = byid[id], 
                card = info.dom, push = !1) : card = this.renderCard(add));
                if (card) {
                    if (about || (about = RefDB.resolve(id)), info ? byid[id] || (byid[id] = info) : byid[id] = info = {
                        added: fdjtTime(),
                        id: id,
                        about: about
                    }, scores && scores.get(add) && (info.score = scores.get(add)), info.dom = card, 
                    card.getAttribute("data-location") && (info.location = parseInt(card.getAttribute("data-location"), 10)), 
                    card.getAttribute("data-gloss") && (info.gloss = metaBook.glossdb.refs[card.getAttribute("data-gloss")]), 
                    card.getAttribute("data-searchscore") && (info.score = parseInt(card.getAttribute("data-searchscore"), 10)), 
                    card.getAttribute("data-timestamp") && (info.timestamp = parseInt(card.getAttribute("data-timestamp"), 10)), 
                    card.getAttribute("data-passage") && (info.passage = card.getAttribute("data-passage")), 
                    card.getAttribute("data-tochead") && (info.head = card.getAttribute("data-tochead")), 
                    this.filterfn) {
                        var fn = this.filterfn;
                        info.hidden = fn(info) ? !1 : !0;
                    }
                    replace ? this.container.replaceChild(card, replace) : push && cards.push(info);
                }
            }
            this.needupdate = !0, this.live && this.refresh();
        }
    }, MetaBookSlice.prototype.setSkim = function(card) {
        var visible = this.visible, shown = this.shown, off = card.nodeType ? shown.indexOf(card) : visible.indexOf(card), dom = card.nodeType ? card : card.dom;
        return 0 > off ? void 0 : (card = shown[off], this.skimpoint && dropClass(this.skimpoint, "skimpoint"), 
        this.skimpoint = card, this.skimpos = off, this.atStart = 0 === off, this.atEnd = off >= visible.length - 1, 
        addClass(dom, "skimpoint"), this.container.offsetHeight && 0 === dom.offsetHeight && showPage.showNode(this.container, dom), 
        card);
    }, MetaBookSlice.prototype.forward = function(card) {
        var shown = this.shown;
        card || (card = this.skimpoint || shown[0]);
        var off = shown.indexOf(card);
        return 0 > off || off + 1 >= this.visible.length ? void 0 : this.setSkim(shown[off + 1]);
    }, MetaBookSlice.prototype.backward = function(card) {
        var shown = this.shown;
        card || (card = this.skimpoint || shown[shown.length - 1]);
        var off = shown.indexOf(card);
        return 0 >= off ? void 0 : this.setSkim(shown[off - 1]);
    }, MetaBookSlice.prototype.getInfo = function(card) {
        if ("string" == typeof card) {
            var found = this.byid.get(card) || this.byfrag.get(card);
            card = Array.isArray(found) && found.length ? found[0] : found;
        }
        var pos;
        return card ? 0 > (pos = this.shown.indexOf(card)) && (pos = this.visible.indexOf(card)) : pos = this.skimpos, 
        pos >= 0 ? this.visible[pos] : !1;
    }, MetaBookSlice.prototype.setLocation = function(location) {
        var cards = this.cards, i = 0, lim = cards.length, last_card = !1;
        if (!this.skimpos || !this.cards[this.skimpos] || this.cards[this.skimpos].location !== location) for (;lim > i; ) {
            var card = cards[i];
            if ("number" == typeof card.location) {
                if (card.location === location) return this.setSkim(card), void 0;
                if (card.location > location) return last_card ? this.setSkim(last_card) : this.setSkim(card), 
                void 0;
                last_card = card, i++;
            } else i++;
        }
    }, metaBook.UI.getCard = getCard, metaBook.updateSkimmer = function() {
        if (mB.skimming) {
            var skimpoint, skim = $ID("METABOOKSKIM");
            if (mB.skimming.setLocation(mB.location), mB.skimming !== mB.slices.statictoc) {
                skimpoint = mB.skimming.skimpoint;
                for (var pid = skimpoint && skimpoint.getAttribute("data-passage"), dups = pid && mB.getDups(pid), found = !1, i = 0, lim = dups.length; lim > i; ) found ? i++ : hasParent(dups[i], ".curpage") ? found = dups[i++] : i++;
                if (!found) return mB.setMode(!1), void 0;
            } else skimpoint = mB.skimming.skimpoint;
            skimpoint || mB.setMode(!1);
            var curname = skim.getAttribute("name"), newname = skimpoint.getAttribute("name");
            if (curname === newname) return;
            var clone = skimpoint.cloneNode(!0);
            clone.id && (clone.id = "METABOOKSKIM"), fdjtDOM.replace(skim, clone);
        }
    }, fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, {
        summary: {
            tap: slice_tapped,
            hold: slice_held,
            release: slice_released,
            click: generic_cancel,
            slip: slice_slipped
        }
    }), fdjt.DOM.defListeners(metaBook.UI.handlers.touch, {
        summary: {
            tap: slice_tapped,
            hold: slice_held,
            release: slice_released,
            touchtoo: slice_touchtoo,
            swipe: slice_swiped,
            slip: slice_slipped
        }
    }), MetaBookSlice;
}(), function() {
    "use strict";
    function makeCloud(tags, scores, freqs, n, completions, init_dom, roots) {
        var start = new Date(), sourcedb = metaBook.sourcedb, knodule = metaBook.knodule, dom = init_dom || !1, i = 0, n_terms = tags.length, breadcrumb = !1;
        dom && dom.parentNode && (breadcrumb = document.createTextNode(""), dom.parentNode.replaceChild(breadcrumb, dom)), 
        dom ? addClass(dom, "completions") : dom = completions && completions.dom ? completions.dom : fdjtDOM("div.completions.cloud.noinput", getShowAll(usecues, n_terms));
        var maxmsg = fdjtDOM("div.maxcompletemsg", "There are a lot ", "(", fdjtDOM("span.completioncount", "really"), ")", " of completions.  "), emptymsg = fdjtDOM("div.nomatchmsg", "(no matches)");
        fdjtDOM.prepend(dom, emptymsg, maxmsg), completions || (completions = new Completions(dom));
        var info = organize_tags(tags, scores, knodule, sourcedb), usecues = n_terms > 17 && (info.n_primes > 0 || info.max !== info.min || 17 > info.normals._count || n_terms / info.normals._count > 4);
        usecues ? getChild(dom, ".showall") && fdjtDOM.prepend(dom, getShowAll(usecues, n_terms)) : fdjtDOM.addClass(dom, "showall"), 
        tags = [].concat(tags), sort_tags(tags);
        for (var score_sum = 0; n_terms > i; ) {
            var score = scores.get(tags[i++]);
            score && (score_sum += score);
        }
        for (i = 0; n_terms > i; ) {
            var dterm = tags[i++], span = cloudSpan(dterm, completions, scores, freqs, score_sum / n_terms);
            dom.appendChild(span), dom.appendChild(document.createTextNode(" "));
        }
        sizeCloud(completions, scores, roots);
        var end = new Date();
        return Trace.clouds && fdjtLog("Made cloud for %d tags in %f seconds", tags.length, (end.getTime() - start.getTime()) / 1e3), 
        breadcrumb && breadcrumb.parentNode.replaceChild(dom, breadcrumb), completions.updated = function() {
            adjustCloudFont(this);
        }, completions;
    }
    function cloudSpan(dterm, completions, scores, freqs) {
        var freq = freqs.get(dterm) || 1, score = scores.get(dterm), span = cloudEntry(dterm, completions), title = span.title;
        return freq && (title = title ? title + "; count=" + freq : "count=" + freq), score && score !== freq && (title = title + "; s=" + score), 
        span.title = title, 1 === freq ? addClass(span, "singleton") : 2 === freq && addClass(span, "doubleton"), 
        span;
    }
    function initCloudEntry(tag, entry, cloud, lang) {
        var variations = !1, suffix = !1;
        if (tag instanceof KNode) {
            var knode = tag, dterm = knode.dterm, origin = !1;
            if (tag._db === metaBook.knodule) origin = "index"; else if (tag._db.fullname) origin = tag._db.fullname, 
            suffix = fdjtDOM("sup", "*"); else {
                var sourceref = metaBook.sourcedb.probe(tag._db.name);
                sourceref ? (origin = tag._db.fullname = sourceref.name, suffix = fdjtDOM("sup", "*")) : (origin = "glosses", 
                suffix = fdjtDOM("sup", "*"));
            }
            entry.setAttribute("data-key", dterm), "string" == typeof suffix ? entry.innerHTML = dterm + suffix : suffix ? (entry.innerHTML = dterm, 
            entry.appendChild(suffix)) : entry.innerHTML = dterm;
            var synonyms = knode[lang];
            if (synonyms && "string" == typeof synonyms && (synonyms = [ synonyms ]), synonyms) for (var i = 0; synonyms.length > i; ) {
                var synonym = synonyms[i++];
                if (synonym !== dterm) {
                    var variation = fdjtDOM("span.variation", synonym, "=");
                    variation.setAttribute("data-key", synonym), variations || (variations = fdjtDOM("span.variations")), 
                    variations.appendChild(variation);
                }
            }
            knode.prime ? (addClass(entry, "prime"), addClass(entry, "cue")) : knode.weak && addClass(entry, "weak");
            var noun = dterm.search(/\.\.\.$/) > 0 ? "root form" : "concept", title = (knode.prime ? "key " : knode.weak ? "rough " : "") + ("index" === origin ? "index " + noun + " " : noun + " (from " + origin + ") ");
            if (knode.about) title = title + knode.dterm + ": " + knode.about; else {
                var def = knode.toPlaintext();
                title = def && def !== knode.dterm ? title + knode.dterm + "=" + knode.toPlaintext() : title + "'" + knode.dterm + "'";
            }
            entry.title = title;
        } else tag.name ? (addClass(entry, "source"), addClass(entry, "account"), entry.setAttribute("data-key", tag.name), 
        entry.innerHTML = tag.name) : tag.refuri && (addClass(entry, "doc"), entry.setAttribute("data-key", tag.refuri), 
        cloud && entry.title && cloud.addKeys(entry, entry.title), entry.innerHTML = tag.refuri);
        variations && fdjtDOM.prepend(entry, variations), cloud && cloud.addKeys(entry);
    }
    function initCloudEntries(tag) {
        var droplets = tag.droplets;
        if (droplets) {
            for (var i = 0, lim = droplets.length; lim > i; ) {
                var droplet = droplets[i++];
                initCloudEntry(tag, droplet.entry, droplet.cloud, droplet.lang);
            }
            delete tag.droplets;
        }
    }
    function cloudEntry(tag, cloud, lang, usespec) {
        var entry;
        usespec || (usespec = "span.completion"), "string" != typeof lang && (lang = metaBook.language || Knodule.language || "EN");
        var existing = cloud && cloud.getByValue(tag, ".completion");
        if (existing && existing.length) return existing[0];
        if ("string" == typeof tag) {
            var isrootform = tag.search(/\.\.\.$/) > 0, spec = usespec + (isrootform ? ".rootform" : ".rawterm") + (tag.length > 20 ? ".longterm" : "");
            return entry = fdjtDOM(spec, fdjtDOM("span.termtext", "“" + tag + "”")), entry.setAttribute("data-key", tag), 
            entry.setAttribute("data-value", tag), entry.title = isrootform ? "forms " + tag : tag, 
            cloud && cloud.addCompletion(entry, tag, tag), entry;
        }
        if (!(tag instanceof Ref)) {
            var strungout = "" + entry;
            return entry = fdjtDOM(strungout.length > 20 ? usespec + ".weirdterm.longterm" : usespec + ".weirdterm", "?" + strungout + "¿"), 
            entry.title = strungout, cloud && cloud.addCompletion(entry, strungout, tag), entry;
        }
        var qid = tag._qid || tag.getQID(), id = tag._id || tag.dterm;
        if (tag._db === metaBook.docdb) {
            var showname, sectname = tag.title;
            return showname = sectname.length > 40 ? fdjtDOM("span.name.ellipsis", sectname.slice(0, 17), fdjtDOM("span.elision", "…"), fdjtDOM("span.elided", sectname.slice(sectname.length - 17))) : sectname.length > 25 ? fdjtDOM("span.name.longname", sectname) : fdjtDOM("span.name", sectname), 
            showname = fdjtDOM("span.name", sectname), entry = fdjtDOM(usespec + ".sectname", "§", showname), 
            entry.setAttribute("data-key", sectname), entry.setAttribute("data-value", tag._qid || tag.getQID()), 
            sectname.length > 24 && addClass(entry, "longterm"), sectname.length > 20 && (entry.title = sectname), 
            cloud && cloud.addCompletion(entry, sectname, tag), entry;
        }
        return entry = tag instanceof KNode ? fdjtDOM(id.length > 20 ? usespec + ".dterm.longterm" : usespec + ".dterm", qid) : fdjtDOM(id.length > 20 ? usespec + ".longterm" : usespec, qid), 
        tag.cssclass && addClass(entry, tag.cssclass), entry.setAttribute("data-value", qid), 
        cloud && cloud.addCompletion(entry, !1, tag), tag._live ? (initCloudEntry(tag, entry, cloud, lang), 
        entry) : tag.droplets ? (tag.droplets.push({
            entry: entry,
            lang: lang,
            cloud: cloud
        }), void 0) : (tag.droplets = [ {
            entry: entry,
            lang: lang,
            cloud: cloud
        } ], tag.onLoad(initCloudEntries), entry);
    }
    function addTag2Cloud(tag, cloud, kb, scores, freqs, thresh) {
        if (kb || (kb = metaBook.knodule), tag) {
            if (tag instanceof Array) {
                for (var i = 0, lim = tag.length; lim > i; ) addTag2Cloud(tag[i++], cloud, kb, scores, freqs, thresh);
                return;
            }
            var container = cloud.dom, tagref = "string" == typeof tag && kb ? RefDB.resolve(tag, kb, Knodule, !1) || tag : tag, entry = scores ? cloudSpan(tagref, cloud, scores, freqs, thresh) : cloudEntry(tagref, cloud);
            return hasParent(entry, container) || fdjtDOM(container, entry, " "), entry;
        }
    }
    function getShowAll(use_cues, how_many) {
        var showall = use_cues && fdjtDOM("span.showall", fdjtDOM("span.showmore", "more"), fdjtDOM("span.showless", "fewer"));
        return how_many && showall && (showall.title = "There are " + how_many + " in all"), 
        showall && (showall.onclick = showall_ontap), showall;
    }
    function organize_tags(tags, scores, knodule, sourcedb) {
        for (var min_score = !1, max_score = !1, normals = {}, n_normal = 0, n_primes = 0, i = 0; tags.length > i; ) {
            var tag = tags[i++];
            if (tag instanceof Ref && (tag.prime && n_primes++, tag._db === sourcedb || tag.weak || (normals[tag] = !0, 
            n_normal++)), scores) {
                var score = scores.get(tag);
                score && (min_score === !1 ? min_score = score : min_score > score && (min_score = score), 
                score > max_score && (max_score = score));
            }
        }
        return normals._count = n_normal, {
            normals: normals,
            n_primes: n_primes,
            min: min_score,
            max: max_score
        };
    }
    function showall_ontap(evt) {
        var target = fdjtUI.T(evt), completions = getParent(target, ".completions");
        completions && (fdjtUI.cancel(evt), fdjtDOM.toggleClass(completions, "showall"));
    }
    function queryCloud(query) {
        if (query.cloud) return query.cloud;
        if (0 === query.tags.length) return query.cloud = metaBook.empty_cloud, query.cloud;
        var showtags = query.getRefiners(), completions = makeCloud(showtags, query.tagscores, query.tagfreqs, showtags.length, !1, !1, query.tags), cloud = completions.dom;
        completions.taphold || (completions.taphold = new TapHold(cloud)), addClass(cloud, "searchcloud"), 
        metaBook.setupGestures(cloud);
        var n_refiners = showtags.length, hide_some = n_refiners > metaBook.show_refiners;
        if (hide_some) {
            var ranked = [].concat(showtags), scores = query.tagscores;
            ranked.sort(function(x, y) {
                if ("string" == typeof x && "string" == typeof y || x instanceof Ref && y instanceof Ref) {
                    var xs = scores.get(x), ys = scores.get(y);
                    return "number" == typeof xs && "number" == typeof ys ? ys - xs : "number" == typeof xs ? -1 : 1;
                }
                return "string" == typeof x ? 1 : -1;
            });
            for (var i = 0, lim = metaBook.show_refiners; lim > i; ) {
                var tag = ranked[i++], elt = completions.getByValue(tag);
                addClass(elt, "cue");
            }
        } else addClass(cloud, "showall");
        return query.cloud = completions, query.cloud;
    }
    function tag_sorter(x, y, scores) {
        if (x instanceof KNode) {
            if (!(y instanceof KNode)) return -1;
        } else {
            if (y instanceof KNode) return 1;
            if (x instanceof Ref) {
                if (!(y instanceof Ref)) return -1;
            } else {
                if (y instanceof Ref) return 1;
                if ("string" != typeof x || "string" != typeof y) {
                    if (typeof x == typeof y) return y > x ? -1 : x > y ? 1 : 0;
                    var xt = typeof x, yt = typeof y;
                    return yt > xt ? -1 : xt > yt ? 1 : 0;
                }
            }
        }
        var xv = scores.get(x), yv = scores.get(y);
        if (xv === void 0) {
            if (yv === void 0) {
                var xid, yid;
                return "string" == typeof x ? (xid = x, yid = y) : (xid = x._qid || x.getQID(), 
                yid = y._qid || y.getQID()), yid > xid ? -1 : yid > xid ? 1 : 0;
            }
            return 1;
        }
        return yv === void 0 ? -1 : xv === yv ? y > x ? -1 : x > y ? 1 : 0 : xv > yv ? -1 : 1;
    }
    function sort_tags(tags) {
        tags.sort(function(x, y) {
            var sx = x, sy = y;
            if (x instanceof KNode) {
                if (!(y instanceof KNode)) return -1;
                sx = x.dterm, sy = y.dterm;
            } else {
                if (y instanceof KNode) return 1;
                if (x instanceof Ref) {
                    if (!(y instanceof Ref)) return -1;
                    sx = x._qid || x.getQID(), sy = y._qid || y.getQID();
                } else {
                    if (y instanceof Ref) return 1;
                    if ("string" != typeof x || "string" != typeof y) {
                        if ("string" == typeof x) return -1;
                        if ("string" == typeof y) return 1;
                        if (typeof x == typeof y) return y > x ? -1 : x > y ? 1 : 0;
                        var xt = typeof x, yt = typeof y;
                        return yt > xt ? -1 : xt > yt ? 1 : 0;
                    }
                }
            }
            return "§" === sx[0] && "§" !== sy[0] ? 1 : "§" === sy[0] && "§" !== sx[0] ? -1 : (sx.search(/\w/) > 0 && (sx = sx.slice(sx.search(/\w/))), 
            sy.search(/\w/) > 0 && (sy = sy.slice(sy.search(/\w/))), sy > sx ? -1 : sx > sy ? 1 : 0);
        });
    }
    function sortCloud(cloud) {
        var values = [].concat(cloud.values);
        sort_tags(values);
        for (var byvalue = cloud.byvalue, holder = document.createDocumentFragment(), i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completion = byvalue.get(value);
            completion && (i > 1 && holder.appendChild(document.createTextNode(" ")), holder.appendChild(completion));
        }
        cloud.dom.appendChild(holder);
    }
    function sizeCloud(cloud, scores, roots) {
        var gscores = metaBook.tagscores, gweights = metaBook.tagweights, values = cloud.values, byvalue = cloud.byvalue, compscores = Array(values.length), matchscores = Array(values.length), i = 0, lim = values.length, min_vscore = 1/0, max_vscore = -1, min_score = 1/0, max_score = -1;
        for (Trace.clouds && fdjtLog("Sizing %d tags in cloud %o with roots %o", values.length, cloud.dom, roots); lim > i; ) {
            var score, value = values[i], matchscore = !1;
            if (roots && roots.length && roots.indexOf(value) >= 0) matchscores[i] = compscores[i] = !1, 
            i++; else {
                if (scores) {
                    matchscore = scores.get(value);
                    var gscore = gscores.get(value);
                    if (gscore) {
                        var gweight = gweights.get(value) || 1;
                        score = matchscore / gscore * gweight;
                    } else score = !1;
                } else score = gscores.get(value);
                "number" != typeof score || isNaN(score) ? compscores[i] = !1 : (compscores[i] = score, 
                min_vscore > score && (min_vscore = score), score > max_vscore && (max_vscore = score)), 
                "number" != typeof matchscore || isNaN(matchscore) ? matchscores[i] = !1 : (matchscores[i] = matchscore, 
                min_score > matchscore && (min_score = matchscore), matchscore > max_score && (max_score = matchscore)), 
                i++;
            }
        }
        for (Trace.clouds && fdjtLog("Sizing %d tags in %o with scores in [%o,%o]", values.length, cloud.dom, min_vscore, max_vscore), 
        cloud.dom.style.display = "none", i = 0; lim > i; ) {
            var v = values[i], s = compscores[i], ms = matchscores[i], elt = byvalue.get(v);
            if (v.prime && (addClass(elt, "prime"), addClass(elt, "cue")), roots && roots.length && roots.indexOf(v) >= 0 && addClass(elt, "cloudroot"), 
            s || ms) {
                var factor = s ? (s - min_vscore) / (max_vscore - min_vscore) : (ms - min_score) / (max_score - min_score), fsize = 50 + 150 * factor;
                elt.style.fontSize = 200 > fsize ? Math.round(fsize) + "%" : "200%", i++;
            } else addClass(elt, "unscored"), elt.style.fontSize = "", i++;
        }
        Trace.clouds && fdjtLog("Finished computing sizes for %o using scores [%o,%o]", cloud.dom, min_vscore, max_vscore), 
        cloud.dom.style.display = "", dropClass(cloud.dom, "working"), Trace.clouds && fdjtLog("Rendered new cloud %o using scores [%o,%o]", cloud.dom, min_vscore, max_vscore), 
        cloud.dom.parentNode && setTimeout(function() {
            adjustCloudFont(cloud);
        }, 50), Trace.clouds && fdjtLog("Finished sizing tags in %o using scores [%o,%o]", cloud.dom, min_vscore, max_vscore);
    }
    function searchcloud_select(evt) {
        evt = evt || window.event;
        var target = fdjtDOM.T(evt), completion = getParent(target, ".completion");
        if (hasClass(completion, "cloudroot")) return Trace.gestures && log("cloud tap on cloudroot %o", completion), 
        void 0;
        Trace.gestures && log("cloud tap on %o", completion);
        var completions = getParent(target, ".completions");
        if (completion) {
            var cinfo = metaBook.query.cloud || metaBook.query.getCloud(), value = cinfo.getValue(completion);
            "string" != typeof value ? add_searchtag(value) : 0 === value.length || (value.indexOf("@") >= 0 ? add_searchtag(kbref(value)) : metaBook.knodule && metaBook.knodule.probe(value) ? add_searchtag(metaBook.knodule.probe(value)) : add_searchtag(value)), 
            fdjtUI.cancel(evt);
        } else fdjtDOM.inherits(target, ".resultcounts") ? (metaBook.showSearchResults(metaBook.query), 
        metaBook.setMode("searchresults"), $ID("METABOOKSEARCHINPUT").blur(), $ID("METABOOKSEARCHRESULTS").focus(), 
        fdjtUI.cancel(evt)) : fdjtDOM.inherits(target, ".refinercounts") ? (fdjtDOM.toggleClass(completions, "showall"), 
        fdjtDOM.cancel(evt)) : fdjtDOM.inherits(target, ".maxcompletemsg") && (metaBook.touch || $ID("METABOOKSEARCHINPUT").focus(), 
        fdjtDOM.toggleClass(completions, "showall"), fdjtDOM.cancel(evt));
    }
    function add_searchtag(value) {
        metaBook.setQuery(metaBook.extendQuery(metaBook.query, value));
    }
    function setCloudCues(cloud, tags) {
        for (var cursoft = getChildren(cloud.dom, ".cue.softcue"), i = 0, lim = cursoft.length; lim > i; ) {
            var cur = cursoft[i++];
            dropClass(cur, "cue"), dropClass(cur, "softcue");
        }
        var newcues = cloud.getByValue(tags);
        for (i = 0, lim = newcues.length; lim > i; ) {
            var completion = newcues[i++];
            hasClass(completion, "cue") || (addClass(completion, "cue"), addClass(completion, "softcue"));
        }
    }
    function setCloudCuesFromTarget(cloud, target) {
        var tags = [];
        if (mB.docinfo) {
            var targetid = target.codexbaseid || target.id || target.frag, info = mB.docinfo[targetid], knodule = metaBook.knodule;
            if (info && info.tags && (tags = tags.concat(info.tags)), info && info.autotags && info.autotags.length && knodule) for (var autotags = info.autotags, j = 0, jlim = autotags.length; jlim > j; ) {
                var kn = knodule.probe(autotags[j]);
                kn && tags.push(kn.tagString()), j++;
            }
            var glosses = mB.glossdb && mB.glossdb.find("frag", targetid);
            if (glosses) for (var i = 0, lim = glosses.length; lim > i; ) {
                var g = glosses[i++], gtags = g.tags;
                gtags && (tags = tags.concat(gtags));
            }
            setCloudCues(cloud, tags);
        }
    }
    function adjustCloudFont(cloud) {
        var round = Math.round, sqrt = Math.sqrt, dom = cloud.dom, parent = dom.parentNode;
        if (!parent) return dom.style.fontSize = "", void 0;
        var pct = 100;
        dom.style.fontSize = "";
        var ih = dom.scrollHeight, oh = parent.clientHeight;
        Trace.clouds && fdjtLog("Adjusting cloud %o: %o/%o", dom, ih, oh), 0 !== oh && 0 !== ih && (oh > ih && ih > .8 * oh || ih > 2 * oh || (oh = .9 * oh, 
        pct = oh > ih ? round(100 * sqrt(oh / ih) * (pct / 100)) : round(100 * oh / ih * (pct / 100)), 
        dom.style.fontSize = pct > 200 ? "200%" : pct + "%", Trace.clouds && fdjtLog("Adjusted cloud %o: %o/%o to %o%%", dom, ih, oh, pct)));
    }
    var mB = metaBook, Trace = mB.Trace, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, $ID = fdjt.ID, TapHold = fdjt.TapHold, RefDB = fdjt.RefDB, Ref = fdjt.Ref, KNode = Knodule.KNode;
    metaBook.search_cloud = !1, metaBook.empty_cloud || (metaBook.empty_cloud = !1), 
    metaBook.show_refiners || (metaBook.show_refiners = 25), metaBook.search_gotlucky || (metaBook.search_gotlucky = 7);
    var Completions = fdjtUI.Completions, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getChildren = fdjtDOM.getChildren, getChild = fdjtDOM.getChild, getParent = fdjtDOM.getParent, hasParent = fdjtDOM.hasParent, hasClass = fdjtDOM.hasClass, log = fdjtLog, kbref = RefDB.resolve;
    metaBook.makeCloud = makeCloud, metaBook.cloudEntry = cloudEntry, metaBook.addTag2Cloud = addTag2Cloud, 
    metaBook.UI.getShowAll = getShowAll, metaBook.queryCloud = queryCloud, RefDB.Query.prototype.getCloud = function() {
        return queryCloud(this);
    }, metaBook.tag_sorter = tag_sorter, metaBook.sortTags = sort_tags, metaBook.sortCloud = sortCloud, 
    metaBook.sizeCloud = sizeCloud, metaBook.UI.handlers.searchcloud_select = searchcloud_select, 
    metaBook.UI.searchCloudToggle = function() {
        fdjtDOM.toggleClass($ID("METABOOKSEARCHCLOUD"), "showall");
    }, metaBook.setCloudCues = setCloudCues, metaBook.setCloudCuesFromTarget = setCloudCuesFromTarget, 
    metaBook.adjustCloudFont = adjustCloudFont, Completions.prototype.adjustCloudFont = function() {
        return adjustCloudFont(this);
    };
}(), metaBook.TOCSlice = function() {
    "use strict";
    function navicon(kind) {
        switch (kind) {
          case "right":
            return mbicon("skim_right", 64, 64);

          case "left":
            return mbicon("skim_left", 64, 64);

          case "start":
            return mbicon("skim_left_stop", 64, 64);

          case "end":
            return mbicon("skim_right_stop", 64, 64);

          default:
            return !1;
        }
    }
    function tocBar(headinfo, context) {
        var title = fdjtDOM("a.mbtoc_sectname", headinfo.title), elements = fdjtDOM("div.mbtoc_elements"), tocbar = fdjtDOM("div.mbtoc", fdjtDOM("div.mbtoc_text", context && context.cloneNode(!0), title), elements), start = headinfo.starts_at, end = headinfo.ends_at, sectlen = end - start;
        if (headinfo.sub && headinfo.sub.length) {
            var sub = headinfo.sub, s = 0, smax = sub.length;
            for (addClass(tocbar, "mbtocbranch"); smax > s; ) {
                var subsect = sub[s++], brick = fdjtDOM("a.mbtoc_sectbrick"), left = subsect.starts_at, size = subsect.ends_at - left;
                brick.name = "MBTOC4" + subsect.frag, brick.style.left = 100 * ((left - start) / sectlen) + "%", 
                brick.style.width = 100 * (size / sectlen) + "%", subsect.title && (brick.title = subsect.title), 
                elements.appendChild(brick);
            }
        }
        var parent = headinfo.head, rel_start = headinfo.starts_at - parent.starts_at, outer_length = parent.ends_at - parent.starts_at, inner_length = headinfo.ends_at - headinfo.starts_at, showsize = fdjtDOM("a.mbtoc_showsize");
        return addClass(tocbar, "mbtocleaf"), showsize.style.width = 100 * (inner_length / outer_length) + "%", 
        showsize.style.left = 100 * (rel_start / outer_length) + "%", elements.appendChild(fdjtDOM("div.mbtoc_posbar")), 
        elements.appendChild(showsize), tocbar.id = "MBTOC4" + headinfo.frag, tocbar.setAttribute("name", "MBTOC4" + headinfo.frag), 
        tocbar.setAttribute("data-passage", headinfo.frag), tocbar.setAttribute("data-location", headinfo.starts_at), 
        tocbar.setAttribute("data-level", headinfo.toclevel), addClass(tocbar, "mbtoc" + headinfo.toclevel), 
        tocbar;
    }
    function maketoc(slice, headinfo, context) {
        var bar = headinfo.toclevel && tocBar(headinfo, context), card = bar && {
            dom: bar,
            about: headinfo,
            id: headinfo._id,
            head: headinfo.frag,
            passage: headinfo._id,
            location: headinfo.starts_at
        };
        if (card && (slice.addCards([ card ]), slice.container.appendChild(bar)), context = fdjtDOM("span.context", fdjtDOM("span.tocpath", "§", headinfo.title)), 
        headinfo.sub && headinfo.sub.length) for (var sub = headinfo.sub, s = 0, slim = sub.length; slim > s; ) maketoc(slice, sub[s++], context);
        return slice;
    }
    function MetaBookTOC(rootinfo, dom) {
        return this instanceof MetaBookTOC ? (MetaBookSlice.call(this, dom), maketoc(this, rootinfo), 
        this) : new MetaBookTOC(rootinfo, dom);
    }
    var fdjtDOM = fdjt.DOM, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, $ = fdjtDOM.$, MetaBookSlice = metaBook.Slice, mbicon = metaBook.icon;
    return metaBook.navicon = navicon, MetaBookTOC.prototype = new MetaBookSlice(), 
    MetaBookTOC.setHead = function(headinfo) {
        if (dropClass($(".mblivetoc"), "mblivetoc"), dropClass($(".mbcurtoc"), "mbcurtoc"), 
        headinfo) {
            for (var head = headinfo; head; ) {
                for (var refs = document.getElementsByName("MBTOC4" + head.frag), j = 0, jlim = refs.length; jlim > j; ) {
                    var ref = refs[j++];
                    addClass(ref, "mblivetoc"), head === headinfo && addClass(ref, "mbcurtoc");
                }
                head = head.head;
            }
            var toc = metaBook.slices.statictoc;
            if (toc) {
                var info = toc.byfrag[headinfo.frag];
                info && toc.setSkim(info.dom);
            }
        }
    }, MetaBookTOC.prototype.mode = "statictoc", metaBook.TOC = MetaBookTOC, MetaBookTOC;
}(), metaBook.setMode = function() {
    "use strict";
    function initHUD() {
        function messageHandler(evt) {
            var origin = evt.origin;
            return Trace.messages && fdjtLog("Got a message from %s with payload %j", origin, evt.data), 
            0 !== origin.search(/https:\/\/[^\/]+.(bookhub\.io|metabooks\.net)/) ? (fdjtLog.warn("Rejecting insecure message from %s: %s", origin, evt.data), 
            void 0) : ("sbooksapp" === evt.data ? setMode("sbooksapp") : "metabooksapp" === evt.data ? setMode("sbooksapp") : "loggedin" === evt.data ? mB.user || mB.userSetup() : "string" == typeof evt.data && 0 === evt.data.search("setuser=") ? mB.user || (metaBook.userinfo = JSON.parse(evt.data.slice(8)), 
            mB.loginUser(mB.userinfo), "login" === mB.mode && setMode("cover"), mB.userSetup()) : evt.data.updateglosses ? mB.updateInfo() : evt.data.addlayer ? mB.updateInfo() : evt.data.droplayer || evt.data.hidelayer || evt.data.showlayer ? mB.refreshOffline() : evt.data.userinfo ? mB.user || (metaBook.userinfo = evt.data.userinfo, 
            mB.loginUser(mB.userinfo), "login" === mB.mode && setMode("cover"), mB.userSetup()) : evt.data && fdjtDOM("METABOOKINTRO", evt.data), 
            void 0);
        }
        if (!$ID("METABOOKHUD")) {
            var started = fdjtTime(), messages = fdjtDOM("div#METABOOKSTARTUPMESSAGES.startupmessages");
            messages.innerHTML = fixStaticRefs(metaBook.HTML.messages), Trace.startup > 2 && fdjtLog("Initializing HUD layout"), 
            metaBook.HUD = metaBookHUD = hud = fdjtDOM("div#METABOOKHUD.metabookhud"), hud.innerHTML = fixStaticRefs(mB.HTML.hud), 
            hud.metabookui = !0, fdjtDOM.append(messages), $ID("METABOOKFRAME") ? frame = $ID("METABOOKFRAME") : (frame = fdjtDOM("div#METABOOKFRAME"), 
            !mB.dontanimate && mB.getConfig("animatehud") && addClass(frame, "_ANIMATE"), fdjtDOM.prepend(document.body, frame)), 
            addClass(frame, "metabookframe"), addClass(frame, "tapholdcontext"), frame.appendChild(messages), 
            frame.appendChild(hud), mB.getConfig("uisize") && addClass(frame, "metabookuifont" + mB.getConfig("uisize")), 
            metaBook.Frame = frame;
            var hudhelp = $ID("METABOOKHUDHELP");
            hudhelp.innerHTML = fixStaticRefs(mB.HTML.hudhelp);
            var helptext = $ID("METABOOKAPPHELP");
            helptext.innerHTML = fixStaticRefs(mB.HTML.help);
            var heart = $ID("METABOOKHEARTBODY");
            heart.innerHTML = fixStaticRefs(mB.HTML.heart), metaBook.DOM.heart = heart;
            var gloss_attach = $ID("METABOOKGLOSSATTACH");
            gloss_attach.innerHTML = fixStaticRefs(mB.HTML.attach), metaBook.DOM.heart = heart, 
            metaBook.DOM.head = $ID("METABOOKHEAD"), metaBook.DOM.heart = $ID("METABOOKHEARTBODY"), 
            metaBook.DOM.foot = $ID("METABOOKFOOT"), metaBook.DOM.tabs = $ID("METABOOKTABS"), 
            metaBook.DOM.noteshud = $ID("METABOOKNOTETEXT"), metaBook.DOM.asidehud = $ID("METABOOKASIDE"), 
            metaBook.DOM.pagebar = $ID("METABOOKPAGEBAR");
            var search = $ID("METABOOKSEARCH");
            search.innerHTML = fixStaticRefs(mB.HTML.searchbox), addClass(mB.HUD, "emptysearch");
            var addgloss = $ID("METABOOKADDGLOSSPROTOTYPE");
            if (addgloss.innerHTML = fixStaticRefs(mB.HTML.addgloss), metaBook.UI.addHandlers(hud, "hud"), 
            Trace.startup > 1 && fdjtLog("Created basic HUD in %dms", fdjtTime() - started), 
            !mB.svg) {
                var images = fdjtDOM.getChildren(hud, "img"), i = 0, lim = images.length;
                for (Trace.startup && fdjtLog("Switching images to SVG"); lim > i; ) {
                    var img = images[i++];
                    img.src && (hasSuffix(img.src, ".svg") || hasSuffix(img.src, ".svgz")) && img.getAttribute("bmp") && (img.src = img.getAttribute("bmp"));
                }
            }
            metaBook.hudtick = fdjtTime(), fdjtDOM.setInputs(".metabookrefuri", mB.refuri), 
            fdjtDOM.setInputs(".metabookdocuri", mB.docuri), fdjtDOM.setInputs(".metabooktopuri", mB.topuri), 
            metaBook.DOM.allglosses = $ID("METABOOKALLGLOSSES"), Trace.startup > 2 && mB.DOM.allglosses && fdjtLog("Setting up gloss UI %o", allglosses), 
            metaBook.slices.allglosses = allglosses = new mB.Slice(mB.DOM.allglosses), metaBook.slices.allglosses.mode = "allglosses", 
            metaBook.glossdb.onAdd("maker", function(f, p, v) {
                mB.sourcedb.ref(v).oninit(mB.UI.addGlossSource, "newsource");
            }), metaBook.glossdb.onAdd("sources", function(f, p, v) {
                mB.sourcedb.ref(v).oninit(mB.UI.addGlossSource, "newsource");
            }), metaBook.glossdb.onLoad(addGloss2UI), Trace.messages && fdjtLog("Setting up message listener"), 
            fdjtDOM.addListener(window, "message", messageHandler), metaBook.TapHold.foot = new fdjtUI.TapHold(metaBook.DOM.foot, {
                override: !0,
                holdfast: !0,
                taptapmsecs: 0,
                holdmsecs: 150,
                minswipe: 0
            }), metaBook.TapHold.head = new TapHold(mB.DOM.head, {
                override: !0,
                taptapmsecs: 0,
                holdmsecs: 200
            }), metaBook.DOM.skimmer = $ID("METABOOKSKIMMER"), metaBook.TapHold.skimmer = new TapHold(mB.DOM.skimmer, {
                taptapmsecs: 300
            }), metaBook.DOM.sources = $ID("METABOOKSOURCES"), metaBook.TapHold.sources = new TapHold(mB.DOM.sources, {
                taptapmsecs: 300
            });
            var help = mB.DOM.help = $ID("METABOOKHELP");
            help.innerHTML = fixStaticRefs(mB.HTML.help);
            var dom_gloss_cloud = $ID("METABOOKGLOSSCLOUD");
            metaBook.gloss_cloud = new fdjtUI.Completions(dom_gloss_cloud, $ID("METABOOKADDTAGINPUT"), fdjtUI.FDJT_COMPLETE_OPTIONS | fdjtUI.FDJT_COMPLETE_CLOUD | fdjtUI.FDJT_COMPLETE_ANYWORD), 
            metaBook.TapHold.gloss_cloud = new TapHold(mB.gloss_cloud.dom), metaBook.empty_cloud = new fdjtUI.Completions($ID("METABOOKALLTAGS"), !1, fdjtUI.FDJT_COMPLETE_OPTIONS | fdjtUI.FDJT_COMPLETE_CLOUD | fdjtUI.FDJT_COMPLETE_ANYWORD), 
            mB.adjustCloudFont && (metaBook.empty_cloud.updated = function() {
                mB.adjustCloudFont(this);
            }), metaBook.DOM.empty_cloud = $ID("METABOOKALLTAGS"), metaBook.TapHold.empty_cloud = new TapHold(mB.empty_cloud.dom);
            var dom_share_cloud = $ID("METABOOKSHARECLOUD");
            metaBook.share_cloud = new fdjtUI.Completions(dom_share_cloud, $ID("METABOOKADDSHAREINPUT"), fdjtUI.FDJT_COMPLETE_OPTIONS | fdjtUI.FDJT_COMPLETE_CLOUD | fdjtUI.FDJT_COMPLETE_ANYWORD), 
            metaBook.DOM.share_cloud = dom_share_cloud, metaBook.TapHold.share_cloud = new TapHold(mB.share_cloud.dom), 
            fdjtDOM.setupCustomInputs($ID("METABOOKHUD")), Trace.startup > 1 && fdjtLog("Initialized basic HUD in %dms", fdjtTime() - started);
        }
    }
    function resizeHUD() {
        fdjt.DOM.adjustFonts(mB.HUD);
    }
    function addGloss2UI(item) {
        if (item.frag) {
            if (!mbID(item.frag)) return fdjtLog("Gloss (add2UI) refers to nonexistent '%s': %o", item.frag, item), 
            void 0;
            var addGlossmark = mB.UI.addGlossmark;
            !item.maker && mB.user && (item.maker = mB.user), allglosses.addCards(item);
            var nodes = mB.getDups(item.frag);
            addClass(nodes, "glossed");
            for (var i = 0, lim = nodes.length; lim > i; ) addGlossmark(nodes[i++], item);
            if (item.excerpt) {
                var range = mB.findExcerpt(nodes, item.excerpt, item.exoff);
                range && fdjtUI.Highlight(range, "mbexcerpt", item.note, {
                    "data-glossid": item._id
                });
            }
            if (item.tags) for (var gloss_cloud = mB.gloss_cloud, tags = item.tags, j = 0, n_tags = tags.length; n_tags > j; ) mB.cloudEntry(tags[j++], gloss_cloud);
            item.tstamp > mB.syncstamp && (metaBook.syncstamp = item.tstamp);
        } else fdjtLog.warn("Warning: skipping gloss %o with no fragment identifier", item.uuid);
    }
    function setupTOC(root_info) {
        var panel = fdjtDOM("div#METABOOKSTATICTOC.metabookslice.mbtocslice.hudpanel");
        fdjtDOM.replace("METABOOKSTATICTOC", panel);
        var tocslice = new MetaBookTOC(root_info, panel);
        return metaBook.tocslice = tocslice, metaBook.slices.statictoc = tocslice, metaBook.setupGestures(panel), 
        tocslice;
    }
    function setHUD(flag, clearmode) {
        if (clearmode === void 0 && (clearmode = !0), (Trace.gestures || Trace.mode) && fdjtLog("setHUD(%s) %o mode=%o hudup=%o bc=%o hc=%o", clearmode ? "clearmode" : "keepmode", flag, mB.mode, mB.hudup, document.body.className, hud.className), 
        flag) metaBook.hudup = !0, dropClass(document.body, /\b(openhud|openglossmark)\b/g), 
        dropClass(document.body, "mbSHOWHELP"), addClass(document.body, "hudup"), mB.mode || addClass(document.body, "mbNOMODE"); else {
            if (metaBook.hudup = !1, mB.previewing && mB.stopPreview("setHUD"), dropClass(document.body, "mbSHRINK"), 
            clearmode) {
                if (mB.popmode) {
                    var fn = mB.popmode;
                    mB.popmode = !1, fn();
                }
                dropClass(hud, "openheart"), dropClass(hud, "openhead"), dropClass(hud, "full"), 
                dropClass(hud, metaBookModes), dropClass(mB.menu, metaBookModes), dropClass(document.body, "mbSKIMMING"), 
                dropClass(document.body, "mbSKIMSTART"), dropClass(document.body, "mbSKIMEND"), 
                addClass(document.body, "mbNOMODE"), metaBook.skimming = !1, mB.mode && 0 > mB.mode.search(metaBookCoverModes) && (mB.mode = !1);
            }
            dropClass(document.body, "hudup"), dropClass(document.body, "openhud"), mB.focusBody();
        }
    }
    function showCover() {
        mB._started && fdjtState.dropLocal("mB(" + mB.docid + ").opened"), setHUD(!1), metaBook.closed = !0, 
        mB.covermode && (addClass(mB.cover, mB.covermode), metaBook.mode = metaBook.covermode), 
        addClass(document.body, "mbCOVER");
    }
    function hideCover() {
        mB._started && fdjtState.setLocal("mB(" + mB.docid + ").opened", fdjtTime()), metaBook.closed = !1, 
        dropClass(document.body, "mbCOVER"), mB.mode && (metaBook.covermode = mB.mode, metaBook.mode = !1, 
        metaBook.cover.className = "");
    }
    function toggleCover() {
        hasClass(document.body, "mbCOVER") ? hideCover() : showCover();
    }
    function setMode(mode, nohud) {
        var mode_focus, mode_input, oldmode = mB.mode;
        if (mode === void 0) return oldmode;
        if ("last" === mode && (mode = mB.last_mode), !mode && mB.mode && mB.mode.search(metaBookPopModes) >= 0 && (mode = mB.last_mode), 
        "none" === mode && (mode = !1), "heart" === mode && (mode = mB.heart_mode || "statictoc"), 
        Trace.mode && fdjtLog("setMode %o, cur=%o dbc=%o", mode, mB.mode, document.body.className), 
        mode !== mB.mode && mB.previewing && mB.stopPreview("setMode"), mode !== mB.mode && mB.popmode) {
            var fn = mB.popmode;
            mB.popmode = !1, fn();
        }
        if ("layers" !== mode || $ID("BOOKHUBAPP").src || mB.appinit || mB.initIFrameApp(), 
        "addgloss" === mB.mode && "addgloss" !== mode && hasClass("METABOOKLIVEGLOSS", "modified") && mB.submitGloss($ID("METABOOKLIVEGLOSS")), 
        mode ? dropClass(document.body, "mbNOMODE") : addClass(document.body, "mbNOMODE"), 
        mode) {
            if ("search" === mode && (mode = mB.search_mode || "refinesearch"), "addgloss" === mode || dropClass(document.body, "mbSHRINK"), 
            mode === !0) mB.hideCover(), metabook_mode_foci[mB.mode] && (mode_focus = metabook_mode_foci[mB.mode], 
            mode_input = mode_focus.search(/[.#]/) >= 0 ? fdjtDOM.$1(mode_focus) : $ID(mode_focus), 
            mode_input.blur()), dropClass(hud, metaBookModes), dropClass(mB.menu, metaBookModes), 
            metaBook.mode = !1, metaBook.last_mode = !0; else {
                if ("string" != typeof mode) throw Error("mode arg not a string");
                if (mode.search(metaBookCoverModes) >= 0) {
                    var cover = fdjt.ID("METABOOKCOVER");
                    return "login" === mode && addClass(document.documentElement, "_SHOWLOGIN"), "cover" === mode && (mode = cover.getAttribute("data-defaultclass") || "help"), 
                    mode !== mB.mode && (cover.className = mode, metaBook.mode = mode, metaBook.modechange = fdjtTime()), 
                    "console" === mode && fdjtLog.update(), showCover(), void 0;
                }
                mode === mB.mode || (mB.hideCover(), metaBook.modechange = fdjtTime(), metabook_mode_foci[mB.mode] && (mode_focus = metabook_mode_foci[mB.mode], 
                mode_input = mode_focus.search(/[.#]/) >= 0 ? fdjtDOM.$1(mode_focus) : $ID(mode_focus), 
                mode_input.blur()), mode !== mB.mode && (metaBook.last_mode = mB.mode), metaBook.mode = mode);
            }
            "sbooksapp" !== mode || $ID("BOOKHUBAPP").src || mB.appinit || initIFrameApp(), 
            ("refinesearch" === mode || "searchresults" === mode || "expandsearch" === mode) && (metaBook.search_mode = mode), 
            "addgloss" === mode ? addClass(document.body, "openhud") : "openglossmark" === mode ? (addClass(document.body, "openhud"), 
            addClass(document.body, "openglossmark")) : nohud || setHUD(!0), mode === !0 ? (dropClass(hud, "openhead"), 
            dropClass(hud, "openheart"), fdjtDOM.swapClass(hud, metaBookModes, "minimal"), fdjtDOM.swapClass(mB.menu, metaBookModes, "minimal")) : "addgloss" === mode ? (addClass(hud, "openhead"), 
            dropClass(hud, "openheart")) : (0 > mode.search(metabookHeartModes) && dropClass(hud, "openheart"), 
            0 > mode.search(metabookHeadModes) && dropClass(hud, "openhead"), mode.search(metabookHeartModes) >= 0 && (metaBook.heart_mode = mode, 
            addClass(hud, "openheart")), mode.search(metabookHeadModes) >= 0 && (metaBook.head_mode = mode, 
            addClass(hud, "openhead"))), changeMode(mode);
        } else {
            if (metaBook.last_mode = mB.mode, hasClass(document.body, "mbCOVER") && hideCover(), 
            "openglossmark" === mB.mode && $ID("METABOOKOPENGLOSSMARK") && ($ID("METABOOKOPENGLOSSMARK").id = "", 
            dropClass(document.body, "openglossmark")), mB.textinput && mB.setFocus(!1), mB.focusBody(), 
            mB.skimpoint) {
                var dups = mB.getDups(mB.target);
                mB.clearHighlights(dups), dropClass(dups, "mbhighlightpassage");
            }
            dropClass(hud, "openheart"), dropClass(hud, "openhead"), dropClass(document.body, "dimmed"), 
            dropClass(document.body, "mbSHOWHELP"), dropClass(document.body, "mbPREVIEW"), dropClass(document.body, "mbSHRINK"), 
            dropClass(hud, metaBookModes), dropClass(mB.menu, metaBookModes), metaBook.cxthelp = !1, 
            display_sync && mB.displaySync(), nohud ? mB.setHUD(!1) : setHUD(!1);
        }
    }
    function changeMode(mode) {
        if (Trace.mode && fdjtLog("changeMode %o, cur=%o dbc=%o", mode, mB.mode, document.body.className), 
        dropClass(mB.menu, metaBookModes), dropClass(hud, metaBookModes), addClass(hud, mode), 
        addClass(mB.menu, mode), "openglossmark" !== mode && "openglossmark" === mB.mode && ($ID("METABOOKOPENGLOSSMARK") && ($ID("METABOOKOPENGLOSSMARK").id = ""), 
        dropClass(document.body, "openglossmark")), "statictoc" === mode) {
            var headinfo = mB.head && mB.head.id && mB.docinfo[mB.head.id], static_head = $ID("MBTOC4" + headinfo.frag), toc = fdjt.ID("METABOOKSTATICTOC");
            hasClass(toc, "mbsyncslice") && (fdjt.showPage.check(toc), 0 === static_head.offsetHeight && fdjt.showPage.showNode(toc, static_head));
        } else if (mB.slices[mode]) {
            var curloc = mB.location, slice = mB.slices[mode], slicediv = slice.container;
            slice.setLive(!0), hasClass(slicediv, "mbsyncslice") && slice.setLocation(curloc);
        } else mB.pagers[mode] && fdjt.showPage.check(mB.pagers[mode]);
        if (metabook_mode_foci[mode]) {
            var mode_focus = metabook_mode_foci[mB.mode], mode_input = mode_focus.search(/[.#]/) >= 0 ? fdjtDOM.$1(mode_focus) : $ID(mode_focus);
            !mode_input || mB.touch && !hasParent(mode_input, mB.DOM.foot) || setTimeout(function() {
                mB.setFocus(mode_input);
            }, 50);
        } else if ("addgloss" === mode && mB.glossform) {
            var glossform = mB.glossform, curglossmode = mB.getGlossMode(glossform);
            mB.setGlossMode(curglossmode, glossform);
        } else setTimeout(mB.focusBody, 50);
        mB.slices[mode] && mB.slices[mode].setLive(!0), display_sync && mB.displaySync();
    }
    function toggleMode(mode, keephud) {
        mB.mode ? mode === mB.mode ? keephud ? setMode(!0) : setMode(!1) : "heart" === mode && 0 === mB.mode.search(metabookHeartModes) ? keephud ? setMode(!0) : setMode(!1) : setMode(mode) : setMode(mode);
    }
    function initIFrameApp() {
        if (!iframe_app_init && !mB.appinit) {
            var query = "";
            document.location.search && (query += "?" === document.location.search[0] ? document.location.search.slice(1) : document.location.search), 
            query.length && "&" !== query[query.length - 1] && (query += "&");
            var refuri = mB.refuri, appuri = "https://" + mB.server + "/flyleaf?" + query;
            0 > query.search("REFURI=") && (appuri = appuri + "REFURI=" + encodeURIComponent(refuri)), 
            0 > query.search("TOPURI=") && (appuri = appuri + "&TOPURI=" + encodeURIComponent(document.location.href)), 
            document.title && (appuri = appuri + "&DOCTITLE=" + encodeURIComponent(document.title)), 
            mB.user && (appuri = appuri + "&BOOKUSER=" + encodeURIComponent(mB.user._id)), document.location.hash && (appuri = appuri + "&HASH=" + document.location.hash.slice(1));
            var app = $ID("BOOKHUBAPP");
            app.src = appuri, iframe_app_init = !0;
        }
    }
    function stopSkimming() {
        var skimming = mB.skimpoint;
        skimming && ((Trace.skimming || Trace.flips) && fdjtLog("stopSkimming() %o", skimming), 
        mB.skimming && (dropClass(document.body, "mbSKIMMING"), mB.skimming = !1, getParent(skimming, $ID("METABOOKALLGLOSSES")) ? setMode("allglosses") : getParent(skimming, $ID("METABOOKSTATICTOC")) ? setMode("statictoc") : getParent(skimming, $ID("METABOOKSEARCHRESULTS")) && setMode("searchresults")));
    }
    function metaBookSkimTo(card, dir, hudup) {
        var skimmer = $ID("METABOOKSKIMMER"), skimpoint = mB.skimpoint, slice = getSlice(card);
        if (!slice) return fdjtLog.warn("Can't determine slice for skimming to %o", card), 
        void 0;
        var cardinfo = slice.getInfo(card);
        if (!cardinfo) return fdjtLog.warn("No info for skimming to %s in %s", card, slice), 
        void 0;
        card = cardinfo.dom || card, slice.mode && mB.mode !== slice.mode && setMode(slice.mode);
        var passage = mbID(cardinfo.passage || cardinfo.id);
        if ("number" != typeof dir && (dir = 0), hasParent(card, mB.DOM.allglosses) ? metaBook.skimming = mB.slices.allglosses : hasParent(card, $ID("METABOOKSEARCHRESULTS")) ? metaBook.skimming = mB.slices.searchresults : hasParent(card, $ID("METABOOKSTATICTOC")) ? metaBook.skimming = mB.slices.statictoc : mB.skimming = !0, 
        (Trace.mode || Trace.skimming) && fdjtLog("metaBookSkim() %o (card=%o) mode=%o scn=%o/%o dir=%o", passage, card, mB.mode, mB.skimpoint, mB.target, dir), 
        skimpoint !== card) {
            var clone = card.cloneNode(!0);
            clone.id = "METABOOKSKIM", fdjtDOM.replace("METABOOKSKIM", clone), clone.offsetHeight > skimmer.offsetHeight ? addClass(skimmer, "oversize") : dropClass(skimmer, "oversize");
            slice.setSkim(card), $ID("MBPAGELEFT").innerHTML = slice.atStart ? "" : "<span>-" + slice.skimpos + "</span>", 
            $ID("MBPAGERIGHT").innerHTML = slice.atEnd ? "" : "<span>" + (slice.visible.length - slice.skimpos - 1) + "+</span>", 
            skimpoint && dropClass(skimpoint, "skimpoint"), card && addClass(card, "skimpoint"), 
            metaBook.skimpoint = card;
        }
        skimMode(slice), hudup !== void 0 && setHUD(hudup, !1), mB.GoTo(passage, "Skim"), 
        setSkimTarget(passage), highlightSkimTarget(passage, card);
    }
    function skimMode(slice) {
        var body = document.body, skimmer = $ID("METABOOKSKIMMER");
        addClass(body, "mbSKIMMING"), slice.atEnd ? addClass(body, "mbSKIMEND") : dropClass(body, "mbSKIMEND"), 
        slice.atStart ? addClass(body, "mbSKIMSTART") : dropClass(body, "mbSKIMSTART"), 
        dropClass(skimmer, "mbfoundhighlights");
    }
    function setSkimTarget(passage) {
        mB.target && mB.clearHighlights(mB.getDups(mB.target)), mB.setTarget(passage);
    }
    function highlightSkimTarget(passage, card) {
        var highlights = [];
        if (card && hasClass(card, "gloss")) {
            var glossinfo = mB.glossdb.ref(card.name);
            if (glossinfo.excerpt) {
                var searching = mB.getDups(passage.id), range = mB.findExcerpt(searching, glossinfo.excerpt, glossinfo.exoff);
                range && (highlights = fdjtUI.Highlight(range, "mbhighlightexcerpt"), addClass("METABOOKSKIMMER", "mbfoundhighlights"));
            } else "#" === card.about[0] ? addClass(mB.getDups(card.about.slice(1)), "mbhighlightpassage") : addClass(mB.getDups(card.about), "mbhighlightpassage");
        } else if (card && getParent(card, ".searchslice")) {
            var about = card.about, target = mbID(about);
            if (target) {
                var info = mB.docinfo[target.id], terms = mB.query.tags, spellings = info.knodeterms, i = 0, lim = terms.length;
                if (0 === lim) addClass(mB.getDups(target), "mbhighlightpassage"); else for (;lim > i; ) {
                    var term = terms[i++], h = mB.highlightTerm(term, target, info, spellings);
                    highlights = highlights.concat(h);
                }
            }
        }
    }
    function getSlice(card) {
        var cur_slice = mB.slices[mB.mode];
        return cur_slice && cur_slice.getInfo(card) ? cur_slice : card.nodeType ? hasParent(card, mB.DOM.allglosses) ? mB.slices.allglosses : hasParent(card, $ID("METABOOKSEARCHRESULTS")) ? mB.searchresults : !1 : "string" == typeof card ? mB.glossdb.probe(card) ? mB.slices.allglosses : mB.docinfo[card] ? mB.slices.statictoc : !1 : !1;
    }
    function keyboardHelp(arg, force) {
        if (arg === !0) return mB.keyboardHelp.timer && (clearTimeout(mB.keyboardHelp.timer), 
        mB.keyboardHelp.timer = !1), dropClass("METABOOKKEYBOARDHELPBOX", "closing"), dropClass("METABOOKKEYBOARDHELPBOX", "closed"), 
        void 0;
        if (arg === !1) return mB.keyboardHelp.timer && (clearTimeout(mB.keyboardHelp.timer), 
        mB.keyboardHelp.timer = !1), addClass("METABOOKKEYBOARDHELPBOX", "closed"), dropClass("METABOOKKEYBOARDHELPBOX", "closing"), 
        void 0;
        if ((force || mB.keyboardhelp) && ("string" == typeof arg && (arg = $ID(arg)), arg && arg.nodeType)) {
            var box = $ID("METABOOKKEYBOARDHELPBOX"), content = arg.cloneNode(!0);
            content.id = "METABOOKKEYBOARDHELP", fdjtDOM.replace("METABOOKKEYBOARDHELP", content), 
            fdjtDOM.dropClass(box, "closed"), metaBook.keyboardHelp.timer = setTimeout(function() {
                fdjtDOM.addClass(box, "closing"), metaBook.keyboardHelp.timer = setTimeout(function() {
                    metaBook.keyboardHelp.timer = !1, fdjtDOM.swapClass(box, "closing", "closed");
                }, 5e3);
            }, 5e3);
        }
    }
    var fdjtString = fdjt.String, fdjtTime = fdjt.Time, fdjtState = fdjt.State, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, $ID = fdjt.ID, TapHold = fdjtUI.TapHold, mbID = metaBook.ID, mB = metaBook, Trace = mB.Trace, MetaBookTOC = mB.TOCSlice, display_sync = !1, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, hasClass = fdjtDOM.hasClass, getParent = fdjtDOM.getParent, hasParent = fdjtDOM.hasParent, hasSuffix = fdjtString.hasSuffix, fixStaticRefs = mB.fixStaticRefs, metaBookHUD = !1, frame = !1, hud = !1, allglosses = !1;
    metaBook.initHUD = initHUD, metaBook.resizeHUD = resizeHUD, metaBook.addGloss2UI = addGloss2UI, 
    metaBook.setupTOC = setupTOC, metaBook.setHUD = setHUD, metaBook.showCover = showCover, 
    metaBook.hideCover = hideCover, metaBook.toggleCover = toggleCover;
    var metaBookModes = /\b((search)|(refinesearch)|(expandsearch)|(searchresults)|(openglossmark)|(allglosses)|(context)|(statictoc)|(minimal)|(addgloss)|(gotoloc)|(gotoref)|(gotopage)|(shownote)|(showaside)|(glossdetail))\b/g, metabookHeartModes = /\b((statictoc)|(search)|(refinesearch)|(expandsearch)|(searchresults)|(allglosses)|(showaside)|(glossaddtag)|(glossaddtag)|(glossaddoutlet)|(glossdetail))\b/g, metabookHeadModes = /\b((search)|(refinesearch)|(expandsearch)|(searchresults)|(allglosses)|(addgloss)|(shownote))\b/g, metaBookPopModes = /\b((glossdetail))\b/g, metaBookCoverModes = /\b((cover)|(help)|(layers)|(login)|(settings)|(cover)|(aboutsbooks)|(aboutmetabooks)|(console)|(aboutbook)|(titlepage))\b/g, metaBookSearchModes = /((refinesearch)|(searchresults)|(expandsearch))/;
    metaBook.searchModes = metaBookSearchModes;
    var metabook_mode_foci = {
        gotopage: "METABOOKPAGEINPUT",
        gotoloc: "METABOOKLOCINPUT",
        gotoref: "METABOOKREFINPUT",
        search: "METABOOKSEARCHINPUT",
        refinesearch: "METABOOKSEARCHINPUT",
        expandsearch: "METABOOKSEARCHINPUT"
    };
    metaBook.toggleMode = toggleMode, metaBook.dropHUD = function() {
        return setMode(!1);
    }, metaBook.toggleHUD = function(evt) {
        evt = evt || window.event, evt && fdjtUI.isClickable(fdjtUI.T(evt)) || (fdjtLog("toggle HUD %o hudup=%o", evt, mB.hudup), 
        mB.hudup ? setHUD(!1, !1) : setHUD(!0));
    };
    var iframe_app_init = !1;
    metaBook.initIFrameApp = initIFrameApp, metaBook.selectApp = function() {
        "sbooksapp" === mB.mode ? setMode(!1) : setMode("sbooksapp");
    }, metaBook.stopSkimming = stopSkimming;
    var rAF = fdjtDOM.requestAnimationFrame;
    return metaBook.SkimTo = function(card, dir) {
        rAF(function() {
            metaBookSkimTo(card, dir);
        });
    }, metaBook.SkimTo = metaBookSkimTo, metaBook.getSlice = getSlice, metaBook.addConfig("uisize", function(name, value) {
        fdjtDOM.swapClass(mB.Frame, /metabookuifont\w+/g, "metabookuifont" + value), fdjt.Async(function() {
            mB.resizeUI();
        }), fdjt.Async(function() {
            mB.updateSettings(name, value);
        });
    }), metaBook.addConfig("dyslexical", function(name, value) {
        var root = document.documentElement || document.body;
        if (value && "string" == typeof value && /yes|on|t/i.exec(value)) {
            if (hasClass(root, "_DYSLEXICAL")) return;
            metaBook.dyslexical = !0, addClass(root, "_DYSLEXICAL");
        } else {
            if (!hasClass(root, "_DYSLEXICAL")) return;
            metaBook.dyslexical = !1, fdjtDOM.dropClass(root, "_DYSLEXICAL");
        }
        fdjt.Async(function() {
            mB.resizeUI(), mB.layout && mB.Paginate("typechange");
        }, 10);
    }), metaBook.addConfig("animatecontent", function(name, value) {
        mB.dontanimate || (value ? addClass(document.body, "_ANIMATE") : dropClass(document.body, "_ANIMATE")), 
        fdjt.Async(function() {
            mB.updateSettings(name, value);
        });
    }), metaBook.addConfig("animatehud", function(name, value) {
        mB.dontanimate || (value ? addClass("METABOOKFRAME", "_ANIMATE") : dropClass("METABOOKFRAME", "_ANIMATE")), 
        fdjt.Async(function() {
            mB.updateSettings(name, value);
        });
    }), metaBook.keyboardHelp = keyboardHelp, metaBook.showGloss = function(uuid) {
        if (!mB.glossdb.ref(uuid)) return !1;
        var elts = document.getElementsByName(uuid);
        if (elts) {
            if (elts.length) {
                for (var hasParent = fdjtDOM.hasParent, i = 0, lim = elts.length; lim > i; ) {
                    var src = elts[i++];
                    if (hasParent(src, allglosses)) return setMode("allglosses"), mB.SkimTo(src), !0;
                }
                return !1;
            }
            return !1;
        }
        return !1;
    }, metaBook.hideHelp = function() {
        fdjtDOM.dropClass(document.body, "mbSHOWHELP");
    }, metaBook.showHelp = function() {
        fdjtDOM.addClass(document.body, "mbSHOWHELP");
    }, setMode;
}(), function() {
    "use strict";
    function scrollPreview(elt, caller) {
        var xoff = window.scrollLeft || 0, yoff = window.scrollTop || 0;
        if (elt) {
            if (elt.frag && (elt = elt.frag), "string" == typeof elt && (elt = mbID(elt)), !elt) return;
            preview_elt = elt, oldscroll || (oldscroll = {
                x: 0,
                y: yoff
            });
            var offinfo = fdjtDOM.getGeometry(elt, mB.content);
            Trace.flips && fdjtLog("startScrollPreview/%s to %d for %o", caller || "nocaller", offinfo.top - 100, elt);
            var use_top = offinfo.top - (fdjtDOM.viewHeight() - 50) / 2;
            0 > use_top && (use_top = 0), window.scrollTo(0, use_top);
        } else oldscroll ? (Trace.flips && fdjtLog("stopScrollPreview/%s to %j from %d,%d(%o)", caller || "nocaller", oldscroll, xoff, yoff, preview_elt), 
        preview_elt = !1, window.scrollTo(oldscroll.x, oldscroll.y), oldscroll = !1) : (Trace.flips && fdjtLog("stopScrollPreview/%s to %j from %d,%d(%o)", caller || "nocaller", oldscroll, xoff, yoff, preview_elt), 
        preview_elt = !1, oldscroll = !1);
    }
    function clearPreview() {
        for (var current = fdjtDOM.$(".mbpreviewing"), i = 0, lim = current.length; lim > i; ) {
            var p = current[i++];
            dropClass(p, "mbpreviewing"), mB.clearHighlights(p);
        }
    }
    function startPreview(spec, caller) {
        var target = spec.nodeType ? spec : mbID(spec);
        if ((Trace.flips || Trace.preview) && fdjtLog("startPreview %o (%s)", target, caller), 
        target === mB.previewing, mB.skimming && mB.stopSkimming(), mB.layout instanceof fdjt.CodexLayout) {
            var dups = getTarget(target) && mB.getDups(target);
            mB.startPagePreview(target, caller), addClass(target, "mbpreviewing"), dups && addClass(dups, "mbpreviewing");
        } else scrollPreview(target, caller), addClass(target, "mbpreviewing");
        return metaBook.previewing = target, addClass(document.body, "mbPREVIEW"), hasClass(target, "codexpage") && addClass(document.body, "mbPAGEPREVIEW"), 
        target;
    }
    function stopPreview(caller, jumpto) {
        return clearPreview(), jumpto && !jumpto.nodeType && (jumpto = mB.previewTarget || mB.previewing), 
        (Trace.flips || Trace.preview) && fdjtLog("stopPreview/%s jump to %o, pt=%o, p=%o", caller || "nocaller", jumpto, mB.previewTarget, mB.previewing), 
        mB.layout instanceof fdjt.CodexLayout ? mB.stopPagePreview(caller, jumpto) : jumpto ? jumpto === mB.previewing ? (oldscroll = !1, 
        scrollPreview(!1, caller)) : scrollPreview(!1, caller) : scrollPreview(!1, caller), 
        mB.previewing = !1, mB.previewTarget = !1, dropClass(document.body, "mbPREVIEW"), 
        dropClass(document.body, "mbPAGEPREVIEW"), jumpto && (mB.hudup && mB.setHUD(!1), 
        mbGoTo(jumpto)), !1;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, hasClass = fdjtDOM.hasClass, mB = metaBook, mbID = mB.ID, getTarget = mB.getTarget, Trace = mB.Trace, mbGoTo = mB.GoTo, oldscroll = !1, preview_elt = !1;
    metaBook.startPreview = startPreview, metaBook.stopPreview = stopPreview;
}(), function() {
    "use strict";
    function resizeUI(wait) {
        function resizing(done) {
            ui_resize_wait && clearTimeout(ui_resize_wait), ui_resize_wait = setTimeout(function() {
                var h = fdjtDOM.viewHeight(), w = fdjtDOM.viewWidth();
                if (w !== ui_width || h !== ui_height) {
                    var adjstart = fdjt.Time(), hud = $ID("METABOOKHUD"), cover = $ID("METABOOKCOVER");
                    ui_height = h, ui_width = w, cover && mB.resizeCover(cover), hud && mB.resizeHUD(hud), 
                    (hud || cover) && fdjtLog("Resized UI in %fsecs, running %d callbacks", (fdjt.Time() - adjstart) / 1e3, ui_resize_done.length);
                }
                var when_done = ui_resize_done;
                ui_resize_wait = !1, ui_resize_done = [];
                for (var i = 0, n = when_done.length; n > i; ) when_done[i++]();
            }, wait), ui_resize_done.push(done);
        }
        return "number" != typeof wait && (wait = 100), new Promise(resizing);
    }
    function metabookResize() {
        var layout = mB.layout;
        if (Trace.resize && fdjtLog("Real resize w/layout=%o", layout), resizing && (clearTimeout(resizing), 
        resizing = !1), updateSizeClasses(), mB.resizeUI(), mB.sizeContent(), layout && mB.scaleLayout(!1), 
        mB.touch && (mB.textinput || document.activeElement && ("INPUT" === document.activeElement.tagName || "TEXTAREA" === document.activeElement.tagName || document.activeElement.isContentEditable))) return Trace.resize && fdjtLog("Resize for soft keyboard, mostly ignoring"), 
        void 0;
        if (window.outerWidth === outer_width && window.outerHeight === outer_height) return layout && metaBook.scaleLayout(!0), 
        Trace.resize && fdjtLog("Resize to norm, ignoring"), void 0;
        resizePagers(), outer_width = window.outerWidth, outer_height = window.outerHeight;
        var width = getGeometry($ID("CODEXPAGE"), !1, !0).width, height = getGeometry($ID("CODEXPAGE"), !1, !0).inner_height;
        if (layout && layout.width === width && layout.height === height) return Trace.resize && fdjtLog("Layout size unchanged, ignoring"), 
        void 0;
        if (layout && layout.onresize && !metaBook.freezelayout) if (metaBook.long_layout_thresh && layout.started && metaBook.long_layout_thresh >= layout.done - layout.started) resizing = setTimeout(resizeNow, 50); else if (choosing_resize) ; else if (metaBook.layoutCached()) resizing = setTimeout(resizeNow, 50); else {
            var msg = fdjtDOM("div.title", "Update layout?");
            metaBook.scaleLayout(!0), choosing_resize = !0;
            var choices = [ {
                label: "Yes",
                handler: function() {
                    choosing_resize = !1, resize_default = !0, metaBook.layout_choice_timeout = 10, 
                    resizing = setTimeout(resizeNow, 50);
                },
                isdefault: resize_default
            }, {
                label: "No",
                handler: function() {
                    choosing_resize = !1, resize_default = !1, metaBook.layout_choice_timeout = 10;
                },
                isdefault: !resize_default
            } ], spec = {
                choices: choices,
                timeout: metaBook.layout_choice_timeout || metaBook.choice_timeout || 20,
                spec: "div.fdjtdialog.fdjtconfirm.updatelayout"
            };
            choosing_resize = fdjtUI.choose(spec, msg);
        }
    }
    function resizeNow(evt) {
        resizing && clearTimeout(resizing), resizing = !1, metaBook.layout.onresize(evt);
    }
    function resizePagers() {
        for (var pagers = fdjtDOM.$(".fdjtpage"), i = 0, lim = pagers.length; lim > i; ) {
            var pager = pagers[i++];
            pager.offsetHeight ? showPage.update(pager) : addClass(pager, "needsresize");
        }
    }
    function updateSizeClasses() {
        var addClass = fdjtDOM.addClass, body = document.body, w = fdjtDOM.viewWidth(), h = fdjtDOM.viewHeight();
        fdjtDOM.dropClass(body, sizeclass_regexp), 700 > w ? addClass(body, "_NARROW") : w > 1200 && addClass(body, "_WIDE"), 
        350 > h ? addClass(document.body, "_REALLYSHORT") : 600 > h ? addClass(document.body, "_SHORT") : h > 1200 && addClass(document.body, "_TALL");
    }
    function resizeHandler(evt) {
        evt = evt || window.event, Trace.resize && fdjtLog("Resize event %o, waiting=%o", evt, resize_wait), 
        resize_wait && clearTimeout(resize_wait), choosing_resize && (Trace.resize && fdjtLog("Close resize dialog %o", evt), 
        fdjt.Dialog.close(choosing_resize), choosing_resize = !1), resize_wait = setTimeout(metabookResize, metaBook.resize_wait);
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, $ID = fdjt.ID, addClass = fdjtDOM.addClass, showPage = fdjt.showPage, fdjtUI = fdjt.UI, Trace = metaBook.Trace, mB = metaBook, getGeometry = fdjtDOM.getGeometry, outer_height = window.outerHeight, outer_width = window.outerWidth, resize_default = !1, ui_resize_wait = !1, ui_resize_done = [], ui_width = !1, ui_height = !1;
    metaBook.resizeUI = resizeUI, metaBook.resize = metabookResize;
    var sizeclass_regexp = /\b_(NARROW|WIDE|REALLYSHORT|SHORT|TALL)\b/g;
    metaBook.updateSizeClasses = updateSizeClasses;
    var resizing = !1, resize_wait = !1, choosing_resize = !1;
    metaBook.resizeHandler = resizeHandler;
}(), function() {
    "use strict";
    function addSource(info, withgloss) {
        "string" == typeof info && (info = RefDB.resolve(info));
        var humid = info.humid;
        if (info.name) {
            if (withgloss) {
                var icon = $ID("SBOOKSOURCEICON" + humid);
                if (!icon) {
                    var pic = info._pic || info.pic || info.fbid && "https://graph.facebook.com/" + info.fbid + "/picture?type=square", kind = info.kind;
                    pic || (pic = ":CIRCLE" === kind || info.iscircle ? mbicon("readingcircle", 64, 64) : mbicon("sideguide", 64, 64)), 
                    icon = pic ? fdjtDOM.Image(pic, ".button.source", info.name | info.kind, "click to show/hide glosses from " + info.name) : fdjtDOM("div.button.source", getInitials(info.name));
                    var title = (":CIRCLE" === kind ? "the reading circle " : ":OVERLAY" === kind ? "the reading guide " : "the layer ") + (info.name ? "“" + info.name + "”" : "") + (info.about ? ": " : "") + (info.about ? info.about : "");
                    icon.title = title, icon.oid = info._id, info.name && (icon.alt = getInitials(info.name)), 
                    icon.id = "SBOOKSOURCEICON" + humid, fdjtDOM($ID("METABOOKSOURCES"), " ", icon);
                }
            }
            return info;
        }
    }
    function everyone_ontap(evt) {
        evt = evt || window.event || null;
        var target = fdjtDOM.T(evt), sources = $ID("METABOOKSOURCES"), glosses = $ID("METABOOKALLGLOSSES");
        if (sources && glosses) {
            if (fdjtDOM.hasClass(target, "selected")) return metaBook.setMode(!1), fdjtDOM.cancel(evt), 
            void 0;
            var selected = fdjtDOM.$(".selected", sources);
            toggleClass(selected, "selected"), addClass(target, "selected"), metaBook.UI.selectSources(metaBook.slices.allglosses, !1), 
            fdjtDOM.cancel(evt);
        }
    }
    function sources_tapped(evt) {
        evt = evt || window.event || null;
        var target = fdjtDOM.T(evt), sources = $ID("METABOOKSOURCES"), glosses = $ID("METABOOKALLGLOSSES"), new_sources = [];
        if (sources && glosses && target && target.oid) {
            var selected = fdjtDOM.$(".selected", sources);
            toggleClass(target, "selected"), evt.shiftKey || dropClass(selected, "selected"), 
            selected = fdjtDOM.$(".selected", sources);
            for (var i = 0, lim = selected.length; lim > i; ) new_sources.push(selected[i++].oid);
            var everyone = fdjtDOM.$(".everyone", sources)[0];
            new_sources.length ? (everyone && dropClass(everyone, "selected"), metaBook.UI.selectSources(metaBook.slices.allglosses, new_sources)) : (everyone && addClass(everyone, "selected"), 
            metaBook.UI.selectSources(metaBook.slices.allglosses, !1)), fdjtDOM.cancel(evt);
        }
    }
    function sources_taptap(evt) {
        evt = evt || window.event || null;
        var target = fdjtDOM.T(evt), sources = $ID("METABOOKSOURCES"), glosses = $ID("METABOOKALLGLOSSES"), new_sources = [];
        if (sources && glosses && target && target.oid) {
            var selected = fdjtDOM.$(".selected", sources);
            toggleClass(target, "selected"), selected = fdjtDOM.$(".selected", sources);
            for (var i = 0, lim = selected.length; lim > i; ) new_sources.push(selected[i++].oid);
            var everyone = fdjtDOM.$(".everyone", sources)[0];
            new_sources.length ? (everyone && dropClass(everyone, "selected"), metaBook.UI.selectSources(metaBook.slices.allglosses, new_sources)) : (everyone && addClass(everyone, "selected"), 
            metaBook.UI.selectSources(metaBook.slices.allglosses, !1)), fdjtDOM.cancel(evt);
        }
    }
    function geticon(source) {
        return source._pic || source.pic || source.fb_pic || source.twitter_pic || source.gplus_pic || source.fbid && "https://graph.facebook.com/" + source.fbid + "/picture?type=square";
    }
    function extendGlossmark(glossmark, glosses, image) {
        var sources = metaBook.sourcedb, glossdb = metaBook.glossdb;
        image || (image = fdjtDOM.getChild(glossmark, ".wedge"));
        var images = image.getAttribute("data-images").split("|");
        1 === images.length && "" === images[0] && (images = []);
        for (var i = 0, lim = glosses.length; lim > i; ) {
            var glossid = glosses[i++];
            if ("string" != typeof glossid && (glossid = glossid._id), glossid) {
                var gloss = glossdb.ref(glossid), cur = glossmark.glosses, maker = gloss.maker && sources.ref(gloss.maker), maker_img = maker && geticon(maker);
                maker_img && images.push(maker_img), cur ? 0 > cur.indexOf(glossid) && cur.push(glossid) : glossmark.glosses = [ glossid ];
                var outlets = gloss.sources || [];
                "string" == typeof outlets && (outlets = [ outlets ]);
                for (var j = 0, jlim = outlets.length; jlim > j; ) {
                    var outlet = sources.ref(outlets[j++]), outlet_img = geticon(outlet);
                    outlet_img && images.push(outlet_img);
                }
            }
        }
        return image.setAttribute("data-images", images.join("|")), glossmark;
    }
    function showGlossmark(target, point) {
        var id = target.codexbaseid || target.id;
        if (id) {
            var dups = metaBook.getDups(id), glossids = metaBook.glossdb.find("frag", id), glosses = [], slicediv = fdjtDOM("div.metabookglosses.metabookslice");
            glossids && glossids.length || addClass(slicediv, "noglosses"), metaBook.target && metaBook.clearHighlights(metaBook.target);
            for (var i = 0, lim = glossids.length; lim > i; ) {
                var glossref = metaBook.glossdb.ref(glossids[i++]);
                glosses.push(glossref);
            }
            for (i = 0; lim > i; ) {
                var gloss = glosses[i++];
                if (gloss.excerpt) {
                    var range = metaBook.findExcerpt(dups, gloss.excerpt, gloss.exoff);
                    if (range) {
                        var starts = range.startContainer;
                        hasClass(starts, "mbhighlightexcerpt") || fdjtUI.Highlight(range, "mbhighlightexcerpt");
                    }
                }
            }
            var slice = new MetaBookSlice(slicediv, glosses, sort_point_glosses), hudwrapper = fdjtDOM("div.hudpanel#METABOOKPOINTGLOSSES", slicediv);
            if (metaBook.openglossmark = slice, point) {
                mB.setMode(!1), hudwrapper.style.display = "block", hudwrapper.style.opacity = 0, 
                $ID("METABOOKPOINTGLOSSES") ? fdjtDOM.replace("METABOOKPOINTGLOSSES", hudwrapper) : mB.body.appendChild(hudwrapper);
                var geom = fdjtDOM.getGeometry(slicediv), wgeom = fdjtDOM.getGeometry(hudwrapper), pgeom = fdjtDOM.getGeometry(point), tgeom = fdjtDOM.getGeometry(target), w = fdjtDOM.viewWidth(), h = fdjtDOM.viewHeight();
                if (metaBook.fullwidth) {
                    var wspec = w - 30 + "px";
                    hudwrapper.style.left = "10px", hudwrapper.style.width = hudwrapper.style.maxWidth = hudwrapper.style.minWidth = wspec;
                } else geom.width > w ? (hudwrapper.style.maxWidth = w - 20 + "px", hudwrapper.style.minWidth = Math.floor(w / 2) + "px", 
                hudwrapper.style.left = "10px") : (geom.height > h / 2 || 500 > w) && (500 > w ? (hudwrapper.style.maxWidth = w - 20 + "px", 
                hudwrapper.style.minWidth = Math.floor(w / 2) + "px", hudwrapper.style.left = "10px") : hudwrapper.style.maxWidth = w - 100 + "px");
                geom = fdjtDOM.getGeometry(slicediv), wgeom = fdjtDOM.getGeometry(hudwrapper), !metaBook.fullwidth && geom.width > w - 50 && (hudwrapper.style.left = "10px");
                var wh = !1;
                wh = geom.height + 15 > h / 2 ? h / 2 : geom.height + 10, !metaBook.fullwidth && wh > 50 && (hudwrapper.style.minHeight = wh + "px"), 
                slicediv.style.overflowX = "hidden", slicediv.style.overflowY = "auto";
                var above_point = pgeom.top - 60, below_point = h - 60 - pgeom.bottom, below_passage = h - 60 - tgeom.bottom;
                pgeom.bottom > tgeom.bottom && (tgeom.bottom = pgeom.bottom + 10), above_point > wh ? hudwrapper.style.top = pgeom.top - (wh + 15) + "px" : below_passage > geom.height ? hudwrapper.style.top = tgeom.bottom + 5 + "px" : below_point > geom.height ? hudwrapper.style.top = pgeom.bottom + 15 + "px" : (metaBook.fullwidth || (hudwrapper.style.right = w - pgeom.left + 10 + "px", 
                hudwrapper.style.left = "50px"), 50 > pgeom.top - h / 4 ? (hudwrapper.style.top = "50px", 
                hudwrapper.style.bottom = "auto", hudwrapper.style.height = h / 2 + "px") : (hudwrapper.style.top = pgeom.top - h / 4 + "px", 
                hudwrapper.style.bottom = "auto", hudwrapper.style.height = h / 2 + "px")), metaBook.fullwidth || 300 > fdjtDOM.viewWidth() && (hudwrapper.style.minWidth = fdjtDOM.viewWidth() - 10 + "px"), 
                hudwrapper.style.display = "", hudwrapper.style.opacity = "";
            } else fdjtDOM.replace("METABOOKPOINTGLOSSES", hudwrapper);
            if (point) {
                var cur = $ID("METABOOKOPENGLOSSMARK");
                cur && (metaBook.target && metaBook.clearHighlights(metaBook.target), cur.id = ""), 
                point.id = "METABOOKOPENGLOSSMARK";
            }
            metaBook.setTarget(target), slice.update(), metaBook.setMode("openglossmark");
        }
    }
    function sort_point_glosses(g1, g2) {
        return g1.location && g2.location ? g1.location > g2.location ? -1 : g2.location > g1.location ? 1 : 0 : g1.exoff && g2.exoff ? g1.exoff > g2.exoff ? -1 : g2.exoff > g1.exoff ? 1 : 0 : g1.created > g2.created ? -1 : g2.created > g1.created ? 1 : 0;
    }
    function clearGlossmark() {
        "openglossmark" === metaBook.mode && metaBook.setMode(!1, !0);
        var slicediv = fdjtDOM("div.metabookglosses.metabookslice"), hudwrapper = fdjtDOM("div.hudpanel#METABOOKPOINTGLOSSES", slicediv);
        fdjtDOM.replace("METABOOKPOINTGLOSSES", hudwrapper);
    }
    var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, RefDB = fdjt.RefDB, $ID = fdjt.ID, getInitials = fdjtString.getInitials, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, hasClass = fdjtDOM.hasClass, toggleClass = fdjtDOM.toggleClass, mbicon = metaBook.icon, mB = metaBook;
    metaBook.UI.addSource = addSource, metaBook.UI.addGlossSource = function(info) {
        addSource(info, !0);
    }, metaBook.UI.handlers.everyone_ontap = everyone_ontap, metaBook.UI.addGlossmark = function(passage, gloss) {
        var Glosses = metaBook.glossdb, current_glossmark = fdjtDOM.getChild(passage, ".glossmark");
        if (current_glossmark && current_glossmark.parentNode === passage) return gloss && extendGlossmark(current_glossmark, [ gloss ]), 
        current_glossmark;
        var imgsrc = mbicon("sbwedge", 64, 64), wedge = fdjtDOM.Image(imgsrc, "wedge", "glosses"), glossmark = fdjtDOM("a.glossmark.fdjtskiptext", wedge), id = passage.getAttribute("data-baseid") || passage.id, glosses = Glosses.find("frag", id);
        return glossmark.title = glosses.length > 1 ? "See " + glosses.length + " glosses on this passage" : "See the gloss on this passage", 
        wedge.defaultsrc = imgsrc, wedge.setAttribute("data-images", ""), extendGlossmark(glossmark, glosses, wedge), 
        metaBook.UI.addHandlers(glossmark, "glossmark"), addClass(passage, "glossed"), fdjtDOM.prepend(passage, glossmark), 
        glossmark.name = "METABOOK_GLOSSMARK_" + id, glossmark;
    };
    var MetaBookSlice = metaBook.Slice;
    metaBook.showGlossmark = showGlossmark, metaBook.clearGlossmark = clearGlossmark;
    var cancel = fdjtUI.cancel;
    fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, {
        "#METABOOKSOURCES": {
            tap: sources_tapped,
            taptap: sources_taptap
        },
        "#METABOOKSOURCES .button.everyone": {
            tap: function(evt) {
                evt = evt || window.event, metaBook.UI.handlers.everyone_ontap(evt), fdjt.UI.cancel(event);
            }
        }
    }), fdjt.DOM.defListeners(metaBook.UI.handlers.touch, {
        "#METABOOKSOURCES": {
            tap: sources_tapped,
            taptap: sources_taptap
        },
        "#METABOOKSOURCES .button.everyone": {
            touchstart: cancel,
            touchend: function(evt) {
                evt = evt || window.event, metaBook.UI.handlers.everyone_ontap(evt), fdjt.UI.cancel(event);
            }
        }
    });
}(), function() {
    "use strict";
    function setQuery(query) {
        if (query = query instanceof Query ? query : new metaBook.Query(query), query === metaBook.query) return query;
        if (Trace.search && log("Setting working query to %o", query), 0 === query.tags.length) return addClass(metaBook.HUD, "emptysearch"), 
        metaBook.empty_cloud.dom.style.fontSize = "", metaBook.search_cloud = metaBook.empty_cloud, 
        fdjtDOM.replace("METABOOKSEARCHCLOUD", fdjtDOM("div#METABOOKSEARCHCLOUD")), fdjtDOM.replace("METABOOKSEARCHRESULTS", fdjtDOM("div.metabookslice.mbsyncslice.searchslice.hudpanel")), 
        displayQuery(query, $ID("METABOOKSEARCH")), metaBook.empty_cloud.complete(""), addClass(metaBook.HUD, "emptysearch"), 
        metaBook.query = mB.empty_query, metaBook.qstring = "", "searchresults" === mB.mode && mB.setMode("refinesearch"), 
        void 0;
        dropClass(metaBook.HUD, "emptysearch"), mB.empty_cloud.complete("");
        var qstring = query.getString();
        return qstring !== metaBook.qstring && (displayQuery(query, $ID("METABOOKSEARCH")), 
        metaBook.query = query, metaBook.qstring = qstring), search_modes.exec(metaBook.mode) && query.results && 0 !== query.results.length && (7 > query.results.length ? showSearchResults() : metaBook.touch || $ID("METABOOKSEARCHINPUT").focus()), 
        query;
    }
    function displayQuery(query, box_arg) {
        box_arg && "string" == typeof box_arg && (box_arg = document.getElementById(box_arg));
        var box = box_arg || query._box || $ID("METABOOKSEARCH"), qstring = query.getString();
        query.dom && box && box !== query.dom && fdjtDOM.replace(box_arg, query.dom), box.setAttribute("qstring", qstring), 
        query.execute();
        var cotags = query.getCoTags(), showtags = query.getRefiners(), input = getChild(box, ".searchinput"), cloudid = input.getAttribute("completions"), infoid = input.getAttribute("info"), qtags = getChild(box, ".qtags") || $ID("METABOOKSEARCHTAGS"), info = infoid && $ID(infoid), resultcount = getChild(info, ".resultcount"), refinecount = getChild(info, ".refinecount");
        input.value = "";
        var elts = query.tags, i = 0, lim = elts.length;
        elts.length ? (fdjtDOM.dropClass(metaBook.HUD, "emptysearch"), fdjtDOM.dropClass("METABOOKSEARCHINFO", "notags")) : (addClass(metaBook.HUD, "emptysearch"), 
        fdjtDOM.dropClass("METABOOKSEARCHINFO", "notags"));
        for (var newtags = fdjtDOM("div.qtags"); lim > i; ) {
            var tag = elts[i];
            "string" == typeof tag && (tag = kbref(tag) || tag);
            var entry = metaBook.cloudEntry(tag, !1, !1, "span.qelt");
            entry.appendChild(fdjtDOM("span.redx", "x")), fdjtDOM(newtags, i > 0 && " · ", entry), 
            i++;
        }
        if (qtags.id && (newtags.id = qtags.id), fdjtDOM.replace(qtags, newtags), 0 === query.tags.length) ; else if (query.results.length) {
            var plural = 1 !== query.results.length;
            resultcount.innerHTML = query.results.length + " <br/>" + (elts.length > 2 ? plural ? "results" : "result" : plural ? "matches" : "match"), 
            fdjtDOM.dropClass([ box, info ], "noresults");
        } else resultcount.innerHTML = "no results", addClass([ box, info ], "noresults");
        newtags.setAttribute("data-maxfont", "120%"), newtags.setAttribute("data-min", "60%"), 
        fdjt.DOM.adjustFontSize(newtags);
        var n_refiners = showtags ? showtags.length : cotags ? cotags.length : 0, completions = metaBook.queryCloud(query);
        return refinecount.innerHTML = n_refiners + " <br/>" + (1 === n_refiners ? "co-tag" : "co-tags"), 
        fdjtDOM.dropClass(box, "norefiners"), completions !== mB.empty_cloud ? (fdjtDOM.replace(cloudid, completions.dom), 
        cloudid && (completions.dom.id = cloudid), addClass(completions.dom, "hudpanel")) : cloudid = "METABOOKALLTAGS", 
        metaBook.search_cloud = completions, Trace.search > 1 && log("Setting search cloud for %o to %o", box, completions.dom), 
        completions.complete("", function() {
            completions.dom.style.fontSize = "", $ID(cloudid) ? fdjtDOM.replace(cloudid, completions.dom) : fdjtDOM.append($ID("METABOOKHEARTBODY"), completions.dom), 
            metaBook.adjustCloudFont(completions);
        }), 0 === n_refiners && (addClass(box, "norefiners"), refinecount.innerHTML = "no refiners"), 
        query._box = box, box.setAttribute("qstring", qstring), query;
    }
    function searchTags_onclick(evt) {
        var target = fdjtUI.T(evt), onx = hasParent(target, ".redx"), qelt = getParent(target, ".qelt");
        if (qelt) {
            fdjtUI.cancel(evt);
            var elt, eltval = qelt.getAttribute("data-value");
            eltval.indexOf("@") >= 0 && (elt = kbref(eltval) || eltval), Trace.gestures && fdjtLog("searchTags_ontap %o: %s%o", evt, onx ? "(onx) " : "", elt);
            var cur = [].concat(metaBook.query.tags), splicepos = elt ? cur.indexOf(elt) : cur.indexOf(eltval);
            0 > splicepos && (splicepos = cur.indexOf(eltval)), 0 > splicepos || (cur.splice(splicepos, 1), 
            0 === cur.length ? (metaBook.empty_cloud.dom.style.fontSize = "", setQuery(metaBook.empty_query)) : setQuery(new metaBook.Query(cur)), 
            fdjtUI.cancel(evt));
        }
    }
    function extendQuery(query, elt) {
        var elts = [].concat(query.tags);
        return "string" == typeof elt ? elt.indexOf("@") >= 0 ? elts.push(kbref(elt) || elt) : elts.push(elt) : elts.push(elt), 
        new metaBook.Query(elts);
    }
    function showSearchResults() {
        var results = metaBook.query.showResults(), results_panel = results.container;
        addClass(results_panel, "hudpanel"), results_panel.id = "METABOOKSEARCHRESULTS", 
        fdjtDOM.replace("METABOOKSEARCHRESULTS", results_panel), mB.slices.searchresults = results, 
        metaBook.setMode("searchresults"), results.update(), $ID("METABOOKSEARCHINPUT").blur(), 
        $ID("METABOOKSEARCHRESULTS").focus();
    }
    function startSearch(tag) {
        setQuery([ tag ]), metaBook.setMode("refinesearch");
    }
    function searchInput_keydown(evt) {
        evt = evt || window.event || null;
        var ch = evt.charCode || evt.keyCode, target = fdjtDOM.T(evt), completeinfo = !1, completions = !1;
        if (13 === ch || 13 === ch || 59 === ch || 93 === ch) {
            var qstring = target.value;
            if (fdjtString.isEmpty(qstring)) showSearchResults(); else {
                completeinfo = metaBook.queryCloud(metaBook.query), completeinfo.timer && (clearTimeout(completeinfo.timer), 
                completeinfo.timer = !1), completions = completeinfo.complete(qstring);
                var completion = completeinfo.selection || completeinfo.select(new Selector(".cue")) || completeinfo.select();
                if (!completion) {
                    var found = metaBook.textindex.termindex[qstring];
                    return found && found.length && setQuery(extendQuery(metaBook.query, qstring)), 
                    void 0;
                }
                var value = completeinfo.getValue(completion);
                setQuery(extendQuery(metaBook.query, value));
            }
            return fdjtDOM.cancel(evt), metaBook.search_gotlucky && metaBook.query.results.length > 0 && metaBook.search_gotlucky >= metaBook.query.results.length ? showSearchResults() : (completeinfo = metaBook.queryCloud(metaBook.query), 
            completeinfo.complete("")), !1;
        }
        if (9 === ch) {
            var partial_string = target.value;
            completeinfo = metaBook.queryCloud(metaBook.query), completions = completeinfo.complete(partial_string), 
            fdjtUI.cancel(evt), completions.prefix && completions.prefix !== partial_string ? (target.value = completions.prefix, 
            fdjtDOM.cancel(evt), completeinfo.selectNext()) : evt.shiftKey ? completeinfo.selectPrevious() : completeinfo.selectNext();
        }
    }
    function searchInput_keyup(evt) {
        evt = evt || window.event || null;
        var ch = evt.charCode || evt.keyCode, target = fdjtDOM.T(evt);
        13 === ch || 13 === ch || 59 === ch || 93 === ch || 9 === ch || (8 === ch ? setTimeout(function() {
            searchUpdate(target);
        }, 100) : searchUpdate(target));
    }
    function searchInput_keypress(evt) {
        evt = evt || window.event || null;
        var ch = evt.charCode || evt.keyCode, target = fdjtDOM.T(evt);
        13 === ch || 13 === ch || 59 === ch || 93 === ch || 9 === ch || 8 === ch || searchUpdate(target);
    }
    function searchUpdate(input, cloud) {
        input || (input = $ID("METABOOKSEARCHINPUT")), cloud || (cloud = metaBook.queryCloud(metaBook.query)), 
        0 === input.value.length && cloud.clearSelection(), cloud.complete(input.value, function(results) {
            input.value.length > 0 && (!results || 0 === results.length || input.value.length > 4) && (addRawText(cloud, input.value), 
            setTimeout(function() {
                cloud.complete(input.value);
            }, 50));
        });
    }
    function addRawText(cloud, text, ptree, maxmatch) {
        ptree || (ptree = metaBook.textindex.prefixTree()), maxmatch || (maxmatch = 42);
        var matches = fdjtString.prefixFind(ptree, text);
        if (0 !== matches.length && !(matches.length > maxmatch)) for (var i = 0, lim = matches.length; lim > i; ) metaBook.cloudEntry(matches[i++], cloud);
    }
    function searchInput_focus(evt) {
        evt = evt || window.event || null;
        var input = fdjtDOM.T(evt);
        metaBook.setFocus(input), metaBook.mode && "searchresults" === metaBook.mode && metaBook.setMode("refinesearch"), 
        searchUpdate(input);
    }
    function searchInput_blur(evt) {
        evt = evt || window.event || null;
        var input = fdjtDOM.T(evt);
        metaBook.clearFocus(input);
    }
    function clearSearch(evt) {
        var target = fdjtUI.T(evt || window.event), box = fdjtDOM.getParent(target, ".searchbox"), input = getChild(box, ".searchinput");
        return fdjtUI.cancel(evt), 0 === metaBook.query.tags.length && 0 === input.value.length ? (metaBook.setMode(!1), 
        void 0) : (metaBook.empty_cloud.dom.style.fontSize = "", setQuery(metaBook.empty_query), 
        input.value = "", metaBook.empty_cloud.clearSelection(), metaBook.empty_cloud.complete(""), 
        metaBook.setMode("refinesearch"), void 0);
    }
    function SearchResults(query) {
        return this instanceof SearchResults ? (this.query = query, this.results = query.results, 
        this.scores = query.scores, MetaBookSlice.call(this, fdjtDOM("div.metabookslice.mbsyncslice.searchslice"), this.results)) : new SearchResults(query);
    }
    function showResults(query) {
        return query.listing ? query.listing : (query.listing = new SearchResults(query), 
        query.listing);
    }
    var mB = metaBook, Trace = mB.Trace, fdjtString = fdjt.String, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, $ID = fdjt.ID, RefDB = fdjt.RefDB, Query = RefDB.Query;
    metaBook.search_cloud = !1, metaBook.empty_cloud || (metaBook.empty_cloud = !1), 
    metaBook.show_refiners || (metaBook.show_refiners = 25), metaBook.search_gotlucky || (metaBook.search_gotlucky = 7);
    var addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getChild = fdjtDOM.getChild, log = fdjtLog, kbref = RefDB.resolve, search_modes = /(search|refinesearch|searchresults|expandsearch)/;
    metaBook.getQuery = function() {
        return metaBook.query;
    }, metaBook.setQuery = setQuery;
    var hasParent = fdjtDOM.hasParent, getParent = fdjtDOM.hasParent;
    metaBook.searchTags_onclick = searchTags_onclick, metaBook.extendQuery = extendQuery, 
    metaBook.updateQuery = function(input_elt) {
        var q = Knodule.Query.string2query(input_elt.value);
        q !== metaBook.query.tags && metaBook.setQuery(q, !1);
    }, metaBook.showSearchResults = showSearchResults, metaBook.startSearch = startSearch;
    var Selector = fdjtDOM.Selector;
    metaBook.UI.handlers.search_keydown = searchInput_keydown, metaBook.UI.handlers.search_keyup = searchInput_keyup, 
    metaBook.UI.handlers.search_keypress = searchInput_keypress, metaBook.searchUpdate = searchUpdate, 
    metaBook.UI.handlers.search_focus = searchInput_focus, metaBook.UI.handlers.search_blur = searchInput_blur, 
    metaBook.UI.handlers.clearSearch = clearSearch;
    var MetaBookSlice = metaBook.Slice;
    metaBook.SearchResults = SearchResults, SearchResults.prototype = new MetaBookSlice(), 
    SearchResults.prototype.renderCard = function(result) {
        return metaBook.renderCard(result, this.query);
    }, SearchResults.prototype.sortfn = function(x, y) {
        if ("number" == typeof x.score && "number" == typeof y.score) {
            if (x.score !== y.score) return y.score - x.score;
        } else {
            if ("number" == typeof x.score) return -1;
            if ("number" == typeof y.score) return 1;
        }
        if ("number" == typeof x.location && "number" == typeof y.location) {
            if (x.location !== y.location) return x.location - y.location;
        } else {
            if ("number" == typeof x.location) return -1;
            if ("number" == typeof y.location) return 1;
        }
        if ("number" == typeof x.timestamp && "number" == typeof y.timestamp) {
            if (x.timestamp !== y.timestamp) return x.timestamp - y.timestamp;
        } else {
            if ("number" == typeof x.timestamp) return -1;
            if ("number" == typeof y.timestamp) return 1;
        }
        return 0;
    }, RefDB.Query.prototype.showResults = function() {
        return showResults(this);
    };
}(), function() {
    "use strict";
    function goodURL(string) {
        return /https?:[\/][\/](\w+[.])+\w+[\/]/.exec(string);
    }
    function getGlossMode(arg) {
        if (arg || (arg = $ID("METABOOKLIVEGLOSS")), "string" == typeof arg && (arg = $ID(arg)), 
        !arg || !arg.nodeType) return !1;
        "FORM" !== arg.tagName && (arg = getChild(arg, "FORM"));
        var classname = arg.className, match = glossmodes.exec(classname);
        return match && 0 !== match.length && match[0] ? match[0] : !1;
    }
    function setGlossMode(mode, arg, toggle) {
        function setglossmode(resolve) {
            var div = getParent(form, ".metabookglossform"), input = !1, frag = fdjtDOM.getInput(form, "FRAG"), uuid = fdjtDOM.getInput(form, "UUID");
            if ((Trace.mode || Trace.glossing) && fdjtLog("setGlossMode %o%s: #%s #U%s", mode, toggle ? " (toggle)" : "", frag && frag.value, uuid && uuid.value), 
            toggle && mode === form.className && (mode = !1), mode && addClass(div, "focused"), 
            mode) {
                if ("addtag" === mode) input = $ID("METABOOKADDTAGINPUT"); else if ("attach" === mode) {
                    var upload_glossid = $ID("METABOOKUPLOADGLOSSID");
                    upload_glossid.value = uuid.value;
                    var upload_itemid = $ID("METABOOKUPLOADITEMID");
                    upload_itemid.value = fdjtState.getUUID(), input = $ID("METABOOKATTACHURL");
                } else {
                    if ("addoutlet" !== mode) return dropClass(form, glossmodes), dropClass("METABOOKHUD", /\bgloss\w+\b/), 
                    resolve(form);
                    input = $ID("METABOOKADDSHAREINPUT");
                }
                return (Trace.mode || Trace.glossing) && fdjtLog("setGlossMode gm=%s input=%o", mode, input), 
                form.className = mode, swapClass("METABOOKHUD", /\bgloss\w+\b/, "gloss" + mode), 
                metaBook.setHUD(!0), mode && /(addtag|addoutlet)/.exec(mode) && addClass("METABOOKHUD", "openheart"), 
                input && metaBook.setFocus(input), resolve(form);
            }
            if (dropClass(form, glossmodes), dropClass("METABOOKHUD", /\bgloss\w+\b/), dropClass("METABOOKHUD", "openheart"), 
            !metaBook.touch) {
                var glossinput = getInput(form, "NOTE");
                glossinput && metaBook.setFocus(glossinput), addClass(div, "focused");
            }
        }
        var node, form;
        return mode && arg && mode.nodeType && "string" == typeof arg ? (node = mode, mode = arg) : node = arg ? "string" == typeof arg ? $ID(arg) : arg : $ID("METABOOKLIVEGLOSS"), 
        node && node.nodeType ? (form = "FORM" === node.tagName ? node : fdjtDOM.getParent(node, "form") || fdjtDOM.getChild(node, "form"), 
        form ? new Promise(setglossmode) : (fdjtLog.warn("Missing FORM for setGlossMode"), 
        void 0)) : (fdjtLog.warn("Missing DOM arg for setGlossMode"), !1);
    }
    function getGlossForm(arg, response) {
        if ("string" == typeof arg && (arg = mbID(arg) || metaBook.glossdb.ref(arg) || !1), 
        !arg) return !1;
        var gloss = !arg.nodeType && (arg.maker || arg.gloss) && arg, maker = gloss && gloss.maker, makerid = maker && maker._id;
        response = maker ? maker === metaBook.user || makerid === metaBook.user._id || metaBook.outlets.indexOf(arg.maker) >= 0 || metaBook.outlets.indexOf(arg.maker._id) >= 0 ? !1 : !0 : !1;
        var passage = gloss ? mbID(gloss.frag) : arg, passageid = passage.codexbaseid || passage.id, formid = gloss ? response ? "METABOOKRESPONDGLOSS_" + gloss._id : "METABOOKEDITGLOSS_" + gloss._id : "METABOOKADDGLOSS_" + passageid, form = $ID(formid), div = form && form.parentNode, proto = $ID("METABOOKADDGLOSSPROTOTYPE");
        return div ? form = getChildren(div, "form")[0] : (div = proto.cloneNode(!0), div.id = "", 
        fdjtDOM($ID("METABOOKADDGLOSS"), div), form = getChildren(div, "form")[0], form.id = formid, 
        form = setupGlossForm(form, passage, gloss, response || !1), metaBook.setupGestures(div)), 
        gloss ? response ? addClass(div, "glossreply") : (addClass(div, "glossedit"), addClass(metaBook.HUD, "editgloss")) : addClass(div, "glossadd"), 
        form ? div : !1;
    }
    function setupGlossForm(form, passage, gloss, response) {
        var passageid = passage.codexbaseid || passage.id, info = metaBook.docinfo[passageid];
        if (form.getAttribute("sbooksetup")) return !1;
        if (!info) return !1;
        if (form.onsubmit = submitGloss, getInput(form, "REFURI").value = metaBook.refuri, 
        getInput(form, "DOCTITLE").value = document.title, getInput(form, "DOCURI").value = document.location.href, 
        getInput(form, "FRAG").value = passageid, info.wsnid && (getInput(form, "WSNID").value = info.wsnid), 
        metaBook.user && (getInput(form, "MAKER").value = gloss && gloss.maker && gloss.maker._id || metaBook.user._id), 
        metaBook.mycopyid && (getInput(form, "MYCOPYID").value = metaBook.mycopyid), metaBook.mycopyid && (getInput(form, "MYCOPYID").value = metaBook.mycopyid), 
        gloss) {
            var glossdate_elt = getChild(form, ".glossdate");
            fdjtDOM(glossdate_elt, fdjtTime.shortString(gloss.created)), glossdate_elt.title = fdjtTime.timeString(gloss.created);
        }
        var glossinput = getInput(form, "NOTE"), notespan = getChild(form, ".notespan");
        glossinput && (glossinput.onkeypress = glossinput_onkeypress, glossinput.onkeydown = glossinput_onkeydown, 
        glossinput.onfocus = glossinput_onfocus, gloss && !response ? (glossinput.value = gloss.note || "", 
        notespan && (notespan.innerHTML = glossinput.value)) : glossinput.value = ""), metaBook.syncstamp && (getInput(form, "SYNC").value = metaBook.syncstamp + 1);
        var menu = getChild(form, ".addglossmenu");
        fdjt.UI.TapHold(menu, {
            override: !0
        });
        var loc = getInput(form, "LOCATION"), loclen = getInput(form, "LOCLEN"), tagline_elt = getInput(form, "TAGLINE"), respondsto = getInput(form, "RE"), thread = getInput(form, "THREAD"), uuidelt = getInput(form, "UUID"), detail_elt = getInput(form, "DETAIL"), response_elt = getChild(form, "div.response");
        if (response_elt && response && gloss) {
            var maker_elt = getChild(response_elt, ".respmaker"), date_elt = getChild(response_elt, ".respdate"), note_elt = getChild(response_elt, ".respnote"), makerinfo = metaBook.sourcedb.ref(gloss.maker);
            fdjtDOM(maker_elt, makerinfo.name), fdjtDOM(date_elt, fdjtTime.shortString(gloss.created)), 
            gloss.note ? (gloss.note.length > 42 ? fdjtDOM(note_elt, gloss.note.slice(0, 42) + "…") : fdjtDOM(note_elt, gloss.note), 
            note_elt.title = gloss.note) : fdjtDOM.remove(note_elt);
        } else fdjtDOM.remove(response_elt), response_elt = !1;
        loc && (loc.value = info.starts_at), loclen && (loclen.value = info.ends_at - info.starts_at), 
        response && gloss ? (thread.disabled = !1, respondsto.disabled = !1, thread.value = gloss.thread || gloss._id, 
        respondsto.value = gloss._id) : (respondsto.disabled = !0, thread.disabled = !0);
        var tagline = getTagline(passage);
        if (tagline && (tagline_elt.value = tagline), gloss) {
            var tags = getGlossTags(gloss);
            if (tags.length) for (var i = 0, lim = tags.length; lim > i; ) addTag(form, tags[i++], !1);
        }
        if (gloss && !response && gloss.posted) {
            var wasposted = getChild(form, ".wasposted");
            wasposted && (wasposted.disabled = !1);
            var postgloss = getChild(form, ".postgloss");
            fdjtUI.setCheckspan(postgloss, !0);
        }
        if (gloss && !response && gloss.links) {
            var links = gloss.links;
            for (var url in links) if ("_" !== url[0]) {
                var title, urlinfo = links[url];
                title = "string" == typeof urlinfo ? urlinfo : urlinfo.title, addLink(form, url, title);
            }
        }
        if (gloss && (detail_elt.value = gloss.detail || ""), gloss && gloss.share) {
            var share = gloss.share;
            "string" == typeof share && (share = [ share ]);
            for (var share_i = 0, share_lim = share.length; share_lim > share_i; ) addTag(form, share[share_i++], "SHARE");
        }
        if (uuidelt.value = !response && gloss && gloss._id ? gloss._id : fdjtState.getUUID(metaBook.nodeid), 
        gloss) {
            resetOutlets(form);
            var shared = gloss && gloss.shared || [];
            "string" == typeof shared && (shared = [ shared ]);
            for (var outlet_i = 0, n_outlets = shared.length; n_outlets > outlet_i; ) addOutlet(form, shared[outlet_i++], "SHARE", !0);
            var private_span = getChild(form, ".private");
            setCheckSpan(private_span, gloss.private);
        }
        gloss && gloss.excerpt && metaBook.setExcerpt(form, gloss.excerpt, gloss.exoff);
        var cancel_button = fdjtDOM.getChild(form, ".cancelbutton");
        cancel_button && fdjtDOM.addListener(cancel_button, "click", cancelGloss_handler), 
        form.setAttribute("sbooksetup", "yes"), updateForm(form);
        var container = getParent(form, ".metabookglossform");
        return container && dropClass(container, "modified"), form;
    }
    function setGlossTarget(target, form, selecting) {
        if (Trace.glossing && fdjtLog("setGlossTarget %o form=%o selecting=%o", target, form, selecting), 
        metaBook.glosstarget && dropClass(metaBook.glosstarget, "mbglosstarget"), dropClass("METABOOKHUD", /\bgloss\w+\b/), 
        dropClass("METABOOKHUD", "editgloss"), !target) {
            var cur = $ID("METABOOKLIVEGLOSS");
            return cur && (cur.id = ""), metaBook.glosstarget = !1, metaBook.glossform = !1, 
            setSelecting(!1), void 0;
        }
        var gloss = !1;
        if ("string" == typeof target && mbID(target) ? target = mbID(target) : "string" == typeof target && metaBook.glossdb.probe(target) ? (gloss = metaBook.glossdb.ref(target), 
        target = mbID(gloss.frag)) : target._db === metaBook.glossdb && (gloss = target, 
        target = mbID(gloss.frag)), gloss && form && !form.nodeType && (form = getGlossForm(gloss, !0)), 
        form) {
            var frag = fdjtDOM.getInput(form, "FRAG");
            frag.value !== target.id && (setExcerpt(form, !1), fdjtDOM.addClass(getParent(form, ".metabookglossform"), "modified"), 
            frag.value = target.id);
        } else if (form = gloss ? getGlossForm(gloss) : getGlossForm(target), !form) return fdjtUI.alert("There was a problem adding a gloss"), 
        !1;
        return metaBook.glosstarget = target, metaBook.select_target = !1, addClass(target, "mbglosstarget"), 
        gloss.exoff ? metaBook.GoTo({
            target: target,
            offset: gloss.exoff
        }, "addgloss", !0) : metaBook.GoTo(target, "addgloss", !0), metaBook.setCloudCuesFromTarget(metaBook.gloss_cloud, target), 
        setGlossForm(form), setSelecting(!1), metaBook.clearHighlights(target), selecting ? setSelecting(selecting) : setSelecting(selectText(target)), 
        gloss && gloss.excerpt && gloss.excerpt.length ? metaBook.selecting.setString(gloss.excerpt) : selecting && updateExcerpt(form, selecting), 
        metaBook.selecting.onchange = function() {
            updateExcerpt(form, this);
        }, form;
    }
    function glossModified(arg) {
        var target = arg.nodeType ? arg : fdjtUI.T(arg), form = getParent(target, "FORM"), div = getParent(form, ".metabookglossform");
        div && addClass(div, "modified");
    }
    function setSelecting(selecting) {
        metaBook.selecting !== selecting && (metaBook.selecting && ((Trace.selection || Trace.glossing) && fdjtLog("setSelecting, replacing %o with %o", metaBook.selecting, selecting), 
        metaBook.selecting.clear()), metaBook.selecting = selecting);
    }
    function updateExcerpt(form, sel) {
        var info = sel.getInfo();
        if ((Trace.glossing || Trace.selection) && fdjtLog("Updating excerpt for %o from %o: %s", form, sel, sel.getString()), 
        !info) return metaBook.setExcerpt(form, !1), void 0;
        metaBook.setExcerpt(form, info.string, info.off);
        var start_target = getTarget(info.start, !0), new_target = start_target && !hasParent(metaBook.glosstarget, start_target) && start_target;
        if (new_target) {
            var input = fdjtDOM.getInput(form, "FRAG");
            if (input.value = new_target.id, sel && "number" == typeof info.off) {
                var offinput = fdjtDOM.getInput(form, "EXOFF"), newoff = sel.getOffset(new_target);
                offinput.value = newoff;
            }
        }
    }
    function selectText(passages, opts) {
        passages.nodeType && (passages = [ passages ]);
        for (var dups = [], i = 0, lim = passages.length; lim > i; ) dups = dups.concat(metaBook.getDups(passages[i++]));
        return (Trace.selection || Trace.glossing) && fdjtLog("selectText %o, dups=%o", passages, dups), 
        new fdjt.UI.TextSelect(dups, {
            ontap: gloss_selecting_ontap,
            onrelease: opts && opts.onrelease,
            onslip: opts && opts.onslip,
            loupe: metaBook.touch || metaBook.useloupe,
            fortouch: metaBook.touch,
            holdmsecs: 150,
            movethresh: 250
        });
    }
    function gloss_selecting_ontap(evt) {
        evt = evt || window.event, (Trace.selection || Trace.glossing || Trace.gestures) && fdjtLog("gloss_selecting_ontap %o, mode=%o, livegloss=%o", evt, metaBook.mode, $ID("METABOOKLIVEGLOSS")), 
        "addgloss" !== metaBook.mode ? metaBook.setMode("addgloss", !1) : metaBook.modechange && 1500 > fdjtTime() - metaBook.modechange || metaBook.setHUD(!1), 
        fdjtUI.cancel(evt);
    }
    function setGlossForm(form) {
        var cur = $ID("METABOOKLIVEGLOSS");
        if (cur && (cur.id = ""), Trace.glossing && fdjtLog("setGlossForm %o <== %o", form, metaBook.glossform), 
        !form) return metaBook.glossform = !1, void 0;
        form.id = "METABOOKLIVEGLOSS", metaBook.glossform = form, $ID("METABOOKGLOSSBODYTEXT").value = fdjtDOM.getInputValue(form, "DETAIL") || "";
        var syncelt = getInput(form, "SYNC");
        syncelt.value = metaBook.syncstamp + 1, metaBook.share_cloud.complete(), metaBook.gloss_cloud.complete();
    }
    function updateForm(form) {
        var glossetc = getChild(form, ".glossetc");
        fdjtUI.Overflow(glossetc);
    }
    function getTagline(target) {
        var attrib = target.getAttributeNS("tagline", "https://beingmeta.com/METABOOK/") || target.getAttributeNS("tagline", "https://metabooks.net/") || target.getAttributeNS("tagline", "https://sbooks.net/") || target.getAttribute("data-tagline") || target.getAttribute("tagline");
        if (attrib) return attrib;
        var text = fdjtDOM.textify(target);
        return text ? (text = fdjtString.stdspace(text), text.length > 40 ? text.slice(0, 40) + "..." : text) : !1;
    }
    function addOutlet(form, outlet, formvar, checked) {
        checked === void 0 && (checked = !0);
        var wrapper = getParent(form, ".metabookglossform");
        addClass(wrapper, "modified"), Trace.glossing && fdjtLog("addOutlet wrapper=%o form=%o outlet=%o formvar=%o checked=%o", wrapper, form, outlet, formvar, checked);
        var outletspan = getChild(form, ".outlets"), outlet_id = "string" == typeof outlet ? outlet : outlet._id;
        "string" == typeof outlet ? "@" === outlet[0] || ":" === outlet[0] && "@" === outlet[0] ? outlet = metaBook.sourcedb.ref(outlet) : (outlet = {
            name: outlet
        }, spanspec = "span.checkspan.email", formvar || (formvar = "EMAIL")) : outlet.nodeType && (formvar || (formvar = "NETWORK"), 
        outlet_id = outlet.getAttribute("data-value"), outlet = {
            name: outlet.getAttribute("data-key") || outlet_id
        }), formvar || (formvar = "SHARE");
        for (var inputs = getInputs(form, formvar), i = 0, lim = inputs.length; lim > i; ) {
            if (inputs[i].value === outlet_id) {
                var current_checkspan = getParent(inputs[i], ".checkspan");
                return setCheckSpan(current_checkspan, checked), current_checkspan;
            }
            i++;
        }
        var spanspec = "span.checkspan.waschecked.ischecked.outlet." + formvar.toLowerCase(), checkspan = fdjtUI.CheckSpan(spanspec, formvar || "SHARE", outlet_id, checked, fdjtDOM.Image(mbicon("share", 32, 32), "img.share", "↣"), outlet.nick || outlet.name, fdjtDOM.Image(mbicon("redx", 32, 32), "img.redx", "x"));
        return checkspan.title = outlet.nick && outlet.description ? outlet.name + ": " + outlet.description : outlet.description ? outlet.description : outlet.name, 
        fdjtDOM(outletspan, checkspan, " "), dropClass(outletspan, "empty"), checkspan;
    }
    function clearOutlets(form) {
        var outletspan = getChild(form, ".outlets");
        fdjtDOM.replace(outletspan, fdjtDOM("span.outlets"));
    }
    function resetOutlets(form) {
        for (var outletspan = getChild(form, ".outlets"), outlets = getChildren(outletspan, ".checkspan"), i = 0, lim = outlets.length; lim > i; ) {
            var span = outlets[i++];
            setCheckSpan(span, !1);
        }
    }
    function addLink(form, url, title, replace) {
        var linkselt = getChild(form, ".links"), linkval = title ? url + " " + title : url, type = metaBook.urlType(url), icon = metaBook.typeIcon(type), img = fdjtDOM.Image(icon, "img"), text = fdjtDOM("span.linktext", title || url), checkbox = fdjtDOM.Checkbox("LINKS", linkval, !0), aspan = fdjtDOM("span.checkspan.ischecked.waschecked.glosslink", img, checkbox, text);
        aspan.title = title || url, aspan.setAttribute("data-href", url), 0 === url.search(/https:\/\/glossdata./) && addClass(aspan, "glossdata"), 
        type && addClass(aspan, metaBook.mediaTypeClass(type));
        var wrapper = getParent(form, ".metabookglossform");
        return Trace.glossing && fdjtLog("addOutlet wrapper=%o form=%o url=%o title=%o", wrapper, form, url, title), 
        addClass(wrapper, "modified"), replace ? fdjtDOM.replace(replace, aspan) : fdjtDOM(linkselt, aspan, " "), 
        dropClass(linkselt, "empty"), updateForm(form), aspan;
    }
    function changeLink(form, oldlink, newlink, title) {
        var exists = fdjtDOM.getChild(form, "[data-href='" + oldlink + "']");
        addLink(form, newlink, title, exists);
    }
    function setExcerpt(form, excerpt, off) {
        var wrapper = getParent(form, ".metabookglossform"), excerpt_span = getChild(form, ".excerpt"), changed = !1, input = getInput(form, "EXCERPT"), exoff = getInput(form, "EXOFF");
        !excerpt || fdjtString.isEmpty(excerpt) ? (input.value && (changed = !0), input.value = "", 
        exoff.value = "", input.disabled = exoff.disabled = !0, excerpt_span && (excerpt_span.innerHTML = "")) : (input.disabled = exoff.disabled = !1, 
        input.value = excerpt, changed = !0, "number" == typeof off ? exoff.value = off : (exoff.value = "", 
        exoff.disabled = !0), excerpt_span && (excerpt_span.innerHTML = trim_excerpt(excerpt), 
        excerpt_span.title = excerpt)), (Trace.glossing || Trace.selecting) && fdjtLog("setExcerpt %o form=%o excerpt=%o off=%o", wrapper, form, excerpt, off), 
        updateForm(form), changed && addClass(wrapper, "modified");
    }
    function trim_excerpt(string, lim) {
        var len = string.length;
        if (lim || (lim = 20), lim > len) return string;
        var words = string.split(/\s+/), nwords = words.length;
        if (3 > words.length) return string.slice(0, Math.floor(lim / 2)) + "..." + string.slice(Math.floor(len - lim / 2));
        for (var left = 1, left_len = words[0].length + 1, right = nwords - 2, right_len = words[nwords - 1].length + 1; right > left && lim > left_len + right_len; ) left_len += words[left++].length, 
        right_len += words[right--].length;
        return words.slice(0, left).join(" ") + "..." + words.slice(right).join(" ");
    }
    function addTag(form, tag, varname, checked, knodule) {
        var prefix = !1;
        tag || (tag = form), tag.prefix && (prefix = tag.prefix, tag = tag.tag), "FORM" !== form.tagName && (form = getParent(form, "form") || form), 
        knodule || (knodule = metaBook.getMakerKnodule(metaBook.user)), checked === void 0 && (checked = !0);
        var wrapper = getParent(form, ".metabookglossform");
        Trace.glossing && fdjtLog("AddTag %o form=%o tag=%o var=%o checked=%o kno=%o", wrapper, form, tag, varname, checked, knodule), 
        addClass(wrapper, "modified");
        var tagselt = getChild(form, ".tags"), title = !1, textspec = "span.term";
        varname || (varname = "TAGS"), tag.nodeType && hasClass(tag, "completion") && (hasClass(tag, "outlet") ? (varname = "SHARED", 
        textspec = "span.outlet") : hasClass(tag, "source") && (varname = "SHARE", textspec = "span.source"), 
        tag.title && (title = tag.title), tag = metaBook.gloss_cloud.getValue(tag));
        var ref = tag instanceof Ref ? tag : "string" == typeof tag && knodule.handleSubjectEntry(tag), text = ref ? ref.toHTML && ref.toHTML() || ref.name || ref.dterm || ref.title || ref.norm || "string" == typeof ref.EN || ref.EN || ref.EN instanceof Array || ref.EN[0] || ref._qid || ref._id : "string" == typeof tag ? tag : "" + tag, tagval = tag;
        ref && (tagval = ref.knodule === knodule ? ref.dterm : ref._qid || ref.getQID()), 
        prefix && (tagval = prefix + tagval), ref && ref._db === metaBook.sourcedb && (varname = "SHARED");
        for (var checkspans = getChildren(tagselt, ".checkspan"), i = 0, lim = checkspans.length; lim > i; ) {
            var cspan = checkspans[i++];
            if (cspan.getAttribute("data-varname") === varname && cspan.getAttribute("data-tagval") === tagval) return checked && addClass(cspan, "waschecked"), 
            cspan;
        }
        var span = fdjtUI.CheckSpan("span.checkspan", varname, tagval, checked);
        return checked && addClass(span, "waschecked"), title && (span.title = title), span.setAttribute("data-varname", varname), 
        span.setAttribute("data-tagval", tag), addClass(span, "glosstag"), addClass(span, varname.toLowerCase() + "var"), 
        "string" == typeof text ? fdjtDOM.append(span, fdjtDOM(textspec, text)) : fdjtDOM.append(span, text), 
        fdjtDOM.append(span, fdjtDOM.Image(mbicon("redx", 32, 32), "img.redx", "x")), fdjtDOM.append(tagselt, span, " "), 
        dropClass(tagselt, "empty"), updateForm(form), span;
    }
    function findTag(string, pos, partialok, nospaces) {
        if (string && string.length && pos > 0) {
            for (var space = !1, start = pos - 1, delim = !1, need = !1, c = string[start], pc = string[start - 1], cstart = start; start >= 0; ) {
                if ("\\" === pc) ; else if (/\s/.test(c)) space = start; else {
                    if ("@" === c || "#" === c) break;
                    if (0 === start) return !1;
                }
                start--, c = pc, pc = string[start - 1];
            }
            var prefix = string[start], sc = string[start + 1], end = string.length;
            if (tag_delims[sc]) {
                var matching = tag_delims[sc];
                delim = sc, cstart = start + 2;
                var match_off = string.slice(start + 2).indexOf(matching);
                if (0 > match_off) {
                    if (!partialok) return !1;
                    end = pos, need = matching;
                } else end = start + 2 + match_off;
                if (pos > end) return !1;
            } else {
                if (nospaces && space) return !1;
                var end_off = string.slice(start).search(tag_ends);
                end_off > 0 && (end = start + end_off), cstart = start + 1;
            }
            var result = {
                text: string.slice(start, end),
                start: start,
                end: end,
                pos: pos,
                prefix: prefix,
                content: delim && need ? string.slice(start + 2, end) : delim ? string.slice(start + 2, end - 1) : string.slice(start + 1, end)
            };
            return delim && (result.delim = delim), delim && partialok && (result.needs = tag_delims[delim]), 
            result;
        }
        return !1;
    }
    function tagclear(input_elt, pos) {
        var text = input_elt.value;
        pos || (pos = input_elt.selectionStart);
        var info = findTag(text, pos);
        info && (input_elt.value = text.slice(0, info.start) + text.slice(info.end));
    }
    function glossinput_onfocus(evt) {
        var target = fdjtUI.T(evt), text = target.value, pos = target.selectionStart, taginfo = findTag(text, pos);
        (Trace.glossing || Trace.gestures) && fdjtLog("glossinput_onfocus %o text=%o pos=%o taginfo=%o", evt, text, pos, taginfo), 
        glossform_focus(evt), taginfo && (glossinput_timer && clearTimeout(glossinput_timer), 
        glossinput_timer = setTimeout(function() {
            glosstag_complete(target);
        }, 150));
    }
    function glossinput_onkeypress(evt) {
        var target = fdjtUI.T(evt), form = getParent(target, "FORM"), text = target.value, pos = target.selectionStart || 0, ch = evt.charCode, charstring = String.fromCharCode(ch), taginfo = findTag(text, pos, !0);
        if ((Trace.glossing || Trace.gestures > 2) && fdjtLog("glossinput_onkeypress '%o' %o text=%o pos=%o taginfo=%o", ch, evt, text, pos, taginfo), 
        13 !== ch && (addClass(getParent(form, ".metabookglossform"), "focused"), addClass(getParent(form, ".metabookglossform"), "modified")), 
        13 === ch) if (taginfo) target.value = text.slice(0, taginfo.start) + text.slice(taginfo.end), 
        glosstag_done(target, taginfo.content, evt.ctrlKey, "@" === taginfo.prefix), fdjt.UI.cancel(evt); else {
            if (evt.shiftKey) return target.value = text.slice(0, pos) + "\n" + text.slice(pos), 
            target.selectionStart++, fdjtUI.cancel(evt);
            fdjtUI.cancel(evt), submitGloss(form);
        } else if (taginfo) {
            if (tag_ends.test(charstring)) {
                if (taginfo = findTag(text, pos, !0), !taginfo) return;
                return taginfo.needs === charstring && (target.value = text.slice(0, taginfo.start) + text.slice(taginfo.end), 
                glosstag_done(target, taginfo.content, evt.ctrlKey, "@" === taginfo.prefix), fdjtUI.cancel(evt)), 
                void 0;
            }
            glossinput_timer && clearTimeout(glossinput_timer), glossinput_timer = setTimeout(function() {
                glosstag_complete(target);
            }, 150);
        } else ;
    }
    function glossinput_onkeydown(evt) {
        var ch = evt.keyCode, target = fdjtUI.T(evt);
        if (27 === ch) return metaBook.cancelGloss(), fdjtUI.cancel(evt), void 0;
        if (9 === ch || 13 === ch) {
            var form = getParent(target, "FORM"), text = target.value, pos = target.selectionStart || 0, taginfo = findTag(text, pos, !0), cloud = "@" === taginfo.prefix ? metaBook.share_cloud : metaBook.gloss_cloud;
            if ((Trace.glossing || Trace.gestures > 2) && fdjtLog("glossinput_onkeydown '%o' %o taginfo=%o cloud=%o", ch, evt, taginfo, cloud), 
            !taginfo) return;
            if (9 === ch) {
                var content = taginfo.content;
                if (cloud.complete(content), cloud.prefix && cloud.prefix !== content) {
                    var replace_start = taginfo.start + (taginfo.delim ? 2 : 1), replace_end = taginfo.end - (taginfo.needs ? 0 : 1);
                    return target.value = cloud.prefix.search(/\s/) >= 0 ? text.slice(0, replace_start) + (taginfo.delim ? "" : '"') + cloud.prefix + (taginfo.needs ? taginfo.needs : "") + text.slice(replace_end) : text.slice(0, replace_start) + cloud.prefix + text.slice(replace_end), 
                    void 0;
                }
                evt.shiftKey ? cloud.selectPrevious() : cloud.selectNext(), fdjtUI.cancel(evt);
            } else if (cloud.selection) {
                if ("@" === taginfo.prefix) {
                    var outlet = cloud.selection.getAttribute("data-value");
                    metaBook.addOutlet2Form(form, outlet, "SHARE");
                } else metaBook.addTag2Form(form, cloud.selection);
                target.value = text.slice(0, taginfo.start) + text.slice(taginfo.end), dropClass("METABOOKHUD", /gloss(tagging|tagoutlet)/g), 
                setTimeout(function() {
                    cloud.complete("");
                }, 10), cloud.clearSelection(), fdjtUI.cancel(evt);
            }
        } else (8 === ch || 46 === ch || ch >= 35 && 40 >= ch) && (glossModified(evt), glossinput_timer && clearTimeout(glossinput_timer), 
        glossinput_timer = setTimeout(function() {
            glosstag_complete(target);
        }, 150));
    }
    function glosstag_complete(input_elt) {
        var text = input_elt.value, pos = input_elt.selectionStart || 0, taginfo = findTag(text, pos, !0);
        if (taginfo) {
            var completions, isoutlet = "@" === taginfo.prefix;
            isoutlet ? swapClass("METABOOKHUD", /gloss(tagging|tagoutlet)/g, "glosstagoutlet") : swapClass("METABOOKHUD", /gloss(tagging|tagoutlet)/g, "glosstagging"), 
            completions = isoutlet ? metaBook.share_cloud.complete(taginfo.content) : metaBook.gloss_cloud.complete(taginfo.content), 
            Trace.glossing && fdjtLog("Got %d completions for %s", completions.length, taginfo.content);
        } else dropClass("METABOOKHUD", /gloss(tagging|addoutlet)/g);
    }
    function glosstag_done(input_elt, tagtext, personal, isoutlet) {
        var form = getParent(input_elt, "FORM"), tag = !1;
        if (!isoutlet && personal) tag = metaBook.knodule.def(tagtext); else if (tagtext.indexOf("|") > 0) isoutlet ? fdjtLog.warn("Can't define outlets (sources) from %s", tagtext) : tag = metaBook.knodule.def(tagtext); else {
            var cloud = isoutlet ? metaBook.share_cloud : metaBook.gloss_cloud, completions = cloud.complete(tagtext);
            0 === completions.length || 1 === completions.length && (tag = completions[0]), 
            isoutlet && !tag ? fdjtLog.warn("Unknown outlet %s", tagtext) : isoutlet ? addOutlet(form, tag) : tag ? addTag(form, tag) : (tag = metaBook.knodule.ref(tagtext), 
            tag ? addTag(form, tag) : addTag(form, tagtext));
        }
        dropClass("METABOOKHUD", /gloss(tagging|addoutlet)/);
    }
    function getTagString(span, content) {
        var tagval = span.getAttribute("data-tagval");
        if (tagval) {
            var at = tagval.indexOf("@");
            return metaBook.knodule && at > 0 && tagval.slice(at + 1) === metaBook.knodule.name ? tagval.slice(0, at) : tagval;
        }
        var bar = content.indexOf("|");
        return bar > 0 ? content.slice(0, bar) : content;
    }
    function handleTagInput(tagstring, form, exact) {
        var isoutlet = "@" === tagstring[0], cloud = isoutlet ? metaBook.share_cloud : metaBook.gloss_cloud, text = "@" === tagstring[0] || "#" === tagstring[0] ? tagstring.slice(1) : tagstring, completions = cloud.complete(text), std = stdspace(text);
        if (isoutlet) {
            for (var oc = [], j = 0, jlim = completions.length; jlim > j; ) {
                var c = completions[j++];
                hasClass(c, "outlet") && oc.push(c);
            }
            completions = oc;
        }
        if (completions && 0 !== completions.length) {
            var completion = !1;
            if (1 === completions.length) completion = completions[0]; else if (completions.exact && 1 === completions.exact.length) completion = completions.exact[0]; else {
                completion = completions[0];
                for (var i = 0, lim = completions.length; lim > i; ) {
                    var mc = completions[i++];
                    if (mc !== completion) {
                        completion = !1;
                        break;
                    }
                }
            }
            if (completion && completion === completions[0]) {
                var ks = metaBook.gloss_cloud.getKey(completions.matches[0]);
                if (exact ? ks.toLowerCase() !== std.toLowerCase() : 0 !== ks.toLowerCase().search()) return addTag(form, std), 
                metaBook.gloss_cloud.complete(""), std;
            }
            if (completion) {
                var span = addTag(form, completion);
                return metaBook.gloss_cloud.complete(""), getTagString(span, metaBook.gloss_cloud.getKey(completion));
            }
            return addTag(form, std), metaBook.gloss_cloud.complete(""), std;
        }
        return isoutlet ? addOutlet(form, std) : addTag(form, std), cloud.complete(""), 
        std;
    }
    function get_addgloss_callback(form, keep, uri) {
        return function(req) {
            return addgloss_callback(req, form, keep, uri);
        };
    }
    function addgloss_callback(req, form, keep) {
        if ((Trace.network || Trace.glossing) && fdjtLog("Got AJAX gloss response %o from %o", req, req.responseURL), 
        Trace.savegloss && fdjtLog("Gloss %o successfully added (status %d) to %o", getInput(form, "UUID").value, req.status, getInput(form, "FRAG").value), 
        dropClass(form.parentNode, "submitting"), 200 > req.status || req.status >= 300) return addClass(form.parentNode, "submitfailed"), 
        403 === req.status ? fdjt.Dialog.alert("Sorry, you're not allowed to save this gloss") : fdjt.Dialog.alert("There was a problem saving your gloss"), 
        form.parentNode && form.parentNode && fdjtDOM.remove(form.parentNode), setGlossTarget(!1), 
        metaBook.setTarget(!1), metaBook.setMode(!1), void 0;
        keep ? addClass(form.parentNode, "submitdone") : (addClass(form.parentNode, "submitclose"), 
        metaBook.setHUD(!1, !1));
        for (var json = JSON.parse(req.responseText), ref = metaBook.glossdb.Import(json, !1, RefDB.REFINDEX | RefDB.REFSTRINGS | RefDB.REFLOAD), reps = document.getElementsByName(ref._id), i = 0, lim = reps.length; lim > i; ) {
            var rep = reps[i++];
            if (hasClass(rep, "mbcard")) {
                var new_card = metaBook.renderCard(ref);
                new_card && fdjtDOM.replace(rep, new_card);
            }
        }
        ref.save(), metaBook.selecting && (metaBook.selecting.onclear ? metaBook.selecting.onclear.push(function() {
            metaBook.addGloss2UI(ref);
        }) : metaBook.selecting.onclear = [ function() {
            metaBook.addGloss2UI(ref);
        } ]), form && !keep ? setTimeout(function() {
            hasClass(form.parentNode, "submitclose") && (form.parentNode && form.parentNode && fdjtDOM.remove(form.parentNode), 
            setGlossTarget(!1), metaBook.setTarget(!1), metaBook.setMode(!1));
        }, 1500) : form && setTimeout(function() {
            dropClass(form.parentNode, "submitdone");
        }, 1500);
    }
    function clearGlossForm(form) {
        var uuid = getInput(form, "UUID");
        uuid && (uuid.value = "");
        var note = getInput(form, "NOTE");
        note && (note.value = "");
        var href = getInput(form, "HREF");
        href && (href.value = "");
        var tagselt = getChildren(form, ".tags");
        if (tagselt && tagselt.length) {
            var tags = getChildren(tagselt[0], ".checkspan");
            fdjtDOM.remove(fdjtDOM.Array(tags));
        }
    }
    function glosscloud_select(evt) {
        var target = fdjtUI.T(evt), completion = getParent(target, ".completion");
        if (completion) {
            var live = $ID("METABOOKLIVEGLOSS"), form = live && getChild(live, "form"), span = addTag(form, completion);
            if (!hasClass("METABOOKHUD", "glossaddtag")) {
                var tagstring = getTagString(span, metaBook.gloss_cloud.getKey(completion)), input = getInput(form, "NOTE");
                input && tagstring && tagclear(input);
            }
        }
        fdjtUI.cancel(evt);
    }
    function sharecloud_ontap(evt) {
        var target = fdjtUI.T(evt), completion = getParent(target, ".completion");
        if (completion) {
            var live = $ID("METABOOKLIVEGLOSS"), form = live && getChild(live, "form"), value = completion.getAttribute("data-value");
            hasClass(completion, "source") ? value && addOutlet(form, metaBook.sourcedb.ref(value), "SHARE") : hasClass(completion, "network") ? addOutlet(form, completion, "NETWORK") : hasClass(completion, "email") && (value ? addOutlet(form, completion, "EMAIL") : addOutlet(form, completion));
        }
        fdjtUI.cancel(evt);
    }
    function submitGloss(arg, keep) {
        var div = !1, form = !1;
        if (arg === void 0) {
            if (div = $ID("METABOOKLIVEGLOSS"), !div) return;
            form = getChild(div, "FORM");
        } else arg.nodeType || (arg = fdjtUI.T(arg)), arg.nodeType && 1 === arg.nodeType && "FORM" === arg.tagName ? (form = arg, 
        div = getParent(form, ".metabookglossform")) : arg.nodeType && 1 === arg.nodeType && "DIV" === arg.tagName && hasClass(arg, "metabookglossform") && (div = arg, 
        form = getChild(div, "FORM"));
        if (form) {
            var detail_elt = getInput(form, "DETAIL"), glossbodytext = $ID("METABOOKGLOSSBODYTEXT");
            detail_elt.value = glossbodytext.value || "", addClass(div, "submitting"), hasParent(form, ".glossedit") || hasParent(form, ".glossreply") || saveGlossDefaults(form, getChild("METABOOKADDGLOSSPROTOTYPE", "FORM"));
            var uuidelt = getInput(form, "UUID");
            uuidelt && uuidelt.value && uuidelt.value.length > 5 || (fdjtLog.warn("missing UUID"), 
            uuidelt && (uuidelt.value = fdjtState.getUUID(metaBook.nodeid)));
            var note_input = getInputs(form, "NOTE")[0];
            if (0 === note_input.value.search(uri_prefix)) {
                var note = note_input.value, brk = note.search(/\s/);
                0 > brk ? addLink(form, note) : addLink(form, note.slice(0, brk), note.slice(brk + 1)), 
                note_input.value = "";
            }
            if (!(login_message || navigator.onLine && metaBook.connected)) {
                var choices = [];
                return navigator.onLine && choices.push({
                    label: "Login",
                    isdefault: !0,
                    handler: function() {
                        setTimeout(function() {
                            metaBook.setMode("login");
                        }, 0);
                        var resubmit = function() {
                            submitGloss(form, keep);
                        };
                        metaBook._onconnect ? metaBook._onconnect.push(resubmit) : metaBook._onconnect = [ resubmit ], 
                        login_message = !0;
                    }
                }), metaBook.user && metaBook.persist ? choices.push({
                    label: "Queue",
                    isdefault: !navigator.onLine && metaBook.cacheglosses,
                    handler: function() {
                        metaBook.nocache && metaBook.setConfig("cacheglosses", !0), login_message = !0, 
                        navigator.onLine && metaBook.connected ? submitGloss(form, keep) : queueGloss(form, !1, keep);
                    }
                }) : (choices.push({
                    label: "Cache",
                    isdefault: !navigator.onLine && metaBook.cacheglosses,
                    handler: function() {
                        metaBook.nocache && metaBook.setConfig("cacheglosses", !0, !0), login_message = !0, 
                        queueGloss(form, !1, keep);
                    }
                }), metaBook.nocache && choices.push({
                    label: "Lose",
                    isdefault: !navigator.onLine && metaBook.nocache,
                    handler: function() {
                        tempGloss(form), login_message = !0;
                    }
                })), choices.push({
                    label: "Cancel",
                    handler: function() {
                        fdjtDOM.remove(form.parentNode), setGlossTarget(!1), metaBook.setTarget(!1), metaBook.setMode(!1);
                    }
                }), fdjtUI.choose(choices, navigator.onLine && !metaBook.user && [ fdjtDOM("p.smaller", "This book isn't currently associated with an sBooks account, ", "so any highlights or glosses you add will not be permanently saved ", "until you login."), fdjtDOM("p.smaller", "You may either login now, cache your changes ", "on this machine until you do login, ", "lose your changes when this page closes, ", "or cancel the change you're about to make.") ], navigator.onLine && metaBook.user && [ fdjtDOM("p.smaller", "You aren't currently logged into your sBooks account from ", "this machine, so any highlights or glosses you add won't ", "be saved until you do."), fdjtDOM("p.smaller", "In addition, you won't get updated glosses from ", "your networks or layers."), fdjtDOM("p.smaller", "You may either login now, queue any changes you make until ", "you do login, or cancel the change you were trying to make.") ], !navigator.onLine && metaBook.nocache && [ fdjtDOM("p.smaller", "You are currently offline and have elected to not save ", "highlights or glosses locally on this computer."), fdjtDOM("p.smaller", "You can either queue your changes by storing information locally, ", "lose your changes when this page closes,", "or cancel the change you were about to make.") ]), 
                void 0;
            }
            var sent = navigator.onLine && metaBook.connected && metaBook.user && fdjt.Ajax.onsubmit(form, get_addgloss_callback(form, keep));
            sent ? dropClass(div, "modified") : queueGloss(form, arg && arg.type && arg, keep);
        }
    }
    function cancelGloss_handler(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        cancelGloss(target), fdjtUI.cancel(evt);
    }
    function cancelGloss(arg) {
        var evt = arg || window.event || null, target = arg ? arg.nodeType ? arg : fdjtUI.T(arg) : $ID("METABOOKLIVEGLOSS"), glossform = target && fdjtDOM.getParent(target, ".metabookglossform");
        setGlossTarget(!1), metaBook.setMode(!1), arg && (arg.cancelable || arg.bubbles) && fdjtUI.cancel(evt), 
        glossform && fdjtDOM.remove(glossform);
    }
    function saveGlossDefaults(form, proto) {
        var i, lim, mode = form.className;
        swapClass(proto, glossmodes, mode);
        var post = getInput(form, "POSTGLOSS"), proto_post = getInput(form, "POSTGLOSS");
        setCheckSpan(proto_post, post.checked);
        var networks = getInputs(form, "NETWORKS");
        for (i = 0, lim = networks.length; lim > i; ) {
            var network_input = networks[i++], proto_input = getInputFor(form, "NETWORKS", network_input.value);
            setCheckSpan(proto_input, network_input.checked);
        }
        clearOutlets(proto);
        var shared = getChild(form, ".outlets"), inputs = getChildren(shared, "INPUT");
        i = 0, lim = inputs.length;
        for (var n_others = 0; lim > i; ) {
            var input = inputs[i++];
            if (input.checked || 5 >= n_others) {
                var checkspan = addOutlet(proto, input.value, input.name, input.checked);
                input.checked ? addClass(checkspan, "waschecked") : n_others++;
            }
        }
    }
    function queueGloss(form, evt, keep) {
        var json = fdjt.Ajax.formJSON(form, !0), params = fdjt.Ajax.formParams(form), queued = metaBook.queued;
        queued.push(json.uuid), metaBook.cacheglosses ? (fdjtState.setLocal("mB(" + json.uuid + ").params", params), 
        fdjtState.setLocal("mB(" + mB.docid + ").queued", queued, !0)) : queued_data[json.uuid] = params;
        var glossdata = {
            refuri: json.refuri,
            frag: json.frag,
            _id: json.uuid,
            uuid: json.uuid,
            maker: json.user || metaBook.user,
            qid: json.uuid,
            gloss: json.uuid,
            created: json.created || fdjtTime()
        };
        glossdata.tstamp = fdjtTime.tick(), json.note && !fdjtString.isEmpty(json.note) && (glossdata.note = json.note), 
        json.excerpt && !fdjtString.isEmpty(json.excerpt) && (glossdata.excerpt = json.excerpt, 
        glossdata.exoff = json.exoff), json.detail && !fdjtString.isEmpty(json.detail) && (glossdata.detail = json.detail), 
        json.tags && json.tags.length > 0 && (glossdata.tags = json.tags), json.xrefs && json.xrefs.length > 0 && (glossdata.xrefs = json.xrefs), 
        metaBook.glossdb.Import(glossdata, !1, RefDB.REFLOAD | RefDB.REFSTRINGS | RefDB.REFINDEX, !0), 
        evt && fdjtUI.cancel(evt), dropClass(form.parentNode, "submitting"), keep || (clearGlossForm(form), 
        setGlossTarget(!1), metaBook.setTarget(!1), metaBook.setMode(!1));
    }
    function tempGloss(form, evt) {
        var json = fdjt.Ajax.formJSON(form, !0), glossdata = {
            refuri: json.refuri,
            frag: json.frag,
            maker: json.user,
            _id: json.uuid,
            uuid: json.uuid,
            qid: json.uuid,
            gloss: json.uuid,
            created: fdjtTime()
        };
        glossdata.tstamp = fdjtTime.tick(), json.note && !fdjtString.isEmpty(json.note) && (glossdata.note = json.note), 
        json.excerpt && !fdjtString.isEmpty(json.excerpt) && (glossdata.excerpt = json.excerpt, 
        glossdata.exoff = json.exoff), json.detail && !fdjtString.isEmpty(json.detail) && (glossdata.detail = json.detail), 
        json.tags && json.tags.length > 0 && (glossdata.tags = json.tags), json.xrefs && json.xrefs.length > 0 && (glossdata.xrefs = json.xrefs), 
        metaBook.glossdb.Import(glossdata, !1, !1, !0), clearGlossForm(form), evt && fdjtUI.cancel(evt), 
        dropClass(form.parentNode, "submitting"), setGlossTarget(!1), metaBook.setTarget(!1), 
        metaBook.setMode(!1);
    }
    function writeQueuedGlosses() {
        if (metaBook.queued.length) {
            var ajax_uri = getChild($ID("METABOOKADDGLOSSPROTOTYPE"), "form").getAttribute("ajaxaction"), queued = metaBook.queued, glossid = queued[0], post_data = metaBook.nocache ? queued_data[glossid] : fdjtState.getLocal("mB(" + glossid + ").params");
            if (post_data) {
                var req = new XMLHttpRequest();
                req.open("POST", ajax_uri), req.withCredentials = "yes", req.onreadystatechange = function() {
                    if (4 === req.readyState && req.status >= 200 && 300 > req.status) {
                        fdjtState.dropLocal("mB(" + glossid + ").params");
                        var pending = metaBook.queued;
                        if (pending && pending.length) {
                            var pos = pending.indexOf(glossid);
                            pos >= 0 && (pending.splice(pos, 1), metaBook.cacheglosses && fdjtState.setLocal("mB(" + mB.docid + ").queued", pending, !0), 
                            metaBook.queued = pending);
                        }
                        addgloss_callback(req, !1, !1), pending.length && setTimeout(writeQueuedGlosses, 200), 
                        fdjtState.dropLocal("mB(" + mB.docid + ").queued");
                    } else 4 === req.readyState && metaBook.setConnected(!1);
                };
                try {
                    req.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), req.send(post_data);
                } catch (ex) {
                    metaBook.setConnected(!1);
                }
            }
        }
    }
    function glossform_outlets_tapped(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        return getParent(target, ".checkspan") ? fdjt.UI.CheckSpan.onclick(evt) : (getParent(target, ".sharing") && toggleClass(getParent(target, ".sharing"), "expanded"), 
        void 0);
    }
    function outlet_select(evt) {
        var target = fdjtUI.T(evt), outletspan = getParent(target, ".outlet") || getParent(target, ".source");
        if (outletspan) {
            var live = $ID("METABOOKLIVEGLOSS"), form = live && getChild(live, "form"), outlet = metaBook.share_cloud.getValue(outletspan);
            metaBook.addOutlet2Form(form, outlet), fdjtUI.cancel(evt);
        }
    }
    function glossmode_tap(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), alt = target.alt;
        if (alt) {
            var menu = getParent(target, ".addglossmenu"), form = getParent(target, "form"), div = getParent(form, "div.metabookglossform");
            "downmenu" === alt ? (addClass(menu, "expanded"), dropClass(menu, "held")) : "upmenu" === alt ? (dropClass(menu, "expanded"), 
            dropClass(menu, "held")) : "glossdelete" === alt ? addgloss_delete(menu, form, !1, !0) : "glosscancel" === alt ? addgloss_cancel(menu, form, div) : "glosspush" === alt ? (metaBook.submitGloss(form, !1), 
            dropClass(menu, "expanded")) : "glossupdate" === alt ? (metaBook.submitGloss(form, !1), 
            dropClass(menu, "expanded")) : "glossrespond" === alt ? addgloss_respond(menu, form) : "glosscancel" === alt ? addgloss_cancel(menu, form, div) : alt === form.className ? (metaBook.setGlossMode(!1, form), 
            dropClass(menu, "expanded")) : metaBook.glossmodes.exec(alt) ? (metaBook.setGlossMode(alt, form), 
            dropClass(menu, "expanded")) : fdjtLog.warn("Bad alt=%s in glossmode_tap", alt), 
            fdjtUI.cancel(evt);
        }
    }
    function glossmode_hold(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), alt = target.alt;
        if (slip_timeout && (clearTimeout(slip_timeout), slip_timeout = !1), alt) {
            slip_timeout && (clearTimeout(slip_timeout), slip_timeout = !1);
            var menu = getParent(target, ".addglossmenu");
            hasClass(menu, "expanded") ? (addClass(menu, "held"), addClass(target, "held")) : (addClass(menu, "expanded"), 
            addClass(menu, "held"));
        }
    }
    function glossmode_release(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), menu = getParent(target, ".addglossmenu"), form = getParent(target, "form"), div = getParent(form, "div.metabookglossform"), alt = target.alt;
        dropClass(target, "held"), hasClass(target, "menutop") ? metaBook.setGlossMode(!1, form) : "glossdelete" === alt ? addgloss_delete(menu, form) : "glosscancel" === alt ? addgloss_cancel(menu, form, div) : "glosspush" === alt ? metaBook.submitGloss(form, !1) : "glossupdate" === alt ? metaBook.submitGloss(form, !1) : "glossrespond" === alt ? addgloss_respond(menu, form) : metaBook.glossmodes.exec(alt) ? metaBook.setGlossMode(alt, form) : fdjtLog.warn("Bad alt=%s in glossmode_release", alt), 
        dropClass(menu, "expanded"), dropClass(menu, "held");
    }
    function glossmode_slip(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), menu = getParent(target, ".addglossmenu");
        dropClass(target, "held"), slip_timeout || (slip_timeout = setTimeout(function() {
            slip_timeout = !1, dropClass(menu, "held"), dropClass(menu, "expanded");
        }, 500));
    }
    function addgloss_delete(menu, form, div, noprompt) {
        form || (form = getParent(menu, "FORM")), div || (div = getParent(form, ".metabookglossform"));
        var modified = fdjtDOM.hasClass(div, "modified");
        dropClass(div, "modified"), dropClass(menu, "expanded");
        var uuid = getInputValues(form, "UUID")[0], gloss = metaBook.glossdb.probe(uuid);
        return gloss && gloss.created ? noprompt ? (delete_gloss(uuid), metaBook.setMode(!1), 
        fdjtDOM.remove(div), setGlossTarget(!1), metaBook.setTarget(!1), void 0) : (fdjt.UI.choose([ {
            label: "Delete",
            handler: function() {
                delete_gloss(uuid), metaBook.setMode(!1), fdjtDOM.remove(div), setGlossTarget(!1), 
                metaBook.setTarget(!1);
            },
            isdefault: !0
        }, {
            label: "Cancel"
        } ], modified ? "Delete this gloss?  Discard your changes?" : "Delete this gloss?", fdjtDOM("div.smaller", "(Created ", fdjtTime.shortString(gloss.created), ")")), 
        void 0) : (delete_gloss(uuid), metaBook.setMode(!1), fdjtDOM.remove(div), setGlossTarget(!1), 
        metaBook.setTarget(!1), void 0);
    }
    function addgloss_cancel(menu, form, div) {
        form || (form = getParent(menu, "FORM")), div || (div = getParent(form, ".metabookglossform")), 
        metaBook.cancelGloss(), metaBook.setMode(!1), fdjtDOM.remove(div), setGlossTarget(!1), 
        metaBook.setTarget(!1);
    }
    function addgloss_respond(target) {
        var block = getParent(target, ".metabookglossform");
        if (block) {
            var glosselt = getInput(block, "UUID");
            if (glosselt) {
                var qref = glosselt.value, gloss = metaBook.glossdb.probe(qref);
                if (gloss) {
                    var form = setGlossTarget(gloss, metaBook.getGlossForm(gloss, !0));
                    form && metaBook.setMode("addgloss");
                }
            }
        }
    }
    function changeGlossNetwork(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), alternate = $ID(fdjtDOM.hasParent(target, ".metabookglossform") ? "METABOOKNETWORKBUTTONS" : "METABOOKLIVEGLOSS"), doppels = getInputsFor(alternate, "NETWORK", target.value);
        fdjtUI.CheckSpan.set(doppels, target.checked);
    }
    function changeGlossPosting(evt) {
        var target = fdjtUI.T(evt = evt || window.event), glossdiv = getParent(target, ".metabookglossform");
        target.checked ? fdjtDOM.addClass(glossdiv, "posted") : fdjtDOM.dropClass(glossdiv, "posted");
    }
    function changeGlossPrivacy(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt = evt || window.event), glossdiv = getParent(target, ".metabookglossform"), postgloss = getChild(glossdiv, ".postgloss"), postinput = postgloss && getInput(postgloss, "POSTGLOSS");
        postgloss && (target.checked ? postinput && (postinput.disabled = !0) : postinput && (postinput.disabled = !1)), 
        target.checked ? fdjtDOM.addClass(glossdiv, "private") : fdjtDOM.dropClass(glossdiv, "private");
    }
    function glossform_focus(evt) {
        evt = evt || window.event, gloss_blurred = !1;
        var target = fdjtUI.T(evt), form = getParent(target, "FORM"), div = form && getParent(form, ".metabookglossform"), input = div && getChild(div, "TEXTAREA");
        div && metaBook.setGlossMode(!1), input && metaBook.setFocus(input), metaBook.setHUD(!0), 
        metaBook.freezelayout = !0, gloss_focus = form;
    }
    function glossform_blur(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), form = getParent(target, "FORM"), div = form && getParent(form, ".metabookglossform"), input = div && getChild(div, "TEXTAREA");
        div && dropClass(div, "focused"), input && metaBook.clearFocus(input), metaBook.setHUD(!1, !1), 
        gloss_blurred = fdjtTime(), metaBook.freezelayout = !1, gloss_focus = !1;
    }
    function glossform_touch(evt) {
        evt = evt || window.event, gloss_blur_timeout && clearTimeout(gloss_blur_timeout);
        var target = fdjtUI.T(evt), closing = getParent(target, ".submitclose");
        closing && dropClass(closing, "submitclose");
        var form = getParent(target, "FORM"), div = form && getParent(form, ".metabookglossform"), input = div && getChild(div, "TEXTAREA");
        return hasClass(div, "focused") ? (setTimeout(function() {
            input && (metaBook.setFocus(input), input.focus());
        }, 150), void 0) : (hasParent(target, ".addglossmenu") || hasParent(target, ".glossexposure") || (hasParent(target, ".textbox") || fdjtUI.cancel(evt), 
        addClass(div, "focused"), metaBook.setHUD(!0), glossform_focus(evt)), void 0);
    }
    function glossbutton_ontap(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), passage = getTarget(target);
        if ("addgloss" === metaBook.mode && metaBook.glosstarget === passage) fdjtUI.cancel(evt), 
        metaBook.setMode(!0); else if (passage) {
            fdjtUI.cancel(evt);
            var form = setGlossTarget(passage);
            if (!form) return;
            metaBook.setMode("addgloss"), setGlossForm(form);
        }
    }
    function glossdeleted(response, glossid, frag) {
        if (response === glossid) {
            metaBook.glossdb.drop(glossid);
            var editform = $ID("METABOOKEDITGLOSS_" + glossid);
            if (editform) {
                var editor = editform.parentNode;
                editor === $ID("METABOOKLIVEGLOSS") && (metaBook.glosstarget = !1, metaBook.setMode(!1)), 
                fdjtDOM.remove(editor);
            }
            var renderings = fdjtDOM.Array(document.getElementsByName(glossid)), i = 0, lim = renderings.length;
            if (renderings) for (;lim > i; ) {
                var rendering = renderings[i++];
                "METABOOKSKIM" === rendering.id ? fdjtDOM.replace(rendering, fdjtDOM("div.mbcard.deletedgloss")) : fdjtDOM.remove(rendering);
            }
            var glossmarks = document.getElementsByName("METABOOK_GLOSSMARK_" + frag);
            for (glossmarks = fdjtDOM.Array(glossmarks), i = 0, lim = glossmarks.length; lim > i; ) {
                var glossmark = glossmarks[i++], newglosses = RefDB.remove(glossmark.glosses, glossid);
                0 === newglosses.length ? fdjtDOM.remove(glossmark) : glossmark.glosses = newglosses;
            }
            var highlights = fdjtDOM.$(".mbexcerpt[data-glossid='" + glossid + "']");
            for (highlights = fdjtDOM.Array(highlights), i = 0, lim = highlights.length; lim > i; ) fdjtUI.Highlight.remove(highlights[i++]);
        } else fdjtUI.alert(response);
    }
    function delete_gloss(uuid) {
        var gloss = metaBook.glossdb.probe(uuid);
        if (gloss && gloss.created && gloss.maker) {
            var frag = gloss.get("frag");
            fdjt.Ajax.jsonCall(function(response) {
                glossdeleted(response, uuid, frag);
            }, "https://" + metaBook.server + "/1/delete", "gloss", uuid);
        } else gloss && gloss.frag && glossdeleted(uuid, uuid, gloss.frag);
    }
    function addoutlet_keydown(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), content = target.value, glossdiv = $ID("METABOOKLIVEGLOSS");
        if (glossdiv) {
            var form = getChild(glossdiv, "FORM"), share_cloud = metaBook.share_cloud, ch = evt.keyCode || evt.charCode;
            if (fdjtString.isEmpty(content) && 13 === ch) return share_cloud.selection ? metaBook.addOutlet2Form(form, share_cloud.selection.getAttribute("data-value")) : metaBook.setGlossMode("editnote"), 
            void 0;
            if (13 === ch && share_cloud.selection) metaBook.addOutlet2Form(form, share_cloud.selection), 
            share_cloud.complete(""), target.value = ""; else if (13 === ch) {
                var completions = share_cloud.complete(content);
                completions.length ? metaBook.addOutlet2Form(form, completions[0].getAttribute("data-value")) : metaBook.addOutlet2Form(form, content), 
                fdjtUI.cancel(evt), target.value = "", share_cloud.complete("");
            } else if (9 === ch) {
                if (share_cloud.complete(content), fdjtUI.cancel(evt), share_cloud.prefix && share_cloud.prefix !== content) return target.value = share_cloud.prefix, 
                fdjtDOM.cancel(evt), void 0;
                evt.shiftKey ? share_cloud.selectPrevious() : share_cloud.selectNext();
            } else setTimeout(function() {
                share_cloud.complete(target.value);
            }, 100);
        }
    }
    function addtag_keydown(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), content = target.value, glossdiv = $ID("METABOOKLIVEGLOSS");
        if (glossdiv) {
            var form = getChild(glossdiv, "FORM"), gloss_cloud = metaBook.gloss_cloud, ch = evt.keyCode || evt.charCode;
            if (fdjtString.isEmpty(content) && 13 === ch) return gloss_cloud.selection ? metaBook.addTag2Form(form, gloss_cloud.selection) : metaBook.setGlossMode(!1), 
            gloss_cloud.clearSelection(), void 0;
            if (13 === ch && gloss_cloud.selection) metaBook.addTag2Form(form, gloss_cloud.selection), 
            gloss_cloud.complete(""), gloss_cloud.clearSelection(), target.value = ""; else if (13 === ch) gloss_cloud.complete(content), 
            content.indexOf("|") >= 0 || content.indexOf("@") >= 0 ? metaBook.addTag2Form(form, content) : metaBook.handleTagInput(content, form, !0), 
            fdjtUI.cancel(evt), target.value = "", gloss_cloud.complete(""); else if (9 === ch) {
                if (gloss_cloud.complete(content), fdjtUI.cancel(evt), gloss_cloud.prefix && gloss_cloud.prefix !== content) return target.value = gloss_cloud.prefix, 
                fdjtDOM.cancel(evt), void 0;
                evt.shiftKey ? gloss_cloud.selectPrevious() : gloss_cloud.selectNext();
            } else setTimeout(function() {
                gloss_cloud.complete(target.value);
            }, 100);
        }
    }
    function changeAttachment(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), form = getParent(target, "form"), newtype = target.value;
        target.checked ? fdjtDOM.swapClass(form, attach_types, newtype) : dropClass(form, target.value);
    }
    function setAttachType(newtype) {
        var livegloss = $ID("METABOOKLIVEGLOSS"), form = fdjtDOM.getChild(livegloss, "FORM");
        fdjtDOM.swapClass(form, attach_types, newtype);
        var attachform = $ID("METABOOKATTACHFORM"), input = fdjtDOM.getInputFor(attachform, "ATTACHTYPE", newtype);
        fdjt.UI.CheckSpan.set(input, !0);
    }
    function attach_submit(evt) {
        evt = evt || window.event;
        var form = fdjtUI.T(evt);
        "FORM" !== form.tagName && (form = getParent(form, "form"));
        var livegloss = $ID("METABOOKLIVEGLOSS"), linkinput = fdjtDOM.getInput(form, "URL"), titleinput = fdjtDOM.getInput(form, "TITLE"), title = titleinput.value && fdjtString.stdspace(titleinput.value), isokay = fdjtDOM.getInput(form, "FILEOKAY"), path = linkinput.value;
        if (fdjtUI.cancel(evt), livegloss) {
            if (!title && path) {
                var namestart = path.indexOf("/") >= 0 ? path.search(/\/[^\/]+$/) : 0;
                title = 0 > namestart ? path : path.slice(namestart);
            }
            if (hasClass(form, "link")) {
                if (!goodURL(linkinput.value)) return fdjtUI.alert("This URL doesn't look right"), 
                void 0;
                metaBook.editlink ? (changeLink(form, metaBook.editlink, linkinput.value, title), 
                metaBook.editlink = !1) : addLink(form, linkinput.value, title), fdjtDOM.addClass(livegloss, "modified"), 
                metaBook.setGlossMode("editnote"), clearAttachForm();
            } else if (hasClass(form, "upload")) {
                if (!metaBook.glossattach && !metaBook.editlink) return fdjtUI.alert("You need to specify a file!"), 
                void 0;
                if (metaBook.glossattach && !isokay.checked) fdjt.UI.choose([ {
                    label: "Yes",
                    handler: function() {
                        fdjtUI.CheckSpan.set(isokay, !0), doFileAttach(title, livegloss);
                    }
                }, {
                    label: "Cancel"
                } ], fdjtDOM("P", "By choosing 'Yes,' I affirm that ", "I have the right to use and share this ", "file according to the sBooks ", fdjtDOM.Anchor("https://www.bookhub.io/legalia/TOS/", "A[target='_blank']", "Terms of Service"), ".")); else if (metaBook.glossattach) {
                    var filename = metaBook.glossattach.name;
                    attachFile(metaBook.glossattach, title || metaBook.glossattach.name, livegloss).then(function(req) {
                        metaBook.editlink ? (changeLink(livegloss, metaBook.editlink, req.responseURL, title), 
                        metaBook.editlink = !1) : addLink(livegloss, req.responseURL, title || filename || "attachment"), 
                        fdjtDOM.addClass("METABOOKLIVEGLOSS", "modified"), metaBook.setGlossMode("editnote"), 
                        clearAttachForm();
                    }).catch(function(trouble) {
                        fdjtLog("Trouble attaching file %o (%o)", metaBook.glossattach, trouble);
                    });
                } else metaBook.editlink ? (fdjtDOM.addClass("METABOOKLIVEGLOSS", "modified"), changeLink(livegloss, metaBook.editlink, metaBook.editlink, title), 
                clearAttachForm(), metaBook.editlink = !1) : fdjtLog.warn("Fall through in attach_submit");
            } else fdjtLog.warn("Fall through in attach_submit");
        }
    }
    function attach_cancel(evt) {
        var livegloss = $ID("METABOOKLIVEGLOSS");
        clearAttachForm(), fdjtUI.cancel(evt), livegloss && metaBook.setGlossMode("editnote");
    }
    function attach_keydown(evt) {
        evt = evt || window.event;
        var ch = evt.keyCode || evt.charCode;
        if (13 === ch) {
            fdjtUI.cancel(evt);
            var livegloss = $ID("METABOOKLIVEGLOSS");
            livegloss && (attach_submit(evt), metaBook.setGlossMode("editnote"));
        }
    }
    function editLink(href, title) {
        if (metaBook.editlink = href, setGlossMode("attach"), 0 === href.search(/https:\/\/glossdata\./)) {
            var name = /\/([^\/]+)$/.exec(href);
            setAttachType("upload"), addClass("METABOOKGLOSSATTACH", "haveupload"), $ID("METABOOKATTACHFILENAME").innerHTML = name[1];
        } else href.search(/\/capture\.[A-Za-z0-9]+$/) >= 0 ? setAttachType("capture") : (setAttachType("link"), 
        $ID("METABOOKATTACHURL").value = href);
        fdjt.UI.CheckSpan.set($ID("METABOOKUPLOADRIGHTS"), !0), $ID("METABOOKATTACHTITLE").value = title || href, 
        addClass($ID("METABOOKATTACHFORM"), "editlink"), $ID("METABOOKATTACHTITLE").focus();
    }
    function doFileAttach(title, livegloss) {
        var filename = metaBook.glossattach.name;
        attachFile(metaBook.glossattach, title || metaBook.glossattach.name, livegloss).then(function(req) {
            metaBook.editlink ? (changeLink(livegloss, metaBook.editlink, req.responseURL, title), 
            metaBook.editlink = !1) : addLink(livegloss, req.responseURL, title || filename || "attachment"), 
            metaBook.setGlossMode("editnote"), addClass(livegloss, "modified"), clearAttachForm();
        }).catch(function(trouble) {
            fdjtLog("Trouble attaching file %o (%o)", metaBook.glossattach, trouble);
        });
    }
    function attach_file_click(evt) {
        var file_input = $ID("METABOOKFILEINPUT"), ev = document.createEvent("MouseEvents");
        ev.initMouseEvent("click", !0, !0, evt.view), file_input.dispatchEvent(ev), fdjtUI.cancel(evt);
    }
    function clearAttachForm() {
        var linkinput = $ID("METABOOKATTACHURL"), titleinput = $ID("METABOOKATTACHTITLE"), rightsok = $ID("METABOOKUPLOADRIGHTS"), fileinput = $ID("METABOOKFILEINPUT");
        linkinput.value = "", titleinput.value = "", fdjtDOM.dropClass("METABOOKGLOSSATTACH", "haveupload"), 
        $ID("METABOOKATTACHFILE").className = "nofile", $ID("METABOOKATTACHFILENAME").innerHTML = "", 
        fdjt.UI.CheckSpan.set(rightsok, !1), dropClass($ID("METABOOKATTACHFORM"), "editlink"), 
        metaBook.glossattach = !1, metaBook.editlink = !1, fileinput.value = "";
    }
    function attach_delete(evt) {
        var oldlink = metaBook.editlink, livegloss = $ID("METABOOKLIVEGLOSS"), exists = fdjtDOM.getChild(livegloss, "[data-href='" + oldlink + "']");
        fdjtUI.cancel(evt), exists && (addClass(livegloss, "modified"), fdjtUI.CheckSpan.set(exists, !1)), 
        clearAttachForm(), setGlossMode("editnote");
    }
    function attachFile(file, title, livegloss) {
        function attaching_file(resolve, reject) {
            savereq.onreadystatechange = function() {
                aborted || done || 4 === savereq.readyState && (200 === savereq.status ? (metaBook.glossattach = !1, 
                done = !0, resolve(savereq)) : (done = aborted = !0, reject(savereq)));
            }, savereq.ontimeout = function(evt) {
                reject(evt);
            }, savereq.open("POST", endpoint), savereq.setRequestHeader("content-type", filetype), 
            savereq.withCredentials = !0, savereq.send(file);
        }
        var glossid = fdjtDOM.getInputValue(livegloss, "UUID"), itemid = fdjtState.getUUID(), filename = file.name, filetype = file.type, savereq = new XMLHttpRequest(), endpoint = "https://glossdata.bookhub.io/" + glossid + "/" + itemid + "/" + filename, aborted = !1, done = !1;
        return new Promise(attaching_file);
    }
    function glossetc_click(evt) {
        var target = fdjtUI.T(evt), link = getParent(target, ".glosslink");
        if (link) return editLink(link.getAttribute("data-href"), link.title), fdjtUI.cancel(evt), 
        void 0;
        fdjtUI.CheckSpan.onclick(evt);
        var form = getParent(target, "form"), input = getInput(form, "NOTE");
        input.focus();
    }
    function addGlossDragOK(evt) {
        evt = evt || window.event;
        var types = evt.dataTransfer.types;
        if (types) if (types.indexOf("Files") >= 0) fdjt.UI.cancel(evt); else if (types.indexOf("text/uri-list") >= 0) fdjt.UI.cancel(evt); else if (types.indexOf("text/plain") >= 0) {
            var text = evt.dataTransfer.getData("text/plain");
            0 === text.search(/^\s*https?:\/\//) && fdjt.UI.cancel(evt);
        }
    }
    function addGlossDrop(evt) {
        evt = evt || window.event;
        var attachform = $ID("METABOOKATTACHFORM"), types = evt.dataTransfer.types;
        if (types) if (types.indexOf("Files") >= 0) {
            var files = evt.dataTransfer.files, file = files[0];
            fdjtUI.cancel(evt), metaBook.glossattach = file, setAttachType("uploadfile"), $ID("METABOOKATTACHFILENAME").innerHTML = file.name, 
            fdjtDOM.addClass("METABOOKGLOSSATTACH", "haveupload"), hasClass(attachform, "editlink") && fdjt.UI.CheckSpan.set($ID("METABOOKUPLOADRIGHTS"), !1);
        } else if (types.indexOf("text/uri-list") >= 0) {
            var url = evt.dataTransfer.getData("URL") || evt.dataTransfer.getData("text/uri-list");
            if (!url) return;
            fdjt.UI.cancel(evt), metaBook.setGlossMode("attach"), setAttachType("linkurl"), 
            $ID("METABOOKATTACHURL").value = url, $ID("METABOOKATTACHTITLE").focus();
        } else if (types.indexOf("text/plain") >= 0) {
            var text = evt.dataTransfer.getData("text/plain");
            if (fdjt.UI.cancel(evt), 0 === text.search(/^\s*https?:\/\//)) metaBook.setGlossMode("attach"), 
            hasClass(attachform, "linkurl") || hasClass(attachform, "copyurl") || setAttachType("linkurl"), 
            $ID("METABOOKATTACHURL").value = text, $ID("METABOOKATTACHTITLE").focus(); else {
                var livegloss = $ID("METABOOKLIVEGLOSS"), input = fdjtDOM.getInput(livegloss, "NOTE");
                metaBook.setGlossMode(!1), input.value = text, input.focus();
            }
        }
    }
    function glossUploadChanged(evt) {
        var target = fdjtUI.T(evt), file = target.files[0];
        file && (metaBook.glossattach = file, $ID("METABOOKATTACHFILENAME").innerHTML = file.name, 
        fdjtDOM.addClass("METABOOKGLOSSATTACH", "haveupload"), hasClass("METABOOKATTACHFORM", "editlink") && fdjt.UI.CheckSpan.set($ID("METABOOKUPLOADRIGHTS"), !1));
    }
    function editglossnote(evt) {
        evt = evt || window.event, metaBook.setGlossMode("editnote"), fdjtUI.cancel(evt);
    }
    function startGloss(passage) {
        var selecting = metaBook.UI.selectText(passage);
        metaBook.TapHold.body && metaBook.TapHold.body.abort && metaBook.TapHold.body.abort(), 
        metaBook.select_target = passage, selectors.push(selecting), selectors[passage.id] = selecting, 
        fdjtUI.TapHold.clear(), startAddGloss(passage, !1, !1);
    }
    function startAddGloss(passage, mode, evt) {
        if (metaBook.glosstarget === passage) return (Trace.gestures || Trace.glossing) && fdjtLog("startAddGloss/resume %o %o form=%o", evt, passage, metaBook.glossform), 
        mode && metaBook.setGlossMode(mode, metaBook.glossform), metaBook.setMode("addgloss", !0), 
        evt && fdjtUI.cancel(evt), void 0;
        var selecting = selectors[passage.id];
        abortSelect(selecting);
        var form_div = setGlossTarget(passage, "addgloss" === metaBook.mode && metaBook.glossform, selecting), form = getChild(form_div, "form");
        form && (evt && fdjtUI.cancel(evt), (Trace.gestures || Trace.glossing) && fdjtLog("startAddGloss (%o) %o f=%o/%o", evt, passage, form_div, form), 
        setGlossForm(form_div), mode && (form.className = mode), metaBook.setMode("addgloss", !1));
    }
    function saveGlossDialog() {
        var msg = fdjtDOM("div.message", "Saving gloss");
        saving_dialog = !0;
        var choices = [ {
            label: "Save",
            handler: function() {
                metaBook.submitGloss(), saving_dialog = !1;
            },
            value: "SAVE",
            isdefault: !0
        }, {
            label: "Discard",
            value: "DISCARD",
            handler: function() {
                metaBook.cancelGloss(), saving_dialog = !1;
            }
        } ], spec = {
            choices: choices,
            timeout: metaBook.save_gloss_timeout || metaBook.choice_timeout || 7,
            spec: "div.fdjtdialog.fdjtconfirm.savegloss"
        };
        return saving_dialog = fdjtUI.choose(spec, msg);
    }
    function startSelect(passage, evt) {
        var selecting = metaBook.UI.selectText(passage);
        metaBook.TapHold.body && metaBook.TapHold.body.abort && metaBook.TapHold.body.abort(), 
        metaBook.select_target = passage, selectors.push(selecting), selectors[passage.id] = selecting, 
        fdjtUI.TapHold.clear(), (Trace.gestures || Trace.selecting) && fdjtLog("body_held/select_wait %o %o %o", selecting, passage, evt), 
        setTimeout(function() {
            (Trace.gestures || Trace.selecting) && fdjtLog("body_held/select_start %o %o %o", selecting, passage, evt), 
            selecting.startEvent(evt, 250);
        }, 0);
    }
    function abortSelect(except) {
        for (var i = 0, lim = selectors.length; lim > i; ) {
            var sel = selectors[i++];
            sel !== except && sel.clear();
        }
        selectors = [], metaBook.select_target = !1;
    }
    function closeGlossForm(glossform, evt) {
        glossform || (glossform = metaBook.glossform), glossform && (saving_dialog || (hasClass(glossform, "modified") ? hasClass(glossform, "glossadd") ? saveGlossDialog() : metaBook.submitGloss(glossform) : metaBook.cancelGloss(), 
        evt && fdjtUI.cancel(evt)));
    }
    var fdjtString = fdjt.String, fdjtState = fdjt.State, fdjtTime = fdjt.Time, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, RefDB = fdjt.RefDB, Ref = fdjt.Ref, $ID = fdjt.ID, mB = metaBook, mbID = mB.ID, Trace = metaBook.Trace, addClass = fdjtDOM.addClass, hasClass = fdjtDOM.hasClass, dropClass = fdjtDOM.dropClass, toggleClass = fdjtDOM.toggleClass, swapClass = fdjtDOM.swapClass, getParent = fdjtDOM.getParent, hasParent = fdjtDOM.hasParent, getChildren = fdjtDOM.getChildren, getChild = fdjtDOM.getChild, getInput = fdjtDOM.getInput, getInputs = fdjtDOM.getInputs, getInputFor = fdjtDOM.getInputFor, getInputsFor = fdjtDOM.getInputsFor, getInputValues = fdjtDOM.getInputValues, cancel = fdjtUI.cancel, setCheckSpan = fdjtUI.CheckSpan.set, glossmodes = metaBook.glossmodes, mbicon = metaBook.icon, getTarget = metaBook.getTarget, getGlossTags = metaBook.getGlossTags, uri_prefix = /(http:)|(https:)|(ftp:)|(urn:)/, saving_dialog = !1, selectors = [];
    metaBook.getGlossMode = getGlossMode, metaBook.setGlossMode = setGlossMode, metaBook.getGlossForm = getGlossForm, 
    metaBook.setGlossTarget = setGlossTarget, metaBook.setSelecting = setSelecting, 
    metaBook.UI.selectText = selectText, metaBook.setGlossForm = setGlossForm, metaBook.addOutlet2Form = addOutlet, 
    metaBook.setExcerpt = setExcerpt, metaBook.addTag2Form = addTag, metaBook.setGlossNetwork = function(form, network, checked) {
        if ("string" == typeof form && (form = $ID(form)), form) {
            var input = getInput(form, "NETWORKS", network);
            if (input) {
                var cs = getParent(input, ".checkspan");
                cs && setCheckSpan(cs, checked);
            }
        }
    };
    var tag_delims = {
        '"': '"',
        "'": "'",
        "/": "/",
        "<": ">",
        "[": "]",
        "(": ")",
        "{": "}",
        "«": "»"
    }, tag_ends = /["'\/\[(<{}>)\]«»]/g, glossinput_timer = !1;
    metaBook.findTag = findTag;
    var stdspace = fdjtString.stdspace;
    metaBook.handleTagInput = handleTagInput, metaBook.UI.handlers.glosscloud_select = glosscloud_select, 
    metaBook.UI.sharecloud_ontap = sharecloud_ontap;
    var login_message = !1;
    metaBook.submitGloss = submitGloss, metaBook.cancelGloss = cancelGloss;
    var queued_data = {};
    metaBook.writeQueuedGlosses = writeQueuedGlosses, metaBook.UI.glossform_outlets_tapped = glossform_outlets_tapped;
    var slip_timeout = !1;
    metaBook.UI.changeGlossNetwork = changeGlossNetwork, metaBook.UI.changeGlossPosting = changeGlossPosting, 
    metaBook.UI.changeGlossPrivacy = changeGlossPrivacy;
    var gloss_focus = !1, gloss_blurred = !1, gloss_blur_timeout = !1;
    metaBook.UI.glossFormFocus = glossform_focus, metaBook.UI.glossform_touch = glossform_touch, 
    metaBook.UI.glossform_focus = glossform_focus, metaBook.UI.glossform_blur = glossform_blur;
    var attach_types = /\b(link|upload|body|capture)\b/g;
    metaBook.UI.changeAttachment = changeAttachment, metaBook.setAttachType = setAttachType, 
    metaBook.startGloss = startGloss, metaBook.startAddGloss = startAddGloss, metaBook.saveGlossDialog = saveGlossDialog, 
    metaBook.startSelect = startSelect, metaBook.abortSelect = abortSelect, metaBook.getTextSelectors = function() {
        return selectors;
    }, metaBook.closeGlossForm = closeGlossForm, fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, {
        ".metabookglossform": {
            click: glossform_touch,
            touchstart: glossform_touch
        },
        glossbutton: {
            mouseup: glossbutton_ontap,
            mousedown: cancel
        },
        "span.metabooksharegloss": {
            tap: fdjt.UI.CheckSpan.onclick
        },
        ".metabookglossform .response": {
            click: metaBook.toggleHUD
        },
        ".addglossmenu": {
            tap: glossmode_tap,
            hold: glossmode_hold,
            slip: glossmode_slip,
            release: glossmode_release,
            click: cancel
        },
        "div.glossetc": {
            click: glossetc_click
        },
        "div.glossetc div.sharing": {
            click: glossform_outlets_tapped
        },
        "div.glossetc div.notetext": {
            click: editglossnote
        },
        "#METABOOKADDGLOSS": {
            dragenter: addGlossDragOK,
            dragover: addGlossDragOK,
            drop: addGlossDrop
        },
        "#METABOOKATTACHFILE": {
            click: attach_file_click
        },
        "#METABOOKGLOSSATTACH": {
            dragenter: addGlossDragOK,
            dragover: addGlossDragOK,
            drop: addGlossDrop
        },
        "#METABOOKADDTAGINPUT": {
            keydown: addtag_keydown
        },
        "#METABOOKADDSHAREINPUT": {
            keydown: addoutlet_keydown
        },
        "#METABOOKATTACHFORM": {
            submit: attach_submit
        },
        "#METABOOKATTACHURL": {
            keydown: attach_keydown
        },
        "#METABOOKATTACHTITLE": {
            keydown: attach_keydown
        },
        "#METABOOKATTACHCANCEL": {
            click: attach_cancel
        },
        "#METABOOKATTACHDELETE": {
            click: attach_delete
        },
        "#METABOOKFILEINPUT": {
            change: glossUploadChanged
        },
        "#METABOOKGLOSSCLOUD": {
            tap: metaBook.UI.handlers.glosscloud_select,
            release: metaBook.UI.handlers.glosscloud_select
        },
        "#METABOOKSHARECLOUD": {
            tap: outlet_select,
            release: outlet_select
        }
    }), fdjt.DOM.defListeners(metaBook.UI.handlers.touch, {
        ".metabookglossform .response": {
            click: metaBook.toggleHUD
        },
        ".addglossmenu": {
            tap: glossmode_tap,
            hold: glossmode_hold,
            slip: glossmode_slip,
            release: glossmode_release,
            click: cancel
        },
        "div.glossetc": {
            touchstart: glossetc_click,
            touchend: cancel
        },
        "div.glossetc div.sharing": {
            touchend: glossform_outlets_tapped,
            click: cancel
        },
        "div.glossetc div.notetext": {
            touchend: editglossnote,
            click: cancel
        },
        "#METABOOKADDTAGINPUT": {
            keydown: addtag_keydown
        },
        "#METABOOKADDSHAREINPUT": {
            keydown: addoutlet_keydown
        },
        "#METABOOKATTACHFORM": {
            submit: attach_submit
        },
        "#METABOOKATTACHURL": {
            keydown: attach_keydown
        },
        "#METABOOKATTACHTITLE": {
            keydown: attach_keydown
        },
        "#METABOOKATTACHFILE": {
            click: attach_file_click
        },
        "#METABOOKATTACHCANCEL": {
            click: attach_cancel
        },
        "#METABOOKATTACHDELETE": {
            click: attach_delete
        },
        "#METABOOKADDGLOSS": {
            dragenter: addGlossDragOK,
            dragover: addGlossDragOK,
            drop: addGlossDrop
        },
        "#METABOOKFILEINPUT": {
            change: glossUploadChanged
        },
        "#METABOOKGLOSSCLOUD": {
            tap: metaBook.UI.handlers.glosscloud_select,
            release: metaBook.UI.handlers.glosscloud_select
        },
        "#METABOOKSHARECLOUD": {
            tap: outlet_select,
            release: outlet_select
        }
    });
}(), function() {
    "use strict";
    function previewTimeout(fcn, interval) {
        if (fcn === !0) return preview_timer;
        if (fcn) {
            if (preview_timer) return;
            setTimeout(function() {
                preview_timer = !1, fcn();
            }, interval || 400);
        } else preview_timer && (clearTimeout(preview_timer), preview_timer = !1);
    }
    function slipTimeout(fcn, interval) {
        if (fcn === !0) return slip_timer;
        if (fcn) {
            if (slip_timer) return;
            setTimeout(function() {
                slip_timer = !1, fcn();
            }, interval || 500);
        } else slip_timer && (clearTimeout(slip_timer), slip_timer = !1);
    }
    function addHandlers(node, type) {
        var mode = metaBook.ui;
        fdjtDOM.addListeners(node, mB.UI.handlers[mode][type]);
    }
    function setupGestures(domnode) {
        var mode = metaBook.ui;
        if (mode || (metaBook.ui = mode = "mouse"), !domnode && (Trace.startup > 1 || Trace.gestures) && fdjtLog("Setting up basic handlers for %s UI", mode), 
        domnode && Trace.gestures && fdjtLog("Setting up %s UI handlers for %o", mode, domnode), 
        domnode || (addHandlers(!1, "window"), addHandlers(document, "document"), addHandlers(document.body, "body"), 
        addHandlers(metaBook.HUD, "hud")), mode) {
            var handlers = metaBook.UI.handlers[mode], keys = [], seen = [];
            for (var key in handlers) handlers.hasOwnProperty(key) && (key.indexOf(".") >= 0 || key.indexOf("#") >= 0) && keys.push(key);
            keys = keys.sort(function(kx, ky) {
                return ky.length - kx.length;
            });
            for (var i = 0, lim = keys.length; lim > i; ) {
                key = keys[i++];
                var nodes = fdjtDOM.$(key, domnode), h = handlers[key], sel = new Selector(key);
                domnode && sel.match(domnode) && fdjtDOM.addListeners(domnode, h);
                for (var j = 0, jlim = nodes.length; jlim > j; ) {
                    var node = nodes[j++];
                    0 > seen.indexOf(node) && (seen.push(node), fdjtDOM.addListeners(node, h));
                }
            }
        }
        Trace.startup > 2 && fdjtLog("Done with handler setup");
    }
    function clear_hold(caller) {
        held && (clearTimeout(held), held = !1, Trace.gestures && fdjtLog("clear_hold from %s", caller || "somewhere"));
    }
    function body_tapped(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), sX = evt.screenX, sY = evt.screenY, cX = evt.clientX, cY = evt.clientY, now = fdjtTime(), touch = !1, vw = fdjtDOM.viewWidth();
        if (evt.changedTouches && evt.changedTouches.length && (touch = evt.changedTouches[0], 
        sX = touch.screenX, sY = touch.screenY, cX = touch.clientX, cY = touch.clientY), 
        Trace.gestures && fdjtLog("body_tapped %o c=%d,%d now=%o p=%o %s", evt, cX, cY, now, mB.previewing, touch ? "(touch)" : ""), 
        mB.previewing) {
            var jumpto = getTarget(target);
            return mB.stopPreview("body_tapped/stop_preview", jumpto || !0), fdjtUI.TapHold.clear(), 
            cancel(evt), !1;
        }
        if (hasClass(document.body, "mbSHOWHELP")) return dropClass(document.body, "mbSHOWHELP"), 
        cancel(evt), void 0;
        if (mB.touch && mB.textinput) return mB.clearFocus(mB.textinput), cancel(evt), void 0;
        if (mB.passage_menu) return Trace.gestures && fdjtLog("body_tapped %o closing menu %o", evt, mB.passage_menu), 
        mB.TapHold.body && metaBook.TapHold.body.abort(), cancel(evt), closePassageMenu(evt);
        if (mB.skimming) return mB.hudup ? setHUD(!1, !1) : touch && vw / 4 > cX ? pageBackward(evt, !0) : touch && vw / 4 > cX ? pageForward(evt, !0) : setHUD(!1), 
        cancel(evt), void 0;
        if (mB.glosstarget) {
            var glossform = metaBook.glossform;
            return hasParent(target, mB.glosstarget) ? (setMode("addgloss", !1), cancel(evt), 
            void 0) : (metaBook.closeGlossForm(glossform), cancel(evt), void 0);
        }
        return mB.hudup || mB.mode ? (setMode(!1), setHUD(!1), $ID("METABOOKOPENGLOSSMARK") && (mB.target && metaBook.clearHighlights(mB.target), 
        $ID("METABOOKOPENGLOSSMARK").id = ""), cancel(evt), gesture_start = !1, clicked = fdjtTime(), 
        !1) : $ID("METABOOKOPENGLOSSMARK") ? ($ID("METABOOKOPENGLOSSMARK").id = "", mB.target && metaBook.clearHighlights(mB.target), 
        cancel(evt), gesture_start = !1, void 0) : hasParent(target, ".glossmark") || handle_content_click(target) ? (cancel(evt), 
        !1) : (Trace.gestures && fdjtLog("body_tapped/fallthrough (%o) %o, m=%o, @%o,%o, vw=%o", evt, target, mB.mode, cX, cY, fdjtDOM.viewWidth()), 
        mB.fullheight && !mB.hudup && (50 > cY || cY > fdjtDOM.viewHeight() - 50) ? setHUD(!0) : .4 * fdjtDOM.viewWidth() > cX ? pageBackward(evt, !0) : pageForward(evt, !0), 
        cancel(evt), gesture_start = !1, void 0);
    }
    function resolve_anchor(ref) {
        var elt = mbID(ref);
        if (elt) return elt;
        var elts = document.getElementsByName(ref);
        if (0 === elts.length) return !1;
        if (1 === elts.length) return elts[0];
        for (var found = 0, i = 0, lim = elts.length, metabook_page = metaBook.page; lim > i; ) {
            var r = elts[i++];
            if (hasClass(r, "metabookdupstart")) return r;
            found || hasParent(r, metabook_page) && (found = 4);
        }
        return found ? found : elts[0];
    }
    function handle_content_click(target) {
        if (clicked && 1e3 > fdjtTime() - clicked) return !0;
        var href, anchor = getParent(target, "A"), elt = !1, rel = anchor.rel, classname = anchor.className;
        if ("string" != typeof classname && (classname = ""), "string" != typeof rel && (rel = ""), 
        anchor && anchor.href && (href = anchor.getAttribute("href"))) {
            if (Trace.gestures && fdjtLog("ctouch: follow link %s", href), "#" === href[0]) {
                var idref = href.slice(1);
                if ("string" != typeof classname && (classname = ""), "string" != typeof rel && (rel = ""), 
                rel.search(note_classes) >= 0 || classname.search(noteref_classes) >= 0 || mB.noterefspecs && mB.noterefspecs.match(anchor)) {
                    var note_node = getNoteNode(idref), noteid = note_node.id;
                    metaBook.DOM.noteshud.innerHTML = "";
                    var shownote = note_node.cloneNode(!0);
                    return fdjtDOM.stripIDs(shownote), dropClass(shownote, /\bmetabook\S+/g), addClass(shownote, "metabooknotebody"), 
                    metaBook.DOM.noteshud.setAttribute("data-note", noteid || idref), fdjtDOM.append(mbDOM.noteshud, shownote), 
                    setMode("shownote"), gesture_start = !1, clicked = fdjtTime(), !0;
                }
                if (rel.search(aside_rels) >= 0) {
                    var aside_target = $ID(idref);
                    return fdjtDOM.removeChildren(mbDOM.asidehud), fdjtDOM.append(mbDOM.asidehud, aside_target.cloneNode(!0)), 
                    setMode("showaside"), gesture_start = !1, clicked = fdjtTime(), !0;
                }
                if (metaBook.xtargets[idref]) {
                    var fn = metaBook.xtargets[idref];
                    return gesture_start = !1, clicked = fdjtTime(), fn(), !0;
                }
                return (elt = resolve_anchor(idref)) ? (metaBook.JumpTo(elt), gesture_start = !1, 
                clicked = fdjtTime(), !0) : (fdjtLog.warn("Couldn't resolve %s", idref), !0);
            }
            return rel.search(iframe_rels) >= 0 || classname.search(iframe_classes) >= 0 ? (gesture_start = !1, 
            fdjtDOM.triggerClick(anchor), !0) : (anchor.target || (anchor.target = "_blank"), 
            gesture_start = !1, fdjtDOM.triggerClick(anchor), !0);
        }
        var details = getParent(target, "details,.html5details,.sbookdetails");
        if (details) return fdjtDOM.removeChildren(mbDOM.notehud), metaBook.DOM.notehud.innerHTML = details.innerHTML, 
        setMode("showdetails"), clicked = fdjtTime(), !0;
        var aside = getParent(target, "aside,.html5aside,.sbookaside");
        if (aside) return fdjtDOM.removeChildren(mbDOM.asidehud), metaBook.DOM.asidehud.innerHTML = aside.innerHTML, 
        setMode("showaside"), clicked = fdjtTime(), !0;
        var glossref = getParent(target, "[data-glossid]");
        if (glossref) {
            var glossid = glossref.getAttribute("data-glossid"), gloss = metaBook.glossdb.ref(glossid);
            if (!gloss) return !1;
            var slicediv = fdjtDOM("div.metabookglosses.metabookslice"), slice = new MetaBookSlice(slicediv, [ gloss ], !1), hudwrapper = fdjtDOM("div.hudpanel#METABOOKPOINTGLOSSES", slicediv);
            return fdjtDOM.replace("METABOOKPOINTGLOSSES", hudwrapper), metaBook.setTarget(target), 
            slice.update(), setMode("openglossmark"), !0;
        }
        return !1;
    }
    function getNoteNode(ref) {
        var elt = mbID(ref), body = $ID("METABOOKBODY"), db = document.body;
        if (!elt) {
            var elts = document.getElementsByName(ref);
            if (!body) return !1;
            if (elts.length) for (var i = 0, lim = elts.length; lim > i; ) {
                if (hasParent(elt[i], body)) {
                    elt = elt[i];
                    break;
                }
                i++;
            }
        }
        if (elt) {
            for (var scan = elt, style = fdjtDOM.getStyle(elt), block = !1, notespecs = metaBook.notespecs; scan && scan !== body && scan !== db; ) {
                if (notespecs && notespecs.match(scan)) return scan;
                block || "block" === style.display && (block = scan, style = !1), scan = scan.parentNode, 
                style = fdjtDOM.getStyle(scan);
            }
            return block ? block : elt;
        }
    }
    function jumpToNote(evt) {
        evt = evt || window.event;
        var target = fdjt.UI.T(evt), anchor = getParent(target, "A[href]");
        if (!anchor) {
            cancel(evt);
            var noteshud = mB.DOM.noteshud, jumpto = noteshud.getAttribute("data-note");
            jumpto ? (noteshud.removeAttribute("data-note"), noteshud.innerHTML = "", mB.setMode(!1), 
            mB.GoTo(jumpto, "jumpToNote", !0, !0)) : mB.setMode(!1);
        }
    }
    function body_held(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), passage = getTarget(target);
        if (Trace.gestures && fdjtLog("body_held %o p=%o p.p=%o bc=%s hc=%s", evt, passage, passage && passage.parentNode, document.body.className, metaBook.HUD.className), 
        !mB.previewing) {
            if (hasParent(target, "A")) {
                var anchor = getParent(target, "A"), href = anchor && anchor.getAttribute("href");
                if (cancel(evt), href && "#" === href[0] && mbID(href.slice(1))) return Trace.gestures && fdjtLog("anchor_preview/body_held %o %o %o", evt, anchor, href), 
                mB.startPreview(href.slice(1), "content/anchor_held"), void 0;
            }
            if (passage) {
                if (mB.glosstarget === passage) return "addgloss" !== mB.mode && setMode("addgloss", !1), 
                void 0;
                if (mB.skimming) return cancel(evt), Trace.gestures && fdjtLog("stop_skimming/body_held %o skimming=%o", evt, mB.skimming), 
                mB.stopSkimming(), setHUD(!1), mB.TapHold.body.abort(), void 0;
                mB.startSelect(passage, evt), mB.startAddGloss(passage, !1, evt);
            }
        }
    }
    function body_taptap(evt) {
        var target = fdjtUI.T(evt), passage = getTarget(target);
        if (Trace.gestures && fdjtLog("body_taptap %o p=%o p.p=%o bc=%s hc=%s t=%o gt=%o", evt, passage, passage && passage.parentNode, document.body.className, mB.HUD.className, target, mB.glosstarget), 
        hasParent(target, "IMG,AUDIO,VIDEO,OBJECT")) return mB.startZoom(getParent(target, "IMG,AUDIO,VIDEO,OBJECT")), 
        cancel(evt), void 0;
        if (mB.glosstarget && (hasParent(target, mB.glosstarget) ? setMode("addgloss", !1) : metaBook.closeGlossForm()), 
        passage) {
            if (mB.glosstarget === passage) return "addgloss" !== mB.mode && setMode("addgloss", !1), 
            void 0;
            var choices = [ {
                label: "Add Gloss",
                classname: "addgloss",
                handler: function() {
                    mB.startGloss(passage);
                },
                isdefault: !0
            } ];
            if (choices.push({
                label: "Zoom content",
                classname: "zoomcontent",
                handler: function() {
                    mB.startZoom(passage), cancel(evt);
                }
            }), addOptions(passage, choices), 1 === choices.length) return cancel(evt), mB.startGloss(passage), 
            void 0;
            cancel(evt), choices.push({
                label: "Cancel",
                classname: "cancel",
                handler: function() {
                    metaBook.cancelGloss();
                }
            });
            var spec = {
                choices: choices,
                spec: "div.fdjtdialog.metabooktaptap"
            };
            metaBook.passage_menu = fdjtUI.choose(spec);
        }
    }
    function addOptions(passage, choices) {
        for (var scan = passage; scan; ) {
            var link = passage.getAttribute("data-xref");
            if (link) {
                var space = link.indexOf(" "), href = space > 0 ? link.slice(0, space) : link, label = space > 0 ? link.slice(space + 1) : link, data = {
                    id: passage.id,
                    docid: mB.docref,
                    refuri: mB.refuri,
                    docuri: mB.docuri
                };
                mB.user && mB.user._id && (data.user = mB.user._id);
                var opt = {
                    label: label,
                    handler: makeOpener(fillIn(href, data))
                };
                choices.push(opt);
            }
            scan = scan.parentNode;
        }
        for (var anchors = getChildren(passage, "a[href]"), i = 0, lim = anchors.length; lim > i; ) {
            var anchor = anchors[i++], linkref = decodeEntities(anchor.getAttribute("href")), handler = 0 === linkref.search("#") ? makeGoTo(linkref) : makeOpener(anchor.href), anchor_text = fdjtDOM("span.anchortext");
            anchor_text.innerHTML = anchor.title || anchor.innerHTML;
            var anchor_opt = {
                handler: handler,
                label: anchor_text,
                classname: "anchor"
            };
            choices.push(anchor_opt);
        }
    }
    function closePassageMenu(evt) {
        if (evt = evt || window.event, !mB.passage_menu) return !1;
        if (evt) {
            var target = fdjtUI.T(evt);
            if (mB.passage_menu && hasParent(target, mB.passage_menu)) return !1;
        }
        var menu = mB.passage_menu;
        return mB.passage_menu = !1, fdjt.Dialog.close(menu), evt && cancel(evt), !0;
    }
    function makeGoTo(href) {
        return function() {
            metaBook.GoTo(href);
        };
    }
    function makeOpener(url) {
        return function() {
            window.open(url);
        };
    }
    function body_touchstart(evt) {
        if (evt = evt || window.event, body_tapstart = !1, !mB.zoomed) {
            var target = fdjtUI.T(evt);
            "METABOOKBODY" === target.id && (body_tapstart = fdjtTime());
        }
    }
    function body_touchend(evt) {
        if (evt = evt || window.event, !mB.zoomed) {
            var target = fdjtUI.T(evt);
            if ("METABOOKBODY" === target.id && body_tapstart && 1e3 > fdjtTime() - body_tapstart) {
                mB.TapHold.body && metaBook.TapHold.body.abort(), cancel(evt);
                var x = evt.clientX || evt.changedTouches && evt.changedTouches.length && evt.changedTouches[0].clientX, w = fdjtDOM.viewWidth();
                x > w / 2 ? pageForward(evt) : pageBackward(evt);
            }
        }
    }
    function body_released(evt) {
        if (evt = evt || window.event, !mB.zoomed) {
            var target = fdjtUI.T(evt), children = !1;
            if (Trace.gestures && fdjtLog("body_released %o", evt), mB.previewing) return mB.stopPreview("body_released"), 
            cancel(evt), void 0;
            if (hasParent(target, "A")) return cancel(evt), void 0;
            var passage = hasParent(target, ".fdjtselecting") && getTarget(target);
            if (!passage) {
                if (children = getChildren(target, ".fdjtselected"), 0 === children.length) return metaBook.abortSelect(), 
                void 0;
                target = children[0], passage = getTarget(target);
            }
            Trace.gestures && fdjtLog("body_released %o p=%o gt=%o gf=%o", evt, passage, mB.glosstarget, mB.glossform), 
            mB.glosstarget === passage ? (mB.glossform && (metaBook.glossform.id = "METABOOKLIVEGLOSS"), 
            "addgloss" !== mB.mode && setMode("addgloss")) : mB.startAddGloss(passage, evt.shiftKey && "addtag", evt);
        }
    }
    function body_swiped(evt) {
        if (!mB.zoomed) {
            var dx = evt.deltaX, dy = evt.deltaY, vw = fdjtDOM.viewWidth(), adx = 0 > dx ? -dx : dx, ady = 0 > dy ? -dy : dy;
            if (Trace.gestures && fdjtLog("swiped d=%o,%o, ad=%o,%o, s=%o,%o vw=%o, n=%o", dx, dy, adx, ady, evt.startX, evt.startY, vw, evt.ntouches), 
            adx > 1.25 * ady) -(mB.minswipe || 10) > dx ? evt.ntouches > 2 ? window.history.forward() : evt.ntouches > 1 ? mB.skimming ? metaBook.skimForward(evt) : window.history.forward() : mB.mode && !mB.skimming && pagers[metaBook.mode] ? 2 === evt.touches ? showPage.fastForward(pagers[metaBook.mode]) : showPage.forward(pagers[metaBook.mode]) : pageForward(evt, !0) : dx > (mB.minswipe || 10) && (evt.ntouches > 2 ? window.history.back() : evt.ntouches > 1 ? mB.skimming ? metaBook.skimBackward(evt) : window.history.back() : mB.mode && !mB.skimming && pagers[metaBook.mode] ? 2 === evt.touches ? showPage.fastBckward(pagers[metaBook.mode]) : showPage.backward(pagers[metaBook.mode]) : pageBackward(evt, !0)); else if (ady > 2 * adx) if (mB.hudup) -(mB.minswipe || 10) > dy ? setMode("allglosses") : dy > (mB.minswipe || 10) && setMode("search"); else {
                if ((mB.minswipe || 10) >= ady) return;
                vw / 5 > evt.startX && 0 > dy ? setMode("help") : vw / 5 > evt.startX && dy > 0 ? setMode("statictoc") : evt.startX > .8 * vw && dy > 0 ? setMode("search") : evt.startX > .8 * vw && 0 > dy ? setMode("allglosses") : dy > 0 && metaBook.skimming ? mB.stopSkimming() : dy > 0 ? (metaBook.clearStateDialog(), 
                metaBook.showCover()) : setHUD(!0);
            }
        }
    }
    function initGlossMode() {
        var form = getChild("METABOOKLIVEGLOSS", "form");
        if (form) {
            var input = getInput(form, "NOTE");
            input && metaBook.setFocus(input), metaBook.setGlossMode(form.className);
        }
    }
    function getAbout(elt) {
        for (var body = document.body; elt; ) {
            if (elt === body) return !1;
            if (1 !== elt.nodeType) return !1;
            if (elt.name && 0 === elt.name.search("SBR")) return elt;
            if (elt.getAttribute("name") && 0 === elt.getAttribute("name").search("SBR")) return elt;
            elt = elt.parentNode;
        }
        return !1;
    }
    function getTitleSpan(toc, ref) {
        for (var titles = getChildren(toc, ".metabooktitle"), i = 0, lim = titles.length; lim > i; ) {
            var title = titles[i++];
            if (title.name === ref) return title;
        }
        return !1;
    }
    function toc_tapped(evt) {
        evt = evt || window.event;
        var tap_target = fdjtUI.T(evt);
        if (mB.previewing) return mB.stopPreview("toc_tapped"), cancel(evt), void 0;
        var about = getAbout(tap_target);
        if (about) {
            var name = about.name || about.getAttribute("name"), ref = name.slice(3), info = metaBook.docinfo[ref], target = info.elt || mbID(ref);
            target.id !== ref && (target = mbID(ref)), Trace.gestures && fdjtLog("toc_tapped %o about=%o ref=%s target=%o", evt, about, ref, target), 
            metaBook.JumpTo(target), cancel(evt);
        } else Trace.gestures && fdjtLog("toc_tapped %o noabout", evt);
    }
    function toc_held(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), about = getAbout(target);
        if (previewTimeout(!1), slipTimeout(!1), about) {
            var name = about.name || about.getAttribute("name"), ref = name.slice(3), toc = getParent(about, ".metabooktoc"), title = getTitleSpan(toc, name);
            Trace.gestures && fdjtLog("toc_held %o about=%o ref=%s toc=%o title=%s", evt, about, ref, toc, title), 
            addClass(title, "metabookpreviewtitle"), addClass(about.parentNode, "metabookheld");
            var spanbar = getParent(about, ".spanbar") || getChild(toc, ".spanbar");
            return addClass(spanbar, "metabookvisible"), addClass(toc, "metabookheld"), mB.startPreview(mbID(ref), "toc_held"), 
            cancel(evt);
        }
        Trace.gestures && fdjtLog("toc_held %o noabout", evt);
    }
    function toc_released(evt) {
        evt = evt || window.event;
        var about = getAbout(fdjtUI.T(evt));
        if (previewTimeout(!1), about) {
            var name = about.name || about.getAttribute("name"), ref = name.slice(3), toc = getParent(about, ".metabooktoc"), title = getTitleSpan(toc, name);
            Trace.gestures && fdjtLog("toc_released %o ref=%o about=%o toc=%o title=%s", evt, ref, about, toc, title), 
            dropClass(title, "metabookpreviewtitle"), dropClass(about.parentNode, "metabookheld");
            var spanbar = getParent(about, ".spanbar") || getChild(toc, ".spanbar");
            dropClass(spanbar, "metabookvisible"), dropClass(toc, "metabookheld"), mB.previewing && mB.stopPreview("toc_released");
        } else Trace.gestures ? (fdjtLog("toc_released %o noabout", evt), mB.stopPreview("toc_released")) : mB.stopPreview("toc_released");
        cancel(evt);
    }
    function toc_touchtoo(evt) {
        evt = evt || window.event, previewTimeout(!1), mB.previewing && (Trace.gestures ? (fdjtLog("toc_touchtoo %o noabout", evt), 
        mB.stopPreview("toc_touchtoo", !0)) : mB.stopPreview("toc_touchtoo", !0), cancel(evt));
    }
    function toc_slipped(evt) {
        evt = evt || window.event, slip_timer || slipTimeout(function() {
            slip_timer = !1, Trace.gestures && fdjtLog("toc_slipped/timeout %o", evt), mB.stopPreview("toc_slipped");
        });
    }
    function highlightTerm(term, target, info, spellings) {
        var words = [], highlights = [];
        if ("string" == typeof term) words = spellings && spellings[term] || [ term ]; else {
            var knodes = info.knodes;
            knodes ? knodes instanceof Array || (knodes = [ knodes ]) : knodes = [];
            for (var i = 0, lim = knodes.length; lim > i; ) {
                var knode = knodes[i++];
                if (knode === term || RefDB.contains(knode.allways, term)) {
                    var qid = knode._qid, dterm = knode.dterm, spelling = spellings && (spellings[qid] || spellings[dterm]);
                    if (spelling) "string" == typeof spelling ? words.push(spelling) : words = words.concat(spelling); else {
                        var synonyms = knode.EN;
                        synonyms && ("string" == typeof synonyms ? words.push(synonyms) : words = words.concat(synonyms));
                        var hooks = knode.hooks;
                        hooks && ("string" == typeof hooks ? words.push(hooks) : words = words.concat(hooks));
                    }
                }
            }
            0 === words.length && (words = !1);
        }
        if (!words) return [];
        "string" == typeof words && (words = [ words ]);
        for (var j = 0, jlim = words.length; jlim > j; ) {
            var word = words[j++], pattern = wordRegExp(word), dups = metaBook.getDups(target), ranges = fdjtDOM.findMatches(dups, pattern);
            if (ranges && ranges.length || (pattern = wordRegExp(word, !0), ranges = fdjtDOM.findMatches(dups, pattern)), 
            Trace.highlight && fdjtLog("Trying to highlight %s (using %o) in %o, ranges=%o", word, pattern, target, ranges), 
            ranges && ranges.length) for (var k = 0; ranges.length > k; ) {
                var h = fdjtUI.Highlight(ranges[k++], "mbhighlightsearch");
                highlights = highlights.concat(h);
            }
        }
        return highlights;
    }
    function mb_onkeydown(evt) {
        evt = evt || window.event || null;
        var kc = evt.keyCode, target = fdjtUI.T(evt);
        if (27 === evt.keyCode) return mB.previewing && (mB.stopPreview("escape_key"), fdjtUI.TapHold.clear()), 
        dropClass(document.body, "mbZOOM"), dropClass(document.body, "mbMEDIA"), mB.zoomed = !1, 
        "addgloss" === mB.mode && metaBook.cancelGloss(), mB.mode && (metaBook.last_mode = metaBook.mode, 
        setMode(!1), metaBook.setTarget(!1), $ID("METABOOKSEARCHINPUT").blur()), void 0;
        if ("TEXTAREA" !== target.tagName && "INPUT" !== target.tagName && "BUTTON" !== target.tagName && !target.isContentEditable) {
            if (Trace.gestures && fdjtLog("metabook_keydown %o: %o on %o", evt, kc, target), 
            mB.controlc && evt.ctrlKey && (99 === kc || 67 === kc)) mB.previewing && mB.stopPreview("mb_onkeydown", !0), 
            fdjtUI.TapHold.clear(), setMode("console"), cancel(evt); else {
                if (evt.altKey || evt.ctrlKey || evt.metaKey) return !0;
                if (mB.previewing) return mB.stopPreview("mb_onkeydown", !0), fdjtUI.TapHold.clear(), 
                setHUD(!1), cancel(evt), !1;
                if (hasClass(document.body, "mbCOVER")) return metaBook.clearStateDialog(), metaBook.hideCover(), 
                cancel(evt), !1;
                if (hasClass(document.body, "mbZOOM")) return 34 === kc ? fdjtDOM.pageScroll($ID("METABOOKZOOM"), 1) : 33 === kc && fdjtDOM.pageScroll($ID("METABOOKZOOM"), -1), 
                !1;
                if (mB.glossform) {
                    var input = fdjt.DOM.getInput(mB.glossform, "NOTE");
                    metaBook.UI.glossFormFocus(mB.glossform), metaBook.setFocus(input), input.focus();
                    var new_evt = document.createEvent("UIEvent");
                    return new_evt.initUIEvent("keydown", !0, !0, window), new_evt.keyCode = kc, input.dispatchEvent(new_evt), 
                    cancel(evt), void 0;
                }
                if (34 === kc) pageForward(evt); else if (33 === kc) pageBackward(evt); else if (40 === kc) setHUD(!1), 
                pageForward(evt); else if (38 === kc) setHUD(!1), pageBackward(evt); else if (37 === kc) mB.mode && !mB.skimming && pagers[metaBook.mode] ? showPage.fastBackward(pagers[metaBook.mode]) : metaBook.skimBackward(evt); else if (39 === kc) mB.mode && !mB.skimming && pagers[metaBook.mode] ? showPage.fastForward(pagers[metaBook.mode]) : metaBook.skimForward(evt); else {
                    if (fdjtDOM.isTextInput(fdjtDOM.T(evt))) return !0;
                    if (32 === kc) mB.mode && !mB.skimming && pagers[metaBook.mode] ? evt.shiftKey ? showPage.fastForward(pagers[metaBook.mode]) : showPage.forward(pagers[metaBook.mode]) : pageForward(evt, !0); else if (8 === kc || 45 === kc) mB.mode && !mB.skimming && pagers[metaBook.mode] ? evt.shiftKey ? showPage.fastBackward(pagers[metaBook.mode]) : showPage.backward(pagers[metaBook.mode]) : pageBackward(evt, !0); else if (36 === kc) metaBook.JumpTo(mB.head); else {
                        if ("addgloss" !== mB.mode) return;
                        var mode = metaBook.getGlossMode();
                        if (mode) return;
                        var formdiv = $ID("METABOOKLIVEGLOSS"), form = formdiv && getChild(formdiv, "FORM");
                        if (!form) return;
                        13 === kc ? submitEvent(form) : 35 === kc || 91 === kc ? metaBook.setGlossMode("addtag", form) : 32 === kc ? metaBook.setGlossMode("editnote", form) : 47 === kc || 58 === kc ? metaBook.setGlossMode("attach", form) : 64 === kc && metaBook.setGlossMode("addoutlet", form);
                    }
                }
            }
            cancel(evt);
        }
    }
    function mb_onkeyup(evt) {
        return evt = evt || window.event || null, fdjtDOM.isTextInput(fdjtDOM.T(evt)) ? !0 : evt.ctrlKey || evt.altKey || evt.metaKey ? !0 : void 0;
    }
    function mb_onkeypress(evt) {
        var modearg = !1;
        evt = evt || window.event || null;
        var ch = evt.charCode || evt.keyCode, target = fdjtDOM.T(evt);
        if (fdjtDOM.isTextInput(target)) return !0;
        if (evt.altKey || evt.ctrlKey || evt.metaKey) return !0;
        if (Trace.gestures && fdjtLog("metabook_onkeypress %o: %o on %o", evt, ch, target), 
        72 === ch || 104 === ch) return metaBook.clearStateDialog(), metaBook.hideCover(), 
        fdjtDOM.toggleClass(document.body, "metabookhelp"), !1;
        if (67 === ch || 99 === ch) return metaBook.clearStateDialog(), metaBook.toggleCover(), 
        !1;
        if (hasClass(document.body, "mbZOOM")) {
            if (43 === ch) return mB.zoom(1.1);
            if (45 === ch) return mB.zoom(.9);
            modearg = modechars[ch];
        } else modearg = modechars[ch];
        "openheart" === modearg && (modearg = metaBook.last_heartmode || "about");
        var mode = setMode();
        modearg && (mode === modearg ? (setMode(!1), mode = !1) : (setMode(modearg), mode = modearg)), 
        "searching" === mode ? metaBook.setFocus($ID("METABOOKSEARCHINPUT")) : metaBook.clearFocus($ID("METABOOKSEARCHINPUT")), 
        fdjtDOM.cancel(evt);
    }
    function goto_keypress(evt) {
        evt = evt || window.event || null;
        var target = fdjtUI.T(evt), ch = evt.charCode || evt.keyCode, max = !1, min = !1, handled = !1;
        if ("GOTOLOC" === target.name ? (min = 0, max = Math.floor(mB.ends_at / 128)) : "GOTOPAGE" === target.name ? (min = 1, 
        max = metaBook.pagecount) : 13 === ch && cancel(evt), 13 === ch) {
            if ("GOTOPAGE" === target.name) {
                var num = parseInt(target.value, 10);
                "number" == typeof num ? (handled = !0, metaBook.GoToPage(num)) : isEmptyString(target.value) && (handled = !0);
            } else if ("GOTOREF" === target.name) {
                var pagemap = metaBook.layout.pagemap, page = pagemap[target.value];
                page ? (metaBook.GoToPage(page), handled = !0) : isEmptyString(target.value) && (handled = !0);
            } else if ("GOTOLOC" === target.name) {
                var locstring = target.value, loc = parseFloat(locstring);
                "number" == typeof loc && loc >= 0 && 100 >= loc ? (loc = Math.floor(loc / 100 * metaBook.ends_at) + 1, 
                metaBook.JumpTo(loc), handled = !0) : isEmptyString(target.value) && (handled = !0);
            }
            handled && (target.value = "", setMode(!1));
        }
    }
    function hudmodebutton(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), mode = target.getAttribute("hudmode");
        if (Trace.gestures && fdjtLog("hudmodebutton() %o mode=%o cl=%o skim=%o sbh=%o mode=%o", evt, mode, isClickable(target), metaBook.skimpoint, mB.hudup, mB.setMode()), 
        metaBook.clearStateDialog(), reticle.live && reticle.flash(), cancel(evt), mode) {
            var mode_live = hasClass(mB.HUD, mode) || "search" === mode && hasClass(mB.HUD, mB.searchModes);
            if ("click" === evt.type || "tap" === evt.type || "release" === evt.type) {
                if (dropClass(document.body, "_HOLDING"), mB.skimpoint && !mB.hudup) {
                    if (mB.skimming && mB.stopSkimming(), "refinesearch" === mode || "searchresults" === mode) return setMode("searchresults"), 
                    void 0;
                    if ("allglosses" === mode) return setMode("allglosses"), void 0;
                    if ("statictoc" === mode) return setMode("statictoc"), void 0;
                }
                mode_live ? hasClass(document.body, "mbSKIMMING") ? mB.stopSkimming() : setMode(!1, !0) : (hasClass(document.body, "mbSKIMMING") && mB.stopSkimming(), 
                setMode(mode));
            } else "hold" === evt.type ? addClass(document.body, "_HOLDING") : dropClass(document.body, "_HOLDING");
        }
    }
    function glossmark_tapped(evt) {
        if (evt = evt || window.event || null, held && clear_hold("glossmark_tapped"), !(evt.ctrlKey || evt.altKey || evt.metaKey || evt.shiftKey)) {
            var target = fdjtUI.T(evt), glossmark = getParent(target, ".glossmark"), passage = glossmark.name && 0 === glossmark.name.search("GLOSSMARK_NAME_") && $ID(glossmark.name.slice(15)) || getTarget(glossmark.parentNode, !0);
            return passage && passage.getAttribute("data-baseid") && (passage = mbID(passage.getAttribute("data-baseid"))), 
            Trace.gestures && fdjtLog("glossmark_tapped (%o) on %o gmark=%o passage=%o mode=%o target=%o", evt, target, glossmark, passage, mB.mode, mB.target), 
            glossmark ? (cancel(evt), "openglossmark" === mB.mode && mB.target === passage ? (setMode(!1), 
            metaBook.clearGlossmark(), void 0) : (mB.select_target || metaBook.showGlossmark(passage, glossmark), 
            void 0)) : !1;
        }
    }
    function animate_glossmark(target, enable) {
        if (target && enable) {
            var glossmark = hasClass(target, "glossmark") ? target : getParent(target, ".glossmark");
            if (!glossmark) return;
            if (animated_glossmark === glossmark) return;
            glossmark_animated && (clearInterval(glossmark_animated), animated_glossmark = !1, 
            glossmark_animated = !1, glossmark_image && fdjtUI.ImageSwap.reset(glossmark_image));
            var wedge = getChild(glossmark, "img.wedge");
            if (!wedge) return;
            animated_glossmark = glossmark, glossmark_image = wedge, glossmark_animated = fdjtUI.ImageSwap(wedge, 750);
        } else glossmark_animated && (clearInterval(glossmark_animated), animated_glossmark = !1, 
        glossmark_animated = !1, glossmark_image && fdjtUI.ImageSwap.reset(glossmark_image), 
        glossmark_image = !1);
    }
    function glossmark_hoverstart(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), passage = getTarget(target);
        fdjtDOM.hasClass(passage, "mbtarget") || animate_glossmark(target, !0);
    }
    function glossmark_hoverdone(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), passage = getTarget(target);
        fdjtDOM.hasClass(passage, "mbtarget") || animate_glossmark(target, !1);
    }
    function setTargetUI(target) {
        if (target) {
            var glossmark = getChild(target, ".glossmark");
            glossmark ? animate_glossmark(glossmark, !0) : animate_glossmark(!1, !1);
        } else animate_glossmark(!1, !1);
    }
    function forceSyncAction(evt) {
        return evt = evt || window.event, cancel(evt), metaBook.forceSync(), navigator.onLine ? mB.connected ? fdjtUI.alertFor(7, "Sychronizing glosses, etc with the remote server") : fdjtUI.alertFor(15, "You're not currently logged into sBooks.  Information will be synchronized when you've logged in.") : fdjtUI.alertFor(15, "You're currently offline; information will be synchronized when you're back online"), 
        !1;
    }
    function forward(evt) {
        evt || (evt = window.event || !1), evt && cancel(evt), Trace.nav && fdjtLog("Forward e=%o h=%o t=%o", evt, metaBook.head, mB.target), 
        mB.skimming ? skimForward(evt) : mB.mode && pagers[metaBook.mode] ? showPage.forward(pagers[metaBook.mode]) : evt && evt.shiftKey ? skimForward(evt) : pageForward(evt);
    }
    function backward(evt) {
        evt || (evt = window.event || !1), evt && cancel(evt), Trace.nav && fdjtLog("Backward e=%o h=%o t=%o", evt, metaBook.head, mB.target), 
        mB.skimming ? skimBackward(evt) : mB.mode && pagers[metaBook.mode] ? showPage.backward(pagers[metaBook.mode]) : evt && evt.shiftKey ? skimBackward() : pageBackward();
    }
    function preview_touchmove_nodefault(evt) {
        mB.previewing && fdjtUI.noDefault(evt);
    }
    function pageForward(evt, clearmodes) {
        evt = evt || window.event, dropClass(document.body, /\bmb(PAGE)?PREVIEW/g);
        var now = fdjtTime();
        if (!(last_motion && 100 > now - last_motion)) if (last_motion = now, dropClass(document.body, /\bmb(PAGE)?PREVIEW/g), 
        clearmodes && (mB.hudup || mB.mode) && fdjt.Async(function() {
            mB.setHUD(!1);
        }), mB.readsound && fdjtDOM.playAudio("METABOOKPAGEORWARDAUDIO"), (Trace.gestures || Trace.flips) && fdjtLog("pageForward (on %o) c=%o n=%o", evt, mB.curpage, mB.pagecount), 
        mB.bypage && "number" == typeof metaBook.curpage) {
            var pagemax = mB.bypage && (mB.pagecount || mB.layout.pagenum - 1), newpage = !1;
            mB.curpage >= pagemax || metaBook.GoToPage(newpage = metaBook.curpage + 1, "pageForward", !0, !0);
        } else {
            var delta = fdjtDOM.viewHeight() - 50;
            0 > delta && (delta = fdjtDOM.viewHeight());
            var newy = fdjtDOM.viewTop() + delta;
            window.scrollTo(fdjtDOM.viewLeft(), newy);
        }
    }
    function pageBackward(evt, clearmodes) {
        var now = fdjtTime();
        if (dropClass(document.body, /\bmb(PAGE)?PREVIEW/g), !(last_motion && 100 > now - last_motion)) if (last_motion = now, 
        evt = evt || window.event, clearmodes && fdjt.Async(function() {
            mB.setHUD(!1);
        }), mB.readsound && fdjtDOM.playAudio("METABOOKPAGEBACKWARDAUDIO"), (Trace.gestures || Trace.flips) && fdjtLog("pageBackward (on %o) c=%o n=%o", evt, mB.curpage, mB.pagecount), 
        mB.bypage && "number" == typeof metaBook.curpage) {
            var newpage = !1;
            0 === mB.curpage || (newpage = metaBook.curpage - 1, metaBook.GoToPage(newpage, "pageBackward", !0, !0));
        } else {
            var delta = fdjtDOM.viewHeight() - 50;
            0 > delta && (delta = fdjtDOM.viewHeight());
            var newy = fdjtDOM.viewTop() - delta;
            window.scrollTo(fdjtDOM.viewLeft(), newy);
        }
    }
    function skimForward(evt) {
        var now = fdjtTime(), slice = metaBook.slices[metaBook.mode];
        if ((Trace.gestures || Trace.nav) && fdjtLog("skimForward %o: mode=%s", evt, mB.mode), 
        dropClass(document.body, /\bmb(PAGE)?PREVIEW/g), !(last_motion && 100 > now - last_motion) && (last_motion = now, 
        mB.uisound && fdjtDOM.playAudio("METABOOKSKIMFORWARDAUDIO"), slice)) {
            mB.uisound && fdjtDOM.playAudio("METABOOKSKIMFORWARDAUDIO"), addClass("METABOOKSKIMMER", "flash"), 
            addClass("METABOOKNEXTSKIM", "flash"), setTimeout(function() {
                dropClass("METABOOKSKIMMER", "flash"), dropClass("METABOOKNEXTSKIM", "flash");
            }, 200);
            var next = slice.forward();
            return next && metaBook.SkimTo(next, 1), next;
        }
    }
    function skimBackward(evt) {
        var now = fdjtTime(), slice = metaBook.slices[metaBook.mode];
        if ((Trace.gestures || Trace.nav) && fdjtLog("skimBackward %o: mode=%s", evt, mB.mode), 
        dropClass(document.body, /\bmb(PAGE)?PREVIEW/g), !(last_motion && 100 > now - last_motion) && (last_motion = now, 
        mB.uisound && fdjtDOM.playAudio("METABOOKSKIMBACKWARDAUDIO"), slice)) {
            addClass("METABOOKPREVSKIM", "flash"), addClass("METABOOKSKIMMER", "flash"), setTimeout(function() {
                dropClass("METABOOKSKIMMER", "flash"), dropClass("METABOOKPREVSKIM", "flash");
            }, 200);
            var next = slice.backward();
            return next && metaBook.SkimTo(next, -1), next;
        }
    }
    function skimmer_tapped(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if (!isClickable(target)) if (getParent(target, ".tool")) {
            var card = getCard(target);
            if (card && (card.name || card.getAttribute("name"))) {
                var name = card.name || card.getAttribute("name"), gloss = RefDB.resolve(name, mB.glossdb);
                if (!gloss) return;
                var form = metaBook.setGlossTarget(gloss);
                if (!form) return;
                return mB.stopSkimming(), setMode("addgloss"), void 0;
            }
        } else {
            if (getParent(target, ".mbmedia")) {
                var link = getParent(target, ".mbmedia"), src = link.getAttribute("data-src"), cancelling = !1, type = link.getAttribute("data-type");
                if (hasClass(link, "imagelink") ? (metaBook.showMedia(src, type), cancelling = !0) : (hasClass(link, "audiolink") || hasClass(link, "musiclink")) && (metaBook.showMedia(src, type), 
                cancelling = !0), cancelling) return cancel(evt), void 0;
            }
            if (getParent(target, "mbcard_tochead")) {
                var anchor = getParent(target, ".tocref"), href = anchor && anchor.getAttribute("data-tocref");
                return href ? metaBook.GoTOC(href) : toggleClass("METABOOKSKIMMER", "expanded"), 
                void 0;
            }
            mB.hudup ? mB.stopSkimming() : setHUD(!0, !1), cancel(evt);
        }
    }
    function skimmer_swiped(evt) {
        var dx = evt.deltaX, dy = evt.deltaY, vw = fdjtDOM.viewWidth(), adx = 0 > dx ? -dx : dx, ady = 0 > dy ? -dy : dy;
        if (Trace.gestures && fdjtLog("skimmer_swiped d=%o,%o, ad=%o,%o, s=%o,%o vw=%o, n=%o", dx, dy, adx, ady, evt.startX, evt.startY, vw, evt.ntouches), 
        adx > 2 * ady) -(mB.minswipe || 10) > dx ? metaBook.skimForward(evt) : dx > (mB.minswipe || 10) && metaBook.skimBackward(evt); else if (ady > 2 * adx) {
            if ((mB.minswipe || 10) >= ady) return;
            0 > dy ? mB.setHUD(!1) : mB.stopSkimming();
        }
        cancel(evt);
    }
    function enterPageNum(evt) {
        return evt = evt || window.event, mB.hudup || mB.mode || mB.cxthelp ? (cancel(evt), 
        setMode(!1), void 0) : (cancel(evt), mB.hudup ? (setMode(!1), void 0) : (setMode("gotopage", !0), 
        void 0));
    }
    function enterPageRef(evt) {
        return evt = evt || window.event, mB.hudup || mB.mode || mB.cxthelp ? (cancel(evt), 
        setMode(!1), void 0) : (cancel(evt), mB.hudup ? (setMode(!1), void 0) : (setMode("gotoref", !0), 
        void 0));
    }
    function enterLocation(evt) {
        return evt = evt || window.event, mB.hudup || mB.mode || mB.cxthelp ? (cancel(evt), 
        setMode(!1), void 0) : (cancel(evt), mB.hudup ? (setMode(!1), void 0) : (setMode("gotoloc", !0), 
        void 0));
    }
    function enterPercentage(evt) {
        return evt = evt || window.event, mB.hudup || mB.mode || mB.cxthelp ? (cancel(evt), 
        setMode(!1), void 0) : (cancel(evt), mB.hudup ? (setMode(!1), void 0) : (setMode("gotoloc", !0), 
        void 0));
    }
    function flyleaf_tap(evt) {
        isClickable(evt) || setMode(!1);
    }
    function head_tap(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        return Trace.gestures && fdjtLog("head_tap %o t=%o", evt, target), mB.previewing ? (mB.stopPreview("head_tap"), 
        cancel(evt), void 0) : fdjtUI.isClickable(target) ? default_tap(evt) : ((target === metaBook.DOM.head || target === metaBook.DOM.tabs) && (mB.mode ? (cancel(evt), 
        setMode(!1)) : fdjtDOM.hasClass(document.body, "mbSHOWHELP") ? (cancel(evt), dropClass(document.body, "mbSHOWHELP")) : mB.hudup ? (cancel(evt), 
        setMode(!1)) : (cancel(evt), setMode(!0))), void 0);
    }
    function foot_tap(evt) {
        return Trace.gestures && fdjtLog("foot_tap %o", evt), mB.previewing ? (mB.stopPreview("foot_tap"), 
        cancel(evt), void 0) : isClickable(evt) || hasParent(fdjtUI.T(evt), "hudbutton") ? void 0 : mB.hudup || mB.mode || mB.cxthelp ? (cancel(evt), 
        setMode(!1), void 0) : void 0;
    }
    function back_to_reading(evt) {
        evt = evt || window.event, cancel(evt), "addgloss" === mB.mode && metaBook.cancelGloss(), 
        setMode(!1), dropClass(document.body, "mbSHOWHELP");
    }
    function clearMode(evt) {
        evt = evt || window.event, setMode(!1);
    }
    function setFocus(target) {
        if (!target) {
            var cur = metaBook.textinput;
            return metaBook.textinput = !1, metaBook.freezelayout = !1, cur && cur.blur(), void 0;
        }
        mB.textinput !== target && (metaBook.textinput = target, metaBook.freezelayout = !0, 
        target.focus());
    }
    function clearFocus(target) {
        target || (target = metaBook.textinput), target && mB.textinput === target && (metaBook.textinput = !1, 
        metaBook.freezelayout = !1, target.blur());
    }
    function mb_onfocus(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), input = getParent(target, "textarea");
        input || (input = getParent(target, "input")), input && "string" == typeof input.type && 0 === input.type.search(fdjtDOM.text_types) && setFocus(input);
    }
    function mb_onblur(evt) {
        evt = evt || window.event;
        var target = evt.nodeType ? evt : fdjtUI.T(evt), input = getParent(target, "textarea");
        metaBook.previewing && target === window && mB.stopPreview(), input || (input = getParent(target, "input")), 
        input && "string" == typeof input.type && 0 === input.type.search(fdjtDOM.text_types) && clearFocus(input);
    }
    function metabookmouseout(evt) {
        var target = fdjtUI.T(evt);
        (target === window || target === document.documentElement) && metaBook.previewing && mB.stopPreview();
    }
    function metabookvischange(evt) {
        evt = evt || window.event, document[fdjtDOM.isHidden] && metaBook.previewing && mB.stopPreview();
    }
    function setHelp(flag) {
        return flag ? (addClass(document.body, "mbSHOWHELP"), metaBook.cxthelp = !0) : (dropClass(document.body, "mbSHOWHELP"), 
        metaBook.cxthelp = !1), !1;
    }
    function toggleHelp(evt) {
        return evt = evt || window.event, Trace.gestures && fdjtLog("toggleHelp %o", evt), 
        cancel(evt), mB.cxthelp ? (dropClass(document.body, "mbSHOWHELP"), metaBook.cxthelp = !1) : (addClass(document.body, "mbSHOWHELP"), 
        metaBook.cxthelp = !0), !1;
    }
    function default_tap(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if ("TEXTAREA" === target.tagName || "INPUT" === target.tagName && target.type.search(fdjtDOM.text_input_types) >= 0) target.focus(), 
        noBubble(evt); else if ("A" === target.tagName && target.href) {
            var href = target.href;
            if ("#" === href[0]) {
                var elt, id = href.slice(1), xt = mB.xtargets[id];
                xt ? (cancel(evt), xt()) : (elt = mB.ID(id)) && (cancel(evt), fdjtAsync(function() {
                    mB.GoTo(elt);
                }));
            } else if (mB.xrules && mB.xrules.length > 0) for (var xrules = mB.xrules, r = 0, nrules = xrules.length; nrules > r; ) {
                var rule = xrules[r++];
                if (href.search(rule.pattern) >= 0 && rule.handler(href, target)) break;
            }
        }
    }
    function dombody_touched(evt) {
        if (!mB.hudup && !mB.closed) {
            var touches = evt.touches && evt.touches.length && evt.touches || evt.changedTouches && evt.changedTouches.length && evt.changedTouches, x = evt.clientX || touches && touches[0].clientX, y = evt.clientY || touches && touches[0].clientY, elt = (x || y) && document.elementFromPoint(x, y);
            if (mB.Trace.gestures > 1 && fdjtLog("dombody_touched %o: %o @ <%o,%o>", evt, elt, x, y), 
            !(elt !== document.body && hasParent(elt, document.body) || elt.offsetHeight && (50 > y || 50 > elt.offsetHeight - y))) return mB.Trace.gestures && fdjtLog("dombody_touched(atedge) %o: %o @ <%o,%o>", evt, elt, x, y), 
            25 > x ? backward(evt) : 25 > elt.offsetWidth - x ? forward(evt) : void 0;
        }
    }
    function showcover_tapped(evt) {
        if (evt = evt || window.event, !mB.touch || mB.hudup) {
            if (!(evt.shiftKey || evt.touches && evt.touches.length >= 2)) {
                var opened = metaBook.readLocal("mB(" + mB.docid + ").opened", !0);
                opened && opened - fdjtTime() > 6e5 && ($ID("METABOOKCOVER").className = $ID("METABOOKCOVERHOLDER") ? "bookcover" : "titlepage");
            }
            metaBook.clearStateDialog(), metaBook.showCover(), cancel(evt);
        }
    }
    function showcover_released(evt) {
        evt = evt || window.event, evt.shiftKey || evt.touches && evt.touches.length >= 2 || ($ID("METABOOKCOVER").className = "bookcover"), 
        metaBook.clearStateDialog(), metaBook.showCover(), cancel(evt);
    }
    function global_mouseup(evt) {
        return evt = evt || window.event, mB.zoomed ? void 0 : mB.page_turner ? (clearInterval(mB.page_turner), 
        metaBook.page_turner = !1, void 0) : (mB.select_target && (mB.startAddGloss(metaBook.select_target, evt.shiftKey && "addtag", evt), 
        metaBook.select_target = !1), void 0);
    }
    function raiseHUD(evt) {
        return evt = evt || window.event, Trace.gestures && fdjtLog("raiseHUD %o", evt), 
        setHUD(!0), cancel(evt), !1;
    }
    function lowerHUD(evt) {
        return evt = evt || window.event, Trace.gestures && fdjtLog("lowerHUD %o", evt), 
        setHUD(!1), cancel(evt), !1;
    }
    function saveGloss(evt) {
        evt = evt || window.event, Trace.gestures && fdjtLog("saveGloss %o", evt), metaBook.submitGloss();
    }
    function refreshLayout(evt) {
        evt = evt || window.event, cancel(evt), Trace.gestures && fdjtLog("refreshLayout %o", evt), 
        metaBook.refreshLayout();
    }
    function resetState(evt) {
        evt = evt || window.event, cancel(evt), fdjtUI.choose({
            choices: [ {
                label: "OK",
                isdefault: !0,
                handler: function() {
                    metaBook.resetState();
                }
            }, {
                label: "Cancel"
            } ],
            spec: "div.fdjtdialog.mbsettings"
        }, "Mark current location as ", fdjtDOM("em", "latest"), " and ", fdjtDOM("em", "farthest"), "?", mB.locsync && "for all syncing devices");
    }
    function refreshOffline(evt) {
        evt = evt || window.event, cancel(evt), fdjtUI.choose({
            choices: [ {
                label: "OK",
                isdefault: !0,
                handler: function() {
                    metaBook.refreshOffline();
                }
            }, {
                label: "Cancel"
            } ],
            spec: "div.fdjtdialog.mbsettings"
        }, "Reload all glosses and layers?");
    }
    function clearOffline(evt) {
        evt = evt || window.event, cancel(evt), Trace.gestures && fdjtLog("clearOffline %o", evt), 
        metaBook.clearOffline(), fdjt.ID("METABOOKSETTINGSMESSAGE").innerHTML = "<strong>Poof!</strong> Local copies of your personalizations (glosses, settings, etc) for this book have been erased.";
    }
    function consolefn(evt) {
        evt = evt || window.event, metaBook.consolefn(evt);
    }
    function toggleDevMode(evt) {
        if (fdjtLog("toggleDevMode %o", evt), devmode_click) {
            var root = document.documentElement || document.body, now = fdjtTime();
            1e3 > now - devmode_click ? (mB.devmode ? (metaBook.devmode = !1, fdjtState.dropLocal("mB.devmode"), 
            dropClass(root, "_DEVMODE")) : (metaBook.devmode = !0, fdjtState.setLocal("mB.devmode", !0), 
            addClass(root, "_DEVMODE")), devmode_click = !1) : devmode_click = now;
        } else devmode_click = fdjtTime();
        cancel(evt);
    }
    function cancelNotAnchor(evt) {
        var target = fdjt.UI.T(evt);
        return hasParent(target, "A[href]") ? (clicked && 2e3 > fdjtTime() - clicked && cancel(evt), 
        void 0) : (cancel(evt), void 0);
    }
    var mB = metaBook, Trace = mB.Trace, fdjtString = fdjt.String, showPage = fdjt.showPage, fdjtState = fdjt.State, fdjtTime = fdjt.Time, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtAsync = fdjt.Async, RefDB = fdjt.RefDB, $ID = fdjt.ID, mbID = metaBook.ID, addClass = fdjtDOM.addClass, hasClass = fdjtDOM.hasClass, dropClass = fdjtDOM.dropClass, toggleClass = fdjtDOM.toggleClass, getTarget = metaBook.getTarget, getParent = fdjtDOM.getParent, hasParent = fdjtDOM.hasParent, isClickable = fdjtUI.isClickable, getChild = fdjtDOM.getChild, getChildren = fdjtDOM.getChildren, getInput = fdjtDOM.getInput, Selector = fdjtDOM.Selector, isEmptyString = fdjtString.isEmpty, decodeEntities = fdjtString.decodeEntities, fillIn = fdjtString.fillIn, getCard = metaBook.UI.getCard, pagers = metaBook.pagers, mbDOM = metaBook.DOM, submitEvent = fdjtUI.submitEvent, noDefault = fdjt.UI.noDefault, cancel = fdjt.UI.cancel, noBubble = fdjt.UI.noBubble, reticle = fdjtUI.Reticle, setMode = metaBook.setMode, setHUD = metaBook.setHUD, preview_timer = !1;
    metaBook.previewTimeout = previewTimeout;
    var slip_timer = !1;
    metaBook.slipTimeout = slipTimeout, metaBook.uiclasses = /\b(metabookui|glossmark)\b/gi, 
    metaBook.addConfig("controlc", function(key, val) {
        metaBook.controlc = val;
    }), metaBook.UI.addHandlers = addHandlers, metaBook.setupGestures = setupGestures;
    var held = !1, gesture_start = !1, clicked = !1, MetaBookSlice = metaBook.Slice, note_classes = /\b(((sbook)|(book)|(mbook)|(metabook)|(foot)|(end)|())note)\b/, noteref_classes = /\b((((sbook)|(book)|(meta))book)|(foot)|(end)|())(note|noteref)\b/, aside_rels = /\b((sidebar)|(breakout)|(tangent))\b/, iframe_rels = /\b((iframe)|(popin))\b/, iframe_classes = /\b(()|(s)|(m)|(meta))book((iframe)|(popin))\b/;
    metaBook.closePassageMenu = closePassageMenu;
    var body_tapstart = !1;
    metaBook.initGlossMode = initGlossMode;
    var wordRegExp = fdjtDOM.wordRegExp;
    metaBook.highlightTerm = highlightTerm, metaBook.UI.handlers.onkeyup = mb_onkeyup;
    var modechars = {
        63: "searching",
        102: "searching",
        65: "openheart",
        97: "openheart",
        83: "searching",
        115: "searching",
        80: "gotopage",
        112: "gotopage",
        76: "gotoloc",
        108: "gotoloc",
        70: "searching",
        100: "device",
        68: "device",
        116: "statictoc",
        84: "statictoc",
        72: "help",
        103: "allglosses",
        71: "allglosses",
        67: "console",
        99: "console"
    };
    metaBook.UI.handlers.onkeypress = mb_onkeypress, metaBook.UI.goto_keypress = goto_keypress, 
    metaBook.UI.hudmodebutton = hudmodebutton, metaBook.UI.dropHUD = function(evt) {
        var target = fdjtUI.T(evt);
        return isClickable(target) ? (Trace.gestures && fdjtLog("Clickable: don't dropHUD %o", evt), 
        void 0) : (Trace.gestures && fdjtLog("dropHUD %o", evt), cancel(evt), setMode(!1), 
        void 0);
    };
    var animated_glossmark = !1, glossmark_animated = !1, glossmark_image = !1;
    metaBook.UI.setTarget = setTargetUI, metaBook.UI.forceSyncAction = forceSyncAction;
    var last_motion = !1;
    metaBook.Forward = forward, metaBook.Backward = backward, metaBook.pageForward = pageForward, 
    metaBook.pageBackward = pageBackward, metaBook.skimForward = skimForward, metaBook.skimBackward = skimBackward, 
    metaBook.setFocus = setFocus, metaBook.clearFocus = clearFocus, metaBook.UI.focus = mb_onfocus, 
    metaBook.UI.blur = mb_onblur, metaBook.setHelp = setHelp, metaBook.toggleHelp = toggleHelp, 
    metaBook.dombody_touched = dombody_touched, metaBook.raiseHUD = raiseHUD, metaBook.lowerHUD = lowerHUD;
    var devmode_click = !1;
    fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, {
        window: {
            keyup: mb_onkeyup,
            keydown: mb_onkeydown,
            keypress: mb_onkeypress,
            focus: mb_onfocus,
            mouseout: metabookmouseout,
            blur: mb_onblur
        },
        "#METABOOKBODY": {
            mouseup: global_mouseup
        },
        content: {
            tap: body_tapped,
            taptap: body_taptap,
            hold: body_held,
            release: body_released,
            mousedown: body_touchstart,
            mouseup: body_touchend,
            click: cancelNotAnchor
        },
        toc: {
            tap: toc_tapped,
            hold: toc_held,
            release: toc_released,
            slip: toc_slipped,
            mouseover: fdjtUI.CoHi.onmouseover,
            mouseout: fdjtUI.CoHi.onmouseout,
            click: cancel
        },
        ".mbtocslice": {
            mouseover: fdjtUI.CoHi.onmouseover,
            mouseout: fdjtUI.CoHi.onmouseout
        },
        glossmark: {
            mouseup: glossmark_tapped,
            click: cancel,
            mousedown: cancel,
            mouseover: glossmark_hoverstart,
            mouseout: glossmark_hoverdone
        },
        hud: {
            click: default_tap,
            tap: default_tap
        },
        "#METABOOKSTARTPAGE": {
            click: metaBook.UI.dropHUD
        },
        "#METABOOKMENU": {
            tap: raiseHUD
        },
        "#METABOOKSHOWCOVER": {
            tap: showcover_tapped,
            release: showcover_released
        },
        "#METABOOKHUDHELP": {
            click: metaBook.UI.dropHUD
        },
        ".hudtip": {
            click: metaBook.UI.dropHUD
        },
        ".metabookheart": {
            tap: flyleaf_tap
        },
        "#METABOOKPAGEREFTEXT": {
            tap: enterPageRef
        },
        "#METABOOKPAGENOTEXT": {
            tap: enterPageNum
        },
        "#METABOOKLOCPCT": {
            tap: enterPercentage
        },
        "#METABOOKLOCOFF": {
            tap: enterLocation
        },
        "#METABOOKSKIMMER": {
            tap: skimmer_tapped,
            swipe: skimmer_swiped
        },
        "#METABOOKPAGEHEAD": {
            click: head_tap
        },
        "#METABOOKTABS": {
            click: head_tap
        },
        "#METABOOKHEAD": {
            click: head_tap
        },
        "#METABOOKFOOT": {
            tap: foot_tap
        },
        ".searchcloud": {
            tap: metaBook.UI.handlers.searchcloud_select,
            release: metaBook.UI.handlers.searchcloud_select
        },
        "#METABOOKHELPBUTTON": {
            tap: toggleHelp,
            hold: function(evt) {
                setHelp(!0), cancel(evt);
            },
            release: function(evt) {
                setHelp(!1), cancel(evt);
            },
            slip: function(evt) {
                setHelp(!1), cancel(evt);
            }
        },
        "#METABOOKHELP": {
            click: toggleHelp,
            mousedown: cancel,
            mouseup: cancel
        },
        "#MBPAGERIGHT": {
            click: function(evt) {
                hasClass(document.body, "mbSKIMMING") ? skimForward(evt) : pageForward(evt), cancel(evt);
            }
        },
        "#MBPAGELEFT": {
            click: function(evt) {
                hasClass(document.body, "mbSKIMMING") ? skimBackward(evt) : pageBackward(evt), cancel(evt);
            }
        },
        "#METABOOKSHOWTEXT": {
            click: back_to_reading
        },
        "#METABOOKGLOSSDETAIL": {
            click: metaBook.UI.dropHUD
        },
        "#METABOOKNOTETEXT": {
            click: jumpToNote
        },
        ".hudmodebutton": {
            tap: hudmodebutton,
            hold: hudmodebutton,
            slip: hudmodebutton,
            release: hudmodebutton
        },
        ".hudbutton[alt='save gloss']": {
            tap: saveGloss,
            hold: saveGloss
        },
        ".metabookclosehud": {
            click: back_to_reading
        },
        "#METABOOKSETTINGS": {
            click: fdjt.UI.CheckSpan.onclick
        },
        ".metabooktogglehelp": {
            click: toggleHelp
        },
        "#METABOOKCONSOLETEXTINPUT": {
            focus: function() {
                fdjt.DOM.addClass("METABOOKCONSOLEINPUT", "uptop");
            },
            blur: function() {
                fdjt.DOM.dropClass("METABOOKCONSOLEINPUT", "uptop");
            }
        },
        "#METABOOKCONSOLEBUTTON": {
            click: consolefn
        },
        "#METABOOKREFRESHOFFLINE": {
            click: refreshOffline
        },
        "#METABOOKREFRESHLAYOUT": {
            click: refreshLayout
        },
        "#METABOOKRESETSYNC": {
            click: resetState
        },
        ".clearoffline": {
            click: clearOffline
        },
        ".metabookclearmode": {
            click: clearMode
        },
        "#METABOOKGOTOREFHELP": {
            click: clearMode
        },
        "#METABOOKGOTOPAGEHELP": {
            click: clearMode
        },
        "#METABOOKGOTOLOCHELP": {
            click: clearMode
        },
        ".metabookshowsearch": {
            click: function(evt) {
                metaBook.showSearchResults(), cancel(evt);
            }
        },
        ".metabookrefinesearch": {
            click: function(evt) {
                setMode("refinesearch"), cancel(evt);
            }
        },
        ".metabookexpandsearch": {
            click: function(evt) {
                setMode("expandsearch"), cancel(evt);
            }
        },
        ".metabookclearsearch": {
            click: function(evt) {
                return evt = evt || window.event, metaBook.UI.handlers.clearSearch(evt), cancel(evt), 
                !1;
            }
        },
        "#METABOOKSEARCHINFO": {
            click: metaBook.searchTags_onclick
        },
        "#METABOOKINFOPANEL": {
            click: toggleDevMode
        },
        ".metabooksettings input[type='RADIO']": {
            change: mB.configChange
        },
        ".metabooksettings input[type='CHECKBOX']": {
            change: mB.configChange
        }
    }), fdjt.DOM.defListeners(metaBook.UI.handlers.touch, {
        window: {
            keyup: mb_onkeyup,
            keydown: mb_onkeydown,
            keypress: mb_onkeypress,
            touchmove: preview_touchmove_nodefault,
            focus: mb_onfocus,
            touchstart: dombody_touched,
            blur: mb_onblur
        },
        content: {
            tap: body_tapped,
            hold: body_held,
            taptap: body_taptap,
            release: body_released,
            swipe: body_swiped,
            touchstart: body_touchstart,
            touchend: body_touchend,
            touchmove: noDefault,
            click: cancelNotAnchor
        },
        hud: {
            tap: default_tap
        },
        toc: {
            tap: toc_tapped,
            hold: toc_held,
            slip: toc_slipped,
            release: toc_released,
            touchtoo: toc_touchtoo,
            touchmove: preview_touchmove_nodefault
        },
        glossmark: {
            touchstart: glossmark_tapped,
            touchend: cancel
        },
        "#METABOOKSTARTPAGE": {
            touchend: metaBook.UI.dropHUD
        },
        "#METABOOKMENU": {
            tap: raiseHUD
        },
        "#METABOOKSHOWCOVER": {
            tap: showcover_tapped,
            release: showcover_released
        },
        "#METABOOKSEARCHINFO": {
            click: metaBook.searchTags_onclick
        },
        "#METABOOKPAGEREFTEXT": {
            tap: enterPageRef
        },
        "#METABOOKPAGENOTEXT": {
            tap: enterPageNum
        },
        "#METABOOKLOCPCT": {
            tap: enterPercentage
        },
        "#METABOOKLOCOFF": {
            tap: enterLocation
        },
        "#METABOOKSKIMMER": {
            tap: skimmer_tapped,
            swipe: skimmer_swiped
        },
        "#METABOOKPAGEHEAD": {
            touchstart: head_tap
        },
        "#METABOOKTABS": {
            touchstart: head_tap
        },
        "#METABOOKHEAD": {
            touchend: head_tap
        },
        "#METABOOKFOOT": {
            tap: foot_tap,
            touchstart: noDefault,
            touchmove: noDefault
        },
        "#METABOOKGLOSSDETAIL": {
            touchend: metaBook.UI.dropHUD,
            click: cancel
        },
        ".searchcloud": {
            tap: metaBook.UI.handlers.searchcloud_select,
            release: metaBook.UI.handlers.searchcloud_select
        },
        "#MBPAGERIGHT": {
            touchstart: function(evt) {
                hasClass(document.body, "mbSKIMMING") ? skimForward(evt) : pageForward(evt), cancel(evt);
            }
        },
        "#MBPAGELEFT": {
            touchstart: function(evt) {
                hasClass(document.body, "mbSKIMMING") ? skimBackward(evt) : pageBackward(evt), cancel(evt);
            }
        },
        "#METABOOKHELP": {
            tap: toggleHelp,
            swipe: cancel
        },
        "#METABOOKHELPBUTTON": {
            tap: toggleHelp,
            hold: function(evt) {
                setHelp(!0), cancel(evt);
            },
            release: function(evt) {
                setHelp(!1), cancel(evt);
            },
            slip: function(evt) {
                setHelp(!1), cancel(evt);
            }
        },
        "#METABOOKNOTETEXT": {
            touchend: jumpToNote,
            click: cancel
        },
        "#METABOOKSHOWTEXT": {
            touchstart: back_to_reading,
            touchmove: cancel,
            touchend: cancel
        },
        ".hudmodebutton": {
            tap: hudmodebutton,
            hold: hudmodebutton,
            release: hudmodebutton,
            slip: hudmodebutton
        },
        ".hudbutton[alt='save gloss']": {
            tap: saveGloss,
            hold: saveGloss
        },
        ".metabookclosehud": {
            click: back_to_reading,
            touchmove: cancel,
            touchend: cancel
        },
        "#METABOOKSETTINGS": {
            touchend: fdjt.UI.CheckSpan.onclick
        },
        ".metabooktogglehelp": {
            touchstart: cancel,
            touchend: toggleHelp
        },
        "#METABOOKCONSOLETEXTINPUT": {
            touchstart: function() {
                $ID("METABOOKCONSOLETEXTINPUT").focus();
            },
            focus: function() {
                fdjt.DOM.addClass("METABOOKCONSOLEINPUT", "ontop");
            },
            blur: function() {
                fdjt.DOM.dropClass("METABOOKCONSOLEINPUT", "ontop");
            }
        },
        "#METABOOKCONSOLEBUTTON": {
            touchstart: cancel,
            touchend: consolefn
        },
        "#METABOOKREFRESHOFFLINE": {
            touchstart: refreshOffline,
            touchend: cancel
        },
        "#METABOOKREFRESHLAYOUT": {
            touchstart: refreshLayout,
            touchend: cancel
        },
        "#METABOOKRESETSYNC": {
            touchend: cancel,
            touchstart: resetState
        },
        ".clearoffline": {
            touchstart: cancel,
            touchend: clearOffline
        },
        ".metabookclearmode": {
            touchstart: cancel,
            touchend: clearMode
        },
        "#METABOOKGOTOREFHELP": {
            touchstart: cancel,
            touchend: clearMode
        },
        "#METABOOKGOTOPAGEHELP": {
            touchstart: cancel,
            touchend: clearMode
        },
        "#METABOOKGOTOLOCHELP": {
            touchstart: cancel,
            touchend: clearMode
        },
        ".metabookshowsearch": {
            touchstart: cancel,
            touchend: function(evt) {
                metaBook.showSearchResults(), cancel(evt);
            }
        },
        ".metabookrefinesearch": {
            touchstart: cancel,
            touchend: function(evt) {
                setMode("refinesearch"), cancel(evt);
            }
        },
        ".metabookexpandsearch": {
            touchstart: cancel,
            touchend: function(evt) {
                setMode("expandsearch"), cancel(evt);
            }
        },
        ".metabookclearsearch": {
            touchstart: cancel,
            touchend: function(evt) {
                return evt = evt || window.event, metaBook.UI.handlers.clearSearch(evt), cancel(evt), 
                !1;
            }
        },
        summary: {
            touchmove: preview_touchmove_nodefault
        },
        "#METABOOKINFOPANEL": {
            touchstart: toggleDevMode
        },
        ".metabooksettings input[type='RADIO']": {
            change: mB.configChange
        },
        ".metabooksettings input[type='CHECKBOX']": {
            change: mB.configChange
        }
    });
    var vis_listeners = {
        window: {}
    };
    vis_listeners.window[fdjtDOM.vischange] = metabookvischange, fdjt.DOM.defListeners(metaBook.UI.handlers.touch, vis_listeners), 
    fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, vis_listeners);
}(), function() {
    "use strict";
    function getGoPage(target, evt) {
        var pagebar = $ID("METABOOKPAGEBAR"), w = pagebar.offsetWidth, npages = mB.pagecount, evt_x = evt.clientX || evt.touches && evt.touches.length && evt.touches[0].clientX, off = pagebar.offsetLeft, relx = evt_x - off, gopage = npages * (relx / w);
        return (Trace.gestures > 1 || hasClass(pagebar, "metabooktrace")) && fdjtLog("pagebar_GoPage %o: %o-%o=%o/%o=%o => %o/%o", evt, evt_x, off, relx, w, relx / w, gopage, npages), 
        Math.round(gopage + 1);
    }
    function pagebar_hold(evt, target) {
        if (evt = evt || window.event, target || (target = fdjtUI.T(evt)), "mousemove" !== evt.type || evt.buttons) {
            var pagebar = $ID("METABOOKPAGEBAR");
            if (previewTimeout(!1), (mB.hudup || mB.mode) && !mB.fullheight) return fdjtUI.cancel(evt), 
            metaBook.setMode(!1), void 0;
            3 === target.nodeType && (target = target.parentNode);
            var gopage = getGoPage(target, evt);
            (Trace.gestures || hasClass(pagebar, "metabooktrace")) && fdjtLog("pagebar_hold %o t=%o gopage: %o=>%o/%o, start=%o", evt, target, previewing_page, gopage, mB.pagecount, preview_start_page), 
            preview_start_page || (preview_start_page = gopage), previewing_page !== gopage && gopage && (pagebar.title = previewing_page ? fdjtString("Release to go to this page (%d), move away to return to page %d", gopage, mB.curpage) : fdjtString(mB.touch ? "Release to return to page %d, tap the content or margin to settle here (page %d)" : "Release to return to page %d, tap a key to settle here (page %d)", metaBook.curpage, gopage), 
            previewing_page = gopage, metaBook.startPreview("CODEXPAGE" + previewing_page, "pagebar_hold/timeout"));
        }
    }
    function pagebar_tap(evt, target) {
        evt = evt || window.event, target || (target = fdjtUI.T(evt));
        var pagebar = $ID("METABOOKPAGEBAR");
        if ((Trace.gestures || hasClass(pagebar, "metabooktrace")) && fdjtLog("pagebar_tap %o", evt), 
        previewTimeout(!1), mB.previewing && !previewing_page) return metaBook.stopPreview("pagebar_tap", !0), 
        void 0;
        if (mB.hudup || mB.mode || mB.cxthelp) return Trace.gestures && fdjtLog("clearHUD %s %s %s", mB.mode, mB.hudup ? "hudup" : "", mB.cxthelp ? "hudup" : ""), 
        fdjtUI.cancel(evt), metaBook.setMode(!1), void 0;
        3 === target.nodeType && (target = target.parentNode);
        var gopage = getGoPage(target, evt);
        previewing_page !== gopage && (metaBook.GoToPage(gopage, "pagebar_tap", !0), metaBook.setMode(!1));
    }
    function pagebar_release(evt, target) {
        evt = evt || window.event, target || (target = fdjtUI.T(evt));
        var pagebar = $ID("METABOOKPAGEBAR");
        return (Trace.gestures || hasClass(pagebar, "metabooktrace")) && fdjtLog("pagebar_release %o, previewing=%o, ptarget=%o start=%o", evt, mB.previewing, mB.previewTarget, preview_start_page), 
        previewTimeout(!1), 3 === target.nodeType && (target = target.parentNode), mB.previewing ? (dropClass(target, "preview"), 
        metaBook.stopPreview("pagebar_release", !0), preview_start_page = !1, previewing_page = !1, 
        fdjtUI.cancel(evt), hasParent(target, pagebar) && "SPAN" === target.tagName, void 0) : (preview_start_page = !1, 
        void 0);
    }
    function pagebar_slip(evt, target) {
        evt = evt || window.event, target || (target = fdjtUI.T(evt));
        var rel = evt.relatedTarget, pagebar = $ID("METABOOKPAGEBAR");
        previewTimeout(!1), (Trace.gestures || hasClass(pagebar, "metabooktrace")) && fdjtLog("pagebar_slip %o, pre=%o, target=%o start=%o, rel=%o", evt, mB.previewing, mB.previewTarget, preview_start_page, rel), 
        mB.previewing && (getParent(rel, mbDOM.pagebar) || (rel && hasParent(rel, mB.body) ? previewTimeout(function() {
            var pagebar = $ID("METABOOKPAGEBAR");
            pagebar.title = "", metaBook.GoTo(rel, evt);
        }) : previewTimeout(function() {
            var pagebar = $ID("METABOOKPAGEBAR");
            pagebar.title = "", dropClass(target, "preview"), metaBook.stopPagePreview("pagebar_slip/timeout");
        }), previewing_page = !1));
    }
    function pagebar_touchtoo(evt, target) {
        return evt = evt || window.event, target || (target = fdjtUI.T(evt)), mB.previewing ? (metaBook.stopPreview("touchtoo"), 
        fdjtUI.TapHold.clear(), metaBook.setHUD(!1), fdjt.UI.cancel(evt), !1) : void 0;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, $ID = fdjt.ID, fdjtString = fdjt.String, dropClass = fdjtDOM.dropClass, hasClass = fdjtDOM.hasClass, hasParent = fdjtDOM.hasParent, getParent = fdjtDOM.getParent, mB = metaBook, mbDOM = metaBook.DOM, previewTimeout = mB.previewTimeout, cancel = fdjtUI.cancel, Trace = metaBook.Trace, previewing_page = !1, preview_start_page = !1;
    fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, {
        "#METABOOKPAGEBAR": {
            tap: pagebar_tap,
            hold: pagebar_hold,
            mousemove: pagebar_hold,
            release: pagebar_release,
            slip: pagebar_slip,
            click: cancel
        }
    }), fdjt.DOM.defListeners(metaBook.UI.handlers.touch, {
        "#METABOOKPAGEBAR": {
            tap: pagebar_tap,
            hold: pagebar_hold,
            touchmove: pagebar_hold,
            release: pagebar_release,
            slip: pagebar_slip,
            touchtoo: pagebar_touchtoo,
            click: cancel
        }
    });
}(), function() {
    "use strict";
    function startZoom(node) {
        var copy, zoom_target = $ID("METABOOKZOOMTARGET");
        if ((Trace.zoom || Trace.mode) && fdjtLog("startZoom %o", node), !node) return stopZoom();
        if (metaBook.zoomtarget === node && (metaBook.zoomed = node, addClass(document.body, "mbZOOM")), 
        metaBook.zoomtarget = node, metaBook.layout) {
            var layout = metaBook.layout, id = node.getAttribute("data-baseid") || node.id;
            layout.lostids && layout.lostids[id] ? copy = layout.lostids[id].cloneNode(!0) : layout.splits[id] && (copy = layout.splits[id].cloneNode(!0));
        } else ;
        copy || (copy = node.cloneNode(!0)), fdjtDOM.stripIDs(copy, !1, "data-baseid"), 
        copy.setAttribute("style", ""), copy.id = "METABOOKZOOMTARGET", fdjt.DOM.replace(zoom_target, copy), 
        addClass(document.body, "mbZOOM");
        var mz = $ID("METABOOKZOOM"), zb = $ID("METABOOKZOOM"), xscale = .9 * mz.clientWidth / mz.scrollWidth, yscale = .9 * mz.clientHeight / mz.scrollHeight;
        mB.zoomscale = 1, zb.style[fdjt.DOM.transform] = "", yscale > xscale ? setZoom(xscale) : setZoom(yscale);
    }
    function stopZoom(evt) {
        dropClass(document.body, "mbZOOM"), metaBook.zoomed = !1, evt && fdjt.UI.cancel(evt);
    }
    function setZoom(scale, zx, zy) {
        var mz = $ID("METABOOKZOOM"), zb = $ID("METABOOKZOOMBOX"), rx = mz.scrollLeft / mz.scrollWidth, ry = mz.scrollTop / mz.scrollHeight;
        if ("number" == typeof zx ? (mB.zoomX = zx || 0, mB.zoomY = zy || 0) : "number" == typeof mB.zoomX && (zx = mB.zoomX, 
        zy = mB.zoomY), (Trace.zoom || Trace.gestures) && ("number" == typeof zx ? fdjtLog("setZoom(%o) @%o,%o %o", scale, zx, zy, zb) : fdjtLog("setZoom(%o) @%o,%o %o", scale, rx, ry, zb)), 
        scale) metaBook.zoomscale = scale, zb.style[fdjt.DOM.transform] = "number" == typeof zx ? "transform(" + zx + "px," + zy + "px) " + "scale(" + scale + ")" : "scale(" + scale + ")", 
        Trace.zoom && fdjtLog("%s=%s %o", fdjt.DOM.transform, zb.style[fdjt.DOM.transform], zb); else {
            mB.zoomX = mB.zoomY = !1, mB.zoomscale = 1, zb.style[fdjt.DOM.transform] = "";
            var xscale = .9 * mz.clientWidth / mz.scrollWidth, yscale = .9 * mz.clientHeight / mz.scrollHeight;
            yscale > xscale ? setZoom(xscale) : setZoom(yscale);
        }
        "number" != typeof zx && (mB.zoomX = mB.zoomY = !1, mz.scrollLeft = rx * mz.scrollWidth, 
        mz.scrollTop = ry * mz.scrollHeight);
    }
    function zoom(adjust) {
        adjust ? setZoom((metaBook.zoomscale || 1) * adjust) : setZoom(!1);
    }
    function zoomIn(evt) {
        evt = evt || window.event, zoom(1.1), fdjt.UI.cancel(evt);
    }
    function zoomOut(evt) {
        evt = evt || window.event, zoom(1 / 1.1), fdjt.UI.cancel(evt);
    }
    function unZoom(evt) {
        evt = evt || window.event, zoom(!1), fdjt.UI.cancel(evt);
    }
    function zoom_touchstart(evt) {
        if (evt && evt.touches && evt.touches.length >= 1) {
            var zc = $ID("METABOOKZOOMCONTROLS"), target = getTarget(evt);
            if (!hasParent(target, zc)) {
                var touches = evt.touches, touch1 = touches[0], x1 = touch1.clientX, y1 = touch1.clientY;
                if (2 === evt.touches.length) {
                    var touch2 = touches[1], x2 = touch2.clientX, y2 = touch2.clientY, dx = x2 - x1, dy = y2 - y1, d = Math.sqrt(dx * dx + dy * dy);
                    cg_x = (x1 + x2) / 2, cg_y = (y1 + y2) / 2, (Trace.zoom || Trace.gestures) && fdjtLog("zoom_touchstart(2) %o: d=%o@[%o,%o] [%o,%o]-[%o,%o]", evt, d, cg_x, cg_y, x1, y1, x2, y2), 
                    d_last = d_start = d, panstart_x = panstart_y = pan_dx = pan_dy = !1, cancel(evt);
                } else 1 === evt.touches.length && (panstart_x = x1, panstart_y = y1, (Trace.zoom || Trace.gestures) && fdjtLog("zoom_touchstart(1) %o: [%o,%o]", evt, x1, y1), 
                cancel(evt));
            }
        }
    }
    function zoom_touchmove(evt) {
        if (evt && evt.touches && evt.touches.length >= 1) {
            var zb = $ID("METABOOKZOOMBOX"), zbs = zb.style, zoomscale = mB.zoomscale || 1, transform = fdjtDOM.transform, touches = evt.touches, touch1 = touches[0], x1 = touch1.clientX, y1 = touch1.clientY, off_x = mB.zoomX || 0, off_y = mB.zoomY || 0;
            if (2 === evt.touches.length && "number" == typeof d_last) {
                var touch2 = touches[1], x2 = touch2.clientX, y2 = touch2.clientY, ncg_x = (x1 + x2) / 2, ncg_y = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d = Math.sqrt(dx * dx + dy * dy), scale = d / d_start * zoomscale;
                off_x += ncg_x * zoomscale - ncg_x * scale, off_y += ncg_y * zoomscale - ncg_y * scale, 
                (Trace.zoom || Trace.gestures > 1) && fdjtLog("zoom_touchmove(2) %o: d=%o->%o@[%o,%o] [%o,%o] [%o,%o]", evt, d_last, d, ncg_x, ncg_y, x1, y1, x2, y2), 
                zbs[transform] = "translate3d(" + off_x + "px," + off_y + "px) " + "scale(" + scale + ",0)", 
                Trace.zoom && fdjtLog("%s %o: %s", transform, zb, zbs[transform]), cg_x = ncg_x, 
                cg_y = ncg_y, d_last = d, cancel(evt);
            } else 1 === evt.touches.length && "number" == typeof panstart_x && (pan_dx = x1 - panstart_x, 
            pan_dy = y1 - panstart_y, off_x += pan_dx, off_y += pan_dy, (Trace.zoom || Trace.gestures > 1) && fdjtLog("zoom_touchmove(1) %o: [%o,%o]=[%o,%o]+([%o,%o]=[%o,%o]-[%o,%o])", evt, off_x, off_y, mB.zoomX, mB.zoomY, pan_dx, pan_dy, x1, y1, panstart_x, panstart_y), 
            zbs[transform] = "translate3d(" + off_x + "px," + off_y + "px) " + "scale(" + zoomscale + ",0)", 
            Trace.zoom && fdjtLog("%s %o: %s", transform, zb, zbs[transform]), cancel(evt));
        }
    }
    function zoom_touchend(evt) {
        var zoomscale = mB.zoomscale || 1, off_x = mB.zoomX || 0, off_y = mB.zoomY || 0;
        if (d_last && d_start) {
            var scale = d_last / d_start;
            off_x += cg_x * zoomscale - cg_x * scale * zoomscale, off_y += cg_y * zoomscale - cg_y * scale * zoomscale, 
            (Trace.zoom || Trace.gestures) && fdjtLog("zoom_touchend(2) %o: %o=%o/%o@[%o,%o] zx=%o zy=%o", evt, scale, d_last, d_start, cg_x, cg_y, off_x, off_y), 
            setZoom(scale * zoomscale, off_x, off_y), off_x = off_y = d_last = d_start = !1;
        } else if ("number" == typeof panstart_x) {
            var new_x = mB.zoomX || 0, new_y = mB.zoomY || 0;
            (Trace.zoom || Trace.gestures) && fdjtLog("zoom_touchend(2) %o: [%o,%o]=[%o,%o] start [%o,%o]", evt, new_x + pan_dx, new_y + pan_dy, pan_dx, pan_dy, panstart_x, panstart_y), 
            mB.zoomX = new_x + pan_dx, mB.zoomY = new_y + pan_dy, pan_dx = pan_dy = panstart_x = panstart_y = !1;
        }
    }
    function showMedia(url, type) {
        function placeMedia() {
            media_elt ? media_target.parentNode && fdjt.DOM.replace(media_target, media_elt) : $ID("METABOOKMEDIA").appendChild(media_target), 
            addClass(document.body, "mbMEDIA");
        }
        var media_target = $ID("METABOOKMEDIATARGET"), media_elt = !1, src_elt = !1;
        return metaBook.showing === url ? (addClass(document.body, "mbMEDIA"), void 0) : (0 === type.search("image") ? src_elt = media_elt = fdjtDOM("IMG") : 0 === type.search("audio") ? (src_elt = fdjtDOM("SOURCE"), 
        media_elt = fdjtDOM("AUDIO", src_elt), media_elt.setAttribute("CONTROLS", "CONTROLS"), 
        media_elt.setAttribute("AUTOPLAY", "AUTOPLAY"), src_elt.type = type) : 0 === type.search("video") ? (src_elt = fdjtDOM("SOURCE"), 
        src_elt.type = type, media_elt = fdjtDOM("VIDEO", src_elt), media_elt.setAttribute("CONTROLS", "CONTROLS"), 
        media_elt.setAttribute("AUTOPLAY", "AUTOPLAY")) : 0 === url.search("https://www.youtube.com/embed/") ? (url = "https://www.youtube-nocookie.com/" + url.slice("https://www.youtube.com/".length), 
        url += url.indexOf("?") > 0 ? "&rel=0" : "?rel=0") : src_elt = media_elt = fdjtDOM("IFRAME"), 
        media_elt.id = "METABOOKMEDIATARGET", metaBook.showing = url, src_elt && mB.glossdata[url] ? (src_elt.src = mB.glossdata[url], 
        placeMedia()) : src_elt ? (addClass($ID("METABOOKMEDIA"), "loadingcontent"), addClass(src_elt, "loadingcontent"), 
        metaBook.getGlossData(url).then(function(val) {
            dropClass($ID("METABOOKMEDIA"), "loadingcontent"), dropClass(src_elt, "loadingcontent"), 
            src_elt.src = val, placeMedia();
        }).catch(function(ex) {
            fdjt.Log("Couldn't fetch glossdata from %s: %o", url, ex), metaBook.showing = url, 
            dropClass($ID("METABOOKMEDIA"), "loadingcontent"), dropClass(src_elt, "loadingcontent");
        })) : placeMedia(), void 0);
    }
    function hideMedia() {
        dropClass(document.body, "mbMEDIA");
    }
    function closeMedia_tapped(evt) {
        evt = evt || window.event;
        var media_elt = $ID("METABOOKMEDIATARGET");
        pause_media_timeout ? (clearTimeout(pause_media_timeout), pause_media_timeout = !1, 
        dropClass(document.body, "mbMEDIA")) : evt.shiftKey ? (clearTimeout(pause_media_timeout), 
        pause_media_timeout = !1, dropClass(document.body, "mbMEDIA")) : media_elt && media_elt.pause && !media_elt.paused ? pause_media_timeout = setTimeout(function() {
            media_elt.pause(), pause_media_timeout = !1, dropClass(document.body, "mbMEDIA");
        }, 1500) : dropClass(document.body, "mbMEDIA"), fdjt.UI.cancel(evt);
    }
    function zoomMedia(evt) {
        evt = evt || window.event;
        var target = getTarget(evt), media_elt = $ID("METABOOKMEDIATARGET");
        target === media_elt && fdjtDOM.isImage(target) && (dropClass(document.body, "mbMEDIA"), 
        mB.startZoom(media_elt));
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, cancel = fdjtDOM.cancel, getTarget = fdjtDOM.T, hasParent = fdjtDOM.hasParent, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, mB = metaBook, $ID = fdjt.ID, Trace = mB.Trace;
    metaBook.startZoom = startZoom, metaBook.stopZoom = stopZoom, metaBook.zoom = zoom;
    var d_start, d_last, cg_x, cg_y, panstart_x, panstart_y, pan_dx, pan_dy;
    fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, {
        "#METABOOKZOOMCLOSE": {
            click: stopZoom
        },
        "#METABOOKZOOMHELP": {
            click: metaBook.toggleHelp
        },
        "#METABOOKZOOMIN": {
            click: zoomIn
        },
        "#METABOOKZOOMOUT": {
            click: zoomOut
        },
        "#METABOOKUNZOOM": {
            click: unZoom
        }
    }), fdjt.DOM.defListeners(metaBook.UI.handlers.touch, {
        "#METABOOKZOOM": {
            touchstart: zoom_touchstart,
            touchmove: zoom_touchmove,
            touchend: zoom_touchend
        },
        "#METABOOKZOOMCLOSE": {
            click: metaBook.stopZoom
        },
        "#METABOOKZOOMHELP": {
            click: metaBook.toggleHelp
        },
        "#METABOOKZOOMIN": {
            touchend: zoomIn
        },
        "#METABOOKZOOMOUT": {
            touchend: zoomOut
        },
        "#METABOOKUNZOOM": {
            touchend: unZoom
        }
    }), metaBook.showMedia = showMedia, metaBook.hideMedia = hideMedia;
    var pause_media_timeout = !1;
    fdjt.DOM.defListeners(metaBook.UI.handlers.mouse, {
        "#METABOOKCLOSEMEDIA": {
            mousedown: closeMedia_tapped
        },
        "#METABOOKMEDIA": {
            click: zoomMedia
        }
    }), fdjt.DOM.defListeners(metaBook.UI.handlers.touch, {
        "#METABOOKCLOSEMEDIA": {
            touchend: closeMedia_tapped
        },
        "#METABOOKMEDIA": {
            touchend: zoomMedia
        }
    });
}(), metaBook.Paginate = function() {
    "use strict";
    function layoutWait() {
        layout_waiting || (layout_waiting = []), layout_preview_next = fdjtTime(), fdjtLog("Waiting for layout to finish"), 
        setTimeout(function() {
            addClass("MBLAYOUTWAIT", "live");
        }, 100);
    }
    function stopLayoutWait() {
        if (layout_previewing && (dropClass(layout_previewing, "previewcurpage"), dropClass(layout_previewing, "curpage"), 
        layout_previewing = !1), layout_waiting) {
            fdjtLog("Done with layout wait");
            var readyfns = layout_waiting;
            layout_waiting = !1, layout_preview_next = !1, setTimeout(function() {
                dropClass("MBLAYOUTWAIT", "live");
            }, 200);
            for (var i = 0, lim = readyfns.length; lim > i; ) readyfns[i++]();
        }
    }
    function layoutReady(whenready) {
        return mB.layout && mB.layout.done ? whenready() : (layout_waiting ? layout_waiting.push(whenready) : layout_waiting = [ whenready ], 
        void 0);
    }
    function layoutMessage(string, pct) {
        var pb = $ID("METABOOKLAYOUTMESSAGE");
        pb && (fdjt.UI.ProgressBar.setMessage(pb, string), "number" == typeof pct && fdjt.UI.ProgressBar.setProgress(pb, pct));
        var fpb = $ID("METABOOKLAYOUTADJUST");
        if (layout_waiting) {
            var layout = mB.layout, now = fdjtTime();
            if (fpb && (fpb.innerHTML = "Updating layout (" + Math.round(pct) + "%)"), now > layout_preview_next) {
                var pages = layout.pages, latest = pages[pages.length - 2];
                dropClass(layout_previewing, "curpage"), dropClass(layout_previewing, "previewcurpage"), 
                latest && (addClass(latest, "curpage"), addClass(latest, "previewcurpage")), layout_previewing = latest, 
                layout_preview_next = now + layout_preview_interval;
            }
        } else fpb && (fpb.innerHTML = "Finishing layout @" + Math.round(pct) + "%");
    }
    function layout_progress(info) {
        var tracelevel = info.tracelevel, started = info.started, pagenum = info.pagenum;
        if (pagenum) {
            var now = fdjtTime(), howlong = secs2short((now - started) / 1e3), indicator = $ID("METABOOKLAYOUTINDICATOR");
            if (info.done) indicator && (indicator.style.width = "100%"), layout_next_report = !1, 
            dropClass(layout_previewing, "curpage"), dropClass(layout_previewing, "previewcurpage"), 
            layout_previewing = !1, fdjtDOM.replace("METABOOKPAGENOTEXT", fdjtDOM("div.metabookpageno#METABOOKPAGENOTEXT", mB.curpage || "?", "/", pagenum)), 
            layoutMessage(fdjtString("Finished laying out %d %dx%d pages in %s", pagenum, info.width, info.height, secs2short((info.done - info.started) / 1e3)), 100), 
            fdjtLog("Finished laying out %d %dx%d pages in %s", pagenum, info.width, info.height, secs2short((info.done - info.started) / 1e3)); else {
                if (layout_next_report && layout_next_report > now) return;
                if (layout_next_report = now + layout_report_interval, info.lastid && mB.docinfo && mB.docinfo[info.lastid]) {
                    var docinfo = mB.docinfo, maxloc = docinfo._maxloc, lastloc = docinfo[info.lastid].starts_at, pct = 100 * lastloc / maxloc, fpct = Math.floor(pct);
                    indicator && (indicator.style.width = fpct + "%"), fdjtDOM.replace("METABOOKPAGENOTEXT", fdjtDOM("div.metabookpageno#METABOOKPAGENOTEXT", mB.curpage || "?", "/", pagenum, " (", fpct, "%)")), 
                    mB.devmode ? layoutMessage(fdjtString("Formatted %d %dx%d pages (%d%%)", pagenum, info.width, info.height, fpct), pct) : layoutMessage(fdjtString("Formatting for your device (%d%%)", fpct), pct), 
                    tracelevel && fdjtLog("Formatted %d %dx%d pages (%d%%) in %s", pagenum, info.width, info.height, fpct, howlong);
                } else layoutMessage(fdjtString("Formatted %d %dx%d pages in %s", info.pagenum, info.width, info.height, howlong)), 
                tracelevel && fdjtLog("Formatted %d pages in %s", info.pagenum, howlong);
            }
        }
    }
    function Paginate(why, init) {
        function restore_layout(content, layout_id) {
            fdjtLog("Using saved layout %s", layout_id), $ID("CODEXCONTENT").style.display = "none", 
            layoutMessage("Using cached layout", 0), dropClass(document.body, "_SCROLL"), addClass(document.body, "_BYPAGE"), 
            layout.started = fdjtTime(), layout.restoreLayout(content).then(function() {
                Timeline.layout_restored = fdjtTime(), finish_restore(layout);
            });
        }
        function finish_restore(layout) {
            var started = layout.started;
            $ID("CODEXPAGE").style.visibility = "", $ID("CODEXCONTENT").style.visibility = "", 
            dropClass(document.body, "mbLAYOUT"), mB.layout = layout, mB.pagecount = layout.pages.length, 
            fdjtLog("Restored %d-page layout %s in %ds, adding glosses", layout.pages.length, layout_id, (fdjtTime() - started) / 1e3), 
            stopLayoutWait();
            for (var lostids = layout.lostids, moved_ids = lostids._all_ids, i = 0, lim = moved_ids.length; lim > i; ) {
                var addGlossmark = mB.UI.addGlossmark, id = moved_ids[i++], glosses = mB.glossdb.find("frag", id);
                if (glosses && glosses.length) for (var j = 0, jlim = glosses.length; jlim > j; ) {
                    var gloss = mB.glossdb.probe(glosses[j++]);
                    if (gloss) {
                        var nodes = mB.getDups(gloss.frag);
                        addClass(nodes, "glossed");
                        for (var k = 0, klim = nodes.length; klim > k; ) addGlossmark(nodes[k++], gloss);
                    }
                }
            }
            if (Trace.startup && fdjtLog("Finished adding glossmarks to saved layout"), setupPagebar(), 
            mB.layoutdone) {
                var fn = mB.layoutdone;
                mB.layoutdone = !1, fn();
            }
            return Timeline.layout_complete = fdjtTime(), mB.state && mB.restoreState(mB.state, "layoutRestored"), 
            mB.layout.running = !1, !1;
        }
        function recordLayout(layout_id, source_id) {
            var key = "mB(" + source_id + ").layouts", saved = getLocal(key, !0);
            if (saved) {
                var loc = saved.indexOf(layout_id);
                if (loc >= 0 && saved.splice(loc, 1), saved.push(layout_id), saved.length > max_layouts) {
                    for (var j = saved.length - max_layouts - 1; j >= 0; ) fdjtLog("Dropping layout #%d %s", j, saved[j]), 
                    CodexLayout.dropLayout(saved[j--]);
                    saved = saved.slice(saved.length - max_layouts);
                }
                setLocal(key, saved, !0);
            } else setLocal(key, [ layout_id ], !0);
        }
        function finishPageInfo(page, layout) {
            var pages = layout.pages, pagenum = atoi(page.getAttribute("data-pagenum"), 10), docinfo = mB.docinfo, curloc = !1, lastid = getPageLastID(page), prevpage = pagenum && pagenum > 1 && pages[pagenum - 2];
            if (lastid && page.setAttribute("data-lastid", lastid), !page.getAttribute("data-mbloc") && prevpage) {
                var prevlast = prevpage.getAttribute("data-lastid"), lastinfo = prevlast && docinfo[prevlast];
                if (lastinfo) curloc = lastinfo.starts_at, page.setAttribute("data-mbloc", lastinfo.ends_at); else {
                    var prevoff = prevpage.getAttribute("data-mbloc");
                    prevoff ? page.setAttribute("data-mbloc", prevoff) : page.setAttribute("data-mbloc", "0");
                }
            }
        }
        function getPageLastID(node, id) {
            if (hasClass(node, "codexpage") || node.id && !node.codexbaseid && mB.docinfo[node.id] && (id = node.id), 
            1 !== node.nodeType) return id;
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                1 === child.nodeType && (id = getPageLastID(child, id));
            }
            return id;
        }
        function get_image_donefn(whenready) {
            function image_loaded(evt) {
                var target = fdjt.UI.T(evt);
                target.onload = !1, target.onerror = !1, "load" === evt.type ? images_loaded++ : images_failed++, 
                target.parentElement && target.parentElement.removeChild(target), images_loaded + images_failed >= images_count && (Timeline.images_loaded = fdjtTime(), 
                whenready());
            }
            return image_loaded;
        }
        function body_wait(content, whenready) {
            if (content || (content = mB.content || document.body), Timeline.dom_ready) return whenready();
            var images = fdjtDOM.getChildren(content, "IMG"), donefn = get_image_donefn(whenready);
            if (images && images.length) {
                for (var dups = [], i = 0, n_imgs = images.length; n_imgs > i; ) {
                    var img = images[i++];
                    if (img.src) {
                        var dup = fdjtDOM("IMG");
                        dup.src = img.src, dup.onload = dup.onerror = donefn, dup.style.display = "none", 
                        dups.push(dup);
                    }
                }
                if (0 === dups.length) return whenready();
                images_count = dups.length;
                for (var body = document.body, j = 0, n_dups = dups.length; n_dups > j; ) body.appendChild(dups[j++]);
            }
        }
        function new_layout() {
            function rootloop() {
                if (root_i >= n_roots) {
                    layout.Finish(), layout_progress(layout);
                    for (var pages = layout.pages, i = 0, n = pages.length; n > i; ) finishPageInfo(pages[i++], layout);
                    Timeline.layout_done = fdjtTime();
                    var cachethresh = mB.cache_layout_thresh;
                    if (cachethresh) {
                        var elapsed = layout.done - layout.started;
                        ("number" == typeof cachethresh ? elapsed > cachethresh : elapsed > 5e3) && layout.saveLayout(function(l) {
                            recordLayout(l.layout_id, mB.sourceid);
                        });
                    }
                    if ($ID("CODEXPAGE").style.visibility = "", $ID("CODEXCONTENT").style.visibility = "", 
                    dropClass(document.body, "mbLAYOUT"), mB.layout = layout, mB.pagecount = layout.pages.length, 
                    setupPagebar(), stopLayoutWait(), mB.layoutdone) {
                        var fn = mB.layoutdone;
                        mB.layoutdone = !1, fn();
                    }
                    if (mB.state && (layout_waiting || !mB.curpage)) {
                        var state = mB.state, targetid = state.target || state.hash;
                        mB.GoTo(state.location || state.target || state.hash, "layoutDone", targetid && mbID(targetid), !1, !0);
                    }
                    return mB.layout.running = !1, async && setTimeout(checkLayout, 100), !1;
                }
                var root = roots[root_i++];
                return 3 === root.nodeType && !isEmpty(root.nodeValue) || 1 === root.nodeType && "LINK" !== root.tagName && "META" !== root.tagName && "SCRIPT" !== root.tagName && "BASE" !== root.tagName ? (layout.addContent(root, timeslice, timeskip, layout.tracelevel, layout_progress, async && rootloop), 
                void 0) : async ? rootloop() : !0;
            }
            dropClass(document.body, "_SCROLL"), addClass(document.body, "_BYPAGE"), layoutWait();
            var saved_width = mB.content.style.width;
            mB.content.style.width = getGeometry(mB.page).width + "px";
            var content = mB.content, roots = toArray(content.childNodes);
            fdjtLog("Laying out %d root nodes into %dx%d pages (%s), id=%s, async=%s", roots.length, layout.width, layout.height, why || "", layout_id, timeslice ? fdjtString("%d(%d)", timeslice, timeskip) : "no"), 
            layoutMessage("Starting new layout", 0), fdjt.DOM.adjustFonts(content), mB.content.style.width = saved_width;
            var root_i = 0, n_roots = roots.length;
            if (async) rootloop(); else for (var running = !0; running; ) running = rootloop();
        }
        function start_new_layout() {
            Timeline.layout_started = fdjtTime(), new_layout();
        }
        function request_layout() {
            Timeline.layout_requested || (Timeline.layout_requested = fdjtTime()), body_wait(mB.content, start_new_layout);
        }
        if (!mB.layout || mB.layout.done) {
            why || (why = "because"), Timeline.page_layout_started = fdjtTime(), Trace.layout && fdjtLog("Starting pagination (%s) with %j", why, init), 
            layoutMessage("Preparing your book", 0), dropClass(document.body, "_SCROLL"), addClass(document.body, "mbLAYOUT"), 
            scaleLayout(!1), Trace.layout && fdjtLog("Unscaled layout");
            var forced = init && init.forced, geom = getGeometry($ID("CODEXPAGE"), !1, !0), height = geom.inner_height, width = geom.width, justify = mB.textjustify, spacing = mB.bodyspacing, size = mB.bodysize || "normal", family = mB.dyslexical ? "opendyslexic" : mB.bodyfamily || "default";
            if (!mB.layout && Trace.startup > 1 && fdjtLog("Page layout requires %dx%d %s pages", width, height, size), 
            mB.layout) {
                var current = mB.layout;
                if (!forced && width === current.width && height === current.height && size === current.bodysize && family === current.bodyfamily && (!spacing || spacing === current.bodyspacing) && (justify && current.justify || !justify && !current.justify)) return dropClass(document.body, "mbLAYOUT"), 
                fdjtLog("Skipping redundant pagination for %s", current.layout_id), void 0;
                Trace.layout && fdjtLog("Reverting current layout"), mB.layout.Revert(), mB.layout = !1;
            }
            Trace.layout && fdjtLog("Sizing the content"), mB.sizeContent();
            var layout_args = getLayoutArgs();
            init && init.hasOwnProperty("timeslice") && (layout_args.timeslice = init.timeslice), 
            Trace.layout && fdjtLog("Starting content layout");
            var layout = new CodexLayout(layout_args);
            layout.bodysize = size, layout.bodyfamily = family, mB.layout = layout;
            var timeslice = layout.hasOwnProperty("timeslice") ? layout.timeslice : CodexLayout.timeslice, timeskip = "number" == typeof timeslice && (layout.hasOwnProperty("timeskip") ? layout.timeskip : CodexLayout.timeskip), async = "number" == typeof timeslice, layout_id = layout.layout_id, max_layouts = 3, images_count = 0, images_loaded = 0, images_failed = 0;
            !mB.cache_layout_thresh || mB.forcelayout || forced ? request_layout() : (Trace.layout && fdjtLog("Fetching layout %s", layout_id), 
            CodexLayout.fetchLayout(layout_id).then(function(content) {
                if (!content) return request_layout();
                Trace.layout && fdjtLog("Got layout %s", layout_id), recordLayout(layout_id, mB.sourceid);
                try {
                    return Timeline.layout_fetched = fdjtTime(), restore_layout(content, layout_id);
                } catch (ex) {
                    fdjtLog("Layout restore error: %o", ex), request_layout();
                }
            }).catch(function() {
                request_layout();
            }));
        }
    }
    function updateLayoutProperty(name, val) {
        val === !0 ? fdjtDOM.addClass(mB.body, "metabook" + name) : val ? fdjtDOM.swapClass(mB.body, RegExp("metabook" + name + "\\w*"), "metabook" + name + val) : fdjtDOM.dropClass(mB.body, RegExp("metabook" + name + "\\w*")), 
        metaBook[name] = val, mB.postconfig && mB.content ? (0 > mB.postconfig.indexOf(mB.sizeContent) && (mB.sized = !1), 
        mB.postconfig.push(mB.sizeContent)) : mB.content && mB.sizeContent(), mB.layout && (mB.postconfig ? mB.postconfig.push(function() {
            mB.Paginate(name);
        }) : mB.Paginate(name)), fdjt.Async(function() {
            mB.updateSettings(name, val);
        });
    }
    function getLayoutID(width, height, family, size, spacing, justify, source_id) {
        var page = $ID("CODEXPAGE"), left = page.style.left, right = page.style.right, docref = mB.docref, sourceid = mB.sourceid, sourcehash = fdjt.CodexLayout.sourcehash;
        return page.style.left = "", page.style.right = "", width || (width = getGeometry(page, !1, !0).width), 
        height || (height = getGeometry($ID("CODEXPAGE"), !1, !0).inner_height), size || (size = mB.bodysize || "normal"), 
        source_id || (source_id = mB.sourceid || fdjtHash.hex_md5(mB.docuri)), justify || (justify = mB.textjustify), 
        spacing || (spacing = mB.linespacing), page.style.left = left, page.style.right = right, 
        fdjtString("%s%dx%d-%s-%s%s%s%s%s", docref ? docref + ":" : "", width, height, family, size, justify ? "-j" : "", spacing ? "-l" + spacing : "", sourceid ? "#" + sourceid : "", sourcehash ? "/" + sourcehash : "");
    }
    function layoutCached(layout_id) {
        layout_id ? "number" == typeof layout_id && (layout_id = getLayoutID.apply(null, arguments)) : layout_id = getLayoutID();
        var layouts = getLocal("mB(" + mB.sourceid + ").layouts", !0);
        return layouts && layouts.indexOf(layout_id) >= 0;
    }
    function clearLayouts(source_id) {
        if (source_id === void 0 && (source_id = mB.sourceid), source_id) {
            for (var layouts = getLocal("mB(" + source_id + ").layouts", !0), i = 0, lim = layouts.length; lim > i; ) {
                var layout = layouts[i++];
                fdjtLog("Dropping layout %s", layout), CodexLayout.dropLayout(layout);
            }
            fdjtState.dropLocal("mB(" + source_id + ").layouts");
        } else CodexLayout.clearLayouts(), CodexLayout.clearAll(), fdjtState.dropLocal(/^mB.layouts\(/g);
    }
    function getLayoutArgs() {
        function finishedPage(page, layout) {
            var pages = layout.pages, pagenum = layout.pagenum, topnode = getPageTop(page), topid = topnode.codexbaseid || topnode.id, prevpage = pagenum && pagenum > 1 && pages[pagenum - 2], staticref = getChild(page, ".staticpageref"), curloc = !1;
            if (staticref) {
                var pageref = staticref.getAttribute("data-pageref");
                pageref || (pageref = stripMarkup(staticref.innerHTML)), pageref && (layout.pagemap || (layout.pagemap = {}), 
                page.setAttribute("data-staticpageref", pageref), layout.pagemap[pageref] || (layout.laststaticref = pageref), 
                layout.pagemap[pageref] = page);
            } else if (prevpage) {
                var prevref = prevpage.getAttribute("data-staticpageref");
                prevref && page.setAttribute("data-staticpageref", prevref);
            }
            if (topnode) {
                var topstart = mbID(topid), locoff = topstart === topnode ? 0 : getLocOff(pages, topstart, topnode), info = docinfo[topid];
                curloc = info.starts_at + locoff, topid && page.setAttribute("data-topid", topid), 
                page.setAttribute("data-mbloc", curloc);
            }
            if (mB.state && layout_waiting) {
                var state = mB.state, target = state.target, loc = state.location, resolved = target ? getPage(target, loc) : curloc && curloc > loc && loc2page(loc, layout);
                Trace.layout && fdjtLog("Checking state %j, resolved=%o", state, resolved), resolved && (stopLayoutWait(), 
                fdjtAsync(function() {
                    mB.GoToPage(resolved, "partial_layout", !1);
                }));
            }
        }
        function getPageTop(node) {
            var last = !1;
            hasClass(node, "codexpage") || (node.id && docinfo[node.id] || node.codexbaseid && docinfo[node.codexbaseid]) && hasContent(node, !0) && (last = node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                if (1 === child.nodeType) {
                    var first = getPageTop(child);
                    if (first) return first;
                }
            }
            return last;
        }
        function getDupNode(under, id) {
            var children;
            if (1 !== under.nodeType) return !1;
            if (under.codexbaseid === id) return under;
            if (!(children = under.childNodes)) return !1;
            if (!children.length) return !1;
            for (var i = 0, lim = children.length; lim > i; ) {
                var found = getDupNode(children[i++], id);
                if (found) return found;
            }
        }
        function getLocOff(pages, topstart, topnode) {
            for (var pagenum, id = topstart.id, locoff = 0, pagescan = topstart, elt = topstart; pagescan && !hasClass(pagescan, "codexpage"); ) pagescan = pagescan.parentNode;
            if (!pagescan) return locoff;
            for (pagenum = parseInt(pagescan.getAttribute("data-pagenum"), 10); elt && elt !== topnode; ) {
                var width = textWidth(elt);
                if (width && (locoff += width), pagescan = pages[pagenum++], !pagescan) return locoff;
                elt = getDupNode(pagescan, id);
            }
            return locoff;
        }
        var width = getGeometry($ID("CODEXPAGE"), !1, !0).width, height = getGeometry($ID("CODEXPAGE"), !1, !0).inner_height, origin = fdjtDOM("div#CODEXCONTENT"), container = fdjtDOM("div.metabookpages#METABOOKPAGES"), bodyfamily = mB.dyslexical ? "opendyslexic" : mB.bodyfamily || "default", bodysize = mB.bodysize || "normal", docref = mB.docref, sourceid = mB.sourceid, justify = mB.textjustify, spacing = mB.linespacing, sourcehash = fdjt.CodexLayout.sourcehash, layout_id = fdjtString("%s%dx%d-%s-%s%s%s%s%s", docref ? docref + ":" : "", width, height, bodyfamily, bodysize, justify ? "-j" : "", spacing ? "-l" + spacing : "", sourceid ? "#" + sourceid : "", sourcehash ? "/" + sourcehash : ""), docinfo = mB.docinfo, getChild = fdjtDOM.getChild, stripMarkup = fdjtString.stripMarkup, saved_sourceid = fdjtState.getLocal("mB(" + mB.docid + ").sourceid");
        if (saved_sourceid && sourceid && sourceid !== sourceid) {
            var layouts = fdjtState.getLocal("fdjtmetaBook.layouts", !0), kept = [];
            if (layouts) for (var pat = RegExp("\\(" + saved_sourceid + "\\)$"), i = 0, lim = layouts.length; lim > i; ) {
                var cacheid = layouts[i++];
                cacheid.search(pat) > 0 ? CodexLayout.dropLayout(cacheid) : kept.push(cacheid);
            }
            kept.length ? fdjtState.setLocal("fdjtmetaBook.layouts", kept) : fdjtState.dropLocal("fdjtmetaBook.layouts", kept);
        }
        sourceid && fdjtState.setLocal("mB(" + mB.docid + ").sourceid", sourceid);
        var args = {
            page_height: height,
            page_width: width,
            orientation: fdjtDOM.getOrientation(window),
            container: container,
            origin: origin,
            pagerule: mB.CSS.pagerule,
            tracelevel: Trace.layout,
            layout_id: layout_id,
            pagefn: finishedPage,
            logfn: fdjtLog
        };
        fdjtDOM.replace("METABOOKPAGES", container), metaBook.pages = container;
        var fbb = getMeta("alwaysbreakbefore", !0, !0).concat(getMeta("forcebreakbefore", !0, !0));
        fbb && fbb.length && (args.forcebreakbefore = fdjtDOM.sel(fbb));
        var fba = getMeta("alwaysbreakafter", !0, !0).concat(getMeta("forcebreakafter", !0, !0));
        fba && fba.length && (args.forcebreakafter = fdjtDOM.sel(fba));
        var abb = getMeta("avoidbreakbefore", !0, !0).concat(getMeta("dontbreakbefore", !0, !0));
        abb && abb.length && (args.avoidbreakbefore = fdjtDOM.sel(abb));
        var aba = getMeta("avoidbreakafter", !0, !0).concat(getMeta("dontbreakafter", !0, !0));
        aba && aba.length && (args.avoidbreakafter = fdjtDOM.sel(aba));
        var abi = getMeta("avoidbreakinside", !0, !0).concat(getMeta("dontbreakinside", !0, !0));
        abi && abi.length && (args.avoidbreakinside = abi);
        var fullpages = [ ".sbookfullpage", ".sbooktitlepage", ".sbookpage" ].concat(getMeta("codexfullpage", !0));
        args.fullpages = fdjtDOM.sel(fullpages);
        var floatpages = [ ".codexfloatpage" ].concat(getMeta("codexfloatpage", !0));
        floatpages && floatpages.length && (args.floatpages = fdjtDOM.sel(floatpages));
        var floating = [ ".codexfloating", ".codexfloat" ].concat(getMeta("codexfloat", !0)).concat(getMeta("codexfloating", !0));
        return floating && floating.length && (args.floating = fdjtDOM.sel(floating)), args.break_blocks = getMeta("metaBook.dontbreakblocks") || getMeta("metaBook.keepblocks") || getMeta("~=metaBook.dontbreakblocks") || getMeta("~=metaBook.keepblocks") || getMeta("~dontbreakblocks") || getMeta("~keepblocks") ? !1 : !0, 
        args.scale_pages = getMeta("metaBook.dontscalepages") || getMeta("~=metaBook.dontscalepages") || getMeta("dontscalepages") ? !1 : !0, 
        args.dontsave = fdjt.DOM.Selector(".glossmark"), args;
    }
    function sizeCodexPage() {
        var page = mB.page, geom = getGeometry(page), page_height = geom.height, view_height = fdjtDOM.viewHeight(), page_width = geom.width, view_width = fdjtDOM.viewWidth(), page_hmargin = view_width - page_width, page_vmargin = view_height - page_height;
        50 !== page_hmargin ? (page.style.left = page_hmargin / 2 + "px", page.style.right = page_hmargin / 2 + "px") : page.style.left = page.style.right = "", 
        mB.fullheight = 80 > page_vmargin ? !0 : !1, mB.fullwidth = 80 > page_hmargin ? !0 : !1, 
        mB.fullwidth ? addClass(document.body, "_FULLWIDTH") : dropClass(document.body, "_FULLWIDTH"), 
        mB.fullheight ? addClass(document.body, "_FULLHEIGHT") : dropClass(document.body, "_FULLHEIGHT");
    }
    function scaleLayout(flag) {
        var cheaprule = mB.CSS.resizerule;
        if (flag === void 0 && (flag = !0), !(flag && hasClass(document.body, "_SCALEDLAYOUT") || !flag && !hasClass(document.body, "_SCALEDLAYOUT"))) {
            if (cheaprule && (cheaprule.style[fdjtDOM.transform] = "", cheaprule.style[fdjtDOM.transformOrigin] = "", 
            cheaprule.style.left = "", cheaprule.style.top = ""), !flag) return dropClass(document.body, "_SCALEDLAYOUT"), 
            sizeCodexPage(), void 0;
            sizeCodexPage();
            var layout = mB.layout, geom = getGeometry($ID("CODEXPAGE"), !1, !0), width = geom.width, height = geom.inner_height, lwidth = layout.width, lheight = layout.height, hscale = height / lheight, vscale = width / lwidth, scale = vscale > hscale ? hscale : vscale;
            if (!cheaprule) {
                var s = "#CODEXPAGE div.codexpage";
                mB.CSS.resizerule = cheaprule = fdjtDOM.addCSSRule(s + ", body._ANIMATE.mbPREVIEW " + s, "");
            }
            cheaprule.style[fdjtDOM.transformOrigin] = "left top", cheaprule.style[fdjtDOM.transform] = "scale(" + scale + "," + scale + ") translateZ(0)";
            var nwidth = lwidth * scale, nheight = lheight * scale;
            width > nwidth && (cheaprule.style.left = (width - nwidth) / 2 + "px"), height > nheight && (cheaprule.style.top = "0px");
            var n = mB.pagecount, spanwidth = $ID("METABOOKPAGEBAR").offsetWidth / n;
            1 > spanwidth && (spanwidth = 1), mB.CSS.pagespanrule ? mB.CSS.pagespanrule.style.width = spanwidth + "px" : mB.CSS.pagespanrule = fdjtDOM.addCSSRule("div.metabookpagespans > span", "width: " + spanwidth + "px;"), 
            addClass(document.body, "_SCALEDLAYOUT");
        }
    }
    function updatePageDisplay(pagenum, staticref, location, eltid) {
        var update_progress = !eltid;
        eltid || (eltid = "METABOOKCURPAGESPAN");
        var locoff, npages = mB.pagecount, staticmax = mB.layout.laststaticref, showpage_elt = $ID(eltid);
        if ("number" == typeof location) {
            var max_loc = mB.ends_at, pct = 100 * location / max_loc, prec = Math.round(Math.log(max_loc / 40) / Math.log(10)) - 2;
            0 > prec && (prec = 0), locoff = fdjtDOM("span.metabookloc#METABOOKLOCPCT", (0 === prec ? Math.floor(pct) : fdjtString.precString(pct, prec)) + "%"), 
            locoff.title = location + "/" + max_loc;
        } else locoff = fdjtDOM("span.metabookloc#METABOOKLOCPCT");
        showpage_elt && (showpage_elt.innerHTML = pagenum, showpage_elt.style.left = 100 * (pagenum - 1) / npages + "%");
        var pageno_text = fdjtDOM("span#METABOOKPAGENOTEXT.metabookpageno", pagenum, "/", npages);
        pageno_text.title = "select to change page number", fdjtDOM.replace("METABOOKPAGENOTEXT", pageno_text);
        var pageref_text = staticref && staticmax && fdjtDOM("span#METABOOKPAGEREFTEXT.metabookpageno", staticref + "(" + staticmax + ")");
        if (pageref_text && (pageref_text.title = "Reference page number (from some print version)", 
        fdjtDOM.replace("METABOOKPAGEREFTEXT", pageref_text)), fdjtDOM.replace("METABOOKLOCPCT", locoff), 
        locoff.title = (locoff.title || "") + (locoff.title ? "; " : "") + " select to change %", 
        update_progress) {
            var page_progress = $ID("METABOOKPAGEPROGRESS");
            page_progress && (page_progress.style.width = 100 * (pagenum - 1) / npages + "%");
        }
        if (update_progress) {
            var page = $ID("CODEXPAGE" + pagenum), topid = page && page.getAttribute("data-topid"), info = topid && mB.docinfo[topid];
            if (info) {
                for (var head1 = info.level ? info : info.head, head2 = head1 && head1.head, head3 = head2 && head2.head, range1 = getpagerange(head1), range2 = getpagerange(head2), range3 = getpagerange(head3); range3 && range2 && 1 >= range1.width; ) {
                    var nextspan = head3.head && getpagerange(head3.head);
                    if (!nextspan) break;
                    head1 = head2, head2 = head3, head3 = head3.head, range1 = range2, range2 = range3, 
                    range3 = nextspan;
                }
                var marker1 = $ID("METABOOKSECTMARKER1"), marker2 = $ID("METABOOKSECTMARKER2"), marker3 = $ID("METABOOKSECTMARKER3");
                range1 && range1.width ? (marker1.style.left = 100 * ((range1.start - 1) / npages) + "%", 
                marker1.style.width = 100 * (range1.width / npages) + "%", marker1.style.display = "block") : marker1.style.display = "none", 
                range2 && range2.width ? (marker2.style.left = 100 * ((range2.start - 1) / npages) + "%", 
                marker2.style.width = 100 * (range2.width / npages) + "%", marker2.style.display = "block") : marker2.style.display = "none", 
                range3 && range3.width ? (marker3.style.left = 100 * ((range3.start - 1) / npages) + "%", 
                marker3.style.width = 100 * (range3.width / npages) + "%", marker3.style.display = "block") : marker3.style.display = "none";
            }
        }
        var handlers = mB.UI.handlers[mB.ui];
        fdjtDOM.addListeners(locoff, handlers["#METABOOKLOCPCT"]), fdjtDOM.addListeners(pageno_text, handlers["#METABOOKPAGENOTEXT"]), 
        pageref_text && fdjtDOM.addListeners(pageref_text, handlers["#METABOOKPAGEREFTEXT"]);
    }
    function getpagerange(headinfo) {
        for (var nextinfo, scan = headinfo, result = {}; scan; ) {
            if (scan.next) {
                nextinfo = scan.next;
                break;
            }
            scan = scan.head;
        }
        var start_page = getPage(headinfo.frag, headinfo.starts_at);
        if (!start_page) return !1;
        if (result.start = parseInt(start_page.getAttribute("data-pagenum"), 10), nextinfo) {
            var end_page = getPage(nextinfo.frag, nextinfo.starts_at);
            end_page && (result.end = parseInt(end_page.getAttribute("data-pagenum"), 10));
        }
        return result.end || (result.end = mB.layout.pages.length + 1), result.width = result.end - result.start, 
        result;
    }
    function setupPagebar() {
        var layout = mB.layout, pages = layout.pages, i = 0, n = pages.length, pagemax = $ID("METABOOKGOTOPAGEMAX");
        pagemax && (pagemax.innerHTML = "" + n);
        var spanwidth = $ID("METABOOKPAGEBAR").offsetWidth / n;
        for (1 > spanwidth && (spanwidth = 1), mB.CSS.pagespanrule ? mB.CSS.pagespanrule.style.width = spanwidth + "px" : mB.CSS.pagespanrule = fdjtDOM.addCSSRule("div.metabookpagespan", "width: " + spanwidth + "px;"); n > i; ) {
            var page = pages[i], pageref = page.getAttribute("data-staticpageref");
            if (pageref) {
                var pagemap = layout.pagemap, pagerefmax = $ID("METABOOKGOTOPAGEREFMAX");
                pagerefmax && (pagerefmax.innerHTML = "" + pageref), pagemap || (layout.pagemap = pagemap = {}), 
                layout.laststaticref = pageref, pagemap[pageref] = page;
            }
            i++;
        }
        layout.laststaticref ? addClass(document.body, "mbPAGEREFS") : dropClass(document.body, "mbPAGEREFS");
    }
    function getDups(id) {
        if (id) {
            if ("string" == typeof id) {
                if (mB.layout && mB.layout.dups) {
                    var dups = mB.layout.dups, d = dups[id];
                    return d ? [ mbID(id) ].concat(d) : [ mbID(id) ];
                }
                return [ mbID(id) ];
            }
            return getDups(id.codexbaseid || id.id);
        }
        return !1;
    }
    function GoToPage(spec, caller, savestate, skiphist) {
        savestate === void 0 && (savestate = !0), mB.previewing && mB.stopPreview("GoToPage", !1), 
        dropClass(document.body, "mbSHOWHELP"), mB.clearGlossmark();
        var page = mB.layout && (mB.layout.getPage(spec) || mB.layout.getPage(1));
        if (page && page !== curpage) {
            var pagenum = parseInt(page.getAttribute("data-pagenum"), 10), dirclass = !1;
            if ("addgloss" === mB.mode && mB.setMode(!1, !1), savestate && mB.clearStateDialog(), 
            Trace.flips && fdjtLog("GoToPage/%s Flipping to %o (%d) for %o", caller, page, pagenum, spec), 
            curpage) if (mB.dontanimate || !hasClass(document.body, "_ANIMATE")) dropClass(curpage, "curpage"), 
            addClass(page, "curpage"); else {
                var curpagestring = curpage.getAttribute("data-pagenum"), curnum = parseInt(curpagestring, 10);
                dropClass(curpage, /\b(oldpage|newpage|onleft|onright)\b/g), dropClass(page, /\b(oldpage|newpage|onleft|onright)\b/g), 
                dirclass = curnum > pagenum ? "onleft" : "onright", dirclass && addClass(page, dirclass), 
                addClass(curpage, "oldpage"), addClass(page, "newpage");
                var lastpage = curpage;
                setTimeout(function() {
                    var whoops = mB.pages.getElementsByClassName("curpage");
                    whoops.length && dropClass(toArray(whoops), "curpage"), dropClass(lastpage, "curpage"), 
                    addClass(page, "curpage"), dropClass(page, "newpage"), dropClass(page, /\bon(right|left)\b/);
                }, 50), setTimeout(function() {
                    dropClass(lastpage, "oldpage");
                }, 500);
            } else {
                var curpages = mB.pages.getElementsByClassName("curpage");
                curpages.length && dropClass(toArray(curpages), "curpage"), addClass(page, "curpage");
            }
            if ("number" == typeof spec) {
                var locval = page.getAttribute("data-mbloc"), location = locval && parseInt(locval, 10);
                location && mB.setLocation(location);
            }
            var staticref = page.getAttribute("data-staticpageref");
            updatePageDisplay(pagenum, staticref, mB.location), curpage = page, mB.curpage = pagenum;
            var curnode = mbID(page.getAttribute("data-lastid")) || mbID(page.getAttribute("data-topid"));
            if (curnode && mB.setHead(curnode), savestate && (mB.point = curnode, mB.hudup || mB.mode || (mB.skimpoint = !1)), 
            savestate && page) {
                var loc = page.getAttribute("data-mbloc"), pageno = page.getAttribute("data-pagenum");
                mB.saveState({
                    location: atoi(loc, 10),
                    page: atoi(pageno, 10),
                    target: curnode && (curnode.getAttribute("data-baseid") || curnode.id)
                }, skiphist);
            }
            var glossed = fdjtDOM.$(".glossed", page);
            if (glossed) for (var addGlossmark = mB.UI.addGlossmark, i = 0, lim = glossed.length; lim > i; ) addGlossmark(glossed[i++]);
        }
    }
    function startPagePreview(spec, caller) {
        var page = spec.nodeType && getParent(spec, ".codexpage") || mB.layout.getPage(spec) || mB.layout.getPage(1);
        if ((Trace.preview || Trace.flips) && fdjtLog("startPagePreview for %o from %s", page, spec), 
        page) {
            var pagenum = parseInt(page.getAttribute("data-pagenum"), 10), pageloc = parseInt(page.getAttribute("data-mbloc"), 10);
            if (previewing !== page) {
                previewing && dropClass(previewing, "previewpage"), dropClass(getChildren(mB.pages, ".previewpage"), "previewpage"), 
                (Trace.flips || Trace.gestures) && fdjtLog("startPagePreview/%s to %o (%d) for %o", caller || "nocaller", page, pagenum, spec), 
                curpage && addClass(curpage, "hidepage"), addClass(page, "previewpage"), mB.previewing = previewing = page, 
                addClass(document.body, "mbPREVIEW");
                var staticref = page.getAttribute("data-staticpageref");
                updatePageDisplay(pagenum, staticref, pageloc, "METABOOKPRVPAGESPAN");
            }
        }
    }
    function stopPagePreview(caller, target) {
        var pagenum = parseInt(curpage.getAttribute("data-pagenum"), 10);
        (Trace.flips || Trace.gestures) && fdjtLog("stopPagePreview/%s from %o to %o (%d)", caller || "nocaller", previewing, curpage, pagenum);
        var newpage = !1;
        if (previewing) {
            if (target && target.nodeType ? (dropClass(curpage, "curpage"), dropClass(curpage, "hidepage"), 
            addClass(previewing, "curpage"), newpage = hasClass(target, "codexpage") ? target : getParent(target, ".codexpage")) : target ? (dropClass(curpage, "curpage"), 
            dropClass(curpage, "hidepage"), addClass(previewing, "curpage"), newpage = curpage) : (dropClass(previewing, "preview"), 
            dropClass(curpage, "hidepage")), dropClass(previewing, "previewpage"), dropClass(getChildren(mB.pages, ".previewpage"), "previewpage"), 
            mB.previewing = previewing = !1, dropClass(document.body, "mbPREVIEW"), dropClass(document.body, "mbPAGEPREVIEW"), 
            newpage) {
                var newnum = parseInt(newpage.getAttribute("data-pagenum"), 10), newloc = mB.getLocInfo(target);
                updatePageDisplay(newnum, newpage.getAttribute("data-staticpageref"), newloc && newloc.starts_at);
            } else updatePageDisplay(pagenum, curpage.getAttribute("data-staticpageref"), mB.location);
            "number" == typeof newpage && mB.GoToPage(newpage);
        }
    }
    function getPage(arg, location, layout) {
        layout || (layout = mB.layout);
        var node = arg && (arg.nodeType ? arg : "string" == typeof arg ? mbID(arg) : !1), page = node && getParent(node, ".codexpage");
        if (page && 0 > layout.pages.indexOf(page) && (page = !1), !location || !page) return page;
        var loc = parseInt(page.getAttribute("data-mbloc"), 10);
        if (loc === location) return page;
        var pages = layout.pages, npages = pages.length, i = page ? parseInt(page.getAttribute("data-pagenum"), 10) : 1;
        i--;
        for (var prev = page; npages > i; ) {
            var next = pages[i++];
            if (loc = parseInt(next.getAttribute("data-mbloc"), 10), "number" != typeof loc) return prev;
            if (loc === location) return next;
            if (loc > location) return prev;
            prev = next;
        }
        return page;
    }
    function loc2page(loc, layout) {
        for (var pages = layout.pages, n = pages.length - 1, i = n; i >= 0; ) {
            var page = pages[i], mbloc = page.getAttribute("data-mbloc");
            if (mbloc && (mbloc = parseInt(mbloc)), loc === mbloc) return page;
            if (!(mbloc > loc)) return i === n ? !1 : page[n + 1];
            i--;
        }
        return !1;
    }
    function refreshLayout(why, slice, skip) {
        var opts = {
            forced: !0
        };
        slice && (opts.timeslice = slice), skip && (opts.timeskip = skip), mB.Paginate(why || "refreshLayout", opts);
    }
    function syncLayout(why) {
        mB.Paginate(why, {
            forced: !0,
            timeslice: !1
        });
    }
    function checkLayout() {
        if (!mB.layout.running) {
            var geom = getGeometry($ID("CODEXPAGE"), !1, !0), height = geom.inner_height, width = geom.width;
            (mB.layout.height !== height || mB.layout.width !== width) && refreshLayout("checkLayout");
        }
    }
    function displaySync() {
        mB.pagecount && mB.curpage && mB.GoToPage(mB.curpage, "displaySync", !1);
    }
    var mB = metaBook, Trace = mB.Trace, Timeline = mB.Timeline, fdjtString = fdjt.String, fdjtState = fdjt.State, fdjtHash = fdjt.Hash, fdjtTime = fdjt.Time, fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtAsync = fdjt.Async, $ID = fdjt.ID, mbID = metaBook.ID, CodexLayout = fdjt.CodexLayout, getGeometry = fdjtDOM.getGeometry, getParent = fdjtDOM.getParent, getChildren = fdjtDOM.getChildren, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, toArray = fdjtDOM.toArray, textWidth = fdjtDOM.textWidth, hasContent = fdjtDOM.hasContent, isEmpty = fdjtString.isEmpty, secs2short = fdjtTime.secs2short, getLocal = fdjtState.getLocal, setLocal = fdjtState.setLocal, getMeta = fdjtDOM.getMeta, atoi = parseInt, layout_preview_interval = 2e3, layout_previewing = !1, layout_preview_next = !1, layout_waiting = !1;
    metaBook.layoutReady = layoutReady;
    var layout_next_report = !1, layout_report_interval = 500;
    metaBook.Paginate = Paginate, CodexLayout.prototype.onresize = function() {
        mB.bypage ? mB.Paginate("resize") : fdjt.DOM.adjustFonts(mB.content);
    }, mB.addConfig("layout", function(name, val) {
        mB.page_style = val, "bypage" === val ? mB.docinfo ? mB.bypage || (mB.bypage = !0, 
        mB.postconfig ? mB.postconfig.push(Paginate) : mB.Paginate("config")) : mB.bypage = !0 : (mB.layout ? (mB.layout.Revert(), 
        mB.layout = !1) : mB.layout && !mB.layout.done && (mB.layout.timer && (clearTimeout(mB.layout.timer), 
        mB.layout.timer = !1), mB.layout.Revert(), mB.layout = !1), mB.bypage = !1, mB.layout && (mB.layout.Revert(), 
        mB.layout = !1), dropClass(document.body, "_BYPAGE"), addClass(document.body, "_SCROLL"), 
        fdjt.DOM.adjustFonts(mB.content));
    }), mB.addConfig("bodysize", updateLayoutProperty), mB.addConfig("bodyfamily", updateLayoutProperty), 
    mB.addConfig("bodyspacing", updateLayoutProperty), mB.addConfig("textjustify", updateLayoutProperty), 
    metaBook.getLayoutID = getLayoutID, metaBook.layoutCached = layoutCached, metaBook.clearLayouts = clearLayouts, 
    CodexLayout.getLayoutArgs = getLayoutArgs, metaBook.sizeCodexPage = sizeCodexPage, 
    metaBook.scaleLayout = scaleLayout, metaBook.updatePageDisplay = updatePageDisplay, 
    metaBook.setupPagebar = setupPagebar, metaBook.getDups = getDups;
    var curpage = !1;
    metaBook.GoToPage = GoToPage;
    var previewing = !1;
    return metaBook.startPagePreview = startPagePreview, metaBook.stopPagePreview = stopPagePreview, 
    metaBook.getPage = getPage, metaBook.refreshLayout = refreshLayout, metaBook.syncLayout = syncLayout, 
    metaBook.displaySync = displaySync, Paginate;
}(), metaBook.HTML.searchbox = '<div class=\'query\'>\n  <input id="METABOOKSEARCHINPUT"\n         type="TEXT" class="autoprompt searchinput"\n         name="QTEXT" value="" isempty="yes" autocomplete="off"\n         onfocus="metaBook.UI.handlers.search_focus(event);"\n         onblur="metaBook.UI.handlers.search_blur(event);"\n         onkeydown="metaBook.UI.handlers.search_keydown(event);"\n         onkeyup="metaBook.UI.handlers.search_keyup(event);"\n         onkeypress="metaBook.UI.handlers.search_keypress(event);"\n         completeopts="anywhere cloud" enterchars=";" maxcomplete="45"\n         placeholder="type or tap tags or terms"\n         completions="METABOOKSEARCHCLOUD"\n         results="METABOOKSEARCHRESULTS"\n         info="METABOOKSEARCHINFO"/>\n  <img class="metabookclearsearch" alt="X" title="clear search"\n       src="{{bmg}}metabook/redx.svgz"\n       onerror="this.src=\'{{bmg}}metabook/redx64x64.png"/\'>\n</div>\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n\n', 
metaBook.HTML.addgloss = '<form action="https://glosses.bookhub.io/glosses"\n      ajaxaction="https://glosses.bookhub.io/glosses"\n      method="POST" target="addgloss"\n      accept-charset="utf-8">\n  <div class="messageoverlay">\n    <div class="saving">Saving...</div>\n    <div class="saved">Saved</div>\n  </div>\n  <div class="hidden">\n    <input type="HIDDEN" name="FRAG"/>\n    <input type="HIDDEN" name="WSNID"/>\n    <input type="HIDDEN" name="REFURI"/>\n    <input type="HIDDEN" name="DOCURI"/>\n    <input type="HIDDEN" name="SYNC"/>\n    <input type="HIDDEN" name="UUID"/>\n    <input type="HIDDEN" name="TAGLINE"/>\n    <input type="HIDDEN" name="LOCATION"/>\n    <input type="HIDDEN" name="LOCLEN"/>\n    <input type="HIDDEN" name="DOCTITLE"/>\n    <input type="HIDDEN" name="MYCOPYID"/>\n    <input type="HIDDEN" name="MAKER"/>\n    <input type="HIDDEN" name="RE"/>\n    <input type="HIDDEN" name="THREAD"/>\n    <input TYPE="HIDDEN" NAME="DETAIL" VALUE=""/>\n    <input TYPE="HIDDEN" NAME="EXCERPT" VALUE=""/>\n    <input TYPE="HIDDEN" NAME="EXOFF" VALUE=""/>\n    <!-- Force IE to send the form in UTF-8 -->\n    <input type="HIDDEN" name="IEHACK" VALUE="&#9760;"/>\n  </div>\n  <div class="response">\n    Responding to <span class="respmaker"></span>\n    <span class="respdate"></span> <span class="respnote"></span> \n    <span class="resptags"></span> <span class="resplinks"></span>\n  </div>\n  <div class="metabookglossformbody">\n    <div class="addglossmenu" data-touchable="img">\n      <img src="{{bmg}}metabook/upmenu.svgz"\n           onerror="this.src=\'{{bmg}}metabook/upmenu64x64.png\'"\n           class="button menutop" alt="upmenu"/>\n      <img src="{{bmg}}metabook/downmenu.svgz"\n           onerror="this.src=\'{{bmg}}metabook/downmenu64x64.png\'"\n           class="button menutop" alt="downmenu"/>\n      <img src="{{bmg}}metabook/holdmenu.svgz"\n           onerror="this.src=\'{{bmg}}metabook/holdmenu64x64.png\'"\n           class="button menutop" alt="holdmenu"/>\n      <img src="{{bmg}}metabook/gloss_save_titled.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_save_titled64x64.png\'"\n           title="save this gloss" class="button" alt="glosspush"\n           tabindex="2"/>\n      <img src="{{bmg}}metabook/gloss_save_titled.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_save_titled64x64.png\'"\n           title="update this gloss" class="button" alt="glossupdate"\n           tabindex="2"/>\n      <img src="{{bmg}}metabook/gloss_tag_titled.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_tag_titled64x64.png\'"\n           title="add tags" class="button" alt="addtag"\n           tabindex="3"/>\n      <img src="{{bmg}}metabook/gloss_attach_titled.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_attach_titled64x64.png\'"\n           title="attach files" class="button" alt="attach"\n           tabindex="4"/>\n      <img src="{{bmg}}metabook/gloss_share_titled.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_share_titled64x64.png\'"\n           title="add outlets/share this gloss" class="button" alt="addoutlet"\n           tabindex="6"/>\n      <img src="{{bmg}}metabook/gloss_respond_toptitle.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_respond_toptitle64x64.png\'"\n           title="respond to this gloss" class="button" alt="glossrespond"\n           tabindex="7"/>\n      <img src="{{bmg}}metabook/gloss_delete_titled.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_delete_titled64x64.png\'"\n           title="delete gloss" class="button" alt="glossdelete"\n           tabindex="9"/>\n      <img src="{{bmg}}metabook/gloss_cancel_titled.svgz"\n           onerror="this.src=\'{{bmg}}metabook/gloss_cancel_titled64x64.png\'"\n           title=" cancel gloss" class="button" alt="glosscancel"\n           tabindex="8"/>\n    </div>\n    <div class="textbox">\n      <textarea\n         name="NOTE"\n         placeholder="Use #tag or @share or to add tags or shares.  Markdown to format, Enter to save, Escape to cancel."\n         title="Add text (using markdown), using @share and #tag to add outlets and tags."\n         class="markdowninput"\n         wrap="virtual"\n         tabindex="0"></textarea>\n    </div>\n    <div class="glossetc">\n      <span class="glossexposure">\n        <span class="checkspan private" tabindex="5">\n          <input type="CHECKBOX" name="PRIVATE" value="yes"\n                 onchange="metaBook.UI.changeGlossPrivacy(event);"/>\n          <span class="checked"\n                title="this gloss won\'t be shared with my associated networks">\n            Private</span>\n          <span class="unchecked"\n                title="this gloss will be shared with my associated networks">\n            Shared</span>\n        </span>\n      </span>\n      <span class="glossdate"></span>\n      <span class="tags empty"></span>    \n      <span class="links empty"></span>\n      <span class="outlets empty"></span>\n      <span class="excerpt"></span>\n    </div>\n  </div>\n</form>\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n', 
metaBook.HTML.hud = '<div id="METABOOKHEAD">\n  <div id="METABOOKTOC" class="hudpanel"></div>\n  <div id="METABOOKSEARCH" class="searchbox hudpanel notags">\n    <!-- This content comes from searchbox.html -->\n  </div>\n  <div id="METABOOKNOTETEXT" class="hudpanel"\n       title="tap/click to jump to the note">\n    <!-- This displays the text for a "note" -->\n  </div>\n  <div id="METABOOKGLOSS" class="hudpanel">\n    <div class="editbar">\n      <span class="deletebutton">Delete</span>\n      <span class="deletebutton">Edit</span>\n      <span class="deletebutton">Reply</span>\n    </div>\n    <div id="METABOOKTARGETGLOSS">\n      <!-- This is generated on demand -->\n    </div>\n  </div>\n  <div id="METABOOKSOURCES" class="hudpanel metabooksources">\n    <img src="{{bmg}}metabook/sbookspeople.svgz"\n         onerror="this.src=\'{{bmg}}metabook/sbookspeople50x50.png\'"\n         class="button everyone selected"\n         alt="show all" title="show all glosses"/>\n  </div>\n  <div id="METABOOKADDGLOSS" class="metabookaddgloss hudpanel">\n  </div>\n  <div class="metabookglossform" id="METABOOKADDGLOSSPROTOTYPE">\n    <!-- This content comes from addgloss.html -->\n  </div>\n</div>\n<div id="METABOOKSKIMMER">\n  <div id="METABOOKSKIM"></div>\n</div>\n<div id="METABOOKTOPHELPCONTENT">\n  <div id="METABOOKSLICEHELP" class="hudpanel">\n    Press to see the context, tap to start skimming\n  </div>\n  <div id="METABOOKSEETHRUHELP" class="metabookhelp helpbox">\n    <p><span class="action">Release</span> to\n      <span class="result">return</span>.\n      <span class="notouch action">Press any key</span>\n      <span class="fortouch action">Tap anywhere else</span>\n      to <span class="result">settle</span> here.</p>\n  </div>\n  <div id="METABOOKPAGEBARHELP" class="metabookhelp helpbox">\n    <p><span class="action">Release</span>\n      <span class="fortouch action">or tap the text</span>\n      to <span class="result">settle</span> here.\n      <span class="action notouch">Press any key</span>\n      <span class="notouch">or</span>\n      <span class="notouch action">move the pointer away</span>\n      <span class="action fortouch">Move your finger away</span>\n      to <span class="result">return</span> to where you were.</p>\n  </div>\n  <div id="METABOOKPREVIEWHELP" class="helpbox">\n    <p>You\'re <em>previewing</em> a reference. <strong>Let go</strong>\n      to <em>go back</em> to the\n      reference, <strong class="fortouch">tap anywhere\n        else</strong> <strong class="notouch">tap any key</strong>\n      to <em>settle here</em>.</p>\n  </div>\n</div>\n</div>\n<div id="METABOOKHEART">\n  <div id="METABOOKRIBBON">\n    <div class="inputbox" ID="METABOOKADDTAGHOLDER">\n      <input TYPE="TEXT" NAME="TAG" VALUE=""\n             placeholder="Type or define a tag, with completion"\n             autocomplete="off"\n             ID="METABOOKADDTAGINPUT"/>\n    </div>\n    <div class="inputbox" ID="METABOOKADDSHAREHOLDER">\n      <input TYPE="TEXT" NAME="OUTLET" VALUE=""\n             placeholder="Type a group or individual name"\n             autocomplete="off"\n             ID="METABOOKADDSHAREINPUT"/>\n    </div>\n    <div class="resultinfo notags noresults" id="METABOOKSEARCHINFO">\n      <span class="noresults">No results</span>\n      <span class="noquery">\n        <span class="fortouch">Tap</span> <span class="notouch">Click</span>\n        tags or start typing to begin a search</span>\n      <span class="stats">\n        <span class="resultcount metabookshowsearch"></span>\n        <span class="refinecount metabookrefinesearch"></span>\n        <span class="showalltags metabookexpandsearch">all<br/>tags</span>\n      </span>\n      <span id="METABOOKSEARCHTAGS" class="qtags"></span>\n    </div>\n  </div>\n  <div id="METABOOKHEARTBODY"></div>\n</div>\n<div id="METABOOKHELPCONTENT">\n  <div id="METABOOKHELP" class="metabookhelp">\n    <!-- This is the help text for reading the book as a whole (it get\'s\n         displayed for help when there isn\'t an active reader mode) -->\n    <div id="METABOOKAPPHELP"></div>\n  </div>\n  <div id="METABOOKHUDHELP" class="helpbox"></div>\n  <div id="METABOOKKEYBOARDHELPBOX" class="closed">\n    <span class="keep" onclick="metaBook.keyboardHelp(true);">keep</span>\n    <span class="close" onclick="metaBook.keyboardHelp(false);">close</span>\n    <div id="METABOOKKEYBOARDHELP"></div>\n    <div class="checkspan">\n      <input TYPE="CHECKBOX" NAME="METABOOKKEYBOARDHELP" VALUE="yes"\n             CHECKED>\n      Show keyboard help\n    </div>\n  </div>\n  <div class="hudtip topcenter">\n    <span class="fortouch">Tap</span><span class="notouch">Click</span>\n    at the top of the page to see the &metaBook; <em>tools</em>\n  </div>\n  <div class="hudtip topleft" data-hudmode="toc">\n    <span class="nobreak"><span class="arrow">&#x2190;</span>navigate</span><br/>\n    <span class="nobreak">outline</span></div>\n  <div class="hudtip topright" data-hudmode="search">\n    <span class="nobreak"><span class="arrow">&#x2192;</span>search</span><br/>\n    for&nbsp;tags\n  </div>\n  <div class="hudtip leftmiddle">\n    back page\n  </div>\n  <div class="hudtip rightmiddle">\n    next page\n  </div>\n</div>\n<div id="METABOOKFOOT" data-xtouchable="span.metabookpagespan,span.metabookpageno,span.metabookloc,img.hudbutton">\n  <div id="METABOOKSHOWTEXT">\n    <span>\n      <span class="justreading">close tools</span>\n      <span class="stopskimming">stop skimming</span>\n      <span class="cancelgloss">cancel gloss</span>\n      <span class="cancelchanges">discard changes</span>\n    </span>\n  </div>\n  <div class="hudtip botcenter">\n    <span style="font-size: 200%; font-weight: bold; position: absolute; left: 2px; bottom: 2px;" class="arrow">\n      &#x2193;</span>\n    this bar shows where you are in the book;\n    <span class="fortouch">tap</span><span class="notouch">click</span>\n    to jump, press to skim, and <span class="fortouch">tap</span>\n      <span class="notouch">click</span> numeric indicators to change\n      them.\n  </div>\n  <div id="METABOOKPAGEBAR">\n    <div class="textfoot">\n      <div id="METABOOKLAYOUTADJUST">Updating layout</div>\n      <span id="METABOOKPAGEREFTEXT" class="metabookpageno"></span>\n      <span id="METABOOKPAGENOTEXT" class="metabookpageno">p/n</span>\n      <span class="metabookloc" id="METABOOKLOCPCT">??.??%</span>\n      <div id="METABOOKGOTOLOC" class="metabookgoto">\n        <span class="gototext">\n          <input type="text" name="GOTOLOC" value="" placeholder="loc"\n                 title="Enter a percent (<= 100) or an immediate location (> 100)"\n                 id="METABOOKLOCINPUT"\n                 onkeypress="metaBook.UI.goto_keypress(event);"/>%</span>\n      </div>\n      <div id="METABOOKGOTOPAGE" class="metabookgoto">\n        <span class="gototext">\n          <input type="text" name="GOTOPAGE" value=""\n                 id="METABOOKPAGEINPUT" placeholder="page#"\n                 onkeypress="metaBook.UI.goto_keypress(event);"/>/\n          <span id="METABOOKGOTOPAGEMAX"></span></span>\n      </div>\n      <div id="METABOOKGOTOREF" class="metabookgoto">\n        <span class="gototext">\n          <input type="text" name="GOTOREF" value=""\n                 id="METABOOKREFINPUT" placeholder="pg ref#"\n                 onkeypress="metaBook.UI.goto_keypress(event);"/>/\n          <span id="METABOOKGOTOPAGEREFMAX"></span></span>\n      </div>\n    </div>\n    <hr class="metabooklayoutindicator" id="METABOOKLAYOUTINDICATOR"/>\n    <div class="metabooksectmarker" id="METABOOKSECTMARKER1"></div>\n    <div class="metabooksectmarker" id="METABOOKSECTMARKER2"></div>\n    <div class="metabooksectmarker" id="METABOOKSECTMARKER3"></div>\n    <div class="metabookpagespan" id="METABOOKCURPAGESPAN"></div>\n    <div class="metabookpagespan" id="METABOOKPRVPAGESPAN"></div>\n  </div>\n  <img src="{{bmg}}metabook/allglosses.svgz"\n       onerror="this.src=\'{{bmg}}metabook/allglosses50x50.png\'"\n       alt="allglosses" title="show all glosses"\n       class="hudbutton hudmodebutton botright"\n       id="METABOOKALLGLOSSESBUTTON"\n       hudmode="allglosses"/>\n  <img src="{{bmg}}metabook/tagsearch.svgz"\n       onerror="this.src=\'{{bmg}}metabook/tagsearch50x50.png\'"\n       alt="searchresults" title="show searchresults"\n       class="hudbutton hudmodebutton botright"\n       hudmode="searchresults"/>\n  <img src="{{bmg}}metabook/tocicon.svgz"\n       onerror="this.src=\'{{bmg}}metabook/tocicon50x50.png\'"\n       alt="statictoc" title="show TOC"\n       class="hudbutton hudmodebutton botright"\n       hudmode="statictoc"/>\n  <img src="{{bmg}}metabook/gloss_save_titled.svgz"\n       onerror="this.src=\'{{bmg}}metabook/gloss_save_titled50x50.png\'"\n       alt="save gloss" title="save gloss"\n       class="hudbutton botright"/>\n  <img src="{{bmg}}metabook/help.svgz"\n       onerror="this.src=\'{{bmg}}metabook/help50x50.png\'"\n       alt="help" title="show contextual help"\n       class="hudbutton hudmodebutton botleft"\n       id="METABOOKHELPBUTTON"\n       hudmode="help"/>\n  <div class="hudtip botright" data-hudmode="toc">\n    <span class="nobreak">browse</span><br/>\n    <span class="nobreak">glosses<span class="arrow">&#x2192;</span></span></div>\n  <div class="hudtip botleft">\n    <span class="nobreak">toggle</span><br/>\n    <span class="nobreak"><span class="arrow">&#x2190;</span>help</span></div>\n</div>\n<div id="METABOOKAUDIO">\n  <audio id="METABOOKPAGEFORWARDAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/pageforward.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/pageforward.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKPAGEBACKWARDAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/pagebackward.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/pagebackward.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKSKIMFORWARDAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/skimforward.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/skimforward.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKSKIMBACKWARDAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/skimbackward.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/skimbackward.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKSKIMSTOPAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/skimstop.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/skimstop.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKTEXTSELECTAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/selecting.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/selecting.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKRAISEHUDAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/raisehud.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/raisehud.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKDROPHUDAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/drophud.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/drophud.ogg" type="audio/ogg"/>\n  </audio>\n  <audio id="METABOOKGLOSSEDAUDIO" volume="0.5" preload="auto">\n    <source src="{{bmg}}metabook/glossed.wav" type="audio/wave"/>\n    <source src="{{bmg}}metabook/glossed.ogg" type="audio/ogg"/>\n  </audio>\n</div>\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n -->\n', 
metaBook.HTML.heart = '<div id="METABOOKALLGLOSSES" class="metabookslice mbsyncslice hudpanel">\n  <!-- This is filled in on startup -->\n</div>\n<div id="METABOOKGLOSSDETAIL" class="hudpanel">\n  <!-- This displays detail text for a gloss -->\n</div>\n<div id="METABOOKASIDE" class="hudpanel">\n  <!-- This displays the text for an aside -->\n</div>\n<div id="METABOOKGLOSSEDITDETAIL" class="hudpanel">\n  <!-- This is for editing the detail text for a gloss -->\n  <textarea NAME="METABOOKDETAILTEXT" class="markdowninput"\n            ID="METABOOKDETAILTEXT">\n  </textarea>\n</div>\n<div id="METABOOKGLOSSATTACH" class="hudpanel"></div>\n<div id="METABOOKSEARCHCLOUD" class="completions cloud searchcloud"></div>\n<div id="METABOOKALLTAGS" class="completions searchcloud cloud noinput">\n</div>\n<div id="METABOOKSEARCHRESULTS" class="metabookslice mbsyncslice hudpanel"></div>\n<div id="METABOOKSHARECLOUD" class="hudpanel completions cloud showall"></div>\n<div id="METABOOKGLOSSCLOUD" class="hudpanel completions cloud showall">\n  <div class="nomatchmsg">(no matches)</div>\n</div>\n<div class="tabcontent flyleaftab hudpanel" id="METABOOKSTATICTOC"\n     data-touchable=".mbtoc"></div>\n<iframe name="METABOOKGLOSSCOMM" id="METABOOKGLOSSCOMM"\n        frameborder="0" scrolling="auto"\n        class="hudpanel tabcontent"></iframe>\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n', 
metaBook.HTML.attach = '<form id="METABOOKATTACHFORM" target="METABOOKGLOSSCOMM"\n      method="POST" enctype="multipart/form-data" accept-charset="utf-8"\n      action="https://glossdata.bookhub.io/1/attach"\n      class="link">\n  <table class="fdjtform"\n         onclick="fdjt.UI.CheckSpan.onclick(event);">\n    <input TYPE="HIDDEN" NAME="GLOSSID" VALUE="" id="METABOOKUPLOADGLOSSID"/>\n    <input TYPE="HIDDEN" NAME="ITEMID" VALUE="" id="METABOOKUPLOADITEMID"/>\n    <tr class="attachtype">\n      <th class="headcell">\n        Attach<img src="{{bmg}}metabook/gloss_attach.svgz"/></th>\n      <td>\n        <button id="METABOOKATTACHDELETE" NAME="ATTACH" VALUE="DELETE">\n          Delete</button>\n        <span class="checkspan ischecked mbaddlink"\n              title="Attach a link to this gloss">\n          <input type="RADIO" NAME="ATTACHTYPE" VALUE="link"\n                 onchange="metaBook.UI.changeAttachment(event);"\n                 CHECKED/>\n          Link</span>\n        <span class="checkspan mbupload"\n              title="Upload a file and attach it to this gloss">\n          <input type="RADIO" NAME="ATTACHTYPE" VALUE="upload"\n                 onchange="metaBook.UI.changeAttachment(event);"/>\n          File</span>\n        <span class="checkspan mbeditbody"\n              title="Create or edit a \'body\' for this gloss">\n          <input type="RADIO" NAME="ATTACHTYPE" VALUE="body"\n                 onchange="metaBook.UI.changeAttachment(event);"/>\n          Body</span>\n        <span class="checkspan mbcapture"\n              title="Attach audio or video recorded on this device">\n          <input type="RADIO" NAME="ATTACHTYPE" VALUE="capture"\n                 onchange="metaBook.UI.changeAttachment(event);"/>\n          Capture</span>\n      </td>\n      <th class="button">\n        <button id="METABOOKATTACHLINK" NAME="ATTACH" VALUE="LINK">\n          Link</button>\n        <button id="METABOOKUPLOADOK" NAME="ATTACH" VALUE="UPLOAD">\n          Save</button>\n        <button id="METABOOKUPLOADOK" NAME="ATTACH" VALUE="SAVE">\n          Save</button>\n        <button id="METABOOKATTACHLINK" NAME="ATTACH" VALUE="BODY">\n          Save</button>\n        <button id="METABOOKATTACHLINK" NAME="ATTACH" VALUE="DONE">\n          Done</button>\n        <button id="METABOOKATTACHCANCEL" VALUE="CANCEL">\n          Cancel</button></th>\n    </tr>\n    <tr class="title">\n      <th>Label</th>\n      <td colspan="2">\n        <INPUT TYPE="TEXT" NAME="TITLE" VALUE="" ID="METABOOKATTACHTITLE"\n               placeholder="a descriptive label"/></tr>\n    <tr class="checkspan uploadrights"\n        id="METABOOKUPLOADRIGHTS">\n      <th><input TYPE="CHECKBOX" NAME="FILEOKAY" VALUE="yes"/></th>\n      <td colspan="2">\n        I affirm that I have the right to use and share this\n        content according to the bookhub.io\n        <a href="https://www.bookhub.io/legalia/TOS/" target="_blank">\n          Terms of Service</a>.</td>\n    </tr>\n    <tr class="url">\n      <th>URL</th>\n      <td colspan="2">\n        <input TYPE="TEXT" NAME="URL" VALUE=""\n               ID="METABOOKATTACHURL" class="fdjturlinput"\n               placeholder="a URL to attach"/>\n      </td>\n    </tr>\n    <tr class="capturefile">\n      <th>Capture</th>\n      <td id="METABOOKCAPTUREFILE" class="nofile" colspan="2">\n	<button NAME="CAPTURE" VALUE="AUDIO">Audio</button>\n	<button NAME="CAPTURE" VALUE="VIDEO">Video</button>\n	<button NAME="CAPTURE" VALUE="IMAGE">Photo</button>\n    </td></tr>\n    <tr class="uploadfile">\n      <th>Upload<input TYPE="FILE" NAME="UPLOAD" ID="METABOOKFILEINPUT"/></th>\n      <td id="METABOOKATTACHFILE" class="nofile" colspan="2">\n        <span class="mbdragmessage">Drag a file here or click to browse</span>\n        <span class="mbmessage">Tap to find files or media</span>\n        <span class="mbfilename" id="METABOOKATTACHFILENAME"></span>\n    </td></tr>\n    <tbody class="glossbody" id="METABOOKGLOSSBODY">\n      <tr>\n        <td colspan="3"><textarea NAME="BODYTEXT" ID="METABOOKGLOSSBODYTEXT"></textarea></td>\n      </tr>\n    </tbody>\n  </table>\n</form>\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n', 
metaBook.HTML.help = '<h1><span class="metabooktogglehelp">Ok</span>Using &metaBook;</h1>\n\n<p><img src="{{bmg}}metabook/browser_edges.svgz"\n        onerror="this.src=\'{{bmg}}metabook/browser_edges32x32.png\'"\n        alt="top of browser" class="floatright"/>\n  <strong>Move by pages</strong>\n  <span class="fortouch">by swiping left or right</span>\n  <span class="notouch">using the Space or Backspace keys</span> or\n  <span class="fortouch">tapping</span> <span class="notouch">clicking</span>\n  on the left or right regions of the page.</p>\n<!--\n<p><img src="{{bmg}}metabook/browser_corners.svgz" \n        onerror="this.src=\'{{bmg}}metabook/browser_corners32x32.png\'"\n        alt="top of browser" class="floatright"/>\n  <strong>Open the <dfn>book tools</dfn></strong> by\n  <span class="fortouch">tapping</span>\n  <span class="notouch">clicking</span> at the top of the\n  page.  <strong>Navigate, search, or skim</strong> using the icons\n  in the corners of the page.</p>\n<p><strong>Show this and other help</strong> by\n  <span class="fortouch">tapping</span><span class="notouch">clicking</span>\n  the <img src="{{bmg}}metabook/help.svgz" alt="top of browser"\n  onerror="this.src=\'{{bmg}}metabook/help50x50.png\'" class="inline"/>\n  icon in the lower left corner of the page.</p>\n-->\n<p class="glossexample">\n  <strong style="color: blue;">Blue <dfn>gloss bars</dfn></strong> in\n  the right margin indicate glosses already overlaid on your\n  book.  <strong><span class="fortouch">Tap or drag\n  left</span> <span class="notouch">Click to the left</span></strong>\n  of the blue bar to see associated notes, tags, links, etc.</p>\n\n<p><strong>Add your own glosses</strong> by\ndouble <span class="fortouch">tapping</span>\n  <span class="notouch">clicking</span> on the content or pressing and\n  holding to select text.  <strong>Enter notes, tags, links,\n  etc</strong> in the <dfn>gloss box</dfn> appearing at the top of the\n  page. <strong>Drag <span class="fortouch">your finger</span>\n  <span class="notouch">the pointer</span></strong> to select adjust\n  the <span class="fdjtselected"><span class="fdjtselectstart">beginning</span>\n  and <span class="fdjtselectend">end</span></span> of highlighted\n  text.</p>\n\n<p class="helphelp">\n  <strong>Show this and other help</strong> by\n  <span class="fortouch">tapping</span><span class="notouch">clicking</span>\n  the <img src="{{bmg}}metabook/help.svgz" alt="top of browser"\n           onerror="this.src=\'{{bmg}}metabook/help50x50.png\'" class="inline"/>\n  icon in the lower left of the page.</p>\n\n<!--\n<p class="tightbottom">\n  <img src="{{bmg}}metabook/docs/pagebar_zoom.png" class="floatright"/>\n  <strong>Browse the book</strong> using the <dfn>pagebar</dfn> along\n  the bottom.  The dark blue line show the current location with\n  lighter regions around for the current section and its parent.\n  <img src="{{bmg}}metabook/docs/pagebar_wide.png" class="wideimage"/>\n  <img src="{{bmg}}metabook/docs/pagebar_wide.png"\n  class="narrowimage"/><br/>\n  <span class="subpara">\n    <span class="fortouch">Tap</span><span class="notouch">Click</span>\n    the page number (in the middle) or percentage (on the right) to move\n    precisely.  Press and hold the pagebar to see a particular page,\n    moving <span class="fortouch">your\n      finger</span> <span class="notouch">the pointer</span> to skim\n    through pages.  <span class="notouch">Release</span>\n    <span class="fortouch">Lift your finger</span> to settle where you\n    are or <span class="fortouch">move\n      it</span> <span class="notouch">drag the mouse</span> out of the\n    pagebar to return to where you were.</span></p>\n-->\n\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n', 
metaBook.HTML.hudhelp = '<div id="METABOOKADDGLOSSHELP" class="helpbox">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    Add your own gloss to a passage</h2>\n  <p><strong class="fortouch">Tap</strong>\n    <strong class="notouch">Click</strong>\n    or <strong><span class="fortouch">touch</span> \n      <span class="notouch">press</span> and drag</strong> the menu\n    button <img src="{{bmg}}metabook/downmenu.svgz"\n    onerror="this.src=\'{{bmg}}metabook/downmenu64x64.png"\n    class="inline" style="border: solid black 1px; padding: 0px;"/>\n    for more options (<strong>release</strong> to select).</p>\n  <p><img src="{{bmg}}metabook/remark.svgz"\n          onerror="this.src=\'{{bmg}}metabook/remark64x64.png" class="screengrab"\n          alt="the balloon icon"/> Type your comments in the input\n          box, ending with <kbd>Enter</kbd> and using\n    <kbd>Shift-Enter</kbd> to insert a newline.  Specify **bold** or\n    *italics* and other formatting using\n    <a href="http://daringfireball.net/projects/markdown/syntax"\n       target="_blank">\n      Markdown syntax</a>.</p>\n  <p><img src="{{bmg}}metabook/tagicon.svgz"\n          onerror="this.src=\'{{bmg}}metabook/tagicon64x64.png\'"\n          class="screengrab" alt="the tag icon"/>\n    <strong>Add simple tags</strong> as <tt>#tag</tt> or even\n    &ldquo;<tt>#compound tag</tt>,&rdquo; pressing <kbd>Enter</kbd>\n    when done.</p>\n  <p><strong><span class="fortouch">Tap</span> \n      <span class="notouch">Click</span> the passage</strong> to\n    show or hide the gloss form; press and drag the \n    <span class="fdjtselected"><span class="fdjtselectstart">ends</span>\n      of the <span class="fdjtselectend">highlight</span></span> to change\n    it.  <strong><span class="fortouch">Tap</span>\n      <span class="notouch">Click</span> anywhere else</strong> to close\n    the gloss (and save or discard your changes).</p>\n</div>\n<div id="METABOOKGLOSSATTACHHELP" class="helpbox">\n  <p><img src="{{bmg}}metabook/diaglink.svgz"\n          onerror="this.src=\'{{bmg}}metabook/diaglink64x64.png\'"\n          class="inline" alt="the link icon"/>\n    <strong>Add links</strong>\n    as <strong>[@</strong><em><tt>uri</tt></em>\n    <em>title</em><strong>]</strong>,\n    e.g. <strong>[@</strong><tt>http://www.whitehouse.gov/</tt>\n    The White House<strong>]</strong>.</p>\n</div>\n<div id="METABOOKGLOSSTAGHELP" class="helpbox">\n  <p><img src="{{bmg}}metabook/tagicon.svgz"\n          onerror="this.src=\'{{bmg}}metabook/tagicon64x64.png\'"\n          class="inline" alt="the tag icon"/>\n    Specify <strong>synonyms</strong> for your tags (e.g.\n    <span class="tagsample"><strong>[</strong>airplane|plane|aircraft<strong>]</strong></span>)\n    or describe <strong>relations</strong>\n    (e.g. <span class="tagsample">\n      <strong>[</strong>sloop|^sailboat|^boat<strong>]</strong></span>)\n    to make your tags <strong>more useful</strong> for browsing\n    and search by yourself or others.</p>\n</div>\n<div id="METABOOKSKIMTOCHELP" class="helpbox fdjtadjustfont">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    Skimming by sections</h2>\n  <p>You\'re <span>skimming</span> through your book based on the\n    chapters, sections, and subsections in the table of contents.</p>\n  <p class="fortouch">\n    <span>Swipe left or right with two fingers</span> to move forward\n    and backward by sections or use the\n    <img src="{{bmg}}metabook/skim_left.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_left100x100.png"\n    class="inline"/\'> and <img src="{{bmg}}metabook/skim_right.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_right100x100.png"\n    class="inline"/\'> arrows on the sides of the page. These also\n    indicate the number of sections in each direction.</p>\n  <p class="notouch">\n    Use the <span>arrow keys</span> to move forward and backward by\n    sections or use the <img src="{{bmg}}metabook/skim_left.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_left100x100.png"\n    class="inline"/> and <img src="{{bmg}}metabook/skim_right.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_right100x100.png"\n    class="inline"/> arrows on the sides of the page.  These also\n    indicate the number of sections in each direction.</p>\n  <p><span class="fortouch">Tap</span><span class="notouch">Click</span>\n    the book text to minimize the interface;\n    <span class="fortouch">tap</span><span class="notouch">click</span>\n    again to stop skimming altogether.</p>\n  <p>The <img src="{{bmg}}metabook/tocicon.svgz"\n              onerror="this.src=\'{{bmg}}metabook/tocicon50x50.png"\n              class="inline"> in\n              the lower right corner returns to the table of contents.\n              The <strong>overleaf</strong> at the top of the page\n              shows the current point in the table of\n              contents; <span class="fortouch">tap</span>\n    <span class="notouch">click</span> once to expand it and again to\n    return to the TOC.</p>\n</div>\n<div id="METABOOKSKIMSEARCHHELP" class="helpbox fdjtadjustfont">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    Skimming your search</h2>\n  <p>You\'re currently <span>skimming</span> through the results of\n    your search.  The current search result is shown in\n    the <strong>overleaf</strong> at the top of the page and the\n    matching text is highlighted in the body.</p>\n  <p class="fortouch">\n    <span>Swipe left or right with two fingers</span> to move to the\n    next (or previous) result or use the\n    <img src="{{bmg}}metabook/skim_left.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_left100x100.png"\n    class="inline"/\'> and <img src="{{bmg}}metabook/skim_right.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_right100x100.png"\n    class="inline"/\'> arrows on the sides of the page.  These also\n    indicate the number of search results in each direction.</p>\n  <p class="notouch">\n    Use the <span>arrow keys</span> to to the next or previous search\n    result or use the <img src="{{bmg}}metabook/skim_left.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_left100x100.png"\n    class="inline"/> and <img src="{{bmg}}metabook/skim_right.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_right100x100.png"\n    class="inline"/> arrows on the sides of the page.  These also\n    indicate the number of search results in each direction.</p>\n  <p><span class="fortouch">Tap</span><span class="notouch">Click</span>\n    the book text to minimize the interface;\n    <span class="fortouch">tap</span><span class="notouch">click</span>\n    again to stop skimming altogether.</p>\n  <p>The <img src="{{bmg}}metabook/tagsearch.svgz"\n              onerror="this.src=\'{{bmg}}metabook/tagsearch50x50.png"\n              class="inline">\n    icon in the lower right corner returns to the search results.\n    The <strong>overleaf</strong> at the top of the page\n    shows the result being\n    displayed; <span class="fortouch">tap</span>\n    <span class="notouch">click</span> it once to expand it and again\n    to return to the list of results.</p>\n</div>\n<div id="METABOOKSKIMGLOSSESHELP" class="helpbox fdjtadjustfont">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    Skimming Glosses</h2>\n  <p>You\'re <span>skimming</span> through your book based on the\n    glosses (highlights, notes, etc) which you or others have added.\n    The <strong>overleaf</strong> at the top of the page shows the\n    current gloss and the text itself shows any highlights.</p>\n  <p class="fortouch">\n    <span>Swipe left or right with two fingers</span> to move to the\n    next (or previous) gloss or use the\n    <img src="{{bmg}}metabook/skim_left.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_left100x100.png"\n    class="inline"/\'> and <img src="{{bmg}}metabook/skim_right.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_right100x100.png"\n    class="inline"/\'> arrows on the sides of the page.  These also\n    indicate the number of glosses in each direction.</p>\n  <p class="notouch">\n    Use the <span>arrow keys</span> to to the next or previous gloss\n    or use the <img src="{{bmg}}metabook/skim_left.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_left100x100.png"\n    class="inline"/> and <img src="{{bmg}}metabook/skim_right.svgz"\n    onerror="this.src=\'{{bmg}}metabook/skim_right100x100.png"\n    class="inline"/> arrows on the sides of the page.  These also\n    indicate the number of glosses in each direction.\n  </p>\n  <p><span class="fortouch">Tap</span><span class="notouch">Click</span>\n    the book text to minimize the interface;\n    <span class="fortouch">tap</span><span class="notouch">click</span>\n    again to stop skimming\n    altogether.</p>\n  <p>The <img src="{{bmg}}metabook/allglosses.svgz"\n              onerror="this.src=\'{{bmg}}metabook/allglosses50x50.png"\n              class="inline">\n              button in the lower right corner returns to the list of\n              glosses.  The <strong>overleaf</strong> at the top of\n              the page shows the gloss you\'re\n              seeing; <span class="fortouch">tap</span>\n    <span class="notouch">click</span> it once to expand it and again\n    to return to the list of results.</p>\n</div>\n<div id="METABOOKGOTOPAGEHELP" class="helpbox">\n  <p>Enter a page number at the top of the page to jump directly to that\n    page.<br/> Use the escape key or <span class="fortouch">tap</span>\n    <span class="notouch">click</span> at the bottom of the page to\n    cancel.</p>\n</div>\n<div id="METABOOKGOTOREFHELP" class="helpbox">\n  <p>Enter a reference page number (from the reference version of the\n    book) at the top of the page to jump to that part of the book.<br/>\n    Use the escape key or <span class="fortouch">tap</span>\n    <span class="notouch">click</span> at the bottom of the page to\n    cancel.</p>\n</div>\n<div id="METABOOKGOTOLOCHELP" class="helpbox">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    Got to a specific location</h2>\n  <p>Enter a numeric percentage (in the field at the top of the page)\n    to jump directly to that point within the book.<br/>  These\n    percentages will remain stable even as page layout or font size\n    changes.  Use the escape key or <span class="fortouch">tap</span>\n    <span class="notouch">click</span> at the bottom of the page to\n    cancel and return to the text.</p>\n</div>\n<div id="METABOOKSEARCHINPUTHELP" class="helpbox">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    Searching tags and text</h2>\n  <p>You are searching for passages or glosses within your book, using\n    either semantic <span class="dterm">tags</span> or\n    literal <span class="rawterm">terms</span>.  As you type or edit\n    the text in the search box, the cloud of tags and phrases will\n    grow or shrink to display matching phrases, tags, or tag\n    synonyms.</p>\n  <p><span class="fortouch">Tapping</span>\n    <span class="notouch">Clicking</span>\n    <span>a term or tag</span> adds it to the current search,\n    generating both new results and an updated cloud of associated\n    terms and tags.  Tags may be related to other tags (for\n    example, <span class="dterm">dachshund</span>\n    to <span class="dterm">dog</span>) and those relationships are\n    used in your search.</p>\n</div>\n<div id="METABOOKSEARCHRESULTSHELP" class="helpbox">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    Browsing search results</h2>\n  <p>The results of your search are ordered by relevance and position\n    within the book.  Refine or change your search by selecting one of\n    the tabs (\'co-tags\' or \'all tags\') above the\n    results<img src="/static/g/metabook/searchtabs.png"\n    class="screengrab"/> or by simply entering more text.  Co-tags are\n    tags which occur among the current search results; all tags are\n    all tags used throughout the book.</p>\n  <p class="notouch">Use <strong>the space and backspace keys</strong>\n    to move through the list of results page-by-page; <strong>combine\n    with the shift key</strong> or use the <strong>arrow keys</strong>\n    to move in larger increments. Use the <strong>percentage\n    indicator</strong> <img src="{{bmg}}/metabook/pagecontrol.png"\n    class="inlineright"/> to move page-by-page or to enter a specific\n    percentage (just click on the number).</p>\n  <p class="fortouch"><strong>Swipe left or right</strong> to move\n    page-by-page through the search results; <strong>swipe with two\n    fingers</strong> to move in larger increments.  Use\n    the <strong>percentage indicator</strong>\n    <img src="{{bmg}}/metabook/pagecontrol.png" class="inlineright"/>\n    to move page-by-page or to enter a specific percentage (just tap\n    on the number).</p>\n  <p><strong><span class="fortouch">Tap</span>\n    <span class="notouch">Click</span> a search result</strong> to\n    jump to that part of the book and begin <span>skimming</span>\n    through the search results starting at that point.</p>\n  <p><strong><span class="notouch">Hold the mouse button down\n      on</span><span class="fortouch">Press and hold</span> a\n      result</strong> to preview the result in in its context;\n      <strong>release</strong> to return to the list of results.</p>\n</div>\n<div id="METABOOKALLGLOSSESHELP" class="helpbox">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    All glosses</h2>\n  <p>These are <span>all of the glosses</span> applied to your\n    copy of this book.</p>\n  <p>The <strong>row of icons</strong> at the top of the screen show\n    the <span>creators or layers</span> where different glosses\n    originate. <span class="fortouch">Tap</span>\n    <span class="notouch">Click</span> the icons to just see glosses\n    from a single source or double <span class="fortouch">tap</span>\n    <span class="notouch">click</span> to add glosses from other\n    sources.</p>\n  <p class="notouch">The <strong>space and backspace keys</strong>\n    move through the list of glosses page-by-page; combine them with\n    the shift key or use the <strong>arrow keys</strong> to move in\n    larger increments. Use the <strong>percentage indicator</strong>\n    <img src="{{bmg}}/metabook/pagecontrol.png" class="inlineright"/>\n    to move page-by-page or to enter a specific percentage (just click\n    on the number).</p>\n  <p class="fortouch"><strong>Swipe left or right</strong> to move\n    page-by-page through the glosses; <strong>swipe with two\n    fingers</strong> to move in larger increments.  Use\n    the <strong>percentage indicator</strong>\n    <img src="{{bmg}}/metabook/pagecontrol.png" class="inlineright"/>\n    to move page-by-page or to enter a specific percentage (just tap\n    on the number).</p>\n  <p><span class="fortouch">Tap</span>\n    <span class="notouch">Click</span> a particular gloss to jump to\n    that part of the book and begin <span>skimming</span> through the\n    displayed glosses starting at that point.</p>\n  <p><span class="notouch">Hold the mouse button down\n      on</span><span class="fortouch">Press and hold</span> a a gloss\n      to see it in in context; <strong>release</strong> to return to the list of\n      glosses.</p>\n</div>\n<div id="METABOOKSTATICTOCHELP" class="helpbox">\n  <h2><span class="metabooktogglehelp">Ok</span>\n    The Table of Contents</h2>\n  <p>The <strong>table of contents</strong> (TOC) displays a\n    hierarchical map of your book created by the author or publisher.\n    Red lines indicate your current reading location; the\n    light-colored bars indicate the subsection\'s size and position\n    within its parent.</p>\n  <p class="notouch">Use <strong>the space and backspace keys</strong>\n    to move through the TOC page-by-page; <strong>combine with the\n    shift key</strong> or use the <strong>arrow keys</strong> to move\n    in larger increments. You can also use the <strong>percentage\n    indicator</strong> <img src="{{bmg}}/metabook/pagecontrol.png"\n    class="inlineright"/> to move page-by-page or enter a specific\n    percentage (just click on the number).</p>\n  <p class="fortouch"><strong>Swipe left or right</strong> to move\n    page-by-page through the TOC; <strong>swipe with two\n    fingers</strong> to move in larger increments.  You can also use\n    the <strong>percentage indicator</strong>\n    <img src="{{bmg}}/metabook/pagecontrol.png" class="inlineright"/>\n    to move forward or backward or to enter a specific percentage\n    (just tap on the number).</p>\n  <p><strong><span class="fortouch">Tap</span>\n    <span class="notouch">Click</span> a line</strong> in the TOC to\n    jump to that section.  You\'ll start <em>skimming</em> through the\n    table of contents while seeing the content of the book.</p>\n  <p><strong>\n      <span class="notouch">Hold the mouse button down\n        on</span><span class="fortouch">Press and hold</span> a TOC\n        line</strong> to preview the section without leaving the table\n        of contents.  <strong>Release</strong> to return to the TOC\n        listing.</p>\n</div>\n\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n', 
metaBook.HTML.menu = '<img src="{{bmg}}metabook/tocicon.svgz"\n     onerror="this.src=\'{{bmg}}metabook/tocicon50x50.png\'"\n     alt="toc" title="navigate sections"\n     class="hudbutton hudmodebutton topleft"\n     id="METABOOKTOCBUTTON"\n     hudmode="statictoc"/>\n<div id="METABOOKBREVET"\n     title="Open the meta layer for navigation, search, etc.">\n  &nbsp;</div>\n<div id="METABOOKCOVERTAB">\n  <img src="{{bmg}}metabook/mbsettings.svgz"\n       onerror="this.src=\'{{bmg}}metabook/mbsettings50x50.png\'"\n       alt="toc" title="book settings"\n       class="hudbutton hudmodebutton left"\n       id="METABOOKSETTINGSBUTTON"\n       hudmode="settings"/>\n  <div class="hudbutton" id="METABOOKSHOWCOVER">Cover</div>\n  <img src="{{bmg}}metabook/overlay.svgz"\n       onerror="this.src=\'{{bmg}}metabook/overlay50x50.png\'"\n       alt="toc" title="see book layers"\n       class="hudbutton hudmodebutton right"\n       id="METABOOKLAYERSBUTTON"\n       hudmode="layers"/>\n</div>\n<img src="{{bmg}}metabook/tagsearch.svgz"\n     onerror="this.src=\'{{bmg}}metabook/tagsearch50x50.png\'"\n     alt="search" title="search tags"\n     class="hudbutton hudmodebutton topright"\n     hudmode="search"/>\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n -->\n', 
metaBook.HTML.console = '<h1>metaBook Console</h1>\n<div class=\'message\' id=\'METABOOKCONSOLEMESSAGE\'></div>\n<div id="METABOOKCONSOLELOG" class=\'sbookmessagelog\'></div>\n<div id="METABOOKCONSOLEINPUT">\n  <span class="button" id="METABOOKCONSOLEBUTTON">run</span>\n  <textarea id="METABOOKCONSOLETEXTINPUT">\n  </textarea>\n</div>\n\n<!--\n/* Emacs local variables\n;;;  Local variables: ***\n;;;  compile-command: "cd ../..; make" ***\n;;;  indent-tabs-mode: nil ***\n;;;  End: ***\n*/\n-->\n\n', 
metaBook.HTML.messages = '<div class="startupmessage fdjtprogress" id="METABOOKSTARTUPSCAN">\n  <div class="indicator"></div>\n  <div class="message">\n    Scanning the book content for structure and metadata.</div>\n</div>\n<div class="startupmessage fdjtprogress" id="METABOOKSTARTUPTOC">\n  <div class="indicator"></div>\n  <div class="message">\n    Setting up tables of content for book navigation.</div>\n</div>\n<div class="startupmessage fdjtprogress" id="METABOOKSTARTUPKNO">\n  <div class="indicator"></div>\n  <div class="message">\n    Processing embedded or referenced knowledge bases.\n    <div id="METABOOKSTARTUPKNODETAILS"></div>\n  </div>\n</div>\n<div class="startupmessage fdjtprogress" id="METABOOKSTARTUPTAGGING">\n  <div class="indicator"></div>\n  <div class="message">Indexing with published tags.</div>\n</div>\n<div class="startupmessage fdjtprogress" id="METABOOKSTARTUPCLOUDS">\n  <div class="indicator"></div>\n  <div class="message">Setting up tag clouds for search and glossing.</div>\n</div>\n</div>\n<div class="startupmessage fdjtprogress" id="METABOOKNEWGLOSSES">\n  <div class="indicator"></div>\n  <div class="message">Applying your glosses to your book.</div>\n</div>\n<!--\n     /* Emacs local variables\n     ;;;  Local variables: ***\n     ;;;  compile-command: "cd ../..; make" ***\n     ;;;  End: ***\n     */\n  -->\n\n', 
metaBook.HTML.cover = '<div id="METABOOKCOVERMESSAGE" class="controls">\n  <div id="METABOOKOPENCOVER">\n    <span class="fortouch">Tap</span><span class="notouch">Click</span> to Open\n  </div>\n</div>\n<div id="METABOOKCOVERPAGE" class="flap"\n     style="position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto; overflow: hidden;">\n  <img src="{{coverimage|}}" alt="{{covertext|}}"\n       style="max-width: 95%; width: auto; height: 90%;"\n       id="METABOOKCOVERIMAGE"/>\n</div>\n<div id="METABOOKTITLE" class="flap"\n     style="position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto; overflow: hidden;">\n</div>\n<div id="METABOOKCREDITS" class="flap metabookcredits"\n     style="position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto; overflow: hidden;">\n</div>\n<div id="METABOOKBLURB" class="scrolling flap"\n     style="position: absolute; top: 50px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;">\n</div>\n<div id="METABOOKAPPHELP" class="metabookhelp scrolling flap"\n     style="position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;">\n  <h1><span class="adjustfont">Welcome to the &metaBook; web-based\n      e-reader</span></h1>\n  \n  <p>You\'re using &metaBook;, a web-based e-reader created to deepen\n    reading and engagement while connecting to networks of knowledge,\n    conversation, and commmunity.  &metaBook; aims to reclaim the\n    virtues of physical books for electronic books, making them\n    natural to navigate, annotate, search, and personalize.</p>\n  <div id="METABOOKCOVERHELP"></div>\n</div>\n<div id="METABOOKSETTINGS" class="scrolling flap"\n     style="position: absolute; top: 50px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;">\n</div>\n<div id="METABOOKCONSOLE" class="scrolling flap"\n     style="position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;">\n</div>\n<div id="METABOOKLAYERS" class="flap"\n     style="position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;">\n  <iframe name="BOOKHUBAPP" id="BOOKHUBAPP" frameborder="0" scrolling="auto"></iframe>\n</div>\n<div id="METABOOKLOGIN" class="flap"\n     style="position: absolute; top: 75px; left: 50px; right: 50px; width: auto; bottom: 100px; height: auto;">\n  <iframe name="BOOKHUBLOGIN" id="BOOKHUBLOGIN" frameborder="0" scrolling="auto"></iframe>\n</div>\n<div id="METABOOKCOVERCONTROLS" class="adjustfonts" \n     style="position: absolute; bottom: 40px; left: 50px; right: 50px; width: auto; height: 60px; top: auto; font-size: 0.8em; font-size: 1.5rem; font-size: 3vw;">\n  <span class="control" data-mode="coverpage" title="see the cover"\n        tabindex="1">\n    Cover</span>\n  <span class="control" data-mode="titlepage"\n        title="this book\'s title page and other information"\n        tabindex="2">\n    Title</span>\n  <span class="control" data-mode="creditspage"\n        title="Credits to people and organizations contributing to this book, including bibliographic information"\n        tabindex="3">\n    Credits</span>\n  <span class="control" data-mode="blurb"\n        title="learn more about this book and its background"\n        tabindex="4">\n    About</span>\n  <span class="control" data-mode="layers"\n        title="manage added layers of glosses for your sBook"\n        tabindex="5">\n    Layers</span>\n  <span class="control" data-mode="login"\n        title="login to bookhub.io"\n        tabindex="5">\n    Login</span>\n  <span class="control" data-mode="console"\n        title="the debugging console (advanced)"\n        tabindex="6">\n    Console</span>\n  <span class="control" data-mode="settings"\n        title="alter this e-reader\'s appearance and interactions"\n        tabindex="7">\n    Settings</span>\n  <span class="control" data-mode="help"\n        title="simple help for using metaBook"\n        tabindex="8">\n    Help</span>\n</div>\n<div class="userbox controls"\n     data-maxfont="120%" id="METABOOKUSERBOX">\n  <span class="bookplate">\n    <a href="https://www.bookhub.io/" target="_blank"\n       class="bookplate__bookref metabookref"\n       title="Learn more about the metaBook reader and bookhub.io" tabindex="9">\n      This book</a>\n    <span class="bookplate__text">is personalized for</span>\n    <a href="https://my.bookhub.io/profile/"\n       class="bookplate__username metabookusername"\n       title="Edit your profile, add social networks, etc"\n       target="_blank" tabindex="10">\n      you</a></span>\n</div>\n<div class="loginbox controls" data-maxfont="120%" \n     id="METABOOKLOGINBOX">\n  <div class="loginmessage">\n    Login to bookhub.io to read smarter</div>\n  <form action="https://auth.bookhub.io/"\n        onsubmit="metaBook.setMode(\'login\');"\n        target="BOOKHUBLOGIN">\n    <input TYPE="HIDDEN" NAME="FRESHLOGIN" VALUE="yes"/>\n    <input TYPE="HIDDEN" NAME="LOGINFORM" VALUE="yes"/>\n    <input TYPE="HIDDEN" NAME="REFURI" VALUE="" ID="BHLOGIN_REFURI"/>\n    <input TYPE="HIDDEN" NAME="DOCID" VALUE="" ID="BHLOGIN_DOCID"/>\n    <input TYPE="HIDDEN" NAME="BOOKORIGIN" VALUE="" ID="BHLOGIN_ORIGIN"/>\n    <input TYPE="HIDDEN" NAME="EMBEDDED" VALUE="yes"/>\n    <input TYPE="HIDDEN" NAME="RETURN_TO" VALUE="welcome"/>\n    <input TYPE="TEXT" NAME="LOGIN" VALUE=""\n           PLACEHOLDER="email/cell login"\n           ONKEYPRESS="fdjt.UI.submitOnEnter(event);"\n           AUTOCOMPLETE="off"\n           tabindex="9"/>\n    <span>or use</span>\n    <select NAME="AUTHORITY">\n      <option value="" selected="SELECTED">Using account</option>\n      <option value=":FACEBOOK">Facebook</option>\n      <option value=":TWITTER">Twitter</option>\n      <option value=":YAHOO">Yahoo!</option>\n      <option value=":GOOGLE">Google</option>\n      <option value=":GPLUS">Google+</option>\n      <option value=":LINKEDIN">Linked In</option>\n      <option value=":AMAZON">Amazon</option>\n      <option value=":PAYPAL">PayPal</option>\n    </select>\n    <button name="AUTHORITY" TABINDEX="11"\n            value=":FACEBOOK">\n      <img src="{{bmg}}metabook/facebook64x64.png" class="nosvg"\n           alt="Facebook" class="noautoscale"/>\n      <img src="{{bmg}}metabook/facebook.svgz" class="svg"\n           alt="Facebook" class="noautoscale"/>\n    </button>\n    <button NAME="AUTHORITY" TABINDEX="12"\n            VALUE=":TWITTER">\n      <img src="{{bmg}}metabook/twitter64x64.png"\n           alt="Twitter" title="login with Twitter"\n           class="nosvg"/>\n      <img src="{{bmg}}metabook/twitter.svgz"\n           alt="Twitter" title="login with Twitter"\n           class="svg"/>\n    </button>\n    <button NAME="AUTHORITY" TABINDEX="13"\n            VALUE="https://open.login.yahooapis.com/openid/op/auth">\n      <img src="{{bmg}}metabook/yahoo64x64.png" class="nosvg"\n           alt="Yahoo!" title="login using Yahoo!"/>\n      <img src="{{bmg}}metabook/yahoo.svgz" class="svg"\n           alt="Yahoo!" title="login using Yahoo!"/>\n    </button>\n    <button NAME="AUTHORITY" TABINDEX="14"\n            VALUE=":GOOGLE">\n      <img src="{{bmg}}metabook/google64x64.png"\n           alt="Google" title="login using your Google account"\n           class="nosvg"/>\n      <img src="{{bmg}}metabook/google.svgz"\n           alt="Google" title="login using your Google account"\n           class="svg"/>\n    </button>\n    <button NAME="AUTHORITY" TABINDEX="15"\n            VALUE=":GPLUS">\n      <img src="{{bmg}}metabook/googleplus64x64.png"\n           alt="Google" title="login using Google+"\n           class="nosvg"/>\n      <img src="{{bmg}}metabook/googleplus.svgz"\n           alt="Google" title="login using Google+"\n           class="svg"/>\n    </button>\n    <button NAME="AUTHORITY" VALUE=":LINKEDIN" TABINDEX="16">\n      <img src="{{bmg}}metabook/linkedin64x64.png"\n           alt="Linked In" title="login with Linked In"\n           class="nosvg"/>\n      <img src="{{bmg}}metabook/linkedin.svgz"\n           alt="Linked In" title="login with Linked In"\n           class="svg"/>\n    </button>\n    <button name="AUTHORITY" TABINDEX="17"\n            value=":AMAZON">\n      <img src="{{bmg}}metabook/amazon64x64.png"\n           alt="Amazon" title="login with your Amazon account"/>\n    </button>\n    <button name="AUTHORITY" TABINDEX="18"\n            value=":PAYPAL">\n      <img src="{{bmg}}metabook/paypalsquare64x64.png" class="nosvg"\n           alt="PayPal" title="login with PayPal"/>\n      <img src="{{bmg}}metabook/paypalsquare.svgz" class="svg"\n           alt="PayPal" title="login with PayPal"/>\n    </button>\n  </form>\n</div>\n\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n', 
metaBook.HTML.settings = '<form onsubmit="fdjt.UI.cancel(event); return false;" class="metabooksettings">\n  <h1 class="cf">\n    Settings\n    <span class="message" ID="METABOOKSETTINGSMESSAGE"></span></h1>\n  <div class="fontsizes body"\n       title="Set the font sizes used for the body text.">\n    <span class="label" id="METABOOKBODYSIZELABEL">\n      Body text<br/>\n      <button name="REFRESH" value="Layout"\n              id="METABOOKREFRESHLAYOUT">\n        <img src="{{bmg}}metabook/refresh.svgz" \n             onerror="this.src=\'{{bmg}}metabook/refresh50x50.png\'"\n             alt="Update">\n        Layout</button></span>\n    <span class="samples">\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="bodysize"\n               VALUE="xlarge"/>\n        <span class="sample xlarge">Aa</span></span>\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="bodysize" \n               VALUE="large"/>\n        <span class="sample large">Aa</span></span>\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="bodysize" \n               VALUE="normal"/>\n        <span class="sample normal">Aa</span></span>\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="bodysize" \n               VALUE="small"/>\n        <span class="sample small">Aa</span></span>\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="bodysize"\n               VALUE="tiny"/>\n        <span class="sample tiny">Aa</span></span>\n    </span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="contrast checkspans"\n       title="Select the contrast level for body text">\n    <span class="label smaller">Text Contrast</span>\n    <span class="checkspan highcontrast">\n      <input TYPE="RADIO" NAME="bodycontrast"\n             VALUE="high"/>\n      <span class="sample">High</span></span>\n    <span class="checkspan normalcontrast">\n      <input TYPE="RADIO" NAME="bodycontrast" \n             VALUE="medium"/>\n      <span class="sample">Normal</span></span>\n    <span class="checkspan lowcontrast">\n      <input TYPE="RADIO" NAME="bodycontrast"\n             VALUE="low"/>\n      <span class="sample">Low</span></span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="textlayout checkspans">\n    <span class="label smaller">Layout</span>\n    <span class="checkspans">\n      <span class="checkspan codex">\n        <input TYPE="RADIO" NAME="METABOOKLAYOUT"\n               VALUE="bypage"/>\n        by pages</span>\n      <span class="checkspan scrolling">\n        <input TYPE="RADIO" NAME="METABOOKLAYOUT" \n               VALUE="scrolling"/>\n        just scroll</span>\n      <span class="checkspan scrollio">\n        <input TYPE="RADIO" NAME="METABOOKLAYOUT"\n               VALUE="scrollio"/>\n        hybrid (<em>scrollio</em>)</span>\n    </span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="also checkspans">\n    <span class="label smaller">Other Options</span>\n    <span class="checkspan opendyslexical"\n          title="OpenDyslexic is a font designed to increase readability for readers with dyslexia">\n      <input TYPE="CHECKBOX" NAME="dyslexical" VALUE="yes"/>\n      <span class="checktext">Use OpenDyslexic font</span>\n      <a href="http://opendyslexic.org/"\n         title="The Open Dyslexic font site">(about)</a>\n    </span>\n    <span class="sep">//</span>\n    <span class="checkspan justify"\n          title="left/right justify paragraphs of body text">\n      <input TYPE="CHECKBOX" NAME="textjustify" VALUE="yes"/>\n      Justify paragraphs</span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="fontsizes device"\n       title="Set the font sizes used by the interface components of metaBook">\n    <span class="label">Application</span>\n    <span class="samples">\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="uisize" VALUE="large"/>\n        <span class="sample xlarge">Aa</span></span>\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="uisize" VALUE="normal"/>\n        <span class="sample normal">Aa</span></span>\n      <span class="checkspan">\n        <input TYPE="RADIO" NAME="uisize" VALUE="small"/>\n        <span class="sample small">Aa</span></span>\n    </span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="animation">\n    <span class="label smaller">Animate</span>\n    <span class="checkspan">\n      <input TYPE="CHECKBOX" NAME="animatecontent" VALUE="yes"/>\n      <span class="checktext">content (page flips, etc)</span></span>\n    <span class="checkspan">\n      <input TYPE="CHECKBOX" NAME="animatehud" VALUE="yes"/>\n      <span class="checktext">interface (overlays, controls, etc)</span></span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="header dataheader cf">\n    <button NAME="CLEARDATA" VALUE="ALL" class="clearoffline">Erase all</button>\n    <span class="label">Storage</span>\n  </div>\n  <div class="checkspan syncloc cf">\n    <button id="METABOOKRESETSYNC" name="SYNC" VALUE="RESET"\n            class="reset floatright"\n            title="Reset synchronized location information.">\n      <img src="{{bmg}}metabook/reset.svgz" \n           onerror="this.src=\'{{bmg}}metabook/reset50x50.png" alt=""/>\n      Reset</button>\n    <input TYPE="CHECKBOX" NAME="locsync" VALUE="yes"/>\n    <span class="checktext">\n      Sync your <strong>reading location</strong> with other devices</span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="checkspan saveglosses cf">\n    <button id="METABOOKREFRESHOFFLINE" class="refresh floatright"\n            title="Reload glosses and layers for this book from the cloud.">\n      <img src="{{bmg}}metabook/refresh.svgz" \n           onerror="this.error=\'{{bmg}}metabook/refresh50x50.png" alt=""/>\n      Reload</button>\n    <input TYPE="CHECKBOX" NAME="cacheglosses" VALUE="yes" CHECKED/>\n    <span class="checktext">\n      Save copies of <strong>glosses</strong>\n      and <strong>layers</strong> on this device</span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="checkspan showconsole cf">\n    <span class="label">Developer</span>\n    <input TYPE="CHECKBOX" NAME="showconsole" VALUE="yes"/>\n    <span class="checktext">Show the application console</span>\n  </div>\n  <div class="clearfloats"></div>\n  <div class="info" id="METABOOKINFOPANEL">\n    <span class="label">Info</span>\n    <p class="metabookrefinfo"></p>\n    <p class="metabooksourceinfo"></p>\n    <p class="metabookbuildinfo"></p>\n    <p class="metabookappinfo"></p>\n    <p class="metabookserverinfo"></p>\n  </div>\n  <div class="metabookcopyright">\n    <p class="metabookcopyrightinfo"></p>\n  </div>\n\n</form>\n\n<!--\n    /* Emacs local variables\n    ;;;  Local variables: ***\n    ;;;  compile-command: "cd ../..; make" ***\n    ;;;  indent-tabs-mode: nil ***\n    ;;;  End: ***\n    */\n  -->\n', 
metaBook.HTML.layoutwait = '<div id="METABOOKLAYOUTMESSAGE" class="fdjtprogress">\n  <div class="indicator"></div>\n  <div class="message"></div>\n</div>\n', 
fdjt.revision = "1.5-1578-ga4f947a", fdjt.buildhost = "dev.beingmeta.com", fdjt.buildtime = "Mon Apr 11 12:59:23 UTC 2016", 
fdjt.builduuid = "e1c9235f-b05d-4c74-b026-d7acb7dfa09e", fdjt.CodexLayout.sourcehash = "97270F93A03966AAAF053C82E5EB0AB59E5DD93B", 
Knodule.version = "v0.8-160-ga7c7916", metaBook.version = "v0.8-352-g233c1b1", metaBook.buildid = "f69a2f35-3086-4d9f-bd6e-992492785762", 
metaBook.buildtime = "Sat Apr 23 08:44:20 UTC 2016", metaBook.buildhost = "dev.beingmeta.com", 
"undefined" != typeof _metabook_suppressed && _metabook_suppressed || (metaBook.appInit(), 
document.addEventListener ? (document.addEventListener("load", metaBook.headReady), 
document.addEventListener("DOMContentLoaded", metaBook.bodyReady), window.onload = metaBook.domReady) : window.onload = function() {
    metaBook.Setup();
});
//@ sourceMappingURL=dist/metabook.min.js.map