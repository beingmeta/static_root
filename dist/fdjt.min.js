var fdjt = fdjt === void 0 ? {} : fdjt, fdjt_versions = fdjt_versions === void 0 ? [] : fdjt_versions || [];

(function() {
    "use strict";
    fdjt_versions.decl = function(name, num) {
        (!fdjt_versions[name] || num > fdjt_versions[name]) && (fdjt_versions[name] = num);
    }, Array.prototype.indexOf || (Array.prototype.indexOf = function(elt, i) {
        i || (i = 0);
        for (var len = this.length; len > i; ) {
            if (this[i] === elt) return i;
            i++;
        }
        return -1;
    }), Object.keys || (Object.keys = function(o) {
        if (o !== Object(o)) throw new TypeError("Object.keys called on non-object");
        var p, ret = [];
        for (p in o) Object.prototype.hasOwnProperty.call(o, p) && ret.push(p);
        return ret;
    }), String.prototype.trim || (String.prototype.trim = function() {
        var trimLeft = /^\s+/, trimRight = /\s+$/;
        return function() {
            return this.replace(trimLeft, "").replace(trimRight, "");
        };
    });
})(), function() {
    "use strict";
    function bind(fn, thisArg) {
        return function() {
            fn.apply(thisArg, arguments);
        };
    }
    function PromiseFillIn(fn) {
        if ("object" != typeof this) throw new TypeError('Use "new" to make Promises');
        if ("function" != typeof fn) throw new TypeError("not a function");
        this._state = null, this._value = null, this._deferreds = [], doResolve(fn, bind(resolve, this), bind(reject, this));
    }
    function handle(deferred) {
        var me = this;
        return null === this._state ? (this._deferreds.push(deferred), void 0) : (asap(function() {
            var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
            if (null === cb) return (me._state ? deferred.resolve : deferred.reject)(me._value), 
            void 0;
            var ret;
            try {
                ret = cb(me._value);
            } catch (e) {
                return deferred.reject(e), void 0;
            }
            deferred.resolve(ret);
        }), void 0);
    }
    function resolve(newValue) {
        try {
            if (newValue === this) throw new TypeError("A promise cannot be resolved with itself.");
            if (newValue && ("object" == typeof newValue || "function" == typeof newValue)) {
                var then = newValue.then;
                if ("function" == typeof then) return doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this)), 
                void 0;
            }
            this._state = !0, this._value = newValue, finale.call(this);
        } catch (e) {
            reject.call(this, e);
        }
    }
    function reject(newValue) {
        this._state = !1, this._value = newValue, finale.call(this);
    }
    function finale() {
        for (var i = 0, len = this._deferreds.length; len > i; i++) handle.call(this, this._deferreds[i]);
        this._deferreds = null;
    }
    function Handler(onFulfilled, onRejected, resolve, reject) {
        this.onFulfilled = "function" == typeof onFulfilled ? onFulfilled : null, this.onRejected = "function" == typeof onRejected ? onRejected : null, 
        this.resolve = resolve, this.reject = reject;
    }
    function doResolve(fn, onFulfilled, onRejected) {
        var done = !1;
        try {
            fn(function(value) {
                done || (done = !0, onFulfilled(value));
            }, function(reason) {
                done || (done = !0, onRejected(reason));
            });
        } catch (ex) {
            if (done) return;
            done = !0, onRejected(ex);
        }
    }
    var root;
    root = "object" == typeof window && window ? window : global;
    var asap = root.Promise && root.Promise.immediateFn || root.setImmediate || function(fn) {
        setTimeout(fn, 1);
    }, isArray = Array.isArray || function(value) {
        return "[object Array]" === Object.prototype.toString.call(value);
    };
    PromiseFillIn.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
    }, PromiseFillIn.prototype.then = function(onFulfilled, onRejected) {
        var me = this;
        return new PromiseFillIn(function(resolve, reject) {
            handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
        });
    }, PromiseFillIn.all = function() {
        var args = Array.prototype.slice.call(1 === arguments.length && isArray(arguments[0]) ? arguments[0] : arguments);
        return new PromiseFillIn(function(resolve, reject) {
            function res(i, val) {
                try {
                    if (val && ("object" == typeof val || "function" == typeof val)) {
                        var then = val.then;
                        if ("function" == typeof then) return then.call(val, function(val) {
                            res(i, val);
                        }, reject), void 0;
                    }
                    args[i] = val, 0 === --remaining && resolve(args);
                } catch (ex) {
                    reject(ex);
                }
            }
            if (0 === args.length) return resolve([]);
            for (var remaining = args.length, i = 0; args.length > i; i++) res(i, args[i]);
        });
    }, PromiseFillIn.resolve = function(value) {
        return value && "object" == typeof value && value.constructor === PromiseFillIn ? value : new PromiseFillIn(function(resolve) {
            resolve(value);
        });
    }, PromiseFillIn.reject = function(value) {
        return new PromiseFillIn(function(resolve, reject) {
            reject(value);
        });
    }, PromiseFillIn.race = function(values) {
        return new PromiseFillIn(function(resolve, reject) {
            for (var i = 0, len = values.length; len > i; i++) values[i].then(resolve, reject);
        });
    }, "undefined" != typeof module && module.exports ? module.exports = PromiseFillIn : root.Promise || (root.Promise = PromiseFillIn);
}(), fdjt.Async = fdjt.ASync = fdjt.async = function() {
    "use strict";
    function fdjtAsync(fn, args) {
        function async_call(resolve, reject) {
            function async_doit() {
                var value;
                try {
                    value = args ? fn.call(null, args) : fn(), resolve(value);
                } catch (ex) {
                    reject(ex);
                }
            }
            setTimeout(async_doit, 1);
        }
        return new Promise(async_call);
    }
    function getnow() {
        return new Date().getTime();
    }
    function timeslice(fcns, slice, space, stop, done, fail) {
        function slicefn() {
            for (var timelim = getnow() + slice, nextspace = !1; lim > i; ) {
                var fcn = fcns[i++];
                if (fcn) {
                    if ("number" == typeof fcn) {
                        nextspace = fcn;
                        break;
                    }
                    try {
                        fcn();
                    } catch (ex) {
                        fail(ex);
                    }
                    if (getnow() > timelim) break;
                }
            }
            !(lim > i) || stop && stop() ? (clearTimeout(timer), timer = !1, done(!1)) : timer = setTimeout(slicefn, nextspace || space);
        }
        var timer = !1;
        "number" != typeof slice && (slice = 100), "number" != typeof space && (space = 100);
        var i = 0, lim = fcns.length;
        return slicefn();
    }
    function timeslice_method(fcns, opts) {
        function timeslicing(success, failure) {
            timeslice(fcns, slice, space, stop, success, failure);
        }
        opts || (opts = {});
        var slice = opts.slice || 100, space = opts.space || 100, stop = opts.stop || !1;
        return new Promise(timeslicing);
    }
    function slowmap(fn, vec, watch, done, failed, slice, space, onerr, watch_slice) {
        function slowmap_stepfn() {
            try {
                var started = getnow(), now = started, stopat = started + slice;
                for (watch && watch(0 === i ? "start" : "resume", i, lim, chunks, used, zerostart); lim > i && stopat > (now = getnow()); ) {
                    var elt = vec[i];
                    watch && (watch_slice && 0 === i % watch_slice || i + 1 === lim) && watch("element", i, lim, elt, used, now - zerostart);
                    try {
                        fn(elt);
                    } catch (ex) {
                        var exdata = {
                            elt: elt,
                            i: i,
                            lim: lim,
                            vec: vec
                        };
                        if (onerr && onerr(ex, elt, exdata)) continue;
                        if (failed) return failed(ex);
                        throw ex;
                    }
                    watch && (watch_slice && 0 === i % watch_slice || i + 1 === lim) && watch("after", i, lim, elt, used + (getnow() - started), zerostart, getnow() - now), 
                    i++;
                }
                if (chunks += 1, lim > i) used += now - started, watch && watch("suspend", i, lim, chunks, used, zerostart), 
                timer = setTimeout(slowmap_stepfn, space); else {
                    now = getnow(), used += now - started, clearTimeout(timer), timer = !1, watch && watch("finishing", i, lim, chunks, used, zerostart);
                    var donetime = done && getnow() - now;
                    now = getnow(), used += now - started, watch && watch("done", i, lim, chunks, used, zerostart, donetime), 
                    done && done.call && done(vec, now - zerostart, used);
                }
            } catch (ex) {
                failed && failed(ex);
            }
        }
        var i = 0, lim = vec.length, chunks = 0, used = 0, zerostart = getnow(), timer = !1;
        slice || (slice = 100), space || (space = slice), watch_slice || (watch_slice = 0), 
        timer = setTimeout(slowmap_stepfn, space);
    }
    function slowmap_handler(fcn, vec, opts) {
        function slowmapping(resolve, reject) {
            if (sync) {
                for (var i = 0, lim = vec.length; lim > i; ) {
                    var elt = vec[i++];
                    try {
                        fcn(vec[elt]);
                    } catch (ex) {
                        var exdata = {
                            elt: elt,
                            i: i,
                            lim: lim,
                            vec: vec
                        };
                        if (onerr && onerr(ex, elt, exdata)) continue;
                        if (reject) return reject(ex);
                        throw ex;
                    }
                }
                resolve && resolve(vec);
            } else slowmap(fcn, vec, watchfn, donefn ? function() {
                donefn(), resolve && resolve(vec);
            } : resolve, reject, slice, space, onerr, watch_slice);
        }
        opts || (opts = {});
        var slice = opts.slice, space = opts.space, onerr = opts.onerr, watchfn = opts.watchfn, watch_slice = opts.watch, sync = opts.hasOwnProperty("sync") ? opts.sync : opts.hasOwnProperty("async") ? !opts.async : !1, donefn = opts.done;
        return 1 > watch_slice && (watch_slice = vec.length * watch_slice), new Promise(slowmapping);
    }
    function debounce(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this, args = arguments, later = function() {
                timeout = null, immediate || func.apply(context, args);
            }, callNow = immediate && !timeout;
            clearTimeout(timeout), timeout = setTimeout(later, wait), callNow && func.apply(context, args);
        };
    }
    function poll(fn, callback, errback, timeout, interval) {
        var endTime = Number(new Date()) + (timeout || 2e3);
        interval = interval || 100, function p() {
            fn() ? callback() : endTime > Number(new Date()) ? setTimeout(p, interval) : errback(Error("timed out for " + fn + ": " + arguments));
        }();
    }
    function once(fn, context) {
        var result;
        return function() {
            return fn && (result = fn.apply(context || this, arguments), fn = null), result;
        };
    }
    return fdjtAsync.timeslice = timeslice_method, fdjtAsync.slowmap = slowmap_handler, 
    fdjtAsync.debounce = debounce, fdjtAsync.poll = poll, fdjtAsync.once = once, fdjtAsync;
}(), function(self) {
    "use strict";
    function normalizeName(name) {
        if ("string" != typeof name && (name += ""), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) throw new TypeError("Invalid character in header field name");
        return name.toLowerCase();
    }
    function normalizeValue(value) {
        return "string" != typeof value && (value += ""), value;
    }
    function Headers(headers) {
        this.map = {}, headers instanceof Headers ? headers.forEach(function(value, name) {
            this.append(name, value);
        }, this) : headers && Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
        }, this);
    }
    function consumed(body) {
        return body.bodyUsed ? Promise.reject(new TypeError("Already read")) : (body.bodyUsed = !0, 
        void 0);
    }
    function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
            reader.onload = function() {
                resolve(reader.result);
            }, reader.onerror = function() {
                reject(reader.error);
            };
        });
    }
    function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        return reader.readAsArrayBuffer(blob), fileReaderReady(reader);
    }
    function readBlobAsText(blob) {
        var reader = new FileReader();
        return reader.readAsText(blob), fileReaderReady(reader);
    }
    function Body() {
        return this.bodyUsed = !1, this._initBody = function(body) {
            if (this._bodyInit = body, "string" == typeof body) this._bodyText = body; else if (support.blob && Blob.prototype.isPrototypeOf(body)) this._bodyBlob = body; else if (support.formData && FormData.prototype.isPrototypeOf(body)) this._bodyFormData = body; else if (body) {
                if (!support.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(body)) throw Error("unsupported BodyInit type");
            } else this._bodyText = "";
        }, support.blob ? (this.blob = function() {
            var rejected = consumed(this);
            if (rejected) return rejected;
            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
            if (this._bodyFormData) throw Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([ this._bodyText ]));
        }, this.arrayBuffer = function() {
            return this.blob().then(readBlobAsArrayBuffer);
        }, this.text = function() {
            var rejected = consumed(this);
            if (rejected) return rejected;
            if (this._bodyBlob) return readBlobAsText(this._bodyBlob);
            if (this._bodyFormData) throw Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
        }) : this.text = function() {
            var rejected = consumed(this);
            return rejected ? rejected : Promise.resolve(this._bodyText);
        }, support.formData && (this.formData = function() {
            return this.text().then(decode);
        }), this.json = function() {
            return this.text().then(JSON.parse);
        }, this;
    }
    function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
    }
    function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (Request.prototype.isPrototypeOf(input)) {
            if (input.bodyUsed) throw new TypeError("Already read");
            this.url = input.url, this.credentials = input.credentials, options.headers || (this.headers = new Headers(input.headers)), 
            this.method = input.method, this.mode = input.mode, body || (body = input._bodyInit, 
            input.bodyUsed = !0);
        } else this.url = input;
        if (this.credentials = options.credentials || this.credentials || "omit", (options.headers || !this.headers) && (this.headers = new Headers(options.headers)), 
        this.method = normalizeMethod(options.method || this.method || "GET"), this.mode = options.mode || this.mode || null, 
        this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && body) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(body);
    }
    function decode(body) {
        var form = new FormData();
        return body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
                var split = bytes.split("="), name = split.shift().replace(/\+/g, " "), value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
        }), form;
    }
    function headers(xhr) {
        var head = new Headers(), pairs = xhr.getAllResponseHeaders().trim().split("\n");
        return pairs.forEach(function(header) {
            var split = header.trim().split(":"), key = split.shift().trim(), value = split.join(":").trim();
            head.append(key, value);
        }), head;
    }
    function Response(bodyInit, options) {
        options || (options = {}), this._initBody(bodyInit), this.type = "default", this.status = options.status, 
        this.ok = this.status >= 200 && 300 > this.status, this.statusText = options.statusText, 
        this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers), 
        this.url = options.url || "";
    }
    if (!self.fetch) {
        Headers.prototype.append = function(name, value) {
            name = normalizeName(name), value = normalizeValue(value);
            var list = this.map[name];
            list || (list = [], this.map[name] = list), list.push(value);
        }, Headers.prototype["delete"] = function(name) {
            delete this.map[normalizeName(name)];
        }, Headers.prototype.get = function(name) {
            var values = this.map[normalizeName(name)];
            return values ? values[0] : null;
        }, Headers.prototype.getAll = function(name) {
            return this.map[normalizeName(name)] || [];
        }, Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
        }, Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = [ normalizeValue(value) ];
        }, Headers.prototype.forEach = function(callback, thisArg) {
            Object.getOwnPropertyNames(this.map).forEach(function(name) {
                this.map[name].forEach(function(value) {
                    callback.call(thisArg, value, name, this);
                }, this);
            }, this);
        };
        var support = {
            blob: "FileReader" in self && "Blob" in self && function() {
                try {
                    return new Blob(), !0;
                } catch (e) {
                    return !1;
                }
            }(),
            formData: "FormData" in self,
            arrayBuffer: "ArrayBuffer" in self
        }, methods = [ "DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT" ];
        Request.prototype.clone = function() {
            return new Request(this);
        }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
            });
        }, Response.error = function() {
            var response = new Response(null, {
                status: 0,
                statusText: ""
            });
            return response.type = "error", response;
        };
        var redirectStatuses = [ 301, 302, 303, 307, 308 ];
        Response.redirect = function(url, status) {
            if (-1 === redirectStatuses.indexOf(status)) throw new RangeError("Invalid status code");
            return new Response(null, {
                status: status,
                headers: {
                    location: url
                }
            });
        }, self.Headers = Headers, self.Request = Request, self.Response = Response, self.fetch = function(input, init) {
            return new Promise(function(resolve, reject) {
                function responseURL() {
                    return "responseURL" in xhr ? xhr.responseURL : /^X-Request-URL:/m.test(xhr.getAllResponseHeaders()) ? xhr.getResponseHeader("X-Request-URL") : void 0;
                }
                var request;
                request = Request.prototype.isPrototypeOf(input) && !init ? input : new Request(input, init);
                var xhr = new XMLHttpRequest();
                xhr.onload = function() {
                    var status = 1223 === xhr.status ? 204 : xhr.status;
                    if (100 > status || status > 599) return reject(new TypeError("Network request failed")), 
                    void 0;
                    var options = {
                        status: status,
                        statusText: xhr.statusText,
                        headers: headers(xhr),
                        url: responseURL()
                    }, body = "response" in xhr ? xhr.response : xhr.responseText;
                    resolve(new Response(body, options));
                }, xhr.onerror = function() {
                    reject(new TypeError("Network request failed"));
                }, xhr.open(request.method, request.url, !0), "include" === request.credentials && (xhr.withCredentials = !0), 
                "responseType" in xhr && support.blob && (xhr.responseType = "blob"), request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                }).xhr.send(request._bodyInit === void 0 ? null : request._bodyInit);
            });
        }, self.fetch.polyfill = !0;
    }
}(self || window || this);

var idbModules = {};

(function(idbModules) {
    function callback(fn, context, event, func) {
        event.target = context, "function" == typeof context[fn] && context[fn].apply(context, [ event ]), 
        "function" == typeof func && func();
    }
    function throwDOMException(name, message, error) {
        var e = new DOMException.constructor(0, message);
        throw e.name = name, e.message = message, e.stack = arguments.callee.caller, idbModules.DEBUG && console.log(name, message, error, e), 
        e;
    }
    var StringList = function() {
        this.length = 0, this._items = [];
    };
    StringList.prototype = {
        contains: function(str) {
            return -1 !== this._items.indexOf(str);
        },
        item: function(key) {
            return this._items[key];
        },
        indexOf: function(str) {
            return this._items.indexOf(str);
        },
        push: function(item) {
            this._items.push(item), this.length += 1;
        },
        splice: function() {
            this._items.splice.apply(this._items, arguments), this.length = this._items.length;
        }
    }, idbModules.util = {
        throwDOMException: throwDOMException,
        callback: callback,
        quote: function(arg) {
            return "'" + arg + "'";
        },
        StringList: StringList
    };
})(idbModules), function(idbModules) {
    var Sca = function() {
        return {
            encode: function(val) {
                return JSON.stringify(val);
            },
            decode: function(val) {
                return JSON.parse(val);
            }
        };
    }();
    idbModules.Sca = Sca;
}(idbModules), function(idbModules) {
    var collations = [ "", "number", "string", "boolean", "object", "undefined" ], getGenericEncoder = function() {
        return {
            encode: function(key) {
                return collations.indexOf(typeof key) + "-" + JSON.stringify(key);
            },
            decode: function(key) {
                return key === void 0 ? void 0 : JSON.parse(key.substring(2));
            }
        };
    }, types = {
        number: getGenericEncoder("number"),
        "boolean": getGenericEncoder(),
        object: getGenericEncoder(),
        string: {
            encode: function(key) {
                return collations.indexOf("string") + "-" + key;
            },
            decode: function(key) {
                return "" + key.substring(2);
            }
        },
        undefined: {
            encode: function() {
                return collations.indexOf("undefined") + "-undefined";
            },
            decode: function() {
                return void 0;
            }
        }
    }, Key = function() {
        return {
            encode: function(key) {
                return types[typeof key].encode(key);
            },
            decode: function(key) {
                return types[collations[key.substring(0, 1)]].decode(key);
            }
        };
    }();
    idbModules.Key = Key;
}(idbModules), function(idbModules) {
    var Event = function(type, debug) {
        return {
            type: type,
            debug: debug,
            bubbles: !1,
            cancelable: !1,
            eventPhase: 0,
            timeStamp: new Date()
        };
    };
    idbModules.Event = Event;
}(idbModules), function(idbModules) {
    var IDBRequest = function() {
        this.onsuccess = this.onerror = this.result = this.error = this.source = this.transaction = null, 
        this.readyState = "pending";
    }, IDBOpenRequest = function() {
        this.onblocked = this.onupgradeneeded = null;
    };
    IDBOpenRequest.prototype = IDBRequest, idbModules.IDBRequest = IDBRequest, idbModules.IDBOpenRequest = IDBOpenRequest;
}(idbModules), function(idbModules, undefined) {
    var IDBKeyRange = function(lower, upper, lowerOpen, upperOpen) {
        this.lower = lower, this.upper = upper, this.lowerOpen = lowerOpen, this.upperOpen = upperOpen;
    };
    IDBKeyRange.only = function(value) {
        return new IDBKeyRange(value, value, !0, !0);
    }, IDBKeyRange.lowerBound = function(value, open) {
        return new IDBKeyRange(value, undefined, open, undefined);
    }, IDBKeyRange.upperBound = function(value) {
        return new IDBKeyRange(undefined, value, undefined, open);
    }, IDBKeyRange.bound = function(lower, upper, lowerOpen, upperOpen) {
        return new IDBKeyRange(lower, upper, lowerOpen, upperOpen);
    }, idbModules.IDBKeyRange = IDBKeyRange;
}(idbModules), function(idbModules, undefined) {
    function IDBCursor(range, direction, idbObjectStore, cursorRequest, keyColumnName, valueColumnName) {
        this.__range = range, this.source = this.__idbObjectStore = idbObjectStore, this.__req = cursorRequest, 
        this.key = undefined, this.direction = direction, this.__keyColumnName = keyColumnName, 
        this.__valueColumnName = valueColumnName, this.source.transaction.__active || idbModules.util.throwDOMException("TransactionInactiveError - The transaction this IDBObjectStore belongs to is not active."), 
        this.__offset = -1, this.__lastKeyContinued = undefined, this["continue"]();
    }
    IDBCursor.prototype.__find = function(key, tx, success, error) {
        var me = this, sql = [ "SELECT * FROM ", idbModules.util.quote(me.__idbObjectStore.name) ], sqlValues = [];
        sql.push("WHERE ", me.__keyColumnName, " NOT NULL"), me.__range && (me.__range.lower || me.__range.upper) && (sql.push("AND"), 
        me.__range.lower && (sql.push(me.__keyColumnName + (me.__range.lowerOpen ? " >=" : " >") + " ?"), 
        sqlValues.push(idbModules.Key.encode(me.__range.lower))), me.__range.lower && me.__range.upper && sql.push("AND"), 
        me.__range.upper && (sql.push(me.__keyColumnName + (me.__range.upperOpen ? " <= " : " < ") + " ?"), 
        sqlValues.push(idbModules.Key.encode(me.__range.upper)))), key !== undefined && (me.__lastKeyContinued = key, 
        me.__offset = 0), me.__lastKeyContinued !== undefined && (sql.push("AND " + me.__keyColumnName + " >= ?"), 
        sqlValues.push(idbModules.Key.encode(me.__lastKeyContinued))), sql.push("ORDER BY ", me.__keyColumnName), 
        sql.push("LIMIT 1 OFFSET " + me.__offset), idbModules.DEBUG && console.log(sql.join(" "), sqlValues), 
        tx.executeSql(sql.join(" "), sqlValues, function(tx, data) {
            if (1 === data.rows.length) {
                var key = idbModules.Key.decode(data.rows.item(0)[me.__keyColumnName]), val = "value" === me.__valueColumnName ? idbModules.Sca.decode(data.rows.item(0)[me.__valueColumnName]) : idbModules.Key.decode(data.rows.item(0)[me.__valueColumnName]);
                success(key, val);
            } else idbModules.DEBUG && console.log("Reached end of cursors"), success(undefined, undefined);
        }, function(tx, data) {
            idbModules.DEBUG && console.log("Could not execute Cursor.continue"), error(data);
        });
    }, IDBCursor.prototype["continue"] = function(key) {
        var me = this;
        this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__offset++, me.__find(key, tx, function(key, val) {
                me.key = key, me.value = val, success(me.key !== undefined ? me : undefined, me.__req);
            }, function(data) {
                error(data);
            });
        });
    }, IDBCursor.prototype.advance = function(count) {
        0 >= count && idbModules.util.throwDOMException("Type Error - Count is invalid - 0 or negative", count);
        var me = this;
        this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__offset += count, me.__find(undefined, tx, function(key, value) {
                me.key = key, me.value = value, success(me.key !== undefined ? me : undefined, me.__req);
            }, function(data) {
                error(data);
            });
        });
    }, IDBCursor.prototype.update = function(valueToUpdate) {
        var me = this;
        return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__find(undefined, tx, function(key) {
                var sql = "UPDATE " + idbModules.util.quote(me.__idbObjectStore.name) + " SET value = ? WHERE key = ?";
                idbModules.DEBUG && console.log(sql, valueToUpdate, key), tx.executeSql(sql, [ idbModules.Sca.encode(valueToUpdate), idbModules.Key.encode(key) ], function(tx, data) {
                    1 === data.rowsAffected ? success(key) : error("No rowns with key found" + key);
                }, function(tx, data) {
                    error(data);
                });
            }, function(data) {
                error(data);
            });
        });
    }, IDBCursor.prototype["delete"] = function() {
        var me = this;
        return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__find(undefined, tx, function(key) {
                var sql = "DELETE FROM  " + idbModules.util.quote(me.__idbObjectStore.name) + " WHERE key = ?";
                idbModules.DEBUG && console.log(sql, key), tx.executeSql(sql, [ idbModules.Key.encode(key) ], function(tx, data) {
                    1 === data.rowsAffected ? success(undefined) : error("No rowns with key found" + key);
                }, function(tx, data) {
                    error(data);
                });
            }, function(data) {
                error(data);
            });
        });
    }, idbModules.IDBCursor = IDBCursor;
}(idbModules), function(idbModules, undefined) {
    function IDBIndex(indexName, idbObjectStore) {
        this.indexName = indexName, this.__idbObjectStore = this.source = idbObjectStore;
    }
    IDBIndex.prototype.__createIndex = function(indexName, keyPath, optionalParameters) {
        var me = this, transaction = me.__idbObjectStore.transaction;
        transaction.__addToTransactionQueue(function(tx, args, success, failure) {
            me.__idbObjectStore.__getStoreProps(tx, function() {
                function error() {
                    idbModules.util.throwDOMException(0, "Could not create new index", arguments);
                }
                2 !== transaction.mode && idbModules.util.throwDOMException(0, "Invalid State error, not a version transaction", me.transaction);
                var idxList = JSON.parse(me.__idbObjectStore.__storeProps.indexList);
                idxList[indexName] !== undefined && idbModules.util.throwDOMException(0, "Index already exists on store", idxList);
                var columnName = indexName;
                idxList[indexName] = {
                    columnName: columnName,
                    keyPath: keyPath,
                    optionalParams: optionalParameters
                }, me.__idbObjectStore.__storeProps.indexList = JSON.stringify(idxList);
                var sql = [ "ALTER TABLE", idbModules.util.quote(me.__idbObjectStore.name), "ADD", columnName, "BLOB" ].join(" ");
                idbModules.DEBUG && console.log(sql), tx.executeSql(sql, [], function(tx, data) {
                    tx.executeSql("SELECT * FROM " + idbModules.util.quote(me.__idbObjectStore.name), [], function(tx, data) {
                        (function initIndexForRow(i) {
                            if (data.rows.length > i) try {
                                var value = idbModules.Sca.decode(data.rows.item(i).value), indexKey = eval("value['" + keyPath + "']");
                                tx.executeSql("UPDATE " + idbModules.util.quote(me.__idbObjectStore.name) + " set " + columnName + " = ? where key = ?", [ idbModules.Key.encode(indexKey), data.rows.item(i).key ], function() {
                                    initIndexForRow(i + 1);
                                }, error);
                            } catch (e) {
                                initIndexForRow(i + 1);
                            } else idbModules.DEBUG && console.log("Updating the indexes in table", me.__idbObjectStore.__storeProps), 
                            tx.executeSql("UPDATE __sys__ set indexList = ? where name = ?", [ me.__idbObjectStore.__storeProps.indexList, me.__idbObjectStore.name ], function() {
                                me.__idbObjectStore.__setReadyState("createIndex", !0), success(me);
                            }, error);
                        })(0);
                    }, error);
                }, error);
            }, "createObjectStore");
        });
    }, IDBIndex.prototype.openCursor = function(range, direction) {
        var cursorRequest = new idbModules.IDBRequest();
        return new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, "value"), 
        cursorRequest;
    }, IDBIndex.prototype.openKeyCursor = function(range, direction) {
        var cursorRequest = new idbModules.IDBRequest();
        return new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, "key"), 
        cursorRequest;
    }, IDBIndex.prototype.__fetchIndexData = function(key, opType) {
        var me = this;
        return me.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            var sql = [ "SELECT * FROM ", idbModules.util.quote(me.__idbObjectStore.name), " WHERE", me.indexName, "NOT NULL" ], sqlValues = [];
            key !== undefined && (sql.push("AND", me.indexName, " = ?"), sqlValues.push(idbModules.Key.encode(key))), 
            idbModules.DEBUG && console.log("Trying to fetch data for Index", sql.join(" "), sqlValues), 
            tx.executeSql(sql.join(" "), sqlValues, function(tx, data) {
                var d;
                d = "count" == typeof opType ? data.rows.length : 0 === data.rows.length ? undefined : "key" === opType ? idbModules.Key.decode(data.rows.item(0).key) : idbModules.Sca.decode(data.rows.item(0).value), 
                success(d);
            }, error);
        });
    }, IDBIndex.prototype.get = function(key) {
        return this.__fetchIndexData(key, "value");
    }, IDBIndex.prototype.getKey = function(key) {
        return this.__fetchIndexData(key, "key");
    }, IDBIndex.prototype.count = function(key) {
        return this.__fetchIndexData(key, "count");
    }, idbModules.IDBIndex = IDBIndex;
}(idbModules), function(idbModules) {
    var IDBObjectStore = function(name, idbTransaction, ready) {
        this.name = name, this.transaction = idbTransaction, this.__ready = {}, this.__setReadyState("createObjectStore", ready === void 0 ? !0 : ready), 
        this.indexNames = new idbModules.util.StringList();
    };
    IDBObjectStore.prototype.__setReadyState = function(key, val) {
        this.__ready[key] = val;
    }, IDBObjectStore.prototype.__waitForReady = function(callback, key) {
        var ready = !0;
        if (key !== void 0) ready = this.__ready[key] === void 0 ? !0 : this.__ready[key]; else for (var x in this.__ready) this.__ready[x] || (ready = !1);
        if (ready) callback(); else {
            idbModules.DEBUG && console.log("Waiting for to be ready", key);
            var me = this;
            window.setTimeout(function() {
                me.__waitForReady(callback, key);
            }, 100);
        }
    }, IDBObjectStore.prototype.__getStoreProps = function(tx, callback, waitOnProperty) {
        var me = this;
        this.__waitForReady(function() {
            me.__storeProps ? (idbModules.DEBUG && console.log("Store properties - cached", me.__storeProps), 
            callback(me.__storeProps)) : tx.executeSql("SELECT * FROM __sys__ where name = ?", [ me.name ], function(tx, data) {
                1 !== data.rows.length ? callback() : (me.__storeProps = {
                    name: data.rows.item(0).name,
                    indexList: data.rows.item(0).indexList,
                    autoInc: data.rows.item(0).autoInc,
                    keyPath: data.rows.item(0).keyPath
                }, idbModules.DEBUG && console.log("Store properties", me.__storeProps), callback(me.__storeProps));
            }, function() {
                callback();
            });
        }, waitOnProperty);
    }, IDBObjectStore.prototype.__deriveKey = function(tx, value, key, callback) {
        function getNextAutoIncKey() {
            tx.executeSql("SELECT * FROM sqlite_sequence where name like ?", [ me.name ], function(tx, data) {
                1 !== data.rows.length ? callback(0) : callback(data.rows.item(0).seq);
            }, function(tx, error) {
                idbModules.util.throwDOMException(0, "Data Error - Could not get the auto increment value for key", error);
            });
        }
        var me = this;
        me.__getStoreProps(tx, function(props) {
            if (props || idbModules.util.throwDOMException(0, "Data Error - Could not locate defination for this table", props), 
            props.keyPath) if (key !== void 0 && idbModules.util.throwDOMException(0, "Data Error - The object store uses in-line keys and the key parameter was provided", props), 
            value) try {
                var primaryKey = eval("value['" + props.keyPath + "']");
                primaryKey ? callback(primaryKey) : "true" === props.autoInc ? getNextAutoIncKey() : idbModules.util.throwDOMException(0, "Data Error - Could not eval key from keyPath");
            } catch (e) {
                idbModules.util.throwDOMException(0, "Data Error - Could not eval key from keyPath", e);
            } else idbModules.util.throwDOMException(0, "Data Error - KeyPath was specified, but value was not"); else key !== void 0 ? callback(key) : "false" === props.autoInc ? idbModules.util.throwDOMException(0, "Data Error - The object store uses out-of-line keys and has no key generator and the key parameter was not provided. ", props) : getNextAutoIncKey();
        });
    }, IDBObjectStore.prototype.__insertData = function(tx, value, primaryKey, success, error) {
        var paramMap = {};
        primaryKey !== void 0 && (paramMap.key = idbModules.Key.encode(primaryKey));
        var indexes = JSON.parse(this.__storeProps.indexList);
        for (var key in indexes) try {
            paramMap[indexes[key].columnName] = idbModules.Key.encode(eval("value['" + indexes[key].keyPath + "']"));
        } catch (e) {
            error(e);
        }
        var sqlStart = [ "INSERT INTO ", idbModules.util.quote(this.name), "(" ], sqlEnd = [ " VALUES (" ], sqlValues = [];
        for (key in paramMap) sqlStart.push(key + ","), sqlEnd.push("?,"), sqlValues.push(paramMap[key]);
        sqlStart.push("value )"), sqlEnd.push("?)"), sqlValues.push(idbModules.Sca.encode(value));
        var sql = sqlStart.join(" ") + sqlEnd.join(" ");
        idbModules.DEBUG && console.log("SQL for adding", sql, sqlValues), tx.executeSql(sql, sqlValues, function() {
            success(primaryKey);
        }, function(tx, err) {
            error(err);
        });
    }, IDBObjectStore.prototype.add = function(value, key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__deriveKey(tx, value, key, function(primaryKey) {
                me.__insertData(tx, value, primaryKey, success, error);
            });
        });
    }, IDBObjectStore.prototype.put = function(value, key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__deriveKey(tx, value, key, function(primaryKey) {
                var sql = "DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?";
                tx.executeSql(sql, [ idbModules.Key.encode(primaryKey) ], function(tx, data) {
                    idbModules.DEBUG && console.log("Did the row with the", primaryKey, "exist? ", data.rowsAffected), 
                    me.__insertData(tx, value, primaryKey, success, error);
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.get = function(key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                var primaryKey = idbModules.Key.encode(key);
                idbModules.DEBUG && console.log("Fetching", me.name, primaryKey), tx.executeSql("SELECT * FROM " + idbModules.util.quote(me.name) + " where key = ?", [ primaryKey ], function(tx, data) {
                    idbModules.DEBUG && console.log("Fetched data", data);
                    try {
                        if (0 === data.rows.length) return success();
                        success(idbModules.Sca.decode(data.rows.item(0).value));
                    } catch (e) {
                        idbModules.DEBUG && console.log(e), success(void 0);
                    }
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype["delete"] = function(key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                var primaryKey = idbModules.Key.encode(key);
                idbModules.DEBUG && console.log("Fetching", me.name, primaryKey), tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?", [ primaryKey ], function(tx, data) {
                    idbModules.DEBUG && console.log("Deleted from database", data.rowsAffected), success();
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.clear = function() {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name), [], function(tx, data) {
                    idbModules.DEBUG && console.log("Cleared all records from database", data.rowsAffected), 
                    success();
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.count = function(key) {
        var me = this;
        return me.transaction.__addToTransactionQueue(function(tx, args, success, error) {
            me.__waitForReady(function() {
                var sql = "SELECT * FROM " + idbModules.util.quote(me.name) + (key !== void 0 ? " WHERE key = ?" : ""), sqlValues = [];
                key !== void 0 && sqlValues.push(idbModules.Key.encode(key)), tx.executeSql(sql, sqlValues, function(tx, data) {
                    success(data.rows.length);
                }, function(tx, err) {
                    error(err);
                });
            });
        });
    }, IDBObjectStore.prototype.openCursor = function(range, direction) {
        var cursorRequest = new idbModules.IDBRequest();
        return new idbModules.IDBCursor(range, direction, this, cursorRequest, "key", "value"), 
        cursorRequest;
    }, IDBObjectStore.prototype.index = function(indexName) {
        var index = new idbModules.IDBIndex(indexName, this);
        return index;
    }, IDBObjectStore.prototype.createIndex = function(indexName, keyPath, optionalParameters) {
        var me = this;
        optionalParameters = optionalParameters || {}, me.__setReadyState("createIndex", !1);
        var result = new idbModules.IDBIndex(indexName, me);
        return me.__waitForReady(function() {
            result.__createIndex(indexName, keyPath, optionalParameters);
        }, "createObjectStore"), me.indexNames.push(indexName), result;
    }, IDBObjectStore.prototype.deleteIndex = function(indexName) {
        var result = new idbModules.IDBIndex(indexName, this, !1);
        return result.__deleteIndex(indexName), result;
    }, idbModules.IDBObjectStore = IDBObjectStore;
}(idbModules), function(idbModules) {
    var READ = 0, READ_WRITE = 1, VERSION_TRANSACTION = 2, IDBTransaction = function(storeNames, mode, db) {
        if ("number" == typeof mode) this.mode = mode, 2 !== mode && idbModules.DEBUG && console.log("Mode should be a string, but was specified as ", mode); else if ("string" == typeof mode) switch (mode) {
          case "readonly":
            this.mode = READ_WRITE;
            break;

          case "readwrite":
            this.mode = READ;
            break;

          default:
            this.mode = READ;
        }
        this.storeNames = "string" == typeof storeNames ? [ storeNames ] : storeNames;
        for (var i = 0; this.storeNames.length > i; i++) db.objectStoreNames.contains(this.storeNames[i]) || idbModules.util.throwDOMException(0, "The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.", this.storeNames[i]);
        this.__active = !0, this.__running = !1, this.__requests = [], this.__aborted = !1, 
        this.db = db, this.error = null, this.onabort = this.onerror = this.oncomplete = null;
    };
    IDBTransaction.prototype.__executeRequests = function() {
        if (this.__running && this.mode !== VERSION_TRANSACTION) return idbModules.DEBUG && console.log("Looks like the request set is already running", this.mode), 
        void 0;
        this.__running = !0;
        var me = this;
        window.setTimeout(function() {
            2 === me.mode || me.__active || idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished", me.__active), 
            me.db.__db.transaction(function(tx) {
                function success(result, req) {
                    req && (q.req = req), q.req.readyState = "done", q.req.result = result, delete q.req.error;
                    var e = idbModules.Event("success");
                    idbModules.util.callback("onsuccess", q.req, e), i++, executeRequest();
                }
                function error() {
                    q.req.readyState = "done", q.req.error = "DOMError";
                    var e = idbModules.Event("error", arguments);
                    idbModules.util.callback("onerror", q.req, e), i++, executeRequest();
                }
                function executeRequest() {
                    return i >= me.__requests.length ? (me.__active = !1, me.__requests = [], void 0) : (q = me.__requests[i], 
                    q.op(tx, q.args, success, error), void 0);
                }
                me.__tx = tx;
                var q = null, i = 0;
                try {
                    executeRequest();
                } catch (e) {
                    idbModules.DEBUG && console.log("An exception occured in transaction", arguments), 
                    "function" == typeof me.onerror && me.onerror();
                }
            }, function() {
                idbModules.DEBUG && console.log("An error in transaction", arguments), "function" == typeof me.onerror && me.onerror();
            }, function() {
                idbModules.DEBUG && console.log("Transaction completed", arguments), "function" == typeof me.oncomplete && me.oncomplete();
            });
        }, 1);
    }, IDBTransaction.prototype.__addToTransactionQueue = function(callback, args) {
        this.__active || this.mode === VERSION_TRANSACTION || idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished.", this.__mode);
        var request = new idbModules.IDBRequest();
        return request.source = this.db, this.__requests.push({
            op: callback,
            args: args,
            req: request
        }), this.__executeRequests(), request;
    }, IDBTransaction.prototype.objectStore = function(objectStoreName) {
        return new idbModules.IDBObjectStore(objectStoreName, this);
    }, IDBTransaction.prototype.abort = function() {
        !this.__active && idbModules.util.throwDOMException(0, "A request was placed against a transaction which is currently not active, or which is finished", this.__active);
    }, IDBTransaction.prototype.READ_ONLY = 0, IDBTransaction.prototype.READ_WRITE = 1, 
    IDBTransaction.prototype.VERSION_CHANGE = 2, idbModules.IDBTransaction = IDBTransaction;
}(idbModules), function(idbModules) {
    var IDBDatabase = function(db, name, version, storeProperties) {
        this.__db = db, this.version = version, this.__storeProperties = storeProperties, 
        this.objectStoreNames = new idbModules.util.StringList();
        for (var i = 0; storeProperties.rows.length > i; i++) this.objectStoreNames.push(storeProperties.rows.item(i).name);
        this.name = name, this.onabort = this.onerror = this.onversionchange = null;
    };
    IDBDatabase.prototype.createObjectStore = function(storeName, createOptions) {
        var me = this;
        createOptions = createOptions || {}, createOptions.keyPath = createOptions.keyPath || null;
        var result = new idbModules.IDBObjectStore(storeName, me.__versionTransaction, !1), transaction = me.__versionTransaction;
        return transaction.__addToTransactionQueue(function(tx, args, success) {
            function error() {
                idbModules.util.throwDOMException(0, "Could not create new object store", arguments);
            }
            me.__versionTransaction || idbModules.util.throwDOMException(0, "Invalid State error", me.transaction);
            var sql = [ "CREATE TABLE", idbModules.util.quote(storeName), "(key BLOB", createOptions.autoIncrement ? ", inc INTEGER PRIMARY KEY AUTOINCREMENT" : "PRIMARY KEY", ", value BLOB)" ].join(" ");
            idbModules.DEBUG && console.log(sql), tx.executeSql(sql, [], function(tx) {
                tx.executeSql("INSERT INTO __sys__ VALUES (?,?,?,?)", [ storeName, createOptions.keyPath, createOptions.autoIncrement ? !0 : !1, "{}" ], function() {
                    result.__setReadyState("createObjectStore", !0), success(result);
                }, error);
            }, error);
        }), me.objectStoreNames.push(storeName), result;
    }, IDBDatabase.prototype.deleteObjectStore = function(storeName) {
        var error = function() {
            idbModules.util.throwDOMException(0, "Could not delete ObjectStore", arguments);
        }, me = this;
        !me.objectStoreNames.contains(storeName) && error("Object Store does not exist"), 
        me.objectStoreNames.splice(me.objectStoreNames.indexOf(storeName), 1);
        var transaction = me.__versionTransaction;
        transaction.__addToTransactionQueue(function() {
            me.__versionTransaction || idbModules.util.throwDOMException(0, "Invalid State error", me.transaction), 
            me.__db.transaction(function(tx) {
                tx.executeSql("SELECT * FROM __sys__ where name = ?", [ storeName ], function(tx, data) {
                    data.rows.length > 0 && tx.executeSql("DROP TABLE " + idbModules.util.quote(storeName), [], function() {
                        tx.executeSql("DELETE FROM __sys__ WHERE name = ?", [ storeName ], function() {}, error);
                    }, error);
                });
            });
        });
    }, IDBDatabase.prototype.close = function() {}, IDBDatabase.prototype.transaction = function(storeNames, mode) {
        var transaction = new idbModules.IDBTransaction(storeNames, mode || 1, this);
        return transaction;
    }, idbModules.IDBDatabase = IDBDatabase;
}(idbModules), function(idbModules) {
    var DEFAULT_DB_SIZE = 4194304;
    if (window.openDatabase) {
        var sysdb = window.openDatabase("__sysdb__", 1, "System Database", DEFAULT_DB_SIZE);
        sysdb.transaction(function(tx) {
            tx.executeSql("SELECT * FROM dbVersions", [], function() {}, function() {
                sysdb.transaction(function(tx) {
                    tx.executeSql("CREATE TABLE IF NOT EXISTS dbVersions (name VARCHAR(255), version INT);", [], function() {}, function() {
                        idbModules.util.throwDOMException("Could not create table __sysdb__ to save DB versions");
                    });
                });
            });
        }, function() {
            idbModules.DEBUG && console.log("Error in sysdb transaction - when selecting from dbVersions", arguments);
        });
        var shimIndexedDB = {
            open: function(name, version) {
                function dbCreateError() {
                    if (!calledDbCreateError) {
                        var e = idbModules.Event("error", arguments);
                        req.readyState = "done", req.error = "DOMError", idbModules.util.callback("onerror", req, e), 
                        calledDbCreateError = !0;
                    }
                }
                function openDB(oldVersion) {
                    var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
                    req.readyState = "done", version === void 0 && (version = oldVersion || 1), (0 >= version || oldVersion > version) && idbModules.util.throwDOMException(0, "An attempt was made to open a database using a lower version than the existing version.", version), 
                    db.transaction(function(tx) {
                        tx.executeSql("CREATE TABLE IF NOT EXISTS __sys__ (name VARCHAR(255), keyPath VARCHAR(255), autoInc BOOLEAN, indexList BLOB)", [], function() {
                            tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
                                var e = idbModules.Event("success");
                                req.source = req.result = new idbModules.IDBDatabase(db, name, version, data), version > oldVersion ? sysdb.transaction(function(systx) {
                                    systx.executeSql("UPDATE dbVersions set version = ? where name = ?", [ version, name ], function() {
                                        var e = idbModules.Event("upgradeneeded");
                                        e.oldVersion = oldVersion, e.newVersion = version, req.transaction = req.result.__versionTransaction = new idbModules.IDBTransaction([], 2, req.source), 
                                        idbModules.util.callback("onupgradeneeded", req, e, function() {
                                            var e = idbModules.Event("success");
                                            idbModules.util.callback("onsuccess", req, e);
                                        });
                                    }, dbCreateError);
                                }, dbCreateError) : idbModules.util.callback("onsuccess", req, e);
                            }, dbCreateError);
                        }, dbCreateError);
                    }, dbCreateError);
                }
                var req = new idbModules.IDBOpenRequest(), calledDbCreateError = !1;
                return sysdb.transaction(function(tx) {
                    tx.executeSql("SELECT * FROM dbVersions where name = ?", [ name ], function(tx, data) {
                        0 === data.rows.length ? tx.executeSql("INSERT INTO dbVersions VALUES (?,?)", [ name, version || 1 ], function() {
                            openDB(0);
                        }, dbCreateError) : openDB(data.rows.item(0).version);
                    }, dbCreateError);
                }, dbCreateError), req;
            },
            deleteDatabase: function(name) {
                function dbError(msg) {
                    if (!calledDBError) {
                        req.readyState = "done", req.error = "DOMError";
                        var e = idbModules.Event("error");
                        e.message = msg, e.debug = arguments, idbModules.util.callback("onerror", req, e), 
                        calledDBError = !0;
                    }
                }
                function deleteFromDbVersions() {
                    sysdb.transaction(function(systx) {
                        systx.executeSql("DELETE FROM dbVersions where name = ? ", [ name ], function() {
                            req.result = void 0;
                            var e = idbModules.Event("success");
                            e.newVersion = null, e.oldVersion = version, idbModules.util.callback("onsuccess", req, e);
                        }, dbError);
                    }, dbError);
                }
                var req = new idbModules.IDBOpenRequest(), calledDBError = !1, version = null;
                return sysdb.transaction(function(systx) {
                    systx.executeSql("SELECT * FROM dbVersions where name = ?", [ name ], function(tx, data) {
                        if (0 === data.rows.length) {
                            req.result = void 0;
                            var e = idbModules.Event("success");
                            return e.newVersion = null, e.oldVersion = version, idbModules.util.callback("onsuccess", req, e), 
                            void 0;
                        }
                        version = data.rows.item(0).version;
                        var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
                        db.transaction(function(tx) {
                            tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
                                var tables = data.rows;
                                (function deleteTables(i) {
                                    i >= tables.length ? tx.executeSql("DROP TABLE __sys__", [], function() {
                                        deleteFromDbVersions();
                                    }, dbError) : tx.executeSql("DROP TABLE " + idbModules.util.quote(tables.item(i).name), [], function() {
                                        deleteTables(i + 1);
                                    }, function() {
                                        deleteTables(i + 1);
                                    });
                                })(0);
                            }, function() {
                                deleteFromDbVersions();
                            });
                        }, dbError);
                    });
                }, dbError), req;
            },
            cmp: function(key1, key2) {
                return idbModules.Key.encode(key1) > idbModules.Key.encode(key2) ? 1 : key1 === key2 ? 0 : -1;
            }
        };
        idbModules.shimIndexedDB = shimIndexedDB;
    }
}(idbModules), function(window, idbModules) {
    window.openDatabase !== void 0 && (window.shimIndexedDB = idbModules.shimIndexedDB, 
    window.shimIndexedDB && (window.shimIndexedDB.__useShim = function() {
        window.indexedDB = idbModules.shimIndexedDB, window.IDBDatabase = idbModules.IDBDatabase, 
        window.IDBTransaction = idbModules.IDBTransaction, window.IDBCursor = idbModules.IDBCursor, 
        window.IDBKeyRange = idbModules.IDBKeyRange;
    }, window.shimIndexedDB.__debug = function(val) {
        idbModules.DEBUG = val;
    })), window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB, 
    window.indexedDB === void 0 && window.openDatabase !== void 0 ? window.shimIndexedDB.__useShim() : (window.IDBDatabase = window.IDBDatabase || window.webkitIDBDatabase, 
    window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction, window.IDBCursor = window.IDBCursor || window.webkitIDBCursor, 
    window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange, window.IDBTransaction.READ_ONLY = window.IDBTransaction.READ_ONLY || "readonly", 
    window.IDBTransaction.READ_WRITE = window.IDBTransaction.READ_WRITE || "readwrite");
}(window, idbModules), fdjt.charnames = {
    AElig: "",
    Aacgr: "",
    Aacute: "",
    Abreve: "",
    Acirc: "",
    Acy: "",
    Agr: "",
    Agrave: "",
    Alpha: "",
    Amacr: "",
    Aogon: "",
    Aring: "",
    Atilde: "",
    Auml: "",
    Barwed: "",
    Bcy: "",
    Beta: "",
    Bgr: "",
    CHcy: "",
    Cacute: "",
    Cap: "",
    Ccaron: "",
    Ccedil: "",
    Ccirc: "",
    Cdot: "",
    Chi: "",
    Cup: "",
    DJcy: "",
    DScy: "",
    DZcy: "",
    Dagger: "",
    Dcaron: "",
    Dcy: "",
    Delta: "",
    Dgr: "",
    Dot: "",
    DotDot: "",
    Dstrok: "",
    EEacgr: "",
    EEgr: "",
    ENG: "",
    ETH: "",
    Eacgr: "",
    Eacute: "",
    Ecaron: "",
    Ecirc: "",
    Ecy: "",
    Edot: "",
    Egr: "",
    Egrave: "",
    Emacr: "",
    Eogon: "",
    Epsilon: "",
    Eta: "",
    Euml: "",
    Fcy: "",
    GJcy: "",
    Gamma: "",
    Gbreve: "",
    Gcedil: "",
    Gcirc: "",
    Gcy: "",
    Gdot: "",
    Gg: "",
    Ggr: "",
    Gt: "",
    HARDcy: "",
    Hcirc: "",
    Hstrok: "",
    IEcy: "",
    IJlig: "",
    IOcy: "",
    Iacgr: "",
    Iacute: "",
    Icirc: "",
    Icy: "",
    Idigr: "",
    Idot: "",
    Igr: "",
    Igrave: "",
    Imacr: "",
    Iogon: "",
    Iota: "",
    Itilde: "",
    Iukcy: "",
    Iuml: "",
    Jcirc: "",
    Jcy: "",
    Jsercy: "",
    Jukcy: "",
    KHcy: "",
    KHgr: "",
    KJcy: "",
    Kappa: "",
    Kcedil: "",
    Kcy: "",
    Kgr: "",
    LJcy: "",
    Lacute: "",
    Lambda: "",
    Larr: "",
    Lcaron: "",
    Lcedil: "",
    Lcy: "",
    Lgr: "",
    Ll: "",
    Lmidot: "",
    Lstrok: "",
    Lt: "",
    Mcy: "",
    Mgr: "",
    Mu: "",
    NJcy: "",
    Nacute: "",
    Ncaron: "",
    Ncedil: "",
    Ncy: "",
    Ngr: "",
    Ntilde: "",
    Nu: "",
    OElig: "",
    OHacgr: "",
    OHgr: "",
    Oacgr: "",
    Oacute: "",
    Ocirc: "",
    Ocy: "",
    Odblac: "",
    Ogr: "",
    Ograve: "",
    Omacr: "",
    Omega: "",
    Omicron: "",
    Oslash: "",
    Otilde: "",
    Ouml: "",
    PHgr: "",
    PSgr: "",
    Pcy: "",
    Pgr: "",
    Phi: "",
    Pi: "",
    Prime: "",
    Psi: "",
    Racute: "",
    Rarr: "",
    Rcaron: "",
    Rcedil: "",
    Rcy: "",
    Rgr: "",
    Rho: "",
    SHCHcy: "",
    SHcy: "",
    SOFTcy: "",
    Sacute: "",
    Scaron: "",
    Scedil: "",
    Scirc: "",
    Scy: "",
    Sgr: "",
    Sigma: "",
    Sub: "",
    Sup: "",
    THORN: "",
    THgr: "",
    TSHcy: "",
    TScy: "",
    Tau: "",
    Tcaron: "",
    Tcedil: "",
    Tcy: "",
    Tgr: "",
    Theta: "",
    Tstrok: "",
    Uacgr: "",
    Uacute: "",
    Ubrcy: "",
    Ubreve: "",
    Ucirc: "",
    Ucy: "",
    Udblac: "",
    Ugr: "",
    Ugrave: "",
    Umacr: "",
    Uogon: "",
    Upsi: "",
    Upsilon: "",
    Uring: "",
    Utilde: "",
    Uuml: "",
    Vcy: "",
    Vdash: "",
    Verbar: "",
    Vvdash: "",
    Wcirc: "",
    Xgr: "",
    Xi: "",
    YAcy: "",
    YIcy: "",
    YUcy: "",
    Yacute: "",
    Ycirc: "",
    Ycy: "",
    Yuml: "",
    ZHcy: "",
    Zacute: "",
    Zcaron: "",
    Zcy: "",
    Zdot: "",
    Zeta: "",
    Zgr: "",
    aacgr: "",
    aacute: "",
    abreve: "",
    acirc: "",
    acute: "",
    acy: "",
    aelig: "",
    agr: "",
    agrave: "",
    alefsym: "",
    aleph: "",
    alpha: "",
    amacr: "",
    amalg: "",
    amp: "&",
    and: "",
    ang: "",
    ang90: "",
    angmsd: "",
    angsph: "",
    angst: "",
    aogon: "",
    ap: "",
    ape: "",
    apos: "'",
    aposmod: "",
    aring: "",
    ast: "*",
    asymp: "",
    atilde: "",
    auml: "",
    "b.Delta": "",
    "b.Gamma": "",
    "b.Lambda": "",
    "b.Omega": "",
    "b.Phi": "",
    "b.Pi": "",
    "b.Psi": "",
    "b.Sigma": "",
    "b.Theta": "",
    "b.Upsi": "",
    "b.Xi": "",
    "b.alpha": "",
    "b.beta": "",
    "b.chi": "",
    "b.delta": "",
    "b.epsi": "",
    "b.epsis": "",
    "b.epsiv": "",
    "b.eta": "",
    "b.gamma": "",
    "b.gammad": "",
    "b.iota": "",
    "b.kappa": "",
    "b.kappav": "",
    "b.lambda": "",
    "b.mu": "",
    "b.nu": "",
    "b.omega": "",
    "b.phis": "",
    "b.phiv": "",
    "b.pi": "",
    "b.piv": "",
    "b.psi": "",
    "b.rho": "",
    "b.rhov": "",
    "b.sigma": "",
    "b.sigmav": "",
    "b.tau": "",
    "b.thetas": "",
    "b.thetav": "",
    "b.upsi": "",
    "b.xi": "",
    "b.zeta": "",
    barwed: "",
    bcong: "",
    bcy: "",
    bdquo: "",
    becaus: "",
    bepsi: "",
    bernou: "",
    beta: "",
    beth: "",
    bgr: "",
    blackstar: "",
    blank: "",
    blk12: "",
    blk14: "",
    blk34: "",
    block: "",
    bottom: "",
    bowtie: "",
    boxDL: "",
    boxDR: "",
    boxDl: "",
    boxDr: "",
    boxH: "",
    boxHD: "",
    boxHU: "",
    boxHd: "",
    boxHu: "",
    boxUL: "",
    boxUR: "",
    boxUl: "",
    boxUr: "",
    boxV: "",
    boxVH: "",
    boxVL: "",
    boxVR: "",
    boxVh: "",
    boxVl: "",
    boxVr: "",
    boxdL: "",
    boxdR: "",
    boxdl: "",
    boxdr: "",
    boxh: "",
    boxhD: "",
    boxhU: "",
    boxhd: "",
    boxhu: "",
    boxuL: "",
    boxuR: "",
    boxul: "",
    boxur: "",
    boxv: "",
    boxvH: "",
    boxvL: "",
    boxvR: "",
    boxvh: "",
    boxvl: "",
    boxvr: "",
    bprime: "",
    breve: "",
    brvbar: "",
    bsim: "",
    bsime: "",
    bsol: "\\",
    bull: "",
    bump: "",
    bumpe: "",
    cacute: "",
    cap: "",
    caret: "",
    caron: "",
    ccaron: "",
    ccedil: "",
    ccirc: "",
    cdot: "",
    cedil: "",
    cent: "",
    chcy: "",
    check: "",
    chi: "",
    cir: "",
    circ: "",
    cire: "",
    clubs: "",
    colon: ":",
    colone: "",
    comma: ",",
    commat: "@",
    comp: "",
    compfn: "",
    cong: "",
    conint: "",
    coprod: "",
    copy: "",
    copysr: "",
    crarr: "",
    cross: "",
    cuepr: "",
    cuesc: "",
    cularr: "",
    cup: "",
    cupre: "",
    curarr: "",
    curren: "",
    cuvee: "",
    cuwed: "",
    dArr: "",
    dagger: "",
    daleth: "",
    darr: "",
    darr2: "",
    dash: "",
    dashv: "",
    dblac: "",
    dcaron: "",
    dcy: "",
    deg: "",
    delta: "",
    dgr: "",
    dharl: "",
    dharr: "",
    diam: "",
    diams: "",
    die: "",
    divide: "",
    divonx: "",
    djcy: "",
    dlarr: "",
    dlcorn: "",
    dlcrop: "",
    dollar: "$",
    dot: "",
    drarr: "",
    drcorn: "",
    drcrop: "",
    dscy: "",
    dstrok: "",
    dtri: "",
    dtrif: "",
    dzcy: "",
    eDot: "",
    eacgr: "",
    eacute: "",
    ecaron: "",
    ecir: "",
    ecirc: "",
    ecolon: "",
    ecy: "",
    edot: "",
    eeacgr: "",
    eegr: "",
    efDot: "",
    egr: "",
    egrave: "",
    egs: "",
    ell: "",
    els: "",
    emacr: "",
    empty: "",
    emsp: "",
    emsp13: "",
    emsp14: "",
    eng: "",
    ensp: "",
    eogon: "",
    epsi: "",
    epsilon: "",
    epsis: "",
    epsiv: "",
    equals: "=",
    equiv: "",
    erDot: "",
    esdot: "",
    eta: "",
    eth: "",
    euml: "",
    euro: "",
    excl: "!",
    exist: "",
    fcy: "",
    female: "",
    ffilig: "",
    fflig: "",
    ffllig: "",
    filig: "",
    flat: "",
    fllig: "",
    fnof: "",
    forall: "",
    fork: "",
    frac12: "",
    frac13: "",
    frac14: "",
    frac15: "",
    frac16: "",
    frac18: "",
    frac23: "",
    frac25: "",
    frac34: "",
    frac35: "",
    frac38: "",
    frac45: "",
    frac56: "",
    frac58: "",
    frac78: "",
    frasl: "",
    frown: "",
    gE: "",
    gEl: "",
    gacute: "",
    gamma: "",
    gammad: "",
    gap: "",
    gbreve: "",
    gcedil: "",
    gcirc: "",
    gcy: "",
    gdot: "",
    ge: "",
    gel: "",
    ges: "",
    ggr: "",
    gimel: "",
    gjcy: "",
    gl: "",
    gnE: "",
    gnap: "",
    gne: "",
    gnsim: "",
    grave: "`",
    gsdot: "",
    gsim: "",
    gt: ">",
    gvnE: "",
    hArr: "",
    hairsp: "",
    half: "",
    hamilt: "",
    hardcy: "",
    harr: "",
    harrw: "",
    hcirc: "",
    hearts: "",
    hellip: "",
    horbar: "",
    hstrok: "",
    hybull: "",
    hyphen: "-",
    iacgr: "",
    iacute: "",
    icirc: "",
    icy: "",
    idiagr: "",
    idigr: "",
    iecy: "",
    iexcl: "",
    iff: "",
    igr: "",
    igrave: "",
    ijlig: "",
    imacr: "",
    image: "",
    incare: "",
    infin: "",
    inodot: "",
    "int": "",
    intcal: "",
    iocy: "",
    iogon: "",
    iota: "",
    iquest: "",
    isin: "",
    itilde: "",
    iukcy: "",
    iuml: "",
    jcirc: "",
    jcy: "",
    jsercy: "",
    jukcy: "",
    kappa: "",
    kappav: "",
    kcedil: "",
    kcy: "",
    kgr: "",
    kgreen: "",
    khcy: "",
    khgr: "",
    kjcy: "",
    lAarr: "",
    lArr: "",
    lE: "",
    lEg: "",
    lacute: "",
    lagran: "",
    lambda: "",
    lang: "",
    lap: "",
    laquo: "",
    larr: "",
    larr2: "",
    larrhk: "",
    larrlp: "",
    larrtl: "",
    lcaron: "",
    lcedil: "",
    lceil: "",
    lcub: "{",
    lcy: "",
    ldot: "",
    ldquo: "",
    ldquor: "",
    le: "",
    leg: "",
    les: "",
    lfloor: "",
    lg: "",
    lgr: "",
    lhard: "",
    lharu: "",
    lhblk: "",
    ljcy: "",
    lmidot: "",
    lnE: "",
    lnap: "",
    lne: "",
    lnsim: "",
    lowast: "",
    lowbar: "_",
    loz: "",
    lozf: "",
    lpar: "(",
    lrarr2: "",
    lrhar2: "",
    lrm: "",
    lsaquo: "",
    lsh: "",
    lsim: "",
    lsqb: "[",
    lsquo: "",
    lsquor: "",
    lstrok: "",
    lt: "<",
    lthree: "",
    ltimes: "",
    ltri: "",
    ltrie: "",
    ltrif: "",
    lvnE: "",
    macr: "",
    male: "",
    malt: "",
    map: "",
    marker: "",
    mcy: "",
    mdash: "",
    mgr: "",
    micro: "",
    mid: "",
    middot: "",
    minus: "",
    minusb: "",
    mldr: "",
    mnplus: "",
    models: "",
    mu: "",
    mumap: "",
    nVDash: "",
    nVdash: "",
    nabla: "",
    nacute: "",
    nap: "",
    napos: "",
    natur: "",
    nbsp: "",
    ncaron: "",
    ncedil: "",
    ncong: "",
    ncy: "",
    ndash: "",
    ne: "",
    nearr: "",
    nequiv: "",
    nexist: "",
    nge: "",
    nges: "",
    ngr: "",
    ngt: "",
    nhArr: "",
    nharr: "",
    ni: "",
    njcy: "",
    nlArr: "",
    nlarr: "",
    nldr: "",
    nle: "",
    nles: "",
    nlt: "",
    nltri: "",
    nltrie: "",
    nmid: "",
    not: "",
    notin: "",
    npar: "",
    npr: "",
    npre: "",
    nrArr: "",
    nrarr: "",
    nrtri: "",
    nrtrie: "",
    nsc: "",
    nsce: "",
    nsim: "",
    nsime: "",
    nsmid: "",
    nspar: "",
    nsub: "",
    nsubE: "",
    nsube: "",
    nsup: "",
    nsupE: "",
    nsupe: "",
    ntilde: "",
    nu: "",
    num: "#",
    numero: "",
    numsp: "",
    nvDash: "",
    nvdash: "",
    oS: "",
    oacgr: "",
    oacute: "",
    oast: "",
    ocir: "",
    ocirc: "",
    ocy: "",
    odash: "",
    odblac: "",
    odot: "",
    oelig: "",
    ogon: "",
    ogr: "",
    ograve: "",
    ohacgr: "",
    ohgr: "",
    ohm: "",
    olarr: "",
    oline: "",
    omacr: "",
    omega: "",
    omicron: "",
    ominus: "",
    oplus: "",
    or: "",
    orarr: "",
    order: "",
    ordf: "",
    ordm: "",
    oslash: "",
    osol: "",
    otilde: "",
    otimes: "",
    ouml: "",
    par: "",
    para: "",
    part: "",
    pcy: "",
    percnt: "%",
    period: ".",
    permil: "",
    perp: "",
    pgr: "",
    phgr: "",
    phi: "",
    phis: "",
    phiv: "",
    phmmat: "",
    phone: "",
    pi: "",
    piv: "",
    planck: "",
    plus: "+",
    plusb: "",
    plusdo: "",
    plusmn: "",
    pound: "",
    pr: "",
    prap: "",
    pre: "",
    prime: "",
    prnE: "",
    prnap: "",
    prnsim: "",
    prod: "",
    prop: "",
    prsim: "",
    psgr: "",
    psi: "",
    puncsp: "",
    quest: "?",
    quot: '"',
    rAarr: "",
    rArr: "",
    racute: "",
    radic: "",
    rang: "",
    raquo: "",
    rarr: "",
    rarr2: "",
    rarrhk: "",
    rarrlp: "",
    rarrtl: "",
    rarrw: "",
    rcaron: "",
    rcedil: "",
    rceil: "",
    rcub: "}",
    rcy: "",
    rdquo: "",
    rdquor: "",
    real: "",
    rect: "",
    reg: "",
    rfloor: "",
    rgr: "",
    rhard: "",
    rharu: "",
    rho: "",
    rhov: "",
    ring: "",
    rlarr2: "",
    rlhar2: "",
    rlm: "",
    rpar: ")",
    rpargt: "",
    rsaquo: "",
    rsh: "",
    rsqb: "]",
    rsquo: "",
    rsquor: "",
    rthree: "",
    rtimes: "",
    rtri: "",
    rtrie: "",
    rtrif: "",
    rx: "",
    sacute: "",
    samalg: "",
    sbquo: "",
    sbsol: "\\",
    sc: "",
    scap: "",
    scaron: "",
    sccue: "",
    sce: "",
    scedil: "",
    scirc: "",
    scnE: "",
    scnap: "",
    scnsim: "",
    scsim: "",
    scy: "",
    sdot: "",
    sdotb: "",
    sect: "",
    semi: ";",
    setmn: "",
    sext: "",
    sfgr: "",
    sfrown: "",
    sgr: "",
    sharp: "",
    shchcy: "",
    shcy: "",
    shy: "",
    sigma: "",
    sigmaf: "",
    sigmav: "",
    sim: "",
    sime: "",
    smid: "",
    smile: "",
    softcy: "",
    sol: "/",
    spades: "",
    spar: "",
    sqcap: "",
    sqcup: "",
    sqsub: "",
    sqsube: "",
    sqsup: "",
    sqsupe: "",
    squ: "",
    square: "",
    squf: "",
    ssetmn: "",
    ssmile: "",
    sstarf: "",
    star: "",
    starf: "",
    sub: "",
    subE: "",
    sube: "",
    subnE: "",
    subne: "",
    sum: "",
    sung: "",
    sup: "",
    sup1: "",
    sup2: "",
    sup3: "",
    supE: "",
    supe: "",
    supnE: "",
    supne: "",
    szlig: "",
    target: "",
    tau: "",
    tcaron: "",
    tcedil: "",
    tcy: "",
    tdot: "",
    telrec: "",
    tgr: "",
    there4: "",
    theta: "",
    thetas: "",
    thetasym: "",
    thetav: "",
    thgr: "",
    thinsp: "",
    thkap: "",
    thksim: "",
    thorn: "",
    tilde: "",
    times: "",
    timesb: "",
    top: "",
    tprime: "",
    trade: "",
    trie: "",
    tscy: "",
    tshcy: "",
    tstrok: "",
    twixt: "",
    uArr: "",
    uacgr: "",
    uacute: "",
    uarr: "",
    uarr2: "",
    ubrcy: "",
    ubreve: "",
    ucirc: "",
    ucy: "",
    udblac: "",
    udiagr: "",
    udigr: "",
    ugr: "",
    ugrave: "",
    uharl: "",
    uharr: "",
    uhblk: "",
    ulcorn: "",
    ulcrop: "",
    umacr: "",
    uml: "",
    uogon: "",
    uplus: "",
    upsi: "",
    upsih: "",
    upsilon: "",
    urcorn: "",
    urcrop: "",
    uring: "",
    utilde: "",
    utri: "",
    utrif: "",
    uuml: "",
    vArr: "",
    vDash: "",
    varr: "",
    vcy: "",
    vdash: "",
    veebar: "",
    vellip: "",
    verbar: "|",
    vltri: "",
    vprime: "",
    vprop: "",
    vrtri: "",
    vsubnE: "",
    vsubne: "",
    vsupnE: "",
    vsupne: "",
    wcirc: "",
    wedgeq: "",
    weierp: "",
    whitestar: "",
    wreath: "",
    xcirc: "",
    xdtri: "",
    xgr: "",
    xhArr: "",
    xharr: "",
    xi: "",
    xlArr: "",
    xrArr: "",
    xutri: "",
    yacute: "",
    yacy: "",
    ycirc: "",
    ycy: "",
    yen: "",
    yicy: "",
    yucy: "",
    yuml: "",
    zacute: "",
    zcaron: "",
    zcy: "",
    zdot: "",
    zeta: "",
    zgr: "",
    zhcy: "",
    zwj: "",
    zwnj: ""
}, fdjt.String = function() {
    "use strict";
    function fdjtString(string) {
        if ("string" != typeof string && !(string instanceof String)) return stringify(string);
        for (var arg, output = "", cmd = string.indexOf("%"), i = 1; cmd >= 0; ) {
            if (cmd > 0 && (output += string.slice(0, cmd)), "%" === string[cmd + 1]) output += "%"; else if ("o" === string[cmd + 1]) if (arg = arguments[i++], 
            "string" == typeof arg) output = output + "'" + arg + "'"; else if ("number" == typeof arg) output += arg; else if (Array.isArray(arg)) {
                var j = 0, len = arg.length;
                for (output += "["; len > j; ) output = output + (j > 0 ? "," : "") + stringify(arg[j++]);
                output += "]";
            } else output += stringify(arg); else if ("j" === string[cmd + 1]) if (arg = arguments[i++], 
            Array.isArray(arg)) {
                var k = 0, lim = arg.length;
                for (output += "["; lim > k; ) output = output + (k > 0 ? "," : "") + JSON.stringify(arg[k++]);
            } else if ("object" == typeof arg) {
                var objstr = !1;
                try {
                    objstr = JSON.stringify(arg);
                } catch (ex1) {
                    var norm = {};
                    for (var p in arg) if (arg.hasOwnProperty(p)) {
                        var nv, pv = arg[p];
                        if (Array.isArray(pv)) {
                            nv = [];
                            for (var ei = 0, elim = pv.length; elim > ei; ) {
                                var sv, e = pv[ei++];
                                try {
                                    sv = fdjtString(e);
                                } catch (ex2) {
                                    sv = "" + e;
                                }
                                nv.push(sv);
                            }
                        } else try {
                            nv = fdjtString(pv);
                        } catch (ex) {
                            nv = "" + pv;
                        }
                        norm[p] = nv;
                    }
                    objstr = JSON.stringify(norm);
                }
                output += objstr;
            } else output += JSON.stringify(arg); else "x" === string[cmd + 1] && "number" == typeof arguments[i] && arguments[i] >= 0 && arguments[i] % 1 >= 0 ? (arg = arguments[i++], 
            output += arg.toString(16)) : arguments[i] ? output += arguments[i++] : arguments[i] === void 0 ? (output += "?undef?", 
            i++) : output += arguments[i++];
            string = string.slice(cmd + 2), cmd = string.indexOf("%");
        }
        return output += string;
    }
    function stringify(arg) {
        if (arg === void 0) return "?undef?";
        if (arg) {
            if ("number" == typeof arg) return "" + arg;
            if (arg.tagName) {
                var output = "[" + arg.tagName;
                arg.className && (output = output + "." + arg.className.replace(/\s+/g, ".")), arg.id && (output = output + "#" + arg.id), 
                arg.name && (output = output + "[name=" + arg.name + "]");
                var txt = arg.innerText ? arg.innerText.trim() : stripMarkup(arg.innerHTML).trim();
                return txt && 0 !== txt.length && (output = 32 > txt.length ? output + "'" + txt.replace(/\n/g, "\\n") + "'" : output + "'" + txt.slice(0, 16).replace(/\n/g, "\\n") + "'..."), 
                output + "]";
            }
            if (arg.nodeType) return 3 === arg.nodeType ? '["' + arg.nodeValue + '"]' : "<" + arg.nodeType + ">";
            if (arg.oid) return arg.oid;
            if (arg._fdjtid) return "#@" + arg._fdjtid;
            if (arg.type && (arg.target || arg.srcElement)) {
                var target = arg.target || arg.srcElement;
                return "[" + arg.type + "@" + stringify(target) + ((arg.target || arg.srcElement).nodeType ? getDOMEventInfo(arg) : "") + "]";
            }
            return "" + arg;
        }
        return arg;
    }
    function getDOMEventInfo(arg) {
        var info = "(m=" + (arg.shiftKey === !0 ? "s" : "") + (arg.ctrlKey === !0 ? "c" : "") + (arg.metaKey === !0 ? "m" : "") + (arg.altKey === !0 ? "a" : "") + (arg.button !== void 0 ? ",b=" + arg.button : "") + (arg.which !== void 0 ? ",w=" + arg.which : ""), ox = arg.clientX, oy = arg.clientY;
        return ("number" == typeof ox || "number" == typeof oy) && (info = info + ",cx=" + ox + ",cy=" + oy), 
        arg.touches && (info = info + ",touches=" + arg.touches.length), arg.keyCode && (info = info + ",kc=" + arg.keyCode), 
        arg.charCode && (info = info + ",cc=" + arg.charCode), info + ")";
    }
    function ellipsize(string, lim, fudge) {
        var before, after, chopped, broke;
        if ("number" != typeof fudge && (fudge = .1), !lim) return string;
        if ("number" == typeof lim) ; else {
            if (lim.constructor !== Array) return string;
            before = lim[0] || 0, after = lim[1] || 0, lim = after + before;
        }
        if (lim) {
            if (lim + floor(fudge * lim) > string.length) return string;
            if (before && after) {
                var start, end, len = string.length;
                return 0 === /\s/.test(string[before]) ? start = before : (chopped = string.slice(0, before), 
                broke = chopped.search(/\s+\w+$/), start = broke > 0 ? broke : before), 0 === /\s/.test(string[len - after]) ? end = len - after : (chopped = string.slice(len - after), 
                broke = chopped.search(/\s+/), end = broke > 0 ? len - after + broke : after), [ string.slice(0, start), string.slice(end) ];
            }
            var edge = string[lim];
            return 0 === /\s/.test(edge) ? string.slice(0, lim) : (chopped = string.slice(0, lim), 
            broke = chopped.search(/\s+\w+$/), broke > 0 ? chopped.slice(0, broke) : chopped);
        }
        return string;
    }
    function isEmpty(string) {
        if ("string" == typeof string) {
            var pt;
            return 0 === string.length ? !0 : (pt = string.search(notspace), 0 > pt ? !0 : "&" !== string[pt] ? !1 : (string = string.replace(/&nbsp;/g, ""), 
            pt = string.search(notspace), 0 > pt));
        }
        return !1;
    }
    function trim(string) {
        var start = 0, len = string.length;
        if (0 >= len) return string;
        for (;len > start && spacechars.indexOf(string.charAt(start)) > -1; ) start++;
        if (start === len) return "";
        for (var end = len - 1; end > start && spacechars.indexOf(string.charAt(end)) > -1; ) end--;
        return start > 0 || len > end ? string.slice(start, end + 1) : string;
    }
    function stdspace(string) {
        string = string.replace(/\s+/g, " ");
        var start = 0, len = string.length;
        if (0 >= len) return string;
        for (;len > start && spacechars.indexOf(string.charAt(start)) > -1; ) start++;
        if (start === len) return "";
        for (var end = len - 1; end > start && spacechars.indexOf(string.charAt(end)) > -1; ) end--;
        return start > 0 || len > end ? string.slice(start, end + 1) : string;
    }
    function stdcap(string) {
        var somecaps = string.search(/(^|\s)[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/g) >= 0;
        if (!somecaps) return string.replace(/\s+/g, " ").replace(/(^ | $)/g, "");
        for (var words = string.split(/\s+/g), i = 0, lim = words.length; lim > i; ) {
            var word = words[i], weird = word.slice(1).search(/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/) >= 0;
            weird || (words[i] = word[0].toUpperCase() + word.slice(1)), i++;
        }
        return words.join(" ");
    }
    function flatten(string) {
        return string.replace(/\s+/g, " ");
    }
    function oneline(string) {
        string = trim(string);
        var flat = string.replace(/\s*[\f\n\r]+\s+/gm, " // ").replace(/\s*[\f\n\r]+\s*/gm, " // "), tight = flat.replace(/\s\s+/g, "");
        return tight;
    }
    function stripMarkup(string) {
        return string.replace(/<[^>]*>/g, "");
    }
    function unEscape(string) {
        return string.indexOf("\\") >= 0 ? string.replace(/\\(.)/g, "$1") : string;
    }
    function normstring(string) {
        return string.replace(/\W*\s\W*/g, " ").toLowerCase();
    }
    function dCharCode(whole, paren) {
        return String.fromCharCode(parseInt(paren, 10));
    }
    function xCharCode(whole, paren) {
        return String.fromCharCode(parseInt(paren, 16));
    }
    function nCharCode(whole, paren) {
        return fdjt.charnames[paren] || "&" + paren + ";";
    }
    function expandEntity(whole, paren) {
        return entities.hasOwnProperty(paren) ? entities[paren] : "&" + paren + ";";
    }
    function decodeEntities(string) {
        return string.replace(/&#(\d+);/g, dCharCode).replace(/&#x([0123456789ABCDEFabcdef]+);/g, xCharCode).replace(/&([abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.]+)/g, nCharCode).replace(/&([A-Za-z][A-Za-z0-9-_.]+;)/g, expandEntity);
    }
    function expandEntities(string) {
        return string.replace(/&([A-Za-z][A-Za-z0-9-_.]+);/g, expandEntity);
    }
    function getMatch(string, rx, i, literal) {
        var match = rx.exec(string);
        return i === void 0 && (i = 0), match && match.length > i ? literal ? match[i] : numpat.test(match[i]) ? parseFloat(match[i]) : match[i] : !1;
    }
    function segment(string, brk, start, keepspace) {
        start && (string = string.slice(start));
        for (var brk_source = "string" == typeof brk ? brk : brk.source, brk_flags = "string" == typeof brk ? "" : brk.ignoreCase ? "i" : "", brkpat = RegExp("(" + brk_source + ")", brk_flags), results = [], segs = string.split(brkpat), i = 0, lim = segs.length, merged = !1; lim > i; ) {
            var seg = segs[i++], sep = segs[i++];
            if (seg && !(0 > seg.search(/\S/))) if (seg.length && "\\" === seg.slice(-1) && (2 > seg.length || "\\" !== seg.slice(-2, -1))) {
                var unescaped = seg.slice(0, -1) + sep;
                merged ? merged += unescaped : merged = unescaped;
            } else merged ? (keepspace ? results.push(merged + seg) : results.push(stdspace(merged + seg)), 
            merged = !1) : keepspace ? results.push(seg) : results.push(stdspace(seg));
        }
        return results;
    }
    function padNum(num, digits, prec) {
        var ndigits = 10 > num ? 1 : 100 > num ? 2 : 1e3 > num ? 3 : 1e4 > num ? 4 : 1e5 > num ? 5 : 1e6 > num ? 6 : 1e6 > num ? 7 : 1e8 > num ? 8 : 1e9 > num ? 9 : 1e10 > num ? 10 : 11;
        !prec && 0 > digits && (prec = -digits, digits = 0);
        var j, nzeroes = digits - ndigits, numstring = "" + num, point = numstring.indexOf("."), prefix = "", suffix = "";
        if (prec) if (point >= 0 && numstring.length > point + prec) numstring = numstring.slice(0, point + prec + 1); else if (0 > point || point + prec + 1 > numstring.length) {
            j = 0;
            var pad = point + prec + 1 - numstring.length;
            for (0 > point && (suffix += "."); pad > j; ) suffix += "0", j++;
        }
        switch (nzeroes) {
          case 0:
            prefix = "";
            break;

          case 1:
            prefix = "0";
            break;

          case 2:
            prefix = "00";
            break;

          case 3:
            prefix = "000";
            break;

          case 4:
            prefix = "0000";
            break;

          case 5:
            prefix = "00000";
            break;

          case 6:
            prefix = "000000";
            break;

          case 7:
            prefix = "0000000";
            break;

          case 8:
            prefix = "00000000";
            break;

          case 9:
            prefix = "000000000";
            break;

          case 10:
            prefix = "0000000000";
            break;

          default:
            for (j = 0; nzeroes > j; ) prefix += "0", j++;
        }
        return prefix + numstring + suffix;
    }
    function precString(num, prec) {
        var numstring = "" + num, suffix = "";
        if ("number" == typeof prec && prec >= 0 && 100 > prec) {
            var point = numstring.indexOf(".");
            if (point >= 0 && numstring.length > point + prec) numstring = numstring.slice(0, point + prec + 1); else if (0 > point || point + prec + 1 > numstring.length) {
                var j = 0, pad = point + prec + 1 - numstring.length;
                for (0 > point && (suffix = "."); pad >= j; ) suffix += "0", j++;
            }
        }
        return numstring + suffix;
    }
    function getInitials(string, n) {
        for (var words = string.split(/\W/), initials = "", i = 0, lim = n && words.length > n ? n : words.length; lim > i; ) {
            var word = words[i++];
            word.length && (initials += word.slice(0, 1));
        }
        return initials;
    }
    function hasPrefix(string, prefix) {
        return 0 === string.indexOf(prefix);
    }
    function hasSuffix(string, suffix) {
        return string.lastIndexOf(suffix) === string.length - suffix.length;
    }
    function commonPrefix(string1, string2, brk, foldcase) {
        for (var i = 0, last = -1; string1.length > i && string2.length > i && (string1[i] === string2[i] || foldcase && string1[i].toLowerCase() === string2[i].toLowerCase()); ) brk ? brk === string1[i] ? (last = i - 1, 
        i++) : i++ : last = i++;
        return last >= 0 ? string1.slice(0, last + 1) : !1;
    }
    function commonSuffix(string1, string2, brk, foldcase) {
        for (var i = string1.length, j = string2.length, last = 0; i >= 0 && j >= 0 && (string1[i] === string2[j] || foldcase && string1[i].toLowerCase() === string2[i].toLowerCase()); ) brk ? brk === string1[i] ? (last = i + 1, 
        i--, j--) : (i--, j--) : (last = i, i--, j--);
        return last > 0 ? string1.slice(last) : !1;
    }
    function stripSuffix(string) {
        var start = string.search(/\.\w+$/);
        return start > 0 ? string.slice(0, start) : string;
    }
    function arrayContains(array, element) {
        if (array.indexOf) return array.indexOf(element) >= 0;
        for (var i = 0, len = array.length; len > i; ) {
            if (array[i] === element) return !0;
            i++;
        }
        return !1;
    }
    function add_prefix(ptree, string, i) {
        var strings = ptree.strings;
        if (i === string.length) return (strings.indexOf ? strings.indexOf(string) >= 0 : arrayContains(strings, string)) ? !1 : (strings.push(string), 
        !0);
        if (ptree.splits) {
            var splitchar = string[i], split = ptree[splitchar];
            return split || (split = {}, split.strings = [], split.splitchar = splitchar, ptree[splitchar] = split, 
            ptree.splits.push(split)), add_prefix(split, string, i + 1) ? (strings.push(string), 
            !0) : !1;
        }
        if (5 > ptree.strings.length) return (strings.indexOf ? strings.indexOf(string) >= 0 : arrayContains(strings, string)) ? !1 : (strings.push(string), 
        !0);
        ptree.splits = [];
        for (var pstrings = ptree.strings, j = 0; pstrings.length > j; ) add_prefix(ptree, pstrings[j++], i);
        return add_prefix(ptree, string, i);
    }
    function prefixAdd(ptree, string, i) {
        return ("number" != typeof i || 0 > i) && (i = 0), add_prefix(ptree, string, i);
    }
    function find_prefix(ptree, prefix, i, plen) {
        if (plen || (plen = prefix.length), i === plen) return ptree.strings;
        if (5 >= ptree.strings.length) {
            for (var strings = ptree.strings, results = [], j = 0; strings.length > j; ) {
                var string = strings[j++];
                hasPrefix(string, prefix) && results.push(string);
            }
            return results.length ? results : !1;
        }
        var split = ptree[prefix[i]];
        return split ? find_prefix(split, prefix, i + 1, plen) : !1;
    }
    function prefixFind(ptree, prefix, i, plen) {
        return ("number" != typeof i || 0 > i) && (i = 0), plen || (plen = prefix.length), 
        find_prefix(ptree, prefix, i, plen);
    }
    function paraHash(node) {
        var text = "string" == typeof node.innerText ? node.innerText : stripMarkup(node.innerHTML), words = text.split(/\W*\S+\W*/g), len = words.length;
        return "_H" + (len > 0 ? words[0][0] : ".") + (len > 1 ? words[1][0] : ".") + (len > 2 ? words[2][0] : ".") + (len > 3 ? words[3][0] : ".") + (len > 0 ? words[len - 1][0] : ".") + (len > 1 ? words[len - 2][0] : ".") + (len > 2 ? words[len - 3][0] : ".") + (len > 3 ? words[len - 4][0] : ".");
    }
    function escapeRegExp(str) {
        return (str + "").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    function fillIn(text, data) {
        var dom = !1;
        if ("string" == typeof data) {
            var tmp = data;
            data = text, text = tmp;
        }
        if (!text && data && data.template ? text = data.template : !data && text.template && (data = text, 
        text = data.template), "string" == typeof text) ; else if (3 === text.nodeType) dom = text, 
        text = dom.nodeValue; else {
            if (1 !== text.nodeType) return fdjt.Log.warn("Bad argument %o to Template", text), 
            void 0;
            dom = text, text = dom.innerHTML;
        }
        var substs = text.match(/\{\{\w+(\|([^\}])*)?\}\}/gm), done = {};
        if (substs && substs.length) for (var i = 0, n = substs.length; n > i; ) {
            var match = substs[i++], prop = match.slice(2, -2), bar = prop.search(/\|/), propname = bar >= 0 ? prop.slice(0, bar) : prop;
            if (!done[prop] && !done[propname]) if (data.hasOwnProperty(propname)) {
                var val = data[propname];
                if (done[propname] = prop, val) {
                    var pat = RegExp("\\{\\{" + propname + "(\\|[^\\}]*)?\\}\\}", "gm"), stringval = "" + val;
                    text = text.replace(pat, stringval);
                }
            } else if (bar > 0) {
                var replace = prop.slice(bar + 1);
                text = text.replace("{{" + prop + "}}", replace), done[prop] = prop;
            } else fdjt.Log.warn("No data for %s in %j to substitute for %s", propname, data, "{{" + prop + "}}");
        }
        return dom ? (3 === dom.nodeType ? dom.nodeValue = text : dom.innerHTML = text, 
        dom) : text;
    }
    var notspace = /[^ \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff]/g;
    fdjtString.nbsp = "", fdjtString.middot = "", fdjtString.emdash = "", fdjtString.endash = "", 
    fdjtString.lsq = "", fdjtString.rsq = "", fdjtString.ldq = "", fdjtString.rdq = "";
    var spacechars = " \n\r	\f\u2028\u2029";
    fdjtString.truncate = function(string, lim) {
        return lim || (lim = 42), lim > string.length ? string : string.slice(0, lim);
    };
    var floor = Math.floor;
    fdjtString.ellipsize = ellipsize, fdjtString.isEmpty = isEmpty, fdjtString.findSplit = function(string, split, escape) {
        for (var next, start = 0; (next = string.indexOf(split, start)) >= 0; ) {
            if (!(escape && next > 0 && string[next - 1] === escape)) return next;
            start = next + 1;
        }
        return -1;
    }, fdjtString.split = function(string, split, escape, mapfn) {
        if (mapfn || escape) {
            for (var next, results = [], start = 0; (next = string.indexOf(split, start)) >= 0; ) escape && next > 0 && string[next - 1] === escape ? start = next + 1 : mapfn && next > start ? (results.push(mapfn(string.slice(start, next))), 
            start = next + 1) : next > start ? (results.push(string.slice(start, next)), start = next + 1) : start = next + 1;
            return string.length > start && (mapfn ? results.push(mapfn(string.slice(start))) : results.push(string.slice(start))), 
            results;
        }
        return string.split(split);
    }, fdjtString.semiSplit = function(string, escape, mapfn) {
        if (mapfn || escape) {
            for (var next, results = [], start = 0; (next = string.indexOf(";", start)) >= 0; ) escape && next > 0 && string[next - 1] === escape ? start = next + 1 : mapfn && next > start ? (results.push(mapfn(string.slice(start, next))), 
            start = next + 1) : next > start ? (results.push(string.slice(start, next)), start = next + 1) : start = next + 1;
            return string.length > start && (mapfn ? results.push(mapfn(string.slice(start))) : results.push(string.slice(start))), 
            results;
        }
        return string.split(";");
    }, fdjtString.lineSplit = function(string, escape, mapfn) {
        if (mapfn || escape) {
            for (var next, results = [], start = 0; (next = string.indexOf("\n", start)) >= 0; ) escape && next > 0 && string[next - 1] === escape ? start = next + 1 : mapfn && next > start ? (results.push(mapfn(string.slice(start, next))), 
            start = next + 1) : next > start ? (results.push(string.slice(start, next)), start = next + 1) : start = next + 1;
            return string.length > start && (mapfn ? results.push(mapfn(string.slice(start))) : results.push(string.slice(start))), 
            results;
        }
        return string.split("\n");
    }, fdjtString.trim = trim, fdjtString.stdspace = stdspace, fdjtString.stdcap = stdcap, 
    fdjtString.flatten = flatten, fdjtString.oneline = oneline, fdjtString.stripMarkup = stripMarkup, 
    fdjtString.unEscape = unEscape, fdjtString.normString = normstring;
    var entities = {};
    fdjtString.entities = entities, fdjtString.decodeEntities = decodeEntities, fdjtString.expandEntities = expandEntities;
    var numpat = /^\d+(\.\d+)$/;
    return fdjtString.getMatch = getMatch, fdjtString.segment = segment, fdjtString.padNum = padNum, 
    fdjtString.precString = precString, fdjtString.getInitials = getInitials, fdjtString.hasPrefix = hasPrefix, 
    fdjtString.hasSuffix = hasSuffix, fdjtString.commonPrefix = commonPrefix, fdjtString.commonSuffix = commonSuffix, 
    fdjtString.stripSuffix = stripSuffix, fdjtString.prefixAdd = prefixAdd, fdjtString.prefixFind = prefixFind, 
    fdjtString.paraHash = paraHash, fdjtString.escapeRegExp = escapeRegExp, fdjtString.escapeRX = escapeRegExp, 
    fdjtString.templates = {}, fdjtString.fillIn = fillIn, fdjtString;
}(), fdjt.Time = function() {
    "use strict";
    function _(x) {
        return x;
    }
    function fdjtTime() {
        return new Date().getTime();
    }
    function shortString(tstamp) {
        var now = new Date();
        "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp));
        var diff = (now.getTime() - tstamp.getTime()) / 1e3;
        if (diff > 43200) return tstamp.toDateString();
        var hours = tstamp.getHours(), minutes = tstamp.getMinutes();
        return tstamp.toDateString() + " (" + (10 > hours ? "0" : "") + hours + ":" + (0 === minutes ? "00" : (10 > minutes ? "0" : "") + minutes) + ")";
    }
    function compactString(tstamp, curdate) {
        "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp));
        var date_string = tstamp.toLocaleDateString();
        curdate === void 0 && (first_date ? curdate = first_date : first_date = new Date().toLocaleDateString());
        var show_date = date_string !== curdate, hours = tstamp.getHours(), minutes = tstamp.getMinutes(), seconds = tstamp.getSeconds();
        return (show_date ? date_string : "") + (show_date ? " - " : "") + (10 > hours ? "0" : "") + hours + ":" + (0 === minutes ? "00" : (10 > minutes ? "0" : "") + minutes) + ":" + (0 === seconds ? "00" : (10 > seconds ? "0" : "") + seconds);
    }
    var loaded = fdjtTime.loaded = new Date().getTime();
    fdjtTime.tick = function() {
        return Math.floor(new Date().getTime() / 1e3);
    }, fdjtTime.dateString = function(tstamp) {
        return "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp)), 
        tstamp.toDateString();
    }, fdjtTime.timeString = function(tstamp) {
        return "number" == typeof tstamp && (tstamp = 131592918600 > tstamp ? new Date(1e3 * tstamp) : new Date(tstamp)), 
        "" + tstamp;
    }, fdjtTime.shortString = shortString, fdjtTime.tick2shortstring = function(tick) {
        return shortString(new Date(1e3 * tick));
    };
    var first_date = !1;
    fdjtTime.compactString = compactString, fdjtTime.tick2string = function(tick) {
        return "" + new Date(1e3 * tick);
    }, fdjtTime.tick2date = function(tick) {
        return new Date(1e3 * tick).toDateString();
    }, fdjtTime.tick2locale = function(tick) {
        return new Date(1e3 * tick).toLocaleString();
    }, fdjtTime.tick2time = function(tick) {
        return new Date(1e3 * tick).toTimeString();
    };
    var fmt = fdjt.String;
    fdjtTime.secs2string = function(interval) {
        var weeks, days, hours, minutes, seconds;
        return 1 > interval ? fmt("%f seconds", interval) : 1 === interval ? fmt("%f second", interval) : 10 > interval ? fmt("%f seconds", interval) : 60 > interval ? fmt("~%d seconds", Math.round(interval / 60)) : 120 > interval ? (minutes = Math.floor(interval / 60), 
        seconds = Math.round(interval - 60 * minutes), 1 === seconds ? _("one minute, one second") : fmt("one minute, %d seconds", seconds)) : 3600 > interval ? (minutes = Math.floor(interval / 60), 
        fmt("~%d minutes", minutes)) : 7200 > interval ? (hours = Math.floor(interval / 3600), 
        minutes = Math.round((interval - 3600 * hours) / 60), 1 === minutes ? _("one hour and one minutes") : fmt("one hour, %d minutes", minutes)) : 86400 > interval ? (hours = Math.floor(interval / 3600), 
        fmt("~%d hours", hours)) : 172800 > interval ? (hours = Math.floor((interval - 86400) / 3600), 
        1 === hours ? _("one day and one hour") : fmt("one day, %d hours", hours)) : 604800 > interval ? (days = Math.floor(interval / 86400), 
        fmt("%d days", days)) : 1209600 > interval ? (days = Math.floor((interval - 604800) / 86400), 
        1 === days ? "one week and one day" : fmt("one week and %d days", days)) : (weeks = Math.floor(interval / 604800), 
        days = Math.round((interval - 3600 * 24 * 7 * days) / 604800), fmt("%d weeks, %d days", weeks, days));
    }, fdjtTime.secs2short = function(interval) {
        if (.001 > interval) return Math.round(1e6 * interval) + "us";
        if (.1 > interval) return Math.round(1e3 * interval) + "ms";
        if (120 > interval) return Math.round(100 * interval) / 100 + "s";
        var min = Math.floor(interval / 60), secs = interval - 60 * min;
        return min + "m, " + Math.round(100 * secs) / 100 + "s";
    }, fdjtTime.runTimes = function(pname, start) {
        for (var point = start, report = "", i = 2; arguments.length > i; ) {
            var phase = arguments[i++], time = arguments[i++];
            report = report + "; " + phase + ": " + (time.getTime() - point.getTime()) / 1e3 + "s", 
            point = time;
        }
        return pname + " " + (point.getTime() - start.getTime()) / 1e3 + "s" + report;
    }, fdjtTime.diffTime = function(time1, time2) {
        time2 || (time2 = new Date());
        var diff = time1.getTime() - time2.getTime();
        return diff > 0 ? diff / 1e3 : -(diff / 1e3);
    }, fdjtTime.ET = function(arg) {
        return arg || (arg = new Date()), (arg.getTime() - loaded) / 1e3;
    };
    var tzpat = /(EST|EDT|PDT|PST|CST|CDT|ECT|GMT|Z|([+-]\d\d?(:\d+)?))$/i;
    return fdjtTime.parse = function(string) {
        var value = !1;
        try {
            value = Date.parse ? new Date(Date.parse(string)) : new Date(string);
        } catch (ex) {
            fdjt.Log("Error parsing time '%s': %o", string, ex);
        }
        if (value instanceof Date && !isNaN(value.getYear())) return value;
        var strip = string.search(tzpat);
        return strip > 0 ? fdjtTime.parse(string.slice(0, strip)) : (fdjt.Log("Couldn't parse time '%s'", string), 
        string);
    }, fdjtTime.timeslice = fdjt.Async.timeslice, fdjtTime.slowmap = fdjt.Async.slowmap, 
    fdjtTime;
}(), fdjt.ET = fdjt.Time.ET, fdjt.Template = function() {
    "use strict";
    function Template(text, data, xdata) {
        var dom = !1;
        if ("string" == typeof data) {
            var tmp = data;
            data = text, text = tmp;
        }
        if (!text && data && data.template && (text = data.template), "string" == typeof text) ; else if (3 === text.nodeType) dom = text, 
        text = dom.nodeValue; else {
            if (1 !== text.nodeType) return fdjt.Log.warn("Bad argument %o to Template", text), 
            void 0;
            dom = text, text = dom.innerHTML;
        }
        Template.localTemplates.hasOwnProperty(text) ? text = Template.localTemplates[text] : templates.hasOwnProperty(text) && (text = templates[text]);
        var substs = text.match(/\{\{\w+\}\}/gm), done = {};
        if (substs) for (var i = 0, n = substs.length; n > i; ) {
            var match = substs[i++], prop = match.slice(2, -2), pat = RegExp("\\{\\{" + prop + "\\}\\}", "gm");
            if (!done[prop]) if (data.hasOwnProperty(prop) || xdata && xdata.hasOwnProperty(prop)) {
                var val = data[prop] || xdata && xdata[prop] || "";
                done[prop] = prop, text = text.replace(pat, "" + val);
            } else fdjt.Log.warn("No data for %s in %s to use in %s", prop, data, text), done[prop] = prop;
        }
        return dom ? (3 === dom.nodeType ? dom.nodeValue = text : dom.innerHTML = text, 
        dom) : text;
    }
    function toDOM(text, data, dom_arg) {
        var output = template(text, data), dom = dom_arg ? dom_arg.nodeType ? dom_arg : "string" == typeof dom_arg ? document.createElement(dom_arg) : document.createElement("div") : document.createElement("div");
        if (dom.innerHTML = output, dom_arg && dom_arg.nodeType) return dom;
        if (dom.childNodes) {
            if (1 === dom.childNodes.length) return dom.childNodes[0];
            for (var frag = document.createDocumentFragment, nodes = [], children = dom.childNodes, i = 0, lim = children.length; lim > i; ) nodes.push(children[i++]);
            for (i = 0; lim > i; ) frag.appendChild(nodes[i++]);
            return frag;
        }
        return !1;
    }
    var templates = {}, template = Template;
    return fdjt.Templates = templates, Template.localTemplates = {}, Template.toDOM = toDOM, 
    Template;
}(), fdjt.Hash || (fdjt.Hash = function() {
    "use strict";
    function gethexcase() {
        return hexcase_default;
    }
    function sethexcase(v) {
        hexcase_default = v;
    }
    function getpadchar() {
        return b64pad_default;
    }
    function setpadchar(v) {
        b64pad_default = v;
    }
    function getenc() {}
    function setenc(v) {
        enc = "string" == typeof v ? fdjt.Hash[v] || !1 : v;
    }
    function rstr2binb(input) {
        var i, output = Array(input.length >> 2);
        for (i = 0; output.length > i; i++) output[i] = 0;
        for (i = 0; 8 * input.length > i; i += 8) output[i >> 5] |= (255 & input.charCodeAt(i / 8)) << 24 - i % 32;
        return output;
    }
    function binb2rstr(input) {
        for (var output = "", i = 0; 32 * input.length > i; i += 8) output += String.fromCharCode(255 & input[i >> 5] >>> 24 - i % 32);
        return output;
    }
    function rstr2hex(input, hexcase) {
        hexcase === void 0 && (hexcase = hexcase_default);
        for (var x, hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef", output = "", i = 0; input.length > i; i++) x = input.charCodeAt(i), 
        output += hex_tab.charAt(15 & x >>> 4) + hex_tab.charAt(15 & x);
        return output;
    }
    function rstr2b64(input, b64pad) {
        b64pad || (b64pad = b64pad_default);
        for (var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", output = "", len = input.length, i = 0; len > i; i += 3) for (var triplet = input.charCodeAt(i) << 16 | (len > i + 1 ? input.charCodeAt(i + 1) << 8 : 0) | (len > i + 2 ? input.charCodeAt(i + 2) : 0), j = 0; 4 > j; j++) output += 8 * i + 6 * j > 8 * input.length ? b64pad : tab.charAt(63 & triplet >>> 6 * (3 - j));
        return output;
    }
    function rstr2any(input, encoding) {
        if (!encoding) return enc ? enc(input) : rstr2hex(input);
        var i, j, q, x, quotient, divisor = encoding.length, dividend = Array(Math.ceil(input.length / 2));
        for (i = 0; dividend.length > i; i++) dividend[i] = input.charCodeAt(2 * i) << 8 | input.charCodeAt(2 * i + 1);
        var full_length = Math.ceil(8 * input.length / (Math.log(encoding.length) / Math.log(2))), remainders = Array(full_length);
        for (j = 0; full_length > j; j++) {
            for (quotient = [], x = 0, i = 0; dividend.length > i; i++) x = (x << 16) + dividend[i], 
            q = Math.floor(x / divisor), x -= q * divisor, (quotient.length > 0 || q > 0) && (quotient[quotient.length] = q);
            remainders[j] = x, dividend = quotient;
        }
        var output = "";
        for (i = remainders.length - 1; i >= 0; i--) output += encoding.charAt(remainders[i]);
        return output;
    }
    function str2rstr_utf8(input) {
        for (var x, y, output = "", i = -1; input.length > ++i; ) x = input.charCodeAt(i), 
        y = input.length > i + 1 ? input.charCodeAt(i + 1) : 0, x >= 55296 && 56319 >= x && y >= 56320 && 57343 >= y && (x = 65536 + ((1023 & x) << 10) + (1023 & y), 
        i++), 127 >= x ? output += String.fromCharCode(x) : 2047 >= x ? output += String.fromCharCode(192 | 31 & x >>> 6, 128 | 63 & x) : 65535 >= x ? output += String.fromCharCode(224 | 15 & x >>> 12, 128 | 63 & x >>> 6, 128 | 63 & x) : 2097151 >= x && (output += String.fromCharCode(240 | 7 & x >>> 18, 128 | 63 & x >>> 12, 128 | 63 & x >>> 6, 128 | 63 & x));
        return output;
    }
    function rstr2binl(input) {
        var i, output = Array(input.length >> 2);
        for (i = 0; output.length > i; i++) output[i] = 0;
        for (i = 0; 8 * input.length > i; i += 8) output[i >> 5] |= (255 & input.charCodeAt(i / 8)) << i % 32;
        return output;
    }
    function binl2rstr(input) {
        for (var output = "", i = 0; 32 * input.length > i; i += 8) output += String.fromCharCode(255 & input[i >> 5] >>> i % 32);
        return output;
    }
    function safe_add(x, y) {
        var lsw = (65535 & x) + (65535 & y), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | 65535 & lsw;
    }
    function bit_rol(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
    }
    function hex_md5(s) {
        return rstr2hex(rstr_md5(str2rstr_utf8(s)));
    }
    function b64_md5(s) {
        return rstr2b64(rstr_md5(str2rstr_utf8(s)));
    }
    function any_md5(s, e) {
        return rstr2any(rstr_md5(str2rstr_utf8(s)), e);
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_md5(k, d) {
        return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_md5(k, d, e) {
        return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), 8 * s.length));
    }
    function rstr_hmac_md5(key, data) {
        var bkey = rstr2binl(key);
        bkey.length > 16 && (bkey = binl_md5(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + 8 * data.length);
        return binl2rstr(binl_md5(opad.concat(hash), 640));
    }
    function binl_md5(x, len) {
        x[len >> 5] |= 128 << len % 32, x[(len + 64 >>> 9 << 4) + 14] = len;
        for (var a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, i = 0; x.length > i; i += 16) {
            var olda = a, oldb = b, oldc = c, oldd = d;
            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936), d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586), 
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819), b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330), 
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897), d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426), 
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341), b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983), 
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416), d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417), 
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063), b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162), 
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682), d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101), 
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290), b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329), 
            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510), d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632), 
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713), b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302), 
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691), d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083), 
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335), b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848), 
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438), d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690), 
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961), b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501), 
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467), d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784), 
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473), b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734), 
            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558), d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463), 
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562), b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556), 
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060), d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353), 
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632), b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640), 
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174), d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222), 
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979), b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189), 
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487), d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835), 
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520), b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651), 
            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844), d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415), 
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905), b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055), 
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571), d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606), 
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523), b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799), 
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359), d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744), 
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380), b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649), 
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070), d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379), 
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259), b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551), 
            a = safe_add(a, olda), b = safe_add(b, oldb), c = safe_add(c, oldc), d = safe_add(d, oldd);
        }
        return Array(a, b, c, d);
    }
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    function hex_rmd160(s) {
        return rstr2hex(rstr_rmd160(str2rstr_utf8(s)));
    }
    function b64_rmd160(s) {
        return rstr2b64(rstr_rmd160(str2rstr_utf8(s)));
    }
    function any_rmd160(s, e) {
        return rstr2any(rstr_rmd160(str2rstr_utf8(s)), e);
    }
    function hex_hmac_rmd160(k, d) {
        return rstr2hex(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_rmd160(k, d) {
        return rstr2b64(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_rmd160(k, d, e) {
        return rstr2any(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_rmd160(s) {
        return binl2rstr(binl_rmd160(rstr2binl(s), 8 * s.length));
    }
    function rstr_hmac_rmd160(key, data) {
        var bkey = rstr2binl(key);
        bkey.length > 16 && (bkey = binl_rmd160(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binl_rmd160(ipad.concat(rstr2binl(data)), 512 + 8 * data.length);
        return binl2rstr(binl_rmd160(opad.concat(hash), 672));
    }
    function binl_rmd160(x, len) {
        x[len >> 5] |= 128 << len % 32, x[(len + 64 >>> 9 << 4) + 14] = len;
        for (var h0 = 1732584193, h1 = 4023233417, h2 = 2562383102, h3 = 271733878, h4 = 3285377520, i = 0; x.length > i; i += 16) {
            for (var T, A1 = h0, B1 = h1, C1 = h2, D1 = h3, E1 = h4, A2 = h0, B2 = h1, C2 = h2, D2 = h3, E2 = h4, j = 0; 79 >= j; ++j) T = safe_add(A1, rmd160_f(j, B1, C1, D1)), 
            T = safe_add(T, x[i + rmd160_r1[j]]), T = safe_add(T, rmd160_K1(j)), T = safe_add(bit_rol(T, rmd160_s1[j]), E1), 
            A1 = E1, E1 = D1, D1 = bit_rol(C1, 10), C1 = B1, B1 = T, T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2)), 
            T = safe_add(T, x[i + rmd160_r2[j]]), T = safe_add(T, rmd160_K2(j)), T = safe_add(bit_rol(T, rmd160_s2[j]), E2), 
            A2 = E2, E2 = D2, D2 = bit_rol(C2, 10), C2 = B2, B2 = T;
            T = safe_add(h1, safe_add(C1, D2)), h1 = safe_add(h2, safe_add(D1, E2)), h2 = safe_add(h3, safe_add(E1, A2)), 
            h3 = safe_add(h4, safe_add(A1, B2)), h4 = safe_add(h0, safe_add(B1, C2)), h0 = T;
        }
        return [ h0, h1, h2, h3, h4 ];
    }
    function rmd160_f(j, x, y, z) {
        return j >= 0 && 15 >= j ? x ^ y ^ z : j >= 16 && 31 >= j ? x & y | ~x & z : j >= 32 && 47 >= j ? (x | ~y) ^ z : j >= 48 && 63 >= j ? x & z | y & ~z : j >= 64 && 79 >= j ? x ^ (y | ~z) : "rmd160_f: j out of range";
    }
    function rmd160_K1(j) {
        return j >= 0 && 15 >= j ? 0 : j >= 16 && 31 >= j ? 1518500249 : j >= 32 && 47 >= j ? 1859775393 : j >= 48 && 63 >= j ? 2400959708 : j >= 64 && 79 >= j ? 2840853838 : "rmd160_K1: j out of range";
    }
    function rmd160_K2(j) {
        return j >= 0 && 15 >= j ? 1352829926 : j >= 16 && 31 >= j ? 1548603684 : j >= 32 && 47 >= j ? 1836072691 : j >= 48 && 63 >= j ? 2053994217 : j >= 64 && 79 >= j ? 0 : "rmd160_K2: j out of range";
    }
    function hex_sha1(s) {
        return rstr2hex(rstr_sha1(str2rstr_utf8(s)));
    }
    function b64_sha1(s) {
        return rstr2b64(rstr_sha1(str2rstr_utf8(s)));
    }
    function any_sha1(s, e) {
        return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);
    }
    function hex_hmac_sha1(k, d) {
        return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_sha1(k, d) {
        return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_sha1(k, d, e) {
        return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_sha1(s) {
        return binb2rstr(binb_sha1(rstr2binb(s), 8 * s.length));
    }
    function rstr_hmac_sha1(key, data) {
        var bkey = rstr2binb(key);
        bkey.length > 16 && (bkey = binb_sha1(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + 8 * data.length);
        return binb2rstr(binb_sha1(opad.concat(hash), 672));
    }
    function binb_sha1(x, len) {
        x[len >> 5] |= 128 << 24 - len % 32, x[(len + 64 >> 9 << 4) + 15] = len;
        for (var w = Array(80), a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, e = -1009589776, i = 0; x.length > i; i += 16) {
            for (var olda = a, oldb = b, oldc = c, oldd = d, olde = e, j = 0; 80 > j; j++) {
                w[j] = 16 > j ? x[i + j] : bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
                e = d, d = c, c = bit_rol(b, 30), b = a, a = t;
            }
            a = safe_add(a, olda), b = safe_add(b, oldb), c = safe_add(c, oldc), d = safe_add(d, oldd), 
            e = safe_add(e, olde);
        }
        return Array(a, b, c, d, e);
    }
    function sha1_ft(t, b, c, d) {
        return 20 > t ? b & c | ~b & d : 40 > t ? b ^ c ^ d : 60 > t ? b & c | b & d | c & d : b ^ c ^ d;
    }
    function sha1_kt(t) {
        return 20 > t ? 1518500249 : 40 > t ? 1859775393 : 60 > t ? -1894007588 : -899497514;
    }
    function hex_sha256(s) {
        return rstr2hex(rstr_sha256(str2rstr_utf8(s)));
    }
    function b64_sha256(s) {
        return rstr2b64(rstr_sha256(str2rstr_utf8(s)));
    }
    function any_sha256(s, e) {
        return rstr2any(rstr_sha256(str2rstr_utf8(s)), e);
    }
    function hex_hmac_sha256(k, d) {
        return rstr2hex(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_sha256(k, d) {
        return rstr2b64(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_sha256(k, d, e) {
        return rstr2any(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_sha256(s) {
        return binb2rstr(binb_sha256(rstr2binb(s), 8 * s.length));
    }
    function rstr_hmac_sha256(key, data) {
        var bkey = rstr2binb(key);
        bkey.length > 16 && (bkey = binb_sha256(bkey, 8 * key.length));
        for (var ipad = Array(16), opad = Array(16), i = 0; 16 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binb_sha256(ipad.concat(rstr2binb(data)), 512 + 8 * data.length);
        return binb2rstr(binb_sha256(opad.concat(hash), 768));
    }
    function sha256_S(X, n) {
        return X >>> n | X << 32 - n;
    }
    function sha256_R(X, n) {
        return X >>> n;
    }
    function sha256_Ch(x, y, z) {
        return x & y ^ ~x & z;
    }
    function sha256_Maj(x, y, z) {
        return x & y ^ x & z ^ y & z;
    }
    function sha256_Sigma0256(x) {
        return sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22);
    }
    function sha256_Sigma1256(x) {
        return sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25);
    }
    function sha256_Gamma0256(x) {
        return sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3);
    }
    function sha256_Gamma1256(x) {
        return sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10);
    }
    function binb_sha256(m, l) {
        var a, b, c, d, e, f, g, h, i, j, T1, T2, HASH = Array(1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225), W = Array(64);
        for (m[l >> 5] |= 128 << 24 - l % 32, m[(l + 64 >> 9 << 4) + 15] = l, i = 0; m.length > i; i += 16) {
            for (a = HASH[0], b = HASH[1], c = HASH[2], d = HASH[3], e = HASH[4], f = HASH[5], 
            g = HASH[6], h = HASH[7], j = 0; 64 > j; j++) W[j] = 16 > j ? m[j + i] : safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]), sha256_Gamma0256(W[j - 15])), W[j - 16]), 
            T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)), sha256_K[j]), W[j]), 
            T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c)), h = g, g = f, f = e, e = safe_add(d, T1), 
            d = c, c = b, b = a, a = safe_add(T1, T2);
            HASH[0] = safe_add(a, HASH[0]), HASH[1] = safe_add(b, HASH[1]), HASH[2] = safe_add(c, HASH[2]), 
            HASH[3] = safe_add(d, HASH[3]), HASH[4] = safe_add(e, HASH[4]), HASH[5] = safe_add(f, HASH[5]), 
            HASH[6] = safe_add(g, HASH[6]), HASH[7] = safe_add(h, HASH[7]);
        }
        return HASH;
    }
    function hex_sha512(s) {
        return rstr2hex(rstr_sha512(str2rstr_utf8(s)));
    }
    function b64_sha512(s) {
        return rstr2b64(rstr_sha512(str2rstr_utf8(s)));
    }
    function any_sha512(s, e) {
        return rstr2any(rstr_sha512(str2rstr_utf8(s)), e);
    }
    function hex_hmac_sha512(k, d) {
        return rstr2hex(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function b64_hmac_sha512(k, d) {
        return rstr2b64(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)));
    }
    function any_hmac_sha512(k, d, e) {
        return rstr2any(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)), e);
    }
    function rstr_sha512(s) {
        return binb2rstr(binb_sha512(rstr2binb(s), 8 * s.length));
    }
    function rstr_hmac_sha512(key, data) {
        var bkey = rstr2binb(key);
        bkey.length > 32 && (bkey = binb_sha512(bkey, 8 * key.length));
        for (var ipad = Array(32), opad = Array(32), i = 0; 32 > i; i++) ipad[i] = 909522486 ^ bkey[i], 
        opad[i] = 1549556828 ^ bkey[i];
        var hash = binb_sha512(ipad.concat(rstr2binb(data)), 1024 + 8 * data.length);
        return binb2rstr(binb_sha512(opad.concat(hash), 1536));
    }
    function binb_sha512(x, len) {
        void 0 === sha512_k && (sha512_k = Array(new Int64(1116352408, -685199838), new Int64(1899447441, 602891725), new Int64(-1245643825, -330482897), new Int64(-373957723, -2121671748), new Int64(961987163, -213338824), new Int64(1508970993, -1241133031), new Int64(-1841331548, -1357295717), new Int64(-1424204075, -630357736), new Int64(-670586216, -1560083902), new Int64(310598401, 1164996542), new Int64(607225278, 1323610764), new Int64(1426881987, -704662302), new Int64(1925078388, -226784913), new Int64(-2132889090, 991336113), new Int64(-1680079193, 633803317), new Int64(-1046744716, -815192428), new Int64(-459576895, -1628353838), new Int64(-272742522, 944711139), new Int64(264347078, -1953704523), new Int64(604807628, 2007800933), new Int64(770255983, 1495990901), new Int64(1249150122, 1856431235), new Int64(1555081692, -1119749164), new Int64(1996064986, -2096016459), new Int64(-1740746414, -295247957), new Int64(-1473132947, 766784016), new Int64(-1341970488, -1728372417), new Int64(-1084653625, -1091629340), new Int64(-958395405, 1034457026), new Int64(-710438585, -1828018395), new Int64(113926993, -536640913), new Int64(338241895, 168717936), new Int64(666307205, 1188179964), new Int64(773529912, 1546045734), new Int64(1294757372, 1522805485), new Int64(1396182291, -1651133473), new Int64(1695183700, -1951439906), new Int64(1986661051, 1014477480), new Int64(-2117940946, 1206759142), new Int64(-1838011259, 344077627), new Int64(-1564481375, 1290863460), new Int64(-1474664885, -1136513023), new Int64(-1035236496, -789014639), new Int64(-949202525, 106217008), new Int64(-778901479, -688958952), new Int64(-694614492, 1432725776), new Int64(-200395387, 1467031594), new Int64(275423344, 851169720), new Int64(430227734, -1194143544), new Int64(506948616, 1363258195), new Int64(659060556, -544281703), new Int64(883997877, -509917016), new Int64(958139571, -976659869), new Int64(1322822218, -482243893), new Int64(1537002063, 2003034995), new Int64(1747873779, -692930397), new Int64(1955562222, 1575990012), new Int64(2024104815, 1125592928), new Int64(-2067236844, -1578062990), new Int64(-1933114872, 442776044), new Int64(-1866530822, 593698344), new Int64(-1538233109, -561857047), new Int64(-1090935817, -1295615723), new Int64(-965641998, -479046869), new Int64(-903397682, -366583396), new Int64(-779700025, 566280711), new Int64(-354779690, -840897762), new Int64(-176337025, -294727304), new Int64(116418474, 1914138554), new Int64(174292421, -1563912026), new Int64(289380356, -1090974290), new Int64(460393269, 320620315), new Int64(685471733, 587496836), new Int64(852142971, 1086792851), new Int64(1017036298, 365543100), new Int64(1126000580, -1676669620), new Int64(1288033470, -885112138), new Int64(1501505948, -60457430), new Int64(1607167915, 987167468), new Int64(1816402316, 1246189591)));
        var j, i, H = Array(new Int64(1779033703, -205731576), new Int64(-1150833019, -2067093701), new Int64(1013904242, -23791573), new Int64(-1521486534, 1595750129), new Int64(1359893119, -1377402159), new Int64(-1694144372, 725511199), new Int64(528734635, -79577749), new Int64(1541459225, 327033209)), T1 = new Int64(0, 0), T2 = new Int64(0, 0), a = new Int64(0, 0), b = new Int64(0, 0), c = new Int64(0, 0), d = new Int64(0, 0), e = new Int64(0, 0), f = new Int64(0, 0), g = new Int64(0, 0), h = new Int64(0, 0), s0 = new Int64(0, 0), s1 = new Int64(0, 0), Ch = new Int64(0, 0), Maj = new Int64(0, 0), r1 = new Int64(0, 0), r2 = new Int64(0, 0), r3 = new Int64(0, 0), W = Array(80);
        for (i = 0; 80 > i; i++) W[i] = new Int64(0, 0);
        for (x[len >> 5] |= 128 << 24 - (31 & len), x[(len + 128 >> 10 << 5) + 31] = len, 
        i = 0; x.length > i; i += 32) {
            for (int64copy(a, H[0]), int64copy(b, H[1]), int64copy(c, H[2]), int64copy(d, H[3]), 
            int64copy(e, H[4]), int64copy(f, H[5]), int64copy(g, H[6]), int64copy(h, H[7]), 
            j = 0; 16 > j; j++) W[j].h = x[i + 2 * j], W[j].l = x[i + 2 * j + 1];
            for (j = 16; 80 > j; j++) int64rrot(r1, W[j - 2], 19), int64revrrot(r2, W[j - 2], 29), 
            int64shr(r3, W[j - 2], 6), s1.l = r1.l ^ r2.l ^ r3.l, s1.h = r1.h ^ r2.h ^ r3.h, 
            int64rrot(r1, W[j - 15], 1), int64rrot(r2, W[j - 15], 8), int64shr(r3, W[j - 15], 7), 
            s0.l = r1.l ^ r2.l ^ r3.l, s0.h = r1.h ^ r2.h ^ r3.h, int64add4(W[j], s1, W[j - 7], s0, W[j - 16]);
            for (j = 0; 80 > j; j++) Ch.l = e.l & f.l ^ ~e.l & g.l, Ch.h = e.h & f.h ^ ~e.h & g.h, 
            int64rrot(r1, e, 14), int64rrot(r2, e, 18), int64revrrot(r3, e, 9), s1.l = r1.l ^ r2.l ^ r3.l, 
            s1.h = r1.h ^ r2.h ^ r3.h, int64rrot(r1, a, 28), int64revrrot(r2, a, 2), int64revrrot(r3, a, 7), 
            s0.l = r1.l ^ r2.l ^ r3.l, s0.h = r1.h ^ r2.h ^ r3.h, Maj.l = a.l & b.l ^ a.l & c.l ^ b.l & c.l, 
            Maj.h = a.h & b.h ^ a.h & c.h ^ b.h & c.h, int64add5(T1, h, s1, Ch, sha512_k[j], W[j]), 
            int64add(T2, s0, Maj), int64copy(h, g), int64copy(g, f), int64copy(f, e), int64add(e, d, T1), 
            int64copy(d, c), int64copy(c, b), int64copy(b, a), int64add(a, T1, T2);
            int64add(H[0], H[0], a), int64add(H[1], H[1], b), int64add(H[2], H[2], c), int64add(H[3], H[3], d), 
            int64add(H[4], H[4], e), int64add(H[5], H[5], f), int64add(H[6], H[6], g), int64add(H[7], H[7], h);
        }
        var hash = Array(16);
        for (i = 0; 8 > i; i++) hash[2 * i] = H[i].h, hash[2 * i + 1] = H[i].l;
        return hash;
    }
    function Int64(h, l) {
        this.h = h, this.l = l;
    }
    function int64copy(dst, src) {
        dst.h = src.h, dst.l = src.l;
    }
    function int64rrot(dst, x, shift) {
        dst.l = x.l >>> shift | x.h << 32 - shift, dst.h = x.h >>> shift | x.l << 32 - shift;
    }
    function int64revrrot(dst, x, shift) {
        dst.l = x.h >>> shift | x.l << 32 - shift, dst.h = x.l >>> shift | x.h << 32 - shift;
    }
    function int64shr(dst, x, shift) {
        dst.l = x.l >>> shift | x.h << 32 - shift, dst.h = x.h >>> shift;
    }
    function int64add(dst, x, y) {
        var w0 = (65535 & x.l) + (65535 & y.l), w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16), w2 = (65535 & x.h) + (65535 & y.h) + (w1 >>> 16), w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);
        dst.l = 65535 & w0 | w1 << 16, dst.h = 65535 & w2 | w3 << 16;
    }
    function int64add4(dst, a, b, c, d) {
        var w0 = (65535 & a.l) + (65535 & b.l) + (65535 & c.l) + (65535 & d.l), w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (w0 >>> 16), w2 = (65535 & a.h) + (65535 & b.h) + (65535 & c.h) + (65535 & d.h) + (w1 >>> 16), w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (w2 >>> 16);
        dst.l = 65535 & w0 | w1 << 16, dst.h = 65535 & w2 | w3 << 16;
    }
    function int64add5(dst, a, b, c, d, e) {
        var w0 = (65535 & a.l) + (65535 & b.l) + (65535 & c.l) + (65535 & d.l) + (65535 & e.l), w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (e.l >>> 16) + (w0 >>> 16), w2 = (65535 & a.h) + (65535 & b.h) + (65535 & c.h) + (65535 & d.h) + (65535 & e.h) + (w1 >>> 16), w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (e.h >>> 16) + (w2 >>> 16);
        dst.l = 65535 & w0 | w1 << 16, dst.h = 65535 & w2 | w3 << 16;
    }
    var sha512_k, hexcase_default = 0, b64pad_default = "", enc = !1, rmd160_r1 = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ], rmd160_r2 = [ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ], rmd160_s1 = [ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ], rmd160_s2 = [ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ], sha256_K = Array(1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998);
    return {
        _get_hexcase_: gethexcase,
        _set_hexcase_: sethexcase,
        _get_padchar_: getpadchar,
        _set_padchar_: setpadchar,
        _get_outenc_: getenc,
        _set_outenc_: setenc,
        hex: rstr2hex,
        b64: "rst2b64",
        base64: "rst2b64",
        array: rstr2binl,
        binl: rstr2binl,
        hex_md5: hex_md5,
        b64_md5: b64_md5,
        md5: any_md5,
        hex_hmac_md5: hex_hmac_md5,
        b64_hmac_md5: b64_hmac_md5,
        hmac_md5: any_hmac_md5,
        hex_rmd160: hex_rmd160,
        b64_rmd160: b64_rmd160,
        rmd160: any_rmd160,
        hex_hmac_rmd160: hex_hmac_rmd160,
        b64_hmac_rmd160: b64_hmac_rmd160,
        hmac_rmd160: any_hmac_rmd160,
        hex_sha1: hex_sha1,
        b64_sha1: b64_sha1,
        sha1: any_sha1,
        hex_hmac_sha1: hex_hmac_sha1,
        b64_hmac_sha1: b64_hmac_sha1,
        hmac_sha1: any_hmac_sha1,
        hex_sha256: hex_sha256,
        b64_sha256: b64_sha256,
        sha256: any_sha256,
        hex_hmac_sha256: hex_hmac_sha256,
        b64_hmac_sha256: b64_hmac_sha256,
        hmac_sha256: any_hmac_sha256,
        hex_sha512: hex_sha512,
        b64_sha512: b64_sha512,
        sha512: any_sha512,
        hex_hmac_sha512: hex_hmac_sha512,
        b64_hmac_sha512: b64_hmac_sha512,
        hmac_sha512: any_hmac_sha512
    };
}()), fdjt.Log = function() {
    "use strict";
    function fdjtLog(string) {
        var i, lim, output = !1, now = ET(), date = new Date();
        if ((fdjtLog.doformat || string.search("%j")) && fdjtString !== void 0 && (output = fdjtString.apply(null, arguments)), 
        fdjtLog.console_fn && (output ? fdjtLog.console_fn.call(fdjtLog.console, output) : fdjtLog.console_fn.apply(fdjtLog.console, arguments)), 
        fdjtLog.logurl) {
            var msg = "[" + now + "s " + compactString(date, !1) + "] " + fdjtString.apply(null, arguments);
            window.console && window.console.log("remote logging %s", msg), remote_log(msg);
        }
        if (fdjtLog.console) {
            var domconsole = fdjtLog.console, timespan = fdjt.DOM("span.time", now), abstime = fdjt.DOM("span.abstime", compactString(date)), entry = fdjt.DOM("div.fdjtlog");
            if (entry.innerHTML = output ? output : fdjtString.apply(null, arguments), fdjt.DOM.prepend(entry, timespan), 
            fdjt.DOM.prepend(entry, abstime), "string" == typeof domconsole) {
                var found = document.getElementById(domconsole);
                domconsole = found ? fdjtLog.console = found : !1;
            }
            domconsole && !domconsole.nodeType && (domconsole = !1), domconsole && fdjtLog.livelog ? (update_log(domconsole), 
            domconsole.appendChild(entry), domconsole.appendChild(document.createTextNode("\n"))) : domconsole && 0 !== domconsole.offsetHeight ? (update_log(domconsole), 
            domconsole.appendChild(entry), domconsole.appendChild(document.createTextNode("\n"))) : backlog.push(entry);
        }
        if ((fdjtLog.useconsole || !fdjtLog.console && !fdjtLog.console_fn) && (use_console_log === void 0 && init_use_console_log(), 
        use_console_log)) if (window.console.log.call) if (output) window.console.log.call(window.console, "[" + now + "s] " + output); else {
            var newargs = Array(arguments.length + 1);
            for (newargs[0] = "[%fs] " + string, newargs[1] = now, i = 1, lim = arguments.length; lim > i; ) newargs[i + 1] = arguments[i], 
            i++;
            window.console.log.apply(window.console, newargs);
        } else window.console.log("[" + now + "s] " + fdjtString.apply(null, arguments));
    }
    function update_log(domconsole) {
        if (backlog && backlog.length) {
            var frag = document.createDocumentFragment(), log = backlog;
            backlog = !1;
            for (var i = 0, lim = log.length; lim > i; ) frag.appendChild(log[i++]), frag.appendChild(document.createTextNode("\n"));
            domconsole.appendChild(frag), backlog = [];
        }
    }
    function updateLogHandler() {
        fdjtLog.console && update_log(fdjtLog.console);
    }
    function remote_log(msg) {
        var req = new XMLHttpRequest();
        return req.open("POST", fdjtLog.logurl, !fdjtLog.logsync), req.setRequestHeader("Content-type", "text; charset=utf-8"), 
        req.send(msg), req;
    }
    function fdjtLogWarn() {
        if (!fdjtLog.console_fn && !window.console && window.console.log && window.console.log.count) {
            var output = fdjtString.apply(null, arguments);
            window.alert(output);
        } else fdjtLog.apply(null, arguments);
    }
    function fdjtLogUhOh() {
        fdjtLog.debugging && fdjtLog.warn.call(null, arguments);
    }
    function fdjtLogBkpt() {
        var output = !1;
        fdjtLog.doformat && fdjtString !== void 0 && (output = fdjtString.apply(null, arguments)), 
        fdjtLog.console_fn ? output ? fdjtLog.console_fn(fdjtLog.console, output) : fdjtLog.console_fn.apply(fdjtLog.console, arguments) : window.console && window.console.log && window.console.count && (output ? window.console.log.call(window.console, output) : window.console.log.apply(window.console, arguments));
    }
    function init_use_console_log() {
        if (window.console && window.console.log) if (window.console.count) use_console_log = !0; else {
            use_console_log = !0;
            try {
                window.console.log("Testing console");
            } catch (ex) {
                use_console_log = !1;
            }
        } else use_console_log = !1;
    }
    var use_console_log, fdjtString = fdjt.String, backlog = [], compactString = fdjt.Time.compactString, ET = fdjt.ET;
    return fdjtLog.console = null, fdjtLog.update = updateLogHandler, fdjtLog.warn = fdjtLogWarn, 
    fdjtLog.uhoh = fdjtLogUhOh, fdjtLog.bkpt = fdjtLogBkpt, fdjtLog.useconsole = !0, 
    fdjt.Trace = fdjt.Log, fdjtLog.getBacklog = function() {
        return backlog;
    }, fdjtLog;
}(window, document), function() {
    "use strict";
    function addInit(fcn, name, runagain) {
        if (checkInit(fcn, name)) {
            for (var replace = name && init_names[name], i = 0, lim = inits.length; lim > i; ) {
                if (replace && inits[i] === replace || inits[i] === fcn) return inits_run ? (fdjtLog.warn("Replacing init %s which has already run", name), 
                runagain ? (fdjtLog.warn("Running the new version"), inits[i] = fcn, name && (init_names[name] = fcn), 
                fcn(), void 0) : void 0) : (inits[i] = fcn, name && (init_names[name] = fcn), void 0);
                i++;
            }
            name && (init_names[name] = fcn), inits.push(fcn), inits_run ? (fcn(), run.push(!0)) : run.push(!1);
        }
    }
    function checkInit(fcn, name) {
        return fcn && fcn.call ? !0 : (fdjtLog.warn("Bad argument to addInit(): %s", name || "anonymous", fcn), 
        !1);
    }
    function getMatch(string, rx, i) {
        var match = rx.exec(string);
        return i === void 0 && (i = 0), match && match.length > i ? match[i] : !1;
    }
    function stdspace(string) {
        string = string.replace(/\s+/g, " ");
        var start = 0, len = string.length;
        if (0 >= len) return string;
        for (;len > start && spacechars.indexOf(string.charAt(start)) > -1; ) start++;
        if (start === len) return "";
        for (var end = len - 1; end > start && spacechars.indexOf(string.charAt(end)) > -1; ) end--;
        return start > 0 || len > end ? string.slice(start, end + 1) : string;
    }
    function getVersionNum(s) {
        if ("number" == typeof s) return s;
        if ("string" != typeof s) return s;
        if (s.indexOf("_") && (s = s.replace(/_/g, ".")), /^\d+\.?$/.exec(s)) ; else {
            if (!vnum_pat.exec(s)) return s;
            s = vnum_pat.exec(s)[1];
        }
        try {
            return parseFloat(s) || s;
        } catch (ex) {
            return s;
        }
    }
    function identifyDevice() {
        if (!fdjt.device || !fdjt.device.started) {
            var navigator = window.navigator, ua = navigator.userAgent, isAndroid = getMatch(ua, /\bAndroid +(\d+\.\d+)\b/g, 1), isWebKit = getMatch(ua, /\bAppleWebKit\/(\d+\.\d+)\b/g, 1), isGecko = getMatch(ua, /\bGecko\/(\d+)\b/gi, 1, !0), isChrome = getMatch(ua, /\bChrome\/(\d+\.\d+(.\d+)*)\b/g, 1), isFirefox = getMatch(ua, /\bFirefox\/(\d+\.\d+(.\d+)*)\b/gi, 1), isSafari = getMatch(ua, /\bSafari\/(\d+\.\d+(.\d+)*)\b/gi, 1), isOSX = getMatch(ua, /\bMac OS X \/(\d+\_\d+)\b/gi, 1, !0), isMobileSafari = isSafari && getMatch(ua, /\bMobile\/(\w+)\b/gi, 1, !0), isMobileWebKit = isWebKit && getMatch(ua, /\bMobile\/(\w+)\b/gi, 1, !0), isMobile = getMatch(ua, /\bMobile\/(\w+)\b/gi, 1, !0), hasVersion = getMatch(ua, /\bVersion\/(\d+\.\d+)\b/gi, 1), os_version = getMatch(ua, /\bOS (\d+_\d+(_\d)*)\b/gi, 1), isUbuntu = /ubuntu/gi.test(ua), isRedHat = /redhat/gi.test(ua), isLinux = /linux/gi.test(ua), isMacintosh = /Macintosh/gi.test(ua), isTouchPad = /Touchpad/gi.test(ua), iPhone = /iphone/gi.test(ua), iPad = /ipad/gi.test(ua), isTouch = iPhone || iPad || isAndroid || isTouchPad, isIOS = (iPhone || iPad) && (getMatch(ua, /\bVersion\/(\d+\.\d+)\b/gi, 1) || !0), opt_string = stdspace((isAndroid ? " Android/" + isAndroid : "") + (isWebKit ? " WebKit/" + isWebKit : "") + (isGecko ? " Gecko/" + isGecko : "") + (isChrome ? " Chrome/" + isChrome : "") + (isFirefox ? " Firefox/" + isFirefox : "") + (isSafari ? " Safari/" + isSafari : "") + (isMobileSafari ? " MobileSafari/" + isMobileSafari : "") + (isMobileWebKit ? " MobileWebKit/" + isMobileWebKit : "") + (isIOS ? " IOS/" + isIOS : "") + (isOSX ? " OSX/" + isOSX : "") + (navigator.platform ? " " + navigator.platform : "") + (iPhone ? " iPhone" : "") + (iPad ? " iPad" : "") + (isTouchPad ? " TouchPad" : "") + (isTouch ? " touch" : " mouse"));
            navigator.vendor && (device.vendor = navigator.vendor), navigator.platform && (device.platform = navigator.platform), 
            navigator.oscpu && (device.oscpu = navigator.oscpu), navigator.cookieEnabled && (device.cookies = navigator.cookieEnabled), 
            navigator.doNotTrack && (device.notrack = navigator.doNotTrack), navigator.standalone && (device.standalone = navigator.standalone), 
            device.string = opt_string, isAndroid && (device.android = getVersionNum(isAndroid), 
            device.android_version = isAndroid), isIOS && (device.ios = getVersionNum(os_version) || isIOS, 
            device.ios_version = isIOS, iPhone && (device.iphone = isIOS), iPad && (device.ipad = isIOS)), 
            isChrome && (device.chrome_version = isChrome, device.chrome = getVersionNum(isChrome)), 
            iPad && (device.iPad = !0), iPhone && (device.iPhone = !0), isOSX && (device.osx = getVersionNum(isOSX), 
            device.osx_version = isOSX), isWebKit && (device.webkit = getVersionNum(isWebKit), 
            device.webkit_version = isWebKit), isSafari && (device.safari = getVersionNum(isSafari), 
            device.safari_version = isSafari), isMobileSafari && (device.mobilesafari_version = isMobileSafari, 
            device.mobilesafari = getVersionNum(isMobileSafari)), isMobileWebKit && (device.mobilewebkit_version = isMobileWebKit, 
            device.mobilewebkit = getVersionNum(isMobileWebKit)), isMobile && (device.mobile = isMobile), 
            hasVersion && (device.version = hasVersion), isMacintosh && (device.isMacintosh = !0), 
            isUbuntu && (device.ubuntu = !0), isRedHat && (device.redhat = !0), isLinux && (device.linux = !0), 
            isTouch ? device.touch = !0 : device.mouse = !0, fdjtLog("Device: %j", device);
        }
    }
    var fdjtLog = fdjt.Log, inits_run = !1, inits = [], run = [], init_names = {};
    fdjt.addInit = addInit, fdjt.Init = function() {
        var names = [];
        if (inits_run) return !1;
        for (var name in init_names) init_names.hasOwnProperty(name) && names.push(name);
        0 === names.length ? fdjtLog("Running %d DOM inits", inits.length) : names.length === inits.length ? fdjtLog("Running %d DOM inits (%s)", inits.length, names.join()) : fdjtLog("Running %d DOM inits (including %s)", inits.length, names.join());
        for (var i = 0, lim = inits.length; lim > i; ) run[i] ? i++ : (run[i] = !0, inits[i](), 
        i++);
        inits_run = !0;
    };
    var spacechars = "\n\r	\f\u2028\u2029", vnum_pat = /^(\d+(\.\d+)).*/, device = fdjt.device || (fdjt.device = {});
    (function() {
        "undefined" != typeof window && window.navigator && window.navigator.appVersion && identifyDevice();
    })();
}(), fdjt.State = function() {
    "use strict";
    function fdjtState(name, val, persist) {
        if (1 === arguments.length) return window.sessionStorage && getSession(name) || window.sessionStorage && getLocal(name) || getCookie(name);
        if (persist) if (window.localStorage) val ? setLocal(name, val) : dropLocal(name); else {
            var domain = fdjtState.domain || location.hostname, path = fdjtState.path || "/", duration = fdjtState.duration || 220752e3;
            val ? setCookie(name, val, duration, path, domain) : clearCookie(name, path, domain);
        } else val ? window.sessionStorage ? setSession(name, val) : setCookie(name, val) : window.sessionStorage ? dropSession(name) : clearCookie(name);
    }
    function getCookie(name, parse) {
        try {
            var valuestring, cookies = document.cookie, namepat = RegExp("(^|(; ))" + name + "=", "g"), pos = cookies.search(namepat);
            if (!(pos >= 0)) return !1;
            var start = cookies.indexOf("=", pos) + 1, end = cookies.indexOf(";", start);
            return valuestring = end > 0 ? cookies.slice(start, end) : cookies.slice(start), 
            parse ? JSON.parse(decodeURIComponent(valuestring)) : decodeURIComponent(valuestring);
        } catch (ex) {
            return !1;
        }
    }
    function setCookie(name, value, expires, path, domain, secure) {
        try {
            if (value) {
                var valuestring = "string" == typeof value ? value : value.toJSON ? value.toJSON() : value.toString ? "" + value : value, cookietext = name + "=" + encodeURIComponent(valuestring);
                if (expires) if ("string" == typeof expires) cookietext = cookietext + "; " + expires; else if (expires.toGMTString) cookietext = cookietext + "; expires=" + expires.toGMTString(); else if ("number" == typeof expires) if (expires > 0) {
                    var now = new Date();
                    now.setTime(now.getTime() + expires), cookietext = cookietext + "; expires=" + now.toGMTString;
                } else cookietext += "; expires=Sun 1 Jan 2000 00:00:00 UTC";
                path && (cookietext = cookietext + "; path=" + path), domain && (cookietext = cookietext + "; domain=" + domain), 
                secure && (cookietext += "; Secure"), document.cookie = cookietext;
            } else clearCookie(name, path, domain);
        } catch (ex) {
            fdjtLog.warn("Error setting cookie %s", name);
        }
    }
    function clearCookie(name, path, domain) {
        try {
            var cookietext = encodeURIComponent(name) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
            path && (cookietext = cookietext = cookietext + "; path=" + path), domain && (cookietext = cookietext = cookietext + "; domain=" + domain), 
            document.cookie = cookietext;
        } catch (ex) {
            fdjtLog.warn("Error clearing cookie %s: %s", name, ex);
        }
        if (getCookie(name)) {
            var altcookietext = encodeURIComponent(name) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
            document.cookie = altcookietext;
        }
    }
    function setSession(name, val, unparse) {
        unparse && (val = JSON.stringify(val)), window.sessionStorage ? window.sessionStorage[name] = val : setCookie(name, val);
    }
    function getSession(name, parse) {
        var val = window.sessionStorage ? window.sessionStorage[name] : getCookie(name);
        return val ? parse ? JSON.parse(val) : val : !1;
    }
    function existsSession(name) {
        if (name) {
            if (window.sessionStorage) {
                if (name instanceof RegExp) {
                    for (var storage = window.sessionStorage, i = 0, lim = storage.length; lim > i; ) {
                        var key = storage.key(i++);
                        if (key.search(name) >= 0) return !0;
                    }
                    return !1;
                }
                var val = window.sessionStorage[name];
                return val === void 0 ? !1 : !0;
            }
            return !1;
        }
        throw {
            error: "bad name",
            name: name
        };
    }
    function dropSession(name) {
        return window.sessionStorage ? window.sessionStorage.removeItem(name) : (clearCookie(name), 
        void 0);
    }
    function clearSession() {
        if (window.sessionStorage) {
            for (var storage = window.localStorage, i = 0, lim = storage.length, keys = []; lim > i; ) keys.push(storage.key(i++));
            for (i = 0; lim > i; ) storage.removeItem(keys[i++]);
        }
    }
    function listSession(name) {
        var keys = [];
        if ("string" == typeof name && (name = RegExp("^" + fdjtString.escapeRX(name), "g")), 
        window.sessionStorage) {
            var storage = window.sessionStorage, i = 0, lim = storage.length, key = !1;
            if (name) {
                if (name instanceof RegExp) for (;lim > i; ) key = storage.key(i++), key.search(name) >= 0 && keys.push(key);
            } else for (;lim > i; ) keys.push(storage.key(i++));
        }
        return keys;
    }
    function setLocal(name, val, unparse) {
        if (!name) throw {
            error: "bad name",
            name: name
        };
        if (val === void 0) throw {
            error: "undefined value",
            name: name
        };
        if (!val) return dropLocal(name), void 0;
        if (unparse && (val = JSON.stringify(val)), window.localStorage) if (name instanceof RegExp) {
            for (var keys = [], storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                var key = storage.key(i++);
                key.search(name) >= 0 && keys.push(key);
            }
            for (i = 0, lim = keys.length; lim > i; ) storage[keys[i++]] = val;
        } else window.localStorage[name] = val;
    }
    function getLocal(name, parse) {
        if (name) {
            if (window.localStorage) {
                if (name instanceof RegExp) {
                    for (var storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                        var key = storage.key(i++);
                        if (key.search(name) >= 0) return parse ? JSON.parse(storage[key]) : storage[key];
                    }
                    return !1;
                }
                var val = window.localStorage[name];
                return val ? parse ? JSON.parse(val) : val : !1;
            }
            return !1;
        }
        throw {
            error: "bad name",
            name: name
        };
    }
    function pushLocal(name, val) {
        if (!name) throw {
            error: "bad name",
            name: name
        };
        var fetched = window.localStorage[name], array = !1;
        if (fetched) {
            if (array = JSON.parse(fetched), Array.isArray(array) || (array = [ array ]), !(0 > array.indexOf(val))) return !1;
            array.push(val);
        } else array = [ val ];
        return window.localStorage[name] = JSON.stringify(array), !0;
    }
    function removeLocal(name, val) {
        if (!name) throw {
            error: "bad name",
            name: name
        };
        var fetched = window.localStorage[name];
        if (fetched) {
            var loc, array = JSON.parse(fetched);
            if (array === val) return dropLocal(name), void 0;
            if (!Array.isArray(array)) return;
            if (loc = array.indexOf(val), 0 > loc) return;
            array.splice(loc, 1), window.localStorage[name] = JSON.stringify(array);
        }
        return !0;
    }
    function existsLocal(name) {
        if (name) {
            if (window.localStorage) {
                if (name instanceof RegExp) {
                    for (var storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                        var key = storage.key(i++);
                        if (key.search(name) >= 0) return !0;
                    }
                    return !1;
                }
                var val = window.localStorage[name];
                return val === void 0 ? !1 : !0;
            }
            return !1;
        }
        throw {
            error: "bad name",
            name: name
        };
    }
    function findLocal(name, val, parse) {
        if (window.localStorage) {
            for (var result = {}, storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
                var key = storage.key(i++);
                if (!name || key.search(name) >= 0) {
                    var v = storage[key];
                    if (!val || v.search(val) >= 0) {
                        if (parse) try {
                            v = JSON.parse(v);
                        } catch (ex) {}
                        result[key] = v;
                    }
                }
            }
            return result;
        }
        return !1;
    }
    function dropLocal(name) {
        if (!window.localStorage) return !1;
        if (!(name instanceof RegExp)) return window.localStorage.removeItem(name);
        for (var drop = [], storage = window.localStorage, i = 0, lim = storage.length; lim > i; ) {
            var key = storage.key(i++);
            key.search(name) >= 0 && drop.push(key);
        }
        for (i = 0, lim = drop.length; lim > i; ) storage.removeItem(drop[i++]);
    }
    function listLocal(name) {
        var keys = [];
        if ("string" == typeof name && (name = RegExp("^" + fdjtString.escapeRX(name), "g")), 
        window.localStorage) {
            var storage = window.localStorage, i = 0, lim = storage.length, key = !1;
            if (name) {
                if (name instanceof RegExp) for (;lim > i; ) key = storage.key(i++), key.search(name) >= 0 && keys.push(key);
            } else for (;lim > i; ) keys.push(storage.key(i++));
        }
        return keys;
    }
    function clearLocal() {
        if (window.localStorage) {
            for (var storage = window.localStorage, i = 0, lim = storage.length, keys = []; lim > i; ) keys.push(storage.key(i++));
            for (i = 0; lim > i; ) storage.removeItem(keys[i++]);
        }
    }
    function getParam(from, name, multiple, matchcase, verbatim, start) {
        var results = [], ename = encodeURIComponent(name), namepat = RegExp("(&|^)" + ename + "(=|&|$)", matchcase ? "g" : "gi");
        for (start = from.search(namepat); start >= 0; ) {
            var valstart = start + ename.length, valstring = from.slice(valstart + 1), end = valstring.search(/(&|$)/g);
            if ("=" === from[valstart]) {
                if (0 >= end) {
                    if (results.push(""), !multiple) break;
                } else if (results.push(valstring.slice(0, end)), end = end + valstart + 1, !multiple) break;
            } else {
                if (!multiple) return verbatim ? from.slice(start, end) : querydecode(from.slice(start, end));
                results.push(from.slice(start, end));
            }
            end > 0 && (from = from.slice(end), start = from.search(namepat));
        }
        if (!verbatim) for (var i = 0, lim = results.length; lim > i; ) results[i] = querydecode(results[i]), 
        i++;
        return multiple ? results : results.length ? results[0] : !1;
    }
    function getQuery(name, multiple, matchcase, verbatim) {
        if (!location.search) return multiple ? [] : !1;
        var from = location.search;
        return "?" === from[0] && (from = from.slice(1)), getParam(from, name, multiple, matchcase, verbatim);
    }
    function getHash(name, multiple, matchcase, verbatim) {
        if (!location.hash) return multiple ? [] : !1;
        var from = location.hash;
        return "#" === from[0] && (from = from.slice(1)), getParam(location.hash, name, multiple, matchcase, verbatim);
    }
    function querydecode(string) {
        return decodeURIComponent ? decodeURIComponent(string) : string.replace(/%3A/gi, ":").replace(/%2F/gi, "/").replace(/%3F/gi, "?").replace(/%3D/gi, "=").replace(/%20/gi, " ").replace(/%40/gi, "@").replace(/%23/gi, "#");
    }
    function test_opt(pos, neg) {
        for (var pospat = pos && RegExp("\\b" + pos + "\\b"), negpat = neg && negative_opt_pat(neg), i = 2; arguments.length > i; ) {
            var arg = arguments[i++];
            if (arg) {
                if ("string" == typeof arg) {
                    if (pospat && arg.search(pospat) >= 0) return !0;
                    if (negpat && arg.search(negpat) >= 0) return !1;
                    continue;
                }
                if (arg.length) {
                    for (var j = 0, len = arg.length; len > j; ) {
                        if (pos && arg[j] === pos) return !0;
                        if (neg && arg[j] === neg) return !1;
                        j++;
                    }
                    return !1;
                }
            } else ;
        }
        return !1;
    }
    function negative_opt_pat(neg) {
        if (neg) {
            if ("string" == typeof neg) return RegExp("\\b" + neg + "\\b", "gi");
            if (neg.length) {
                for (var rule = "\\b(", i = 0; neg.length > i; ) {
                    var name = neg[i];
                    i > 0 && (rule += "|"), rule = rule + "(" + name + ")", i++;
                }
                return rule += ")\\b", RegExp(rule, "gi");
            }
            return !1;
        }
        return neg;
    }
    function zeropad(string, len) {
        return string.length === len ? string : string.length > len ? string.slice(0, len) : zeros.slice(0, len - string.length) + string;
    }
    function getUUID(node) {
        var now = new Date().getTime();
        last_time > now ? (now = 1e4 * now, clockid++) : now === last_time ? now = 1e4 * now + msid++ : (now = 1e4 * now, 
        msid = 1), now += 122192928e9, node || (node = nodeid);
        var timestamp = now.toString(16), tlen = timestamp.length;
        return 15 > tlen && (timestamp = zeros.slice(0, 15 - tlen) + timestamp), timestamp.slice(7) + "-" + timestamp.slice(3, 7) + "-1" + timestamp.slice(0, 3) + "-" + (32768 + clockid % 16384).toString(16) + "-" + (node ? "number" == typeof node ? zeropad(node.toString(16), 12) : zeropad(node, 12) : nodeid);
    }
    function versionInfo() {
        for (var start, s = navigator.userAgent, result = {}; (start = s.search(/\w+\/\d/g)) >= 0; ) {
            var slash = s.indexOf("/", start), afterslash = s.slice(slash + 1), num_end = afterslash.search(/\W/), numstring = afterslash.slice(0, num_end);
            try {
                result[s.slice(start, slash)] = parseInt(numstring, 10);
            } catch (ex) {
                result[s.slice(start, slash)] = numstring;
            }
            s = afterslash.slice(num_end);
        }
        return result.browser = result.Chrome ? "Chrome" : result.Opera ? "Opera" : result.Safari ? "Safari" : result.Safari && result.Mobile ? "MobileSafari" : result.Firefox ? "Firefox" : result.Explorer || result.IE || result.InternetExplorer || result.MSIE ? "IE" : result.Mozilla ? "Mozilla" : "Browser", 
        result.platform = navigator.platform || "Turing", result;
    }
    function getStyleTag() {
        var tag = window.getComputedStyle(document.body, ":after").getPropertyValue("content");
        return tag = tag.replace(/"/g, "");
    }
    function getURL(keepquery, keephash) {
        var url = window.location.href, hashpos = url.indexOf("#"), qpos = url.indexOf("?"), hash = keephash && hashpos >= 0 && url.slice(hashpos + 1), query = keepquery && qpos >= 0 && (hashpos >= 0 ? url.slice(qpos + 1, hashpos) : url.slice(qpos + 1));
        return url = qpos >= 0 ? url.slice(0, qpos) : hashpos >= 0 ? url.slice(0, hashpos) : url, 
        url + (query ? "?" + query : "") + (hash ? "#" + hash : "");
    }
    var fdjtLog = fdjt.Log, fdjtString = fdjt.String;
    fdjtState.domain = !1, fdjtState.path = !1, fdjtState.duration = !1, fdjtState.getCookie = getCookie, 
    fdjtState.setCookie = setCookie, fdjtState.clearCookie = clearCookie, fdjtState.setSession = setSession, 
    fdjtState.getSession = getSession, fdjtState.existsSession = existsSession, fdjtState.dropSession = dropSession, 
    fdjtState.clearSession = clearSession, fdjtState.listSession = listSession, fdjtState.setLocal = setLocal, 
    fdjtState.getLocal = getLocal, fdjtState.pushLocal = pushLocal, fdjtState.removeLocal = removeLocal, 
    fdjtState.existsLocal = existsLocal, fdjtState.findLocal = findLocal, fdjtState.dropLocal = dropLocal, 
    fdjtState.listLocal = listLocal, fdjtState.clearLocal = clearLocal, fdjtState.getParam = getParam, 
    fdjtState.getQuery = getQuery, fdjtState.getHash = getHash, fdjtState.testOption = test_opt, 
    fdjtState.argVec = function(argobj, start) {
        for (var i = start || 0, result = Array(argobj.length - i); argobj.length > i; ) result[i - start] = argobj[i], 
        i++;
        return result;
    };
    var zeros = "000000000000000000000000000000000000000000000000000000000000000", nodeid = zeropad((Math.floor(65536 * Math.random()).toString(16) + Math.floor(65536 * Math.random()).toString(16) + Math.floor(65536 * Math.random()).toString(16) + (1 | Math.floor(65536 * Math.random()))).toString(16), 12), clockid = Math.floor(16384 * Math.random()), msid = 1, last_time = new Date().getTime();
    return fdjtState.getNodeID = function() {
        return nodeid;
    }, fdjtState.setNodeID = function(arg) {
        if ("number" == typeof arg) nodeid = zeropad(arg.toString(16), 12); else {
            if ("string" != typeof arg) throw {
                error: "invalid node id",
                value: arg
            };
            if (!(0 > arg.search(/[^0123456789abcdefABCDEF]/))) throw {
                error: "invalid node id",
                value: arg
            };
            nodeid = zeropad(arg, 12);
        }
    }, fdjtState.getUUID = getUUID, fdjtState.versionInfo = versionInfo, fdjtState.getStyleTag = getStyleTag, 
    fdjtState.getURL = getURL, fdjtState;
}(), fdjt.iDB = function() {
    "use strict";
    var iDB = {}, device = fdjt.device;
    return !window.indexedDB || device.ios && device.standalone ? (iDB.indexedDB = idbModules.shimIndexedDB, 
    iDB.IDBDatabase = idbModules.IDBDatabase, iDB.IDBTransaction = idbModules.IDBTransaction, 
    iDB.IDBCursor = idbModules.IDBCursor, iDB.IDBKeyRange = idbModules.IDBKeyRange) : (iDB.indexedDB = window.indexedDB, 
    iDB.IDBDatabase = window.IDBDatabase, iDB.IDBTransaction = window.IDBTransaction, 
    iDB.IDBCursor = window.IDBCursor, iDB.IDBKeyRange = window.IDBKeyRange, iDB.IDBTransaction = window.IDBTransaction, 
    iDB.IDBTransaction = window.IDBTransaction), iDB;
}();

var _fdjt_init;

fdjt.DOM = function() {
    "use strict";
    function fdjtDOM(spec) {
        var node;
        if (spec.nodeType) node = spec; else {
            if ("string" == typeof spec && "<" === spec[0]) {
                var container = document.createDocumentFragment();
                container.innerHTML = spec;
                var children = container.childNodes;
                return 1 === children.length ? children[0] : container;
            }
            if ("string" == typeof spec && "#" === spec[0] && (node = document.getElementById(spec.slice(1)))) ; else if ("string" == typeof spec) {
                var elts = spec.match(css_selector_regex);
                if (!elts) return fdjtLog.warn("bad CSS spec"), !1;
                var classname = !1;
                node = document.createElement(elts[0]);
                for (var i = 1, len = elts.length; len > i; ) {
                    var sel = elts[i++];
                    if ("#" === sel[0]) node.id = sel.slice(1); else if ("." === sel[0]) classname = classname ? classname + " " + sel.slice(1) : sel.slice(1); else if ("[" === sel[0]) {
                        var eqpos = sel.indexOf("=");
                        if (0 > eqpos) node.setAttribute(sel.slice(1, sel.length - 1), sel.slice(1, sel.length - 1)); else {
                            var val = sel.slice(eqpos + 1, sel.length - 1);
                            ("'" === val[0] && "'" === val[val.length - 1] || '"' === val[0] && '"' === val[val.length - 1]) && (val = val.slice(1, val.length - 1)), 
                            node.setAttribute(sel.slice(1, eqpos), val);
                        }
                    }
                }
                classname && (node.className = classname);
            } else {
                node = document.createElement(spec.tagName || "span");
                for (var attrib in spec) "tagName" !== attrib && node.setAttribute(attrib, spec[attrib]);
            }
        }
        for (var j = 1, lim = arguments.length; lim > j; ) domappend(node, arguments[j++]);
        return node;
    }
    function getIE() {
        if ("Microsoft Internet Explorer" === navigator.appName) {
            var rv, ua = navigator.userAgent, re = RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})");
            return rv = null !== re.exec(ua) ? parseFloat(re.$1) : 1, 0 >= rv && (rv = 1), rv;
        }
        return 0;
    }
    function fdjtID(id) {
        return id && (document.getElementById(id) || "#" === id[0] && document.getElementById(id.slice(1)));
    }
    function domappend(node, content, i) {
        if (0 === content) node.appendChild(document.createTextNode("0")); else {
            if (!content) return;
            if (content.nodeType) node.appendChild(content); else if ("string" == typeof content) node.appendChild(document.createTextNode(content)); else {
                if (content.toDOM) return domappend(node, content.toDOM());
                if (content.toHTML) return domappend(node, content.toHTML());
                if (content.length && (!i || content.length > i)) {
                    var frag = window.DocumentFragment && node instanceof window.DocumentFragment ? node : document.createDocumentFragment(), elts = window.NodeList && content instanceof window.NodeList ? TOA(content) : content, len = elts.length;
                    for (i === void 0 && (i = 0); len > i; ) {
                        var elt = elts[i++];
                        "string" == typeof elt ? frag.appendChild(document.createTextNode(elt)) : "number" == typeof elt ? frag.appendChild(document.createTextNode("" + elt)) : elt && (elt.nodeType ? frag.appendChild(elt) : elt.length ? domappend(frag, elt, 0) : elt.toDOM ? domappend(frag, elt.toDOM()) : elt.toHTML ? domappend(frag, elt.toHTML()) : elt.toString ? frag.appendChild(document.createTextNode("" + elt)) : frag.appendChild(document.createTextNode("" + elt)));
                    }
                    node !== frag && node.appendChild(frag);
                } else content.length || node.appendChild(document.createTextNode("" + content));
            }
        }
        return node;
    }
    function dominsert(before, content, i) {
        var node = before.parentNode;
        if (!content.nodeType || content !== before) {
            if (content.nodeType) node.insertBefore(content, before); else if ("string" == typeof content) node.insertBefore(document.createTextNode(content), before); else {
                if (content.toDOM) return dominsert(before, content.toDOM());
                if (content.toHTML) return dominsert(before, node, content.toHTML());
                if (content.length - i > 1) {
                    var frag = window.documentFragment && node instanceof window.DocumentFragment ? node : document.createDocumentFragment();
                    return domappend(frag, content, i), node.insertBefore(frag, before), before;
                }
                if (content.length) {
                    var c = content[i];
                    if (c === before) return;
                    node.insertBefore(c, before);
                } else node.insertBefore(document.createTextNode("" + content), before);
            }
            return node;
        }
    }
    function toArray(arg) {
        return aslice.call(arg);
    }
    function extendArray(result, arg) {
        for (var i = 0, lim = arg.length; lim > i; ) result.push(arg[i]), i++;
        return result;
    }
    function TOA(arg, start) {
        return arg.constructor === Array || arg instanceof Array ? start ? arg.slice(start) : arg : start ? aslice.call(arg, start || 0) : aslice.call(arg, start || 0);
    }
    function wrapChildren(node, spec) {
        spec || (spec = "div.fdjtwrapper");
        var wrapper = getFirstChild(node, spec);
        return wrapper && wrapper.nodeType && wrapper.parentNode === node ? wrapper : (wrapper = fdjtDOM(spec, toArray(node.childNodes)), 
        node.appendChild(wrapper), wrapper);
    }
    function unwrapChildren(nodes, cxt) {
        "string" == typeof nodes ? nodes = cxt ? fdjt.DOM.getChildren(cxt, nodes) : fdjt.DOM.$(nodes) : nodes.nodeType && (nodes = [ nodes ]);
        for (var i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++], frag = document.createDocumentFragment();
            domappend(frag, toArray(node.childNodes)), node.parentNode.replaceChild(frag, node);
        }
    }
    function parsePX(arg, dflt) {
        if (dflt === void 0 && (dflt = 0), 0 === arg) return 0;
        if (arg) {
            if ("none" === arg) return dflt;
            if ("auto" === arg) return dflt;
            if ("number" == typeof arg) return arg;
            if ("string" == typeof arg) {
                var len = arg.length, num = !1;
                return num = len > 2 && "x" === arg[len - 1] && "p" === arg[len - 2] ? parseInt(arg.slice(0, -2), 10) : parseInt(arg, 10), 
                0 === num ? 0 : isNaN(num) ? dflt : "number" == typeof num ? num : dflt;
            }
            return !1;
        }
        return dflt;
    }
    function getLineHeight(node, style) {
        style || (style = getStyle(node));
        var lh = style.lineHeight, fs = style.fontSize;
        return "normal" === lh ? parsePX(fs) : lh.search(/px$/) > 0 ? parsePX(lh) : lh.search(/%$/) > 0 ? parseFloat(lh.slice(0, -1)) / 100 * parsePX(fs) : parsePX(fs);
    }
    function classPat(name) {
        var rx = RegExp("\\b" + name + "\\b", "g");
        return classpats[name] = rx, rx;
    }
    function string_trim(string) {
        var start = string.search(/\S/), end = string.search(/\s+$/g);
        return 0 === start && 0 > end ? string : string.slice(start, end);
    }
    function nodeString(node) {
        if (3 === node.nodeType) return "<'" + node.value + "'>";
        if (1 === node.nodeType) {
            var output = "<" + node.tagName;
            return node.id && (output = output + "#" + node.id), "input" === node.tagName ? (output = output + "[type=" + node.type + "]", 
            output = output + "[name=" + node.name + "]") : "textarea" === node.tagName ? output = output + "[name=" + node.name + "]" : "img" === node.tagName && (node.alt ? output = output + "[alt=" + node.alt + "]" : node.src && (output = output + "[src=" + node.src + "]")), 
            "string" == typeof node.className && (output = output + "." + node.className.replace(/\s+/g, ".")), 
            output + ">";
        }
        return "" + node;
    }
    function make(spec, content, data, init) {
        var dom = fdjtDOM(spec);
        return init || (init = data), data && (content = fdjt.Template(content, data)), 
        init.id && !dom.id && (dom.id = init.id), init.title && !dom.title && (dom.title = init.title), 
        init.name && !dom.name && (dom.name = init.name), init.href && !dom.href && (dom.href = init.href), 
        init.value && !dom.value && (dom.value = init.value), init.src && !dom.src && (dom.src = init.src), 
        init.alt && !dom.alt && (dom.alt = init.alt), addListeners(dom, init), dom;
    }
    function getElementValues(elt, spec, parse, multiple) {
        var candidates = [];
        if (candidates = spec.search(/(\.|#|\[|,)/g) >= 0 ? getChildren(elt, spec) : elt.getElementsByClassName ? elt.getElementsByClassName(spec) : getChildren(), 
        0 === candidates.length) return multiple ? [] : !1;
        if (multiple) {
            for (var values = [], i = 0, lim = multiple.length; lim > i; ) {
                var txt = candidates[i++].innerText;
                parse ? values.push(JSON.parse(txt)) : values.push(txt);
            }
            return values;
        }
        return parse ? JSON.parse(candidates[0].innerText) : candidates[0].innerText;
    }
    function getElementValue(elt, spec, parse) {
        return getElementValues(elt, spec, parse, !1);
    }
    function hasClass(elt, classname, attrib) {
        if (elt && ("string" != typeof elt || (elt = document.getElementById(elt)))) {
            var classinfo = attrib ? elt.getAttribute(attrib) || "" : elt.className;
            if ("string" != typeof classinfo || "" === classinfo) return !1;
            if (classname === !0) return !0;
            if (classinfo === classname) return !0;
            if ("string" == typeof classname) {
                if (0 > classinfo.indexOf(" ")) return !1;
                classname = classpats[classname] || classPat(classname);
            }
            return classinfo.search(classname) >= 0 ? !0 : !1;
        }
    }
    function addClass(elt, classname, attrib) {
        if (elt && classname) {
            if ("string" == typeof elt) {
                if (!(elt = document.getElementById(elt))) return;
            } else {
                if (window.NodeList && elt instanceof window.NodeList) return addClass(TOA(elt), classname, attrib);
                if (elt.length && !elt.nodeType) {
                    for (var elts = TOA(elt), i = 0, lim = elts.length; lim > i; ) addClass(elts[i++], classname, attrib || !1);
                    return;
                }
                if (!attrib && elt.classList && "string" == typeof classname) return elt.classList.contains(classname) || elt.classList.add(classname), 
                void 0;
            }
            var classinfo = (attrib ? elt.getAttribute(attrib) || "" : elt.className) || null;
            if (classinfo && "string" != typeof classinfo) return fdjtLog.warn("Non string classname for %o", elt), 
            !1;
            if (!classinfo) return elt.className = classname, !0;
            var class_regex = classpats[classname] || classPat(classname), newinfo = classinfo;
            return classinfo === classname ? !1 : classinfo.search(class_regex) >= 0 ? !1 : (newinfo = classname + " " + classinfo, 
            attrib ? (elt.setAttribute(attrib, newinfo), elt.className = elt.className) : elt.className = newinfo, 
            !0);
        }
    }
    function dropClass(elt, classname, attrib, keep) {
        if (elt) {
            if ("string" == typeof elt) {
                if (!(elt = document.getElementById(elt))) return;
            } else {
                if (window.NodeList && elt instanceof window.NodeList) return dropClass(TOA(elt), classname, attrib);
                if (elt.length && !elt.nodeType) {
                    for (var elts = TOA(elt), i = 0, lim = elts.length; lim > i; ) dropClass(elts[i++], classname, attrib || !1);
                    return;
                }
                if (!attrib && elt.classList && "string" == typeof classname) return elt.classList.contains(classname) && elt.classList.remove(classname), 
                void 0;
            }
            var classinfo = (attrib ? elt.getAttribute(attrib) || "" : elt.className) || null;
            if ("string" != typeof classinfo || "" === classinfo) return !1;
            var class_regex = "string" == typeof classname ? classpats[classname] || classPat(classname) : classname, newinfo = classinfo;
            if (classinfo === classname) newinfo = ""; else {
                if (!(classinfo.search(class_regex) >= 0)) return !1;
                newinfo = classinfo.replace(class_regex, "");
            }
            return newinfo && (newinfo = newinfo.replace(whitespace_pat, " ").replace(trimspace_pat, "")), 
            attrib ? newinfo ? (elt.setAttribute(attrib, newinfo), elt.className = elt.className) : keep || (elt.removeAttribute(attrib), 
            elt.className = elt.className) : elt.className = newinfo ? newinfo : keep ? "" : "", 
            !0;
        }
    }
    function swapClass(elt, drop, add, attrib) {
        dropClass(elt, drop, attrib), addClass(elt, add, attrib);
    }
    function setClass(elt, classname, add) {
        "string" == typeof elt && (elt = document.getElementById(elt)), add ? addClass(elt, classname) : dropClass(elt, classname);
    }
    function toggleClass(elt, classname, attrib, keep) {
        if ("string" == typeof elt) elt = document.getElementById(elt); else {
            if (window.NodeList && elt instanceof window.NodeList) return toggleClass(TOA(elt), classname, attrib);
            if (elt.length && !elt.nodeType) {
                for (var elts = TOA(elt), i = 0, lim = elts.length; lim > i; ) toggleClass(elts[i++], classname, attrib || !1);
                return;
            }
            if (!attrib && elt.classList && "string" == typeof classname) return elt.classList.toggle(classname), 
            void 0;
        }
        var classinfo = (attrib ? elt.getAttribute(attrib) || "" : elt.className) || null;
        if ("string" != typeof classinfo || "" === classinfo) return attrib ? elt.setAttribute(attrib, classname) : elt.className = classname, 
        !0;
        var class_regex = "string" == typeof classname ? classpats[classname] || classPat(classname) : classname, newinfo = classinfo;
        if (classinfo === classname) newinfo = ""; else {
            if (!(classinfo.search(class_regex) >= 0)) return attrib ? elt.setAttribute(attrib, classinfo + " " + classname) : elt.className = classinfo + " " + classname, 
            !0;
            newinfo = classinfo.replace(class_regex, "");
        }
        return newinfo && (newinfo = newinfo.replace(whitespace_pat, " ").replace(trimspace_pat, "")), 
        attrib ? newinfo ? (elt.setAttribute(attrib, newinfo), elt.className = elt.className) : keep || (elt.removeAttribute(attrib), 
        elt.className = elt.className) : elt.className = newinfo, !1;
    }
    function toggleParent(node, spec, classname, attrib, keep) {
        var parent = getParent(node, spec);
        parent && toggleClass(parent, classname, attrib, keep);
    }
    function isTextInput(target) {
        return "INPUT" === target.tagName && 0 === target.type.search(text_input_types) || "TEXTAREA" === target.tagName;
    }
    function isImage(target) {
        return "IMG" === target.tagName;
    }
    function Selector(spec, tagcs) {
        var i, lim;
        if (!spec) return this;
        if (selectors[spec]) return selectors[spec];
        if (!(this instanceof Selector)) return Selector.call(new Selector(), spec);
        if (Array.isArray(spec) || "string" == typeof spec && spec.indexOf(",") > 0) {
            var compound = [], specs = [];
            if ("string" == typeof spec) specs = spec.split(","); else for (var j = 0, jlim = spec.length; jlim > j; ) "string" != typeof spec[j] ? j++ : spec[j].indexOf(",") >= 0 ? specs = specs.concat(spec[j++].split(",")) : specs.push(spec[j++]);
            for (i = 0, lim = specs.length; lim > i; ) {
                var sub = string_trim(specs[i++]), sel = new Selector(sub);
                sel && compound.push(sel);
            }
            return this.compound = compound, selectors[spec] = this, this.spec = "string" == typeof spec ? spec : specs.join(","), 
            this;
        }
        var elts = spec.match(css_selector_regex), classes = [], classnames = [], attribs = !1;
        if (elts || fdjtLog.warn("Couldn't parse spec %s", spec), elts) for (i = 0, lim = elts.length, 
        "." !== elts[0][0] && "#" !== elts[0][0] && "[" !== elts[0][0] && (this.tag = tagcs ? elts[0] : elts[0].toUpperCase(), 
        i = 1); lim > i; ) if ("#" === elts[i][0]) this.id = elts[i++].slice(1); else if ("." === elts[i][0]) classnames.push(elts[i].slice(1)), 
        classes.push(classPat(elts[i++].slice(1))); else if ("[" === elts[i][0]) {
            var aelts = elts[i++], eltsend = aelts.length - 1;
            attribs || (attribs = {});
            var eqpos = aelts.indexOf("=");
            0 > eqpos ? attribs[aelts.slice(1, eltsend)] = !0 : attribs[aelts.slice(1, eqpos)] = "~" === aelts[eqpos + 1] ? classPat(aelts.slice(eqpos + 2, eltsend)) : aelts.slice(eqpos + 1, eltsend);
        } else fdjtLog.uhoh("weird elts %o", elts[i++]);
        return classes.length && (this.classes = classes, this.classnames = classnames), 
        attribs && (this.attribs = attribs), this.rank = [ 0, this.id ? 1 : 0, classnames.length + attribs.length, 1 ], 
        selectors[spec] = this, this.spec = spec, this;
    }
    function gatherByClass(node, pat, results) {
        if (1 === node.nodeType) {
            var classname = node.className;
            "string" == typeof classname && classname.search(pat) >= 0 && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) gatherByClass(children[i++], pat, results);
        }
    }
    function gatherByTag(node, tag, results) {
        if (1 === node.nodeType) {
            ("string" == typeof tag ? node.tagName.toLowerString() === tag : tag instanceof RegExp && tag.match(node.tagName)) && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) gatherByTag(children[i++], tag, results);
        }
    }
    function gatherByAttrib(node, attrib, val, results) {
        if (1 === node.nodeType) {
            node.getAttribute(attrib) && ("string" == typeof val ? node.getAttribute(attrib) === val : node.getAttribute(attrib).search(val) >= 0) && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) gatherByAttrib(children[i++], attrib, val, results);
        }
    }
    function gather_children(node, pat, attrib, results) {
        attrib ? "class" === attrib ? gatherByClass(node, pat, results) : "tagName" === attrib ? gatherByTag(node, pat, results) : gatherByAttrib(node, attrib, pat, results) : gatherByClass(node, pat, results);
    }
    function getParent(elt, parent) {
        if ("string" == typeof elt && (elt = "#" === elt[0] ? document.getElementById(elt.slice(1)) : document.getElementById(elt)), 
        elt) {
            if (parent) {
                if (parent.nodeType) {
                    for (;elt; ) {
                        if (elt === parent) return parent;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if ("function" == typeof parent) {
                    for (;elt; ) {
                        if (parent(elt)) return elt;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if (parent instanceof Selector) {
                    for (;elt; ) if (1 !== elt.nodeType) elt = elt.parentNode; else {
                        if (parent.match(elt)) return elt;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if (parent instanceof RegExp) {
                    for (;elt; ) if (1 !== elt.nodeType) elt = elt.parentNode; else {
                        if (elt.className && parent.test(elt.className)) return elt;
                        elt = elt.parentNode;
                    }
                    return !1;
                }
                if ("string" == typeof parent) return getParent(elt, new Selector(parent));
                throw {
                    error: "invalid parent spec"
                };
            }
            return !1;
        }
        return !1;
    }
    function getChildNodes(node) {
        return 1 !== node.nodeType ? [] : node.childNodes ? toArray(node.childNodes) : [];
    }
    function getChildren(node, classname, attrib, results) {
        if ("string" == typeof node && (node = fdjtID(node)), !node) return [];
        if (results || (results = []), attrib) {
            if ("string" != typeof attrib) throw {
                error: "bad selector arg",
                selector: classname
            };
            gather_children(node, classname, attrib || !1, results);
        } else if ("function" == typeof classname) filter_children(node, classname, results); else if (classname instanceof RegExp) regexp_filter_children(node, classname, results); else {
            if (classname instanceof Selector) return classname.find(node, results);
            if ("string" == typeof classname) return usenative && node.querySelectorAll ? node.querySelectorAll(classname) : getChildren(node, new Selector(classname), !1, results);
            if (classname.length) for (var i = 0, lim = classname.length; lim > i; ) getChildren(node, classname[i++], attrib, results);
        }
        return results;
    }
    function getFirstChild(elt, spec) {
        var children = getChildren(elt, spec);
        return children.length ? children[0] : !1;
    }
    function filter_children(node, filter, results) {
        if (1 === node.nodeType) {
            filter(node) && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) filter_children(children[i++], filter, results);
        }
    }
    function regexp_filter_children(node, rx, results) {
        if (1 === node.nodeType) {
            var classname = node.className;
            "string" == typeof classname && classname.search(rx) >= 0 && results.push(node);
            var children = node.childNodes;
            if (children) for (var i = 0, lim = children.length; lim > i; ) regexp_filter_children(children[i++], rx, results);
        }
    }
    function getFirstElement(node) {
        return node.firstElementChild ? node.firstElementChild : node.children && node.children.length ? node.children[0] : !1;
    }
    function getLastElement(node) {
        return node.lastElementChild ? node.lastElementChild : node.children && node.children.length ? node.children[node.children.length - 1] : !1;
    }
    function remove_node(node) {
        if (node instanceof Array) for (var i = 0, lim = node.length; lim > i; ) remove_node(node[i++]); else {
            var cur = node;
            "string" == typeof node && (cur = "#" === node[0] ? document.getElementById(node.slice(1)) : document.getElementById(node)), 
            cur && cur.parentNode ? cur.parentNode.removeChild(cur) : cur ? fdjtLog.uhoh("Looks like %o has already been removed (no parent)", cur) : fdjtLog.uhoh("Can't find %o to remove it", node);
        }
    }
    function removeChildren(node) {
        for (var children = node.childNodes, n = children.length - 1; n >= 0; ) node.removeChild(children[n--]);
    }
    function DOMappend(node) {
        "string" == typeof node && (node = document.getElementById(node)), domappend(node, aslice.call(arguments), 1);
    }
    function DOMprepend(node) {
        "string" == typeof node && (node = document.getElementById(node)), node.firstChild ? dominsert(node.firstChild, aslice.call(arguments), 1) : domappend(node, aslice.call(arguments), 1);
    }
    function DOMinsertBefore(before) {
        "string" == typeof before && (before = document.getElementById(before)), dominsert(before, aslice.call(arguments), 1);
    }
    function DOMinsertAfter(after) {
        "string" == typeof after && (after = document.getElementById(after)), after.nextSibling ? dominsert(after.nextSibling, aslice.call(arguments), 1) : domappend(after.parentNode, aslice.call(arguments), 1);
    }
    function tag_spec(spec, tag) {
        if (spec) {
            if ("string" == typeof spec) {
                var wordstart = spec.search(/\w/g), puncstart = spec.search(/\W/g);
                return 0 > puncstart ? tag + "." + spec : 0 !== wordstart ? tag + spec : spec;
            }
            return spec.tagName ? spec : (spec.tagName = tag, spec);
        }
        return tag;
    }
    function getInputs(root, name, type) {
        var results = [];
        if ("string" == typeof root) {
            var root_elt = document.getElementById(root);
            root_elt || fdjtLog.warn("Couldn't resolve %s to an object", root), root = root_elt;
        }
        if (!root) return results;
        for (var inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name || type && inputs[i].type !== type ? i++ : results.push(inputs[i++]);
        if (!type || "textarea" === type || "text" === type) for (inputs = root.getElementsByTagName("textarea"), 
        i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name || type && inputs[i].type !== type ? i++ : results.push(inputs[i++]);
        if (!type || "button" === type || "submit" === type) for (inputs = root.getElementsByTagName("button"), 
        i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name || type && inputs[i].type !== type ? i++ : results.push(inputs[i++]);
        if (!type || "select" === type) for (inputs = root.getElementsByTagName("select"), 
        i = 0, lim = inputs.length; lim > i; ) name && inputs[i].name !== name ? i++ : results.push(inputs[i++]);
        return results;
    }
    function getInputValues(root, name) {
        for (var results = [], inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            input.name === name && ("checkbox" !== input.type && "radio" !== input.type || input.checked) && results.push(input.value);
        }
        return results;
    }
    function getInputValue(root, name, n) {
        for (var r = 0, inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            if (!input.disabled && input.name === name && ("checkbox" !== input.type && "radio" !== input.type || input.checked)) {
                if (!n) return input.value;
                if (r === n) return input.value;
                r++;
            }
        }
        return !1;
    }
    function getInputsFor(root, name, value) {
        if ("string" == typeof root && (root = document.getElementById(root)), !root) return [];
        for (var results = [], inputs = root.getElementsByTagName("input"), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            input.name === name && input.value === value && results.push(input);
        }
        return results;
    }
    function setInputs(selector, value) {
        if (value) for (var inputs = fdjtDOM.$(selector), i = 0, lim = inputs.length; lim > i; ) inputs[i++].value = value;
    }
    function getStyle(elt, prop) {
        if ("string" == typeof elt && (elt = document.getElementById(elt)), !elt) return elt;
        if (1 !== elt.nodeType) throw "Not an element";
        var style = window.getComputedStyle && window.getComputedStyle(elt, null) || elt.currentStyle;
        return style ? prop ? style[prop] : style : !1;
    }
    function styleString(elt) {
        var result, style = elt.style;
        if (!style) return !1;
        var i = 0, lim = style.length;
        if (0 === lim) return !1;
        for (;lim > i; ) {
            var p = style[i], v = style[p];
            result = 0 === i ? p + ": " + v : result + "; " + p + ": " + v, i++;
        }
        return result;
    }
    function getDisplayStyle(elt) {
        return elt && elt.nodeType && 1 === elt.nodeType ? window.getComputedStyle && window.getComputedStyle(elt, null) && window.getComputedStyle(elt, null).display || display_styles[elt.tagName] || "inline" : !1;
    }
    function flatten(string) {
        return string.replace(/\s+/, " ");
    }
    function textify(arg, flat, depth, domarkup) {
        if ("number" != typeof depth && (depth = 0), !arg.nodeType) return arg.toString ? "" + arg : "" + arg;
        if (3 === arg.nodeType) return flat ? flatten(arg.nodeValue) : arg.nodeValue;
        if (1 === arg.nodeType) {
            var children = arg.childNodes, style = getStyle(arg), display_type = style.display, position_type = style.position, whitespace = style.whiteSpace, classname = arg.className, string = "", suffix = "";
            if ("normal" !== whitespace && (flat = !1), "none" === display_type) return "";
            if ("static" !== position_type && "" !== position_type) return "";
            if ("string" == typeof classname && ("fdjtskiptext" === classname || classname.search(/\bfdjtskiptext\b/) >= 0)) return "";
            if (!children || 0 === children.length) return domarkup ? arg.alt ? "[" + arg.alt + "]" : "[?]" : "";
            display_type && ("inline" === display_type || (flat ? suffix = " " : "block" === display_type || "table" === display_type || "preformatted" === display_type ? (string = "\n", 
            suffix = "\n") : "table-row" === display_type ? suffix = "\n" : "table-cell" === display_type && (string = "	")));
            for (var i = 0; children.length > i; ) {
                var child = children[i++];
                if (child.nodeType) if (3 === child.nodeType) string += flat ? flatten(child.nodeValue) : child.nodeValue; else {
                    if (1 !== child.nodeType) continue;
                    var stringval = textify(child, flat, !0, domarkup);
                    stringval && (string += stringval);
                }
            }
            return string + suffix;
        }
    }
    function Geometry(elt, root) {
        if (!elt) return this;
        if ("string" == typeof elt && (elt = document.getElementById(elt)), elt) {
            var top = elt.offsetTop, left = elt.offsetLeft, width = elt.offsetWidth, height = elt.offsetHeight, rootp = root && root.offsetParent;
            if (this.elt = elt, this.root = root, elt === root) left = 0, top = 0, bottom = height, 
            right = width; else for (elt = elt.offsetParent; elt && (!root || elt !== root && elt !== rootp); ) top += elt.offsetTop, 
            left += elt.offsetLeft, elt = elt.offsetParent;
            var bottom = top + height, right = left + width;
            return this.left = left, this.top = top, this.width = width, this.height = height, 
            this.right = right, this.bottom = bottom, this;
        }
    }
    function XGeometry(elt, root, withstack) {
        if (withstack = withstack ? [] : !1, !elt) return this;
        "string" == typeof elt && (elt = document.getElementById(elt));
        var top = elt.offsetTop, left = elt.offsetLeft, width = elt.offsetWidth, height = elt.offsetHeight, rootp = root && root.offsetParent, style = getStyle(elt);
        if (this.elt = elt, this.root = root, elt === root) left = 0, top = 0, bottom = height, 
        right = width; else for (elt = elt.offsetParent; elt && (!root || elt !== root && elt !== rootp); ) withstack && withstack.push(elt), 
        top += elt.offsetTop, left += elt.offsetLeft, elt = elt.offsetParent;
        var bottom = top + height, right = left + width;
        if (this.left = left, this.top = top, this.width = width, this.height = height, 
        this.right = right, this.bottom = bottom, style) {
            var t_margin = parsePX(style.marginTop), r_margin = parsePX(style.marginRight), b_margin = parsePX(style.marginBottom), l_margin = parsePX(style.marginLeft), t_padding = parsePX(style.paddingTop), r_padding = parsePX(style.paddingRight), b_padding = parsePX(style.paddingBottom), l_padding = parsePX(style.paddingLeft), t_border = parsePX(style.borderTopWidth), r_border = parsePX(style.borderRightWidth), b_border = parsePX(style.borderBottomWidth), l_border = parsePX(style.borderLeftWidth), outer_width = width + l_margin + r_margin, outer_height = height + t_margin + b_margin, inner_width = width - (l_border + l_padding + r_border + r_padding), inner_height = height - (t_border + t_padding + b_border + b_padding), lh = style.lineHeight, fs = style.fontSize, lhpx = !1;
            lhpx = "normal" === lh ? parsePX(fs) : lh.search(/px$/) > 0 ? parsePX(lh) : lh.search(/%$/) > 0 ? parseFloat(lh.slice(0, -1)) / 100 * parsePX(fs) : parsePX(fs), 
            this.top_margin = t_margin, this.bottom_margin = b_margin, this.left_margin = l_margin, 
            this.right_margin = r_margin, this.top_border = t_border, this.bottom_border = b_border, 
            this.left_border = l_border, this.right_border = r_border, this.top_padding = t_padding, 
            this.bottom_padding = b_padding, this.left_padding = l_padding, this.right_padding = r_padding, 
            this.outer_height = outer_height, this.outer_width = outer_width, this.inner_height = inner_height, 
            this.inner_width = inner_width, this.line_height = lhpx;
        }
        return withstack && (this.stack = withstack), this;
    }
    function getGeometry(elt, root, extra) {
        return extra ? new XGeometry(elt, root) : new Geometry(elt, root);
    }
    function geomString(geom) {
        return +("number" == typeof geom.width ? geom.width : "?") + "x" + ("number" == typeof geom.height ? geom.height : "?") + "@l:" + ("number" == typeof geom.left ? geom.left : "?") + ",t:" + ("number" == typeof geom.top ? geom.top : "?") + "/r:" + ("number" == typeof geom.right ? geom.right : "?") + ",b:" + ("number" == typeof geom.bottom ? geom.bottom : "?");
    }
    function isVisible(elt, partial) {
        if (partial || (partial = !1), elt.offsetParent && elt.offsetParent !== document.body) {
            var container = elt.offsetParent, offtop = elt.offsetTop, offbot = offtop + elt.offsetHeight, offleft = elt.offsetLeft, offright = offleft + elt.offsetWidth, l = container.scrollLeft, r = l + container.clientWidth, t = container.scrollTop, b = t + container.clientHeight;
            return partial ? (offleft >= l && r >= offleft || offright >= l && r >= offright || l > offleft && offright > r) && (offtop >= t && b >= offtop || offbot >= t && b >= offbot || t >= offtop && offbot >= b) : offleft >= l && r >= offleft && offright >= l && r >= offright && offtop >= t && b >= offtop && offbot >= t && b >= offbot;
        }
        for (var top = elt.offsetTop, left = elt.offsetLeft, width = elt.offsetWidth, height = elt.offsetHeight, winx = window.pageXOffset || document.documentElement.scrollLeft || 0, winy = window.pageYOffset || document.documentElement.scrollTop || 0, winxedge = winx + document.documentElement.clientWidth, winyedge = winy + document.documentElement.clientHeight; elt.offsetParent && elt !== window; ) elt = elt.offsetParent, 
        top += elt.offsetTop, left += elt.offsetLeft;
        return elt && elt !== window && elt !== document.body && (elt.scrollTop || elt.scrollLeft) && (fdjtLog("Adjusting for inner DIV"), 
        winx = elt.scrollLeft, winy = elt.scrollTop, winxedge = winx + elt.scrollWidth, 
        winyedge = winy + elt.scrollHeight), partial ? top > winy && winyedge > top && left > winx && winxedge > left || top + height > winy && winyedge > top + height && left + width > winx && winxedge > left + width || (winy > top || winx > left) && top + height > winyedge && left + width > winxedge : top > winy && left > winx && winyedge >= top + height && winxedge >= left + width;
    }
    function isAtTop(elt, delta) {
        delta || (delta = 50);
        for (var top = elt.offsetTop, left = elt.offsetLeft, winy = window.pageYOffset || document.documentElement.scrollTop || 0, winyedge = winy + document.documentElement.clientHeight; elt.offsetParent; ) elt = elt.offsetParent, 
        top += elt.offsetTop, left += elt.offsetLeft;
        return top > winy && winyedge > top && winy + delta > top;
    }
    function textwidth(node) {
        if (3 === node.nodeType) return node.nodeValue.length;
        if (1 !== node.nodeType) return 0;
        var style = getStyle(node), display = style.display, position = style.position;
        if ("none" === display) return 0;
        if ("" !== position && "static" !== position) return 0;
        if ("string" != typeof node.className) return 0;
        if ("fdjtskiptext" === node.className || "string" == typeof node.className && node.className.search(/\bfdjtskiptext/) >= 0) return 0;
        if (node.getAttribute("data-locwidth")) return parseInt(node.getAttribute("data-locwidth"));
        if (node.childNodes) {
            for (var children = node.childNodes, padding = "inline" === display ? 0 : /^(li|td|dt|dd|label|input)$/i.exec(node.tagName) ? 1 : 2, i = 0, lim = children.length, width = 0; lim > i; ) {
                var child = children[i++];
                3 === child.nodeType ? width += child.nodeValue.length : 1 === child.nodeType && (width += textwidth(child));
            }
            return width + 2 * padding;
        }
        return node.alt ? node.alt.length + 2 : 3;
    }
    function countBreaks(arg) {
        return "string" == typeof arg ? arg.match(/\W*\s+\W*/g).length : arg.nodeType ? 1 !== arg.nodeType ? 3 === arg.nodeType ? arg.nodeValue.match(/\W*\s+\W*/g).length : 0 : void 0 : 0;
    }
    function hasContent(node, recur, test, limit) {
        if (node === limit) return !1;
        if (3 === node.nodeType) return node.nodeValue.search(/\w/g) >= 0;
        if (1 !== node.nodeType) return !1;
        if (test && test.match && test.match(node)) return !0;
        if (0 === node.tagName.search(nontext_content)) return !0;
        if ("string" == typeof node.className && node.className.search(/\bfdjtskiptext\b/g) >= 0) return !1;
        if (node.childNodes && node.childNodes.length) {
            for (var children = node.childNodes, i = 0; children.length > i; ) {
                var child = children[i++];
                if (child === limit) return !1;
                if (3 !== child.nodeType) {
                    if (1 === child.nodeType) if (recur) {
                        if (hasContent(child, recur, test, limit)) return !0;
                    } else ;
                } else if (child.nodeValue.search(/\w/g) >= 0) return !0;
            }
            return !1;
        }
        return !1;
    }
    function hasText(node) {
        if (node.childNodes) {
            for (var children = node.childNodes, i = 0; children.length > i; ) {
                var child = children[i++];
                if (3 === child.nodeType && child.nodeValue.search(/\w/g) >= 0) return !0;
            }
            return !1;
        }
        return !1;
    }
    function addListener(node, evtype, handler) {
        if (node || (node = document), "string" == typeof node) {
            var elt = fdjtID(node);
            if (!node) return fdjtLog.warn("Can't find #%s", node), void 0;
            node = elt;
        } else {
            if (Array.isArray && Array.isArray(node) || window.NodeList && node instanceof window.NodeList) {
                for (var i = 0, lim = node.length; lim > i; ) addListener(node[i++], evtype, handler);
                return;
            }
            if (node !== window && !node.nodeType) return fdjtLog.warn("Bad target(s) arg to addListener(%s) %o", evtype, node), 
            void 0;
        }
        if ("title" === evtype) "string" == typeof handler && (node.title = node.title ? "(" + handler + ") " + node.title : handler); else if ("=" === evtype[0]) node[evtype.slice(1)] = handler; else {
            if (node.addEventListener) return node.addEventListener(evtype, handler, !1);
            if (node.attachEvent) return node.attachEvent("on" + evtype, handler);
            fdjtLog.warn("This node never listens: %o", node);
        }
    }
    function defListeners(handlers, defs) {
        if (handlers && defs) for (var domspec in defs) if (defs.hasOwnProperty(domspec)) {
            var evtable = defs[domspec], addto = handlers[domspec];
            addto && handlers.hasOwnProperty(domspec) || (handlers[domspec] = addto = {});
            for (var evtype in evtable) evtable.hasOwnProperty(evtype) && (addto[evtype] = evtable[evtype]);
        }
    }
    function addListeners(node, handlers) {
        if (handlers) for (var evtype in handlers) if (handlers.hasOwnProperty(evtype)) {
            var match = !1, val = handlers[evtype];
            if (val.call) {
                if (events_pat.exec(evtype)) addListener(node, evtype, handlers[evtype]); else if (match = spec_events_pat.exec(evtype)) {
                    var ev = match[2], handler = handlers[evtype], elts = node.querySelectorAll(match[1]);
                    addListener(elts, ev, handler);
                }
            } else ;
        }
    }
    function removeListener(node, evtype, handler) {
        if (node || (node = document), "string" == typeof node) {
            var elt = fdjtID(node);
            if (!node) return fdjtLog("Can't find #%s", node), void 0;
            node = elt;
        } else {
            if (Array.isArray && Array.isArray(node) || window.NodeList && node instanceof window.NodeList) {
                for (var i = 0, lim = node.length; lim > i; ) removeListener(node[i++], evtype, handler);
                return;
            }
            if (node !== window && !node.nodeType) return fdjtLog.warn("Bad target(s) arg to removeListener(%s) %o", evtype, node), 
            void 0;
        }
        return node.removeEventListener ? node.removeEventListener(evtype, handler, !1) : node.detachEvent ? node.detachEvent("on" + evtype, handler) : (fdjtLog.warn("This node never listens: %o", node), 
        void 0);
    }
    function eventTarget(evt) {
        return evt = evt || window.event, evt.target || evt.srcElement;
    }
    function cancelEvent(evt) {
        evt = evt || window.event, evt.preventDefault ? evt.preventDefault() : evt.returnValue = !1, 
        evt.cancelBubble = !0;
    }
    function triggerClick(elt) {
        if (document.createEvent) {
            var e = document.createEvent("MouseEvents");
            return e.initEvent("click", !0, !0), elt.dispatchEvent(e), void 0;
        }
        return fdjtLog.warn("Couldn't trigger click"), void 0;
    }
    function pageScroll(container, n) {
        var ch = container.clientHeight, delta = ch * n, sh = container.scrollHeight, st = container.scrollTop, nt = st + delta;
        ch >= sh || (container.scrollTop = 0 > nt ? 0 : nt + ch >= sh ? sh - ch : nt);
    }
    function getInsideBounds(container) {
        for (var left = !1, top = !1, right = !1, bottom = !1, children = container.childNodes, i = 0, lim = children.length; lim > i; ) {
            var child = children[i++];
            if ("number" == typeof child.offsetLeft) {
                var style = getStyle(child);
                if ("static" === style.position) {
                    var child_left = child.offsetLeft - parsePX(style.marginLeft), child_top = child.offsetTop - parsePX(style.marginTop), child_right = child.offsetLeft + child.offsetWidth + parsePX(style.marginRight), child_bottom = child.offsetTop + child.offsetHeight + parsePX(style.marginBottom);
                    left === !1 ? (left = child_left, right = child_right, top = child_top, bottom = child_bottom) : (left > child_left && (left = child_left), 
                    top > child_top && (top = child_top), child_right > right && (right = child_right), 
                    child_bottom > bottom && (bottom = child_bottom));
                }
            }
        }
        return {
            left: left,
            right: right,
            top: top,
            bottom: bottom,
            width: right - left,
            height: bottom - top
        };
    }
    function applyScale(container, scale) {
        var images = fdjtDOM.getChildren(container, "IMG"), ilim = images.length;
        if (scale) {
            container.scale = scale, container.style.fontSize = scale + "%";
            var rounded = 10 * Math.round(scale / 10);
            fdjtDOM.addClass(container, "fdjtscaled"), fdjtDOM.swapClass(container, /\bfdjtscale\d+\b/, "fdjtscale" + rounded);
        } else {
            if (!container.scale) return;
            delete container.scale, container.style.fontSize = "", fdjtDOM.dropClass(container, "fdjtscaled"), 
            fdjtDOM.dropClass(container, /\bfdjtscale\d+\b/);
        }
        for (var iscan = 0; ilim > iscan; ) {
            var image = images[iscan++];
            if (!fdjtDOM.hasClass(image, "nofdjtscale") && !fdjtDOM.hasClass(image, "noautoscale") && (image.style.maxWidth = image.style.width = image.style.maxHeight = image.style.height = "", 
            scale)) {
                var width = image.offsetWidth, height = image.offsetHeight;
                image.style.maxWidth = image.style.width = Math.round(width * (scale / 100)) + "px", 
                image.style.maxHeight = image.style.height = Math.round(height * (scale / 100)) + "px";
            }
        }
    }
    function adjustInside(elt, container, step, min, pad) {
        function adjust() {
            var outside = getGeometry(container), inside = getGeometry(elt, container), style = getStyle(container), maxwidth = outside.width - (parsePX(style.paddingLeft, 0) + parsePX(style.borderLeft, 0) + parsePX(style.paddingRight, 0) + parsePX(style.borderRight, 0)), maxheight = outside.height - (parsePX(style.paddingTop, 0) + parsePX(style.borderTop, 0) + parsePX(style.paddingBottom, 0) + parsePX(style.borderBottom, 0));
            trace_adjust && fdjtLog("adjustInside scale=%o step=%o min=%o pad=%o [l%o,t%o,r%o,b%o] << %ox%o < %ox%o", scale, step, min, pad, inside.left, inside.top, inside.right, inside.bottom, maxwidth * pad, maxheight * pad, maxwidth, maxheight), 
            inside.top >= 0 && pad * maxheight >= inside.bottom && inside.left >= 0 && pad * maxwidth >= inside.right || min >= scale || (scale -= step, 
            applyScale(elt, scale, trace_adjust), setTimeout(adjust, 10));
        }
        var trace_adjust = elt.traceadjust || container.traceadjust || fdjtDOM.trace_adjust || "string" == typeof elt.className && elt.className.search(/\btraceadjust\b/) >= 0 || "string" == typeof container.className && container.className.search(/\btraceadjust\b/) >= 0 || default_trace_adjust;
        step || (step = 5), min || (min = 50), pad || (pad = 1);
        var scale = 100;
        setTimeout(adjust, 10);
    }
    function adjustToFit(container, threshold, padding) {
        var trace_adjust = container.traceadjust || fdjtDOM.trace_adjust || "string" == typeof container.className && container.className.search(/\btraceadjust\b/) >= 0 || default_trace_adjust, style = getStyle(container), geom = getGeometry(container), maxheight = style.maxHeight && parsePX(style.maxHeight) || geom.height, maxwidth = style.maxWidth && parsePX(style.maxWidth) || geom.width, goodenough = threshold || .1, scale = container.scale || 100, bounds = getInsideBounds(container), hpadding = (fdjtDOM.parsePX(style.paddingLeft) || 0) + (fdjtDOM.parsePX(style.paddingRight) || 0) + (fdjtDOM.parsePX(style.borderLeftWidth) || 0) + (fdjtDOM.parsePX(style.borderRightWidth) || 0) + padding, vpadding = (fdjtDOM.parsePX(style.paddingTop) || 0) + (fdjtDOM.parsePX(style.paddingBottom) || 0) + (fdjtDOM.parsePX(style.borderTopWidth) || 0) + (fdjtDOM.parsePX(style.borderBottomWidth) || 0) + padding;
        maxwidth -= hpadding, maxheight -= vpadding;
        var itfits = 1 >= bounds.height / maxheight && 1 >= bounds.width / maxwidth;
        if (trace_adjust && fdjtLog("Adjust (%o) %s cur=%o%s, best=%o~%o, limit=%ox%o=%o, box=%ox%o=%o, style=%s", goodenough, fdjtDOM.nodeString(container), scale, itfits ? " (fits)" : "", container.bestscale || -1, container.bestfit || -1, maxwidth, maxheight, maxwidth * maxheight, bounds.width, bounds.height, bounds.width * bounds.height, styleString(container)), 
        itfits) {
            var fit = Math.max(1 - bounds.width / maxwidth, 1 - bounds.height / maxheight), bestfit = container.bestfit || 1.5;
            if (trace_adjust && (container.bestscale ? fdjtLog("%s %o~%o vs. %o~%o", goodenough > fit ? "Good enough!" : bestfit > fit ? "Better!" : "Worse!", scale, fit, container.bestscale, container.bestfit) : fdjtLog("First fit %o~%o", scale, fit)), 
            bestfit > fit && (container.bestscale = scale, container.bestfit = fit), goodenough > fit) return container.goodscale = scale, 
            void 0;
        }
        var rh = maxheight / bounds.height, rw = maxwidth / bounds.width, newscale = itfits ? scale * Math.sqrt(maxwidth * maxheight / (bounds.width * bounds.height)) : rw > rh ? scale * rh : scale * rw;
        trace_adjust && fdjtLog("[%fs] Trying newscale=%o, rw=%o rh=%o", fdjt.ET(), newscale, rw, rh), 
        applyScale(container, newscale, trace_adjust);
    }
    function scale_node(node, fudge, origin, shrink) {
        origin || (origin = node.getAttribute("data-origin")), shrink || (shrink = node.getAttribute("data-shrink")), 
        fudge || (fudge = node.getAttribute("data-fudge"));
        var first = node.firstChild, wrapper = "fdjtadjusted" === first.className ? first : getFirstChild(node, "fdjtadjusted");
        wrapper && wrapper.setAttribute("style", "");
        var geom = getGeometry(node, !1, !0), inside = getInsideBounds(node), avail_width = fudge ? fudge * geom.inner_width : geom.inner_width, avail_height = fudge ? fudge * geom.inner_height : geom.inner_height;
        if (avail_height >= inside.height && avail_width >= inside.width) {
            if (!shrink) return;
            if (avail_height > inside.height && inside.height >= .9 * avail_height || geom.inner_width > inside.width && inside.width >= .9 * avail_height) return;
        }
        if (!wrapper) {
            for (var nodes = [], children = node.childNodes, i = 0, lim = children.length; lim > i; ) nodes.push(children[i++]);
            for (wrapper = fdjtDOM("div.fdjtadjusted"), i = 0, lim = nodes.length; lim > i; ) wrapper.appendChild(nodes[i++]);
            node.appendChild(wrapper);
        }
        var w_scale = avail_width / inside.width, h_scale = avail_height / inside.height, scale = h_scale > w_scale ? w_scale : h_scale;
        wrapper.style[fdjtDOM.transform] = "scale(" + scale + "," + scale + ")", wrapper.style[fdjtDOM.transformOrigin] = origin || "50% 0%";
    }
    function scaleAll() {
        for (var all = fdjtDOM.$(".fdjtadjustfit"), i = 0, lim = all.length; lim > i; ) scale_node(all[i++]);
    }
    function scaleToFit(node, fudge, origin) {
        return fdjtDOM.addClass(node, "fdjtadjustfit"), fudge && "number" != typeof fudge && (fudge = .9), 
        fudge && node.setAttribute("data-fudge", fudge), origin && node.setAttribute("data-origin", origin), 
        scale_node(node, fudge, origin), node;
    }
    function scale_revert(node, wrapper) {
        if (wrapper || (hasClass(node, "fdjtadjusted") ? (wrapper = node, node = wrapper.parentNode) : wrapper = "fdjtadjusted" === node.firstChild.className ? node.firstChild : getFirstChild(node, "fdjtadjusted")), 
        node && wrapper) {
            for (var nodes = [], children = wrapper.childNodes, i = 0, lim = children.length; lim > i; ) nodes.push(children[i++]);
            var frag = document.createDocumentFragment();
            for (i = 0, lim = nodes.length; lim > i; ) frag.appendChild(nodes[i++]);
            return node.replaceChild(frag, wrapper), node;
        }
        return !1;
    }
    function revertAll() {
        for (var all = fdjtDOM.$(".fdjtadjusted"), i = 0, lim = all.length; lim > i; ) {
            var wrapper = all[i++];
            scale_revert(wrapper.parentNode, wrapper);
        }
    }
    function getHTML() {
        for (var children = document.childNodes, i = 0, lim = children.length; lim > i; ) {
            if ("HTML" === children[i].tagName) return children[i];
            i++;
        }
        return !1;
    }
    function getHEAD() {
        for (var children = document.childNodes, i = 0, lim = children.length; lim > i; ) {
            if ("HTML" === children[i].tagName) {
                var grandchildren = children[i].childNodes;
                for (i = 0, lim = grandchildren.length; lim > i; ) {
                    if ("HEAD" === grandchildren[i].tagName) return grandchildren[i];
                    i++;
                }
                return !1;
            }
            i++;
        }
        return !1;
    }
    function getMetaSchemas() {
        for (var links = document.getElementsByTagName && document.getElementsByTagName("link") || document.head.getElementsByTagName && document.head.getElementsByTagName("link") || getChildren(document, "link"), i = 0, lim = links.length; lim > i; ) {
            var link = links[i++];
            if (link.rel && link.href && 0 === link.rel.search("schema.")) {
                var tag = link.rel.slice(7), href = link.href;
                tag2schema[tag] ? fdjtLog.warn("Conflicting schemas for %s", tag) : (schema2tag[href] ? schema2tag[href].push(tag) : schema2tag[href] = [ tag ], 
                tag2schema[tag] = href);
            }
        }
    }
    function getNameRX(name, foldcase) {
        var prefix, schema, prefixes = [];
        if ("string" == typeof name && foldcase === void 0 && ("^" === name[0] ? (foldcase = !1, 
        name = name.slice(1)) : "~" === name[0] && (foldcase = !0, name = name.slice(1))), 
        foldcase === void 0 && (foldcase = !0), "string" != typeof name) return name;
        if ("{" === name[0]) {
            schema = !1;
            var schema_end = name.indexOf("}");
            return schema_end > 2 && (schema = name.slice(1, schema_end)), prefixes = schema && schema2tag[schema] || [], 
            RegExp("\\b(" + escapeRX(schema) + "|" + prefixes.join("|") + ")[.]" + name.slice(schema_end + 1) + "\\b", foldcase ? "i" : "");
        }
        if ("=" === name[0]) return RegExp("\\b" + escapeRX(name = name.slice(1)) + "\\b", foldcase ? "i" : "");
        if ("*" === name[0] && "." === name[1]) return RegExp("\\b([^.]\\.)?" + name.slice(2) + "\\b", foldcase ? "i" : "");
        if (name.indexOf(".") > 0) {
            var dot = name.indexOf(".");
            return prefix = name.slice(0, dot), (schema = app_schemas[prefix]) ? (prefixes = schema && schema2tag[schema] ? schema2tag[schema] : [ prefix ], 
            RegExp("\\b(" + escapeRX(schema) + "|" + prefixes.join("|") + ")\\." + name.slice(dot + 1) + "\\b", foldcase ? "i" : "")) : RegExp("\\b" + escapeRX(name) + "\\b", foldcase ? "i" : "");
        }
        return RegExp("\\b" + name + "\\b", foldcase ? "i" : "");
    }
    function getMeta(name, multiple, foldcase, dom) {
        for (var results = [], elts = document.getElementsByTagName ? document.getElementsByTagName("META") : getChildren(document, "META"), rx = getNameRX(name, foldcase), i = 0; elts.length > i; ) {
            var elt = elts[i++];
            if (elt && elt.name && elt.name.search(rx) >= 0) {
                if (!multiple) return dom ? elt : elt.content;
                dom ? results.push(elt) : results.push(elt.content);
            }
        }
        return multiple ? results : !1;
    }
    function getLink(name, multiple, foldcase, dom, attrib) {
        for (var results = [], elts = document.getElementsByTagName ? document.getElementsByTagName("LINK") : document.body && document.body.getElementsByTagName ? document.body.getElementsByTagName("LINK") : getChildren(document, "LINK"), rx = getNameRX(name, foldcase), i = 0; elts.length > i; ) {
            var elt = elts[i++];
            if (elt && elt.rel && elt.rel.search(rx) >= 0) {
                if (!multiple) return dom ? elt : attrib ? elt.getAttribute("href") : elt.href;
                dom ? results.push(elt) : attrib ? results.push(elt.getAttribute("href")) : results.push(elt.href);
            }
        }
        return multiple ? results : !1;
    }
    function next_node(node) {
        for (;node; ) {
            if (node.nextSibling) return node.nextSibling;
            node = node.parentNode;
        }
        return !1;
    }
    function next_element(node) {
        if (node.nextElementSibling) return node.nextElementSibling;
        for (var scan = node; scan = scan.nextSibling; ) {
            if (!scan) return null;
            if (1 === scan.nodeType) break;
        }
        return scan;
    }
    function scan_next(node, test, justelts) {
        if (!test) return justelts ? havechildren ? node.nextElementSibling : next_element(node) : next_node(node);
        for (var scan = justelts ? havechildren ? node.nextElementSibling : next_element(node) : node.nextSibling || next_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? scan.nextElementSibling || next_element(scan) : scan.nextSibling || next_node(scan);
        }
        return !1;
    }
    function forward_node(node) {
        if (node.childNodes && node.childNodes.length > 0) return node.childNodes[0];
        for (;node; ) {
            if (node.nextSibling) return node.nextSibling;
            node = node.parentNode;
        }
        return !1;
    }
    function forward_element(node, n) {
        var scan, i, lim;
        if (n) {
            for (i = 0, scan = node; n > i; ) scan = forward_element(scan), i++;
            return scan;
        }
        if (havechildren) {
            if (node.children && node.children.length > 0) return node.children[0];
            if (scan = node.nextElementSibling) return scan;
            for (;node = node.parentNode; ) if (scan = node.nextElementSibling) return scan;
            return !1;
        }
        if (node.childNodes) {
            var children = node.childNodes;
            for (i = 0, lim = children.length; lim > i; ) if ((scan = children[i++]) && 1 === scan.nodeType) return scan;
        }
        for (;scan = node.nextSibling; ) if (1 === scan.nodeType) return scan;
        for (;node = node.parentNode; ) if (scan = next_element(node)) return scan;
        return !1;
    }
    function scan_forward(node, test, justelts) {
        if (!test) return justelts ? forward_element(node) : forward_node(node);
        for (var scan = justelts ? forward_element(node) : forward_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? next_element(scan) : next_node(scan);
        }
        return !1;
    }
    function prev_node(node) {
        for (;node; ) {
            if (node.previousSibling) return node.previousSibling;
            node = node.parentNode;
        }
        return !1;
    }
    function previous_element(node) {
        if (havechildren) return node.previousElementSibling;
        for (var scan = node; scan = scan.previousSibling; ) {
            if (!scan) return null;
            if (1 === scan.nodeType) break;
        }
        return scan ? scan : scan.parentNode;
    }
    function scan_previous(node, test, justelts) {
        if (!test) return justelts ? havechildren ? node.previousElementSibling : previous_element(node) : prev_node(node);
        for (var scan = justelts ? havechildren ? node.previousElementSibling : previous_element(node) : prev_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? havechildren ? scan.previousElementSibling : previous_element(scan) : prev_node(scan);
        }
        return !1;
    }
    function backward_node(node) {
        if (node.previousSibling) {
            var scan = node.previousSibling;
            if (1 !== scan.nodeType) return scan;
            for (;scan; ) {
                var children = scan.childNodes;
                if (!children) return scan;
                if (0 === children.length) return scan;
                scan = children[children.length - 1];
            }
            return scan;
        }
        return node.parentNode;
    }
    function backward_element(node) {
        if (havechildren) return node.previousElementSibling ? get_final_child(node.previousElementSibling) : node.parentNode;
        if (node.previousElementSibling || node.previousSibling) {
            var start = node.previousElementSibling || node.previousSibling;
            return 1 === start.nodeType ? get_final_child(start) : start;
        }
        return node.parentNode;
    }
    function get_final_child(node) {
        if (1 === node.nodeType) {
            if (node.childNodes) {
                var children = node.childNodes;
                if (!children.length) return node;
                for (var scan = children.length - 1; scan >= 0; ) {
                    var child = get_final_child(children[scan--]);
                    if (child) return child;
                }
                return node;
            }
            return node;
        }
        return !1;
    }
    function scan_backward(node, test, justelts) {
        if (!test) return justelts ? backward_element(node) : backward_node(node);
        for (var scan = justelts ? backward_element(node) : backward_node(node); scan; ) {
            if (test(scan)) return scan;
            scan = justelts ? next_element(scan) : next_node(scan);
        }
        return !1;
    }
    function viewHeight(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? (win || (win = window), 
        win.hasOwnProperty("innerHeight") ? win.innerHeight : win.document && window.document.documentElement && window.document.documentElement.clientHeight ? window.document.documentElement.clientHeight : win.offsetHeight) : void 0;
    }
    function viewWidth(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? (win || (win = window), 
        win.hasOwnProperty("innerWidth") ? win.innerWidth : win.document && window.document.documentElement && window.document.documentElement.clientWidth ? window.document.documentElement.clientWidth : win.offsetWidth) : void 0;
    }
    function getOrientation(win) {
        if ("string" != typeof win || (win = document.getElementById(win))) {
            if (win || (win = window), win.hasOwnProperty("orientation")) return 90 === win.orientation || -90 === win.orientation ? "landscape" : "portrait";
            var w = viewWidth(win), h = viewHeight(win);
            return w > h ? "landscape" : "portrait";
        }
    }
    function getNodeID(elt) {
        var nelt, id = elt.id;
        if (id) return id;
        for (id = "TMPID_" + unique + "_" + id_count++; !(nelt = document.getElementById(id)) || nelt === elt; ) id = "TMPID_" + unique + "_" + id_count++, 
        (nelt = document.getElementById(id)) && nelt !== elt || (unique = Math.floor(1e5 * Math.random())), 
        id = "TMPID_" + unique + "_" + id_count++;
        return elt.id = id, id;
    }
    function stripIDs(node, nametoo, moveto) {
        if (nametoo || (nametoo = !1), moveto || (moveto = !1), node.id && (moveto && node.setAttribute(moveto, node.id), 
        node.id = "", node.removeAttribute("id")), nametoo && node.name && (node.name = null), 
        node.childNodes && node.childNodes.length) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
            var child = children[i++];
            1 === child.nodeType && stripIDs(child, nametoo, moveto);
        }
    }
    function getCSSRule(ruleName, deleteFlag) {
        if (ruleName = ruleName.toLowerCase(), document.styleSheets) {
            for (var i = 0; document.styleSheets.length > i; i++) for (var styleSheet = document.styleSheets[i], cssRules = styleSheet.cssRules || styleSheet.rules, n_rules = cssRules && cssRules.length, ii = 0; n_rules > ii; ) {
                if (cssRules[ii]) {
                    var cssRule = cssRules[ii];
                    if (cssRule.selectorText.toLowerCase() === ruleName) return "delete" === deleteFlag ? (styleSheet.cssRules && styleSheet.deleteRule(ii), 
                    !0) : cssRule;
                }
                ii++;
            }
            return !1;
        }
        return !1;
    }
    function dropCSSRule(ruleName) {
        return getCSSRule(ruleName, "delete");
    }
    function addCSSRule(selector, style, sheet) {
        if (!sheet) {
            var styles = fdjtID("FDJTSTYLES");
            if (!styles) {
                var head = document.getElementsByTagName("HEAD");
                if (0 === head.length) return;
                head = head[0], styles = fdjtDOM("style#FDJTSTYLES"), head.appendChild(styles);
            }
            sheet = styles.sheet;
        }
        if (sheet) {
            if (sheet.insertRule || sheet.addRule) {
                var rules = sheet.cssRules || sheet.rules, at = rules.length;
                return sheet.insertRule ? sheet.insertRule(selector + " {" + style + "}", at) : sheet.addRule(selector, style, at), 
                rules[at];
            }
            return !1;
        }
        return !1;
    }
    function checkSVG() {
        var root = document.documentElement || document.body;
        return nosvg === void 0 && (nosvg = document.implementation && document.implementation.hasFeature ? !document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1") : "Microsoft Internet Explorer" === navigator.appName ? !0 : navigator.mimeTypes["image/svg+xml"] ? !1 : !0), 
        nosvg ? (addClass(root, "_NOSVG"), dropClass(root, "_USESVG")) : (dropClass(root, "_NOSVG"), 
        addClass(root, "_USESVG")), !nosvg;
    }
    function checkChildren() {
        havechildren = document && document.body && document.body.childNodes && document.body.children;
    }
    function useBMP() {
        for (var hasSuffix = fdjtString.hasSuffix, images = fdjt.$("IMG"), i = 0, lim = images.length; lim > i; ) {
            var image = images[i++], src = image.src;
            if (src && (hasSuffix(src, ".svg") || hasSuffix(src, ".svgz"))) {
                var bmp = image.getAttribute("bmp");
                bmp && (image.setAttribute("svg", image.src), image.src = bmp);
            }
        }
    }
    function useSVG() {
        for (var hasSuffix = fdjtString.hasSuffix, images = fdjt.$("IMG"), i = 0, lim = images.length; lim > i; ) {
            var image = images[i++], src = image.src;
            if (src && !hasSuffix(src, ".svg") && !hasSuffix(src, ".svgz") && image.getAttribute("svg")) {
                var svg = image.getAttribute("svg");
                image.setAttribute("bmp", image.src), image.src = svg;
            }
        }
    }
    function prefSVG() {
        nosvg || useSVG();
    }
    function node2text(node, accum) {
        var i, lim;
        if (accum || (accum = ""), !node.nodeType && node.length) {
            for (i = 0, lim = node.length; lim > i; ) accum = node2text(node[i++], accum);
            return accum;
        }
        if (3 === node.nodeType) {
            var stringval = node.nodeValue;
            return stringval && (accum += stringval), accum;
        }
        if (1 === node.nodeType) {
            var style = getStyle(node), children = node.childNodes;
            if ("string" == typeof node.className && node.className.search(/\bfdjtskiptext\b/) >= 0) return accum;
            if ("none" === style.display || "hidden" === style.visibility || "static" !== style.position && "" !== style.position) return accum;
            for (i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                if (3 === child.nodeType) {
                    var s = child.nodeValue;
                    s && (accum += s);
                } else accum = node2text(child, accum);
            }
            return accum;
        }
        return accum;
    }
    function get_text_pos(node, pos, cur, starting) {
        var i, lim;
        if (cur > pos) return !1;
        if (!node.nodeType && node.length) {
            for (i = 0, lim = node.length; lim > i; ) if (cur = get_text_pos(node[i++], pos, cur, starting), 
            "number" != typeof cur) return cur;
            return cur;
        }
        if (3 === node.nodeType) {
            var stringval = node.nodeValue;
            return cur + stringval.length > pos ? {
                node: node,
                off: pos - cur
            } : pos === cur + stringval.length ? {
                node: node,
                off: pos - cur,
                atend: !0
            } : cur + stringval.length;
        }
        if (1 === node.nodeType) {
            var style = getStyle(node), children = node.childNodes;
            if ("string" == typeof node.className && node.className.search(/\bfdjtskiptext\b/) >= 0) return cur;
            if ("none" === style.display || "hidden" === style.visibility || "static" !== style.position && "" !== style.position) return cur;
            for (i = 0, lim = children.length; lim > i; ) if (cur = get_text_pos(children[i++], pos, cur, starting), 
            "number" != typeof cur) {
                if (starting && cur.atend) {
                    for (cur = pos; lim > i; ) {
                        var next = get_text_pos(children[i++], cur, pos, starting);
                        if (next && "number" != typeof next) return next;
                    }
                    return cur;
                }
                return cur;
            }
            return cur;
        }
        return cur;
    }
    function textPos(node, pos, sofar) {
        var result = get_text_pos(node, pos, sofar || 0);
        return "number" != typeof result ? result : {
            node: node,
            off: pos
        };
    }
    function get_text_off(scan, upto, sofar) {
        if (sofar || (sofar = 0), scan === upto) return [ sofar ];
        if (3 === scan.nodeType) return sofar + scan.nodeValue.length;
        if (1 === scan.nodeType) {
            for (var children = scan.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                if (sofar = get_text_off(child, upto, sofar), "number" != typeof sofar) return sofar;
            }
            return sofar;
        }
        return sofar;
    }
    function textOff(node, pos) {
        var off = get_text_off(node, pos, 0);
        return off ? off[0] : !1;
    }
    function getIDParent(scan) {
        for (;scan && !scan.id; ) scan = scan.parentNode;
        return scan;
    }
    function getRegexString(needle, shyphens, before, after) {
        return shyphens ? (needle = needle.replace("", ""), (before || "") + needle.replace(/\S/g, "$&?").replace(/([()\[\]\.\?\+\*])\?/gm, "[$1]").replace("? ", " ").replace(/\s+/g, "(\\s+)") + (after || "")) : (before || "") + needle.replace(/[()\[\]\.\?\+\*]/gm, "[$&]").replace(/\s+/g, "(\\s+)") + (after || "");
    }
    function textRegExp(needle, foldcase, shyphens, before, after) {
        return shyphens === void 0 && (shyphens = !0), RegExp(getRegexString(needle, shyphens, before, after), foldcase ? "igm" : "gm");
    }
    function wordRegExp(needle, foldcase, shyphens) {
        return shyphens === void 0 && (shyphens = !0), RegExp(getRegexString(needle, shyphens, "\\b", "\\b"), foldcase ? "igm" : "gm");
    }
    function findString(node, needle, off, count) {
        off === void 0 && (off = 0), count === void 0 && (count = 1), needle = needle.replace(//gm, "");
        for (var match = !1, fulltext = node2text(node), sub = 0 === off ? fulltext : fulltext.slice(off), scan = sub.replace(//gm, ""), pat = "string" == typeof needle ? textRegExp(needle, !1, !1) : needle; match = pat.exec(scan); ) {
            if (1 === count) {
                var loc = match.index;
                if (scan !== sub) for (var i = 0; loc > i; ) "" === sub[i] && loc++, i++;
                var absloc = loc + off, start = get_text_pos(node, absloc, 0, !0), end = get_text_pos(node, absloc + match[0].length, 0);
                if (!start || !end) return !1;
                var range = document.createRange();
                if (start.atend) {
                    var txt = firstText(start.node.nextSibling);
                    txt ? range.setStart(txt, 0) : range.setStart(start.node, start.off);
                } else range.setStart(start.node, start.off);
                return range.setEnd(end.node, end.off), range;
            }
            count--, off = match.index + match[0].length, scan = scan.slice(off);
        }
        return !1;
    }
    function findMatches(node, needle, off, count) {
        off === void 0 && (off = 0), count === void 0 && (count = -1);
        for (var match = !1, results = [], fulltext = node2text(node), scan = 0 === off ? fulltext : fulltext.slice(off), pat = "string" == typeof needle ? textRegExp(needle) : needle; 0 !== count && (match = pat.exec(scan)); ) {
            var loc = match.index + off, start = get_text_pos(node, loc, 0), end = get_text_pos(node, loc + match[0].length, 0);
            if (!start || !end) return !1;
            var range = document.createRange();
            if ("number" == typeof start) range.setStart(node, start); else if (start.atend) {
                var txt = firstText(start.node.nextSibling);
                txt ? range.setStart(txt, 0) : range.setStart(start.node, start.off);
            } else range.setStart(start.node, start.off);
            "number" == typeof end ? range.setEnd(node, end) : range.setEnd(end.node, end.off), 
            results.push(range), count--;
        }
        return results;
    }
    function firstText(node) {
        return node ? 3 === node.nodeType ? node : 1 === node.nodeType ? firstText(node.firstChild) : !1 : !1;
    }
    function checkTransitionEvents() {
        var div = document.createElement("div");
        if (div.removeEventListener) {
            var handler = function(e) {
                fdjtDOM.transitionEnd = e.type;
                for (var i = 0, lim = transition_events.length; lim > i; ) div && div.removeEventListener ? div.removeEventListener(transition_events[i++], handler) : i++;
            };
            div.setAttribute("style", "position:absolute;top:0px;transition:top 1ms ease;-webkit-transition:top 1ms ease;-moz-transition:top 1ms ease;-o-transition:top 1ms ease;-ms-transition:top 1ms ease;");
            for (var i = 0, lim = transition_events.length; lim > i; ) div.addEventListener(transition_events[i++], handler, !1);
            document.documentElement.appendChild(div), setTimeout(function() {
                div.style.top = "100px", setTimeout(function() {
                    div.parentNode.removeChild(div), div = handler = null;
                }, 2e3);
            }, 0);
        }
    }
    function setupCustomInputs(dom) {
        dom || (dom = document.body);
        for (var input_elt = document.createElement("input"), i = 0, ntypes = custom_input_types.length; ntypes > i; ) {
            var typename = custom_input_types[i++];
            try {
                input_elt.type = typename;
            } catch (err) {}
            if (input_elt.type === typename) for (var inputs = getChildren(document.body, ".fdjt" + typename + "input"), j = 0, lim = inputs.length; lim > j; ) {
                var input = inputs[j++];
                "INPUT" === input.tagName && (input.type = typename);
            }
        }
    }
    function checkMedia() {
        var media = "media";
        if (window.matchMedia) {
            var mm = window.matchMedia("handheld");
            mm.match && (media += " handheld"), mm = window.matchMedia("(max-width:500px)"), 
            mm.match && (media += " narrow"), mm = window.matchMedia("(min-width:1000px)"), 
            mm.match && (media += " wide"), mm = window.matchMedia("(-webkit-min-device-pixel-ratio:1.5),(-min-resolution:15dp)"), 
            mm.match && (media += " hires");
        }
        fdjt.media = media;
    }
    function getMediaState() {
        return window.getComputedStyle(document.body, ":before").content;
    }
    function insertText(target, text, off) {
        var pos = target.selectionStart, current = target.value;
        target.value = current && "number" == typeof pos && pos >= 0 ? current.slice(0, pos) + text + current.slice(pos) : text, 
        "number" == typeof off && (target.selectionEnd = target.selectionStart = pos + off);
    }
    function playAudio(id) {
        var elt = document.getElementById(id);
        elt && elt.play && (elt.paused || (elt.pause(), elt.currentTime = 0), elt.play());
    }
    function tweakImage(elt, tw, th) {
        var style = elt.style;
        style.maxHeight = style.minHeight = "inherit", style.maxWidth = style.minWidth = "inherit";
        var w = elt.offsetWidth, h = elt.offsetHeight, sw = tw / w, sh = th / h;
        sh > sw ? (style.width = Math.round(w * sw) + "px", style.height = "auto") : (style.height = Math.round(h * sh) + "px", 
        style.width = "auto");
    }
    function makeBlob(string, type) {
        if ("string" == typeof string && 0 === string.search("data:")) {
            if (!type) {
                var typeinfo = /data:([^;]+);/.exec(string);
                typeinfo && (type = typeinfo[1]);
            }
            var elts = string.split(","), byteString = atob(elts[1]);
            byteString = elts[0].indexOf("base64") >= 0 ? atob(elts[1]) : window.unescape(elts[1]);
            for (var ab = new ArrayBuffer(byteString.length), ia = new Uint8Array(ab), i = 0; byteString.length > i; i++) ia[i] = byteString.charCodeAt(i);
            return new Blob([ ab ], {
                type: type || "application"
            });
        }
        return !1;
    }
    function data2URL(datauri) {
        return URL && URL.createObjectURL ? URL.createObjectURL(makeBlob(datauri)) : datauri;
    }
    function addUXClasses() {
        var device = fdjt.device, prefix = fdjt.cxprefix || "_", html = document.documentElement;
        device.ios && addClass(html, prefix + "IOS"), device.touch && addClass(html, prefix + "TOUCH"), 
        device.mouse && addClass(html, prefix + "MOUSE"), device.android && addClass(html, prefix + "Android");
    }
    function focusElt(id) {
        var elt = document.getElementById(id);
        elt && setTimeout(function() {
            elt.focus();
        }, 10);
    }
    function blurElt(id) {
        var elt = document.getElementById(id);
        elt && setTimeout(function() {
            elt.blur();
        }, 10);
    }
    function windowFocus(evt) {
        evt = evt || window.event, addClass(document.body, "_FOCUS");
    }
    function windowBlur(evt) {
        evt = evt || window.event, dropClass(document.body, "_FOCUS");
    }
    function trackPageFocus() {
        windowFocus(), addListener(window, "focus", windowFocus), addListener(window, "blur", windowBlur);
    }
    var usenative = !0, fdjtString = fdjt.String, fdjtLog = fdjt.Log, aslice = Array.prototype.slice, css_selector_regex = /((^|[.#])[^.#\[\s]+)|(\[[^ \]=]+=[^\]]+\])|(\[[^ \]=]+\])/gi;
    fdjtDOM.useNative = function(flag) {
        return flag === void 0 ? usenative : (usenative = flag, void 0);
    }, fdjtDOM.clone = function(node) {
        return node.cloneNode(!0);
    }, fdjtDOM.ie = getIE(), fdjtDOM.iem = Math.floor(fdjtDOM.ie), fdjt.ID = fdjtID, 
    fdjtDOM.appendArray = domappend, fdjtDOM.toArray = toArray, fdjtDOM.Array = TOA, 
    fdjtDOM.slice = TOA, fdjtDOM.wrapChildren = wrapChildren, fdjtDOM.unwrapChildren = unwrapChildren, 
    fdjtDOM.parsePX = parsePX, fdjtDOM.getLineHeight = getLineHeight;
    var whitespace_pat = /(\s)+/, trimspace_pat = /^(\s)+|(\s)+$/, classpats = {};
    fdjtDOM.nodeString = nodeString, fdjtDOM.make = make, fdjtDOM.getElementValues = getElementValues, 
    fdjtDOM.getElementValue = getElementValue, fdjtDOM.hasClass = hasClass, fdjtDOM.addClass = addClass, 
    fdjtDOM.aC = addClass, fdjtDOM.classAdder = function(elt, classname) {
        return function() {
            elt && addClass(elt, classname);
        };
    }, fdjtDOM.dropClass = dropClass, fdjtDOM.dC = dropClass, fdjtDOM.classDropper = function(elt, classname) {
        return function() {
            elt && dropClass(elt, classname);
        };
    }, fdjtDOM.swapClass = swapClass, fdjtDOM.setClass = setClass, fdjtDOM.toggleClass = toggleClass, 
    fdjtDOM.tC = toggleClass, fdjtDOM.toggleParent = toggleParent, fdjtDOM.tP = toggleParent;
    var text_input_types = fdjtDOM.text_input_types = /text|url|email|search|tel|number|range|password/i;
    fdjtDOM.isTextInput = isTextInput, fdjtDOM.isImage = isImage;
    var selectors = {};
    Selector.prototype.match = function(elt) {
        if (elt.matches) return elt.matches(this.spec);
        if (elt.matchesSelector) return elt.matchesSelector(this.spec);
        var i, lim;
        if (this.compound) {
            var compound = this.compound;
            for (i = 0, lim = compound.length; lim > i; ) if (compound[i++].match(elt)) return !0;
            return !1;
        }
        if (this.tag && this.tag !== elt.tagName) return !1;
        if (this.id && this.id !== elt.id) return !1;
        if (this.classes) {
            if ("string" != typeof elt.className) return !1;
            var classname = elt.className, classes = this.classes;
            for (i = 0, lim = classes.length; lim > i; ) if (0 > classname.search(classes[i++])) return !1;
        }
        if (this.attribs) {
            var attribs = this.attribs;
            for (var name in attribs) if (attribs.hasOwnProperty(name)) {
                var val = elt.getAttribute(name);
                if (!val) return !1;
                var need = this[name];
                if (need === !0) ; else if ("string" == typeof need) {
                    if (need !== val) return !1;
                } else if (0 > val.search(need)) return !1;
            }
        }
        return !0;
    }, Selector.prototype.find = function(elt, results) {
        var probe, i, lim;
        if (results || (results = []), this.compound) {
            var compound = this.compound;
            for (i = 0, lim = compound.length; lim > i; ) compound[i++].find(elt, results);
            return results;
        }
        if (this.id) return probe = document.getElementById(this.id), probe ? this.match(probe) ? (results.push(probe), 
        results) : results : results;
        var candidates = [], classnames = this.classnames, attribs = this.attribs;
        if (this.classes) elt.getElementsByClassName ? candidates = elt.getElementsByClassName(classnames[0]) : gatherByClass(elt, this.classes[0], candidates); else if (this.tag && elt.getElementsByTagName) candidates = elt.getElementsByTagName(this.tag); else if (this.attribs) {
            attribs = this.attribs;
            for (var name in attribs) if (attribs.hasOwnProperty(name)) {
                gatherByAttrib(elt, name, attribs[name], candidates);
                break;
            }
        } else this.tag && gatherByTag(elt, this.tag, candidates);
        if (0 === candidates.length) return candidates;
        if (this.tag && !this.classes && !this.attribs || !this.tag && this.classes && 1 === this.classes.length && !this.attribs) return results.length ? extendArray(results, candidates) : candidates instanceof Array ? candidates : toArray(candidates);
        for (i = 0, lim = candidates.length; lim > i; ) {
            var candidate = candidates[i++];
            this.match(candidate) && results.push(candidate);
        }
        return results;
    }, fdjtDOM.Selector = Selector, fdjtDOM.sel = function(spec) {
        return spec ? spec instanceof Selector ? spec : spec instanceof Array ? spec.length ? new Selector(spec.join(",")) : !1 : "string" == typeof spec ? new Selector(spec) : (fdjtLog.warn("Non selector spec: %o", spec), 
        !1) : !1;
    }, fdjtDOM.getParent = getParent, fdjtDOM.hasParent = getParent, fdjtDOM.$P = getParent, 
    fdjtDOM.inherits = function(node, spec) {
        var sel = new Selector(spec);
        return sel.match(node) ? node : getParent(node, sel);
    }, fdjtDOM.getParents = function(node, sel) {
        for (var results = [], scan = node, parent = !1; parent = getParent(scan, sel); ) results.push(parent), 
        scan = parent.parentNode;
        return results;
    }, fdjtDOM.getChildNodes = getChildNodes, fdjtDOM.getChildren = getChildren, fdjt.$ = fdjtDOM.$ = function(spec, root) {
        return toArray(getChildren(root || document, spec));
    }, fdjt.$1 = fdjtDOM.$1 = fdjtDOM.getChild = fdjtDOM.getFirstChild = getFirstChild, 
    fdjtDOM.getAttrib = function(elt, attrib, ns) {
        var probe;
        return ns && elt.getAttributeByNS && (probe = elt.getAttributeNS(attrib, ns)), probe ? probe : elt.getAttribute(attrib) || elt.getAttribute("data-" + attrib);
    }, fdjtDOM.findAttrib = function(scan, attrib, ns) {
        for (var dattrib = "data-" + attrib; scan; ) {
            if (ns && scan.getAttributeNS && scan.getAttributeNS(attrib, ns)) return scan.getAttributeNS(attrib, ns);
            if (scan.getAttribute) {
                if (scan.getAttribute(attrib)) return scan.getAttribute(attrib);
                if (scan.getAttribute(dattrib)) return scan.getAttribute(dattrib);
                scan = scan.parentNode;
            } else scan = scan.parentNode;
        }
        return !1;
    }, fdjtDOM.getFirstElement = getFirstElement, fdjtDOM.getLastElement = getLastElement, 
    fdjtDOM.replace = function(existing, replacement, leaveids) {
        var cur = existing;
        "string" == typeof existing && (cur = "#" === existing[0] ? document.getElementById(existing.slice(1)) : document.getElementById(existing)), 
        cur ? (cur.parentNode.replaceChild(replacement, cur), leaveids || cur.id && !replacement.id && (replacement.id = cur.id)) : fdjtLog.uhoh("Can't find %o to replace it with %o", existing, replacement);
    }, fdjtDOM.remove = remove_node, fdjtDOM.removeChildren = removeChildren, fdjtDOM.append = DOMappend, 
    fdjtDOM.prepend = DOMprepend, fdjtDOM.insertBefore = DOMinsertBefore, fdjtDOM.insertAfter = DOMinsertAfter, 
    fdjtDOM.Input = function(spec, name, value, title) {
        0 !== spec.search(/\w/) && (spec = "INPUT" + spec);
        var node = fdjtDOM(spec);
        return node.name = name, value && (node.value = value), title && (node.title = title), 
        node;
    }, fdjtDOM.Checkbox = function(name, value, checked) {
        var node = fdjtDOM("INPUT");
        return node.type = "checkbox", node.name = name, value && (node.value = value), 
        node.checked = checked ? !0 : !1, node;
    }, fdjtDOM.Anchor = function(href, spec) {
        spec = tag_spec(spec, "A");
        var node = fdjtDOM(spec);
        return node.href = href, domappend(node, aslice.call(arguments), 2), node;
    }, fdjtDOM.Image = function(src, spec, alt, title) {
        spec = tag_spec(spec, "IMG");
        var node = fdjtDOM(spec);
        return node.src = src, alt && (node.alt = alt), title && (node.title = title), domappend(node, aslice.call(arguments), 4), 
        node;
    }, fdjtDOM.getInputs = getInputs, fdjtDOM.getInput = function(root, name, type) {
        var results = getInputs(root, name || !1, type || !1);
        return results && 1 === results.length ? results[0] : results && results.length ? (fdjtLog.warn("Ambiguous input reference name=%o type=%o under %o", name, type, root), 
        results[0]) : !1;
    }, fdjtDOM.getInputValues = getInputValues, fdjtDOM.getInputValue = getInputValue, 
    fdjtDOM.getInputsFor = getInputsFor, fdjtDOM.getInputFor = function(root, name, value) {
        var results = getInputsFor(root, name || !1, value || !1);
        return results && 1 === results.length ? results[0] : results && results.length ? (fdjtLog.warn("Ambiguous input reference name=%o name=%o under %o", name, name, root), 
        results[0]) : !1;
    }, fdjtDOM.setInputs = setInputs, fdjtDOM.getStyle = getStyle, fdjtDOM.styleString = styleString;
    var display_styles = {
        DIV: "block",
        P: "block",
        BLOCKQUOTE: "block",
        H1: "block",
        H2: "block",
        H3: "block",
        H4: "block",
        H5: "block",
        H6: "block",
        H7: "block",
        H8: "block",
        UL: "block",
        LI: "list-item",
        DL: "block",
        DT: "list-item",
        DD: "list-item",
        SPAN: "inline",
        EM: "inline",
        STRONG: "inline",
        TT: "inline",
        DEFN: "inline",
        A: "inline",
        TD: "table-cell",
        TR: "table-row",
        TABLE: "table",
        PRE: "preformatted"
    };
    fdjtDOM.getDisplay = getDisplayStyle, fdjtDOM.textify = textify, Geometry.prototype.width = Geometry.prototype.height = Geometry.prototype.left = Geometry.prototype.right = Geometry.prototype.top = Geometry.prototype.bottom = 0, 
    XGeometry.prototype = new Geometry(), XGeometry.top_margin = XGeometry.bottom_margin = XGeometry.left_margin = XGeometry.right_margin = XGeometry.top_border = XGeometry.bottom_border = XGeometry.left_border = XGeometry.right_border = XGeometry.top_padding = XGeometry.bottom_padding = XGeometry.left_padding = XGeometry.right_padding = XGeometry.outer_height = XGeometry.outer_width = XGeometry.inner_height = XGeometry.inner_width = XGeometry.line_height = 0, 
    fdjtDOM.getGeometry = getGeometry, fdjtDOM.XGeometry = XGeometry, fdjtDOM.Geometry = Geometry, 
    fdjtDOM.geomString = geomString, fdjtDOM.isVisible = isVisible, fdjtDOM.isAtTop = isAtTop, 
    fdjtDOM.textWidth = textwidth, fdjtDOM.countBreaks = countBreaks;
    var nontext_content = /(img|object|svg|hr)/i;
    fdjtDOM.hasContent = hasContent, fdjtDOM.hasText = hasText, fdjtDOM.refresh = function(elt) {
        elt.className = elt.className;
    }, fdjtDOM.setAttrib = function(elt, attrib, val) {
        "string" == typeof elt && fdjtID(elt) && (elt = fdjtID(elt)), elt.setAttribute(attrib, val), 
        elt.className = elt.className;
    }, fdjtDOM.dropAttrib = function(elt, attrib) {
        "string" == typeof elt && fdjtID(elt) && (elt = fdjtID(elt)), elt.removeAttribute(attrib), 
        elt.className = elt.className;
    }, fdjtDOM.overflowing = function(node) {
        return node.scrollHeight > node.clientHeight;
    }, fdjtDOM.voverflow = function(node) {
        return node.scrollHeight / node.clientHeight;
    }, fdjtDOM.hoverflow = function(node) {
        return node.scrollWidth / node.clientWidth;
    }, fdjtDOM.addListener = addListener, fdjtDOM.defListeners = defListeners;
    var events_pat = /^([^:]+)$/, spec_events_pat = /^([^: ]+):([^: ]+)$/;
    fdjtDOM.addListeners = addListeners, fdjtDOM.removeListener = removeListener, fdjtDOM.T = eventTarget, 
    fdjtDOM.eventTarget = eventTarget, fdjtDOM.getTarget = eventTarget, fdjtDOM.cancel = cancelEvent, 
    fdjtDOM.triggerClick = triggerClick, fdjtDOM.pageScroll = pageScroll;
    var default_trace_adjust = !1;
    fdjtDOM.getInsideBounds = getInsideBounds, fdjtDOM.applyScale = applyScale, fdjtDOM.adjustToFit = adjustToFit, 
    fdjtDOM.adjustInside = adjustInside, fdjtDOM.insideBounds = getInsideBounds, fdjtDOM.finishScale = function(container) {
        var traced = container.traceadjust || fdjtDOM.trace_adjust || default_trace_adjust;
        return container.bestscale ? (container.scale === container.bestscale || applyScale(container, container.bestscale, traced), 
        traced && fdjtLog("Final scale %o~%o for %o style=%s", container.bestscale, container.bestfit, fdjtDOM.nodeString(container), fdjtDOM.styleString(container)), 
        delete container.bestscale, delete container.bestfit, delete container.goodscale, 
        void 0) : (applyScale(container, !1, traced), fdjtLog("No good scaling for %o style=%s", fdjtDOM.nodeString(container), fdjtDOM.styleString(container)), 
        void 0);
    }, fdjtDOM.scaleToFit = scaleToFit, fdjtDOM.scaleToFit.scaleNode = fdjtDOM.scaleToFit.adjust = scale_node, 
    fdjtDOM.scaleToFit.revert = scale_revert, fdjtDOM.scaleToFit.revertAll = revertAll, 
    fdjt.addInit(scaleAll), fdjtDOM.addListener(window, "resize", scaleAll), fdjtDOM.getHTML = getHTML, 
    fdjtDOM.getHEAD = getHEAD;
    var schema2tag = {}, tag2schema = {}, app_schemas = {};
    fdjtDOM.addAppSchema = function(name, spec) {
        app_schemas[name] = spec;
    };
    var escapeRX = fdjtString.escapeRX;
    fdjtDOM.getMeta = getMeta, fdjtDOM.getMetaElts = function(name) {
        var matchcase;
        return getMeta(name, !0, matchcase, !0);
    }, fdjtDOM.getLink = getLink, fdjtDOM.getLinks = function(name) {
        return getLink(name, !0);
    }, fdjtDOM.getLinkElts = function(name) {
        var matchcase;
        return getLink(name, !0, matchcase, !0);
    };
    var havechildren = document && document.body && document.body.childNodes && document.body.children;
    fdjtDOM.nextElt = next_element, fdjtDOM.forwardElt = forward_element, fdjtDOM.forward = scan_forward, 
    fdjtDOM.next = scan_next, fdjtDOM.prevElt = previous_element, fdjtDOM.backwardElt = backward_element, 
    fdjtDOM.backward = scan_backward, fdjtDOM.prev = scan_previous, fdjtDOM.viewTop = function(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? !win || win === window || window.Window && win instanceof window.Window ? (win = win || window, 
        win.pageYOffset || win.scrollY || win.document.documentElement.scrollTop || 0) : win.scrollTop : void 0;
    }, fdjtDOM.viewLeft = function(win) {
        return "string" != typeof win || (win = document.getElementById(win)) ? !win || win === window || window.Window && win instanceof window.Window ? (win = win || window, 
        win.pageXOffset || win.scrollX || win.document.documentElement.scrollLeft || 0) : win.scrollLeft : void 0;
    }, fdjtDOM.viewHeight = viewHeight, fdjtDOM.viewWidth = viewWidth, fdjtDOM.getOrientation = getOrientation;
    var id_count = 0, unique = Math.floor(1e5 * Math.random());
    fdjtDOM.getNodeID = getNodeID, fdjtDOM.stripIDs = stripIDs, fdjtDOM.getCSSRule = getCSSRule, 
    fdjtDOM.dropCSSRule = dropCSSRule, fdjtDOM.addCSSRule = addCSSRule;
    var nosvg;
    fdjtDOM.useSVG = useSVG, fdjtDOM.useBMP = useBMP, fdjtDOM.prefSVG = prefSVG, fdjtDOM.checkSVG = checkSVG, 
    fdjtDOM.init = fdjt.Init, fdjtDOM.addInit = fdjt.addInit, fdjt.addInit(checkChildren, "checkChildren"), 
    fdjt.addInit(checkSVG, "checkSVG"), navigator.userAgent.search("WebKit") >= 0 ? (fdjtDOM.transition || (fdjtDOM.transition = "-webkit-transition"), 
    fdjtDOM.transitionProperty || (fdjtDOM.transitionProperty = "-webkit-transition-property"), 
    fdjtDOM.transitionDuration || (fdjtDOM.transitionDuration = "-webkit-transition-duration"), 
    fdjtDOM.transitionDelay || (fdjtDOM.transitionDelay = "-webkit-transition-delay"), 
    fdjtDOM.transitionTiming || (fdjtDOM.transitionTiming = "-webkit-transition-timing-function"), 
    fdjtDOM.transform || (fdjtDOM.transform = "-webkit-transform"), fdjtDOM.transformOrigin || (fdjtDOM.transformOrigin = "-webkit-transform-origin"), 
    fdjtDOM.columnWidth || (fdjtDOM.columnWidth = "-webkit-column-width"), fdjtDOM.columnGap || (fdjtDOM.columnGap = "-webkit-column-gap")) : navigator.userAgent.search("Mozilla") >= 0 ? (fdjtDOM.transition || (fdjtDOM.transition = "-moz-transition"), 
    fdjtDOM.transitionProperty || (fdjtDOM.transitionProperty = "-moz-transition-property"), 
    fdjtDOM.transitionDuration || (fdjtDOM.transitionDuration = "-moz-transition-duration"), 
    fdjtDOM.transitionDelay || (fdjtDOM.transitionDelay = "-moz-transition-delay"), 
    fdjtDOM.transitionTiming || (fdjtDOM.transitionTiming = "-moz-transition-timing-function"), 
    fdjtDOM.transform || (fdjtDOM.transform = "-moz-transform"), fdjtDOM.transformOrigin || (fdjtDOM.transformOrigin = "-moz-transform-origin"), 
    fdjtDOM.columnWidth || (fdjtDOM.columnWidth = "MozColumnWidth"), fdjtDOM.columnGap || (fdjtDOM.columnGap = "MozColumnGap")) : (fdjtDOM.transition || (fdjtDOM.transition = "transition"), 
    fdjtDOM.transitionProperty || (fdjtDOM.transitionProperty = "transition-property"), 
    fdjtDOM.transitionDuration || (fdjtDOM.transitionDuration = "transition-duration"), 
    fdjtDOM.transitionDelay || (fdjtDOM.transitionDelay = "transition-delay"), fdjtDOM.transitionTiming || (fdjtDOM.transitionTiming = "transition-timing-function"), 
    fdjtDOM.transform || (fdjtDOM.transform = "transform"), fdjtDOM.transformOrigin || (fdjtDOM.transformOrigin = "-moz-transform-origin")), 
    document.hidden !== void 0 ? (fdjtDOM.isHidden = "hidden", fdjtDOM.vischange = "visibilitychange") : document.webkitHidden !== void 0 ? (fdjtDOM.isHidden = "webkitHidden", 
    fdjtDOM.vischange = "webkitvisibilitychange") : document.mozHidden !== void 0 ? (fdjtDOM.isHidden = "mozHidden", 
    fdjtDOM.vischange = "mozvisibilitychange") : document.msHidden !== void 0 ? (fdjtDOM.isHidden = "msHidden", 
    fdjtDOM.vischange = "msvisibilitychange") : (fdjtDOM.isHidden = !1, fdjtDOM.vischange = !1), 
    fdjtDOM.getSelectedRange = function(sel) {
        if (sel) ; else if (window.getSelection) sel = window.getSelection(); else {
            if (!document.selection) return !1;
            sel = document.selection.createRange();
        }
        if (!sel) return !1;
        if (sel.getRangeAt) return sel.rangeCount ? sel.getRangeAt(0) : !1;
        if (document.createRange) {
            var range = document.createRange();
            return range.setStart(sel.anchorNode, sel.anchorOffset), range.setEnd(sel.focusNode, sel.focusOffset), 
            range;
        }
        return !1;
    }, fdjtDOM.rangeIsEmpty = function(range) {
        return range ? range.startContainer === range.endContainer && range.startOffset === range.endOffset ? !0 : !1 : !0;
    }, fdjtDOM.clearSelection = function(sel) {
        sel || (sel = document.selection || window.getSelection()), sel.removeAllRanges ? sel.removeAllRanges() : sel.empty && sel.empty();
    }, fdjtDOM.node2text = node2text, fdjtDOM.textPos = textPos, fdjtDOM.refineRange = function(range) {
        if (3 === range.startContainer.nodeType && 3 === range.endContainer.nodeType) return range;
        var start_info = textPos(range.startContainer, range.startOffset), end_info = textPos(range.endContainer, range.endOffset), newrange = document.createRange();
        return newrange.setStart(start_info.node, start_info.off), newrange.setEnd(end_info.node, end_info.off), 
        newrange;
    }, fdjtDOM.textOff = textOff, fdjtDOM.getRangeInfo = function(range, within) {
        var start = range.startContainer;
        within || (within = getIDParent(start));
        var start_edge = textOff(within, start, 0), end = range.endContainer, ends_in = start === end ? within : getParent(end, within) ? within : getIDParent(end), end_edge = start === end ? start_edge : textOff(ends_in, end, 0);
        return {
            start: start_edge + range.startOffset,
            starts_in: within.id,
            ends_in: ends_in.id,
            end: end_edge + range.endOffset
        };
    }, fdjtDOM.getRegexString = getRegexString, fdjtDOM.textRegExp = textRegExp, fdjtDOM.wordRegExp = wordRegExp, 
    fdjtDOM.findString = findString, fdjtDOM.findMatches = findMatches;
    var transition_events = [ "transitionend", "webkitTransitionEnd", "mozTransitionEnd", "oTransitionEnd", "msTransitionEnd" ];
    fdjt.addInit(checkTransitionEvents, "checkTransitionEvents");
    var custom_input_types = [ "email", "number", "range", "tel", "url", "datetime", "datetime-local", "date", "time", "week", "month" ];
    return fdjtDOM.setupCustomInputs = setupCustomInputs, fdjt.addInit(setupCustomInputs, "CustomInputs"), 
    fdjtDOM.text_types = /\b(text|email|number|range|tel|url|datetime|datetime-local|date|time|week|month)\b/i, 
    fdjt.addInit(checkMedia, "matchMedia"), fdjt.getMediaState = getMediaState, fdjtDOM.insertText = insertText, 
    fdjt.addInit(getMetaSchemas, "MetaSchemas"), fdjt.noinit && void 0 !== _fdjt_init && _fdjt_init || fdjtDOM.addListener(window, "load", fdjtDOM.init), 
    fdjtDOM.playAudio = playAudio, fdjtDOM.tweakImage = tweakImage, fdjtString.makeBlob = makeBlob, 
    fdjtDOM.data2URL = data2URL, fdjtDOM.addUXClasses = addUXClasses, fdjtDOM.addUSClasses = addUXClasses, 
    fdjtDOM.addCXClasses = addUXClasses, fdjt.addInit(addUXClasses, "AddUXClasses"), 
    fdjtDOM.focus = focusElt, fdjtDOM.blur = blurElt, fdjt.addInit(trackPageFocus), 
    fdjtDOM.trace_adjust = !1, fdjtDOM;
}(), function() {
    "use strict";
    function fakeAnimationFrame(callback) {
        var currTime = new Date().getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        return lastTime = currTime + timeToCall, id;
    }
    function cancelFakeAnimationFrame(id) {
        clearTimeout(id);
    }
    for (var lastTime = 0, rAF = window.requestAnimationFrame && function(thunk) {
        window.requestAnimationFrame(thunk);
    }, cAF = window.cancelAnimationFrame && function(thunk) {
        window.cancelAnimationFrame(thunk);
    }, vendors = [ "webkit", "moz", "ms", "o" ], x = 0; vendors.length > x && !window.requestAnimationFrame; ++x) rAF = rAF || window[vendors[x] + "RequestAnimationFrame"], 
    cAF = cAF || window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    rAF || (rAF = fakeAnimationFrame, cAF = cancelFakeAnimationFrame), fdjt.DOM.rAF = fdjt.DOM.requestAnimationFrame = rAF, 
    fdjt.DOM.cAF = fdjt.DOM.cancelAnimationFrame = cAF;
}(), function() {
    "use strict";
    function toArray(arg) {
        return Array.prototype.slice.call(arg);
    }
    function adjustWrapperFont(wrapper, delta, done, size, min, max, w, h, fudge, dolog) {
        var nw, nh, newsize, ow = floor(wrapper.scrollWidth), oh = floor(wrapper.scrollHeight), wstyle = wrapper.style;
        if ("number" != typeof fudge && (fudge = 1), w >= ow && h >= oh && oh >= h - fudge) return size;
        for ((ow > w || oh > h) && (delta = -delta), delta > 0 && (wstyle.maxWidth = floor(w) + "px"), 
        size || (size = 100, wstyle.fontSize = size + "%"), min || (min = 20), max || (max = 150), 
        newsize = size + delta, wstyle.fontSize = newsize + "%", nw = floor(wrapper.scrollWidth), 
        nh = floor(wrapper.scrollHeight); size >= min && max >= size && (delta > 0 ? w > nw && h > nh : nw > w || nh > h); ) size = newsize, 
        newsize += delta, wstyle.fontSize = newsize + "%", dolog && fdjtLog("Adjust %o to %dx%d %o: size=%d=%d+(%d), %dx%d => %dx%d", wrapper.parentNode, w, h, wrapper, newsize, size, delta, ow, oh, nw, nh), 
        nw = floor(wrapper.scrollWidth), nh = floor(wrapper.scrollHeight);
        return wstyle.maxWidth = "", delta > 0 ? (wstyle.fontSize = size + "%", size) : newsize;
    }
    function adjustFontSize(node, min_font, max_font, fudge) {
        var h = node.offsetHeight, w = node.offsetWidth, dolog = hasClass(node, "_fdjtlog"), node_display = "";
        if ((0 === h || 0 === w) && (node_display = node.style.display, node.style.display = "initial", 
        h = node.offsetHeight, w = node.offsetWidth, 0 === h || 0 === w)) return node.style.display = node_display, 
        void 0;
        if (0 === h || 0 === w) return node.style.display = node_display, void 0;
        var wrapper = wrapChildren(node, "div.fdjtfontwrapper"), wstyle = wrapper.style, size = 100;
        if (wstyle.boxSizing = "border-box", wstyle.padding = wstyle.margin = "0px", wstyle.fontSize = size + "%", 
        wstyle.transitionProperty = "none", wstyle.transitionDuration = "0s", wstyle[fdjtDOM.transitionProperty] = "none", 
        wstyle[fdjtDOM.transitionDuration] = "0s", wstyle.visibility = "visible", 0 === h || 0 === w) return node.removeChild(wrapper), 
        fdjtDOM.append(node, toArray(wrapper.childNodes)), node.style.display = node_display, 
        void 0;
        var min = min_font || node.getAttribute("data-minfont") || 20, max = max_font || node.getAttribute("data-maxfont") || 200;
        if ("number" != typeof fudge && (fudge = node.getAttribute("data-fudge")), "string" == typeof min && (min = parseFloat(min, 10)), 
        "string" == typeof max && (max = parseFloat(max, 10)), "string" == typeof fudge && (fudge = parseInt(fudge, 10)), 
        "number" != typeof fudge && (fudge = 2), wstyle.width = wstyle.height = "100%", 
        w = wrapper.offsetWidth, h = wrapper.offsetHeight, wstyle.width = wstyle.height = "100%", 
        wstyle.maxWidth = wstyle.maxHeight = "100%", w = wrapper.offsetWidth, h = wrapper.offsetHeight, 
        wstyle.width = wstyle.height = "", size = adjustWrapperFont(wrapper, 10, !1, size, min, max, w, h, fudge, dolog), 
        size = adjustWrapperFont(wrapper, 5, !1, size, min, max, w, h, fudge, dolog), size = adjustWrapperFont(wrapper, 1, !1, size, min, max, w, h, fudge, dolog), 
        wstyle.maxWidth = wstyle.maxHeight = "", node.style.display = node_display, 100 === size) dolog && fdjtLog("No need to resize %o towards %dx%d", node, w, h), 
        node.removeChild(wrapper), fdjtDOM.append(node, toArray(wrapper.childNodes)); else {
            wstyle.width = "", wstyle.height = "", wstyle.maxWidth = "", wstyle.maxHeight = "", 
            dolog && fdjtLog("Adjusted (%s) %o towards %dx%d, wrapper @ %d,%d", wstyle.fontSize, node, w, h, wrapper.scrollWidth, wrapper.scrollHeight), 
            wstyle.transitionProperty = "", wstyle.transitionDuration = "", wstyle[fdjtDOM.transitionProperty] = "", 
            wstyle[fdjtDOM.transitionDuration] = "";
            var cwstyle = getStyle(wrapper);
            cwstyle[fdjtDOM.transitionProperty] ? (wstyle.fontSize = "", wstyle.visibility = "", 
            wstyle.fontSize = size + "%") : wstyle.visibility = "";
        }
        return size;
    }
    function resetFontSize(node) {
        var wrapper = getFirstChild(node, ".fdjtfontwrapper");
        wrapper && (wrapper.style.fontSize = "100%");
    }
    function adjustFonts(arg, top) {
        var all = [];
        if (arg) if ("string" == typeof arg) document.getElementByID(arg) ? all = [ document.getElementByID(arg) ] : (fdjtDOM.autofont = fdjtDOM.autofont + "," + arg, 
        all = fdjtDOM.$(arg)); else if (1 === arg.nodeType) {
            var sel = new Selector(fdjtDOM.autofont);
            all = sel.match(arg) ? [ arg ] : fdjtDOM.getChildren(arg, fdjtDOM.autofont);
        } else all = fdjtDOM.$(fdjtDOM.autofont); else all = fdjtDOM.$(fdjtDOM.autofont);
        var i = 0, lim = all.length;
        if (lim) for (;lim > i; ) adjustFontSize(all[i++]); else top && adjustFontSize(top);
    }
    function adjustPositionedChildren(node) {
        if (node && 1 === node.nodeType) {
            var style = getStyle(node);
            if (node.childNodes && node.childNodes.length) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                1 === child.nodeType && adjustPositionedChildren(child);
            }
            "block" !== style.display && "inline-block" !== style.display || "absolute" !== style.position && "fixed" !== style.position || adjustFontSize(node);
        }
    }
    function adjustLayoutFonts(node) {
        var marked = fdjtDOM.getChildren(node, fdjtDOM.autofont), i = 0, lim = marked.length;
        if (0 === lim) adjustPositionedChildren(node); else for (;lim > i; ) adjustFontSize(marked[i++]);
    }
    function autoAdjustFonts() {
        fdjtDOM.noautofontadjust || (adjustFonts(), fdjtDOM.addListener(window, "resize", adjustFonts));
    }
    var floor = Math.floor, fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, getFirstChild = fdjtDOM.getFirstChild, wrapChildren = fdjtDOM.wrapChildren, getStyle = fdjtDOM.getStyle, Selector = fdjtDOM.Selector, hasClass = fdjtDOM.hasClass;
    fdjtDOM.adjustFontSize = fdjtDOM.tweakFontSize = adjustFontSize, fdjtDOM.resetFontSize = resetFontSize, 
    fdjtDOM.autofont = ".fdjtadjustfont,.adjustfont", fdjtDOM.tweakFont = fdjtDOM.tweakFonts = fdjtDOM.adjustFont = fdjtDOM.adjustFonts = adjustFonts, 
    fdjtDOM.adjustLayoutFonts = adjustLayoutFonts, fdjt.addInit(autoAdjustFonts, "adjustFonts");
}(), "undefined" == typeof window || window.JSON || (window.JSON = {}), function() {
    "use strict";
    function f(n) {
        return 10 > n ? "0" + n : n;
    }
    function quote(string) {
        return escapable.lastIndex = 0, escapable.test(string) ? '"' + string.replace(escapable, function(a) {
            var c = meta[a];
            return "string" == typeof c ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
        var i, k, v, length, partial, mind = gap, value = holder[key];
        switch (value && "object" == typeof value && "function" == typeof value.toJSON && (value = value.toJSON(key)), 
        "function" == typeof rep && (value = rep.call(holder, key, value)), typeof value) {
          case "string":
            return quote(value);

          case "number":
            return isFinite(value) ? value + "" : "null";

          case "boolean":
          case "null":
            return value + "";

          case "object":
            if (!value) return "null";
            if (gap += indent, partial = [], "[object Array]" === Object.prototype.toString.apply(value)) {
                for (length = value.length, i = 0; length > i; i += 1) partial[i] = str(i, value) || "null";
                return v = 0 === partial.length ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]", 
                gap = mind, v;
            }
            if (rep && "object" == typeof rep) for (length = rep.length, i = 0; length > i; i += 1) k = rep[i], 
            "string" == typeof k && (v = str(k, value), v && partial.push(quote(k) + (gap ? ": " : ":") + v)); else for (k in value) Object.hasOwnProperty.call(value, k) && (v = str(k, value), 
            v && partial.push(quote(k) + (gap ? ": " : ":") + v));
            return v = 0 === partial.length ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}", 
            gap = mind, v;
        }
    }
    "function" != typeof Date.prototype.toJSON && (Date.prototype.toJSON = function() {
        return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
    }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
        return this.valueOf();
    });
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
    }, rep;
    "function" != typeof JSON.stringify && (JSON.stringify = function(value, replacer, space) {
        var i;
        if (gap = "", indent = "", "number" == typeof space) for (i = 0; space > i; i += 1) indent += " "; else "string" == typeof space && (indent = space);
        if (rep = replacer, replacer && "function" != typeof replacer && ("object" != typeof replacer || "number" != typeof replacer.length)) throw Error("JSON.stringify");
        return str("", {
            "": value
        });
    }), "function" != typeof JSON.parse && (JSON.parse = function(text, reviver) {
        function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && "object" == typeof value) for (k in value) Object.hasOwnProperty.call(value, k) && (v = walk(value, k), 
            void 0 !== v ? value[k] = v : delete value[k]);
            return reviver.call(holder, key, value);
        }
        var j;
        if (cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function(a) {
            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), 
        "function" == typeof reviver ? walk({
            "": j
        }, "") : j;
        throw new SyntaxError("JSON.parse");
    });
}(), fdjt.JSON || (fdjt.JSON = JSON), fdjt.RefDB = function() {
    "use strict";
    function RefDB(name, init) {
        var db = this;
        if (refdbs[name] ? (db = refdbs[name], init && db.init ? db.xinits ? db.xinits.push(init) : db.xinits = [ init ] : init ? db.init = init : init = {}) : init && init.aliases && checkAliases(init.aliases) ? (db = checkAliases(init.aliases), 
        db.aliases.indexOf(db.name) >= 0 && (db.name = name), init && db.init ? db.xinits ? db.xinits.push(init) : db.xinits = [ init ] : init ? db.init = init : init = {}) : (init || (init = {}), 
        db.name = name, refdbs[name] = db, all_refdbs.push(db), db.aliases = [], db.complete = !1, 
        db.refs = {}, db.altrefs = {}, db.allrefs = [], db.loaded = [], db.changes = [], 
        db.changed = !1, db.storage = init.storage || !1, db.absrefs = init.absrefs || !1, 
        db.oidrefs = init.oidrefs || !1, db.onload = [], db.onloadnames = {}, db.onadd = {}, 
        db.ondrop = {}, db.indices = {}), init.hasOwnProperty("absrefs") && (db.absrefs = init.absrefs), 
        init.aliases) for (var aliases = init.aliases, i = 0, lim = aliases.length; lim > i; ) {
            var alias = aliases[i++];
            aliases[alias] ? aliases[alias] !== db && warn("Alias %s for %o already associated with %o", alias, db, aliases[alias]) : (aliases[alias] = db, 
            db.aliases.push(alias));
        }
        if (init.onload) {
            var onload = init.onload;
            for (var methname in onload) onload.hasOwnProperty(methname) && db.onLoad(onload[methname], methname);
        }
        if (init.indices) for (var index_specs = init.indices, j = 0, jlim = index_specs.length; jlim > j; ) {
            var ix = index_specs[j++];
            if ("string" != typeof ix) warn("Complex indices not yet handled!"); else {
                var index = db.indices[ix] = new ObjectMap();
                index.fordb = db;
            }
        }
        return db;
    }
    function checkAliases(aliases) {
        for (var i = 0, lim = aliases.length; lim > i; ) {
            var alias = aliases[i++], db = refdbs[alias];
            if (db) return db;
        }
        return !1;
    }
    function refDBProbe(name) {
        return refdbs.hasOwnProperty(name) && refdbs[name] || aliases.hasOwnProperty(name) && aliases[name] || !1;
    }
    function resolveRef(arg, db, DBType, force) {
        if ("function" != typeof DBType && (DBType = RefDB), !arg) return arg;
        if (arg instanceof Ref) return arg;
        if ("object" == typeof arg && arg.id) return object2ref(arg, db);
        if (db && db.refs.hasOwnProperty(arg)) return db.refs[arg];
        if (db && db.probe(arg)) return db.probe(arg);
        if ("string" == typeof arg && refpat.exec(arg)) {
            var at = arg.indexOf("@");
            if (1 === at && ":" === arg[0] && (arg = arg.slice(1), at = 0), at > 0) {
                var origin, usedb = !1, dbname = arg.slice(at + 1);
                (usedb = refDBProbe(dbname)) || (refpat.exec(dbname) ? (origin = resolveRef(dbname), 
                origin ? force = !0 : dbname = arg.slice(at + 1)) : dbname = arg.slice(at + 1)), 
                usedb = db && db.name === dbname ? db : refDBProbe(dbname), arg = arg.slice(0, at), 
                usedb ? db = usedb : force ? (warn("Creating forced RefDB domain %s for reference %s", dbname, arg), 
                db = RefDB.open(dbname, DBType)) : db = refDBProbe(dbname), db && origin && (db.origin = origin, 
                origin.name && (db.fullname = origin.name)), arg = arg.slice(0, at);
            } else if (0 > at) {
                var uuid;
                uuid = 0 === arg.search(":#U") ? arg.slice(3) : 0 === arg.search("#U") ? arg.slice(2) : 0 === arg.search("U") ? arg.slice(1) : arg;
                var type = uuid.indexOf("t"), tail = arg.length - 2;
                type = type > 0 ? "UUID" + uuid.slice(type) : !1, tail = tail > 0 ? "-UUIDTYPE=" + uuid.slice(tail) : !1;
                var known_db = type && (refdbs[type] || aliases[type]) || tail && (refdbs[tail] || aliases[tail]);
                known_db ? db = known_db : force && type && DBType && (warn("Creating forced RefDB domain %s for reference %s", type, arg), 
                db = new DBType(type), type && db.addAlias(type));
            } else if ("@" === arg[1]) {
                var idstart = arg.indexOf("/"), atid = arg.slice(0, idstart), atdb = aliases[atid];
                if (atdb) db = atdb; else {
                    var domain = getLocal(arg.slice(0, idstart), !0);
                    domain ? db = new RefDB(domain, {
                        aliases: [ atid ]
                    }) : (warn("Can't find domain for atid %s when resolving %s", atid, arg), db = !1);
                }
            } else {
                var atprefix, slash;
                "/" === arg[1] ? (slash = arg.slice(2).indexOf("/"), slash > 0 && (slash += 2)) : slash = arg.indexOf("/"), 
                atprefix = arg.slice(at, slash + 1), db = refdbs[atprefix] || aliases[atprefix] || DBType && new DBType(atprefix);
            }
        }
        return db ? db.refs.hasOwnProperty(arg) ? db.refs[arg] : force ? db.ref(arg) : !1 : !1;
    }
    function Ref(id, db, instance) {
        if (0 === arguments.length) return this;
        var at = id.indexOf("@");
        if (at > 1 && "\\" !== id[at - 1]) {
            var domain = id.slice(at + 1);
            domain !== db.name && 0 > db.aliases.indexOf(domain) && warn("Reference to %s being handled by %s", id, db), 
            id = id.slice(0, at);
        }
        return db.refs.hasOwnProperty(id) ? db.refs[id] : instance ? (instance._id = id, 
        instance._db = db, db.absrefs || (instance._domain = db.name), db.refs[id] = instance, 
        db.allrefs.push(instance), instance) : !db.refclass || this instanceof db.refclass ? (this._id = id, 
        this._db = db, db.absrefs || (this._domain = db.name), db.refs[id] = this, db.allrefs.push(this), 
        this) : new db.refclass(id, db);
    }
    function object2ref(value, db, dbtype) {
        var ref, dbref = !1;
        return value._domain && (dbref = RefDB.probe(value._domain) || new RefDB(value._domain)), 
        ref = dbref ? dbref.ref(value._id) : RefDB.resolve(value._id, db, dbtype || RefDB, !0);
    }
    function importValue(value, db, refstrings) {
        if (value === void 0 || "number" == typeof value || null === value) return value;
        if (value instanceof Ref) return value;
        if (value instanceof Array) {
            for (var i = 0, lim = value.length, copied = !1; lim > i; ) {
                var v = value[i++], nv = v;
                if (null === v) nv = void 0; else if (v instanceof Ref) nv = v; else if ("object" == typeof v && v._id) {
                    var ref = object2ref(v, db);
                    if (ref) {
                        for (var slot in v) v.hasOwnProperty(slot) && "_id" !== slot && "_db" !== slot && (ref[slot] = importValue(v[slot], db, refstrings));
                        nv = ref;
                    }
                } else refstrings && "string" == typeof v && refpat.exec(v) && (nv = resolveRef(v, db) || v);
                nv === void 0 ? copied || (copied = value.slice(0, i - 1)) : copied ? copied.push(nv) : nv !== v && (copied = value.slice(0, i - 1), 
                copied.push(nv));
            }
            return copied ? copied : value;
        }
        if ("object" == typeof value && value._id) {
            var refv = object2ref(value, db);
            for (var vslot in value) value.hasOwnProperty(vslot) && "_id" !== vslot && "_db" !== vslot && (refv[vslot] = importValue(value[vslot], db, refstrings));
            return refv;
        }
        return refstrings && "string" == typeof value && refpat.exec(value) ? resolveRef(value, db) || value : value;
    }
    function defImport(item, refs, db, rules, flags) {
        var ref = resolveRef(item._id, item._domain || db, db.constructor, !0);
        ref ? (refs.push(ref), ref.Import(item, rules || !1, flags)) : warn("Couldn't resolve database for %o", item._id);
    }
    function exportValue(value, db) {
        if (value instanceof Ref) return value._db === db ? {
            _id: value._id
        } : value._db.absrefs ? {
            _id: value._id
        } : {
            _id: value._id,
            _domain: value._domain || value._db.name
        };
        if (value instanceof Array) {
            for (var i = 0, lim = value.length, exports = !1; lim > i; ) {
                var elt = value[i++], exported = exportValue(elt, db);
                elt !== exported ? exports ? exports.push(exported) : (exports = value.slice(0, i - 1), 
                exports.push(exported)) : exports && exports.push(elt);
            }
            return exports || value;
        }
        if ("object" == typeof value) {
            var copied = !1, fields = [];
            for (var field in value) if (value.hasOwnProperty(field)) {
                var fieldval = value[field], exportval = exportValue(fieldval, db);
                if (fieldval !== exportval) {
                    if (!copied && (copied = {}, fields.length)) for (var j = 0, jlim = fields.length; jlim > j; ) {
                        var f = fields[j++];
                        copied[f] = value[f];
                    }
                    copied[field] = exportval;
                } else copied ? copied[field] = fieldval : fields.push(field);
            }
            return copied || value;
        }
        return value;
    }
    function getatid(storage, db) {
        if (db.atid) return db.atid;
        var atid = storage["atid(" + db.name + ")"];
        if (atid) return db.atid = atid, atid;
        var count = storage["atid.count"];
        return count ? (count = parseInt(count, 10), atid = db.atid = "@@" + count, storage["atid(" + db.name + ")"] = atid, 
        storage["atid.count"] = count + 1) : (atid = count = 1, storage["atid.count"] = "2"), 
        atid;
    }
    function getKeyString(val, db) {
        return val instanceof Ref ? val._db === db ? "@" + val._id : val._domain ? "@" + val._id + "@" + val._domain : "@" + val._id : "number" == typeof val ? "#" + val : "string" == typeof val ? '"' + val : val.toJSON ? "{" + val.toJSON() : "&" + ("" + val);
    }
    function arr_contains(arr, val, start) {
        return arr.indexOf(val, start || 0) >= 0;
    }
    function arr_position(arr, val, start) {
        return arr.indexOf(val, start || 0);
    }
    function set_sortfn(a, b) {
        return a === b ? 0 : typeof a == typeof b ? "number" == typeof a ? a - b : "string" == typeof a ? b > a ? -1 : 1 : a._qid ? b._qid ? b._qid > a._qid ? -1 : 1 : -1 : b._qid ? 1 : a._fdjtid && b._fdjtid ? b._fdjtid > a._fdjtid ? -1 : 1 : 0 : typeof b > typeof a ? -1 : 1;
    }
    function intersection(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return [];
        if (!set2 || 0 === set2.length) return [];
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var results = [], i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings, new_allstrings = !0; len1 > i && len2 > j; ) set1[i] === set2[j] ? (new_allstrings && "string" != typeof set1[i] && (new_allstrings = !1), 
        results.push(set1[i]), i++, j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? i++ : j++;
        return results._allstrings = new_allstrings, results._sortlen = results.length, 
        results;
    }
    function difference(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return [];
        if (!set2 || 0 === set2.length) return set1;
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var results = [], i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings, new_allstrings = !0; len1 > i && len2 > j; ) set1[i] === set2[j] ? (i++, 
        j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? (new_allstrings && "string" != typeof set1[i] && (new_allstrings = !1), 
        results.push(set1[i]), i++) : j++;
        if (!new_allstrings || set1._allstrings) results = results.concat(set1.slice(i)); else for (;len1 > i; ) {
            var elt = set1[i++];
            new_allstrings && "string" != typeof elt && (new_allstrings = !1), results.push(elt);
        }
        return results._allstrings = new_allstrings, results._sortlen = results.length, 
        results;
    }
    function union(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return set2;
        if (!set2 || 0 === set2.length) return set1;
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var results = [], i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings; len1 > i && len2 > j; ) set1[i] === set2[j] ? (results.push(set1[i]), 
        i++, j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? results.push(set1[i++]) : results.push(set2[j++]);
        for (;len1 > i; ) results.push(set1[i++]);
        for (;len2 > j; ) results.push(set2[j++]);
        return results._allstrings = allstrings, results._sortlen = results.length, results;
    }
    function merge(set1, set2) {
        var merged = [];
        if (merged._sortlen = 0, set1 instanceof Array || (set1 = [ set1 ]), set2 instanceof Array || (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return set2 && 0 !== set2.length ? (merged = merged.concat(set2), 
        set2._sortlen ? (merged._sortlen = set2._sortlen, merged._allstrings = set2._allstrings, 
        merged) : setify(merged)) : merged;
        if (!set2 || 0 === set2.length) return merge(set2, set1);
        set1._sortlen !== set1.length && (set1 = setify(set1)), set2._sortlen !== set2.length && (set2 = setify(set2));
        for (var i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings; len1 > i && len2 > j; ) set1[i] === set2[j] ? (merged.push(set1[i]), 
        i++, j++) : (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? merged.push(set1[i++]) : merged.push(set2[j++]);
        for (;len1 > i; ) merged.push(set1[i++]);
        for (;len2 > j; ) merged.push(set2[j++]);
        return merged._allstrings = allstrings, merged._sortlen = merged.length, merged;
    }
    function overlaps(set1, set2) {
        if ("string" == typeof set1 && (set1 = [ set1 ]), "string" == typeof set2 && (set2 = [ set2 ]), 
        !set1 || 0 === set1.length) return !1;
        if (!set2 || 0 === set2.length) return !1;
        set1._sortlen !== set1.length && (set1 = fdjtSet(set1)), set2._sortlen !== set2.length && (set2 = fdjtSet(set2));
        for (var i = 0, j = 0, len1 = set1.length, len2 = set2.length, allstrings = set1._allstrings && set2._allstrings; len1 > i && len2 > j; ) {
            if (set1[i] === set2[j]) return !0;
            (allstrings ? set2[j] > set1[i] : 0 > set_sortfn(set1[i], set2[j])) ? i++ : j++;
        }
        return !1;
    }
    function fdjtSet(arg) {
        var result = [];
        if (result._sortlen = 0, 0 === arguments.length) return result;
        if (1 === arguments.length) return arg ? arg instanceof Array ? arg.length && arg._sortlen !== arg.length ? "number" == typeof arg._sortlen ? setify(arg) : setify([].concat(arg)) : arg : (result = [ arg ], 
        "string" == typeof arg && (result._allstrings = !0), result._sortlen = 1, result) : result;
        var i = 0, lim = arguments.length;
        for (result = []; lim > i; ) {
            var each_arg = arguments[i++];
            each_arg && (each_arg instanceof Array ? result = result.concat(each_arg) : result.push(each_arg));
        }
        return setify(result);
    }
    function setify(array) {
        var len;
        if (array._sortlen === (len = array.length)) return array;
        if (0 === len) return array._sortlen = 0, array;
        if (1 === len) {
            var elt1 = array[0];
            return array._sortlen = 1, array._allstrings = "string" == typeof elt1, "object" == typeof elt1 && (elt1._qid || elt1._fdjtid || (elt1.getQID ? elt1._qid = elt1.getQID() : elt1._fdjtid = ++id_counter)), 
            array;
        }
        for (var allstrings = !0, i = 0, lim = array.length; lim > i; ) {
            var elt = array[i++];
            allstrings && "string" != typeof elt && (allstrings = !1, "object" == typeof elt && (elt._qid || elt._fdjtid || (elt.getQID ? elt._qid = elt.getQID() : elt._fdjtid = ++id_counter)));
        }
        if (array._allstrings = allstrings, 1 === lim) return array;
        allstrings ? array.sort() : array.sort(set_sortfn);
        for (var read = 1, write = 1, readlim = array.length, cur = array[0]; readlim > read; ) array[read] !== cur ? array[write++] = cur = array[read++] : read++;
        return array._sortlen = array.length = write, array;
    }
    function set_add(set, val) {
        if (val instanceof Array) {
            var changed = !1;
            for (var elt in val) set_add(set, elt) && (changed = !0);
            return changed;
        }
        if (set.indexOf) {
            var pos = set.indexOf(val);
            return pos >= 0 ? !1 : (set.push(val), !0);
        }
        for (var i = 0, lim = set.length; lim > i; ) {
            if (set[i] === val) return !1;
            i++;
        }
        return "string" != typeof val && (set._allstrings = !1), set.push(val), !0;
    }
    function set_drop(set, val) {
        if (val instanceof Array) {
            var changed = !1;
            for (var elt in val) set_drop(set, elt) && (changed = !0);
            return changed;
        }
        if (set.indexOf) {
            var pos = set.indexOf(val);
            return 0 > pos ? !1 : (set.splice(pos, 1), !0);
        }
        for (var i = 0, lim = set.length; lim > i; ) {
            if (set[i] === val) return set.splice(i, 1), !0;
            i++;
        }
        return !1;
    }
    function setCall(fn, val) {
        return Array.isArray(val) ? val._sortlen && val._sortlen === val.length ? fn(val) : fn(setify(val)) : fn([ val ]);
    }
    function ObjectMap() {
        return this;
    }
    function StringMap() {
        return this;
    }
    function RefMap(db) {
        return this._db = db, this;
    }
    function countKeys(obj) {
        var count = 0;
        for (var key in obj) obj.hasOwnProperty(key) && count++;
        return count;
    }
    function localKeys(obj) {
        var keys = [];
        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
        return keys;
    }
    function Query(dbs, clauses, weights) {
        if (0 === arguments.length) return this;
        dbs && (this.dbs = dbs), clauses && (this.clauses = clauses instanceof Array ? clauses : [ clauses ]), 
        weights && (this.weights = weights);
        var i = 0, n_dbs = dbs.length;
        if (n_dbs > 1) for (;n_dbs > i; ) {
            if (!dbs[i].absrefs) return this;
            i++;
        }
        return this.uniqueids = !0, this;
    }
    function sortbyweight(f1, f2) {
        return f2.weight - f1.weight;
    }
    function useIndexedDB(dbname, version, init, opts) {
        function usingIndexedDB(resolve, reject) {
            if (indexedDB === void 0 || !indexedDB.open) {
                if (fdjtLog.warn("No indexedDB implementation for opening %:", vname), !reject) throw Error("No indexedDB implementation");
                reject(Error("No indexedDB implementation"));
            }
            try {
                var req = indexedDB.open(dbname, version), fail = !1, init_timeout = setTimeout(function() {
                    fail = !0, fdjtLog.warn("Init timeout for indexedDB %s", vname), reject(Error("Init timeout"));
                }, opts.timeout || 15e3);
                req.onerror = function(event) {
                    return fail = !0, warn("Error initializing indexedDB: %o", event.errorCode), init_timeout && clearTimeout(init_timeout), 
                    reject ? reject(event) : event;
                }, req.onsuccess = function(evt) {
                    if (fail) return fdjtLog("Discarding indexedDB %s after failure!", vname), void 0;
                    var db = evt.target.result;
                    return init_timeout && clearTimeout(init_timeout), trace && fdjtLog("Got existing IndexedDB %s %o", vname, db), 
                    resolve ? resolve(db) : db;
                }, req.onupgradeneeded = function(evt) {
                    var db = evt.target.result;
                    if (!init) return resolve(db);
                    if (req.onsuccess = function() {
                        return resolve ? resolve(db) : db;
                    }, req.onerror = function(evt) {
                        if (fdjtLog("Error upgrading %s %o", vname, evt), !reject) throw Error("Error upgrading %s", vname);
                        reject(evt);
                    }, init.call) try {
                        return init(db), resolve ? resolve(db) : db;
                    } catch (ex) {
                        fdjtLog("Error upgrading %s:%d: %o", dbname, version, ex), reject && reject(ex);
                    } else {
                        if (!reject) throw Error("Bad indexDB init: %o", init);
                        reject(Error("Bad indexDB init: %o", init));
                    }
                    return db;
                };
            } catch (ex) {
                fdjtLog("usingIndexedDB failed: %o", ex), reject && reject(ex);
            }
        }
        version && !opts && "number" != typeof version && version.version ? (opts = version, 
        version = opts.version) : opts || (opts = {}), init || (init = opts.init || !1), 
        version || (version = 1);
        var trace = opts.trace, vname = dbname + ":" + version;
        return new Promise(usingIndexedDB);
    }
    var fdjtState = fdjt.State, fdjtTime = fdjt.Time, fdjtAsync = fdjt.Async, fdjtDOM = fdjt.DOM, JSON = fdjt.JSON, fdjtLog = fdjt.Log, warn = fdjtLog.warn, refdbs = {}, all_refdbs = [], changed_dbs = [], aliases = {}, iDB = fdjt.iDB, indexedDB = iDB.indexedDB;
    RefDB.prototype.name = RefDB.prototype.aliases = RefDB.prototype.refs = RefDB.prototype.altrefs = RefDB.prototype.allrefs = RefDB.prototype.loaded = RefDB.prototype.changes = RefDB.prototype.changed = RefDB.prototype.storage = RefDB.prototype.absrefs = RefDB.prototype.oidrefs = RefDB.prototype.onload = RefDB.prototype.onadd = RefDB.prototype.indices = RefDB.prototype.complete = !1;
    var REFINDEX = RefDB.REFINDEX = 2, REFLOAD = RefDB.REFLOAD = 4, REFSTRINGS = RefDB.REFSTRINGS = 8, default_flags = REFINDEX | REFSTRINGS;
    RefDB.open = function(name, DBClass) {
        return DBClass || (DBClass = RefDB), refdbs.hasOwnProperty(name) && refdbs[name] || aliases.hasOwnProperty(name) && aliases[name] || new DBClass(name);
    }, RefDB.probe = refDBProbe, RefDB.prototype.addAlias = function(alias) {
        aliases[alias] ? aliases[alias] !== this && warn("Alias %s for %o already associated with %o", alias, this, aliases[alias]) : (aliases[alias] = this, 
        this.aliases.push(alias));
    }, RefDB.prototype.toString = function() {
        return "RefDB(" + this.name + ")";
    }, RefDB.prototype.ref = function(id) {
        if ("string" != typeof id) {
            if (id instanceof Ref) return id;
            throw Error("Not a reference");
        }
        ":" === id[0] && "@" === id[1] && (id = id.slice(1));
        var refs = this.refs;
        return refs.hasOwnProperty(id) && refs[id] || this.refclass && new this.refclass(id, this) || new Ref(id, this);
    }, RefDB.prototype.probe = function(id) {
        if ("string" != typeof id) return id instanceof Ref ? id : !1;
        ":" === id[0] && "@" === id[1] && (id = id.slice(1));
        var refs = this.refs;
        return refs.hasOwnProperty(id) && refs[id];
    }, RefDB.prototype.drop = function(refset) {
        var count = 0, refs = this.refs, altrefs = this.altrefs;
        refset instanceof Array || (refset = [ refset ]);
        for (var i = 0, nrefs = refset.length; nrefs > i; ) {
            var id, ref = refset[i++];
            if (ref instanceof Ref ? id = ref._id : (id = ref, ref = this.probe(id)), ref) {
                count++;
                var aliases = ref.aliases, pos = this.allrefs.indexOf(ref);
                if (pos >= 0 && this.allrefs.splice(pos, 1), pos = this.changes.indexOf(ref), pos >= 0 && this.changes.splice(pos, 1), 
                pos = this.loaded.indexOf(ref), pos >= 0 && this.loaded.splice(pos, 1), delete refs[id], 
                this.storage instanceof Storage) {
                    var storage = this.storage, key = "allids(" + this.name + ")", allidsval = storage[key], allids = allidsval && JSON.parse(allidsval), idpos = allids.indexOf(id);
                    idpos >= 0 && (allids.splice(idpos, 1), storage.setItem(key, JSON.stringify(allids)), 
                    storage.removeItem(id));
                }
                if (aliases) for (var j = 0, jlim = aliases.length; jlim > j; ) delete altrefs[aliases[j++]];
            }
        }
        return count;
    }, RefDB.prototype.clearOffline = function(callback) {
        if (!this.storage) return !1;
        if (!(Storage && this.storage instanceof Storage)) return this.storage instanceof indexedDB ? void 0 : !1;
        var storage = this.storage, key = "allids(" + this.name + ")", allids = this.storage[key];
        if (allids && (allids = JSON.parse(allids)), allids) for (var i = 0, lim = allids.length; lim > i; ) delete storage[allids[i++]];
        delete storage[key], callback && setTimeout(callback, 5);
    }, RefDB.prototype.onLoad = function(method, name, noupdate) {
        if (name && this.onloadnames[name]) {
            var cur = this.onloadnames[name];
            if (cur === method) return;
            var pos = this.onload.indexOf(cur);
            if (0 > cur) return warn("Couldn't replace named onload method %s for <RefDB %s>", name, this.name), 
            void 0;
            this.onload[pos] = method;
        } else this.onload.push(method);
        if (name && (this.onloadnames[name] = method), !noupdate) {
            var loaded = [].concat(this.loaded);
            fdjtAsync.slowmap(method, loaded);
        }
    }, RefDB.prototype.onAdd = function(name, method) {
        this.onadd[name] = method;
    }, RefDB.prototype.onDrop = function(name, method) {
        this.ondrop[name] = method;
    };
    var refpat = /^(((:|)@(([0-9a-fA-F]+\/[0-9a-fA-F]+)|(\/\w+\/.*)|(@\d+\/.*)))|((U|#U|:#U|)[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12})|((U|#U|:#U|)[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}t[0-9a-zA-Z]+)|([^@]+@.+))$/, getLocal = fdjtState.getLocal;
    RefDB.resolve = resolveRef, RefDB.ref = resolveRef, fdjt.Ref = RefDB.Ref = Ref, 
    Ref.prototype._db = Ref.prototype._domain = Ref.prototype._qid = Ref.prototype._id = !1, 
    Ref.prototype.toString = function() {
        return this._qid ? this._qid : this._domain ? this._id + "@" + this._domain : this._db.absrefs ? this._id : this._id + "@" + this._db.name;
    }, Ref.prototype.getQID = function() {
        var qid;
        return this._qid ? this._qid : qid = this._qid = this._domain ? this._id + "@" + this._domain : this._db.absrefs ? this._id : this._id + "@" + this._db.name;
    }, Ref.prototype.addAlias = function(term) {
        var refs = this._db.refs;
        if (refs.hasOwnProperty(term)) {
            if (refs[term] === this) return !1;
            throw {
                error: "Ref alias conflict"
            };
        }
        if (this._db.altrefs.hasOwnProperty(term)) {
            if (this._db.altrefs[term] === this) return !1;
            throw {
                error: "Ref alias conflict"
            };
        }
        return this._db.altrefs[term] = this, !0;
    }, Ref.prototype.Import = function(data, rules, flags) {
        var db = this._db, live = this._live, indices = db.indices, onload = db.onload, onadd = live && db.onadd, ondrop = live && db.ondrop, aliases = data.aliases;
        flags === void 0 && (flags = default_flags), rules === void 0 && (rules = this.import_rules || db.import_rules);
        var indexing = 0 !== (flags & REFINDEX), loading = 0 !== (flags & REFLOAD), refstrings = 0 !== (flags & REFSTRINGS);
        if (aliases) for (var ai = 0, alim = aliases.length; alim > ai; ) {
            var alias = aliases[ai++], cur = db.refs.hasOwnProperty(alias) && db.refs[alias] || db.altrefs.hasOwnProperty(alias) && db.altrefs[alias];
            cur && cur !== this ? warn("Ambiguous ref %s in %s refers to both %o and %o", alias, db, cur.name, this.name) : aliases[alias] = this;
        }
        var now = fdjtTime();
        loading && !this._live && (this._live = now);
        for (var key in data) if ("aliases" === key || "_id" === key) ; else if (data.hasOwnProperty(key)) {
            var value = data[key], rule = rules && rules[key];
            value !== void 0 && (rule && (value = rule(this, key, value, data, indexing)), value = importValue(value, db, refstrings));
            var oldval = live && this[key];
            if (this[key] = value, oldval) {
                var drops = difference(oldval, value || []), adds = value ? difference(value, oldval) : [];
                if (indexing && indices[key] && (adds.length && this.indexRef(key, adds, indices[key], db), 
                drops.length && this.dropIndexRef(key, drops, indices[key], db)), adds.length && onadd[key]) for (var addfn = onadd[key], addi = 0, addlen = adds.length; addlen > addi; ) addfn(adds[addi++]);
                if (drops.length && ondrop[key]) for (var dropfn = ondrop[key], dropi = 0, droplen = drops.length; droplen > dropi; ) dropfn(drops[dropi++]);
            } else value && indexing && indices[key] && this.indexRef(key, value, indices[key], db);
        }
        if (loading) {
            if (onload) for (var i = 0, lim = onload.length; lim > i; ) {
                var loadfn = onload[i++];
                loadfn(this, now);
            }
            if (this._onload) {
                for (var onloads = this._onload, inits = onloads.fns, j = 0, jlim = inits.length; jlim > j; ) inits[j++](this, now);
                delete this._onload;
            }
        }
        loading || this._changed || (this._changed = now, db.changes.push(this), db.changed || (db.changed = now, 
        db.changes.push(db)));
    }, Ref.prototype.importValue = function(value, refstrings) {
        return importValue(this._db, value, refstrings);
    }, RefDB.prototype.importValue = function(val, refstrings) {
        return importValue(val, this, refstrings);
    }, RefDB.prototype.Import = function(data, rules, flags, callback) {
        var refs = [], db = this;
        if (!(data instanceof Array)) return defImport(data, refs, db, rules, flags), callback ? (callback.call && setTimeout(function() {
            callback(refs[0]);
        }), refs[0]) : refs[0];
        if (!callback || 7 >= data.length) {
            for (var i = 0, lim = data.length; lim > i; ) defImport(data[i++], refs, db, rules, flags);
            return callback && callback.call && setTimeout(function() {
                callback(refs);
            }, 10), refs;
        }
        callback.call ? fdjtAsync.slowmap(function(item) {
            defImport(item, refs, db, rules, flags);
        }, data, {
            done: function() {
                callback(refs);
            }
        }) : fdjtAsync.slowmap(function(item) {
            defImport(item, refs, db, rules, flags);
        }, data);
    }, Ref.prototype.onLoad = function(fn, name) {
        if (this._live) fn(this); else if (this._onload) {
            if (this._onload[name]) return;
            name && (this._onload[name] = fn), this._onload.fns.push(fn);
        } else this._onload = {
            fns: [ fn ]
        }, name && (this._onload[name] = fn);
    }, Ref.Export = Ref.prototype.Export = function(xforms) {
        var db = this._id, exported = {
            _id: this._id
        };
        xforms || (xforms = this.export_rules || db.export_rules), db.absrefs || (this._domain = db.name);
        for (var key in this) if ("_" !== key[0] && this.hasOwnProperty(key)) {
            var value = this[key], xform = xforms && xforms[key];
            xform && (value = xform(value, key, exported)), value === void 0 || (exported[key] = "number" == typeof value || "string" == typeof value ? value : value instanceof Ref ? value._db.absrefs ? {
                _id: value._id
            } : {
                _id: value._id,
                _domain: value._domain || value._db.name
            } : exportValue(value, this._db));
        }
        return exported;
    }, Ref.exportValue = exportValue, RefDB.prototype.exportValue = function(val) {
        return exportValue(val, this);
    }, RefDB.prototype.load = function(refs, callback, args) {
        function docallback() {
            callback && (args ? callback.apply(null, args) : callback());
        }
        function load_ref(arg, loaded, storage) {
            var content, ref = arg;
            return "string" == typeof ref && (ref = db.ref(ref, !1, !0)), ref ? (ref._live || (loaded.push(ref), 
            absrefs ? content = storage[ref._id] : atid ? content = storage[atid + "(" + ref._id + ")"] : (atid = db.atid ? db.atid : db.atid = getatid(storage, db), 
            content = storage[atid + "(" + ref._id + ")"]), content ? ref.Import(JSON.parse(content), !1, REFLOAD | REFINDEX) : warn("No item stored for %s", ref._id)), 
            void 0) : (warn("Couldn't resolve ref to %s", arg), void 0);
        }
        if (this.storage) {
            if (this.storage instanceof Storage) {
                if (refs) if (refs === !0) {
                    var all = this.storage["allids(" + this.name + ")"];
                    refs = all ? JSON.parse(all).concat(this.allrefs) : [].concat(this.allrefs);
                } else refs instanceof Ref ? refs = [ refs ] : "string" == typeof refs ? refs = [ refs ] : refs.length === void 0 && (refs = [ refs ]); else refs = [].concat(this.allrefs);
                for (var storage = this.storage, loaded = this.loaded, db = this, absrefs = this.absrefs, refmap = this.refs, atid = !1, needrefs = [], i = 0, lim = refs.length; lim > i; ) {
                    var refid = refs[i++], ref = refid;
                    "string" == typeof refid && (ref = refmap[refid]), ref instanceof Ref && ref._live || needrefs.push(refid);
                }
                if (needrefs.length) {
                    var opts = callback ? args ? {
                        done: docallback
                    } : {
                        done: callback
                    } : !1;
                    return fdjtAsync.slowmap(function(arg) {
                        load_ref(arg, loaded, storage);
                    }, needrefs, opts);
                }
                return docallback(), new Promise(function(resolve) {
                    resolve(refs);
                });
            }
            this.storage instanceof window.indexedDB;
        }
    }, RefDB.prototype.load = function(refs) {
        return this.storage instanceof Storage ? this.loadFromStorage(refs) : !1;
    }, RefDB.prototype.loadFromStorage = function(refs) {
        function storage_loader(arg, loaded) {
            var content, ref = arg;
            return "string" == typeof ref && (ref = db.ref(ref, !1, !0)), ref ? (ref._live || (content = absrefs ? storage[ref._id] : atid ? storage[atid + "(" + ref._id + ")"] : storage[atid + "(" + ref._id + ")"], 
            content && (loaded.push(ref), ref.Import(JSON.parse(content), !1, REFLOAD | REFINDEX))), 
            void 0) : (warn("Couldn't resolve ref to %s", arg), void 0);
        }
        var db = this, storage = this.storage, loaded = this.loaded, atid = db.atid || (db.atid = getatid(storage, db)), needrefs = [], refmap = db.refs, absrefs = db.absrefs;
        if (refs) if (refs === !0) {
            var all = storage["allids(" + db.name + ")"] || "[]";
            refs = JSON.parse(all).concat(db.allrefs);
        } else Array.isArray(refs) || (refs = [ refs ]); else refs = [].concat(db.allrefs);
        for (var i = 0, lim = refs.length; lim > i; ) {
            var refid = refs[i++], ref = refid;
            "string" == typeof refid && (ref = refmap[refid]), ref instanceof Ref && ref._live || needrefs.push(refid);
        }
        return needrefs.length ? fdjtAsync.slowmap(function(arg) {
            storage_loader(arg, loaded, storage);
        }, needrefs) : new Promise(function(resolve) {
            for (var resolved = [], i = 0, lim = refs.length; lim > i; ) {
                var refid = refs[i++];
                ref = "string" == typeof ref ? refmap[refid] : refid, resolved.push(ref);
            }
            return resolve(resolved);
        });
    }, RefDB.prototype.loadref = function(ref) {
        return "string" == typeof ref && (ref = this.ref(ref)), ref.load();
    }, Ref.prototype.load = function() {
        function loadref(resolve) {
            return ref._live ? resolve(ref) : (db.load(ref).then(function() {
                resolve(ref);
            }), void 0);
        }
        var ref = this, db = this._db;
        return new Promise(loadref);
    }, RefDB.load = function(spec, dbtype, callback, args) {
        if ("string" == typeof spec) {
            var ref = RefDB.resolve(spec, !1, dbtype || RefDB, !0);
            if (ref) return ref.load(callback, args);
            throw {
                error: "Couldn't resolve " + spec
            };
        }
        if (spec instanceof Ref) return spec.load(callback, args);
        if (spec instanceof Array) {
            for (var loads = {}, dbs = [], i = 0, lim = spec.length; lim > i; ) {
                var s = spec[i++], r = !1;
                if ("string" == typeof s ? r = RefDB.resolve(s, !1, dbtype || RefDB, !0) : s instanceof Ref && (r = s), 
                r && !r._live) {
                    var db = r._db, name = db.name;
                    loads[name] ? loads[name].push(r) : (loads[name] = [ r ], dbs.push(db));
                }
            }
            for (i = 0, lim = dbs.length; lim > i; ) {
                var loadfrom = dbs[i++];
                loadfrom.load(loads[loadfrom.name], args);
            }
            return loads;
        }
        return !1;
    }, RefDB.prototype.saveToStorage = function(refs, updatechanges) {
        function savingLocally(resolve) {
            for (var i = 0, lim = refs.length; lim > i; ) {
                var ref = refs[i++];
                if ("string" == typeof ref && (ref = db.ref(ref)), ref._live && (!ref._saved || ref._changed)) {
                    var exported = ref.Export();
                    if (exported._saved = fdjtTime.tick(), db.absrefs) ids.push(ref._id), storage.setItem(ref._id, JSON.stringify(exported)); else {
                        atid || (atid = ref.atid ? ref.atid : ref.atid = getatid(storage, ref));
                        var id = atid + "(" + ref._id + ")";
                        ids.push(id), storage.setItem(id, JSON.stringify(exported));
                    }
                    ref._changed = !1;
                }
            }
            if (updatechanges) {
                for (var changes = db.changes, new_changes = [], j = 0, n_changed = changes.length; n_changed > j; ) {
                    var c = changes[j++];
                    c._changed && new_changes.push(c);
                }
                if (db.changes = new_changes, 0 === new_changes.length) {
                    db.changed = !1;
                    var pos = changed_dbs.indexOf(db);
                    pos >= 0 && changed_dbs.splice(pos, 1);
                }
            }
            var allids = storage["allids(" + db.name + ")"];
            allids = allids ? JSON.parse(allids) : [];
            var n = allids.length;
            allids = merge(allids, ids), allids.length !== n && storage.setItem("allids(" + db.name + ")", JSON.stringify(allids)), 
            resolve && fdjt.ASync(resolve);
        }
        var db = this, storage = this.storage, atid = this.atid, ids = [];
        return new Promise(savingLocally);
    }, RefDB.prototype.save = function(refs, updatechanges) {
        function saving(resolve) {
            if (db.storage instanceof Storage) db.saveToStorage(refs, updatechanges).then(function() {
                db.changed = !1, db.changes = [];
                var pos = changed_dbs.indexOf(db);
                pos >= 0 && changed_dbs.splice(pos, 1), resolve && resolve();
            }); else if (!(db.storage instanceof window.indexedDB)) return resolve();
        }
        var db = this, storage = this.storage;
        return refs === !0 ? refs = this.allrefs : refs || (refs = this.changes), storage ? new Promise(saving) : !1;
    }, Ref.prototype.save = function() {
        function saveref(resolve) {
            return ref._changed ? db.save([ ref ]).then(function() {
                resolve(ref);
            }) : resolve(ref);
        }
        var ref = this, db = this._db;
        return new Promise(saveref);
    }, RefDB.getKeyString = getKeyString, Ref.prototype.indexRef = function(key, val, index, db) {
        var keystrings = [], rdb = this._db, refstring = !db || rdb === db || rdb.absrefs ? this._id : this._qid || this.getQID && this.getQID();
        db || (db = rdb);
        var indices = db.indices;
        if (index || (index = indices.hasOwnProperty(key) && indices[key]), !index) return warn("No index on %s for %o in %o", key, this, db), 
        !1;
        if (val instanceof Ref) keystrings = rdb === val._db ? [ "@" + val._id ] : [ "@" + (val._qid || val.getQID()) ]; else if (val instanceof Array) {
            db = this._db;
            for (var i = 0, lim = val.length; lim > i; ) {
                var elt = val[i++];
                elt instanceof Ref ? keystrings.push("@" + (elt._qid || elt.getQID())) : "number" == typeof elt ? keystrings = [ "#" + elt ] : "string" == typeof elt ? keystrings = [ '"' + elt ] : elt._qid ? keystrings.push("@" + (elt._qid || elt.getQID())) : elt.getQID && keystrings.push("@" + elt.getQID());
            }
        } else keystrings = "number" == typeof val ? [ "#" + val ] : "string" == typeof val ? [ '"' + val ] : [ "?" + ("" + val) ];
        if (keystrings.length) {
            for (var j = 0, jlim = keystrings.length; jlim > j; ) {
                var keystring = keystrings[j++], refs = index[keystring];
                refs ? refs.push(refstring) : index[keystring] = [ refstring ];
            }
            return keystrings.length;
        }
        return !1;
    }, Ref.prototype.dropIndexRef = function(key, val, index, db) {
        if (db || (db = this._db), index || (index = db.indices[key]), !index) return !1;
        var keystrings = [];
        if (val instanceof Ref) keystrings = this._db === val._db ? [ "@" + val._id ] : [ "@" + (val._qid || val.getQID()) ]; else if (val instanceof Array) for (var i = 0, lim = val.length; lim > i; ) {
            var elt = val[i++];
            elt instanceof Ref ? keystrings.push("@" + (elt._qid || elt.getQID())) : "number" == typeof elt ? keystrings = [ "#" + val ] : "string" == typeof elt ? keystrings = [ '"' + val ] : elt._qid ? keystrings.push("@" + (elt._qid || elt.getQID())) : elt.getQID && keystrings.push("@" + elt.getQID());
        } else "number" == typeof val ? keystrings = [ "#" + val ] : "string" == typeof val && (keystrings = [ '"' + val ]);
        if (keystrings.length) {
            for (var deleted = 0, j = 0, jlim = keystrings.length; jlim > j; ) {
                var keystring = keystrings[j++], refs = index[keystring];
                if (refs) {
                    var pos = refs.indexOf(this._id);
                    0 > pos || (refs.splice(pos, 1), 0 === refs.length && delete index[keystring], deleted++);
                }
            }
            return deleted;
        }
        return !1;
    }, RefDB.prototype.find = function(key, value) {
        var index = this.indices[key];
        if (index) {
            var items = index.getItem(value, this);
            return items ? setify(items) : [];
        }
        return [];
    }, RefDB.prototype.findRefs = function(key, value) {
        var index = this.indices[key];
        if (index) {
            var items = index.getItem(value, this), results = [];
            if (items) for (var i = 0, lim = items.length; lim > i; ) {
                var item = items[i++];
                if (item) if ("string" == typeof item) {
                    var ref = this.probe(item);
                    ref && results.push(ref);
                } else results.push(item); else ;
            }
            return fdjtSet(results);
        }
        return [];
    }, RefDB.prototype.count = function(key, value) {
        var index = this.indices[key];
        if (index) {
            var vals = index.getItem(value, this);
            return vals ? vals.length || 0 : 0;
        }
        return 0;
    }, RefDB.prototype.addIndex = function(key, Constructor) {
        if (Constructor || (Constructor = ObjectMap), this.indices.hasOwnProperty(key)) return this.indices[key];
        var index = this.indices[key] = new Constructor();
        return index.fordb = this, index;
    };
    var id_counter = 1;
    return RefDB.compare = set_sortfn, RefDB.intersection = intersection, RefDB.difference = difference, 
    RefDB.union = union, RefDB.merge = merge, RefDB.overlaps = overlaps, RefDB.Set = fdjtSet, 
    fdjt.Set = fdjtSet, RefDB.toSet = fdjtSet, Ref.prototype.get = function(prop) {
        return this.hasOwnProperty(prop) ? this[prop] : this._live ? !1 : void 0;
    }, Ref.prototype.getSet = function(prop) {
        if (this.hasOwnProperty(prop)) {
            var val = this[prop];
            return val instanceof Array ? val._sortlen === val.length ? val : setify(val) : setify([ val ]);
        }
        return this._live ? [] : void 0;
    }, Ref.prototype.getArray = function(prop) {
        if (this.hasOwnProperty(prop)) {
            var val = this[prop];
            return val instanceof Array ? val : [ val ];
        }
        return this._live ? [] : void 0;
    }, Ref.prototype.getValue = function(prop) {
        function getting(resolve, reject) {
            return ref.hasOwnProperty(prop) ? resolve(ref[prop]) : ref._live ? resolve(void 0) : ref._db.storage ? ref.load().then(function(r) {
                return resolve(r[prop]);
            }).catch(reject) : resolve(void 0);
        }
        var ref = this;
        return new Promise(getting);
    }, Ref.prototype.getValues = function(prop) {
        function getting(resolve, reject) {
            ref.getValue(prop).then(function(val) {
                return setCall(resolve, val);
            }).catch(reject);
        }
        var ref = this;
        return new Promise(getting);
    }, Ref.prototype.add = function(prop, val, index) {
        function handle_add(resolved) {
            if (val instanceof Array && "number" == typeof val._sortlen) for (var i = 0, lim = val.length; lim > i; ) ref.add(prop, val[i++], index); else {
                if ("aliases" === prop) return db.refs[val] === ref || db.altrefs[val] === ref ? resolved && resolved(!1) : (db.altrefs[val] = ref, 
                ref.aliases ? ref.aliases.push(val) : ref.aliases = [ val ], resolved && resolved(!0));
                if (ref.hasOwnProperty(prop)) {
                    var cur = ref[prop];
                    if (cur === val) return resolved && resolved(!1);
                    if (cur instanceof Array) {
                        if (!set_add(cur, val)) return resolved && resolved(!1);
                    } else ref[prop] = fdjtSet([ cur, val ]);
                } else ref[prop] = val instanceof Array && "number" != typeof val._sortlen ? fdjtSet([ val ]) : val;
            }
            if (!ref._changed) {
                var now = fdjtTime();
                db.changed || changed_dbs.push(db), db.changed = now, ref._changed = now, db.changes.push(ref);
            }
            db.onadd.hasOwnProperty(prop) && db.onadd[prop](ref, prop, val), index && db.indices[prop] && ref.indexRef(prop, ref[prop], db.indices[prop]), 
            resolved && resolved(!0);
        }
        function add_onload() {
            handle_add(!1);
        }
        var ref = this, db = this._db;
        return index === void 0 ? index = db.indices.hasOwnProperty(prop) ? !0 : !1 : index && !db.indices.hasOwnProperty(prop) && db.addIndex(prop), 
        val instanceof Array && 0 === val._sortlen ? new Promise(function(resolve) {
            return resolve(!1);
        }) : !this._live && this._db.storage ? (this._onload ? this._onload.push(add_onload) : this._onload = [ add_onload ], 
        this.load()) : new Promise(handle_add);
    }, Ref.prototype.drop = function(prop, val, dropindex) {
        function handle_drop(resolved) {
            if (!ref.hasOwnProperty(prop)) return resolved && resolved(!1);
            var cur = ref[prop];
            if (cur === val) delete ref[prop]; else {
                if (!(cur instanceof Array)) return resolved && resolved(!1);
                if (!set_drop(cur, val)) return resolved && resolved(!1);
                0 === cur.length && delete ref[prop];
            }
            if (db.ondrop.hasOwnProperty(prop) && db.ondrop[prop](ref, prop, val), !ref._changed) {
                var now = fdjtTime();
                db.changed && (db.changed = now, changed_dbs.push(db)), ref._changed = now, db.changes.push(ref);
            }
            return dropindex && db.indices[prop] && ref.indexRefDrop(prop, db.indices[prop]), 
            resolved && resolved(!0);
        }
        function drop_onload() {
            handle_drop(!1);
        }
        var ref = this, db = this._db;
        return dropindex === void 0 && (dropindex = !0), "_id" === prop ? new Promise(function(resolved) {
            resolved(!1);
        }) : !this._live && this._db.storage ? (this._onload ? this._onload.push(drop_onload) : this._onload = [ drop_onload ], 
        this.load()) : new Promise(handle_drop);
    }, Ref.prototype.test = function(prop, val) {
        if (this.hasOwnProperty(prop)) {
            if (val === void 0) return !0;
            var cur = this[prop];
            return cur === val ? !0 : cur instanceof Array ? arr_contains(cur, val) ? !0 : this._live ? !1 : void 0 : this._live ? !1 : void 0;
        }
        return this._live ? !1 : void 0;
    }, Ref.prototype.store = function(prop, val) {
        var toadd = [], todrop = [];
        if (this.hasOwnProperty(prop)) {
            var cur = this[prop];
            if (cur === val) return !1;
            toadd = difference(val, cur), todrop = difference(cur, val);
        } else toadd = val instanceof Array ? val : [ val ];
        for (var i = 0, lim = todrop.length; lim > i; ) this.drop(prop, todrop[i++]);
        for (i = 0, lim = toadd.length; lim > i; ) this.add(prop, toadd[i++]);
        return !0;
    }, Ref.prototype.toHTML = function() {
        var dom = !1;
        return this._db.forHTML && this._db.forHTML(this) || this._db.forDOM && (dom = this._db.forDOM(this)) && dom.outerHTML || this._id || this.oid || this.uuid;
    }, Ref.prototype.toDOM = function() {
        return this._db.forDOM && this._db.forDOM(this) || this._db.forHTML && fdjtDOM(this._db.forHTML(this)) || fdjtDOM("span.fdjtref", this._id || this.oid || this.uuid);
    }, ObjectMap.prototype.get = function(key) {
        var keystring = getKeyString(key, this.fordb);
        return this.hasOwnProperty(keystring) ? this[keystring] : "string" == typeof key ? this[key] || this["@" + key] : void 0;
    }, ObjectMap.prototype.getItem = ObjectMap.prototype.get, ObjectMap.prototype.set = function(key, val) {
        var keystring = getKeyString(key, this.fordb);
        this[keystring] = val instanceof Array ? [ val ] : val;
    }, ObjectMap.prototype.setItem = ObjectMap.prototype.set, ObjectMap.prototype.increment = function(key, delta) {
        var next, keystring = getKeyString(key, this.fordb), cur = this[keystring];
        return this[keystring] = next = cur ? cur + delta : delta, next;
    }, ObjectMap.prototype.add = function(key, val) {
        var keystring = getKeyString(key, this.fordb);
        if (this.hasOwnProperty(keystring)) {
            var cur = this[keystring];
            return cur === val ? !1 : cur instanceof Array ? arr_contains(cur, val) ? !1 : (cur.push(val), 
            !0) : val instanceof Array ? (this[keystring] = setify([ cur, val ]), !0) : (this[keystring] = setify([ cur, val ]), 
            !0);
        }
        this[keystring] = val instanceof Array ? setify([ val ]) : val;
    }, ObjectMap.prototype.drop = function(key, val) {
        var keystring = getKeyString(key, this.fordb);
        if (this.hasOwnProperty(keystring)) {
            var cur = this[keystring];
            if (cur === val) return delete this[keystring], !0;
            if (cur instanceof Array) {
                var pos = cur.indexOf(val);
                return 0 > pos ? !1 : (cur.splice(pos, 1), cur._sortlen && cur._sortlen--, 1 === cur.length && (cur[0] instanceof Array || (this[keystring] = cur[0])), 
                !0);
            }
            return !1;
        }
        return !1;
    }, fdjt.Map = ObjectMap, RefDB.ObjectMap = ObjectMap, RefDB.fdjtMap = ObjectMap, 
    StringMap.prototype.get = function(keystring) {
        return "string" != typeof keystring ? void 0 : this.hasOwnProperty(keystring) ? this[keystring] : void 0;
    }, StringMap.prototype.getItem = StringMap.prototype.get, StringMap.prototype.set = function(keystring, val) {
        "string" == typeof keystring && (this[keystring] = val instanceof Array ? [ val ] : val);
    }, StringMap.prototype.setItem = StringMap.prototype.set, StringMap.prototype.increment = function(keystring, delta) {
        if ("string" == typeof keystring) {
            var next, cur = this[keystring];
            return this[keystring] = next = cur ? cur + delta : delta, next;
        }
    }, StringMap.prototype.add = function(keystring, val) {
        if ("string" == typeof keystring) {
            if (this.hasOwnProperty(keystring)) {
                var cur = this[keystring];
                return cur === val ? !1 : cur instanceof Array ? arr_contains(cur, val) ? !1 : (cur.push(val), 
                !0) : val instanceof Array ? (this[keystring] = setify([ cur, val ]), !0) : (this[keystring] = setify([ cur, val ]), 
                !0);
            }
            this[keystring] = val instanceof Array ? setify([ val ]) : val;
        }
    }, StringMap.prototype.drop = function(keystring, val) {
        if ("string" == typeof keystring) {
            if (this.hasOwnProperty(keystring)) {
                var cur = this[keystring];
                if (cur === val) return delete this[keystring], !0;
                if (cur instanceof Array) {
                    var pos = cur.indexOf(val);
                    return 0 > pos ? !1 : (cur.splice(pos, 1), cur._sortlen && cur._sortlen--, 1 === cur.length && (cur[0] instanceof Array || (this[keystring] = cur[0])), 
                    !0);
                }
                return !1;
            }
            return !1;
        }
    }, fdjt.StringMap = StringMap, RefDB.StringMap = StringMap, RefMap.prototype.get = function(key) {
        if ("string" == typeof key) return this.hasOwnProperty(key) ? this[key] : void 0;
        if (key instanceof Ref) {
            var id = this.uniqueids && key._id || key._qid || key.getQID();
            return this[id];
        }
        return void 0;
    }, RefMap.prototype.set = function(key, val) {
        if ("string" == typeof key) this[key] = val; else {
            if (!(key instanceof Ref)) return !1;
            var id = key._qid || this.uniqueid && key._id || key.getQID();
            this[id] = val;
        }
    }, RefMap.prototype.increment = function(key, delta) {
        if ("string" == typeof key) this[key] = this.hasOwnProperty(key) ? this[key] + delta : delta; else {
            if (!(key instanceof Ref)) return !1;
            var id = key._qid || this.uniqueids && key._id || key.getQID();
            this[id] = (this[id] || 0) + delta;
        }
    }, fdjt.RefMap = RefDB.RefMap = RefMap, RefDB.add = function(obj, field, val, nodup) {
        if (2 === arguments.length) return set_add(obj, field);
        if (obj instanceof Ref) return obj.add.apply(obj, arguments);
        if (nodup) if (obj.hasOwnProperty(field)) {
            var vals = obj[field];
            arr_contains(vals, val) || obj[field].push(val);
        } else obj[field] = Array(val); else obj.hasOwnProperty(field) ? obj[field].push(val) : obj[field] = Array(val);
        obj._all && !arr_contains(obj._all, field) && obj._all.push(field);
    }, RefDB.drop = function(obj, field, val) {
        if (2 === arguments.length) return set_drop(obj, field);
        if (obj instanceof Ref) return obj.drop.apply(obj, arguments);
        if (val) {
            if (obj.hasOwnProperty(field)) {
                var vals = obj[field], pos = arr_position(vals, val);
                if (0 > pos) return;
                vals.splice(pos, 1);
            }
        } else obj[field] = [];
    }, RefDB.test = function(obj, field, val) {
        return 2 === arguments.length ? arr_contains(obj, field) : obj instanceof Ref ? obj.test.apply(obj, arguments) : val === void 0 ? (obj.hasOwnProperty ? obj.hasOwnProperty(field) : obj[field]) && obj[field].length > 0 : obj.hasOwnProperty(field) ? 0 > arr_position(obj[field], val) ? !1 : !0 : !1;
    }, RefDB.insert = function(array, value) {
        0 > arr_position(array, value) && array.push(value);
    }, RefDB.remove = function(array, value, count) {
        var pos = arr_position(array, value);
        if (0 > pos) return array;
        if (array.splice(pos, 1), count) for (count--; count > 0 && (pos = arr_position(array, value, pos)) >= 0; ) array.splice(pos, 1), 
        count--;
        return array;
    }, RefDB.indexOf = function(array, elt, pos) {
        return pos ? array.indexOf(elt, pos) : array.indexOf(elt);
    }, RefDB.contains = arr_contains, RefDB.position = arr_position, RefDB.countKeys = countKeys, 
    RefDB.localKeys = localKeys, RefDB.Query = Query, Query.prototype.uniqueids = !1, 
    Query.prototype.execute = function() {
        if (this.scores) return this;
        var dbs = this.dbs, clauses = this.clauses;
        if (!dbs || !dbs.length) {
            var empty_result = this.results = fdjtSet();
            return warn("No dbs for query %o!", this), empty_result;
        }
        if (!clauses || !clauses.length) {
            for (var full_result = fdjtSet(), i = 0, lim = dbs.length; lim > i; ) full_result = merge(full_result, setify(dbs[i++].allrefs));
            return this.results = full_result, full_result;
        }
        var query_weights = this._weights || this.weights, uniqueids = 1 === dbs.length || this.uniqueids, scores = new RefMap(), counts = new RefMap(), matches = fdjtSet(), match_seen = {};
        counts.uniqueids = scores.uniqueids = uniqueids;
        for (var i_clause = 0, n_clauses = clauses.length; n_clauses > i_clause; ) {
            var clause = clauses[i_clause++], fields = clause.fields, values = clause.values, clause_weights = clause.weights, findings = [];
            fields instanceof Array || (fields = [ fields ]), values instanceof Array || (values = [ values ]);
            for (var i_field = 0, n_fields = fields.length; n_fields > i_field; ) for (var field = fields[i_field++], weight = clause_weights && clause_weights[field] || query_weights && query_weights[field] || this.default_weight || 1, i_value = 0, n_values = values.length; n_values > i_value; ) for (var value = values[i_value++], i_db = 0, n_dbs = dbs.length; n_dbs > i_db; ) {
                var db = dbs[i_db++], hits = db.find(field, value);
                hits && hits.length && findings.push({
                    field: field,
                    hits: setify(hits),
                    weight: weight,
                    value: value,
                    db: db
                });
            }
            findings.sort(sortbyweight);
            for (var finding_i = 0, n_findings = findings.length, seen = {}; n_findings > finding_i; ) {
                var hit_id, ref, finding = findings[finding_i++], hit_ids = finding.hits, fdb = finding.db, abs = fdb.absrefs, i_hit = 0, n_hits = hit_ids.length;
                if (uniqueids || abs) for (;n_hits > i_hit; ) hit_id = hit_ids[i_hit++], seen[hit_id] || (seen[hit_id] = hit_id, 
                match_seen[hit_id] || (matches.push(fdb.ref(hit_id)), match_seen[hit_id] = hit_id), 
                counts[hit_id] = (counts[hit_id] || 0) + 1, scores[hit_id] = (scores[hit_id] || 0) + finding.weight); else {
                    hit_id = hit_ids[i_hit++], ref = fdb.ref(hit_id);
                    var fullid = ref._qid || abs && ref._id || ref.getQID();
                    if (seen[fullid]) continue;
                    seen[fullid] = fullid, match_seen[fullid] || (matches.push(ref), match_seen[fullid] = fullid), 
                    counts[fullid] = (counts[fullid] || 0) + 1, scores[fullid] = (scores[fullid] || 0) + finding.weight;
                }
            }
        }
        if (n_clauses > 1) {
            for (var results = this.results = [], new_scores = new RefMap(), new_counts = new RefMap(), i_matches = 0, n_matches = matches.length; n_matches > i_matches; ) {
                var match = matches[i_matches++], count = counts.get(match);
                if (count >= 2) {
                    var score = scores.get(match);
                    new_scores.set(match, score), new_counts.set(match, count), results.push(match);
                }
            }
            results._allstrings = !1, results._sortlen = results.length, this.results = results, 
            this.scores = new_scores, this.counts = new_counts;
        } else this.results = setify(matches), this.scores = scores, this.counts = counts;
        return this;
    }, RefDB.useIndexedDB = useIndexedDB, RefDB;
}(), fdjt.Ajax = function() {
    "use strict";
    function compose_uri(base_uri, args) {
        var uri = base_uri, need_amp = !1;
        if ("&" === base_uri[-1] ? need_amp = !1 : base_uri.indexOf("?") >= 0 ? need_amp = !0 : uri = base_uri + "?", 
        "string" == typeof args) uri = uri + (need_amp ? "&" : "") + args; else if (args.length) for (var i = 0; args.length > i; ) args[i] ? (uri = uri + (need_amp ? "&" : "") + encodeURIComponent(args[i]) + "=" + encodeURIComponent(args[i + 1]), 
        need_amp = !0, i += 2) : i += 2; else for (var key in args) args.hasOwnProperty(key) && (uri = uri + (need_amp ? "&" : "") + encodeURIComponent(key) + "=" + encodeURIComponent(args[key]), 
        need_amp = !0);
        return uri;
    }
    function statusOK(req, test) {
        var status = req.status;
        return test ? test.call ? test(req) : Array.isArray(test) ? test.indexOf(status) >= 0 : status >= 200 && 300 > status || 304 === status : status >= 200 && 300 > status || 304 === status;
    }
    function fdjtAjax(success_callback, base_uri, args, other_callback, headers, opts) {
        var timeout = "number" == typeof opts ? opts : opts && opts.timeout;
        "number" == typeof opts ? opts = {} : opts || (opts = {});
        var req = new XMLHttpRequest(), success = opts.success, uri = args ? compose_uri(base_uri, args) : base_uri;
        if (req.onreadystatechange = function() {
            4 === req.readyState && (statusOK(req, success) ? success_callback(req) : other_callback && other_callback(req));
        }, timeout && (req.timeout = timeout, other_callback && (req.ontimeout = function(evt) {
            evt = evt || window.event, other_callback(req);
        })), req.open("GET", uri), req.withCredentials = opts.hasOwnProperty("credentials") ? opts.credentials : !0, 
        headers) for (var key in headers) headers.hasOwnProperty(key) && req.setRequestHeader(key, headers[key]);
        return req.send(null), req;
    }
    function jsonpCall(uri, id, cleanup) {
        if (id && $ID(id)) return !1;
        var script_elt = fdjt.DOM("SCRIPT");
        id && (script_elt.id = id), cleanup && (script_elt.oncleanup = cleanup), script_elt.language = "javascript", 
        script_elt.src = uri, document.body.appendChild(script_elt);
    }
    function jsonpFinish(id) {
        var script_elt = $ID(id);
        script_elt && (script_elt.oncleanup && script_elt.oncleanup(), fdjtDOM.remove(script_elt));
    }
    function add_query_param(parameters, name, value) {
        return (parameters ? parameters + "&" : "") + name + "=" + encodeURIComponent(value);
    }
    function formParams(form) {
        fdjt.UI.AutoPrompt.cleanup(form);
        for (var parameters = !1, inputs = fdjtDOM.getChildren(form, "INPUT"), i = 0; inputs.length > i; ) {
            var input = inputs[i++];
            input.disabled || (/(radio)|(checkbox)/i.exec(input.type) ? !input.checked : 0) || (parameters = add_query_param(parameters, input.name, input.value));
        }
        var textareas = fdjtDOM.getChildren(form, "TEXTAREA");
        for (i = 0; textareas.length > i; ) {
            var textarea = textareas[i++];
            textarea.disabled || (parameters = add_query_param(parameters, textarea.name, textarea.value));
        }
        var selectboxes = fdjtDOM.getChildren(form, "SELECT");
        for (i = 0; selectboxes.length > i; ) for (var selectbox = selectboxes[i++], name = selectbox.name, options = fdjtDOM.getChildren(selectbox, "OPTION"), j = 0; options.length > j; ) {
            var option = options[j++];
            option.selected && (parameters = add_query_param(parameters, name, option.value));
        }
        return parameters;
    }
    function add_field(result, name, value, downcase) {
        if (downcase && (name = name.toLowerCase()), result.hasOwnProperty(name)) {
            var cur = result[name];
            cur.push ? cur.push(value) : result[name] = [ cur, value ];
        } else result[name] = value;
    }
    function formJSON(form, downcase) {
        fdjt.UI.AutoPrompt.cleanup(form);
        for (var result = {}, inputs = fdjtDOM.getChildren(form, "INPUT"), i = 0; inputs.length > i; ) {
            var input = inputs[i++];
            input.disabled || ("radio" === input.type || "checkbox" === input.type ? !input.checked : 0) || add_field(result, input.name, input.value, downcase || !1);
        }
        var textareas = fdjtDOM.getChildren(form, "TEXTAREA");
        for (i = 0; textareas.length > i; ) {
            var textarea = textareas[i++];
            textarea.disabled || add_field(result, textarea.name, textarea.value, downcase || !1);
        }
        var selectboxes = fdjtDOM.getChildren(form, "SELECT");
        for (i = 0; selectboxes.length > i; ) for (var selectbox = selectboxes[i++], name = selectbox.name, options = fdjtDOM.getChildren(selectbox, "OPTION"), j = 0; options.length > j; ) {
            var option = options[j++];
            option.selected && add_field(result, name, option.value, downcase || !1);
        }
        return result;
    }
    function ajaxSubmit(form, callback, opts) {
        var ajax_uri = form.getAttribute("ajaxaction") || form.action;
        if (!ajax_uri) return !1;
        var syncp = form.getAttribute("synchronous");
        trace_ajax && fdjtLog("Direct %s AJAX submit to %s for %o with callback %o", syncp ? "synchronous" : "asynchronous", ajax_uri, form, callback);
        var success = !1, callback_run = !1, req = new XMLHttpRequest(), params = formParams(form);
        fdjtDOM.addClass(form, "submitting"), syncp ? "GET" === form.method ? req.open("GET", ajax_uri + "?" + params, !1) : "PUT" === form.method ? req.open("PUT", ajax_uri, !1) : req.open("POST", ajax_uri, !1) : "GET" === form.method ? req.open("GET", ajax_uri + "?" + params) : "PUT" === form.method ? req.open("PUT", ajax_uri) : req.open("POST", ajax_uri), 
        req.onreadystatechange = function() {
            trace_ajax && fdjtLog("Ajax (%d,%d) %o for %o, callback=%o", req.readyState, 4 === req.readyState && req.status, req, ajax_uri, callback), 
            4 === req.readyState && req.status >= 200 && 300 > req.status ? (callback && trace_ajax && fdjtLog("Got callback (%d,%d) %o for %o, calling %o", req.readyState, req.status, req, ajax_uri, callback), 
            fdjtDOM.dropClass(form, "submitting"), success = !0, callback && callback(req, form), 
            callback_run = !0) : 4 === req.readyState && (fdjtLog("Failed callback (%d,%d) %o for %o, not calling %o", req.readyState, 4 === req.readyState && req.status, req, ajax_uri, callback), 
            fdjtDOM.dropClass(form, "submitting"), callback && callback(req, form), callback_run = !0);
        }, opts && opts.accept && req.setRequestHeader("Accept", opts.accepts), req.withCredentials = opts && opts.hasOwnProperty("creds") ? opts.creds : !0;
        try {
            "GET" === form.method ? req.send() : (req.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), 
            req.send(params)), success = !0;
        } catch (ex) {}
        return syncp && !callback_run && (trace_ajax && fdjtLog("Running callback (rs=%d,status=%d) %o for %o, calling %o", req.readyState, 4 === req.readyState && req.status, req, ajax_uri, callback), 
        4 === req.readyState && req.status >= 200 && 300 > req.status && (fdjtDOM.dropClass(form, "submitting"), 
        success = !0, callback && callback(req, form))), success;
    }
    function jsonpSubmit(form) {
        var jsonp_uri = form.getAttribute("jsonpuri");
        if (!jsonp_uri) return !1;
        var jsonid = form.id ? "JSONP" + form.id : "FORMJSONP", params = formParams(form);
        fdjtDOM.addClass(form, "submitting");
        try {
            jsonpCall(jsonp_uri + "?" + params, jsonid, function() {
                fdjt.DOM.dropClass(form, "submitting");
            });
        } catch (ex) {
            return jsonpFinish(jsonid), fdjtLog.warn("Attempted JSONP call signalled %o", ex), 
            !1;
        }
        return !0;
    }
    function form_submit(evt, callback) {
        evt = evt || window.event || null;
        var form = evt.nodeType ? evt : fdjt.UI.T(evt);
        return fdjt.UI.AutoPrompt.cleanup(form), fdjtDOM.hasClass(form, "submitting") ? (fdjtDOM.dropClass(form, "submitting"), 
        form.fdjtsubmit = !1, !1) : (form.fdjtsubmit = !0, fdjtDOM.addClass(form, "submitting"), 
        ajaxSubmit(form, callback) ? (fdjt.UI.cancel(evt), !0) : jsonpSubmit(form) ? (fdjt.UI.cancel(evt), 
        !0) : !1);
    }
    function copy_args(args, i) {
        var lim = args.length;
        i || (i = 0);
        for (var copy = Array(lim - i); lim > i; ) copy[i] = args[i], i++;
        return copy;
    }
    function sync_get(callback, base_uri, args) {
        var req = new XMLHttpRequest(), uri = compose_uri(base_uri, args);
        return req.open("GET", uri, !1), req.send(null), callback ? callback(req) : req;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, $ID = fdjt.ID, trace_ajax = !1;
    return fdjtAjax.textCall = function(callback, base_uri) {
        return fdjtAjax(function(req) {
            callback(req.responseText);
        }, base_uri, fdjtDOM.Array(arguments, 2));
    }, fdjtAjax.jsonCall = function(callback, base_uri) {
        return fdjtAjax(function(req) {
            callback(JSON.parse(req.responseText));
        }, base_uri, fdjtDOM.Array(arguments, 2));
    }, fdjtAjax.xmlCall = function(callback, base_uri) {
        return fdjtAjax(function(req) {
            callback(req.responseXML);
        }, base_uri, fdjtDOM.Array(arguments, 2));
    }, fdjtAjax.fetch = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(req);
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.fetchText = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(req.responseText);
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.fetchJSON = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(JSON.parse(req.responseText));
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.fetchXML = function(baseuri, args, headers, opts) {
        function fetching(resolved, rejected) {
            fdjtAjax(function(req) {
                resolved(JSON.parse(req.responseXML));
            }, baseuri, args, function(req) {
                rejected(req);
            }, headers, opts);
        }
        return new Promise(fetching);
    }, fdjtAjax.jsonpCall = jsonpCall, fdjtAjax.jsonpFinish = jsonpFinish, fdjtAjax.formParams = formParams, 
    fdjtAjax.formJSON = formJSON, fdjtAjax.formSubmit = ajaxSubmit, fdjtAjax.get = function(base_uri) {
        return sync_get(!1, base_uri, copy_args(arguments, 1));
    }, fdjtAjax.getText = function(base_uri) {
        return sync_get(function(req) {
            return req.responseText;
        }, base_uri, copy_args(arguments, 1));
    }, fdjtAjax.getJSON = function(base_uri) {
        return sync_get(function(req) {
            return JSON.parse(req.responseText);
        }, base_uri, fdjtDOM.Array(arguments, 1));
    }, fdjtAjax.getXML = function(base_uri) {
        return sync_get(function(req) {
            return req.responseXML;
        }, base_uri, fdjtDOM.Array(arguments, 1));
    }, fdjtAjax.onsubmit = form_submit, fdjtAjax;
}();

var WSN = function() {
    "use strict";
    function WSN(arg, sortfn, wordfn, keepdup) {
        if ("" === arg) return arg;
        if (!arg && this instanceof WSN) return sortfn && (this.sortfn = sortfn), wordfn && (this.wordfn = wordfn), 
        keepdup && (this.keepdup = keepdup), this;
        if (!arg) return arg;
        if (sortfn === void 0 && (sortfn = WSN.sortfn || !1), wordfn === void 0 && (wordfn = WSN.wordfn || !1), 
        keepdup === void 0 && (keepdup = WSN.keepdup || !1), "string" == typeof arg) {
            var norm = decodeEntities(arg).toLowerCase().replace(punct_regex, "");
            if (norm.trim ? norm = norm.trim() : (norm.search(/\S/) > 0 && (norm = norm.slice(norm.search(/\S/))), 
            norm.search(/\s+$/) > 0 && (norm = norm.slice(0, norm.search(/\s+$/)))), "" === norm) return "";
            var word, xword, i, lim, words = norm.split(/\W*\s+\W*/g), xwords = [], nwords = words.length;
            if (0 === nwords) return "";
            if (words[0] = words[0].replace(/^\W+/, ""), nwords > 1 && (words[nwords - 1] = words[nwords - 1].replace(/\W+$/, "")), 
            wordfn) if ("number" == typeof wordfn) {
                for (i = 0, lim = words.length; lim > i; ) xword = words[i++], word.length > wordfn && xwords.push(xword);
                xwords.length && (words = xwords);
            } else if (wordfn.call) {
                for (i = 0, lim = words.length; lim > i; ) xword = wordfn(words[i++]), xword && xwords.push(xword), 
                i++;
                xwords.length && (words = xwords);
            } else {
                for (i = 0, lim = words.length; lim > i; ) word = words[i++], xword = wordfn[word], 
                "" === xword || (xword && "string" == typeof xword ? xwords.push(xword) : xwords.push(word));
                xwords.length && (words = xwords);
            }
            var sorter = sortfn;
            return sortfn === !0 ? sorter = lensort : sortfn === nativesort && (sorter = !1), 
            sortfn && keepdup ? words.sort(sorter).join(" ") : sortfn ? dedupfn(words.sort(sorter)).join(" ") : words.join(" ");
        }
        if (arg.nodeType) {
            if (3 === arg.nodeType) return WSN(arg.nodeValue);
            if (1 === arg.nodeType) return WSN(textify(arg));
            throw Error("bad arg to WSN");
        }
        throw Error("bad arg to WSN");
    }
    function dedupfn(arr) {
        var i = 0, lim = arr.length, last = !1;
        if (2 > lim) return arr;
        for (;lim > i; ) {
            if (last && arr[i] === last) return dodedup(arr);
            last = arr[i++];
        }
        return arr;
    }
    function dodedup(arr) {
        for (var last = arr[0], result = [ last ], i = 1, lim = arr.length; lim > i; ) arr[i] === last ? i++ : result.push(last = arr[i++]);
        return result;
    }
    function lensort(x, y) {
        var xl = x.length, yl = y.length;
        return xl === yl ? x > y ? -1 : y > x ? 1 : 0 : xl > yl ? -1 : 1;
    }
    function nativesort(x, y) {
        return x > y ? -1 : y > x ? 1 : 0;
    }
    function textify(arg, text) {
        if (arg.nodeType) {
            if (3 === arg.nodeType) return text ? text + arg.nodeValue : arg.nodeValue;
            if (1 === arg.nodeType) {
                var children = arg.childNodes, style = window.getComputedStyle ? window.getComputedStyle(arg) : {
                    position: "static",
                    display: "block"
                };
                if ("static" !== style.position) return text || "";
                "inline" !== style.display ? text = "\n" + (text || "") : text || (text = "");
                for (var i = 0, lim = children.length; lim > i; ) {
                    var child = children[i++];
                    3 === child.nodeType ? text += child.nodeValue : 1 === child.nodeType && (text = textify(child, text));
                }
                return text;
            }
            return text ? text : "";
        }
        return text || "";
    }
    function fuddle(arg, sortfn) {
        return WSN(arg, sortfn || lensort);
    }
    function md5ID() {
        var wsn = WSN.apply(null, arguments);
        if (wsn) {
            if (WSN.md5) return WSN.md5(wsn);
            if (fdjtHash && fdjtHash.hex_md5) return fdjtHash.hex_md5(wsn);
            throw Error("No MD5 implementation");
        }
        return wsn;
    }
    function sha1ID() {
        var wsn = WSN.apply(null, arguments);
        if (wsn) {
            if (WSN.sha1) return WSN.md5(wsn);
            if (fdjtHash && fdjtHash.hex_sha1) return fdjtHash.hex_sha1(wsn);
            throw Error("No SHA1 implementation");
        }
        return wsn;
    }
    function hash(arg, hashfn, sortfn, wordfn, keepdups) {
        hashfn === void 0 && (hashfn = WSN.hashfn || !1), sortfn === void 0 && (sortfn = WSN.sortfn || !1), 
        wordfn === void 0 && (wordfn = WSN.wordfn || !1), keepdups === void 0 && (keepdups = WSN.keepdup || !1);
        var wsn = WSN(arg, sortfn, wordfn, keepdups);
        return wsn ? hashfn ? hashfn(wsn) : wsn : wsn;
    }
    function maphash(nodes, hashfn, sortfn, wordfn, keepdups) {
        hashfn === void 0 && (hashfn = WSN.hashfn || !1), sortfn === void 0 && (sortfn = WSN.sortfn || !1), 
        wordfn === void 0 && (wordfn = WSN.wordfn || !1), keepdups === void 0 && (keepdups = WSN.keepdup || !1);
        for (var map = {}, i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++], wsn = WSN(node, sortfn, wordfn, keepdups), id = hashfn ? hashfn(wsn) : wsn;
            map[id] = node;
        }
        return map;
    }
    function mapMD5(nodes, sortfn, wordfn, keepdups) {
        var hashfn = WSN.md5 || fdjtHash && fdjtHash.hex_md5;
        return maphash(nodes, hashfn, sortfn, wordfn, keepdups);
    }
    function mapSHA1(nodes, sortfn, wordfn, keepdups) {
        var hashfn = WSN.sha1 || fdjtHash && fdjtHash.hex_sha1;
        return maphash(nodes, hashfn, sortfn, wordfn, keepdups);
    }
    var fdjtHash = fdjt.Hash, fdjtString = fdjt.String, punct_regex = /(\pM)/g, decodeEntities = fdjtString.decodeEntities;
    return WSN.lensort = lensort, WSN.nativesort = nativesort, WSN.prototype.textify = WSN.textify = textify, 
    WSN.fuddle = fuddle, WSN.md5ID = md5ID, WSN.sha1ID = sha1ID, WSN.hash = hash, WSN.prototype.Hash = function(arg) {
        return hash(arg, this.hashfn || WSN.hashfn || !1, this.sortfn || WSN.sortfn || !1, this.wordfn || WSN.wordfn || !1, this.keepdup || WSN.keepdup || !1);
    }, WSN.maphash = maphash, WSN.prototype.maphash = function(arg) {
        return maphash(arg, this.hashfn || WSN.hashfn || !1, this.sortfn || WSN.sortfn || !1, this.wordfn || WSN.wordfn || !1, this.keepdup || WSN.keepdup || !1);
    }, WSN.mapMD5 = mapMD5, WSN.mapSHA1 = mapSHA1, WSN.md5 = fdjtHash && fdjtHash.hex_md5, 
    WSN.sha1 = fdjtHash && fdjtHash.hex_sha1, WSN;
}();

fdjt.WSN = WSN, fdjt.TextIndex = function() {
    "use strict";
    function TextIndex(opts) {
        function _indexer(string, id) {
            for (var stdtext = stdspace(string), words = stdtext.split(/\b/g), termlist = [], i = 0, lim = words.length; lim > i; ) {
                var term = words[i++], iscap = /[A-Z][^A-Z]/.exec(term), next = words[i];
                if (!(0 > term.search(/\w/) || (next && glue.exec(next) && lim > i + 1 && words[i + 1].search(/\w/) >= 0 && (term = term + next + words[i + 1], 
                i += 2), 2 > term.length || stopwords.hasOwnProperty(term) || iscap && stopwords.hasOwnProperty(term.toLowerCase())))) if (stopfns) for (var fn = 0, fns = stopfns.length; fns > fn; ) !stopfns[fn++](term); else {
                    if (termlist.push(term), rootmap.hasOwnProperty(term)) {
                        var roots = rootmap[term];
                        "string" == typeof roots ? termlist.push(roots) : termlist = termlist.concat(roots);
                    }
                    if (rootfns) for (var rootfn = 0, nrootfns = rootfns.length; nrootfns > rootfn; ) {
                        var r = rootfns[rootfn++](term);
                        "string" == typeof r ? termlist.push(r) : termlist = termlist.concat(r);
                    }
                }
            }
            var ti = 0, tlim = termlist.length;
            for (idterms.hasOwnProperty(id) ? idterms[id] = idterms[id].concat(termlist) : (idterms[id] = termlist, 
            allids.push(id)); tlim > ti; ) {
                var t = termlist[ti++];
                termindex.hasOwnProperty(t) ? termindex[t].push(id) : (allterms.push(t), termindex[t] = [ id ]);
            }
        }
        function stopWord(s) {
            if (stopwords.hasOwnProperty(s)) return !0;
            if (stopfns) {
                for (var i = 0, lim = stopfns.length; lim > i; ) if (stopfns[i++](s)) return !0;
                return !1;
            }
            return !1;
        }
        function getRoots(s) {
            for (var roots = rootmap[s] || [], i = 0, lim = rootfns.length; lim > i; ) {
                var r = rootfns[i++](s);
                r && ("string" == typeof r ? roots.push(r) : roots = roots.concat(r));
            }
            return roots;
        }
        function mergeTerms() {
            for (var i = 0, lim = allterms.length; lim > i; ) {
                var term = allterms[i++];
                if (0 === term.search(/[A-Z][a-z]/)) {
                    var lterm = term.toLowerCase();
                    termindex.hasOwnProperty(lterm) && (termindex[lterm] = termindex[lterm].concat(termindex[term]));
                }
            }
        }
        function finishIndex(index) {
            for (var newterms = [], newindex = {}, i = 0, lim = allterms.length, moved = [], capwords = index.capwords; lim > i; ) {
                var term = allterms[i++];
                if (0 === term.search(/[A-Z][a-z]/)) {
                    var lterm = term.toLowerCase();
                    termindex.hasOwnProperty(lterm) ? capwords.hasOwnProperty(term) ? (newindex[term] = termindex[term], 
                    newterms.push(term)) : moved.push(term) : (newindex[term] = termindex[term], newterms.push(term));
                } else newindex[term] = termindex[term], newterms.push(term);
            }
            for (i = 0, lim = moved.length; lim > i; ) {
                var move = moved[i++], l = move.toLowerCase();
                newindex[l] = newindex[l].concat(termindex[move]);
            }
            index.termindex = termindex = newindex, index.allterms = allterms = newterms;
        }
        opts || (opts = {});
        var i, lim, stopfns = opts.stopfns || !1, stopwords = {}, rootfns = opts.rootfns || !1, rootmap = {}, termindex = {}, idterms = {}, allterms = [], allids = [], glue = /^[-'_@.\/]$/;
        if (this instanceof TextIndex) {
            if (this._indexer = _indexer, opts.stopwords) {
                var istops = opts.stopwords;
                for (i = 0, lim = istops.length; lim > i; ) {
                    var stop = istops[i++];
                    stopwords[stop] = stop;
                }
            }
            if (opts.stdstops) for (var is = 0, islim = default_stopwords_init.length; islim > is; ) {
                var stop_word = default_stopwords_init[is++];
                stopwords[stop_word] = stop_word;
            }
            return this.capwords = opts.capwords || {}, this.termindex = termindex, this.idterms = idterms, 
            this.allterms = allterms, this.allids = allids, this.opts = opts, this.stopWord = stopWord, 
            this.getRoots = getRoots, this.mergeTerms = mergeTerms, this.finishIndex = function() {
                finishIndex(this);
            }, this;
        }
        return new TextIndex(opts);
    }
    for (var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, stdspace = fdjtString.stdspace, textify = fdjtDOM.textify, default_stopwords_init = [ "a", "i", "--", "am", "an", "as", "at", "be", "by", "d'", "de", "di", "do", "ex", "he", "if", "in", "is", "it", "me", "my", "no", "o'", "of", "on", "or", "so", "t'", "to", "up", "us", "we", "ya", "ye", "any", "are", "but", "can", "cum", "des", "did", "ere", "fer", "few", "for", "had", "has", "her", "him", "his", "hoo", "how", "i'd", "i'm", "its", "lot", "may", "nor", "not", "off", "our", "qua", "s/p", "she", "ten", "the", "via", "was", "who", "why", "yet", "you", "'tis", "amid", "atop", "been", "both", "does", "doth", "down", "d", "each", "even", "from", "haec", "hast", "hath", "have", "he'd", "he's", "here", "hers", "i'll", "i're", "i've", "into", "it'd", "it's", "last", "less", "like", "many", "mine", "miss", "more", "most", "must", "near", "nigh", "none", "o'er", "once", "only", "onto", "ours", "over", "o", "past", "port", "reg.", "sans", "says", "some", "such", "thae", "than", "that", "thee", "them", "then", "they", "thir", "this", "thou", "thro", "thru", "thus", "till", "unto", "upon", "upto", "we'd", "were", "what", "when", "whom", "will", "wilt", "with", "your", "yous", "zero", "abaft", "aboon", "about", "above", "adown", "afore", "after", "ain't", "along", "among", "anear", "anent", "aught", "baith", "being", "below", "can't", "circa", "could", "didst", "doest", "doeth", "don't", "every", "fewer", "fifty", "forty", "gonna", "he'll", "he're", "he've", "her'n", "his'n", "isn't", "it'll", "maybe", "might", "neath", "never", "noone", "one's", "other", "our'n", "round", "shall", "shalt", "she'd", "she's", "since", "their", "there", "these", "those", "thro'", "today", "under", "until", "we'll", "we're", "we've", "where", "which", "while", "who'd", "who's", "whose", "whoso", "won't", "would", "you'd", "yours", "youse", "aboard", "across", "allyou", "amidst", "anyone", "aren't", "around", "before", "behind", "beside", "beyond", "cannot", "contra", "couple", "didn't", "during", "either", "eleven", "except", "google", "hadn't", "hasn't", "having", "inside", "itself", "myriad", "myself", "no-one", "nobody", "oer", "quibus", "she'll", "she're", "she've", "should", "sundry", "that'd", "that's", "theirs", "they'd", "thirty", "this'd", "thwart", "tother", "toward", "twelve", "twenty", "unless", "unlike", "versus", "wasn't", "what's", "whence", "whilst", "withal", "within", "you'll", "you're", "you've", "your'n", "against", "aint", "amongst", "another", "anybody", "astride", "athwart", "because", "beneath", "besides", "between", "betwixt", "cant", "despite", "doesn't", "dont", "haven't", "herself", "himself", "hisself", "however", "hundred", "isnt", "neither", "nothing", "oneself", "ourself", "outside", "outwith", "pending", "perhaps", "several", "someone", "that'll", "there's", "they'll", "they're", "they've", "this'll", "through", "thro", "thyself", "towards", "weren't", "whereby", "wherein", "whereof", "whereon", "whereto", "whether", "whoever", "without", "wont", "you-all", "arent", "didnt", "hadnt", "hasnt", "wasnt", "doesnt", "havent", "werent" ], default_stopwords = {}, is = 0, islim = default_stopwords_init.length; islim > is; ) {
        var stop_word = default_stopwords_init[is++];
        0 > stop_word.indexOf("'") && (default_stopwords[stop_word] = stop_word);
    }
    return TextIndex.default_stops = default_stopwords, TextIndex.prototype.indexText = function(arg, id) {
        var indexer = this._indexer;
        if ("string" == typeof arg) id && indexer(arg, id); else if (arg.nodeType) id || (id = arg.id), 
        id && indexer(textify(arg), id); else if (arg.length) for (var i = 0, lim = arg.length; lim > i; ) {
            var node = arg[i++];
            1 === node.nodeType && node.id && indexer(textify(node), node.id);
        }
    }, TextIndex.prototype.prefixTree = function() {
        if (this.prefixtree) return this.prefixtree;
        for (var ptree = this.prefixtree = {
            strings: []
        }, prefixAdd = fdjtString.prefixAdd, allterms = this.allterms, i = 0, lim = allterms.length; lim > i; ) {
            var term = allterms[i++];
            prefixAdd(ptree, term, 0);
        }
        return ptree;
    }, TextIndex;
}(), fdjt.UI || (fdjt.UI = {}), fdjt.UI.CoHi || (fdjt.UI.CoHi = {
    classname: "cohi"
}), fdjt.UI.AutoPrompt || (fdjt.UI.AutoPrompt = {}), fdjt.UI.InputHelp || (fdjt.UI.InputHelp = {}), 
fdjt.UI.Ellipsis || (fdjt.UI.Ellipsis = {}), fdjt.UI.Expansion || (fdjt.UI.Expansion = {}), 
fdjt.UI.Collapsible || (fdjt.UI.Collapsible = {}), fdjt.UI.Tabs || (fdjt.UI.Tabs = {}), 
fdjt.UI.MultiText || (fdjt.UI.MultiText = {}), fdjt.UI.Reticle || (fdjt.UI.Reticle = {}), 
fdjt.UI.FocusBox || (fdjt.UI.FocusBox = {}), function() {
    "use strict";
    function highlight(namearg, classname_arg) {
        var i, n, classname = classname_arg || fdjtUI.CoHi.classname, newname = namearg.name || namearg, cur = highlights[classname];
        if (cur !== newname) {
            if (cur) {
                var drop = document.getElementsByName(cur);
                for (i = 0, n = drop.length; n > i; ) fdjtDOM.dropClass(drop[i++], classname);
            }
            if (highlights[classname] = newname || !1, newname) {
                var elts = document.getElementsByName(newname);
                for (n = elts.length, i = 0; n > i; ) fdjtDOM.addClass(elts[i++], classname);
            }
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, highlights = {};
    fdjtUI.CoHi.highlight = highlight, fdjtUI.CoHi.onmouseover = function(evt, classname_arg) {
        for (var target = fdjtDOM.T(evt); target; ) {
            if (3 === target.nodeType) target = target.parentNode; else if (1 !== target.nodeType) {
                target = !1;
                break;
            }
            if ("INPUT" === target.tagName || "TEXTAREA" === target.tagName || "A" === target.tagName && target.href) return;
            if (target.name || target.getAttribute("name")) break;
            target = target.parentNode;
        }
        target && highlight(target.name || target.getAttribute("name"), classname_arg);
    }, fdjtUI.CoHi.onmouseout = function(evt, classname_arg) {
        highlight(!1, classname_arg || fdjtUI.CoHi.classname);
    };
}(), fdjt.UI.Highlight = function() {
    "use strict";
    function textnode(s) {
        return document.createTextNode(s);
    }
    function gatherHighlights(node, classpat, into) {
        if (1 === node.nodeType) {
            if (node.childNodes) for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) gatherHighlights(children[i++], classpat, into);
            node.className && node.className.search && node.className.search(classpat) >= 0 && into.push(node);
        }
    }
    function unwrap_hnode(hnode) {
        var ch = hnode.childNodes;
        if (ch) {
            for (var frag = document.createDocumentFragment(), tomove = [], j = 0, n = ch && ch.length; n > j; ) tomove.push(ch[j++]);
            for (j = 0, n = tomove.length; n > j; ) frag.appendChild(tomove[j++]);
            fdjtDOM.replace(hnode, frag);
        } else fdjtDOM.remove(hnode);
    }
    function clear_highlights(node, hclass) {
        var h = [];
        node === hclass || hasClass(node, hclass) ? h = [ node ] : gatherHighlights(node, RegExp("\\b" + hclass + "\\b", "g"), h);
        for (var i = 0, lim = h.length; lim > i; ) unwrap_hnode(h[i++]);
    }
    function highlight_node(node, hclass, htitle, hattribs) {
        hclass || (hclass = highlight_class);
        var hispan = !1;
        if (3 === node.nodeType) {
            var text = node.nodeValue;
            if (text.search(/\S/g) >= 0) hispan = fdjtDOM("span." + hclass); else {
                var parent = node.parentNode, style = getStyle(parent), next = node.nextSibling, prev = node.prevSibling, nstyle = next && 1 === next.nodeType && getStyle(next), pstyle = prev && 1 === prev.nodeType && getStyle(prev), ndisplay = nstyle && nstyle.display, pdisplay = pstyle && pstyle.display;
                hispan = "normal" !== style.whiteSpace ? fdjtDOM("span." + hclass) : next || prev ? "inline" !== ndisplay && "table-cell" !== ndisplay && "inline" !== pdisplay && "table-cell" !== pdisplay ? !1 : fdjtDOM("span." + hclass) : fdjtDOM("span." + hclass);
            }
        } else {
            if (1 !== node.nodeType || hasClass(node, hclass)) return node;
            if (hasClass(node, "fdjtskiptext")) ; else {
                var nodestyle = getStyle(node), display = nodestyle.display, position = nodestyle.position;
                "static" !== position && "" !== position || ("block" === display ? hispan = fdjtDOM("div." + hclass) : "inline" === display && (hispan = fdjtDOM("span." + hclass)));
            }
        }
        if (!hispan) return node;
        if (htitle && (hispan.title = htitle), hattribs) for (var attrib in hattribs) hattribs.hasOwnProperty(attrib) && hispan.setAttribute(attrib, hattribs[attrib]);
        return fdjtDOM.replace(node, hispan), hispan.appendChild(node), hispan;
    }
    function highlight_text(text, hclass, htitle, hattribs) {
        var tnode = fdjtDOM("span." + (hclass || highlight_class), text);
        if (htitle && (tnode.title = htitle), hattribs) for (var attrib in hattribs) hattribs.hasOwnProperty(attrib) && tnode.setAttribute(attrib, hattribs[attrib]);
        return tnode;
    }
    function highlight_node_range(node, start, end, hclass, htitle, hattribs) {
        var stringval = node.nodeValue, parent = node.parentNode;
        if ((end === !1 || end === void 0) && (end = stringval.length), start !== end) {
            var beginning = start > 0 && textnode(stringval.slice(0, start)), middle = highlight_text(stringval.slice(start, end), hclass, htitle, hattribs), ending = stringval.length > end && textnode(stringval.slice(end));
            return beginning && ending ? (parent.replaceChild(ending, node), parent.insertBefore(middle, ending), 
            parent.insertBefore(beginning, middle)) : beginning ? (parent.replaceChild(middle, node), 
            parent.insertBefore(beginning, middle)) : ending ? (parent.replaceChild(ending, node), 
            parent.insertBefore(middle, ending)) : parent.replaceChild(middle, node), middle;
        }
    }
    function highlight_range(range, hclass, htitle, hattribs) {
        range = fdjtDOM.refineRange(range);
        var starts_in = range.startContainer, ends_in = range.endContainer;
        if (starts_in === ends_in) return [ highlight_node_range(starts_in, range.startOffset, range.endOffset, hclass, htitle, hattribs) ];
        for (var highlights = [], scan = starts_in; scan && !scan.nextSibling; ) scan = scan.parentNode;
        for (scan = scan.nextSibling; scan && scan !== ends_in; ) if (hasParent(ends_in, scan)) scan = scan.firstChild; else {
            for (var next = scan; next && !next.nextSibling; ) next = next.parentNode;
            next = next.nextSibling, highlights.push(highlight_node(scan, hclass, htitle, hattribs)), 
            scan = next;
        }
        return highlights.push(highlight_node_range(starts_in, range.startOffset, !1, hclass, htitle, hattribs)), 
        highlights.push(highlight_node_range(ends_in, 0, range.endOffset, hclass, htitle, hattribs)), 
        highlights;
    }
    var fdjtDOM = fdjt.DOM, highlight_class = "fdjthighlight", hasClass = fdjtDOM.hasClass, hasParent = fdjtDOM.getParent, getStyle = fdjtDOM.getStyle;
    return highlight_range.clear = clear_highlights, highlight_range.remove = unwrap_hnode, 
    highlight_range.highlight = highlight_range, highlight_range;
}(), function() {
    "use strict";
    function CheckSpan(spec, varname, val, checked) {
        var input = fdjtDOM.Input("input[type=checkbox]", varname, val), span = fdjtDOM(spec || "span.checkspan", input);
        return checked ? (input.checked = !0, fdjtDOM.addClass(span, "ischecked")) : input.checked = !1, 
        arguments.length > 4 && fdjtDOM.appendArray(span, arguments, 4), span;
    }
    function checkable(elt) {
        return 1 === elt.nodeType && "INPUT" === elt.tagName && ("checkbox" === elt.type || "radio" === elt.type);
    }
    function getcheckable(elt) {
        if (checkable(elt)) return elt;
        var cb = getParent(elt, checkable);
        if (cb) return cb;
        if (cb = getChildren(elt, "input"), cb.length) {
            for (var i = 0, lim = cb.length; lim > i; ) {
                if (checkable(cb[i])) return cb[i];
                i++;
            }
            return !1;
        }
        return !1;
    }
    function checkspan_set(target, checked) {
        var i, lim;
        if ("string" == typeof target) target = fdjtID(target); else if (target.length) {
            for (i = 0, lim = target.length; lim > i; ) checkspan_set(target[i++], checked);
            return;
        }
        if (target && target.nodeType) {
            var checkspan = hasClass(target, "checkspan") ? target : getParent(target, ".checkspan");
            if (!checkspan) return !1;
            var checkbox = checkable(target) && target || getcheckable(target) || getcheckable(checkspan);
            if (!checkbox) return !1;
            if (hasClass(checkspan, "isdisabled")) {
                if (checkbox.disabled) return !1;
                dropClass(checkspan, "isdisabled");
            } else if (checkbox.disabled) return addClass(checkspan, "isdisabled"), !1;
            var ischecked = hasClass(checkspan, "ischecked"), changed = !1, unchecked = [];
            if (checked === void 0 && (checked = ischecked), checkbox.checked !== checked ? (checkbox.checked = checked, 
            changed = !0) : ischecked !== checkbox.checked && (changed = !0), checked ? addClass(checkspan, "ischecked") : dropClass(checkspan, "ischecked"), 
            changed && "radio" === checkbox.type) {
                var form = checkbox.form;
                form || (form = getParent(checkbox, ".fdjtinputs")), form || (form = checkspan.parentNode);
                var name = checkbox.name, tosync = getChildren(form, "input");
                for (i = 0, lim = tosync.length; lim > i; ) {
                    var input = tosync[i++];
                    if (input !== checkbox && "radio" === input.type && input.name === name) {
                        var cspan = getParent(input, ".checkspan");
                        if (cspan === checkspan) continue;
                        hasClass(cspan, "ischecked") && (input.checked || unchecked.push(input));
                    }
                }
            }
            var evt;
            if (changed && (evt = document.createEvent("HTMLEvents"), evt.initEvent("change", !1, !0), 
            checkbox.dispatchEvent(evt)), unchecked.length) for (i = 0, lim = unchecked.length; lim > i; ) {
                var uncheck = unchecked[i++], altspan = getParent(uncheck, ".checkspan");
                dropClass(altspan, "ischecked"), evt = document.createEvent("HTMLEvents"), evt.initEvent("change", !1, !0), 
                uncheck.dispatchEvent(evt);
            }
        }
    }
    function checkspan_onclick(evt) {
        evt = evt || window.event;
        var target = evt.target || evt.srcTarget;
        if ("TEXTAREA" !== target.tagName && "SELECT" !== target.tagName && "OPTION" !== target.tagName && ("INPUT" !== target.tagName || "checkbox" === target.type || "radio" === target.type)) {
            var anchor = "A" === target.tagName ? target : getParent(target, "A");
            if (!anchor || !anchor.href) {
                var checkspan = getParent(target, ".checkspan");
                if (checkspan) {
                    var checked = hasClass(checkspan, "ischecked");
                    return checkspan_set(target, !checked), !1;
                }
            }
        }
    }
    function changed(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if ("radio" === target.type || "checkbox" === target.type) {
            var checkspan = getParent(target, ".checkspan");
            checkspan && (target.checked ? addClass : dropClass)(checkspan, "ischecked");
        }
        if ("radio" === target.type) for (var form = target.form, others = document.getElementsByName(target.name), i = 0, lim = others.length; lim > i; ) {
            var other = others[i++];
            if (other !== target && other.form === form && "radio" === other.type) {
                var ocs = fdjtDOM.getParent(other, ".checkspan");
                dropClass(ocs, "ischecked");
            }
        }
    }
    function initCheckspans() {
        for (var checkspans = fdjt.$(".checkspan"), i = 0, lim = checkspans.length; lim > i; ) for (var checkspan = checkspans[i++], inputs = fdjtDOM.getInputs(checkspan), j = 0, jlim = inputs.length; jlim > j; ) {
            var input = inputs[j++];
            if ("radio" === input.type || "checkspan" === input.type) {
                input.checked && addClass(checkspan, "ischecked"), input.disabled && addClass(checkspan, "isdisabled");
                break;
            }
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getParent = fdjtDOM.getParent, getChildren = fdjtDOM.getChildren;
    fdjtUI.CheckSpan = CheckSpan, fdjtUI.CheckSpan.set = checkspan_set, fdjtUI.CheckSpan.onclick = checkspan_onclick, 
    fdjtUI.CheckSpan.changed = changed, fdjtUI.CheckSpan.initCheckspans = initCheckspans, 
    fdjt.addInit(initCheckspans, "CheckSpans", !1);
}(), fdjt.UI.ProgressBar = function() {
    "use strict";
    function ProgressBar(arg) {
        return arg === void 0 ? arg = fdjtDOM("div.fdjtprogress", fdjtDOM("div.indicator"), fdjtDOM("div.message")) : "string" == typeof arg && (arg = fdjtDOM("div.fdjtprogress", fdjtDOM("HR"), fdjtDOM("div.message", arg))), 
        this.dom = arg, this;
    }
    function setProgress(pb, progress, total) {
        if ("string" == typeof pb && (pb = document.getElementById(pb)), "number" == typeof total && (progress = 100 * (progress / total)), 
        pb) {
            var dom = pb.dom || pb;
            if (dom.nodeType) {
                var rule = fdjtDOM.getChildren(dom, "div.indicator")[0];
                rule.style.width = progress + "%";
            }
        }
    }
    function setMessage(pb) {
        if ("string" == typeof pb && (pb = document.getElementById(pb)), pb) {
            var dom = pb.dom || pb;
            if (dom.nodeType) {
                var oldmsg = fdjtDOM.getChildren(dom, ".message")[0], newmsg = fdjtDOM("div.message");
                fdjtDOM.appendArray(newmsg, fdjtDOM.Array(arguments, 1)), dom.replaceChild(newmsg, oldmsg);
            }
        }
    }
    var fdjtDOM = fdjt.DOM;
    return ProgressBar.setProgress = setProgress, ProgressBar.setMessage = setMessage, 
    ProgressBar.prototype.setProgress = function(progress, total) {
        setProgress(this.dom, progress, total);
    }, ProgressBar.prototype.setMessage = function() {
        var dom = this.dom, oldmsg = fdjtDOM.getChildren(dom, ".message")[0], newmsg = fdjtDOM("div.message");
        fdjtDOM.appendArray(newmsg, fdjtDOM.Array(arguments)), dom.replaceChild(newmsg, oldmsg);
    }, ProgressBar;
}(), function() {
    "use strict";
    function show_help_onfocus(evt) {
        for (var target = fdjtDOM.T(evt); target; ) {
            if (1 === target.nodeType && ("INPUT" === target.tagName || "TEXTAREA" === target.tagName) && target.getAttribute("helptext")) {
                var helptext = fdjtID(target.getAttribute("helptext"));
                return helptext && fdjtDOM.addClass(helptext, "showhelp"), void 0;
            }
            target = target.parentNode;
        }
    }
    function autoprompt_onfocus(evt) {
        evt = evt || window.event || null;
        var elt = fdjtDOM.T(evt);
        elt && hasClass(elt, "isempty") && (elt.value = "", dropClass(elt, "isempty")), 
        show_help_onfocus(evt);
    }
    function hide_help_onblur(evt) {
        for (var target = fdjtDOM.T(evt); target; ) {
            if (1 === target.nodeType && ("INPUT" === target.tagName || "TEXTAREA" === target.tagName) && target.getAttribute("HELPTEXT")) {
                var helptext = fdjtID(target.getAttribute("HELPTEXT"));
                return helptext && dropClass(helptext, "showhelp"), void 0;
            }
            target = target.parentNode;
        }
    }
    function autoprompt_onblur(evt) {
        var elt = fdjtDOM.T(evt);
        if ("" === elt.value) {
            addClass(elt, "isempty");
            var prompt = elt.prompt || elt.getAttribute("prompt") || elt.title;
            prompt && (elt.value = prompt);
        } else dropClass(elt, "isempty");
        hide_help_onblur(evt);
    }
    function autoprompt_cleanup(form) {
        var elements = fdjtDOM.getChildren(form, ".isempty");
        if (elements) for (var i = 0, lim = elements.length; lim > i; ) elements[i++].value = "";
    }
    function autoprompt_onsubmit(evt) {
        var form = fdjtDOM.T(evt);
        autoprompt_cleanup(form);
    }
    function autoprompt_setup(arg, nohandlers) {
        for (var forms = "FORM" === arg.tagName ? [ arg ] : fdjtDOM.getChildren(arg || document.body, "FORM"), i = 0, lim = forms.length; lim > i; ) {
            var form = forms[i++], inputs = fdjtDOM.getChildren(form, "INPUT.autoprompt,TEXTAREA.autoprompt");
            if (inputs.length) {
                for (var j = 0, jlim = inputs.length; jlim > j; ) {
                    var input = inputs[j++];
                    if (input.blur(), isEmpty(input.value)) {
                        addClass(input, "isempty");
                        var prompt = input.prompt || input.getAttribute("prompt") || input.title;
                        prompt && (input.value = prompt);
                    }
                    nohandlers || (fdjtDOM.addListener(input, "focus", autoprompt_onfocus), fdjtDOM.addListener(input, "blur", autoprompt_onblur));
                }
                nohandlers || fdjtDOM.addListener(form, "submit", autoprompt_onsubmit);
            }
        }
    }
    var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, isEmpty = fdjtString.isEmpty;
    fdjt.UI.AutoPrompt.setup = autoprompt_setup, fdjt.UI.AutoPrompt.onfocus = autoprompt_onfocus, 
    fdjt.UI.AutoPrompt.onblur = autoprompt_onblur, fdjt.UI.AutoPrompt.onsubmit = autoprompt_onsubmit, 
    fdjt.UI.AutoPrompt.cleanup = autoprompt_cleanup, fdjt.UI.InputHelp.onfocus = show_help_onfocus, 
    fdjt.UI.InputHelp.onblur = hide_help_onblur;
}(), function() {
    "use strict";
    function fdjt_focusin(evt) {
        var scan = fdjtUI.T(evt), add = [];
        if ("TEXTAREA" === scan.tagName || "INPUT" === scan.tagName && /text|email/i.exec(scan.type)) {
            for (;scan; ) {
                var classname = scan.className;
                classname && "string" == typeof classname && classname.search(/\bfdjtfoci\b/) >= 0 && 0 > classname.search(/\bfdjtfocus\b/) && add.push(scan), 
                scan = scan.parentNode;
            }
            add.length && setTimeout(function() {
                for (var i = 0; add.length > i; ) {
                    var elt = add[i++], classname = elt.className;
                    elt.className = classname + " fdjtfocus";
                }
            }, 300);
        }
    }
    function fdjt_focusout(evt) {
        var scan = fdjtUI.T(evt), drop = [];
        if ("TEXTAREA" === scan.tagName || "INPUT" === scan.tagName && /text|email/i.exec(scan.type)) {
            for (;scan; ) {
                var classname = scan.className;
                classname && "string" == typeof classname && classname.search(/\bfdjtfocus\b/) >= 0 && drop.push(scan), 
                scan = scan.parentNode;
            }
            drop.length && setTimeout(function() {
                for (var i = 0; drop.length > i; ) {
                    var elt = drop[i++], classname = elt.className;
                    elt.className = classname.replace(/ fdjtfocus\b/, "");
                }
            }, 300);
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, addListener = fdjtDOM.addListener;
    fdjtUI.focusin = fdjt_focusin, addListener(window, "focusin", fdjt_focusin), fdjtUI.focusout = fdjt_focusout, 
    addListener(window, "focusout", fdjt_focusout);
}(), function() {
    "use strict";
    function multitext_keypress(evt, sepchars, sepexp, fn) {
        evt = evt || event;
        var chcode = evt.charCode, ch = String.fromCharCode(chcode), target = fdjtUI.T(evt);
        if (sepchars instanceof RegExp ? (sepexp = sepchars, sepchars = !1) : sepchars && sepchars.call && (fn = sepchars, 
        sepchars = !1), !sepchars && target.getAttribute("data-sepchars") && (sepchars = target.getAttribute("data-sepchars")), 
        13 === chcode && isEmpty(target.value) && hasClass(target, "fdjtentersubmit")) return fdjt.UI.cancel(evt), 
        target.form.submit(), void 0;
        if (13 === chcode || sepchars && sepchars.indexOf(ch) >= 0) {
            !sepexp && target.getAttribute("data-separator") && (sepexp = RegExp(target.getAttribute("data-separator"), "g"));
            for (var checkspec = target.getAttribute("data-checkspec") || "div.checkspan", values = sepexp ? target.value.split(sepexp) : [ target.value ], i = 0, lim = values.length; lim > i; ) {
                var value = values[i++];
                if (fn) fdjtDOM(target.parentNode, "\n", fn(target.name, value)); else {
                    var checkbox = fdjtDOM.Input("[type='checkbox']", target.name, value), checkelt = fdjtDOM(checkspec, checkbox, value);
                    checkbox.checked = !0, fdjtDOM.addClass(checkelt, "ischecked"), fdjtDOM(target.parentNode, "\n", checkelt);
                }
            }
            fdjtUI.cancel(evt), target.value = "";
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtString = fdjt.String, isEmpty = fdjtString.isEmpty, hasClass = fdjtDOM.hasClass;
    fdjtUI.MultiText.keypress = multitext_keypress;
}(), function() {
    "use strict";
    function tab_onclick(evt, shownclass) {
        var elt = fdjtUI.T(evt);
        if (shownclass || (shownclass = fdjtDOM.findAttrib(elt, "shownclass", "http://fdjt.org/") || "fdjtshown"), 
        elt) {
            for (var content_id = !1; elt.parentNode && !(content_id = fdjtDOM.getAttrib(elt, "contentid")); ) elt = elt.parentNode;
            if (!content_id) return;
            var content = document.getElementById(content_id), parent = fdjtDOM.getParent(elt, ".tabs") || elt.parentNode, sibs = fdjtDOM.getChildren(parent, ".tab") || parent.childNodes;
            if (null === content) return fdjtLog("No content for " + content_id), void 0;
            for (var i = 0; sibs.length > i; ) {
                var cid, node = sibs[i++];
                if (1 === node.nodeType && (cid = fdjtDOM.getAttrib(node, "contentid"))) {
                    if (!cid) continue;
                    var cdoc = document.getElementById(cid);
                    node === elt || hasClass(node, shownclass) && (dropClass(node, shownclass), cdoc && dropClass(cdoc, shownclass));
                }
            }
            hasClass(elt, shownclass) ? (dropClass(elt, shownclass), dropClass(content, shownclass)) : (addClass(elt, shownclass), 
            addClass(content, shownclass));
            var tabstate = fdjtDOM.findAttrib(elt, "tabstate");
            if (tabstate) if ("#" === tabstate) {
                var scrollstate = {};
                fdjtUI.scrollSave(scrollstate), document.location.hash = tabstate + content_id, 
                fdjtUI.scrollRestore(scrollstate);
            } else fdjtState.setCookie(tabstate, content_id); else ;
            return !1;
        }
    }
    function select_tab(tabbar, contentid, shownclass) {
        shownclass || (shownclass = fdjtDOM.findAttrib(tabbar, "shownclass", "http://fdjt.org/") || "fdjtshown");
        for (var tabseen = !1, tabs = fdjtDOM.getChildren(tabbar, ".tab"), i = 0; tabs.length > i; ) {
            var tab = tabs[i++];
            if (tab.getAttribute("contentid") === contentid) addClass(tab, shownclass), tabseen = !0; else if (hasClass(tab, shownclass)) {
                dropClass(tab, shownclass);
                var cid = fdjtDOM.getAttrib(tab, "contentid"), content = cid && fdjtID(cid);
                content ? dropClass(content, shownclass) : fdjtLog.warn("No reference for tab content %o", cid);
            } else dropClass(tab, shownclass);
        }
        fdjtID(contentid) ? tabseen ? addClass(contentid, shownclass) : fdjtLog.warn("a tab for %s was not found in %o", contentid, tabbar) : fdjtLog.warn("No reference for tab content %o", contentid);
    }
    function setupTabs(elt) {
        if (elt ? "string" == typeof elt && (elt = fdjtID(elt)) : elt = fdjtDOM.$(".tabs[tabstate]"), 
        elt && elt.getAttribute("tabstate")) {
            var tabstate = elt.getAttribute("tabstate"), content_id = !1;
            if ("#" === tabstate) {
                content_id = document.location.hash, "#" === content_id[0] && (content_id = content_id.slice(1));
                var content = content_id && fdjtID(content_id);
                if (!content) return;
                var ss = {};
                fdjtUI.scrollSave(ss), window.scrollTo(0, 0), fdjtDOM.isVisible(content) || fdjtUI.scrollRestore(ss);
            } else content_id = fdjtState.getQuery(tabstate) || fdjtState.getCookie(tabstate);
            content_id && ("#" === content_id[0] && (content_id = content_id.slice(1)), content_id && select_tab(elt, content_id));
        }
    }
    function selected_tab(tabbar) {
        for (var tabs = fdjtDOM.getChildren(tabbar, ".tab"), i = 0; tabs.length > i; ) {
            var tab = tabs[i++];
            if (hasClass(tab, "shown")) return tab.getAttribute("contentid");
        }
        return !1;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtState = fdjt.State, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass;
    fdjtUI.Tabs.click = tab_onclick, fdjtUI.Tabs.selectTab = select_tab, fdjtUI.Tabs.setup = setupTabs, 
    fdjtUI.Tabs.getSelected = selected_tab;
}(), function() {
    "use strict";
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjtUI.Expansion.toggle = function(evt, spec, exspec) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), wrapper = fdjtDOM.getParent(target, spec || ".fdjtexpands");
        wrapper && fdjtDOM.toggleClass(wrapper, exspec || "fdjtexpanded");
    }, fdjtUI.Expansion.onclick = fdjtUI.Expansion.toggle, fdjtUI.Collapsible.click = function(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if (!fdjtUI.isDefaultClickable(target)) {
            var wrapper = fdjtDOM.getParent(target, ".collapsible");
            wrapper && (fdjtUI.cancel(evt), fdjtDOM.toggleClass(wrapper, "expanded"));
        }
    }, fdjtUI.Collapsible.focus = function(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), wrapper = fdjtDOM.getParent(target, ".collapsible");
        wrapper && fdjtDOM.toggleClass(wrapper, "expanded");
    }, fdjtUI.toggleParent = function(evt, spec, classname) {
        var target = fdjtUI.T(evt), parent = fdjtDOM.getParent(target, spec);
        parent && fdjtDOM.toggleClass(parent, classname);
    };
}(), function() {
    "use strict";
    function scroll_discard(ss) {
        ss ? (ss.scrollX = !1, ss.scrollY = !1) : saved_scroll = !1;
    }
    function scroll_save(ss) {
        ss ? (ss.scrollX = window.scrollX, ss.scrollY = window.scrollY) : (saved_scroll || (saved_scroll = {}), 
        saved_scroll.scrollX = window.scrollX, saved_scroll.scrollY = window.scrollY);
    }
    function scroll_into_view(elt, topedge) {
        if (0 === topedge || topedge || !fdjtDOM.isVisible(elt)) if (use_native_scroll && elt.scrollIntoView) {
            if (elt.scrollIntoView(topedge), 0 !== topedge && !topedge && fdjtDOM.isVisible(elt, !0)) return;
        } else {
            for (var top = elt.offsetTop, left = elt.offsetLeft, height = elt.offsetHeight; elt.offsetParent; ) elt = elt.offsetParent, 
            top += elt.offsetTop, left += elt.offsetLeft;
            var y, vh = fdjtDOM.viewHeight(), x = 0, y_target = top + height / 3;
            y = vh / 2 - 50 > 2 * (height / 3) ? y_target - vh / 2 : vh - 100 > height ? top - (50 + height / 2) : top - 50, 
            window.scrollTo(x, y);
        }
    }
    function scroll_preview(target, context, delta) {
        return target ? (target !== preview_elt && (saved_scroll || scroll_save(), "number" == typeof target ? window.scrollTo("number" == typeof context && context || 0, target) : scroll_into_view(target, delta), 
        preview_elt = target), void 0) : (stop_preview(), void 0);
    }
    function scroll_restore(ss) {
        return preview_elt && (preview_elt = !1), ss && "number" == typeof ss.scrollX ? (window.scrollTo(ss.scrollX, ss.scrollY), 
        !0) : !saved_scroll || "number" != typeof saved_scroll.scrollY && "number" != typeof saved_scroll.scrollX ? !1 : (window.scrollTo(saved_scroll.scrollX, saved_scroll.scrollY), 
        saved_scroll = !1, !0);
    }
    function stop_preview() {
        fdjtDOM.dropClass(document.body, "preview"), preview_elt && preview_elt.className && fdjtDOM.dropClass(preview_elt, "previewing"), 
        preview_elt = !1;
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, saved_scroll = !1, use_native_scroll = !1, preview_elt = !1;
    fdjtUI.scrollTo = function(target, id, context, discard, topedge) {
        scroll_discard(discard), id && (document.location.hash = id), context ? setTimeout(function() {
            scroll_into_view(context, topedge), fdjtDOM.isVisible(target) || scroll_into_view(target, topedge);
        }, 100) : setTimeout(function() {
            scroll_into_view(target, topedge);
        }, 100);
    }, fdjtUI.scrollSave = scroll_save, fdjtUI.scrollRestore = scroll_restore, fdjtUI.scrollIntoView = scroll_into_view, 
    fdjtUI.scrollPreview = scroll_preview, fdjtUI.scrollRestore = scroll_restore;
}(), function() {
    "use strict";
    function smartScroll(win, off, content) {
        if (content === void 0 && (content = win), 0 >= off) return win.scrollTop = 0, void 0;
        var block = findBreak(content, off, content);
        if (!block) return win.scrollTop = off, void 0;
        var geom = getGeometry(block, content || win);
        win.scrollTop = win.offsetTop / 4 > geom - top - off ? geom.top : off;
    }
    function findBreak(node, off, container) {
        var style = getStyle(node), display = style.display;
        if ("block" === display || "table-row" === display || "list-item" === display || "preformatted" === display) {
            var geom = getGeometry(node, container);
            if (geom.top > off) return node;
            if (geom.bottom > off) {
                if ("avoid" === style.pageBreakInside) return node;
                for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                    var child = children[i++], bk = 1 === child.nodeType && findBreak(child, off, container);
                    if (bk) return bk;
                }
                return node;
            }
            return !1;
        }
        return !1;
    }
    var fdjtDOM = fdjt.DOM, getGeometry = fdjtDOM.getGeometry, getStyle = fdjtDOM.getStyle;
    fdjt.UI.smartScroll = smartScroll;
}(), function() {
    "use strict";
    fdjt.UI.Delay = function(interval, name, fcn) {
        setTimeout(fcn, interval);
    }, fdjt.UI.Delayed = function(fcn, interval) {
        interval || (interval = 25), setTimeout(fcn, interval);
    };
}(), function() {
    "use strict";
    function dosubmit(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), form = fdjtDOM.getParent(target, "FORM"), submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent("submit", !1, !0), form.dispatchEvent(submit_event), form.submit();
    }
    function forceSubmit(form) {
        var submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent("submit", !1, !0), form.dispatchEvent(submit_event);
    }
    function submitOnEnter(evt) {
        evt = evt || window.event;
        var kc = evt.keyCode || evt.charCode;
        if (13 === kc) {
            var target = fdjtUI.T(evt), form = fdjtDOM.getParent(target, "FORM");
            fdjtUI.cancel(evt), form.submit();
        }
    }
    function checkFileInputs(evt) {
        evt = evt || window.event;
        for (var form = fdjtUI.T(evt), file_inputs = fdjtDOM.getInputs(form, !1, "file"), i = 0, lim = file_inputs.length; lim > i; ) {
            var input = file_inputs[i++];
            input.value && "" !== input.value || (fdjtUI.cancel(evt), (fdjt.UI.alert || window.alert)("You need to specify a file!"));
        }
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjtUI.dosubmit = dosubmit, fdjtUI.forceSubmit = forceSubmit, fdjtUI.submitOnEnter = submitOnEnter, 
    fdjtUI.checkFileInputs = checkFileInputs;
}(), function() {
    "use strict";
    function checkOverflow(node) {
        var geom = getGeometry(node), inside = getInsideBounds(node);
        inside.bottom > geom.bottom ? addClass(node, "overflow") : dropClass(node, "overflow");
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getGeometry = fdjtDOM.getGeometry, getInsideBounds = fdjtDOM.getInsideBounds;
    fdjtUI.Overflow = checkOverflow;
}(), function() {
    "use strict";
    function setXY(x, y) {
        vreticle && (vreticle.style.left = x + "px"), hreticle && (hreticle.style.top = y + "px");
    }
    function setupReticle() {
        vreticle || (vreticle = fdjtDOM("div.reticle.vertical#VRETICLE", " "), fdjtDOM.prepend(document.body, vreticle)), 
        hreticle || (hreticle = fdjtDOM("div.reticle.horizontal#HRETICLE", " "), fdjtDOM.prepend(document.body, hreticle)), 
        fdjtDOM.addListener(document, "mousemove", mousemove), fdjtDOM.addListener(document, "click", doflash), 
        fdjtUI.Reticle.live = !0;
    }
    function doflash() {
        flash();
    }
    function mousemove(evt, x, y) {
        setXY(x || evt.clientX, y || evt.clientY);
    }
    function highlight(flag) {
        flag === void 0 && (flag = !highlighted), flag ? (vreticle && fdjtDOM.addClass(vreticle, "highlight"), 
        hreticle && fdjtDOM.addClass(hreticle, "highlight"), highlighted = !0) : (vreticle && fdjtDOM.dropClass(vreticle, "highlight"), 
        hreticle && fdjtDOM.dropClass(hreticle, "highlight"), highlighted = !1);
    }
    function flash(howlong) {
        howlong === void 0 && (howlong = 1500), highlighted || (highlight(!0), setTimeout(function() {
            highlight(!1);
        }, howlong));
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, vreticle = !1, hreticle = !1, highlighted = !1;
    fdjtUI.Reticle.setup = setupReticle, fdjtUI.Reticle.highlight = highlight, fdjtUI.Reticle.flash = flash, 
    fdjtUI.Reticle.onmousemove = mousemove, fdjtUI.Reticle.setXY = setXY, fdjtUI.Reticle.live = !1;
}(), function() {
    "use strict";
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjtUI.uploadSpecified = function(evt) {
        evt = evt || window.event;
        var parent = fdjtDOM.getParent(fdjtUI.T(evt), ".fileuploader");
        parent && fdjtDOM.addClass(parent, "inuse");
    };
}(), function() {
    "use strict";
    function ImageSwap(img, interval) {
        if ("string" == typeof img && (img = fdjtID(img)), !img) return !1;
        interval || (interval = img.getAttribute("data-interval") ? parseInt(img.getAttribute("data-interval"), 10) : ImageSwap.interval), 
        img.getAttribute("data-images") || img.setAttribute("data-images", img.src), img.defaultsrc || (img.defaultsrc = img.src);
        var images = img.getAttribute("data-images").split("|");
        if (0 === images.length) return !1;
        var counter = 0;
        return setInterval(function() {
            img.src === images[counter] ? counter++ : img.src = images[counter++], counter >= images.length && (counter = 0);
        }, interval);
    }
    var fdjtUI = fdjt.UI, fdjtID = fdjt.ID;
    ImageSwap.reset = function(img) {
        img.defaultsrc && (img.src = img.defaultsrc);
    }, ImageSwap.interval = 1e3, fdjtUI.ImageSwap = ImageSwap;
}(), function() {
    "use strict";
    function submitEvent(arg) {
        for (var form = arg.nodeType ? arg : fdjtUI.T(arg); form && "FORM" !== form.tagName; ) form = form.parentNode;
        if (form) {
            var submit_evt = document.createEvent("HTMLEvents");
            submit_evt.initEvent("submit", !0, !0), form.dispatchEvent(submit_evt);
        }
    }
    function focusEvent(arg) {
        var elt = arg.nodeType ? arg : fdjtUI.T(arg), focus_evt = document.createEvent("HTMLEvents");
        focus_evt.initEvent("focus", !0, !0), elt.dispatchEvent(focus_evt);
    }
    function disableForm(form) {
        if ("string" == typeof form && (form = fdjtID(form)), form) for (var elements = fdjtDOM.getChildren(form, "button,input,optgroup,option,select,textarea"), i = 0, lim = elements.length; lim > i; ) elements[i++].disabled = !0;
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, hasClass = fdjtDOM.hasClass;
    fdjtUI.T = function(evt) {
        return evt = evt || window.event, evt.target || evt.srcElement;
    }, fdjtUI.noDefault = function(evt) {
        return evt = evt || window.event, evt.preventDefault ? evt.preventDefault() : evt.returnValue = !1, 
        !1;
    }, fdjtUI.cancelBubble = fdjtUI.noBubble = function(evt) {
        evt = evt || window.event, evt.stopPropagation ? evt.stopPropagation() : evt.canceBubble = !0;
    }, fdjtUI.cancel = function(evt) {
        return evt = evt || window.event, evt.preventDefault ? evt.preventDefault() : evt.returnValue = !1, 
        evt.stopPropagation ? evt.stopPropagation() : evt.cancelBubble = !0, !1;
    }, fdjtUI.isClickable = function(target) {
        for (window.Event && target instanceof window.Event && (target = fdjtUI.T(target)); target; ) {
            if ("A" === target.tagName && target.href || "INPUT" === target.tagName || "BUTTON" === target.tagName || "TEXTAREA" === target.tagName || "SELECT" === target.tagName || "OPTION" === target.tagName || hasClass(target, "checkspan") || hasClass(target, "clickable") || hasClass(target, "isclickable")) return !0;
            if (target.onclick) return !0;
            target = target.parentNode;
        }
        return !1;
    }, fdjtUI.isDefaultClickable = function(target) {
        for (window.Event && target instanceof window.Event && (target = fdjtUI.T(target)); target; ) {
            if ("A" === target.tagName && target.href || "INPUT" === target.tagName || "TEXTAREA" === target.tagName || "SELECT" === target.tagName || "OPTION" === target.tagName || hasClass(target, "isclickable")) return !0;
            target = target.parentNode;
        }
        return !1;
    }, fdjtUI.submitEvent = submitEvent, fdjtUI.focusEvent = focusEvent, fdjtUI.disableForm = disableForm;
}(), function() {
    "use strict";
    function Ellipsis(spec, string, lim, thresh, handler) {
        var content = ellipsize(string, lim, thresh || .2), split = "string" != typeof content, len = string.length;
        if (handler || (handler = toggle), "string" == typeof content && content.length === len) return spec ? fdjtDOM(spec, string) : document.createTextNode(string);
        var before = split ? content[0] : content, after = split ? content[1] : "", clen = before.length + after.length, pct = Math.round(100 * clen / len);
        spec && addClass(elt, "ellipsis");
        var remaining = split ? string.slice(before.length, len - after.length) : string.slice(before.length), elided = fdjtDOM("span.elided", remaining), elision = fdjtDOM("span.elision", fdjtString("%d%% more", 100 - pct)), delision = fdjtDOM("span.delision", fdjtString("hide %d%%", 100 - pct));
        elision.title = "show elided text", delision.title = "hide elided text", elision.onclick = handler, 
        delision.onclick = handler;
        var elt = fdjtDOM(spec || "span.ellipsis", before, " ", elision, delision, elided, " ", after);
        return spec && addClass(elt, "ellipsis"), elt.title = fdjtString.stdspace(string), 
        elt;
    }
    function expand(node) {
        "string" == typeof node && (node = fdjtID(node));
        var ellipsis = getParent(node, ".ellipsis");
        addClass(ellipsis, "expanded"), dropClass(ellipsis, "compact");
    }
    function contract(node) {
        "string" == typeof node && (node = fdjtID(node));
        var ellipsis = getParent(node, ".ellipsis");
        addClass(ellipsis, "compact"), dropClass(ellipsis, "expanded");
    }
    function toggle(arg) {
        var evt = !1;
        if (arg) "string" == typeof arg ? arg = fdjtID(arg) : arg.nodeType || (evt = arg, 
        arg = fdjtUI.T(arg)); else {
            if (evt = window.event || !1, !evt) return;
            arg = fdjtUI.T(evt);
        }
        var ellipsis = getParent(arg, ".ellipsis");
        ellipsis && (evt && fdjtUI.cancel(evt), hasClass(ellipsis, "expanded") ? (addClass(ellipsis, "compact"), 
        dropClass(ellipsis, "expanded")) : (addClass(ellipsis, "expanded"), dropClass(ellipsis, "compact")));
    }
    var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, ellipsize = fdjtString.ellipsize, getParent = fdjtDOM.getParent, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass;
    fdjtUI.Ellipsis = Ellipsis, Ellipsis.expand = expand, Ellipsis.contract = contract, 
    Ellipsis.toggle = toggle;
}(), function() {
    "use strict";
    function selectSubmit(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        if ("" !== target.value) {
            var form = fdjtDOM.getParent(target, "FORM");
            form && form.submit();
        }
    }
    function setupSelectSubmit() {
        for (var setup = fdjtDOM.$(".fdjtselectsubmit"), i = 0, lim = setup.length; lim > i; ) fdjtDOM.addListener(setup[i++], "change", selectSubmit);
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI;
    fdjt.addInit(setupSelectSubmit, "selectsubmit");
}(), function() {
    "use strict";
    function updatePasswordVisibility(evt, input, visible) {
        if (evt = evt || window.event, "string" == typeof input && (input = document.getElementById(input)), 
        input) {
            var target = fdjtUI.T(evt);
            input.type = visible ? target.checked ? "PASSWORD" : "TEXT" : target.checked ? "TEXT" : "PASSWORD", 
            setTimeout(function() {
                input.focus();
            }, 1e3);
        }
    }
    function uploadSelected(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), tbody = fdjtDOM.getParent(target, ".upload");
        tbody && fdjtDOM.addClass(tbody, "uploading");
    }
    function focusBox_onfocus(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), box = getParent(target, ".focusbox");
        box && addClass(box, "focused");
    }
    function focusBox_onblur(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), box = getParent(target, ".focusbox");
        box && setTimeout(function() {
            dropClass(box, "focused");
        }, 200);
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, getParent = fdjtDOM.getParent, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass;
    fdjtUI.updatePasswordVisibility = updatePasswordVisibility, fdjtUI.uploadSelected = uploadSelected, 
    fdjtUI.FocusBox.focus = focusBox_onfocus, fdjtUI.FocusBox.blur = focusBox_onblur;
}(), function() {
    "use strict";
    function fixTimeElement(elt) {
        var tstring = elt.getAttribute("datetime") || elt.getAttribute("data-datetime") || elt.getAttribute("data-time"), parsed = tstring && new Date(tstring), good = parsed && "nogood" !== (parsed.getYear() || "nogood");
        tstring || (tstring = elt.innerText, parsed = new Date(tstring), good = parsed && "nogood" !== (parsed.getYear() || "nogood"), 
        good && ("TIME" === elt.tagName ? elt.setAttribute("datetime", tstring) : elt.setAttribute("data-datetime", tstring))), 
        good && (elt.title || (elt.title = parsed.toGMTString()), hasClass(elt, "fdjtkeeptext") || (hasClass(elt, "fdjtisotime") ? parsed.toISOString && (elt.innerHTML = parsed.toISOString()) : hasClass(elt, "fdjtutctime") ? parsed.toUTCString && (elt.innerHTML = parsed.toUTCString()) : hasClass(elt, "fdjtdate") ? parsed.toDateString && (elt.innerHTML = parsed.toDateString()) : hasClass(elt, "fdjtdateortime") ? parsed.toDateString && parsed.toTimeString && (elt.innerHTML = parsed.toDateString() === new Date().toDateString ? parsed.toTimeString() : parsed.toDateString()) : hasClass(elt, "fdjtlocaletime") ? parsed.toLocaleString && (elt.innerHTML = parsed.toLocaleString()) : hasClass(elt, "fdjtlocaledate") ? parsed.toLocaleDate && (elt.innerHTML = parsed.toLocaleDate()) : hasClass(elt, "fdjtlocaledateortime") ? (parsed.toLocaleDateString && parsed.toTimeString && (elt.innerHTML = parsed.toDateString() === new Date().toDateString ? parsed.toLocaleTimeString() : parsed.toLocaleDateString()), 
        parsed.toLocaleDate && (elt.innerHTML = parsed.toLocaleDate())) : elt.innerHTML = hasClass(elt, "fdjthumantime") ? parsed.toDateString && parsed.toLocaleTimeString ? parsed.toDateString() + " (" + parsed.toLocaleTimeString() + ")" : parsed.toLocaleString ? parsed.toLocaleString() : "" + parsed : parsed.toDateString && parsed.toLocaleTimeString ? parsed.toDateString() + " (" + parsed.toLocaleTimeString() + ")" : parsed.toLocaleString ? parsed.toLocaleString() : "" + parsed));
    }
    function initTimeElements(node) {
        for (var elts = node ? fdjt.keeptime ? fdjtDOM.getChildren(node, ".fdjtime") : fdjtDOM.getChildren(node, "time,.fdjtime") : fdjt.keeptime ? fdjtDOM.$(".fdjtime") : fdjtDOM.$("time,.fdjtime"), i = 0, lim = elts.length; lim > i; ) fixTimeElement(elts[i++]);
    }
    var fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, hasClass = fdjtDOM.hasClass;
    fdjt.initTimeElements = initTimeElements, fdjt.autoInitTimeElements = function() {
        fdjtDOM.addListener(document.body, "DOMNodeInserted", function(evt) {
            evt = evt || window.event, initTimeElements(fdjtUI.T(evt));
        });
    }, fdjt.addInit(initTimeElements, "TimeElements", !1);
}(), function() {
    "use strict";
    var vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
    fdjt.UI.vibrate = function(args) {
        return vibrate ? (vibrate(args), !0) : !1;
    };
}(), fdjt.disenableInputs = fdjt.UI.disenableInputs = function() {
    "use strict";
    function disenableInputs(under) {
        for (var inputs = $("input,select,button,textarea", under), i = 0, lim = inputs.length; lim > i; ) {
            var input = inputs[i++];
            if (!hasClass(input, "fdjtignore")) {
                for (var scan = input, disable = !1; scan && scan !== under; ) {
                    var style = getStyle(scan);
                    if ("none" === style.display) {
                        disable = !0;
                        break;
                    }
                    scan = scan.parentNode;
                }
                input.disabled = disable;
            }
        }
    }
    var fdjtDOM = fdjt.DOM, getStyle = fdjtDOM.getStyle, hasClass = fdjtDOM.hasClass, $ = fdjtDOM.$;
    return disenableInputs;
}(), fdjt.showPage = fdjt.UI.showPage = function() {
    "use strict";
    function getContainer(arg) {
        var container;
        return container = "string" == typeof arg ? document.getElementById(arg) : arg.nodeType ? arg : fdjt.UI.T(arg) ? fdjt.UI.T(arg) : !1, 
        container ? container = fdjtDOM.getParent(container, ".fdjtpage") || container : fdjtLog.warn("Bad showPage container arg %s", arg), 
        container;
    }
    function istootall(container, height, padding) {
        return height || (height = container.offsetHeight), padding ? container.scrollHeight > height - padding : container.scrollHeight > height;
    }
    function isOversize(elt, w, h) {
        return w === void 0 && (w = !0), h === void 0 && (h = !0), h && elt.scrollHeight > elt.offsetHeight || w && elt.scrollWidth > elt.offsetWidth;
    }
    function showPage(container, start, dir) {
        if (container = getContainer(container)) {
            dir = "number" != typeof dir ? 1 : 0 > dir ? -1 : 1;
            var startpos, h, shown = toArray(getChildren(container, ".fdjtshow")), curstart = getChild(container, ".fdjtstartofpage"), curend = getChild(container, ".fdjtendofpage"), info = getChild(container, ".fdjtpageinfo"), children = getNodes(container), lim = children.length, caboose = 0 > dir ? "fdjtstartofpage" : "fdjtendofpage", padding = getGeometry(container, !1, !0).bottom_padding, tap_event_name = fdjt.device.touch ? "touchstart" : "click";
            if (0 !== children.length && (start ? "number" == typeof start && start > 0 && 1 > start ? (startpos = Math.round(start * children.length), 
            start = children[startpos]) : "number" == typeof start ? (startpos = start - 1, 
            start = children[startpos]) : start.nodeType && (start = getPageElt(container, start), 
            startpos = children.indexOf(start)) : (startpos = 0, start = children[0]), !(!start || 0 > startpos || startpos >= lim || 0 === startpos && 0 > dir))) {
                if (addClass(container, "fdjtpage"), h = container.offsetHeight, addClass(container, "formatting"), 
                info || (info = getProgressIndicator(container, startpos, lim)), shown.length && (dropClass(shown, "fdjtshow"), 
                dropClass(shown, "fdjtoversize")), curstart && dropClass(curstart, "fdjtstartofpage"), 
                curend && dropClass(curend, "fdjtendofpage"), addClass(start, "fdjtshow"), addClass(start, 0 > dir ? "fdjtendofpage" : "fdjtstartofpage"), 
                start.offsetHeight > h && addClass(start, "fdjtoversize"), 0 > dir && hasClass(start, /fdjtpagebreak(auto)?/) || istootall(container, h, padding)) return dropClass(container, "formatting"), 
                startpos;
                var endpos = showchildren(container, children, startpos, dir, h, padding), end = children[endpos];
                if (dir > 0 && hasClass(end, "fdjtpagehead")) for (;endpos > startpos && hasClass(end, "fdjtpagehead"); ) dropClass(end, "fdjtshow"), 
                dropClass(end, caboose), endpos--, end = children[endpos], addClass(end, caboose);
                if (dir > 0 && hasClass(end, "fdjtpagekeep")) for (;startpos > endpos && hasClass(end, "fdjtpagekeep"); ) dropClass(end, "fdjtshow"), 
                dropClass(end, caboose), endpos++, end = children[endpos], addClass(end, caboose);
                var at_start = !1, at_end = !1;
                if (0 === startpos ? (addClass(container, "fdjtfirstpage"), at_start = !0) : dropClass(container, "fdjtfirstpage"), 
                endpos >= lim - 1 ? (addClass(container, "fdjtlastpage"), at_end = !0) : dropClass(container, "fdjtlastpage"), 
                0 > dir && 0 === endpos) return dropClass(container, "formatting"), showPage(container, 0, 1);
                var minpos = endpos >= startpos ? startpos : endpos, maxpos = startpos > endpos ? startpos : endpos, countdom = fdjtDOM("span.count", fdjtDOM("strong", "/"), lim), txtdom = fdjtDOM("span.value", Math.floor(100 * (minpos / lim))), pctdom = fdjtDOM("span.pct", txtdom, "%", countdom), forward_button = fdjtDOM("span.button.forward", " "), backward_button = fdjtDOM("span.button.backward", " ");
                return info.innerHTML = "", fdjtDOM.append(info, backward_button, pctdom, forward_button), 
                info.title = fdjtString("Items %d through %d of %d", minpos, maxpos, lim), txtdom.setAttribute("contentEditable", "true"), 
                addListener(txtdom, "blur", pageInputBlur), addListener(txtdom, "keyup", cancelBubble), 
                addListener(txtdom, "keypress", cancelBubble), addListener(txtdom, "keydown", pageInputKeydown), 
                addListener(pctdom, tap_event_name, pageInputTapped), at_start ? backward_button.innerHTML = " " : addListener(backward_button, tap_event_name, backwardButton), 
                at_end ? forward_button.innerHTML = " " : addListener(forward_button, tap_event_name, forwardButton), 
                addClass(container, "fdjtpagechange"), setTimeout(function() {
                    dropClass(container, "fdjtpagechange");
                }, 1e3), dropClass(container, "formatting"), endpos;
            }
        }
    }
    function pageInputKeydown(evt) {
        var target = fdjtUI.T(evt), container = getParent(target, ".fdjtpage");
        if (container) {
            var kc = evt.keyCode;
            if (target._savedHTML || (target._savedHTML = target.innerHTML), 13 === kc) {
                try {
                    var s = fdjtDOM.textify(target), pct = parseFloat(s) / 100;
                    "number" != typeof pct || Number.isNaN(pct) ? (target.innerHTML = target._savedHTML, 
                    target._savedHTML = !1) : showPage(container, pct, 1), target.blur();
                } catch (ex) {
                    target._savedHTML && (target.innerHTML = target._savedHTML, target._savedHTML = !1), 
                    target.blur();
                }
                cancel(evt);
            } else 27 === kc && (target._savedHTML && (target.innerHTML = target._savedHTML, 
            target._savedHTML = !1), target.blur(), cancel(evt));
        }
    }
    function pageInputBlur(evt) {
        var target = fdjtUI.T(evt), info = getParent(target, ".fdjtpageinfo");
        info && dropClass(info, "fdjteditpageinfo"), target._savedHTML && (target.innerHTML = target._savedHTML, 
        target._savedHTML = !1);
    }
    function pageInputTapped(evt) {
        var target = fdjtUI.T(evt), input = fdjtDOM.getChild(target, "span.value"), info = getParent(target, ".fdjtpageinfo");
        info && addClass(info, "fdjteditpageinfo"), input && input.focus();
        var selection = window.getSelection && window.getSelection();
        if (selection && selection.anchorNode && getParent(selection.anchorNode, input)) {
            var anchor = selection.anchorNode;
            3 === anchor.nodeType && selection.extend(anchor, anchor.nodeValue.length);
        }
        cancel(evt);
    }
    function forwardButton(evt) {
        fdjt.UI.cancel(evt), forwardPage(evt);
    }
    function backwardButton(evt) {
        fdjt.UI.cancel(evt), backwardPage(evt);
    }
    function getProgressIndicator(container, startpos, lim) {
        var info = fdjtDOM("div.fdjtpageinfo", startpos + 1, "/", lim);
        return container.appendChild(info), info;
    }
    function getPageElt(container, node) {
        for (var scan = node, parent = scan.parentNode; parent && parent !== container; ) scan = parent, 
        parent = scan.parentNode;
        return parent === container ? scan : !1;
    }
    function getNodes(container) {
        var children = [], nodes = container.childNodes;
        addClass(container, "getvisible");
        for (var i = 0, lim = nodes.length, prev = !1; lim > i; ) {
            var node = nodes[i++];
            if (1 === node.nodeType) {
                var style = getStyle(node);
                if ("none" === style.display) continue;
                if (style.position && "static" !== style.position) continue;
                "always" === style.pageBreakBefore ? addClass(node, "fdjtpagebreakauto") : dropClass(node, "fdjtpagebreakauto"), 
                prev && hasClass(prev, "fdjtpagekeep") && addClass(node, "fdjtpagekeep"), prev && hasClass(node, "fdjtpagekeep") && addClass(prev, "fdjtpagehead"), 
                children.push(node);
            }
        }
        return dropClass(container, "getvisible"), children;
    }
    function showchildren(container, children, i, dir, h, padding) {
        var lim = children.length, scan = children[i + dir], last = children[i], caboose = 0 > dir ? "fdjtstartofpage" : "fdjtendofpage";
        for (i += dir, addClass(last, caboose); i >= 0 && lim > i; ) {
            if (dir > 0 && hasClass(scan, /fdjtpagebreak(auto)?/)) return i - dir;
            if (dropClass(last, caboose), addClass(scan, "fdjtshow"), addClass(scan, caboose), 
            scan.offsetHeight > h && addClass(scan, "fdjtoversize"), istootall(container, h, padding)) return addClass(last, caboose), 
            dropClass(scan, "fdjtshow"), scan.style.display = "", dropClass(scan, caboose), 
            i - dir;
            if (0 > dir && hasClass(scan, /fdjtpagebreak(auto)?/)) return i;
            i += dir, last = scan, scan = children[i];
        }
        return i - dir;
    }
    function checkOversize(scan) {
        var saved = scan.style.overflow || "";
        scan.style.overflow = "auto", isOversize(scan) && (addClass(scan, "fdjtoversize"), 
        isOversize(scan) && adjustFonts(scan)), scan.style.overflow = saved;
    }
    function forwardPage(container) {
        if (container = getContainer(container)) {
            dropClass(container, "fdjtpagechange");
            var foot = getChild(container, ".fdjtendofpage");
            return foot ? hasClass(container, "fdjtlastpage") ? !1 : foot.nextSibling ? showPage(container, foot.nextSibling) : !1 : showPage(container);
        }
    }
    function fastForwardPage(container) {
        if (container = getContainer(container)) {
            var foot = getChild(container, ".fdjtendofpage");
            if (!foot) return showPage(container);
            if (hasClass(container, "fdjtlastpage")) return !1;
            if (foot.nextSibling) {
                var children = getNodes(container), off = children.indexOf(foot), len = children.length, next_off = Math.floor(off + (len - off) / 2);
                return showPage(container, children[next_off], 1);
            }
            return !1;
        }
    }
    function backwardPage(container) {
        if (container = getContainer(container)) {
            dropClass(container, "fdjtpagechange");
            var head = getChild(container, ".fdjtstartofpage");
            return head ? hasClass(container, "fdjtfirstpage") ? !1 : head.previousSibling ? showPage(container, head.previousSibling, -1) : !1 : showPage(container);
        }
    }
    function fastBackwardPage(container) {
        if (container = getContainer(container)) {
            var head = getChild(container, ".fdjtstartofpage");
            if (!head) return showPage(container);
            if (hasClass(container, "fdjtfirstpage")) return !1;
            if (head.previousSibling) {
                var children = getNodes(container), off = children.indexOf(head), next_off = Math.floor(off / 2);
                return showPage(container, children[next_off], -1);
            }
            return !1;
        }
    }
    function updatePage(container) {
        if (container = getContainer(container)) {
            var head = getChild(container, ".fdjtstartofpage");
            if (head.hidden) {
                for (var scan = head; scan; ) if (1 !== scan.nodeType) scan = scan.nextSibling; else {
                    if (!scan.hidden) return showPage(container, scan);
                    scan = scan.nextSibling;
                }
                showPage(container);
            } else showPage(container, head);
        }
    }
    function checkPage(container) {
        if (container = getContainer(container)) if (hasClass(container, "fdjtpage")) {
            if (!container.offsetHeight || !hasClass(container, "needsresize")) return;
            dropClass(container, "needsresize"), updatePage(container);
        } else container.offsetHeight && showPage(container);
    }
    function showNode(container, node) {
        if (container = getContainer(container)) {
            if (!hasClass(container, "fdjtpage")) {
                if (!container.offsetHeight) return !1;
                showPage(container);
            }
            for (var parent = node.parentNode; parent && parent !== container; ) node = parent, 
            parent = node.parentNode;
            return parent ? hasClass(node, "fdjtshown") ? !1 : showPage(container, node) : void 0;
        }
    }
    var fdjtUI = fdjt.UI, fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtString = fdjt.String, getStyle = fdjtDOM.getStyle, getChild = fdjtDOM.getChild, getChildren = fdjtDOM.getChildren, dropClass = fdjtDOM.dropClass, addClass = fdjtDOM.addClass, hasClass = fdjtDOM.hasClass, addListener = fdjtDOM.addListener, toArray = fdjtDOM.toArray, getGeometry = fdjtDOM.getGeometry, getParent = fdjtDOM.getParent, cancelBubble = fdjtUI.cancelBubble, cancel = fdjtUI.cancel, adjustFonts = fdjtDOM.adjustFonts;
    return showPage.isOversize = isOversize, showPage.checkOversize = checkOversize, 
    showPage.forward = forwardPage, showPage.fastForward = fastForwardPage, showPage.backward = backwardPage, 
    showPage.fastBackward = fastBackwardPage, showPage.update = updatePage, showPage.check = checkPage, 
    showPage.showNode = showNode, showPage;
}(), fdjt.Dialog = function() {
    "use strict";
    function Dialog(spec) {
        spec ? "string" == typeof spec && (spec = {
            spec: spec
        }) : spec = {};
        var box = fdjtDOM(spec.spec || "div.fdjtdialog");
        if (spec.classes && (box.className = (box.className || "") + (box.className ? " " : "") + spec.classes), 
        spec.style && box.setAttribute("style", spec.style), !(spec.modal || spec.keep || hasClass(box, "fdjtmodal") || hasClass(box, "fdjtkeep"))) {
            var countdown = fdjtDOM("div.countdown", "Closing");
            countdown.id = "FDJTCOUNTDOWN" + countdown_serial++, box.appendChild(countdown);
        }
        if (!(spec.modal || spec.noclose || hasClass(box, "fdjtmodal"))) {
            var close_button = fdjtDOM.Image(redx_png, "closebutton", "Close");
            addListener(close_button, "click", close_dialog_handler), addListener(close_button, "touchend", close_dialog_handler), 
            addListener(close_button, "touchstart", fdjtUI.cancel), close_button.title = "click to close", 
            box.appendChild(close_button);
        }
        if (spec.title) if (spec.title.nodeType) elts.push(spec.title); else {
            var title_text = template(spec.title, spec, spec.data);
            box.title = title_text, box.appendChild(fdjtDOM("div.title", title_text));
        }
        for (var content, elts = [], i = 1, lim = arguments.length, wrap = !0; lim > i; ) {
            var e = arguments[i++];
            if (e.nodeType) {
                wrap = !1;
                break;
            }
            if ("string" == typeof e && e.indexOf("<") >= 0) {
                wrap = !1;
                break;
            }
        }
        for (wrap ? (content = fdjtDOM("P"), box.appendChild(content)) : content = box, 
        i = 1; lim > i; ) {
            var arg = arguments[i++];
            if (arg) if (arg.nodeType) content.appendChild(arg); else if ("string" == typeof arg) {
                arg = Templates[arg] || arg;
                var ishtml = arg.indexOf("<") >= 0, istemplate = arg.search("{{") >= 0;
                ishtml && istemplate ? content.appendChild(Template.toDOM(arg, spec)) : ishtml ? fdjtDOM.append(content, arg) : istemplate ? content.appendChild(document.createTextNode(template(arg, spec))) : content.appendChild(document.createTextNode(arg));
            } else content.appendChild(document.createTextNode(arg.toString)); else ;
        }
        return spec.id && !box.id && (box.id = spec.id), fdjtDOM.addListeners(box, spec), 
        box;
    }
    function remove_dialog(evt) {
        evt = evt || window.event;
        var target = evt ? evt.nodeType ? evt : fdjtUI.T(evt) : fdjtID("FDJTALERT") || fdjtID("FDJTDIALOG"), box = fdjtDOM.getParent(target, ".fdjtdialog");
        if (box) {
            var countdown = fdjtDOM.getChild(box, ".countdown");
            if (countdown && countdown.id) {
                var ticker = countdown_tickers[countdown.id];
                ticker && clearInterval(ticker), delete countdown_tickers[countdown.id];
            }
            clear_countdown(box), fdjtDOM.remove(box);
        }
    }
    function close_dialog(evt, fast) {
        evt = evt || window.event;
        var target = evt ? evt.nodeType ? evt : fdjtUI.T(evt) : fdjtID("FDJTALERT") || fdjtID("FDJTDIALOG");
        evt && !evt.nodeType && fdjtUI.cancel(evt);
        var box = fdjtDOM.getParent(target, ".fdjtdialog");
        box && (clear_countdown(box), fast ? fdjtDOM.remove(box) : fdjtDOM.transitionEnd && !fdjtDOM.hasClass(box, "closing") ? (fdjtDOM.addListener(box, fdjtDOM.transitionEnd, function() {
            fdjtDOM.remove(box);
        }), fdjtDOM.addClass(box, "closing")) : fdjtDOM.remove(box));
    }
    function clear_countdown(box) {
        var countdown = fdjtDOM.getChild(box, ".countdown");
        if (countdown) {
            var ticker = countdown_tickers[countdown.id];
            delete countdown_tickers[countdown.id], ticker && clearInterval(ticker);
        }
    }
    function close_dialog_handler(evt) {
        evt = evt || window.event, fdjtUI.cancel(evt), close_dialog(evt);
    }
    function stop_countdown_onclick(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), box = fdjtDOM.getParent(target, ".fdjtdialog");
        clear_countdown(box), box.style[fdjtDOM.transitionDelay] = "", box.style[fdjtDOM.transitionDuration] = "", 
        fdjtDOM.dropClass(box, "countdown"), fdjtDOM.dropClass(box, "closing"), fdjtUI.cancel(evt);
    }
    function alertBox() {
        var args = fdjtDOM.toArray(arguments), box = Dialog.apply(null, [ {} ].concat(args));
        addClass(box, "fdjtalert");
    }
    function alertfn() {
        var curbox = fdjtID("FDJTALERT");
        curbox && (curbox.id = "", fdjtDOM.dropClass(curbox, "closing"), remove_dialog(curbox));
        var args = fdjtDOM.toArray(arguments), box = Dialog.apply(null, [ {} ].concat(args));
        return box.id = "FDJTALERT", fdjtDOM.prepend(document.body, box), box;
    }
    function setCountdown(box, timeout, whendone) {
        var countdown = fdjtDOM.getChild(box, ".countdown");
        countdown.innerHTML = "" + timeout + "";
        var n = timeout;
        box.style[fdjtDOM.transitionDelay] = n / 2 + "s", box.style[fdjtDOM.transitionDuration] = n / 2 + "s";
        var ticker = setInterval(function() {
            0 >= n ? (clearInterval(ticker), ticker = !1, delete countdown_tickers[countdown.id], 
            whendone && whendone(), fdjtDOM.remove(box)) : countdown.innerHTML = "" + n-- + "";
        }, 1e3);
        return countdown_tickers[countdown.id] = ticker, countdown.onclick = stop_countdown_onclick, 
        addListener(countdown, "touchend", stop_countdown_onclick), addListener(countdown, "touchstart", fdjtUI.cancel), 
        setTimeout(function() {
            fdjtDOM.addClass(box, "closing");
        }, 10), box;
    }
    function alertFor(timeout) {
        var curbox = fdjtID("FDJTALERT");
        curbox && (curbox.id = "", fdjtDOM.dropClass(curbox, "closing"), remove_dialog(curbox));
        var args = [ {
            timeout: timeout
        } ].concat(fdjtDOM.slice(arguments, 1)), box = Dialog.apply(null, args);
        return box.id = "FDJTALERT", fdjtDOM.prepend(document.body, box), setCountdown(box, timeout), 
        box;
    }
    function message(spec) {
        var curbox = fdjtID("FDJTMESSAGE");
        curbox && (curbox.id = "", fdjtDOM.dropClass(curbox, "closing"), remove_dialog(curbox));
        var args = fdjtDOM.toArray(arguments), box = Dialog.apply(null, args);
        return spec.timeout && setCountdown(box, spec.timeout), box.id = "FDJTMESSAGE", 
        fdjtDOM.prepend(document.body, box), box;
    }
    function makeChoice(spec, close_choice, i) {
        var dom = spec.dom;
        return dom || (dom = fdjtDOM("button"), spec.label.nodeType ? dom.appendChild(spec.label.cloneNode(!0)) : dom.innerHTML = spec.label ? spec.label : "Choice " + i), 
        spec.name && (dom.name = spec.name), spec.value && (dom.value = spec.value), dom.onmousedown = fdjtUI.cancel, 
        dom.onmouseup = fdjtUI.cancel, dom.tabIndex = i, spec.title && (dom.title = spec.title), 
        spec.classname && addClass(dom, spec.classname), dom.onclick = function(evt) {
            evt = evt || window.event;
            var target = fdjtUI.T(evt), choices = fdjtDOM.getParent(target, ".choices"), cursel = fdjtDOM.getChild(choices, ".selected");
            cursel === dom || (cursel && (fdjtDOM.dropClass(cursel, "selected"), cursel.blur()), 
            fdjtDOM.addClass(dom, "selected"), dom.focus()), spec.handler && spec.handler(), 
            fdjtUI.cancel(evt), close_choice();
        }, addListener(dom, "touchstart", fdjtUI.cancel), addListener(dom, "touchend", dom.onclick), 
        dom;
    }
    function choose(spec) {
        function close_choice() {
            for (var i = 0, lim = buttons.length; lim > i; ) {
                var button = buttons[i++];
                button.onclick && removeListener(button, "touchend", button.onclick), removeListener(button, "touchstart", fdjtUI.cancel), 
                button.onclick = null, button.onmousedown = null, button.onmouseup = null;
            }
            if (close_button && (removeListener(close_button, "touchend", close_button.onclick), 
            removeListener(close_button, "touchstart", fdjtUI.cancel), close_button.onclick = null), 
            box && (box.onclick = null), box && (box.onkeydown = null), box) var timeout = setTimeout(function() {
                spec.onclose && spec.onclose(box), remove_dialog(box), clearTimeout(timeout), timeout = !1;
            }, 500);
        }
        var choices, box = !1, selection = -1, buttons = [], close_button = !1, onchoose = !1;
        if ("function" == typeof spec) choices = [ {
            label: "Cancel"
        }, {
            label: "OK",
            handler: spec,
            isdefault: !0
        } ]; else if (spec.constructor === Array) choices = spec; else if (spec.choices) choices = spec.choices; else if (spec.label && spec.handler) choices = [ {
            label: "Cancel"
        }, spec ]; else if (spec.handler) choices = [ {
            label: "Cancel"
        }, {
            label: "OK",
            handler: spec.handler,
            isdefault: spec.isdefault
        } ]; else {
            if (!choices.length) return fdjtLog.warn("Bad spec %o to fdjtUI.choose"), void 0;
            choices = spec;
        }
        spec.onchoose && (onchoose = spec.onchoose);
        for (var i = 0, lim = choices.length; lim > i; ) {
            var choice = choices[i], button = makeChoice(choice, close_choice, i);
            buttons.push(button), 0 > selection && choice.isdefault && (button.setAttribute("autofocus", "autofocus"), 
            fdjtDOM.addClass(button, "selected"), selection = i), i++;
        }
        0 > selection && !spec.nodefault && (fdjtDOM.addClass(buttons[i], "selected"), selection = 0), 
        box = makeDialog(spec, fdjtDOM("div.message", fdjtDOM.slice(arguments, 1)), fdjtDOM("div.choices", buttons)), 
        close_button = fdjtDOM.getChild(box, ".closebutton"), spec.cancel ? (removeListener(close_button, "touchend", close_button.onclick), 
        close_button.onclick = close_choice, addListener(close_button, "touchend", close_button.onclick)) : fdjtDOM.remove(close_button);
        var cancel = spec.cancel || !1;
        return box.onkeydown = function(evt) {
            evt = evt || window.event;
            var kc = evt.keyCode;
            9 === kc ? (evt.shiftKey ? selection-- : selection++, 0 > selection ? selection = buttons.length - 1 : selection >= buttons.length && (selection = 0), 
            selection >= 0 && buttons[selection].focus(), fdjtUI.cancel(evt)) : 13 === kc ? (selection >= 0 && choices[selection] && choices[selection].handler && choices[selection].handler(), 
            onchoose && selection >= 0 && choices[selection] && onchoose(choices[selection], box), 
            close_choice(), fdjtUI.cancel(evt)) : cancel && 27 === kc && (close_choice(), fdjtUI.cancel(evt));
        }, fdjtDOM.addClass(box, "fdjtconfirm"), box.id = "FDJTDIALOG", fdjtDOM.prepend(document.body, box), 
        spec.timeout && setCountdown(box, spec.timeout, function() {
            return spec.noauto ? (close_choice(), void 0) : (selection >= 0 && choices[selection] && choices[selection].handler && choices[selection].handler(), 
            onchoose && selection >= 0 && choices[selection] && onchoose(choices[selection], box), 
            void 0);
        }), selection >= 0 && buttons[selection].focus(), box;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, fdjtID = fdjt.ID, Template = fdjt.Template, template = fdjt.Template, Templates = fdjt.Templates, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, addListener = fdjtDOM.addListener, removeListener = fdjtDOM.removeListener, countdown_serial = 1, countdown_tickers = {}, redx_png = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyEAYAAAE5qGRkAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAASAAAAEgARslrPgAAEXpJREFUeNrdXGl4VEW6fqv3bCT0SQjhVADpCggMuywiUTbZAoRNFlkER8SZwUdnrtuMy+idcUZFwHEYERdAkR1kcxRkXwVBWYSw5DSE5DQQyOmsnd677o9Ah5vcvt2ns3Cf+/7Jw6n63u99vzpL1anTALeh5NH2rNPGKQgBe6f0NhmW+D8HDygLxRKmG3JQUShljHPlEjWzjmszgwGt6Xi2Mfb5YLuTprM2xU2rGS20NWudNSPYIV+0sfYrtwX/XUgtLK304VCKoNhpf7ZoohIMUGgy6+QvqdlPEwy4JE5kIwwzwCHhg7VmuOCHt3IjABOcmkQlIJayQZ+uqc7wmliZodO/FMxQSpuyLg570EJb0cnaTj4bbK+k/ZjlozHVBCW0NUt33heyqhm0M5s1fR2iBbmT+s4BQZBlSSIkqKBGe8iGmqhJhJqBoQhUZ1DtIXrU1K6coxms5dq+Ecd/Tw+xdxNoqBoETzXSE4/xE1m7gpHN4YRh4uFgYDEdwB5buS9IvE7cw9bGvRwk7IHJ+LSsIBgfByCmeGmtItdSuI9qWVr2RHRCGuI2rw1ryQ0/tKUJQgv5unQxqaJmsyZUHPk1/4ov3fFJxLUvBkX++t2hmquv0s30T2ypccGdUvAfyYvkWWdisKcfgLdiU/D0aY9byJi88K5SX4f4VK+7Lspx7LGP+9QqXa3TygsvnI7rQnO5ULLFtwhnyN6eWlj6tKf5IbhhXLHkzvFaV47SXcxkC0yeiEsVAsp+ms7EL14JOrE/Rxey38VM4m9gPnZUBm9cIa/dUMQ1K2FCIZKWyiTqm0Qo4hqI+m4U8b1FraJwqCkkauuRljLsINZ1jBrfQYONQYOdRQ19HWjg5meQMC5JLXHYfn744Sv1Visppc0YHWeLtvZBnmtUYOnloYUpbUW3ZWPMu7UeuaU0kbH14R9M9QTlFn2Z2ROSaumwiXb2q+WtavYnxUnp/dhU4/aAlefhmGtopIlIKlqhybonzT75sPTzpGV1FW5/QpTZo3F/5gtIH1ypeDPiQC8CSF72QHBo7DqabKkcfoQXwkQ6f/ugaiU6JCF9tSwkymelvY+nhxX+Cn3QsjbuU/4iCsirFU+pzueFBw57QGgu35SuC9qQ55id0Cw2O+sEL8Jp7P2mh+pEJ1CB/JVDhKFyieSZtlOZKPZik2Pfw2JyDSccL6rm8yMOvOSk0Ey+KFmbdq/ZHPnz+JxYxjQj3WhOOqDNNoNqIWqhgw6a0m5CopwnXUo6Fa57xEZqGZMos+RnT0JTuMjAzWui5QlCCx08ZR8ISXKelJ/4e7XhGrUBwQr8k8fh4R11ntIFkQc3+Mb2UeuJtKN9NBUsM01JfBliyCFncRS53Lf/GiMSxtAB2s+mmIvl76WLs8OOeOhH6As03rLKmIY/Iom84bqmWrYHDjgrDglpcrFkS8hUXDSWJTxWCQfMSF0Xo5aOiEhD/CfHzC75uHRqTp9a7UHhs8T5ll+M/fE+WUjGuvaqFk7ghc+RKZjlQikv/lC47koubcs0kz+DGZVos/rXqtM1hxEtF6ebvbJV2vNbmSgBmsj0oy6iGAlotbVtxEw+EAQqVwupcoF0Oe5x1cZrGjsmVlicU4aDkftJp1XfRhzohgvashu1Ti27nvZjxrFX+Q3kIf3rlnc1VYBXrhcEuUSyxk2sq/Cwxs6JlZaC6WY0J23JgC+VYIMWfpCyDUKSfF3KTXwsPNFZamDp32YrT9IKy1/19Xd3UmuomGayfvu2FS1JT2Vm7dnIA/OpkTXZtq/mZM3+gVjIsoz3N5oBP23DHtxTPWksoiJjvMw+TJzHSnQna/avfnlxlqaz9ltLEIcUNBv5SM2OfDrpgYuuc8okOs1y1nClwQyU0p5M3J2KEnhwa0D1bZ6AAEjgq8g/0NPbXHlafN+yQHfXKwU97cS6bJ3Fb6AYjlFLI8wXINuQiymGs+aZcoz0F2+XOhsopqlswC6GAPQoGJQbNoAAILjFd6EQTt1TGp6HEngHd1aZV8NHIQOrPZ2VvmI3yzDd36I2cI22Yxm7ScQG7oAD4EjRrATh53vs1AiiXCDlxP4eWujgrjyjWsk2cotYvS/a19KW7Gl9XqRh9kTagXXe2QxGOMAHBlTnLebf8w/7fG7eInusCT86g9eIkCTnSQVxXWBADAKVR1WRcuj4YHDs9TS3d6GnLJ8b0kKOgI1msAe2/5tfRhkqBxeq1U/m4iHM6btMYLYO1hHHguuY0FOUCtqSdXBmwY0APKZvVJji4KjkbszjX+r1yaL8uPUhn0G5KLrZwO1bkUwsyB86SrWBf0CD9L7Pmv9Tzpf2/rCoVns4AqWStmAZrmw4oQE3blaZ3wcXbuLajn/BhGZoMfQ51QY6Ygw/+WCh+Ya8yJpwtHnIfpESKvk0hbV0jkccjDCYNqgVpBpOCLje7zWByqclx+G3wxpWy69cpxaW7uwEA9wwmtTfHMIJSuX56Jc53+yzaaTlh16IOC7ahEohbc/SXDHQoRxxxso6O4jDRBQ+vEowyQuk8oNTVRegrvmVIprOMnglCDg41K8z2oFC0/8Jc5F8VLq0/8todUS91FUCopdptr4RrYE74BchI7DvoyIvPWiZpmJSWLMgqg2U0kQmbvbBhwTEZGujTVzbEQiAHNIaE3gr/QxzhbzQutv3U70bURTahrHNBIAHyFb/JI5cEQFwiozFy6jQlZv3y3OlG/6Hw4eFM1BERZaxSQYBAR8jqhamBaD1OuEH4NerOQU5gIKAggS+Vdsvpa18wdohkB+qc8hrRLlCzUzY9ETUBq7xDXzXoHZCkixLFw2x0MAPv6dIBQMBkK4RUEFG+88Xj0nvn0E0IU+1WkaUG5SxzhtGogli0XTMctUGfuGn+f5HM4VOtj7W1nsu3TksNJWvS1eMKVVvED3DVLLGBj7nVm7xe+zvpP+c8bP2vf/JdZWBC5Qx8/plSIEL5gkzVRvI5+f5yiGPCt1sCdbeO3eF664U03TW2pOKADh0+hsR56lSvAk+tMcx3fNCM3mnJPjzieKnqazH+hMogR6lE9S/rNbwFWj56LtCU9sAac+uVyINu73ppLGX0RYsw7sVPmjAdVmqchP8wPPJ25q+GosGpdDBNWqPagMBaKAb2k2tgaCGqsoGzE3ka1KufhT80MHvtasi4XhQ0y3QM3DroV537wKKjDlzARDAxEIKuI8fR96wcnOZLU3y7WiiugChNFWNkN5eRluyDM9M+BAA14f+suIAjDznkSbCWNlqNRwor15YCbJNkmIyoIUGenft23I+v4KYEdn1bSBYoKqMXnMTOV/KNayAHxx+b611ELkfduj6f3fHQFhixU5bsDbuJfZYGmspHN67voWHw+0RMiiltAVr55ulHBZzLe5H/qPOxEqWuM2SHdNDuUqTWNI3e2ttUp6nSSxlw0dKX3ED0xm2Nrbxxoa9Ge3FlsavV/xUZJ32dr/r/RtljDsVq1jKWi3Pt38tGtjjulcj5Q05Qyly0YEsNmYRuYpfkLJuPpJhhH7k5YgVO8DRct1xbIAdy6b3FP4gO6VWnjqvGu4VFCudxwYmDEQLfIHA5g6oRAnkgf8MG8jBAdih5QVgy+JwCB3Jiae/EUbZzucW+SbU7F69OX2A7mErTJd5L8zF4nUmOFCGm6PSwiaMDAFcRTKwrgOZgz8iZvp483F5kvSLJ+rXeg0NZR59yzIufi1mYjfZu2UWNLgMYaCjzsRV70evIwAnYpaW4gG+ma+Y01nIs2Vau/i8RHHRrsy8djUcKIJ54uRG8svRBCa0WjeevM1nkwtT3zC/aXs51+br1kj5a0Fx089Yq9jRcOFN+Lbq4AMQM2hjoyQnKEM5NCj/sEv19KRYPMpaDfsRnIyA9utnwBELTUzEy8w6guMS9Ehccw2P8I04M+M5wWPrLnm9DVYQew79OEMb14vH4RPedcsVxOMmSgfdbCS/VV/Eeoqfwg3+C982bLbQ3ZZs7fJjn9CfoTShyZb8EWO4DIH0WT8NXjgQGzu+EaQSEHgQgzS0X92bvISH8NbMMvMieaHUzRP5M6wGlNz0zmxI3HtoyhOR9/UKEFxBYEi9v1sMCSMI4ounws838/dGXBUSbT2sQ44erm0+Qtg70ydY5xG7+CHshmPDFngBkJgPG8EKAYEbF3CTn1k5E1MwDG/N6irky1us73hDroCUt0UTK49ri6kkBVkbX0ACOK4Nnd0IequQAB90JSnkBbREnxHLzB/KP0rLfwi7/xD1rMeeQnuzzKyZ/CpsKNx4DU4AAeOOBjdaNWtx4iA0KF+5lN8ibnhn/otYeQ9+Td8V07GdtNv8M9IgQj/kQoPruQM/YuErPUpa4LfQDEs1++TnpctH26ilqbdpqFJITYxkWeFDIlpt2AAT9NCZXmq0gjQ2tDBAX/odLuBB/smIdUIfeaU188jyutI22LpA+VosYv1GX0Rv0ha2tYNgQiy0poK6M98jGEDAS0rhB/ipUR2EJLnAmnBI/VdfYdBoCzXlNBUtzux3kAo9saypgB4+xJr+0lj5VYPDiECpFev5OXQceVX4jc0kbTs0qKHT3rOVs3KFTrV4sx9BDI6R7uuSoIcLTsPme6UHOmjgLH+eNMdD/HTWEbNTXm1NPni8sWVEvW9YV5Cdgfn85PZxiIcV5p2NN/sJBRuKkbJxBucYzHceabz1SM26NFYi+0DxRcsrpoP8W/IBWbw2Bw6kImX00/fKeBjcwAU0hWbpFvIGfIHtc54z75bPX27jc9ed+n9Hwz3UC2gM6206BAMEONachA6AK3tuQxuqd1RtlJ+GCW1Q+tkm8lfM40t+87n5HbmXdZxPru909Tft9dBVLMY4Gm78DYlrUuFBCeLHRP6b1/rDndtNswZhJ+AAzpEWcCD1s0Vwk3gMfuaAmRfI0lv+nLrTRwllmbiJ7TMMxxAyBS+sc8OEZJRk746WTzXccMHjeB05PAf2UT+RoaQb7hd685sAilcxAAREr/qroihRiTIkwPvpV9oZOI7Jz7yUdFCOl94NlKolivzTkzzahWUas6HHTUirJsAELeLGTWskw4AfZSivmA4X/4pvGLNWaGkbbc3c7Q3V3W4Uyy0lE228kGSQ7isWwA8dNIb3G0ntJSShIyxL3OQK6U6Sf/eqmRX8PXelf1u4wNDflL5H/826GOdhIl5F4leDkYAiXJvQtZEMAQEE4K44jjOo4CfHPS0MksusyTtPRUtnN9OHWedJhTwHeXB8+Tr0CIAYlkTLpwIEBLuQgPvAPj5GWuEosuaeM1+XPdJc/+rane8IXiXmsIcMa3gv0gu2lQKaIgm6CYMbQXAVNHDB6yhGCT+M1mPThfts7aT9O+u+IVQDd74TKU6lTZlhSn9+CXFo88Vr8APw6Qc0uM+qin+LJkhB18Wz8Hd8QqbMfV94Xe6ZOz4wgyiXaDv2q5VzIMAB1+OL/1tYQ8IFDfzOM0jhhxGbPVAw2NKlczuVuhOrw+0BIvYfRCvTTy5DRzIArb/qX/W5iPZEI8mwIYAHoFswuHqDKoca2JgxfdEMAnLWcBBoETAeqbeUfnD4KkXSjBeAjGtnhk0jXdmh/od0DYzgFURodxY/tTkvgR3isoXwwwe/vv5+RuZBJVA2DN/wlfCNrBRm24ZLeQcPhn6GVNLxzDx2KVz4CUmrOoDDB40p8s9onAhA63BgNd/OD0yYLbxo62xN3b464vj/I7g9QCa7m2otFdNdKEUa6fL5M9ABIPrFkRPBDWepA6eQyn8YPV8YLJ+1tjzw55rdIt+gEmhbNmHsJZ4LJ06vvlL1gxDjkGAHLfTwOkcilm/FzfHjBYOtk+T87sl7XdD6xu0BMtpt4hXLkWlOGElfMmXZYGighV5XPe2vhBeB8q44z3NgH7VBGGITpJL9GQ0mTLlFm7DYcX+yC/QPlpzhYf8LhP+v4IEe3Xt0h95uoZls2rRnlSPiQcupR6Iu/H8B7AjpZA9bJIMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMTItMzFUMTI6NDQ6NTYtMDU6MDBEL5TZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTEyLTMxVDEyOjQ0OjU2LTA1OjAwNXIsZQAAADh0RVh0c3ZnOmJhc2UtdXJpAGZpbGU6Ly8vc3JjL2dyYXBoaWNzL3RhcmdldHMvZmRqdC9yZWR4LnN2Z3qXB16JAAAAAElFTkSuQmCC", makeDialog = Dialog;
    return Dialog.close = close_dialog, Dialog.alertBox = alertBox, fdjtUI.alertBox = alertBox, 
    Dialog.alert = alertfn, fdjtUI.alert = alertfn, fdjt.alert = alertfn, Dialog.setCountdown = setCountdown, 
    fdjtUI.setCountdown = setCountdown, Dialog.alertFor = alertFor, fdjtUI.alertFor = alertFor, 
    Dialog.message = message, fdjt.message = message, Dialog.Choice = choose, Dialog.choose = choose, 
    fdjtUI.choose = choose, fdjt.Choice = choose, fdjt.UI.Dialog = Dialog, Dialog;
}(), fdjt.UI || (fdjt.UI = {}), function() {
    "use strict";
    function Completions(dom, input, options) {
        return this.dom = dom || !1, this.input = input || !1, this.options = options || default_options, 
        this.nodes = [], this.values = [], this.serial = ++serial, this.cues = [], this.displayed = [], 
        this.known = {}, this.prefixtree = {
            strings: []
        }, this.bykey = {}, this.byvalue = new ValueMap(), this.selected = !1, this.selclass = !1, 
        options & FDJT_COMPLETE_MATCHCASE || (this.stringmap = {}), this.initialized = !1, 
        this;
    }
    function getKey(node) {
        return node.key || node.getAttribute("data-key") || node.getAttribute("key") || hasClass(node, "variation") && fdjtDOM.textify(node) || hasClass(node, "completion") && completionText(node, "");
    }
    function completionText(node, sofar) {
        if (3 === node.nodeType) return sofar + node.nodeValue;
        if (hasClass(node, "variation")) return sofar;
        if (hasClass(node, "fdjtskiptext")) return sofar;
        if (1 === node.nodeType && node.childNodes) {
            for (var children = node.childNodes, i = 0, lim = children.length; lim > i; ) {
                var child = children[i++];
                3 === child.nodeType ? sofar += child.nodeValue : 1 === child.nodeType && (sofar = completionText(child, sofar));
            }
            return sofar;
        }
        return sofar;
    }
    function addNodeKey(node, keystring, ptree, bykey, anywhere) {
        for (var keys = (anywhere ? keystring.split(/\W/g) : []).concat(keystring), i = 0, lim = keys.length; lim > i; ) {
            var key = keys[i++];
            prefixAdd(ptree, key, 0), bykey[key] && bykey.hasOwnProperty(key) ? bykey[key].push(node) : bykey[key] = Array(node), 
            bykey._count++;
        }
    }
    function getNodes(string, ptree, bykey, matchcase) {
        var result = [], direct = [], variations = [], keystring = stdspace(string);
        if (isEmpty(keystring)) return [];
        matchcase || (keystring = string.toLowerCase());
        for (var strings = prefixFind(ptree, keystring, 0), prefix = !1, exact = [], exactheads = [], keys = [], i = 0, lim = strings.length; lim > i; ) {
            var s = strings[i++], isexact = s === keystring;
            prefix = prefix ? commonPrefix(prefix, s, !1, !matchcase) : s;
            var completions = bykey[s];
            if (completions) for (var j = 0, jlim = completions.length; jlim > j; ) {
                var c = completions[j++];
                if (hasClass(c, "hidden")) ; else if (result.indexOf(c) >= 0) ; else if (hasClass(c, "completion")) isexact && (exactheads.push(c), 
                exact.push(c)), result.push(c), keys.push(s), direct.push(c); else {
                    var head = getParent(c, ".completion");
                    head && hasClass(head, "hidden") || head && (isexact && exact.push(head), result.push(head), 
                    keys.push(s), variations.push(c));
                }
            }
        }
        return exact.length && (result.exact = exact), exactheads.length && (result.exactheads = exactheads), 
        result.prefix = prefix, result.strings = strings, result.matches = direct.concat(variations), 
        result;
    }
    function addCompletion(c, completion, key, value) {
        key === void 0 && (key = completion.key || getKey(completion)), value || (value = completion.value || completion.getAttribute("value") || key), 
        completion._seen || (c.nodes.push(completion), completion._seen = !0, value && (c.values.push(value), 
        c.byvalue.add(value, completion)), c.curstring = c.maxstring = !1, key && addCompletionKeys(c, completion, key));
    }
    function addCompletionKeys(c, completion, key) {
        key || (key = completion.key || getKey(completion));
        var lower, opts = c.options, container = c.dom, ptree = c.prefixtree, bykey = c.bykey, smap = c.stringmap, stdkey = stdspace(key), matchcase = opts & FDJT_COMPLETE_MATCHCASE, anyword = opts & FDJT_COMPLETE_ANYWORD;
        matchcase || (lower = stdkey.toLowerCase(), smap[lower] = stdkey, stdkey = lower), 
        getParent(completion, container) || fdjtDOM.append(container, completion, " "), 
        addNodeKey(completion, stdkey, ptree, bykey, anyword), hasClass(completion, "cue") && c.cues.push(completion);
        for (var variations = getChildren(completion, ".variation"), i = 0, lim = variations.length; lim > i; ) {
            var variation = variations[i++], vkey = stdspace(variation.key || getKey(variation));
            matchcase || (lower = vkey.toLowerCase(), smap[lower] = vkey, vkey = lower), addNodeKey(variation, vkey, ptree, bykey, anyword);
        }
    }
    function initCompletions(c) {
        for (var completions = getChildren(c.dom, ".completion"), i = 0, lim = completions.length; lim > i; ) addCompletion(c, completions[i++]);
        c.initialized = !0;
    }
    function updateDisplay(c, todisplay) {
        var i, lim, displayed = c.displayed;
        if (displayed) {
            for (i = 0, lim = displayed.length; lim > i; ) dropClass(displayed[i++], "displayed");
            c.displayed = displayed = [];
        } else c.displayed = displayed = [];
        if (todisplay) for (i = 0, lim = todisplay.length; lim > i; ) {
            var node = todisplay[i++];
            if (hasClass(node, "completion")) addClass(node, "displayed"), displayed.push(node); else {
                var head = getParent(node, ".completion");
                head && !hasClass(head, "displayed") && (displayed.push(node), displayed.push(head), 
                addClass(head, "displayed"), addClass(node, "displayed"));
            }
        }
        c.visible = !1, c.selection && !hasClass(c.selection, "displayed") && (c.selectNext() || c.selectPrevious() || c.clearSelection()), 
        c.updated && c.updated.call(c);
    }
    function stdspace(string) {
        return string.replace(/\s+/, " ").replace(/(^\s)|(\s$)/, "");
    }
    function gatherVisible(root) {
        for (var scan = root.firstChild, displayed = []; scan !== root; ) {
            if (1 === scan.nodeType) {
                var iscompletion = hasClass(scan, "completion");
                if (iscompletion && "none" !== getStyle(scan).display && displayed.push(scan), scan.firstChild && !iscompletion) {
                    scan = scan.firstChild;
                    continue;
                }
            }
            for (;scan !== root && !scan.nextSibling; ) scan = scan.parentNode;
            scan !== root && (scan = scan.nextSibling);
        }
        return displayed;
    }
    function onkey(evt) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt), name = target.name, completions = cached_completions[name], compid = fdjtDOM.getAttrib(target, "completions"), dom = compid && fdjtID(compid);
        dom && (completions && completions.dom === dom || (completions = new Completions(dom, target, default_options), 
        cached_completions[name] = completions), completions && completions.docomplete(target));
    }
    function update(evt) {
        if (evt = evt || window.event, "string" == typeof evt && (evt = fdjtID(evt)), evt) {
            var target = evt.nodeType ? evt : fdjtUI.T(evt), name = target.name, completions = cached_completions[name], compid = fdjtDOM.getAttrib(target, "completions"), dom = compid && fdjtID(compid);
            dom && (completions && completions.dom === dom || (completions = new Completions(dom, target, default_options), 
            cached_completions[name] = completions), completions && completions.docomplete(target));
        }
    }
    var fdjtString = fdjt.String, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, RefDB = fdjt.RefDB, fdjtID = fdjt.ID, rAF = fdjtDOM.requestAnimationFrame, async = fdjt.async, serial = 0, FDJT_COMPLETE_OPTIONS = 1, FDJT_COMPLETE_CLOUD = 2, FDJT_COMPLETE_ANYWORD = 4, FDJT_COMPLETE_MATCHCASE = 8, FDJT_COMPLETE_EAGER = 16, default_options = FDJT_COMPLETE_OPTIONS | FDJT_COMPLETE_CLOUD | FDJT_COMPLETE_ANYWORD, complete_delay = 100, hasClass = fdjtDOM.hasClass, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, getChildren = fdjtDOM.getChildren, getParent = fdjtDOM.getParent, getStyle = fdjtDOM.getStyle, position = RefDB.position, isEmpty = fdjtString.isEmpty, hasPrefix = fdjtString.hasPrefix, prefixAdd = fdjtString.prefixAdd, prefixFind = fdjtString.prefixFind, commonPrefix = fdjtString.commonPrefix;
    fdjtUI.FDJT_COMPLETE_OPTIONS = FDJT_COMPLETE_OPTIONS, fdjtUI.FDJT_COMPLETE_CLOUD = FDJT_COMPLETE_CLOUD, 
    fdjtUI.FDJT_COMPLETE_ANYWORD = FDJT_COMPLETE_ANYWORD, fdjtUI.FDJT_COMPLETE_MATCHCASE = FDJT_COMPLETE_MATCHCASE, 
    fdjtUI.FDJT_COMPLETE_EAGER = FDJT_COMPLETE_EAGER;
    var ValueMap = fdjt.Map || RefDB.Map;
    Completions.getKey = getKey, Completions.prototype.addCompletion = function(completion, key, value) {
        this.initialized || initCompletions(this), addCompletion(this, completion, key, value), 
        this.visible && (this.visible = !1);
    }, Completions.prototype.addKeys = function(completion, key) {
        this.initialized ? addCompletionKeys(this, completion, key) : (initCompletions(this), 
        addCompletion(this, completion, key)), this.visible && (this.visible = !1);
    }, Completions.prototype.getCompletions = function(string) {
        if (string === this.curstring || string === this.maxstring || this.curstring && this.maxstring && hasPrefix(string, this.curstring) && hasPrefix(this.maxstring, string)) return this.result;
        var result, that = this;
        if (this.initialized || initCompletions(this), isEmpty(string) ? (result = [], result.prefix = "", 
        result.matches = [], this.dom && addClass(this.dom, "noinput")) : (result = getNodes(string, this.prefixtree, this.bykey, this.options & FDJT_COMPLETE_MATCHCASE), 
        this.dom && dropClass(this.dom, "noinput"), rAF(function() {
            updateDisplay(that, result.matches);
        })), this.stringmap && this.strings) for (var stringmap = this.stringmap, strings = this.strings, i = 0, lim = strings.length; lim > i; ) {
            var s = strings[i], m = stringmap[s];
            m ? strings[i++] = m : i++;
        }
        return this.curstring = string, this.maxstring = result.prefix || string, this.result = result, 
        result;
    }, Completions.prototype.getValue = function(completion) {
        if (completion.value) return completion.value;
        if (completion.getAttribute("data-value")) return completion.getAttribute("data-value");
        if (completion.getAttribute("value")) return completion.getAttribute("value");
        var pos = position(this.nodes, completion);
        return 0 > pos ? !1 : this.values[pos];
    }, Completions.prototype.getKey = function(completion) {
        return completion.key ? completion.key : completion.getAttribute("data-key") ? completion.getAttribute("data-key") : completion.getAttribute("key") ? completion.getAttribute("key") : getKey(completion);
    }, Completions.prototype.complete = function(string, callback) {
        var that = this;
        if (this.initialized || initCompletions(this), string || "" === string || (string = this.getText ? this.getText(this.input) : hasClass(this.input, "isempty") ? "" : this.input.value), 
        isEmpty(string)) return rAF(function() {
            that.displayed && updateDisplay(that, !1), addClass(that.dom, "noinput"), dropClass(that.dom, "nomatches"), 
            callback && async(function() {
                callback([]);
            });
        }), [];
        var result = this.getCompletions(string);
        return result && 0 !== result.length ? (rAF(function() {
            updateDisplay(that, result.matches), dropClass(that.dom, "noinput"), dropClass(that.dom, "nomatches"), 
            callback && async(function() {
                callback(result);
            });
        }), result) : (rAF(function() {
            updateDisplay(that, !1), dropClass(that.dom, "noinput"), addClass(that.dom, "nomatches"), 
            callback && async(function() {
                callback(result);
            });
        }), []);
    }, Completions.prototype.getByValue = function(values, spec) {
        this.initialized || initCompletions(this);
        var result = [], byvalue = this.byvalue;
        spec && (spec = new fdjtDOM.Selector(spec)), values instanceof Array || (values = [ values ]);
        for (var i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) if (completions instanceof Array || (completions = [ completions ]), 
            spec) for (var j = 0, jlim = completions.length; jlim > j; ) spec.match(completions[j]) ? result.push(completions[j++]) : j++; else result = result.concat(completions);
        }
        return result;
    }, Completions.prototype.getByKey = function(keys, spec) {
        this.initialized || initCompletions(this);
        var result = [], bykey = this.bykey;
        spec && (spec = new fdjtDOM.Selector(spec)), keys instanceof Array || (keys = [ keys ]);
        for (var i = 0, lim = keys.length; lim > i; ) {
            var key = keys[i++], completions = bykey[key];
            if (completions) if (completions instanceof Array || (completions = [ completions ]), 
            spec) for (var j = 0, jlim = completions.length; jlim > j; ) spec.match(completions[j]) ? result.push(completions[j++]) : j++; else result = result.concat(completions);
        }
        return result;
    }, Completions.prototype.setCues = function(values, cueclass) {
        this.initialized || initCompletions(this), cueclass || (cueclass = "cue");
        for (var cues = [], byvalue = this.byvalue, i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) {
                completions instanceof Array || (completions = [ completions ]);
                for (var j = 0, jlim = completions.length; jlim > j; ) {
                    var c = completions[j++];
                    hasClass(c, cueclass) || (addClass(c, cueclass), cues.push(c));
                }
            }
        }
        return cues;
    }, Completions.prototype.setClass = function(values, classname) {
        this.initialized || initCompletions(this);
        var drop = fdjtDOM.getChildren(this.dom, ".completion." + classname);
        drop && drop.length && dropClass(fdjtDOM.Array(drop), "hidden");
        for (var changed = [], byvalue = this.byvalue, i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) {
                completions instanceof Array || (completions = [ completions ]);
                for (var j = 0, jlim = completions.length; jlim > j; ) {
                    var c = completions[j++];
                    hasClass(c, classname) || (addClass(c, classname), changed.push(c));
                }
            }
        }
        return changed;
    }, Completions.prototype.extendClass = function(values, classname) {
        this.initialized || initCompletions(this);
        for (var changed = [], byvalue = this.byvalue, i = 0, lim = values.length; lim > i; ) {
            var value = values[i++], completions = byvalue.get(value);
            if (completions) {
                completions instanceof Array || (completions = [ completions ]);
                for (var j = 0, jlim = completions.length; jlim > j; ) {
                    var c = completions[j++];
                    hasClass(c, classname) || (addClass(c, classname), changed.push(c));
                }
            }
        }
        return changed;
    }, Completions.prototype.dropClass = function(classname) {
        var drop = fdjtDOM.getChildren(this.dom, ".completion." + classname);
        drop && drop.length && dropClass(fdjtDOM.Array(drop), classname);
    }, Completions.prototype.docomplete = function(input, callback) {
        this.initialized || initCompletions(this), input || (input = this.input);
        var delay = this.complete_delay || complete_delay, that = this;
        this.timer && (clearTimeout(that.timer), that.timer = !1), this.timer = setTimeout(function() {
            input || (input = that.input);
            var completions = that.complete(input.value);
            callback && callback(completions);
        }, delay);
    }, fdjtUI.Completions = Completions;
    var Selector = fdjtDOM.Selector;
    Completions.prototype.getVisible = function() {
        if (this.visible) return this.visible;
        var visible = this.visible = gatherVisible(this.dom);
        return visible;
    }, Completions.prototype.select = function(completion) {
        var pref = !1, displayed = this.getVisible();
        if (completion instanceof Selector && (pref = completion, completion = !1), !completion && pref) for (var nodes = displayed, i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++];
            if (hasClass(node, pref)) {
                completion = node;
                break;
            }
        }
        return !completion && displayed.length && (completion = displayed[0]), this.selection && dropClass(this.selection, "selected"), 
        addClass(completion, "selected"), this.selection = completion, completion;
    }, Completions.prototype.selectNext = function(selection) {
        selection || (selection = this.selection ? this.selection : !1);
        for (var nodes = this.getVisible(), dflt = !1, found = !1, i = 0, lim = nodes.length; lim > i; ) {
            var node = nodes[i++];
            if (dflt || (dflt = node), !selection) {
                selection = node;
                break;
            }
            node === selection && (selection = !1, found = !0);
        }
        return this.selection && dropClass(this.selection, "selected"), found || (selection = dflt), 
        addClass(selection, "selected"), this.selection = selection, selection;
    }, Completions.prototype.selectPrevious = function(selection) {
        selection || (selection = this.selection ? this.selection : !1);
        for (var nodes = this.getVisible(), dflt = !1, found = !1, i = nodes.length - 1; i >= 0; ) {
            var node = nodes[i--];
            if (dflt || (dflt = node), !selection) {
                selection = node;
                break;
            }
            node === selection && (selection = !1, found = !0);
        }
        return this.selection && dropClass(this.selection, "selected"), found || (selection = dflt), 
        selection && addClass(selection, "selected"), this.selection = selection, selection;
    }, Completions.prototype.clearSelection = function(selection) {
        if (selection && this.selection && selection !== this.selection) return !1;
        if (this.selection) return dropClass(this.selection, "selected"), this.selection = !1, 
        !0;
    };
    var cached_completions = {};
    fdjtUI.Completions.onkey = onkey, fdjtUI.Completions.update = update;
}(), fdjt.UI || (fdjt.UI = {}), fdjt.TapHold = fdjt.UI.TapHold = function() {
    "use strict";
    function xyd(x0, y0, x1, y1) {
        return "number" == typeof x0 && "number" == typeof y0 && "number" == typeof x1 && "number" == typeof y1 ? sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1)) : !1;
    }
    function getClientX(evt, x, y) {
        if ("number" == typeof evt.clientX) return evt.clientX;
        var touches = evt.changedTouches && evt.changedTouches.length && evt.changedTouches || evt.touches && evt.touches.length && evt.touches, winxoff = window.pageXOffset, winyoff = window.pageYOffset;
        if (touches && touches.length) {
            if (1 === touches.length || "number" != typeof x || "number" != typeof y) return touches[0].pageX - winxoff;
            for (var i = 1, lim = touches.length, tch = touches[0], d = xyd(Math.abs(tch.pageX - winxoff), Math.abs(tch.pageY - winyoff), x, y), d_min = d, touch = tch; lim > i; ) tch = touches[i++], 
            d = xyd(Math.abs(tch.pageX - winxoff), Math.abs(tch.pageY - winyoff), x, y), d_min > d && (touch = tch, 
            d_min = d);
            return touch.pageX - winxoff;
        }
        return !1;
    }
    function getClientY(evt, x, y) {
        if ("number" == typeof evt.clientY) return evt.clientY;
        var touches = evt.changedTouches && evt.changedTouches.length && evt.changedTouches || evt.touches && evt.touches.length && evt.touches, winxoff = window.pageXOffset, winyoff = window.pageYOffset;
        if (touches && touches.length) {
            if (1 === touches.length || "number" != typeof x || "number" != typeof y) return touches[0].pageY - winyoff;
            for (var i = 1, lim = touches.length, tch = touches[0], d = Math.abs(Math.abs(tch.pageX - winxoff) - x) + Math.abs(Math.abs(tch.pageY - winyoff) - y), d_min = d, touch = tch; lim > i; ) tch = touches[i++], 
            d = Math.abs(Math.abs(tch.pageX - winxoff) - x) + Math.abs(Math.abs(tch.pageY - winyoff) - y), 
            d_min > d && (touch = tch, d_min = d);
            return touch.pageY - winyoff;
        }
        return !1;
    }
    function synthesizeEvent(target, etype, th, orig, tx, ty, tn, also) {
        var thid = th.id || typeof th, trace = th.traced, handlers = th.handlers, orig_target = orig && eTarget(orig);
        target || (target = orig_target);
        var evt = document.createEvent("UIEvent"), event_arg = orig && orig.touches && orig.touches.length || orig && orig.button || 0;
        if (evt.initUIEvent(etype, !0, !0, window, event_arg), evt.clientX = tx, evt.clientY = ty, 
        evt.ntouches = tn || 1, also) for (var prop in also) also.hasOwnProperty(prop) && (evt[prop] = also[prop]);
        (trace || traceall) && (also && "number" == typeof also.startX ? fdjtLog("TapHold/%s(%s) on %o @%d,%d/%d,%d from %o given %j", etype, thid, target, tx, ty, also.startX, also.startY, orig || "scratch", also) : also ? fdjtLog("TapHold/%s(%s) on %o @%d,%d from %o given %j", etype, thid, target, tx, ty, orig || "scratch", also) : fdjtLog("TapHold/%s(%s) on %o @%d,%d from %j", etype, thid, target, tx, ty, orig || "scratch")), 
        target && hasParent(target, document.body) || (target = document.elementFromPoint(tx, ty)), 
        handlers && handlers.hasOwnProperty(etype) ? (evt.target = target, handlers[etype](evt, target)) : target.dispatchEvent(evt);
    }
    function getRealTarget(holder, touchable, x, y) {
        for (var children = getChildren(holder, touchable), i = 0, lim = children.length; lim > i; ) {
            var child = children[i++], left = child.offsetLeft, top = child.offsetTop, right = child.offsetRight, bot = child.offsetBottom;
            if ("number" == typeof left && (1 >= right - left ? x >= left && right >= y : x >= left && right > y) && (1 >= bot - top ? y >= top && bot >= y : x >= top && bot > y)) return child;
        }
        return !1;
    }
    function global_mouseup(evt) {
        evt = evt || window.event, traceall && fdjtLog("TapHold/global/mouseup %o", evt), 
        1 === evt.button && (mouse_down = !1);
    }
    function global_mousedown(evt) {
        evt = evt || window.event, traceall && fdjtLog("TapHold/global/mousedown %o", evt), 
        1 === evt.button && (mouse_down = !0);
    }
    function global_mouseout(evt) {
        evt = evt || window.event;
        var target = eTarget(evt), rel = evt.relatedTarget || evt.toElement;
        traceall > 2 && fdjtLog("TapHold/global/mouseout %o %o==>%o", evt, target, rel), 
        target === document.documentElement && (mouse_down = !1);
    }
    function traceValue(classname) {
        var parsed = /\bfdjtlog(\d*)/.exec(classname);
        if (parsed && parsed.length) {
            var level = "string" == typeof parsed[1] && parseInt(parsed[1], 10);
            return level && !isNaN(level) ? level : 1;
        }
        return 0;
    }
    function initSound(name, th, opts, elt) {
        var found = th[name] || opts && opts[name] || elt.getAttribute("data-" + name) || TapHold[name];
        return found && (th[name] = found), found;
    }
    function playSound(name, evt, th) {
        var target = evt.nodeType && evt || fdjtUI.T(evt);
        if (th.mute || TapHold.mute || hasClass(target, "fdjtmute") || hasClass(th.container, "fdjtmute")) return !1;
        var sound = target.getAttribute("data-" + name) || th[name];
        "string" == typeof sound && (sound = document.getElementById(sound)), sound && sound.play();
    }
    function TapHold(elt, opts) {
        function start_holding() {
            var parents = getParents(elt, ".tapholdcontext");
            parents && parents.length && (addClass(parents, holdclass), drop_holding = parents), 
            addClass(elt, holdclass);
        }
        function stop_holding() {
            drop_holding && drop_holding.length && (dropClass(drop_holding, holdclass), drop_holding = !1), 
            dropClass(elt, holdclass);
        }
        function check_holding() {
            th_target || dropClass(elt, holdclass);
        }
        function cleartouch(all) {
            th_timer && (clearTimeout(th_timer), th_timer = !1), all && tt_timer && (clearTimeout(tt_timer), 
            tt_timer = !1), th_target && touchclass && dropClass(th_target, touchclass), th_target = th_target_t = !1, 
            th_targets = [], swipe_t = start_x = start_y = start_t = touch_x = touch_y = touch_t = touch_n = target_x = target_y = target_t = !1, 
            no_swipe = !1, touched = pressed = pressed_at = !1;
        }
        function synthEvent(target, etype, th, orig, tx, ty, also) {
            return synthesizeEvent(target, etype, th, orig, tx, ty, touch_n, also);
        }
        function setTarget(t) {
            (trace > 2 || traceall > 2 || t !== th_target && (trace || traceall)) && fdjtLog("TapHold/setTarget(%s) %o cur=%o", thid, t, th_target), 
            th_target && th_target !== t && touchclass && dropClass(th_target, "tapholdtarget"), 
            t && touchclass && addClass(t, "tapholdtarget"), t && th_target && t !== th_target && (target_x = touch_x, 
            target_y = touch_y, target_t = touch_t), th_last = th_target, th_target = t, th_target_t = fdjtET();
        }
        function tapped(target, evt, x, y) {
            return x === void 0 && (x = touch_x), y === void 0 && (y = touch_y), playSound("tapsound", target, th), 
            synthEvent(target, "tap", th, evt, x, y, !1);
        }
        function held(target, evt, x, y) {
            return x === void 0 && (x = touch_x), y === void 0 && (y = touch_y), no_swipe = !0, 
            playSound("holdsound", target, th), holdclass && setTimeout(start_holding, 20), 
            synthEvent(target, "hold", th, evt, x, y, !1);
        }
        function released(target, evt, x, y) {
            var target_time = th_target_t && th_last && fdjtET() - th_target_t;
            x === void 0 && (x = touch_x), y === void 0 && (y = touch_y), playSound("releasesound", target, th);
            var point_target = document.elementFromPoint(x, y);
            return point_target && (point_target = getParent(point_target, touchable)), point_target && point_target !== target && hasParent(point_target, target) && (target = point_target), 
            holdclass && setTimeout(check_holding, 50), target_time && 200 > target_time && (trace && fdjtLog("TapHold(%s) %d=i<200ms, target=%o not %o", thid, target_time, th_last, target), 
            target = th_last), synthEvent(target, "release", th, evt, x, y, {
                startX: start_x,
                startY: start_y
            });
        }
        function slipped(target, evt, also) {
            if (also ? (also.startX = start_x, also.startY = start_y) : also = {
                startX: start_x,
                startY: start_y
            }, evt && !also.hasOwnProperty("relatedTarget")) {
                var rel = evt.relatedTarget;
                rel !== target && (also.relatedTarget = rel);
            }
            return playSound("slipsound", target, th), holdclass && setTimeout(check_holding, 50), 
            synthEvent(target, "slip", th, evt, touch_x, touch_y, also);
        }
        function taptapped(target, evt) {
            return playSound("taptapsound", target, th), synthEvent(target, "taptap", th, evt, touch_x, touch_y, !1, trace);
        }
        function swiped(target, evt, sx, sy, cx, cy) {
            var dx = cx - sx, dy = cy - sy;
            return swipe_t = fdjtET(), playSound("swipesound", target, th), synthEvent(target, "swipe", th, evt, cx, cy, {
                startX: sx,
                startY: sy,
                endX: cx,
                endY: cy,
                deltaX: dx,
                deltaY: dy
            });
        }
        function startpress(evt, to) {
            if (to || (to = holdmsecs || TapHold.interval || 100), evt = evt || window.event, 
            (trace > 1 || traceall > 1) && fdjtLog("TapHold/startpress(%s) %o tht=%o timer=%o tt=%o touched=%o pressed=%o@%o timeout=%oms", thid, evt, th_target, th_timer, tap_target, touched, pressed, pressed_at, to), 
            tap_target && th_timer && (clearTimeout(th_timer), th_timer = !1), tap_target && tt_timer) return clearTimeout(tt_timer), 
            tt_timer = !1, taptapped(tap_target, evt), cleartouch(!0), void 0;
            if (!(touched || pressed || th_timer)) {
                if (!th_target) return swipe_t = !1, void 0;
                touched = th_target, pressed = !1, swipe_t = !1, reticle.live && reticle.highlight(!0), 
                pressed_at = fdjtET(), th_timer && clearTimeout(th_timer), th_timer = setTimeout(function() {
                    if ((trace > 1 || traceall > 1) && fdjtLog("TapHold/startpress/timeout(%s) (%dms) %o", thid, to, evt), 
                    th_targets.length > 0) for (var targets = th_targets, i = 0, lim = targets.length; lim > i; ) {
                        var elt = targets[i++];
                        if (i === lim && elt === th_target) break;
                        held(elt), noslip || (lim > i ? slipped(elt, evt, {
                            relatedTarget: targets[i]
                        }) : slipped(elt, evt));
                    }
                    pressed = th_target, th_targets = [], pressed_at = th_target ? fdjtET() : !1, held(th_target, evt), 
                    th_timer && clearTimeout(th_timer), th_timer = !1, touched = !1;
                }, to);
            }
        }
        function endpress(evt) {
            if ((trace > 1 || traceall > 1) && fdjtLog("TapHold/endpress(%s) %o t=%o p=%o tch=%o tm=%o ttt=%o/%o, start=%d,%d,%d/%d", thid, evt, th_target, pressed, touched, th_timer, tap_target, taptapmsecs, start_x, start_y, start_t, fdjtET()), 
            !pressed && !touched && !th_timer) return cleartouch(!0), void 0;
            var x = touch_x, y = touch_y;
            if (th_timer) clearTimeout(th_timer), th_timer = !1, reticle.live && setTimeout(function() {
                reticle.highlight(!1);
            }, 1500), th_target === touched || holdmsecs / 1e3 > fdjtET() - start_t ? (tap_target = th_target, 
            taptapmsecs && taptapmsecs > 0 ? tt_timer = setTimeout(function() {
                tt_timer = !1, tapped(tap_target, evt, x, y);
            }, taptapmsecs) : tapped(th_target, evt, x, y)) : noslip || slipped(th_target, evt); else if (pressed) {
                var geom = fdjtDOM.getGeometry(elt);
                x >= geom.left && geom.right >= x && y >= geom.top && geom.bottom >= y ? released(pressed, evt, x, y) : noslip ? released(pressed, evt, x, y) : slipped(th_target, evt, {
                    touch_x: x,
                    touch_y: y
                });
            }
            reticle.live && reticle.highlight(!1), cleartouch(), setTarget(!1), holdclass && setTimeout(stop_holding, 20), 
            th_targets = [];
        }
        function abortpress(evt, why) {
            (trace || traceall) && fdjtLog("TapHold/abort%s(%s) %o: th=%o t=%o p=%o", why ? "(" + why + ")" : "", thid, evt, th_target, touched, pressed), 
            th_timer ? (clearTimeout(th_timer), th_timer = !1) : noslip || pressed && slipped(pressed, evt, {
                relatedTarget: !1
            }), reticle.live && reticle.highlight(!1), pressed_at = touched = pressed = tap_target = !1, 
            holdclass && setTimeout(stop_holding, 20), th_targets = [], setTarget(!1);
        }
        function taphold_mouseout(evt) {
            evt = evt || window.event;
            var to = evt.toElement || evt.relatedTarget;
            wander_timer || th_target && pressed && !hasParent(to, elt) && (wander_timer = setTimeout(wandered, wanderthresh, evt, to));
        }
        function wandered(evt, to) {
            noslip || slipped(pressed, evt, {
                relatedTarget: to
            }), abortpress(evt, "taphold_mouseout");
        }
        function taphold_mouseover(evt) {
            evt = evt || window.event, wander_timer && (clearTimeout(wander_timer), wander_timer = !1);
        }
        function taphold_move(evt) {
            evt = evt || window.event;
            var target, n_touches = evt.touches && evt.touches.length || 1;
            if (bubble || noBubble(evt), override && noDefault(evt), scrolling && evt.touches && maxtouches >= evt.touches.length && (scroll_x >= 0 && (scrolling.scrollLeft = scroll_x - (evt.touches[0].pageX - window.pageXOffset)), 
            scroll_y >= 0 && (scrolling.scrollTop = scroll_y - (evt.touches[0].pageY - window.pageYOffset))), 
            pressed && cleared > start_t) return abortpress(evt, "move/cleared"), void 0;
            if ((touched || pressed) && !mouse_down) return abortpress(evt, "move/up"), void 0;
            var x = evt.clientX || getClientX(evt, touch_x, touch_y), y = evt.clientY || getClientY(evt, touch_x, touch_y), distance = pressed ? xyd(x, y, target_x, target_y) : xyd(x, y, start_x, start_y);
            if (evt.touches || hot_xoff || hot_yoff ? (x += hot_xoff, y += hot_yoff, target = document.elementFromPoint(x, y)) : target = eTarget(evt), 
            !target || !isTextInput(target)) {
                var delta = Math.abs(x - touch_x) + Math.abs(y - touch_y), dt = fdjtET() - touch_t;
                if ((trace > 2 || traceall > 2) && fdjtLog("TapHold/move(%s) s=%d,%d tt=%d,%d t=%d,%d c=%d,%d d=%d thresh=%o, dt=%o md=%o, pressed=%o, touched=%o, event=%o target=%o", thid, start_x, start_y, target_x, target_y, touch_x, touch_y, x, y, distance, movethresh, dt, mouse_down, pressed, touched, evt, target), 
                !target) return touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                var holder = getParent(target, ".tapholder");
                if (holder !== elt) return (trace > 2 || traceall > 2) && trace_ignore_move(evt, thid, elt, holder, th_target, target, start_x, start_y, target_x, target_y, touch_x, touch_y), 
                th_target && ((trace || traceall) && fdjtLog("setWanderTimeout(%s): h=%o!=elt=%o", thid, holder, elt), 
                wander_timer = setTimeout(function() {
                    abortpress(evt, "taphold_wander_timeout");
                }, wanderthresh), pressed && (noslip || slipped(pressed, evt, {
                    relatedTarget: !1
                }), setTarget(!1))), void 0;
                if (wander_timer && (clearTimeout(wander_timer), wander_timer = !1, (trace > 2 || traceall > 2) && fdjtLog("Wander return(%s) %o pressed=%o, target=%o", thid, evt, pressed, th_target), 
                pressed && !th_target && (setTarget(pressed), held(pressed, evt))), !touched && !pressed) return !swipe_t && !no_swipe && min_swipe > 0 && xyd(start_x, start_y, x, y) > min_swipe && swiped(target, evt, start_x, start_y, x, y), 
                touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                if (movethresh && th_timer && distance > movethresh) return (trace > 1 || traceall > 1) && fdjtLog("TapHold/move/cancel(%s) s=%d,%d tt=%d,%d t=%d,%d c=%d,%d d=%d thresh=%o, dt=%o md=%o, event=%o", thid, start_x, start_y, target_x, target_y, touch_x, touch_y, x, y, distance, movethresh, dt, mouse_down, evt), 
                abortpress(evt, "movefar"), th_timer && clearTimeout(th_timer), pressed_at = touched = th_timer = pressed = !1, 
                th_targets = [], !swipe_t && !no_swipe && min_swipe > 0 && xyd(start_x, start_y, x, y) > min_swipe && swiped(target, evt, start_x, start_y, x, y), 
                setTarget(!1), touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                if (10 * minmove > delta && dt > 0 && minmove > delta / dt) return (trace > 2 || traceall > 2) && fdjtLog("TapHold/move/ignore(%s) s=%d,%d t=%d,%d c=%d,%d dt=%o total=%d/%o, local=%d/%o/%o, thresh=%o md=%o", thid, start_x, start_y, touch_x, touch_y, x, y, dt, distance, movethresh, delta, delta / dt, minmove, mouse_down), 
                touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                void 0;
                (trace > 2 || traceall > 2) && fdjtLog("TapHold/move(%s) s=%d,%d t=%d,%d c=%d,%d dt=%o total=%d/%o, local=%d/%o/%o, md=%o", thid, start_x, start_y, touch_x, touch_y, x, y, dt, distance, movethresh, delta, minmove, delta / dt, mouse_down), 
                touch_x = x, touch_y = y, touch_t = fdjtET(), touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, 
                target = getParent(target, touchable), evt.touches && evt.touches.length && evt.touches.length > maxtouches || (reticle.live && reticle.onmousemove(evt, touch_x, touch_y), 
                target || (target = getRealTarget(elt, touchable, touch_x, touch_y)), target && (hasParent(target, ".tapholder") && !noslip && setTarget(target), 
                evt.touches && touched && !pressed && th_targets[th_targets.length - 1] !== th_target && th_targets.push(th_target), 
                mouse_down ? pressed && th_target !== pressed && !hasParent(th_target, pressed) && !hasParent(pressed, th_target) && noslip ? ((trace > 1 || traceall > 1) && fdjtLog("TapHold/move(%s) endpress pressed=%o tt=%o %o", thid, pressed, th_target, evt), 
                endpress(evt)) : pressed && th_target !== pressed && (noslip || slipped(pressed, evt, {
                    relatedTarget: target
                }), pressed = th_target, pressed_at = pressed ? fdjtET() : !1, held(pressed)) : (noslip || slipped(pressed, evt, {
                    relatedTarget: target
                }), pressed_at = pressed = !1)));
            }
        }
        function trace_ignore_move(evt, thid, elt, holder, th_target, target, start_x, start_y, target_x, target_y, touch_x, touch_y) {
            fdjtLog("TapHold/move%s/farout(%s) %o %o -> %o s=%d,%d tt=%d,%d t=%d,%d", mouse_down ? "/md" : "", thid, evt, th_target, target, start_x, start_y, target_x, target_y, touch_x, touch_y), 
            fdjtLog("TapHold/move/farout(%s) target in %o, elt is %o", thid, holder, elt);
        }
        function taphold_down(evt, holdmsecs) {
            if (evt = evt || window.event, !(evt.ctrlKey || evt.altKey || evt.metaKey || evt.button || evt.which && evt.which > 1)) {
                var n_touches = evt.touches && evt.touches.length || 1;
                mouse_down = !0, cleared = 0, touch_x = (evt.clientX || getClientX(evt) || touch_x) + hot_xoff, 
                touch_y = (evt.clientY || getClientY(evt) || touch_y) + hot_yoff, start_x = target_x = touch_x, 
                start_y = target_y = touch_y, target_t = touch_t = fdjtET();
                var target = hot_xoff || hot_yoff ? document.elementFromPoint(touch_x, touch_y) : eTarget(evt);
                if (!target || !isTextInput(target)) {
                    touch_n ? n_touches > touch_n && (touch_n = n_touches) : touch_n = n_touches, bubble || noBubble(evt), 
                    override && noDefault(evt);
                    var new_event = !1, holder = getParent(target, ".tapholder");
                    if ((trace > 1 || traceall > 1) && fdjtLog("TapHold/down(%s) %o tht=%o target=%o holder=%o elt=%o", thid, evt, th_target, target, holder, elt), 
                    holder !== elt) return (trace > 1 || traceall > 1) && fdjtLog("TapHold/ignore(%s) %o tht=%o t=%o h=%o elt=%o", thid, evt, th_target, target, holder, elt), 
                    void 0;
                    if (target && (target = getParent(target, touchable)), scrolling && evt.touches && maxtouches >= evt.touches.length && (scroll_x >= 0 && (scroll_x = scrolling.scrollLeft + (evt.touches[0].pageX - window.pageXOffset)), 
                    scroll_y >= 0 && (scroll_y = scrolling.scrollLeft + (evt.touches[0].pageY - window.pageYOffset))), 
                    evt.touches && (target = document.elementFromPoint(touch_x, touch_y)), (trace > 1 || traceall > 1) && fdjtLog("TapHold/down2(%s) %o tht=%o trg=%o s=%o,%o,%o t=%o,%o m=%o tch=%o prs=%o ttt=%o", thid, evt, th_target, target, start_x, start_y, start_t, touch_x, touch_y, mouse_down, touched, pressed, taptapmsecs || !1), 
                    evt.touches && th_target) {
                        var cur_holder = getParent(elt, ".tapholder"), touch = evt.changedTouches[0];
                        if ((trace > 1 || traceall > 1) && fdjtLog("TapHold(%s) second touch on %o (in %o) after %o (in %o)", thid, target, holder, th_target, cur_holder, cur_holder === holder), 
                        touchtoo && cur_holder === holder) return (trace > 1 || traceall > 1) && fdjtLog("TapHold(%s) touchtoo with touchtoo on %o after %o: %o", thid, target, th_target, evt), 
                        touchtoo.call ? (touchtoo.call(th, evt), void 0) : (new_event = document.createEvent("UIEvent"), 
                        new_event.initUIEvent("touchtoo", !0, !0, window, 0), new_event.screenX = touch.screenX, 
                        new_event.screenY = touch.screenY, new_event.clientX = touch.clientX, new_event.clientY = touch.clientY, 
                        new_event.ctrlKey = evt.ctrlKey, new_event.altKey = evt.altKey, new_event.shiftKey = evt.shiftKey, 
                        new_event.metaKey = evt.metaKey, new_event.touches = document.createTouchList(touch), 
                        new_event.targetTouches = document.createTouchList(touch), new_event.changedTouches = document.createTouchList(touch), 
                        target.dispatchEvent(new_event), void 0);
                        cur_holder && holder && cur_holder !== holder && ((trace > 1 || traceall > 1) && fdjtLog("TapHold(%s) Clearing on %o, moving %o to %o", thid, th_target, evt, target), 
                        new_event = document.createEvent("TouchEvent"), new_event.initTouchEvent(evt.type, !0, !0, window, null, touch.screenX, touch.screenY, touch.clientX, touch.clientY, evt.ctrlKey, evt.altKey, evt.shiftKey, evt.metaKey, document.createTouchList(touch), document.createTouchList(touch), document.createTouchList(touch)));
                    }
                    if (new_event) return abortpress(evt, "down/touch2"), target.dispatchEvent(new_event), 
                    void 0;
                    setTarget(target), th_targets = [], start_t = fdjtET(), (trace > 1 || traceall > 1) && fdjtLog("TapHold/down3(%s) %o t=%o x=%o y=%o t=%o touched=%o", thid, evt, th_target, start_x, start_y, start_t, touched), 
                    untouchable && untouchable(evt) || touched || startpress(evt, holdmsecs);
                }
            }
        }
        function taphold_up(evt) {
            if (evt = evt || window.event, mouse_down = !1, cleared > start_t) return abortpress(evt, "up"), 
            void 0;
            var target = eTarget(evt);
            if (!target || !isTextInput(target)) {
                bubble || noBubble(evt), override && noDefault(evt);
                var holder = getParent(target, ".tapholder");
                if (holder !== elt) return (trace > 1 || traceall > 1) && fdjtLog("TapHold/up/ignore(%s) %o tht=%o target=%o holder=%o elt=%o", thid, evt, th_target, target, holder, elt), 
                void 0;
                if (target && (target = getParent(target, touchable)), touch_x = (evt.clientX || getClientX(evt) || touch_x) + hot_xoff, 
                touch_y = (evt.clientY || getClientY(evt) || touch_y) + hot_yoff, touch_t = fdjtET(), 
                (!target || hot_xoff || hot_yoff) && (target = getRealTarget(elt, touchable, touch_x, touch_y)), 
                (trace > 1 || traceall > 1) && fdjtLog("TapHold/up(%s) %o tht=%o d=%o s=%o,%o,%o t=%o,%o m=%o touched=%o pressed=%o ttt=%o swipe_t=%o", thid, evt, th_target, xyd(start_x, start_y, touch_x, touch_y), start_x, start_y, start_t, touch_x, touch_y, mouse_down, touched, pressed, taptapmsecs, swipe_t), 
                !(evt.changedTouches && evt.changedTouches.length && evt.changedTouches.length > maxtouches)) {
                    var swipe_len = swipe_t ? 0 : xyd(start_x, start_y, touch_x, touch_y);
                    if (touched || pressed) {
                        if (untouchable && untouchable(evt)) return;
                        endpress(evt);
                    } else !(min_swipe > 0 && swipe_len > min_swipe) || no_swipe || touched && touched === elt || pressed && pressed === elt ? (touched || pressed) && (untouchable && untouchable(evt) || endpress(evt)) : swiped(target, evt, start_x, start_y, touch_x, touch_y);
                    cleartouch();
                }
            }
        }
        function taphold_cancel(evt) {
            (trace || traceall) && fdjtLog("TapHold/cancel(%s) %o: th=%o t=%o p=%o", thid, evt, th_target, touched, pressed), 
            th_timer ? (clearTimeout(th_timer), th_timer = !1) : pressed && released(pressed, evt), 
            reticle.live && reticle.highlight(!1), pressed_at = touched = pressed = tap_target = !1, 
            holdclass && setTimeout(stop_holding, 20), th_targets = [], setTarget(!1);
        }
        if (!elt) return fdjtLog.warn("TapHold with no argument!"), void 0;
        if (!(this instanceof TapHold)) return new TapHold(elt, opts);
        var th = this, holdclass = "tapholding", touchclass = "tapholdtarget", touched = !1, pressed = !1, pressed_at = !1, th_timer = !1, tt_timer = !1, th_target = !1, th_targets = [], tap_target = !1, th_target_t = !1, th_last = !1, fortouch = !1, noslip = !1, bubble = !1, override = !1, maxtouches = 1, touchtoo = !1, holdmsecs = !1, taptapmsecs = !1, movethresh = !1, wanderthresh = !1, min_swipe = 30, no_swipe = !1, scrolling = !1, scroll_x = 0, scroll_y = 0, start_x = !1, start_y = !1, start_t = !1, touch_x = !1, touch_y = !1, touch_t = 0, touch_n = !1, target_x = !1, target_y = !1, target_t = !1, swipe_t = !1, minmove = 2, hot_xoff = 0, hot_yoff = 0, trace = 0, serial = serial_count++, thid = opts && opts.id ? opts.id + ":" + serial : elt.id ? "#" + elt.id + ":" + serial : "" + serial;
        th.id = thid;
        var drop_holding = [], getParents = fdjtDOM.getParents;
        initSound("tapsound", th, opts, elt), initSound("holdsound", th, opts, elt), initSound("releasesound", th, opts, elt), 
        initSound("slipsound", th, opts, elt), initSound("taptapsound", th, opts, elt), 
        initSound("swipesound", th, opts, elt);
        var touchable = elt.getAttribute("data-touchable");
        touchable = opts && opts.hasOwnProperty("touchable") ? "string" == typeof opts.touchable ? fdjtDOM.Selector(opts.touchable) : opts.touchable : touchable ? fdjtDOM.Selector(touchable) : function(e) {
            return hasParent(e, elt);
        };
        var untouchable, isClickable = fdjtUI.isClickable;
        if (opts && opts.hasOwnProperty("untouchable")) if ("string" == typeof opts.untouchable) {
            var notouch = fdjtDOM.Selector(opts.untouchable);
            untouchable = function(e) {
                return e.nodeType ? notouch.match(e) : notouch.match(eTarget(e));
            };
        } else untouchable = opts.untouchable; else untouchable = function(e) {
            return isClickable(e);
        };
        if (opts && opts.noslip && (noslip = opts.noslip), opts && opts.touch_xoff && (hot_xoff = opts.touch_xoff), 
        opts && opts.touch_yoff && (hot_yoff = opts.touch_yoff), opts && opts.hasOwnProperty("trace")) {
            var opt_val = opts.trace;
            trace = "number" == typeof opt_val ? opt_val : opt_val ? 2 : 0;
        } else trace = hasClass(elt, /\bfdjtlog\d*/g) ? traceValue(elt.className) : 0;
        var wander_timer = !1;
        return opts ? opts.hasOwnProperty || (opts = {
            touch: !0
        }) : opts = {}, fortouch = opts.hasOwnProperty("fortouch") ? opts.fortouch : default_opts.hasOwnProperty("fortouch") ? default_opts.fortouch : !1, 
        holdmsecs = opts.hasOwnProperty("holdmsecs") ? opts.holdmsecs : default_opts.hasOwnProperty("holdmsecs") ? default_opts.holdmsecs : 150, 
        movethresh = opts.hasOwnProperty("movethresh") ? opts.movethresh : default_opts.hasOwnProperty("movethresh") ? default_opts.movethresh : 20, 
        taptapmsecs = opts.hasOwnProperty("taptapmsecs") && opts.taptapmsecs, wanderthresh = opts.hasOwnProperty("wanderthresh") ? opts.wanderthresh : default_opts.hasOwnProperty("wanderthresh") ? default_opts.wanderthresh : 2e3, 
        override = opts.hasOwnProperty("override") ? opts.override : default_opts.hasOwnProperty("override") ? default_opts.override : !1, 
        touchtoo = opts.hasOwnProperty("touchtoo") ? opts.touchtoo : default_opts.hasOwnProperty("touchtoo") ? default_opts.touchtoo : !1, 
        min_swipe = opts.hasOwnProperty("minswipe") ? opts.minswipe : default_opts.hasOwnProperty("minswipe") ? default_opts.minswipe : 30, 
        bubble = opts.hasOwnProperty("bubble") ? opts.bubble : default_opts.hasOwnProperty("bubble") ? default_opts.bubble : !1, 
        maxtouches = opts.hasOwnProperty("maxtouches") ? opts.maxtouches : default_opts.hasOwnProperty("maxtouches") ? default_opts.maxtouches : 1, 
        taptapmsecs && "number" != typeof taptapmsecs && (taptapmsecs = default_opts.taptapmsecs || 200), 
        scrolling = opts.hasOwnProperty("scrolling") ? opts.touch : !1, scrolling && (scrolling.nodeType || (scrolling = elt), 
        scroll_x = (opts.hasOwProperty("scrollx") ? opts.scrollx : !1) ? 0 : -1, scroll_y = (opts.hasOwProperty("scrolly") ? opts.scrolly : !0) ? 0 : -1), 
        opts.hasOwnProperty("holdclass") ? holdclass = opts.holdclass : default_opts.hasOwnProperty("holdclass") && (holdclass = default_opts.holdclass), 
        opts.hasOwnProperty("touchclass") ? touchclass = opts.touchclass : default_opts.hasOwnProperty("touchclass") && (touchclass = default_opts.touchclass), 
        minmove = opts.hasOwnProperty("minmove") ? opts.minmove : default_opts.hasOwnProperty("minmove") ? default_opts.minmove : fortouch ? 2 : 0, 
        opts.hasOwnProperty("handlers") && (this.handlers = opts.handlers), addClass(elt, "tapholder"), 
        fortouch || fdjtDOM.addListener(elt, "mousemove", taphold_move), fdjtDOM.addListener(elt, "touchmove", taphold_move), 
        fortouch || fdjtDOM.addListener(elt, "mousedown", taphold_down), fortouch || fdjtDOM.addListener(elt, "mouseout", taphold_mouseout), 
        fortouch || fdjtDOM.addListener(elt, "mouseover", taphold_mouseover), fdjtDOM.addListener(elt, "touchstart", taphold_down), 
        fortouch || fdjtDOM.addListener(elt, "mouseup", taphold_up), fdjtDOM.addListener(elt, "touchend", taphold_up), 
        fdjtDOM.addListener(elt, "touchcancel", taphold_cancel), window_setup || (default_opts.fortouch || (fdjtDOM.addListener(window, "mousedown", global_mousedown), 
        fdjtDOM.addListener(window, "mouseup", global_mouseup), fdjtDOM.addListener(window, "mouseout", global_mouseout)), 
        window_setup = window), this.elt = elt, this.serial = serial, this.opts = {
            bubble: bubble,
            override: override,
            movethresh: movethresh,
            holdmsecs: holdmsecs,
            taptapmsecs: taptapmsecs
        }, this.istouched = function() {
            return touched;
        }, this.ispressed = function() {
            return pressed;
        }, this.clear = function() {
            (trace || traceall) && fdjtLog("TapHold/clear(%s) th=%o t=%o p=%o", thid, th_target, touched, pressed), 
            pressed && !noslip && slipped(pressed), pressed_at = touched = pressed = tap_target = !1, 
            cleartouch(!0), setTarget(!1), th_targets = [];
        }, this.fakePress = function(evt, holdmsecs) {
            start_x = target_x = touch_x = evt.clientX || getClientX(evt), start_y = target_y = touch_y = evt.clientY || getClientY(evt), 
            touch_t = start_t = fdjtET();
            var target = document.elementFromPoint(start_x, start_y);
            target || fdjtLog("TapHold(%s): No target from %o,%o", thid, start_x, start_y), 
            setTarget(target), th_targets = [ target ], (trace || traceall) && fdjtLog("TapHold/fakePress(%s) t=%o x=%o y=%o t=%o", thid, th_target, start_x, start_y, start_t), 
            startpress(evt, holdmsecs);
        }, this.abort = abortpress, this.getState = function() {
            return {
                thid: thid,
                elt: elt,
                pressed: pressed,
                touched: touched,
                th_target: th_target,
                th_last: th_last,
                start_x: start_x,
                start_y: start_y,
                start_t: start_t,
                touch_x: touch_x,
                touch_y: touch_y,
                touch_t: touch_t,
                target_x: target_x,
                target_y: target_y,
                th_target_t: th_target_t,
                trace: trace
            };
        }, this.trace = function(flag) {
            var cur = trace;
            return trace = flag === void 0 ? 1 : "number" == typeof flag ? flag : flag ? 2 : 0, 
            cur;
        }, this.debug = function() {}, (trace || traceall) && fdjtLog("New TapHold(%s) for %o: %o opts %j, trace=%o/%o", thid, elt, th, opts || !1, trace, traceall), 
        this;
    }
    function traceTapHold(flag) {
        if (flag === void 0) return traceall;
        var cur = traceall;
        return "number" == typeof flag ? traceall = flag : flag && (traceall = default_opts.traceall || 2), 
        cur;
    }
    var fdjtLog = fdjt.Log, fdjtDOM = fdjt.DOM, fdjtUI = fdjt.UI, fdjtET = fdjt.ET, traceall = 0, window_setup = !1, default_opts = {}, getChildren = fdjtDOM.getChildren, addClass = fdjtDOM.addClass, dropClass = fdjtDOM.dropClass, hasClass = fdjtDOM.hasClass, getParent = fdjtDOM.getParent, hasParent = fdjtDOM.hasParent, reticle = fdjtUI.Reticle, noBubble = fdjtUI.noBubble, noDefault = fdjtUI.noDefault, eTarget = fdjtUI.T, isTextInput = fdjtDOM.isTextInput, cleared = 0, serial_count = 1, keynums = {
        shift: 16,
        alt: 18,
        control: 17,
        meta: 224,
        os: 91,
        altgr: 225,
        fn: -1,
        numlock: 144,
        capslock: 20,
        scrolllock: 145
    }, keynames = {};
    for (var akeyname in keynums) if (keynums.hasOwnProperty(akeyname)) {
        var akeynum = keynums[akeyname];
        "number" == typeof akeynum && akeynum > 0 && (keynames[akeynum] = akeyname);
    }
    var sqrt = Math.sqrt, mouse_down = !1;
    return TapHold.prototype.id = TapHold.prototype.elt = TapHold.prototype.opts = TapHold.prototype.handlers = !1, 
    TapHold.prototype.serial = 0, TapHold.prototype.istouched = TapHold.prototype.ispressed = TapHold.prototype.fakepress = TapHold.prototype.clear = TapHold.prototype.getState = TapHold.prototype.trace = TapHold.prototype.abort = TapHold.prototype.debug = !1, 
    TapHold.clear = function() {
        traceall && fdjtLog("TapHold.clear()"), cleared = fdjtET();
    }, TapHold.trace = traceTapHold, TapHold.default_opts = default_opts, TapHold;
}(), fdjt.UI || (fdjt.UI = {}), fdjt.TextSelect = fdjt.UI.Selecting = fdjt.UI.TextSelect = function() {
    "use strict";
    function position(elt, arr) {
        if (arr.indexOf) return arr.indexOf(elt);
        for (var i = 0, lim = arr.length; lim > i; ) {
            if (arr[i] === elt) return i;
            i++;
        }
        return -1;
    }
    function TextSelect(nodes, opts) {
        if (!(this instanceof TextSelect)) return new TextSelect(nodes, opts);
        if (this.serial = ++serialnum, "string" == typeof nodes) {
            var elt = document.getElementById(nodes);
            if (!elt) return !1;
            this.nodes = nodes = [ elt ];
        } else if (nodes.nodeType) this.nodes = nodes = [ nodes ]; else {
            if (!nodes.length) return !1;
            this.nodes = nodes;
        }
        var sel = this, trace = 0, orig = this.orig = [], wrapped = this.wrapped = [], words = this.words = [], wrappers = this.wrappers = [], tapholds = this.tapholds = [];
        if (opts && opts.hasOwnProperty("trace")) {
            var trace_val = opts.trace;
            trace = "number" == typeof trace_val ? trace_val : trace_val ? 1 : 0;
        }
        this.traced = trace, opts.onstart && (sel.onstart = opts.onstart), opts.onstop && (sel.onstop = opts.onstop);
        var prefix = this.prefix = "fdjtSel0" + this.serial;
        if (opts.loupe || TextSelect.loupe) {
            var spec = opts.loupe || TextSelect.loupe;
            this.loupe = spec.nodeType ? spec : fdjtDOM("span.fdjtselectloupe");
        }
        this.adjust = !1, selectors[prefix] = sel;
        for (var stripid = prefix.length + 1, k = 0, n = nodes.length; n > k; ) {
            var node = nodes[k++], style = getStyle(node), wrapper = "inline" === style.display ? fdjtDOM("span.fdjtselecting") : fdjtDOM("div.fdjtselecting");
            this.loupe && !this.loupe.parentNode && wrapper.appendChild(this.loupe), wrapper.id = prefix + "w" + k, 
            wrapper.title = opts && opts.title || "Tap or hold/drag to move the ends of the text range", 
            selectors[wrapper.id] = sel, wrappers.push(wrapper);
            var th = addHandlers(wrapper, sel, opts);
            alltapholds[wrapper.id] = th, tapholds.push(th), (trace || traceall) && fdjtLog("Created TapHold handler (#%d) for wrapper %s around %o", th.serial, wrapper.id, node), 
            node.parentNode.replaceChild(wrapper, node), orig.push(node), wrapped.push(wrapper), 
            wrapText(node, orig, wrapped, words, prefix), wrapper.appendChild(node);
        }
        return this.start = !1, this.end = !1, this.min = -1, this.max = -1, this.n_words = 0, 
        this.onchange = opts && opts.onchange || !1, this.wordnum = function(target) {
            for (var id = !1; target && 1 !== target.nodeType; ) target = target.parentNode;
            return target && (id = target.id) && "SPAN" === target.tagName && 0 === id.search(prefix) ? parseInt(id.slice(stripid), 10) : !1;
        }, this.startEvent = function(evt, holdmsecs) {
            var target = fdjtUI.T(evt);
            traceall && fdjtLog("startEvent %o, target=%o, wrappers=%o", evt, target, wrappers);
            for (var j = 0, n_wrappers = wrappers.length; n_wrappers > j; ) {
                var wrapper = wrappers[j++];
                if (hasParent(wrapper, target) || hasParent(target, wrapper)) {
                    var taphold = alltapholds[wrapper.id];
                    return (trace || traceall) && fdjtLog("Using TapHold handler @%d for wrapper %s (#%d)", j - 1, wrapper.id, taphold.serial), 
                    taphold.fakePress(evt, holdmsecs), void 0;
                }
            }
        }, this;
    }
    function wrapText(node, orig, wrapped, words, prefix) {
        var i, lim;
        if (3 === node.nodeType) {
            var span, text = node.nodeValue, sliced = mergeSoftHyphens(text.split(/\b/)), wordspans = [];
            for (i = 0, lim = sliced.length; lim > i; ) {
                var word = sliced[i++];
                if (0 !== word.length) if (word.search(/\S/) >= 0 && word.search(/\s/) >= 0) for (var scan = word; scan.length; ) {
                    var space = scan.search(/\s/), notspace = scan.search(/\S/), split = 0 >= space ? notspace : 0 >= notspace ? space : notspace > space ? space : notspace;
                    if (0 >= split && (split = scan.length), split > 0) {
                        var txt = scan.slice(0, split);
                        span = fdjtDOM("span.fdjtword", txt), span.id = prefix + "_" + words.length, words.push(span), 
                        wordspans.push(span);
                    }
                    scan = scan.slice(split);
                } else span = fdjtDOM("span.fdjtword", word), span.id = prefix + "_" + words.length, 
                words.push(span), wordspans.push(span);
            }
            return fdjtDOM("span.fdjtselectwrap", wordspans);
        }
        if (1 !== node.nodeType) return node;
        var classname = node.className;
        if (classname && "string" == typeof classname && ("fdjtselectwrap" === classname || "fdjtskiptext" === node.className || node.className.search(/\bfdjtskiptext\b/) >= 0)) return node;
        var style = getStyle(node);
        if ("" !== style.position && "static" !== style.position) return node;
        var children = node.childNodes;
        if (children) {
            if (0 === children.length) return node;
            if ("fdjtselectwrap" === node.className) return node;
            for (i = 0, lim = children.length; lim > i; ) {
                var child = children[i++], wrap = wrapText(child, orig, wrapped, words, prefix);
                child !== wrap && (orig.push(child), wrapped.push(wrap), node.replaceChild(wrap, child));
            }
            return node;
        }
        return node;
    }
    function mergeSoftHyphens(vec) {
        for (var i = 0, lim = vec.length, out = [], word = !1; lim > i; ) {
            var wd = vec[i++];
            if ("" === wd) if (word) {
                var nxt = vec[i];
                nxt ? (word = word + wd + nxt, i++) : word += wd;
            } else word = wd; else word && out.push(word), word = wd;
        }
        return word && out.push(word), out;
    }
    function selectWords(words, start, end) {
        for (var i = start; end >= i; ) words[i++].className = "fdjtselected";
    }
    function deselectWords(words, start, end) {
        for (var i = start; end >= i; ) words[i++].className = "fdjtword";
    }
    function startSelection(sel) {
        sel.active || (sel.active = !0, sel.onstart && sel.onstart());
    }
    function stopSelection(sel) {
        sel.active && (sel.active = !1, sel.onstop && sel.onstop());
    }
    function overWord(word, tapped, sel) {
        for (var id = !1; word && 1 !== word.nodeType; ) word = word.parentNode;
        if (!hasParent(word, ".fdjtselectloupe")) {
            if (sel.active || startSelection(sel), !sel && word && (id = word.id) && "SPAN" === word.tagName && 0 === id.search("fdjtSel")) {
                var split = id.indexOf("_");
                split && (sel = selectors[id.slice(0, split)]);
            }
            if (!sel) {
                for (var container = word; container && !(container.className && container.id && "string" == typeof container.className && container.className.search(/\bfdjtselecting\b/) >= 0); ) container = container.parentNode;
                if (!container) return !1;
                sel = selectors[container.id];
            }
            if (!sel) return !1;
            if ((traceall || sel.traced) && fdjtLog("overWord %o, sel=%o, tapped=%o, adjust=%o, anchor=%o", word, sel, tapped, sel.adjust, sel.anchor), 
            tapped) useWord(word, sel, !0); else if (sel.word) useWord(word, sel); else if (hasClass(word, "fdjtselectstart") || hasClass(word, "fdjtselectend")) sel.timeout && (clearTimeout(sel.timeout), 
            sel.timeout = !1), sel.pending = !1, sel.word = word, useWord(word, sel); else {
                if (sel.pending === word) return !0;
                if (!word.offsetParent) return !1;
                sel.timeout && clearTimeout(sel.timeout), updateLoupe(word, sel, !1), sel.word = !1, 
                sel.pending = word, sel.timeout = setTimeout(function() {
                    sel.pending === word && (sel.timeout && clearTimeout(sel.timeout), sel.word = word, 
                    sel.pending = !1, useWord(word, sel));
                }, 100);
            }
            return !0;
        }
    }
    function useWord(word, sel, tapped) {
        var start = sel.start, end = sel.end;
        if (word.offsetParent) {
            if (sel.start) if (sel.anchor) start = sel.anchor, end = word; else if (sel.start === sel.end) start = sel.start, 
            end = word; else {
                var off = sel.wordnum(word);
                if ("start" === sel.adjust && off > sel.max) return;
                if ("end" === sel.adjust && sel.min > off) return;
                if ("start" === sel.adjust) start = word; else if ("end" === sel.adjust) end = word; else if (start === word) sel.setAdjust("start"); else if (end === word) sel.setAdjust("end"); else if (sel.min >= off) start = word, 
                sel.setAdjust("start"); else if (off >= sel.max) end = word, sel.setAdjust("end"); else if (6 > off - sel.min) start = word, 
                sel.setAdjust("start"); else if (6 > sel.max - off) end = word, sel.setAdjust("end"); else {
                    if (tapped) return;
                    off - sel.min > (sel.max - sel.min) / 2 ? (end = word, sel.setAdjust("end")) : (start = word, 
                    sel.setAdjust("start"));
                }
            } else {
                var initial = initSelect(word);
                start = initial.start, end = initial.end;
            }
            rAF(function() {
                sel.setRange(start, end), sel.loupe && updateLoupe(word, sel, tapped);
            });
        }
    }
    function nodeSearch(node, pat) {
        if (3 === node.nodeType) return node.nodeValue.search(pat) >= 0;
        if (1 === node.nodeType) {
            for (var children = node.childNodes, i = 0, lim = children ? children.length : 0; lim > i; ) {
                var child = children[i++];
                if (3 === child.nodeType) {
                    if (child.nodeValue.search(pat) >= 0) return child;
                } else if (1 === child.nodeType && nodeSearch(child, pat)) return child;
            }
            return !1;
        }
        return !1;
    }
    function initSelect(word) {
        var scan, last, begin = word, end = word;
        if (!nodeSearch(word, /"\(\[\{/)) {
            for (last = begin, scan = begin.previousSibling; scan; ) if (1 === scan.nodeType && hasClass(scan, "fdjtword")) {
                if (nodeSearch(scan, /["\(\[\{]/)) {
                    begin = scan;
                    break;
                }
                if (nodeSearch(scan, /[.;!?]/)) {
                    begin = last;
                    break;
                }
                last = scan, scan = scan.previousSibling;
            } else scan = scan.previousSibling;
            scan || (begin = last);
        }
        if (nodeSearch(word, /[.;!?]/)) end = word; else {
            for (last = end, scan = end.nextSibling; scan; ) if (1 === scan.nodeType && hasClass(scan, "fdjtword")) {
                if (nodeSearch(scan, /[".;!?]/)) {
                    end = scan;
                    break;
                }
                last = scan, scan = scan.nextSibling;
            } else scan = scan.nextSibling;
            scan || (end = last);
        }
        return {
            start: begin,
            end: end
        };
    }
    function updateLoupe(word, sel, tapped) {
        var parent = word.parentNode, loupe = sel.loupe;
        if (loupe) {
            var inline_loupe = hasParent(loupe, ".fdjtselecting");
            if (sel.loupe_timeout && (clearTimeout(sel.loupe_timeout), sel.loupe_timeout = !1), 
            word.offsetParent) {
                for (var block = word.parentNode; block && "inline" === getStyle(block).display; ) block = block.parentNode;
                (traceall || sel.traced) && fdjtLog("updateLoupe(%d) over %o for %o%s", sel.serial, word, sel, tapped ? " (tapped)" : "");
                var context = hasClass(word, "fdjtselectend") ? gatherContext(word, 7, 3, block) : gatherContext(word, 3, 7, block), words = fdjtDOM("span.fdjtloupetext");
                loupe.innerHTML = "", fdjtDOM.append(words, context.words), fdjtDOM.append(loupe, words), 
                inline_loupe && parent.insertBefore(loupe, word), loupe.style.display = "", tapped && setTimeout(function() {
                    sel.active && stopSelection(sel), sel.loupe.style.display = "none";
                }, 1e3);
            }
        }
    }
    function gatherContext(node, back, forward, parent) {
        var id = node.id, parsed = id && /(fdjtSel\d+_)(\d+)/.exec(id);
        if (parsed && 3 === parsed.length) {
            var prefix = parsed[1], count = parseInt(parsed[2], 10), start = count - back, end = count + forward;
            0 > start && (start = 0);
            for (var wordstart, wordend, context = [], width = 0, start_geom = getGeometry(node), i = start; end > i; ) {
                var elt = document.getElementById(prefix + i);
                if (!elt || parent && !hasParent(elt, parent)) i++; else {
                    if (1 === elt.nodeType) {
                        var geom = getGeometry(elt);
                        if (start_geom.top > geom.bottom || geom.top >= start_geom.bottom) {
                            i++;
                            continue;
                        }
                        var clone = elt.cloneNode(!0);
                        stripIDs(clone), count > i ? width += elt.offsetWidth : i === count ? (wordstart = width, 
                        width = wordend = width + elt.offsetWidth) : width += elt.offsetWidth, elt === node && fdjtDOM.addClass(clone, "fdjtselected"), 
                        context.push(clone);
                    } else context.push(elt.cloneNode(!0));
                    i++;
                }
            }
            return {
                words: context,
                width: width,
                wordstart: wordstart,
                wordend: wordend
            };
        }
    }
    function getSelector(word) {
        var id = !1;
        if (word && (id = word.id) && "SPAN" === word.tagName && 0 === id.search("fdjtSel")) {
            var split = id.indexOf("_");
            return split ? selectors[id.slice(0, split)] || !1 : !1;
        }
        return !1;
    }
    function hold_handler(evt) {
        evt = evt || window.event;
        for (var target = fdjtUI.T(evt); target && 1 !== target.nodeType; ) target = target.parentNode;
        for (;target; ) {
            if (target && target.id && "SPAN" === target.tagName && 0 === target.id.search("fdjtSel")) {
                var sel = getSelector(target);
                !sel || sel.anchor || sel.start || (sel.anchor = target), (traceall || sel && sel.traced) && fdjtLog("TextSelect/hold %o t=%o sel=%o", evt, target, sel), 
                overWord(target, !1, sel), fdjtUI.cancel(evt);
                break;
            }
            if (1 !== target.nodeType) break;
            target = target.parentNode;
        }
    }
    function tap_handler(evt) {
        evt = evt || window.event;
        for (var target = fdjtUI.T(evt); target && 1 !== target.nodeType; ) target = target.parentNode;
        for (;target; ) {
            if (target && target.id && "SPAN" === target.tagName && 0 === target.id.search("fdjtSel")) {
                var sel = getSelector(target);
                (traceall || sel && sel.traced) && fdjtLog("TextSelect/tap %o t=%o sel=%o", evt, target, sel), 
                1 === sel.n_words ? sel.setRange(!1) : "fdjtselectstart" === target.className || "fdjtselectend" === target.className ? (fdjtUI.cancel(evt), 
                sel.setRange(target, target)) : overWord(target, !0, sel) ? (sel.adjust = "fdjtselectstart" === target.className ? "start" : "fdjtselectend" === target.className ? "end" : !1, 
                fdjtUI.cancel(evt)) : sel && (sel.adjust = !1);
                break;
            }
            if (1 !== target.nodeType) break;
            target = target.parentNode;
        }
    }
    function release_handler(evt, sel) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        (traceall || sel && sel.traced) && fdjtLog("TextSelect/release %o t=%o sel=%o", evt, target, sel), 
        sel && (sel.anchor = !1, sel.word = !1, sel.pending = !1, sel.timeout && (clearTimeout(sel.timeout), 
        sel.timeout = !1), sel.setAdjust(!1), sel.loupe && (sel.loupe.style.display = "none"), 
        sel.active && stopSelection(sel));
    }
    function slip_handler(evt, sel) {
        evt = evt || window.event;
        var target = fdjtUI.T(evt);
        (traceall || sel && sel.traced) && fdjtLog("TextSelect/slip %o t=%o sel=%o", evt, target, sel), 
        sel && sel.loupe && (sel.loupe_timeout = setTimeout(function() {
            sel.loupe_timeout = !1, sel.active && stopSelection(sel), sel.loupe.style.display = "none";
        }, 2e3));
    }
    function get_release_handler(sel, also) {
        return function(evt) {
            release_handler(evt, sel), also && also(evt, sel);
        };
    }
    function get_slip_handler(sel, also) {
        return function(evt) {
            slip_handler(evt, sel), also && also(evt, sel);
        };
    }
    function addHandlers(container, sel, opts) {
        opts || (opts = {}), opts.override = !0, opts.touchable = ".fdjtword,.fdjtselected,.fdjtselectstart,.fdjtselectend";
        var taphold = new fdjtUI.TapHold(container, opts);
        return fdjtDOM.addListener(container, "tap", opts && opts.ontap || tap_handler), 
        fdjtDOM.addListener(container, "hold", opts && opts.onhold || hold_handler), fdjtDOM.addListener(container, "release", get_release_handler(sel, opts.onrelease || !1)), 
        fdjtDOM.addListener(container, "slip", get_slip_handler(sel, opts.onslip || !1)), 
        taphold;
    }
    var fdjtDOM = fdjt.DOM, fdjtLog = fdjt.Log, fdjtUI = fdjt.UI, hasParent = fdjtDOM.hasParent, stripIDs = fdjtDOM.stripIDs, getStyle = fdjtDOM.getStyle, textify = fdjtDOM.textify, hasClass = fdjtDOM.hasClass, swapClass = fdjtDOM.swapClass, dropClass = fdjtDOM.dropClass, rAF = fdjtDOM.requestAnimationFrame, selectors = {}, alltapholds = {}, serialnum = 0, traceall = 0;
    TextSelect.prototype.serial = TextSelect.prototype.traced = TextSelect.prototype.adjust = TextSelect.prototype.n_words = TextSelect.prototype.start = TextSelect.prototype.end = TextSelect.prototype.min = TextSelect.prototype.max = 0, 
    TextSelect.prototype.prefix = TextSelect.prototype.traced = 0, TextSelect.prototype.nodes = TextSelect.prototype.orig = TextSelect.prototype.wrapped = TextSelect.prototype.wrappers = TextSelect.prototype.words = TextSelect.prototype.tapholds = TextSelect.prototype.loupe = [], 
    TextSelect.prototype.onchange = TextSelect.prototype.wordnum = TextSelect.prototype.startEvent = !1, 
    TextSelect.prototype.toString = function() {
        for (var wrappers = this.wrappers, output = "TextSelect([" + this.min + ("start" === this.adjust ? "*" : "") + "," + this.max + ("end" === this.adjust ? "*" : "") + "],", i = 0, lim = wrappers.length; lim > i; ) {
            var id = wrappers[i].id;
            id && (output = output + (i > 0 ? "," : "") + "'" + wrappers[i].id + "'"), i++;
        }
        return output += ")";
    }, TextSelect.prototype.setRange = function(start, end) {
        var trace = this.trace;
        if ((trace || traceall) && fdjtLog("TextSelect.setRange %o %o for %o", start, end, this), 
        !start) return this.start && this.end && deselectWords(this.words, this.min, this.max), 
        this.start = this.end = !1, this.min = this.max = -1, this.n_words = 0, this.onchange && this.onchange(), 
        void 0;
        var words = this.words, min = this.wordnum(start), max = this.wordnum(end);
        if (min > max) {
            var tmp = start;
            start = end, end = tmp, tmp = min, min = max, max = tmp;
        }
        if (this.start) {
            if (this.start === start && this.end === end) return;
            var cur_min = this.wordnum(this.start), cur_max = this.wordnum(this.end);
            min > cur_max || cur_min > max ? (deselectWords(words, cur_min, cur_max), selectWords(words, min, max)) : (cur_min > min ? selectWords(words, min, cur_min) : min > cur_min && deselectWords(words, cur_min, min), 
            max > cur_max ? selectWords(words, cur_max, max) : cur_max > max && deselectWords(words, max, cur_max)), 
            words[max].className = "fdjtselectend", words[min].className = "fdjtselectstart";
        } else selectWords(words, min, max), words[max].className = "fdjtselectend", words[min].className = "fdjtselectstart";
        this.min = min, this.max = max, this.start = start, this.end = end, this.n_words = max - min + 1, 
        this.onchange && this.onchange();
    };
    var getGeometry = fdjtDOM.getGeometry;
    return TextSelect.getSelector = getSelector, TextSelect.prototype.setString = function(string) {
        var wrappers = this.wrappers, whole = 1 === wrappers.length && wrappers[0];
        if (!whole) {
            whole = fdjtDOM("div");
            for (var i = 0, lim = wrappers.length; lim > i; ) {
                var wrapper = wrappers[i++];
                whole.appendChild(wrapper.cloneNode(!0));
            }
        }
        var found = fdjtDOM.findMatches(whole, string, 0, 1);
        if (found && 0 !== found.length) {
            found = found[0];
            for (var start = found.startContainer, end = found.endContainer; start && 1 !== start.nodeType; ) start = start.parentNode;
            for (;end && 1 !== end.nodeType; ) end = end.parentNode;
            start && end && start.id && end.id && 0 === start.id.search(this.prefix) && 0 === end.id.search(this.prefix) && (start = document.getElementById(start.id), 
            end = document.getElementById(end.id), start && end && this.setRange(start, end));
        }
    }, TextSelect.prototype.getString = function(start, end, rawtext) {
        start || (start = this.start), end || (end = this.end);
        for (var wrappers = this.wrappers, combine = [], prefix = this.prefix, wpos = -1, scan = start; scan; ) {
            if (rawtext) ; else if (1 === scan.nodeType) {
                var style = getStyle(scan);
                "static" === style.position && "inline" !== style.display && "none" !== style.display && combine.push("\n");
            }
            if (1 === scan.nodeType && "SPAN" === scan.tagName && scan.id && 0 === scan.id.search(prefix)) {
                var txt = scan.innerText || textify(scan);
                if (combine.push(txt.replace("", "")), scan === end) break;
            }
            if (scan.firstChild && "fdjtselectloupe" !== scan.className && 3 !== scan.firstChild.nodeType) scan = scan.firstChild; else if (scan.nextSibling) scan = scan.nextSibling; else {
                for (;scan && !((wpos = position(scan, wrappers)) >= 0); ) {
                    if (scan.nextSibling) {
                        scan = scan.nextSibling;
                        break;
                    }
                    scan = scan.parentNode;
                }
                wpos >= 0 && wrappers.length > wpos + 1 && (scan = wrappers[wpos + 1]);
            }
            if (!scan) break;
        }
        return combine.join("");
    }, TextSelect.prototype.getOffset = function(under) {
        if (!this.start) return !1;
        var first_word = this.words[0];
        if (under) {
            var words = this.words, i = 0, lim = words.length;
            if (!hasParent(this.start, under) || !hasParent(this.end, under)) return !1;
            for (;lim > i && !hasParent(first_word, under); ) first_word = words[i++];
        }
        var selected = this.getString(!1, !1, !0), preselected = this.getString(first_word, this.end, !0);
        return preselected.length - selected.length;
    }, TextSelect.prototype.getInfo = function(under) {
        var trace = this.traced;
        if (!this.start) return !1;
        var selected = this.getString(), first_word = this.words[0];
        if (under) {
            var words = this.words, i = 0, lim = words.length;
            if (!hasParent(this.start, under) || !hasParent(this.end, under)) return !1;
            for (;lim > i && !hasParent(first_word, under); ) first_word = words[i++];
        }
        var rawselect = this.getString(!1, !1, !0), preselected = this.getString(first_word, this.end, !0);
        return (trace || traceall) && fdjtLog("GetInfo %o: start=%o, end=%o, off=%o, string=%o", this, this.start, this.end, preselected.length - rawselect.length, selected), 
        {
            start: this.start,
            end: this.end,
            off: preselected.length - rawselect.length,
            string: selected
        };
    }, TextSelect.prototype.setAdjust = function(val) {
        var trace = this.traced;
        (traceall || trace) && fdjtLog("TextSelect.setAdjust %o for %o", val, this), val ? (this.adjust = val, 
        swapClass(this.nodes, /\b(fdjtadjuststart|fdjtadjustend)\b/, "fdjtadjust" + val)) : (this.adjust = !1, 
        dropClass(this.nodes, /\b(fdjtadjuststart|fdjtadjustend)\b/));
    }, TextSelect.prototype.clear = function() {
        var wrappers = this.wrappers, orig = this.orig, wrapped = this.wrapped;
        if (orig) {
            for (var i = orig.length - 1; i >= 0; ) {
                var o = orig[i], w = wrapped[i];
                i--, w.parentNode.replaceChild(o, w);
            }
            for (var j = 0, lim = wrappers.length; lim > j; ) {
                var wrapper = wrappers[j++];
                delete alltapholds[wrapper.id], delete selectors[wrapper.id];
            }
            if (this.onclear) {
                var onclear = this.onclear;
                for (this.onclear = !1, Array.isArray(onclear) || (onclear = [ onclear ]), i = 0, 
                lim = onclear.length; lim > i; ) onclear[i++]();
            }
            delete selectors[this.prefix], delete this.wrapped, delete this.orig, delete this.wrappers, 
            delete this.nodes, delete this.words, delete this.wrappers, delete this.start, delete this.end;
        }
    }, TextSelect.hold_handler = hold_handler, TextSelect.handler = hold_handler, TextSelect.tap_handler = tap_handler, 
    TextSelect.release_handler = release_handler, TextSelect.trace = function(flag, thtoo) {
        return flag === void 0 ? traceall : (traceall = "number" == typeof flag ? flag : flag ? 1 : 0, 
        thtoo && fdjt.TapHold.trace(thtoo), void 0);
    }, TextSelect;
}(), function() {
    "use strict";
    fdjt.useGlobals = fdjt.dbg = function(cxt) {
        var names = [ "fdjtDOM", "fdjtUI", "fdjtTime", "fdjtString", "fdjtState", "fdjtLog", "fdjtHash", "fdjtAjax", "fdjtAsync", "fdjtInit", "fdjtDialog", "fdjtTemplate", "fdjtID", "fdjtRef", "fdjtTapHold", "fdjtSelecting", "fdjtTextIndex", "fdjtRefDB", "TextIndex", "RefDB", "CodexLayout", "pageShow" ];
        if (cxt || (cxt = window), !cxt) return fdjt.Log("Nowhere to put globals"), void 0;
        for (var i = 0, n = names.length; n > i; ) {
            var name = names[i++], fname = 0 === name.search("fdjt") ? name.slice(4) : name;
            fdjt[fname] && !cxt[name] && (fdjt.Log("%s = fdjt.%s", name, fname), cxt[name] = fdjt[fname]);
        }
        return n;
    };
}(), function(win, docEl) {
    "use strict";
    function addWinEvent(type, fn) {
        win.addEventListener ? addEventListener(type, fn, !1) : win.attachEvent("on" + type, fn);
    }
    function debounce(fn) {
        var timeout;
        return function() {
            function delayed() {
                fn.apply(obj, args), timeout = null;
            }
            var obj = this, args = arguments;
            timeout && clearTimeout(timeout), timeout = setTimeout(delayed, _debounceRate);
        };
    }
    function onResize() {
        var currentSize = /^device$/i.test(_from + "") ? win.orientation && 180 !== win.orientation ? screen.height : screen.width : /^browser$/i.test(_from + "") ? docEl.clientWidth : _from instanceof String ? Function("return " + _from)() : parseInt(_from, 10) || 0, docElClassNames = docEl.className.replace(/^\s+|(^|\s)(gt|is|lt)[^\s]+|\s+$/g, "").split(/\s+/), classNames = [], i = -1, arr = _sizes, len = arr.length;
        for (arr.sort(function(a, b) {
            return a - b;
        }); len > ++i && !(arr[i] > currentSize); ) ;
        for (currentSize = arr[Math.max(Math.min(--i, len - 1), 0)], i = -1; len > ++i; ) classNames.push((currentSize > arr[i] ? "gt" : arr[i] > currentSize ? "lt" : "is") + (_names[arr[i]] || arr[i]));
        docEl.className = (docElClassNames[0] ? docElClassNames : []).concat(classNames).join(" "), 
        _callback && _callback(currentSize);
    }
    var _callback, _sizes = [], _names = {}, _from = "browser", _debounceRate = 50;
    win.syze = {
        sizes: function() {
            return _sizes = [].concat.apply([], arguments), onResize(), this;
        },
        names: function(val) {
            return val instanceof Object && (_names = val, onResize()), this;
        },
        from: function(val) {
            return _from = val, onResize(), this;
        },
        debounceRate: function(val) {
            return _debounceRate = parseInt(val, 10) || 0, onResize(), this;
        },
        callback: function(val) {
            return val instanceof Function && (_callback = val, onResize()), this;
        }
    }, addWinEvent("resize", debounce(onResize)), addWinEvent("orientationchange", onResize), 
    onResize();
}(this, document.documentElement), fdjt.UI || (fdjt.UI = {}), fdjt.ScrollEver = fdjt.UI.ScrollEver = function() {
    "use strict";
    function fdjtScrollEver(spec) {
        function getMoreResults() {
            if (!busy) {
                if (!url || !container || off >= limit) return timer && clearTimeout(timer), fdjtDOM.addClass(document.body, "scrolleverdone"), 
                void 0;
                busy = !0;
                var call = url.replace("-off-", fdjtString(0 > off ? 0 : off)), req = new XMLHttpRequest();
                req.open("GET", call, !0), req.withCredentials = !0, req.onreadystatechange = function() {
                    if (4 === req.readyState && 200 === req.status) {
                        fdjtScrollEver.debug && fdjtLog("fdjtScrollEver getMoreResults (response)");
                        var tbl = fdjtDOM(container.tagName), htmltext = req.responseText;
                        try {
                            tbl.innerHTML = htmltext;
                        } catch (ex) {
                            var span = document.createElement("span");
                            span.style.display = "none", span.innerHTML = "<" + container.tagName + ">" + htmltext + "</" + container.tagName + ">", 
                            tbl = span.childNodes[0];
                        }
                        for (var add = [], children = tbl.childNodes, i = 0, lim = children.length, seenids = {}; lim > i; ) {
                            var child = children[i++];
                            1 === child.nodeType && child.id ? document.getElementById(child.id) || seenids[child.id] || add.push(child) : add.push(child), 
                            child.id && (seenids[child.id] = child.id);
                        }
                        fdjtDOM(container, add), off += win;
                        var iscroll = spec.iscroll || window.iscroller || !1;
                        iscroll && setTimeout(function() {
                            iscroll.refresh();
                        }, 10), busy = !1;
                    }
                }, fdjtScrollEver.debug && fdjtLog("fdjtScrollEver getMoreResults (call)"), req.send(null);
            }
        }
        function scrollChecker() {
            if (!busy) if (wrapper) {
                var top = wrapper.scrollTop, sh = wrapper.scrollHeight, oh = wrapper.offsetHeight;
                (oh >= sh || top + 2 * oh >= sh) && getMoreResults();
            } else {
                var iscroll = spec.iscroll || window.iscroller || !1, page_height = iscroll ? iscroll.scrollerH : document.documentElement.scrollHeight, scroll_pos = iscroll ? -iscroll.y : window.pageYOffset;
                iscroll || "number" == typeof scroll_pos || (scroll_pos = document.documentElement.scrollTop);
                var client_height = iscroll ? iscroll.wrapperH : document.documentElement.clientHeight;
                (thresh > page_height - (scroll_pos + client_height) || client_height > page_height) && getMoreResults();
            }
        }
        var busy = !1, timer = !1;
        spec || (spec = {});
        var url = spec.url || fdjtDOM.getLink("~{http://fdjt.org/}scrollfetch") || fdjtDOM.getLink("~SCROLLFETCH"), off = spec.off || fdjtState.getQuery("OFF") || fdjtDOM.getMeta("~{http://fdjt.org/}scrolloffset") || fdjtDOM.getMeta("~SCROLLOFFSET") || -1, win = spec.win || fdjtState.getQuery("WINDOW") || fdjtDOM.getMeta("~{http://fdjt.org/}scrollwindow") || fdjtDOM.getMeta("~SCROLLWINDOW") || 7, limit = spec.limit || fdjtState.getQuery("LIMIT") || fdjtDOM.getMeta("~{http://fdjt.org/}scrollmax") || fdjtDOM.getMeta("~scrollmax") || 7, container = spec.container || fdjtDOM.getMeta("~{http://fdjt.org/}scrollelement") || fdjtDOM.getMeta("~scrollelement") || "FDJTSCROLLCONTAINER";
        if ("string" == typeof container) {
            if (!fdjtID(container)) return fdjtLog.warn("No container %s", container), void 0;
            container = fdjtID(container);
        }
        var wrapper = spec.wrapper || fdjtDOM.getMeta("~{http://fdjt.org/}scrollwrapper") || fdjtDOM.getMeta("~scrollwrapper") || "FDJTSCROLLWRAPPER";
        "string" == typeof wrapper && (fdjtID(wrapper) ? wrapper = fdjtID(wrapper) : (fdjtLog.warn("No wrapper %s", container), 
        wrapper = !1));
        var thresh = spec.thresh || fdjtDOM.getMeta("~{http://fdjt.org/}scrollthresh") || fdjtDOM.getMeta("~scrollthresh") || 100, interval = spec.interval || fdjtDOM.getMeta("~{http://fdjt.org/}scrollinterval") || fdjtDOM.getMeta("~scrollinterval") || 500;
        return "number" != typeof off && (off = parseInt(off, 10)), "number" != typeof win && (win = parseInt(win, 10)), 
        "number" != typeof limit && (limit = parseInt(limit, 10)), "number" != typeof thresh && (thresh = parseInt(thresh, 10)), 
        "number" != typeof interval && (interval = parseInt(interval, 10)), fdjtScrollEver.debug && (fdjtLog("fdjtScrollEver called: %o/%o+%o, fetch=%s", off, limit, win, url), 
        fdjtLog("fdjtScrollEver scrolling on %opx, checking every %ous on %o", thresh, interval, container)), 
        timer = setInterval(scrollChecker, interval);
    }
    var fdjtDOM = fdjt.DOM, fdjtID = fdjt.ID, fdjtState = fdjt.State, fdjtString = fdjt.String, fdjtLog = fdjt.Log;
    return fdjtScrollEver;
<<<<<<< HEAD
}(), fdjt.revision = "1.5-1567-g1b90c0d", fdjt.buildhost = "moby.dc.beingmeta.com", 
fdjt.buildtime = "Sat Mar 12 13:41:47 EST 2016", fdjt.builduuid = "c05cc793-9c27-48d0-99ef-d4eb522b8e8d";
=======
}(), fdjt.revision = "1.5-1567-g1b90c0d", fdjt.buildhost = "Venus", fdjt.buildtime = "Fri Mar 11 19:24:11 EST 2016", 
fdjt.builduuid = "d8e27f07-1e77-4bbb-aa69-7451f6c801f7";
>>>>>>> 6eeda5207675b2d9d4ded33c282fcf16652133ce
//@ sourceMappingURL=fdjt.min.map