/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file was created from several component files, some of
      which have different restrictions.

   For purposes of inclusion of this code in non-commercial web documents,
     use and redistribution of this file is permitted under the terms of
     the Creative Commons "Attribution-NonCommercial" license:
          http://creativecommons.org/licenses/by-nc/3.0/ 

   For all other purposes, the contents of this file are licensed
    under the terms of the nearest preceding copyright notice.  The
    copyright notices of the individual files are all prefixed by
    a line of the form "Copyright (C) ...".

    Other uses may be allowed based on prior agreement with
      beingmeta, inc.  Inquiries can be addressed to:

       licensing@biz.beingmeta.com

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

*/

// FDJT build information
var fdjt_revision='1.5-474-g6e3c650';
var fdjt_buildhost='sliver.beingmeta.com';
var fdjt_buildtime='Wed Dec 19 10:38:32 PST 2012';
var fdjt_builduuid='F6CDEC1A-0232-4C39-B052-5D472D695FBD';

/* -*- Mode: Javascript; -*- */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file was created from several component files and is
   part of the FDJT web toolkit (www.fdjt.org)

   Portions of this code are available under the following license:
   * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
   * Released under MIT license, http://cubiq.org/license

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   The copyright notice of the individual files are all prefixed by
   a copyright notice of the form "Copyright (C) ...".

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

var fdjt_versions=((fdjt_versions)||(new Array()));
fdjt_versions.decl=function(name,num){
    if ((!(fdjt_versions[name]))||(fdjt_versions[name]<num)) fdjt_versions[name]=num;};

// Some augmentations
if (!(Array.prototype.indexOf))
    Array.prototype.indexOf=function(elt,i){
	if (!(i)) i=0; var len=this.length;
	while (i<len) if (this[i]===elt) return i; else i++;
	return -1;};
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
    Object.keys = function(o){
	if (o !== Object(o))
            throw new TypeError('Object.keys called on non-object');
	var ret=[], p;
	for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) ret.push(p);
	return ret;}};

if (!String.prototype.trim) {
    String.prototype.trim = (function () {
	var trimLeft  = /^\s+/, trimRight = /\s+$/;
	    
	return function () {
	    return this.replace(trimLeft, "").replace(trimRight, "")
	}
    })()};

var fdjt=((typeof fdjt === "undefined")?({}):(fdjt));

/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/string.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.String=
    (function(){
        function fdjtString(string){
            if ((typeof string !== 'string')&&
                (!(string instanceof String)))
                return stringify(string);
            var output="";
            var cmd=string.indexOf('%'); var i=1;
            while (cmd>=0) {
                if (cmd>0) output=output+string.slice(0,cmd);
                if (string[cmd+1]==='%') output=output+'%';
                else if (string[cmd+1]==='o') {
                    var arg=arguments[i++];
                    if (typeof arg === 'string')
                        output=output+"'"+arg+"'";
                    else if (typeof arg === 'number')
                        output=output+arg;
                    else output=output+stringify(arg);}
                else if (string[cmd+1]==='j') {
                    var arg=arguments[i++];
                    output=output+JSON.stringify(arg);}
                else if ((string[cmd+1]==='x')&&
                         (typeof arguments[i] === 'number')&&
                         (arguments[i]>=0)&&
                         ((arguments[i]%1)>=0)) {
                    var arg=arguments[i++];
                    output=output+arg.toString(16);}
                else if (arguments[i])
                    output=output+arguments[i++];
                else if (typeof arguments[i] === 'undefined') {
                    output=output+'?undef?'; i++;}
                else output=output+arguments[i++];
                string=string.slice(cmd+2);
                cmd=string.indexOf('%');}
            output=output+string;
            return output;}

        fdjtString.revid="$Id$";
        fdjtString.version=parseInt("$Revision$".slice(10,-1));

        fdjtString.nbsp="\u00A0";
        fdjtString.middot="\u00B7";
        fdjtString.emdash="\u2013";
        fdjtString.endash="\u2014";
        fdjtString.lsq="\u2018";
        fdjtString.rsq="\u2019";
        fdjtString.ldq="\u201C";
        fdjtString.rdq="\u201D";

        function stringify(arg){
            if (typeof arg === 'undefined') return '?undef?';
            else if (!(arg)) return arg;
            else if (typeof arg === 'number') return ""+arg;
            else if (arg.tagName) {
                var output="["+arg.tagName;
                if (arg.className)
                    output=output+"."+arg.className.replace(/\s+/g,'.');
                if (arg.id) output=output+"#"+arg.id;
                if (arg.name) output=output+"[name="+arg.name+"]";
                return output+"]";}
            else if (arg.nodeType) {
                if (arg.nodeType===3)
                    return '["'+arg.nodeValue+'"]';
                else return '<'+arg.nodeType+'>';}
            else if (arg.oid) return arg.oid;
            else if (arg._fdjtid) return '#@'+arg._fdjtid;
            else if ((arg.type)&&((arg.target)||arg.srcElement)) {
                var target=arg.target||arg.srcElement;
                var ox=arg.clientX, oy=arg.clientY;
                var result="["+arg.type+"@"+stringify(target)+"(m="+
                    (((arg.shiftKey===true)?"s":"")+
                     ((arg.ctrlKey===true)?"c":"")+
                     ((arg.metaKey===true)?"m":"")+
                     ((arg.altKey===true)?"a":"")+
                     "b="+(arg.button)+",w="+(arg.which));
                if ((typeof ox === "number")||(typeof oy === "number"))
                    result=result+",cx="+ox+",cy="+oy;
                if (arg.touches) {
                    var i=0; var n=arg.touches.length;
                    result=result+",touches="+n;}
                if (arg.keyCode) result=result+",kc="+arg.keyCode;
                if (arg.charCode) result=result+",cc="+arg.charCode;
                return result+")]";}
            else return ""+arg;}

        var spacechars=" \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff";

        fdjtString.truncate=function(string,lim){
            if (!(lim)) lim=42;
            if (string.length<lim) return string;
            else return string.slice(0,lim);}

        var floor=Math.floor;

        function ellipsize(string,lim,fudge){
            var before, after;
            if (typeof fudge !== 'number') fudge=0.1;
            if (!(lim)) return string;
            else if (typeof lim === "number") {}
            else if (lim.constructor === Array) {
                before=lim[0]||0; after=lim[1]||0; lim=after+before;}
            else return string;
            if (!(lim)) return string;
            else if (string.length<(lim+floor(fudge*lim)))
                return string;
            else if ((before)&&(after)) {
                var len=string.length;
                var start, end; // of the elided text
                if (/\s/.test(string[before])===0) 
                    start=before;
                else {
                    var chopped=string.slice(0,before);
                    var broke=chopped.search(/\s+\w+$/);
                    if (broke>0) start=broke; else start=before;}
                if (/\s/.test(string[len-after])===0) end=len-after;
                else {
                    var chopped=string.slice(len-after);
                    var broke=chopped.search(/\s+/);
                    if (broke>0) end=(len-after)+broke;
                    else end=after;}
                return [string.slice(0,start),string.slice(end)];}
            else {
                var edge=string[lim];
                if (/\s/.test(edge)===0) 
                    return string.slice(0,lim);
                else {
                    var chopped=string.slice(0,lim);
                    var broke=chopped.search(/\s+\w+$/);
                    if (broke>0) return chopped.slice(0,broke);
                    else return chopped;}}}
        fdjtString.ellipsize=ellipsize;
                

        fdjtString.isEmpty=function(string){
            if (typeof string === "string")  {
                var i=0; var lim=string.length;
                if (lim===0) return true;
                while (i<lim) {
                    if (spacechars.indexOf(string[i])>=0) i++;
                    else return false;}
                return true;}
            else return false;}

        fdjtString.findSplit=function(string,split,escape){
            var start=0;
            var next;
            while ((next=string.indexOf(split,start))>=0) 
                if ((escape) && (next>0) && (string[next-1]===escape))
                    start=next+1;
            else return next;
            return -1;};

        fdjtString.split=function(string,split,escape,mapfn){
            if ((mapfn) || (escape)) {
                var results=[];
                var start=0; var next;
                while ((next=string.indexOf(split,start))>=0) 
                    if ((escape) && (next>0) && (string[next-1]===escape))
                        start=next+1;
                else if ((mapfn) && (next>start)) {
                    results.push(mapfn(string.slice(start,next))); start=next+1;}
                else if (next>start) {
                    results.push(string.slice(start,next)); start=next+1;}
                else start=next+1;
                if (string.length>start)
                    if (mapfn) results.push(mapfn(string.slice(start)));
                else results.push(string.slice(start));
                return results;}
            else return string.split(split);};

        fdjtString.semiSplit=function(string,escape,mapfn){
            if ((mapfn) || (escape)) {
                var results=[];
                var start=0; var next;
                while ((next=string.indexOf(';',start))>=0) 
                    if ((escape) && (next>0) && (string[next-1]===escape))
                        start=next+1;
                else if ((mapfn) && (next>start)) {
                    results.push(mapfn(string.slice(start,next))); start=next+1;}
                else if (next>start) {
                    results.push(string.slice(start,next)); start=next+1;}
                else start=next+1;
                if (string.length>start)
                    if (mapfn) results.push(mapfn(string.slice(start)));
                else results.push(string.slice(start));
                return results;}
            else return string.split(';');};

        fdjtString.lineSplit=function(string,escapes,mapfn){
            if ((mapfn) || (escape)) {
                var results=[];
                var start=0; var next;
                while ((next=string.indexOf('\n',start))>=0) 
                    if ((escape) && (next>0) && (string[next-1]===escape))
                        start=next+1;
                else if ((mapfn) && (next>start)) {
                    results.push(mapfn(string.slice(start,next))); start=next+1;}
                else if (next>start) {
                    results.push(string.slice(start,next)); start=next+1;}
                else start=next+1;
                if (string.length>start)
                    if (mapfn) results.push(mapfn(string.slice(start)));
                else results.push(string.slice(start));
                return results;}
            else return string.split('\n');};

        var spacechars=" \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff";
        
        function trim(string){
            var start=0; var len=string.length; 
            if (len<=0) return string;
            while ((start<len)&&
                   (spacechars.indexOf(string.charAt(start))>-1))
                start++;
            if (start===len) return "";
            var end=len-1;
            while ((end>start)&&(spacechars.indexOf(string.charAt(end))>-1))
                end--;
            if ((start>0)||(end<len)) return string.slice(start,end+1);
            else return string;}
        fdjtString.trim=trim;

        function stdspace(string){
            var spacechars=" \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff";
            string=string.replace(/\s+/g," ");
            var start=0; var len=string.length; 
            if (len<=0) return string;
            while ((start<len)&&
                   (spacechars.indexOf(string.charAt(start))>-1))
                start++;
            if (start===len) return "";
            var end=len-1;
            while ((end>start)&&(spacechars.indexOf(string.charAt(end))>-1))
                end--;
            if ((start>0)||(end<len)) return string.slice(start,end+1);
            else return string;}
        fdjtString.stdspace=stdspace;

        function flatten(string){
            return string.replace(/\s+/g," ");}
        fdjtString.flatten=flatten;

        function oneline(string){
            string=trim(string);
            var flat=string.replace(/\s*[\f\n\r]+\s+/gm," //\u00B7 ").
                replace(/\s*[\f\n\r]+\s*/gm," // ");
            var tight=flat.replace(/\s\s+/g,"");
            return tight;}
        fdjtString.oneline=oneline;

        function stripMarkup(string){
            return string.replace(/<[^>]*>/g,"");}
        fdjtString.stripMarkup=stripMarkup;

        function unEscape(string){
            if (string.indexOf('\\')>=0)
                return string.replace(/\\(.)/g,"$1");
            else return string;}
        fdjtString.unEscape=unEscape;

        function normstring(string){
            return string.replace(/\W*\s\W*/g," ").toLowerCase();}
        fdjtString.normString=normstring;

        function unEntify(string) {
            return string.replace(/&#(\d+);/g,
                                  function(whole,paren) {
                                      return String.fromCharCode(+paren);});}
        fdjtString.unEntify=unEntify;

        function padNum(num,digits,prec){
            var ndigits=
                ((num<10)?(1):(num<100)?(2):(num<1000)?(3):(num<10000)?(4):
                 (num<100000)?(5):(num<1000000)?(6):(num<1000000)?(7):
                 (num<100000000)?(8):(num<1000000000)?(9):(num<10000000000)?(10):(11));
            var nzeroes=digits-ndigits; var numstring=num.toString();
            var prefix=""; var suffix="";
            if (prec) {
                var point=numstring.indexOf('.');
                if ((point>=0)&&((point+prec)<numstring.length))
                    numstring=numstring.slice(0,point+prec+1);
                else if ((point<0)||(numstring.length<(point+prec+1))) {
                    var j=0; var pad=(point+prec+1)-numstring.length;
                    while (j<pad) {suffix=suffix+"0"; j++;}}}
            switch (nzeroes) {
            case 0: prefix=""; break;
            case 1: prefix="0"; break;
            case 2: prefix="00"; break;
            case 3: prefix="000"; break;
            case 4: prefix="0000"; break;
            case 5: prefix="00000"; break;
            case 6: prefix="000000"; break;
            case 7: prefix="0000000"; break;
            case 8: prefix="00000000"; break;
            case 9: prefix="000000000"; break;
            case 10: prefix="0000000000"; break;
            default: {
                var j=0; while (j<nzeroes) {prefix=prefix+"0"; j++;}}}
            return prefix+numstring+suffix;}
        fdjtString.padNum=padNum;

        function precString(num,prec){
            var numstring=num.toString();
            var suffix="";
            if (prec) {
                var point=numstring.indexOf('.');
                if ((point>=0)&&((point+prec)<numstring.length))
                    numstring=numstring.slice(0,point+prec+1);
                else if ((point<0)||(numstring.length<(point+prec+1))) {
                    var j=0; var pad=(point+prec+1)-numstring.length;
                    while (j<pad) {suffix=suffix+"0"; j++;}}}
            return numstring+suffix;}
        fdjtString.precString=precString;

        /* Getting initials */

        function getInitials(string){
            var words=string.split(/\W/); var initials="";
            var i=0; var lim=words.length;
            while (i<lim) {
                var word=words[i++];
                if (word.length)
                    initials=initials+word.slice(0,1);}
            return initials;}
        fdjtString.getInitials=getInitials;

        /* More string functions */

        function hasPrefix(string,prefix){
            return ((string.indexOf(prefix))===0);}
        fdjtString.hasPrefix=hasPrefix;

        function hasSuffix(string,suffix){
            return ((string.lastIndexOf(suffix))===(string.length-suffix.length));}
        fdjtString.hasSuffix=hasSuffix;

        function commonPrefix(string1,string2,brk,foldcase){
            var i=0; var last=0;
            while ((i<string1.length) && (i<string2.length))
                if ((string1[i]===string2[i])||
                    ((foldcase)&&(string1[i].toLowerCase()===string2[i].toLowerCase())))
                    if (brk)
                        if (brk===string1[i]) {last=i-1; i++;}
            else i++;
            else last=i++;
            else break;
            if (last>0) return string1.slice(0,last+1);
            else return false;}
        fdjtString.commonPrefix=commonPrefix;

        function commonSuffix(string1,string2,brk,foldcase){
            var i=string1.length, j=string2.length; var last=0;
            while ((i>=0) && (j>=0))
                if ((string1[i]===string2[j])||
                    ((foldcase)&&(string1[i].toLowerCase()===string2[i].toLowerCase())))
                    if (brk)
                        if (brk===string1[i]) {last=i+1; i--; j--;}
            else {i--; j--;}
            else {last=i; i--; j--;}
            else break;
            if (last>0) return string1.slice(last);
            else return false;}
        fdjtString.commonSuffix=commonSuffix;

        function stripSuffix(string){
            var start=string.search(/\.\w+$/);
            if (start>0) return string.slice(0,start);
            else return string;}
        fdjtString.stripSuffix=stripSuffix;

        function arrayContains(array,element){
            if (array.indexOf)
                return (array.indexOf(element)>=0);
            else {
                var i=0; var len=array.length;
                while (i<len)
                    if (array[i]===element) return true;
                else i++;
                return false;}}

        function prefixAdd(ptree,string,i) {
            var strings=ptree.strings;
            if (i===string.length) 
                if ((strings.indexOf) ?
                    (strings.indexOf(string)>=0) :
                    (arrayContains(strings,string)))
                    return false;
            else {
                strings.push(string);
                return true;}
            else if (ptree.splits) {
                var splitchar=string[i];
                var split=ptree[splitchar];
                if (!(split)) {
                    // Create a new split
                    split={};
                    split.strings=[];
                    // We don't really use this, but it might be handy for debugging
                    split.splitchar=splitchar;
                    ptree[splitchar]=split;
                    ptree.splits.push(split);}
                if (prefixAdd(split,string,i+1)) {
                    strings.push(string);
                    return true;}
                else return false;}
            else if (ptree.strings.length<5)
                if ((strings.indexOf) ?
                    (strings.indexOf(string)>=0) :
                    (arrayContains(strings,string)))
                    return false;
            else {
                strings.push(string);
                return true;}
            else {
                // Subdivide
                ptree.splits=[];
                var strings=ptree.strings;
                var j=0; while (j<strings.length) prefixAdd(ptree,strings[j++],i);
                return prefixAdd(ptree,string,i);}}
        fdjtString.prefixAdd=prefixAdd;

        function prefixFind(ptree,prefix,i,plen){
            if (!(plen)) plen=prefix.length;
            if (i===plen)
                return ptree.strings;
            else if (ptree.strings.length<=5) {
                var strings=ptree.strings;
                var results=[];
                var j=0; while (j<strings.length) {
                    var string=strings[j++];
                    if (hasPrefix(string,prefix)) results.push(string);}
                if (results.length) return results;
                else return false;}
            else {
                var split=ptree[prefix[i]];
                if (split) return prefixFind(split,prefix,i+1,plen);
                else return false;}}
        fdjtString.prefixFind=prefixFind;

        function paraHash(node){
            var text=node.innerText;
            var words=text.split(/\W*\S+\W*/g);
            var len=words.length;
            return "_H"+
                ((len>0)?(words[0][0]):".")+
                ((len>1)?(words[1][0]):".")+
                ((len>2)?(words[2][0]):".")+
                ((len>3)?(words[3][0]):".")+
                ((len>0)?(words[len-1][0]):".")+
                ((len>1)?(words[len-2][0]):".")+
                ((len>2)?(words[len-3][0]):".")+
                ((len>3)?(words[len-4][0]):".");}
        fdjtString.paraHash=paraHash;

        return fdjtString;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/time.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
    of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use, modification, and redistribution of this program is permitted
    under either the GNU General Public License (GPL) Version 2 (or
    any later version) or under the GNU Lesser General Public License
    (version 3 or later).

    These licenses may be found at www.gnu.org, particularly:
      http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
      http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

/* Time functions */

if (window) {if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.Time=
    (function (){
        function _(x){ return x; }

        function fdjtTime() {
            return (new Date()).getTime();}
        fdjtTime.revid="$Id$";
        fdjtTime.version=parseInt("$Revision$".slice(10,-1));

        var loaded=fdjtTime.loaded=(new Date()).getTime();
        fdjtTime.tick=function(){
            return Math.floor((new Date()).getTime()/1000);};

        fdjtTime.dateString=function(tstamp){
            if (typeof tstamp === 'number') {
                if (tstamp<131592918600)
                    tstamp=new Date(tstamp*1000);
                else tstamp=new Date(tstamp);}
            return tstamp.toDateString();};
        fdjtTime.timeString=function(tstamp){
            if (typeof tstamp === 'number') {
                if (tstamp<131592918600)
                    tstamp=new Date(tstamp*1000);
                else tstamp=new Date(tstamp);}
            return tstamp.toString();};

        function shortString(tstamp){
            var now=new Date();
            if (typeof tstamp === 'number') {
                if (tstamp<131592918600)
                    tstamp=new Date(tstamp*1000);
                else tstamp=new Date(tstamp);}
            var diff=(now.getTime()-tstamp.getTime())/1000;
            if (diff>(12*3600))
                return tstamp.toDateString();
            else {
                var hours=tstamp.getHours();
                var minutes=tstamp.getMinutes();
                return tstamp.toDateString()+" ("+
                    ((hours<10)?"0":"")+hours+":"+
                    ((minutes===0)?"00":(((minutes<10)?"0":"")+minutes));}}
        fdjtTime.shortString=shortString;
        fdjtTime.tick2shortstring=function(tick){
            return shortString(new Date(tick*1000));};

        fdjtTime.tick2string=function(tick){
            return (new Date(tick*1000)).toString();};
        fdjtTime.tick2date=function(tick){
            return (new Date(tick*1000)).toDateString();};
        fdjtTime.tick2locale=function(tick){
            return (new Date(tick*1000)).toLocaleString();};
        fdjtTime.tick2time=function(tick){
            return (new Date(tick*1000)).toTimeString();};

        var fmt=fdjt.String;

        fdjtTime.secs2string=function(interval){
            if (interval<1)
                return fmt("%f seconds",interval);
            else if (interval===1)
                return fmt("%f second",interval);
            else if (interval<10)
                return fmt("%f seconds",interval);
            else if (interval<60)
                return fmt("~%d seconds",Math.round(interval/60));
            else if (interval<120) {
                var minutes=Math.floor(interval/60);
                var seconds=Math.round(interval-(minutes*60));
                if (seconds===1)
                    return _("one minute, one second");
                else return fmt("one minute, %d seconds",seconds);}
            else if (interval<3600) {
                var minutes=Math.floor(interval/60);
                return fmt("~%d minutes",minutes);}
            else if (interval<(2*3600)) {
                var hours=Math.floor(interval/3600);
                var minutes=Math.round((interval-(hours*3600))/60);
                if (minutes===1)
                    return _("one hour and one minutes");
                else return fmt("one hour, %d minutes",minutes);}
            else if (interval<(24*3600)) {
                var hours=Math.floor(interval/3600);
                return fmt("~%d hours",hours);}
            else if (interval<(2*24*3600)) {
                var hours=Math.floor((interval-24*3600)/3600);
                if (hours===1)
                    return _("one day and one hour");
                else return fmt("one day, %d hours",hours);}
            else if (interval<(7*24*3600)) {
                var days=Math.floor(interval/(24*3600));
                return fmt("%d days",days);}
            else if (interval<(14*24*3600)) {
                var days=Math.floor((interval-(7*24*3600))/(24*3600));
                if (days===1)
                    return "one week and one day";
                else return fmt("one week and %d days",days);}
            else {
                var weeks=Math.floor(interval/(7*24*3600));
                var days=Math.round((interval-(days*7*24*3600))/(7*24*3600));
                return fmt("%d weeks, %d days",weeks,days);}};

        fdjtTime.secs2short=function(interval){
            // This is designed for short intervals
            if (interval<0.001)
                return Math.round(interval*1000000)+"us";
            else if (interval<0.1)
                return Math.round(interval*1000)+"ms";
            else if (interval<120)
                return (Math.round(interval*100)/100)+"s";
            else {
                var min=Math.floor(interval/60);
                var secs=interval-min*60;
                return min+"m, "+(Math.round(secs*100)/100)+"s";}};

        fdjtTime.runTimes=function(pname,start){
            var point=start; var report="";
            var i=2; while (i<arguments.length) {
                var phase=arguments[i++]; var time=arguments[i++];
                report=report+"; "+phase+": "+
                    ((time.getTime()-point.getTime())/1000)+"s";
                point=time;}
            return pname+" "+((point.getTime()-start.getTime())/1000)+"s"+report;};

        fdjtTime.diffTime=function(time1,time2){
            if (!(time2)) time2=new Date();
            var diff=time1.getTime()-time2.getTime();
            if (diff>0) return diff/1000; else return -(diff/1000);
        };

        fdjtTime.ET=function(arg){
            if (!(arg)) arg=new Date();
            return (arg.getTime()-loaded)/1000;};

        function timeslice(fcns,slice,space,done){
            var timer=false;
            if (typeof slice !== 'number') slice=100;
            if (typeof space !== 'number') space=100;
            var i=0; var lim=fcns.length;
            var slicefn=function(){
                var timelim=fdjtTime()+slice;
                var nextspace=false;
                while (i<lim) {
                    var fcn=fcns[i++];
                    if (!(fcn)) continue;
                    else if (typeof fcn === 'number') {
                        nextspace=fcn; break;}
                    else fcn();
                    if (fdjtTime()>timelim) break;}
                if ((i<lim)&&((!(done))||(!(done()))))
                    timer=setTimeout(slicefn,nextspace||space);
                else {
                    clearTimeout(timer); timer=false;};}
            return slicefn();}
        fdjtTime.timeslice=timeslice;

        function slowmap(fn,vec,watch,done,slice,space){
            var i=0; var lim=vec.length; var chunks=0;
            var used=0; var zerostart=fdjtTime();
            var timer=false;
            if (!(slice)) slice=100;
            if (!(space)) space=slice;
            var stepfn=function(){
                var started=fdjtTime(); var now=started;
                var stopat=started+slice;
                if (watch) watch(((i==0)?'start':'resume'),i,lim,chunks,used,
                                 zerostart);
                while ((i<lim)&&((now=fdjtTime())<stopat)) {
                    var elt=vec[i];
                    if (watch) watch('element',i,lim,elt,used,now-zerostart);
                    fn(elt);
                    if (watch)
                        watch('after',i,lim,elt,used+(fdjtTime()-started),
                              zerostart,fdjtTime()-now);
                    i++;}
                chunks=chunks+1;
                if (i<lim) {
                    used=used+(now-started);
                    if (watch) watch('suspend',i,lim,chunks,used,
                                     zerostart);
                    timer=setTimeout(stepfn,space);}
                else {
                    now=fdjtTime(); used=used+(now-started);
                    clearTimeout(timer); timer=false;
                    if (done) {
                        if (watch) watch('finishing',i,lim,chunks,used,
                                         zerostart);
                        done();}
                    var donetime=((done)&&(fdjtTime()-now));
                    now=fdjtTime(); used=used+(now-started);
                    if (watch) watch('done',i,lim,chunks,used,
                                     zerostart,donetime);}};
            timer=setTimeout(stepfn,space);}
        fdjtTime.slowmap=slowmap;

        return fdjtTime;})();

fdjt.ET=fdjt.Time.ET;

/* Emacs local variables
;;;  Local variables: ***
;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
;;;  indent-tabs-mode: nil ***
;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/log.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.Log=(function(){
    var fdjtTime=fdjt.Time;
    var fdjtString=fdjt.String;

    var backlog=[];

    var logreq=false;
    var logreqs=[];
    var use_console_log;

    function fdjtLog(string){
        var output=false; var now=fdjt.ET();
        if (((fdjtLog.doformat)||(string.search("%j")))&&
            (typeof fdjtString !== 'undefined'))
            output=fdjtString.apply(null,arguments);
        if (fdjtLog.console_fn) {
            if (output) fdjtLog.console_fn.call(fdjtLog.console,output);
            else fdjtLog.console_fn.apply(fdjtLog.console,arguments);}
        if (fdjtLog.logurl) {
            var msg="["+now+"s] "+fdjtString.apply(null,arguments);
            console.log("remote logging %s",msg);
            remote_log(msg);}
        if (fdjtLog.console) {
            var domconsole=fdjtLog.console;
            var timespan=fdjt.DOM("span.time",now);
            var entry=fdjt.DOM("div.fdjtlog");
            if (output) entry.innerHTML=output;
            else entry.innerHTML=fdjtString.apply(null,arguments);
            fdjt.DOM.prepend(entry,timespan);
            if (typeof domconsole === 'string') {
                var found=document.getElementById(domconsole);
                if (found) {
                    domconsole=fdjtLog.console=found;
                    var i=0; var lim=backlog.length;
                    while (i<lim) fdjt.DOM(domconsole,backlog[i++]);
                    backlog=[];}
                else domconsole=false;}
            else if (!(domconsole.nodeType)) domconsole=false;
            if (domconsole)
                fdjt.DOM.append(domconsole,entry);
            else backlog.push(entry);}
        if ((fdjtLog.useconsole)||
            ((!(fdjtLog.console))&&(!(fdjtLog.console_fn)))) {
            if (typeof use_console_log === 'undefined')
                init_use_console_log();
            if (use_console_log) {
                if (!(window.console.log.call)) 
                    // In IE, window.console.log is an object, not a function,
                    //  but a straight call still works.
                    window.console.log(
                        "["+now+"s] "+fdjtString.apply(null,arguments));
                else if (output)
                    window.console.log.call(
                        window.console,"["+now+"s] "+output);
                else {
                    var newargs=new Array(arguments.length+1);
                    newargs[0]="[%fs] "+string;
                    newargs[1]=now;
                    var i=1; var lim=arguments.length;
                    while (i<lim) {newargs[i+1]=arguments[i]; i++;}
                    window.console.log.apply(window.console,newargs);}}}}
    fdjtLog.console=null;
    fdjtLog.id="$Id$";
    fdjtLog.version=parseInt("$Revision$".slice(10,-1));

    function remote_log(msg){
        var req=new XMLHttpRequest();
        req.open('POST',fdjtLog.logurl,(!(fdjtLog.logsync)));
        req.setRequestHeader("Content-type","text; charset=utf-8");
        req.send(msg);
        return req;}

    fdjtLog.warn=function(string){
        if ((!(fdjtLog.console_fn))&&
            (!(window.console)&&(window.console.log)&&(window.console.log.count))) {
            var output=fdjtString.apply(null,arguments);
            alert(output);}
        else fdjtLog.apply(null,arguments);};

    fdjtLog.uhoh=function(string){
        if (fdjtLog.debugging) fdjtLog.warn.call(this,arguments);}

    fdjtLog.bkpt=function(string){
        var output=false;
        if ((fdjtLog.doformat)&&(typeof fdjtString !== 'undefined'))
            output=fdjtString.apply(null,arguments);
        if (fdjtLog.console_fn)
            if (output) fdjtLog.console_fn(fdjtLog.console,output);
        else fdjtLog.console_fn.apply(fdjtLog.console,arguments);
        else if ((window.console) && (window.console.log) &&
                 (window.console.count))
            if (output)
                window.console.log.call(window.console,output);
        else window.console.log.apply(window.console,arguments);
    };

    fdjtLog.useconsole=true;

    function init_use_console_log() {
        if ((window.console)&&(window.console.log)) {
            if (window.console.count) use_console_log=true;
            else {
                use_console_log=true;
                try {window.console.log("Testing console");}
                catch (ex) { use_console_log=false;}}}
        else use_console_log=false;}

    return fdjtLog;})();

// This is for temporary trace statements; we use a different name
//  so that they're easy to find.
fdjt.Trace=fdjt.Log;

/**
 * HumaneJS
 * Humanized Messages for Notifications
 * @author Marc Harter (@wavded)
 * @contributers
 *   Alexander (@bga_)
 *   Jose (@joseanpg)
 * @example
 *  humane('hello world');
 */
;(function(win,doc){
    var fdjtLog=fdjt.Log;

    var eventOn, eventOff;
    if (win.addEventListener) {
        eventOn = function(obj,type,fn){obj.addEventListener(type,fn,false)};
        eventOff = function(obj,type,fn){obj.removeEventListener(type,fn,false)};
    } else {
        eventOn = function(obj,type,fn){obj.attachEvent('on'+type,fn)};
        eventOff = function(obj,type,fn){obj.detachEvent('on'+type,fn)};
    }

    var eventing = false;
    var animationInProgress = false;
    var humaneEl = null;
    // Table mapping msg node IDs into the nodes themselves
    var msgnodes={};
    var timeout = null;
    // ua sniff for filter support
    var useFilter = /msie [678]/i.test(navigator.userAgent);
    var isSetup = false;
    var queue = [];

    eventOn(win,'load',function(){
        var transitionSupported = (function(style){
            var prefixes = ['MozT','WebkitT','OT','msT','KhtmlT','t'];
            for(var i = 0, prefix; prefix = prefixes[i]; i++){
                if(prefix+'ransition' in style) return true;
            }
            return false;
        }(doc.body.style));

        if(!transitionSupported) animate = jsAnimateOpacity; // override animate
        setup();
        run();
    });

    function setup() {
        var probe=doc.getElementById('HUMANE');
        if (probe) humaneEl=probe;
        else {
            humaneEl = doc.createElement('div');
            humaneEl.id = 'HUMANE';
            humaneEl.className = 'humane';
            doc.body.appendChild(humaneEl);}
        if(useFilter) humaneEl.filters.item('DXImageTransform.Microsoft.Alpha').Opacity = 0; // reset value so hover states work
        isSetup = true;
    }

    function remove() {
        eventOff(doc.body,'mousemove',remove);
        eventOff(doc.body,'click',remove);
        eventOff(doc.body,'keypress',remove);
        eventOff(doc.body,'touchstart',remove);
        eventing = false;
        if(animationInProgress) animate(0);
    }

    function run() {
        if(animationInProgress && !fdjtLog.notify.forceNew) return;
        if(!queue.length){
            remove();
            return;
        }

        animationInProgress = true;

        if(timeout){
            clearTimeout(timeout);
            timeout = null;
        }

        timeout = setTimeout(function(){
            // allow notification to stay alive for timeout
            if(!eventing){
                eventOn(doc.body,'mousemove',remove);
                eventOn(doc.body,'click',remove);
                eventOn(doc.body,'keypress',remove);
                eventOn(doc.body,'touchstart',remove);
                eventing = true;
                if(!fdjtLog.notify.waitForMove) remove();
            }
        }, fdjtLog.notify.timeout);

        var msg=queue.shift();
        if (msg.nodeType) {
            humaneEl.innerHTML = "";
            humaneEl.appendChild(msg);}
        else if (typeof msg !== 'string')
            throw new Exception("Bad arg to Humane");
        else if ((msg.length>1)&&(msg[0]==='#')) {
            var nodeid=msg.slice(1);
            node=msgnodes[nodeid];
            if ((!(node))&&(node=document.getElementById(nodeid)))
                msgnodes[nodeid]=node;
            if (node) {
                humaneEl.innerHTML = "";
                humaneEl.appendChild(node);}
            else humaneEl.innerHTML = msg;}
        else humaneEl.innerHTML = msg;
        animate(1);
    }

    function animate(level){
        if(level === 1){
            humaneEl.className = "humane humane-show";
        } else {
            humaneEl.className = "humane";
            end();
        }
    }

    function end(){
        animationInProgress = false;
        setTimeout(run,500);
    }

    // if CSS Transitions not supported, fallback to JS Animation
    var setOpacity = (function(){
        if(useFilter){
            return function(opacity){
                humaneEl.filters.item('DXImageTransform.Microsoft.Alpha').Opacity = opacity*100;
            }
        } else {
            return function(opacity){
                humaneEl.style.opacity = String(opacity);
            }
        }
    }());
    function jsAnimateOpacity(level,callback){
        var interval;
        var opacity;

        if (level === 1) {
            opacity = 0;
            if(fdjtLog.notify.forceNew){
                opacity = useFilter ? humaneEl.filters.item('DXImageTransform.Microsoft.Alpha').Opacity/100|0 : humaneEl.style.opacity|0;
            }
            humaneEl.style.visibility = "visible";
            interval = setInterval(function(){
                if(opacity < 1) {
                    opacity +=0.1;
                    if (opacity>1) opacity = 1;
                    setOpacity(opacity);
                }
                else {
                    clearInterval(interval);
                }
            }, 500 / 20);
        } else {
            opacity = 1;
            interval = setInterval(function(){
                if(opacity > 0) {
                    opacity -=0.1;
                    if (opacity<0) opacity = 0;
                    setOpacity(opacity);
                }
                else {
                    clearInterval(interval);
                    humaneEl.style.visibility = "hidden";
                    end();
                }
            }, 500 / 20);
        }
    }

    function notify(message){
        fdjtLog.apply(null,arguments);
        if (arguments.length>1)
            message=fdjtString.apply(null,arguments);
        queue.push(message);
        if(isSetup) run();}

    function msg(message){
        if (!(message)) {
            if(!eventing){
                eventOn(doc.body,'mousemove',remove);
                eventOn(doc.body,'click',remove);
                eventOn(doc.body,'keypress',remove);
                eventOn(doc.body,'touchstart',remove);
                eventing = true;}
            animationInProgress=true;
            animate(1);
            return;}
        if (arguments.length>1)
            message=fdjtString.apply(null,arguments);
        queue.push(message);
        if(isSetup) run();}

    fdjtLog.notify = notify;
    fdjtLog.notify.timeout = 2000;
    fdjtLog.notify.waitForMove = true;
    fdjtLog.notify.forceNew = false;

    fdjtLog.Humane=msg;
    fdjtLog.HumaneHide=remove;

}(window,document));

fdjt.Notify=fdjt.Log.notify;

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/init.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

(function(){
    var fdjtLog=fdjt.Log;
    var inits_run=false;
    var inits=[];
    var init_names={};

    function addInit(fcn,name,runagain){
        var replace=((name)&&(init_names[name]));
        var i=0, lim=inits.length;
        while (i<lim) {
            if ((replace)&&(inits[i]===replace)) {
                if (inits_run) {
                    fdjtLog.warn(
                        "Replacing init %s which has already run",name);
                    if (runagain) {
                        fdjtLog.warn("Running the new version");
                        inits[i]=fcn; init_names[name]=fcn; fcn();
                        return;}}
                else {
                    inits[i]=fcn; init_names[name]=fcn;
                    return;}}
            else if (inits[i]===fcn) return;
            else i++;}
        inits.push(fcn);
        if (name) init_names[name]=fcn;}
    fdjt.addInit=addInit;
    
    fdjt.Init=function fdjtInit(){
        var names=[];
        if (inits_run) return false;
        for (var name in init_names)
            if (init_names.hasOwnProperty(name)) names.push(name);
        if (names.length===0)
            fdjtLog("Running %d DOM inits",inits.length);
        else if (names.length===inits.length)
            fdjtLog("Running %d DOM inits (%s)",
                    inits.length,names.join());
        else fdjtLog("Running %d DOM inits (including %s)",
                     inits.length,names.join());
        var i=0; var lim=inits.length;
        while (i<lim) inits[i++]();
        inits_run=true;};

    var device_info=(fdjt.device)||(fdjt.device={});
    if ((window)&&(window.navigator)&&(navigator.appVersion)) {
	device_info.isAndroid = (/android/gi).test(navigator.appVersion);
	device_info.isIDevice = (/iphone|ipad/gi).test(navigator.appVersion);
	device_info.isTouchPad = (/hp-tablet/gi).test(navigator.appVersion);
	device_info.hasTouch = ('ontouchstart' in window) &&
	    (!(device_info.isTouchPad));}
})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/state.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.State=
    (function(){

        var fdjtLog=fdjt.Log;

        function fdjtState(name,val,persist){
            if (arguments.length===1)
                return ((window.sessionStorage)&&(getSession(name)))||
                ((window.sessionStorage)&&(getLocal(name)))||
                getCookie(name);
            else if (persist)
                if (window.localStorage)
                    if (val) setLocal(name,val);
            else dropLocal(name);
            else {
                var domain=fdjtState.domain||location.hostname;
                var path=fdjtState.path||"/";
                var duration=fdjtState.duration||(3600*24*365*7);
                if (val) setCookie(name,val,duration,path,domain);
                else clearCookie(name,path,domain);}
            else if (val)
                if (window.sessionStorage) setSession(name,val);
            else setCookie(name,val);
            else if (window.sessionStorage) dropSession(name);
            else clearCookie(name);};
        fdjtState.domain=false;
        fdjtState.path=false;
        fdjtState.duration=false;

        /* Old-school cookies */

        function getCookie(name,parse){
            try {
                var cookies=document.cookie;
                var namepat=new RegExp("(^|(; ))"+name+"=","g");
                var pos=cookies.search(namepat);
                var valuestring;
                if (pos>=0) {
                    var start=cookies.indexOf('=',pos)+1;
                    var end=cookies.indexOf(';',start);
                    if (end>0) valuestring=cookies.slice(start,end);
                    else valuestring=cookies.slice(start);}
                else return false;
                if (parse)
                    return JSON.parse(decodeURIComponent(valuestring));
                else return decodeURIComponent(valuestring);}
            catch (ex) {
                return false;}}
        fdjtState.getCookie=getCookie;

        function setCookie(name,value,expires,path,domain){
            try {
                if (value) {
                    var valuestring=
                        ((typeof value === 'string') ? (value) :
                         (value.toJSON) ? (value.toJSON()) :
                         (value.toString) ? (value.toString()) : (value));
                    var cookietext=name+"="+encodeURIComponent(valuestring);
                    if (expires)
                        if (typeof(expires)==='string')
                            cookietext=cookietext+'; '+expires;
                    else if (expires.toGMTString)
                        cookietext=cookietext+"; expires="+expires.toGMTString();
                    else if (typeof(expires)==='number')
                        if (expires>0) {
                            var now=new Date();
                            now.setTime(now.getTime()+expires);
                            cookietext=cookietext+"; expires="+now.toGMTString;}
                    else cookietext=cookietext+"; expires=Sun 1 Jan 2000 00:00:00 UTC";
                    else {}
                    if (path) cookietext=cookietext+"; path="+path;
                    // This certainly doesn't work generally and might not work ever
                    if (domain) cookietext=cookietext+"; domain="+domain;
                    // fdjtTrace("Setting cookie %o cookietext=%o",name,cookietext);
                    document.cookie=cookietext;}
                else clearCookie(name,path,domain);}
            catch (ex) {
                fdjtLog.warn("Error setting cookie %s",name);}}
        fdjtState.setCookie=setCookie;
        
        function clearCookie(name,domain,path){
            try {
                var valuestring="ignoreme";
                var cookietext=name+"="+encodeURIComponent(valuestring)+
                    "; expires=Sun 1 Jan 2000 00:00:00 UTC";
                if (path) cookietext=cookietext+"; path="+path;
                // This certainly doesn't work generally and might not work ever
                if (domain) cookietext=cookietext+"; domain="+domain;
                // fdjtTrace("Clearing cookie %o: text=%o",name,cookietext);
                document.cookie=cookietext;}
            catch (ex) {
                fdjtLog.warn("Error clearing cookie %s",name);}}
        fdjtState.clearCookie=clearCookie;

        /* Session storage */

        function setSession(name,val,unparse){
            if (unparse) val=JSON.stringify(val);
            if (window.sessionStorage)
                window.sessionStorage[name]=val;
            else setCookie(name,val);}
        fdjtState.setSession=setSession;

        function getSession(name,parse){
            var val=((window.sessionStorage)?
                     (window.sessionStorage[name]):
                     (fdjtGetCookie(name)));
            if (val)
                if (parse) return JSON.parse(val); else return val;
            else return false;}
        fdjtState.getSession=getSession;

        function dropSession(name){
            if (window.sessionStorage)
                return window.sessionStorage.removeItem(name);
            else clearCookie(name);}
        fdjtState.dropSession=dropSession;

        /* Local storage (persists between sessions) */

        function setLocal(name,val,unparse){
            if (!(name)) throw { error: "bad name",name: name};
            if (unparse) val=JSON.stringify(val);
            if (window.localStorage)
                window.localStorage[name]=val;}
        fdjtState.setLocal=setLocal;

        function getLocal(name,parse){
            if (window.localStorage) {
                var val=window.localStorage[name];
                if (val)
                    if (parse) return JSON.parse(val); else return val;
                else return false;}
            else return false;}
        fdjtState.getLocal=getLocal;

        function dropLocal(name){
            if (window.localStorage)
                return window.localStorage.removeItem(name);
            else return false;}
        fdjtState.dropLocal=dropLocal;
        
        function listLocal(){
            var keys=[];
            if (window.localStorage) {
                var storage=window.localStorage;
                var i=0; var lim=storage.length;
                while (i<lim) keys.push(storage.key(i++));}
            return keys;}
        fdjtState.listLocal=listLocal;

        function clearLocal(){
            if (window.localStorage) {
                var storage=window.localStorage;
                var i=0; var lim=storage.length;
                var keys=[];
                while (i<lim) keys.push(storage.key(i++));
                i=0; while (i<lim) storage.removeItem(keys[i++]);}}
        fdjtState.clearLocal=clearLocal;

        /* Gets arguments from the query string */
        function getQuery(name,multiple,matchcase,verbatim){
            if (!(location.search))
                if (multiple) return [];
            else return false;
            var results=[];
            var ename=encodeURIComponent(name);
            var namepat=new RegExp("(&|^|\\?)"+ename+"(=|&|$)",
                                   ((matchcase)?"g":"gi"));
            var query=location.search;
            var start=query.search(namepat);
            while (start>=0) {
                // Skip over separator if non-initial
                if ((query[start]==='?')||(query[start]==='&')) start++;
                // Skip over the name
                var valstart=start+ename.length;
                var valstring=query.slice(valstart+1);
                var end=valstring.search(/(&|$)/g);
                if (query[valstart]==="=") {
                    if (end<=0) {
                        results.push("");
                        if (!(multiple)) break;}
                    else {
                        results.push(valstring.slice(0,end));
                        end=end+valstart+1;
                        if (!(multiple)) break;}}
                else if (multiple) 
                    results.push(query.slice(start,end));
                else if (verbatim) 
                    return query.slice(start,end);
                else return querydecode(query.slice(start,end));
                if (end>0) {
                    query=query.slice(end);
                    start=query.search(namepat);}}
            if (!(verbatim)) {
                var i=0; var lim=results.length;
                while (i<lim) {results[i]=querydecode(results[i]); i++;}}
            if (multiple) return results;
            else if (results.length)
                return results[0];
            else return false;}
        fdjtState.getQuery=getQuery;
        
        function querydecode(string){
            if (decodeURIComponent)
                return decodeURIComponent(string);
            else return 
            string.replace
            (/%3A/gi,":").replace
            (/%2F/gi,"/").replace
            (/%3F/gi,"?").replace
            (/%3D/gi,"=").replace
            (/%20/gi," ").replace
            (/%40/gi,"@").replace
            (/%23/gi,"#");}

        function test_opt(pos,neg){
            var pospat=((pos)&&(new RegExp("\\b"+pos+"\\b")));
            var negpat=((neg)&&negative_opt_pat(neg));
            var i=2; while (i<arguments.length) {
                var arg=arguments[i++];
                if (!(arg)) continue;
                else if (typeof arg === 'string')
                    if ((pospat)&&(arg.search(pospat)>=0)) return true;
                else if ((negpat)&&(arg.search(negpat)>=0)) return false;
                else continue;
                else if (arg.length) {
                    var j=0; var len=arg.length;
                    while (j<len)
                        if ((pos)&&(arg[j]===pos)) return true;
                    else if ((neg)&&(arg[j]===neg)) return false;
                    else j++;
                    return false;}
                else continue;}
            return false;}
        fdjtState.testOption=test_opt;

        function negative_opt_pat(neg){
            if (!(neg)) return neg;
            else if (typeof neg === 'string')
                return (new RegExp("\\b"+neg+"\\b","gi"));
            else if (neg.length) {
                var rule="\\b(";
                var i=0; while (i<neg.length) {
                    var name=neg[i];
                    if (i>0) rule=rule+"|";
                    rule=rule+"("+name+")";
                    i++;}
                rule=rule+")\\b";
                return new RegExp(rule,"gi");}
            else return false;}

        fdjtState.argVec=function(argobj,start){
            var i=start||0;
            var result=new Array(argobj.length-i);
            while (i<argobj.length) {
                result[i-start]=argobj[i]; i++;}
            return result;};

        var zeros="000000000000000000000000000000000000000000000000000000000000000";
        function zeropad(string,len){
            if (string.length===len) return string;
            else if (string.length>len) return string.slice(0,len);
            else return zeros.slice(0,len-string.length)+string;}
        
        // This is a random nodeid used to generate UUIDs
        //  We use it because we can't access the MAC address
        var nodeid=
            zeropad(((Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)|0x01)).toString(16),
                    12);
        
        var default_version=17; 
        var clockid=Math.floor(Math.random()*16384); var msid=1;
        var last_time=new Date().getTime();
        
        fdjtState.getNodeID=function(){return nodeid;};
        fdjtState.setNodeID=function(arg){
            if (typeof arg==='number')
                nodeid=zeropad(arg.toString(16),12);
            else if (typeof arg === 'string')
                if (arg.search(/[^0123456789abcdefABCDEF]/)<0)
                    nodeid=zeropad(arg,12);
            else throw {error: 'invalid node id',value: arg};
            else throw {error: 'invalid node id',value: arg};};

        function getUUID(node){
            var now=new Date().getTime();
            if (now<last_time) {now=now*10000; clockid++;}
            else if (now===last_time)   now=now*10000+(msid++);
            else {now=now*10000; msid=1;}
            now=now+122192928000000000;
            if (!(node)) node=nodeid;
            var timestamp=now.toString(16); var tlen=timestamp.length;
            if (tlen<15) timestamp=zeros.slice(0,15-tlen)+timestamp;
            return timestamp.slice(7)+"-"+timestamp.slice(3,7)+
                "-1"+timestamp.slice(0,3)+
                "-"+(32768+(clockid%16384)).toString(16)+
                "-"+((node)?
                     ((typeof node === 'number')?
                      (zeropad(node.toString(16),12)):
                      (zeropad(node,12))):
                     (nodeid));}
        fdjtState.getUUID=getUUID;
        
        // Getting version information
        function versionInfo(){
            var s=navigator.userAgent; var result={};
            var start;
            while ((start=s.search(/\w+\/\d/g))>=0) {
                var slash=s.indexOf('/',start);
                var afterslash=s.slice(slash+1);
                var num_end=afterslash.search(/\W/);
                var numstring=afterslash.slice(0,num_end);
                try {
                    result[s.slice(start,slash)]=parseInt(numstring);}
                catch (ex) {
                    result[s.slice(start,slash)]=numstring;}
                s=afterslash.slice(num_end);}
            if (result['Chrome']) result.browser='Chrome';
            else if (result['Opera']) result.browser='Opera';
            else if (result['Safari']) result.browser='Safari';
            else if ((result['Safari'])&&(result['Mobile']))
                result.browser='MobileSafari';
            else if (result['Firefox']) result.browser='Firefox';
            else if ((result['Explorer'])||(result['IE'])||
                     (result['InternetExplorer'])||(result['MSIE']))
                result.browser='IE';
            else if (result['Mozilla']) result.browser='Mozilla';
            else result.browser='Browser';
            result.platform=navigator.platform||"Turing";
            return result;}
        fdjtState.versionInfo=versionInfo;

        return fdjtState;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/dom.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.DOM=
    (function(){
        var usenative=true;
        var fdjtString=fdjt.String;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;

        function fdjtDOM(spec){
            var node;
            if (spec.nodeType) node=spec;
            else if ((typeof spec==='string')&&(spec[0]==='<'))  {
                var container=document.createDocumentFragment();
                // We could do template expansion here
                container.innerHTML=spec;
                var children=container.childNodes;
                if (children.length===1) return children[0];
                else return container;}
            else if ((typeof spec==='string')&&(spec[0]==='#')&&
                    (node=document.getElementById(spec.slice(1)))) {}
            else if (typeof spec==='string') {
                var elts=spec.match(css_selector_regex);
                var classname=false;
                node=document.createElement(elts[0]);
                var i=1; var len=elts.length;
                while (i<len) {
                    var sel=elts[i++];
                    if (sel[0]==='#') node.id=sel.slice(1);
                    else if (sel[0]==='.')
                        if (classname) classname=classname+" "+sel.slice(1);
                    else classname=sel.slice(1);
                    else if (sel[0]==='[') {
                        var eqpos=sel.indexOf('=');
                        if (eqpos<0) {
                            node.setAttribute(
                                sel.slice(1,sel.length-1),
                                sel.slice(1,sel.length-1));}
                        else {
                            node.setAttribute(
                                sel.slice(1,eqpos),
                                sel.slice(eqpos+1,sel.length-1));}}
                    else {}}
                if (classname) node.className=classname;}
            else {
                node=document.createElement(spec.tagName||"span");
                for (var attrib in spec) {
                    if (attrib==="tagName") continue;
                    else node.setAttribute(attrib,spec[attrib]);}}
            domappend(node,arguments,1);
            return node;}

        fdjtDOM.revid="$Id$";
        fdjtDOM.version=parseInt("$Revision$".slice(10,-1));
        fdjtDOM.useNative=function(flag) {
            if (typeof flag === 'undefined') return usenative;
            else usenative=flag;};
        
        fdjtDOM.clone=function(node){
            return node.cloneNode(true);}

        function getIE(){
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent;
                var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat( RegExp.$1 );
                else rv=1;
                // Fails for non-numbers
                if (!(rv>0)) rv=1;
                return rv;}
            else return 0;}

        fdjtDOM.ie=getIE();
        fdjtDOM.iem=Math.floor(fdjtDOM.ie);

        function fdjtID(id) {
            return ((id)&&
                    ((document.getElementById(id))||
                     ((id[0]==='#')&&
                      (document.getElementById(id.slice(1))))));}
        fdjt.ID=fdjtID;

        function domappend(node,content,i) {
            if (content.nodeType) node.appendChild(content);
            else if (typeof content === 'string') 
                node.appendChild(document.createTextNode(content));
            else if (content.toDOM)
                return domappend(node,content.toDOM());
            else if (content.toHTML)
                return domappend(node,content.toHTML());
            else if (content.length) {
                var frag=((node instanceof DocumentFragment)?(node):
                          (document.createDocumentFragment()));
                // We copy node lists because they're prone to change
                // underneath us as we're moving DOM nodes around.
                var elts=((NodeList)&&(content instanceof NodeList))?
                    (TOA(content)):(content);
                var len=elts.length; 
                if (typeof i === 'undefined') i=0;
                while (i<len) {
                    var elt=elts[i++];
                    if (!(elt)) {}
                    else if (typeof elt === 'string')
                        frag.appendChild(document.createTextNode(elt));
                    else if (elt.nodeType) frag.appendChild(elt);
                    else if (elt.length)
                        domappend(frag,elt,0);
                    else if (elt.toDOM)
                        domappend(frag,elt.toDOM());
                    else if (elt.toHTML)
                        domappend(frag,elt.toHTML());
                    else if (elt.toString)
                        frag.appendChild(document.createTextNode(
                            elt.toString()));
                    else frag.appendChild(document.createTextNode(""+elt));}
                if (node!==frag) node.appendChild(frag);}
            else node.appendChild(document.createTextNode(""+content));
            return node;}
        function dominsert(before,content,i) {
            var node=before.parentNode;
            if (content.nodeType) node.insertBefore(content,node);
            else if (typeof content === 'string') 
                node.insertBefore(document.createTextNode(content),before);
            else if (content.toDOM)
                return dominsert(before,content.toDOM());
            else if (content.toHTML)
                return dominsert(before,node,content.toHTML());
            else if (content.length) {
                var frag=((node instanceof DocumentFragment)?(node):
                          (document.createDocumentFragment()));
                domappend(frag,content,i);
                node.insertBefore(frag,before);
                return before;}
            else node.insertBefore(document.createTextNode(""+content),before);
            return node;}
        fdjtDOM.appendArray=domappend;
        
        function toArray(arg) {
            var result=new Array(arg.length);
            var i=0; var lim=arg.length;
            while (i<lim) {result[i]=arg[i]; i++;}
            return result;}
        fdjtDOM.toArray=toArray;
        function extendArray(result,arg) {
            var i=0; var lim=arg.length;
            while (i<lim) {result.push(arg[i]); i++;}
            return result;}
        function TOA(arg,start) {
            if ((arg.constructor === Array)||(arg instanceof Array)) {
                if (start) return arg.slice(start);
                else return arg;}
            start=start||0;
            var i=0; var lim=arg.length-start;
            var result=new Array(lim);
            while (i<lim) {result[i]=arg[i+start]; i++;}
            return result;}
        fdjtDOM.Array=TOA;
        fdjtDOM.slice=TOA;

        /* Utility patterns and functions */

        function parsePX(arg,dflt){
            if (typeof dflt === 'undefined') dflt=0;
            if (arg===0) return 0;
            else if (!(arg)) return dflt;
            else if (arg==="none") return dflt;
            else if (arg==="auto") return dflt;
            else if (typeof arg === 'number') return arg;
            else if (typeof arg === 'string') {
                var len=arg.length; var num=false;
                if ((len>2)&&(arg[len-1]==='x')&&(arg[len-2]==='p'))
                    num=parseInt(arg.slice(0,-2));
                else num=parseInt(arg);
                if (num===0) return 0;
                else if (isNaN(num)) return dflt;
                else if (typeof num === 'number') return num;
                else return dflt;}
            else return false;}
        fdjtDOM.parsePX=parsePX;

        function getLineHeight(node){
            var style=getStyle(node);
            var lh=style.lineHeight, fs=style.fontSize;
            if (lh==="normal") return parsePX(fs);
            else if (lh.search(/px$/)>0) return parsePX(lh);
            else if (lh.search(/%$/)>0) 
                return (parseFloat(lh.slice(0,-1))/100)*(parsePX(fs));
            else return parsePX(fs);}
        fdjtDOM.getLineHeight=getLineHeight;

        var css_selector_regex=/((^|[.#])\w+)|(\[\w+=\w+\])/g;

        var whitespace_pat=/(\s)+/;
        var trimspace_pat=/^(\s)+|(\s)+$/;
        var classpats={};
        function classPat(name){
            var rx=new RegExp("\\b"+name+"\\b","g");
            classpats[name]=rx;
            return rx;};

        function string_trim(string){
            var start=string.search(/\S/); var end=string.search(/\s+$/g);
            if ((start===0) && (end<0)) return string;
            else return string.slice(start,end);}

        function nodeString(node){
            if (node.nodeType===3) 
                return "<'"+node.value+"'>";
            else if (node.nodeType===1) {
                var output="<"+node.tagName;
                if (node.id) output=output+"#"+node.id;
                if (node.tagName==='input') {
                    output+"[type="+node.type+"]";
                    output+"[name="+node.name+"]";}
                else if (node.tagName==='textarea')
                    output+"[name="+node.name+"]";
                else if (node.tagName==='img') {
                    if (node.alt) output=output+"[alt="+node.alt+"]";
                    else if (node.src) output=output+"[src="+node.src+"]";}
                else {}
                if (node.className)
                    output=output+"."+node.className.replace(/\s+/g,'.');
                return output+">";}
            else return node.toString();}
        fdjtDOM.nodeString=nodeString;
        
        /* Getting "values" of elements */
        function getElementValues(elt,spec,parse,multiple){
            var candidates=[];
            if (spec.search(/(\.|#|\[|,)/g)>=0) 
                candidates=getChildren(elt,spec);
            else if (elt.getElementsByClassName)
                candidates=elt.getElementsByClassName(spec);
            else candidates=getChildren();
            if (candidates.length===0) {
                if (multiple) return [];
                else return false;}
            else if (multiple) {
                var values=[];
                var i=0, lim=multiple.length;
                while (i<lim) {
                    var txt=candidates[i++].innerText;
                    if (parse) values.push(JSON.parse(txt));
                    else values.push(txt);}
                return values;}
            else if (parse)
                return JSON.parse(candidates[0].innerText);
            else return candidates[0].innerText;}
        fdjtDOM.getElementValues=getElementValues;
        function getElementValue(elt,spec,parse){
            return getElementValues(elt,spec,parse,false);}
        fdjtDOM.getElementValue=getElementValue;

        /* Simple class/attrib manipulation functions */

        function hasClass(elt,classname,attrib){
            var classinfo=((attrib) ? (elt.getAttribute(attrib)||"") :
                           (elt.className));
            if (!(classinfo)) return false;
            else if (classname===true) return true;
            else if (classinfo===classname) return true;
            else if (typeof classname === 'string')
                if (classinfo.indexOf(' ')<0) return false;
            else classname=classpats[classname]||classPat(classname);
            else {}
            if (classinfo.search(classname)>=0) return true;
            else return false;}
        fdjtDOM.hasClass=hasClass;

        function addClass(elt,classname,attrib){
            if (!(elt)) return;
            else if (typeof elt === 'string') {
                if (!(elt=document.getElementById(elt)))
                    return;}
            else if ((NodeList)&&(elt instanceof NodeList))
                return addClass(TOA(elt),classname,attrib);
            else if ((elt.length)&&(!(elt.nodeType))) { // (assume array)
                var elts=TOA(elt);
                var i=0; var lim=elts.length;
                while (i<lim) addClass(elts[i++],classname,attrib||false);
                return;}
            var classinfo=
                (((attrib) ? (elt.getAttribute(attrib)||"") :(elt.className))||null);
            if (!(classinfo)) {
                elt.className=classname; return true;}
            var class_regex=classpats[classname]||classPat(classname);
            var newinfo=classinfo;
            if (classinfo===classname) return false;
            else if (classinfo.search(class_regex)>=0) return false;
            else newinfo=classname+" "+classinfo;
            if (attrib) {
                elt.setAttribute(attrib,newinfo);
                // This sometimes trigger a CSS update that doesn't happen otherwise
                elt.className=elt.className;}
            else elt.className=newinfo;
            return true;}
        fdjtDOM.addClass=addClass;
        fdjtDOM.aC=addClass;

        fdjtDOM.classAdder=function(elt,classname){
            return function() {
                if (elt) addClass(elt,classname);}};

        function dropClass(elt,classname,attrib){
            if (!(elt)) return;
            else if (typeof elt === 'string') {
                if (!(elt=document.getElementById(elt)))
                    return;}
            else if ((NodeList)&&(elt instanceof NodeList))
                return dropClass(TOA(elt),classname,attrib);
            else if ((elt.length)&&(!(elt.nodeType))) {
                var elts=TOA(elt);
                var i=0; var lim=elts.length;
                while (i<lim) dropClass(elts[i++],classname,attrib||false);
                return;}
            var classinfo=
                (((attrib) ? (elt.getAttribute(attrib)||"") :(elt.className))||null);
            if (!(classinfo)) return false;
            var class_regex=
                ((typeof classname === 'string')?
                 (classpats[classname]||classPat(classname)):
                 classname);
            var newinfo=classinfo;
            if (classinfo===classname) 
                newinfo=null;
            else if (classinfo.search(class_regex)>=0) 
                newinfo=classinfo.replace(class_regex,"");
            else return false;
            if (newinfo)
                newinfo=newinfo.
                replace(whitespace_pat," ").
                replace(trimspace_pat,"");
            if (attrib)
                if (newinfo) {
                    elt.setAttribute(attrib,newinfo);
                    elt.className=elt.className;}
            else if (!(keep)) {
                elt.removeAttribute(attrib);
                elt.className=elt.className;}
            else {}
            else elt.className=newinfo;
            return true;}
        fdjtDOM.dropClass=dropClass;
        fdjtDOM.dC=dropClass;

        fdjtDOM.classDropper=function(elt,classname){
            return function() {
                if (elt) dropClass(elt,classname);}};

        function swapClass(elt,drop,add,attrib) {
            dropClass(elt,drop,attrib); addClass(elt,add,attrib);}
        fdjtDOM.swapClass=swapClass;

        function setClass(elt,classname,add){
            if (typeof elt === 'string') elt=document.getElementById(elt);
            if (add) addClass(elt,classname);
            else dropClass(elt,classname);}
        fdjtDOM.setClass=setClass;

        function toggleClass(elt,classname,attrib){
            if (typeof elt === 'string') elt=document.getElementById(elt);
            else if ((NodeList)&&(elt instanceof NodeList))
                return toggleClass(TOA(elt),classname,attrib);
            else if ((elt.length)&&(!(elt.nodeType))) {
                var elts=TOA(elt);
                var i=0; var lim=elts.length;
                while (i<lim) toggleClass(elts[i++],classname,attrib||false);
                return;}
            var classinfo=
                (((attrib) ? (elt.getAttribute(attrib)||"") :
                  (elt.className))||null);
            if (!(classinfo)) {
                if (attrib) elt.setAttribute(attrib,classname);
                else elt.className=classname;
                return true;}
            var class_regex=
                ((typeof classname === 'string')?
                 (classpats[classname]||classPat(classname)):
                 classname);
            var newinfo=classinfo;
            if (classinfo===classname) 
                newinfo=null;
            else if (classinfo.search(class_regex)>=0) 
                newinfo=classinfo.replace(class_regex,"");
            else {
                if (attrib)
                    elt.setAttribute(attrib,classinfo+' '+classname);
                else elt.className=classinfo+' '+classname;
                return true;}
            if (newinfo)
                newinfo=newinfo.
                replace(whitespace_pat," ").
                replace(trimspace_pat,"");
            if (attrib)
                if (newinfo) {
                    elt.setAttribute(attrib,newinfo);
                    elt.className=elt.className;}
            else if (!(keep)) {
                elt.removeAttribute(attrib);
                elt.className=elt.className;}
            else {}
            else elt.className=newinfo;
            return false;}
        fdjtDOM.toggleClass=toggleClass;
        fdjtDOM.tC=toggleClass;
        
        fdjtDOM.isTextInput=function(target){
            return ((target.tagName==='INPUT')||(target.tagName==='TEXTAREA'));};

        /* Simple CSS selectors */

        var selectors={};

        function Selector(spec,tagcs) {
            if (!(spec)) return this; // just cons with type
            else if (selectors[spec]) return selectors[spec]; // check cache
            else if (!(this instanceof Selector))
                // handle case of the forgotten 'new'
                return Selector.call(new Selector(),spec);
            if (spec.indexOf(',')>0) { // compound selectors
                var specs=spec.split(','); var compound=[];
                var i=0; var lim=specs.length;
                while (i<lim) {
                    var sub=string_trim(specs[i++]);
                    compound.push(new Selector(sub));}
                this.compound=compound;
                selectors[spec]=this;
                return this;}
            // Otherwise, parse and set up this
            var elts=spec.match(css_selector_regex);
            var i=0; var lim=elts.length;
            var classes=[]; var classnames=[]; var attribs=false;
            if (!((elts[0][0]==='.')||(elts[0][0]==='#')||(elts[0][0]==='['))) {
                this.tag=((tagcs)?(elts[0]):(elts[0].toUpperCase()));
                i=1;}
            while (i<lim)
                if (elts[i][0]==='#') this.id=elts[i++].slice(1);
            else if (elts[i][0]==='.') {
                classnames.push(elts[i].slice(1));
                classes.push(classPat(elts[i++].slice(1)));}
            else if (elts[i][0]==='[') {
                var aelts=elts[i++]; var eltsend=aelts.length-1;
                if (!(attribs)) attribs={};
                var eqpos=aelts.indexOf('=');
                if (eqpos<0)
                    attribs[aelts.slice(1,eltsend)]=true;
                else if (aelts[eqpos+1]==='~') 
                    attribs[aelts.slice(1,eqpos)]=
                    classPat(aelts.slice(eqpos+2,eltsend));
                else attribs[aelts.slice(1,eqpos)]=aelts.slice(eqpos+1,eltsend);}
            else fdjtLog.uhoh("weird elts %o",elts[i++]);
            if (classes.length) {
                this.classes=classes; this.classnames=classnames;}
            if (attribs) this.attribs=attribs;
            selectors[spec]=this;
            return this;}
        Selector.prototype.match=function(elt){
            if (this.compound) {
                var compound=this.compound; var i=0; var lim=compound.length;
                while (i<lim) if (compound[i++].match(elt)) return true;
                return false;} 
            if ((this.tag)&&(this.tag!==elt.tagName)) return false;
            else if ((this.id)&&(this.id!==elt.id)) return false;
            if (this.classes)
                if (elt.className) {
                    var classname=elt.className; var classes=this.classes;
                    var i=0; var lim=classes.length;
                    while (i<lim) if (classname.search(classes[i++])<0) return false;}
            else return false;
            if (this.attribs) {
                var attribs=this.attribs;
                for (var name in attribs) {
                    var val=elt.getAttribute(name);
                    if (!(val)) return false;
                    var need=this[name];
                    if (need===true) {}
                    else if (typeof need === 'string') {
                        if (need!==val) return false;}
                    else if (val.search(need)<0) return false;}}
            return true;};
        Selector.prototype.find=function(elt,results){
            var pickfirst=false;
            if (!(results)) results=[];
            if (this.compound) {
                var compound=this.compound; var i=0; var lim=compound.length;
                while (i<lim) compound[i++].find(elt,results);
                return results;}
            if (this.id) {
                var elt=document.getElementById(this.id);
                if (!(elt)) return results;
                else if (this.match(elt)) {
                    results.push(elt); return results;}
                else return results;}
            var candidates=[];
            var classnames=this.classnames; var attribs=this.attribs;
            if (this.classes) 
                if (elt.getElementsByClassName)
                    candidates=elt.getElementsByClassName(classnames[0]);
            else gatherByClass(elt,this.classes[0],candidates);
            else if ((this.tag)&&(elt.getElementsByTagName))
                candidates=elt.getElementsByTagName(this.tag);
            else if (this.attribs) {
                var attribs=this.attribs;
                for (var name in attribs) {
                    gatherByAttrib(elt,name,attribs[name],candidates);
                    break;}}
            else if (this.tag) {
                gatherByTag(elt,this.tag,candidates);}
            else {}
            if (candidates.length===0) return candidates;
            if (((this.tag)&&(!(this.classes))&&(!(this.attribs)))||
                ((!(this.tag))&&(this.classes)&&(this.classes.length===1)&&
                 (!(this.attribs))))
                // When there's only one test, don't bother filtering
                if (results.length) return extendArray(results,candidates);
            else if (candidates instanceof Array)
                return candidates;
            else return toArray(candidates);
            var i=0; var lim=candidates.length;
            while (i<lim) {
                var candidate=candidates[i++];
                if (this.match(candidate)) results.push(candidate);}
            return results;};
        fdjtDOM.Selector=Selector;
        fdjtDOM.sel=function(spec){
            if (!(spec)) return false;
            else if (spec instanceof Selector) return spec;
            else if (spec instanceof Array) {
                if (spec.length)
                    return new Selector(spec.join(","));
                else return false;}
            else if (typeof spec === 'string')
                return new Selector(spec);
            else {
                fdjtLog.warn("Non selector spec: %o",spec);
                return false;}};

        function gatherByClass(node,pat,results){
            if (node.nodeType===1) {
                if ((node.className)&&(node.className.search(pat)>=0))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length; var result;
                    while (i<lim) gatherByClass(children[i++],pat,results);}}}
        function gatherByTag(node,tag,results){
            if (node.nodeType===1) {
                if ((typeof tag === "string")?
                    (node.tagName.toLowerString()===tag):
                    ((tag instanceof RegExp)&&(tag.match(node.tagName))))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length; var result;
                    while (i<lim) gatherByTag(children[i++],tag,results);}}}
        function gatherByAttrib(node,attrib,val,results){
            if (node.nodeType===1) {
                if ((node.getAttribute(attrib))&&
                    ((typeof val === 'string')?
                     (node.getAttribute(attrib)===val):
                     (node.getAttribute(attrib).search(val)>=0)))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length; var result;
                    while (i<lim) gatherByTag(children[i++],tag,results);}}}
        
        function gather_children(node,pat,attrib,results){
            if (!(attrib)) gatherByClass(node,pat,results);
            else if (attrib==='class') gatherByClass(node,pat,results);
            else if (attrib==='tagName') gatherByTag(node,pat,results);
            else gatherByAttrib(node,attrib,pat,results);}

        /* Real simple DOM search */

        function getParent(elt,parent,attrib){
            if (typeof elt === 'string') {
                if (elt[0]==='#')
                    elt=document.getElementById(elt.slice(1));
                else elt=document.getElementById(elt);}
            if (!(elt)) return false;
            else if (!(parent)) return false;
            else if (parent.nodeType) {
                while (elt) {
                    if (elt===parent) return parent;
                    else elt=elt.parentNode;}
                return false;}
            else if (typeof parent === 'function') {
                while (elt) {
                    if (parent(elt)) return elt;
                    else elt=elt.parentNode;}
                return false;}
            else if (parent instanceof Selector) {
                while (elt) {
                    if (parent.match(elt)) return elt;
                    else elt=elt.parentNode;}
                return false;}
            else if (typeof parent === 'string')
                return getParent(elt,new Selector(parent));
            else throw { error: 'invalid parent spec'};}
        fdjtDOM.getParent=getParent;
        fdjtDOM.hasParent=getParent;
        fdjtDOM.$P=getParent;
        fdjtDOM.inherits=function(node,spec) {
            var sel=new Selector(spec);
            return ((sel.match(node))?(node):(getParent(node,sel)));};

        function getChildNodes(node){
            if (node.nodeType!==1) return [];
            else if (!(node.childNodes)) return [];
            else return toArray(node.childNodes);}
        fdjtDOM.getChildNodes=getChildNodes;

        function getChildren(node,classname,attrib,results){
            if (typeof node === "string") node=fdjtID(node);
            if (!(node)) return [];
            if (!(results)) results=[]; 
            if (!(attrib)) {
                if (typeof classname === 'function')
                    filter_children(node,classname,results);
                else if (classname instanceof RegExp)
                    regexp_filter_children(node,classname,results);
                else if (classname instanceof Selector)
                    return classname.find(node,results);
                else if (typeof classname === 'string') {
                    if ((usenative) && (node.querySelectorAll))
                        return node.querySelectorAll(classname);
                    else return getChildren(
                        node,new Selector(classname),false,results);}
                else if (classname.length) {
                    var i=0, lim=classname.length;
                    while (i<lim) getChildren(node,classname[i++],attrib,results);}
                else {}}
            else if (!(typeof attrib === 'string'))
                throw { error: 'bad selector arg', selector: classname};
            else {
                var pat=(classpats[classname]||classPat(classname));
                gather_children(node,classname,attrib||false,results);}
            return results;}
        fdjtDOM.getChildren=getChildren;
        fdjt.$=fdjtDOM.$=function(spec,root){
            return toArray(getChildren(root||document,spec));};
        fdjt.$1=fdjtDOM.getFirstChild=function(elt,spec){
            var children=getChildren(elt,spec);
            if (children.length) return children[0]; else return false;};
        fdjtDOM.getChild=fdjtDOM.getFirstChild;

        function filter_children(node,filter,results){
            if (node.nodeType===1) {
                if (filter(node)) results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length; var result;
                    while (i<lim) filter_children(children[i++],filter,results);}}}

        function regexp_filter_children(node,rx,results){
            if (node.nodeType===1) {
                if ((node.className)&&(node.className.search(rx)>=0))
                    results.push(node);
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length; var result;
                    while (i<lim)
                        regexp_filter_children(children[i++],rx,results);}}}

        fdjtDOM.getAttrib=function(elt,attrib,ns){
            var probe;
            if ((ns)&&(elt.getAttributeByNS))
                probe=elt.getAttributeNS(attrib,ns);
            if (probe) return probe;
            else return elt.getAttribute(attrib)||
                elt.getAttribute("data-"+attrib);};

        fdjtDOM.findAttrib=function(scan,attrib,ns){
            var dattrib="data-"+attrib;
            while (scan) {
                if ((ns)&&(scan.getAttributeNS)&&
                    (scan.getAttributeNS(attrib,ns)))
                    return scan.getAttributeNS(attrib,ns);
                else if (scan.getAttribute) {
                    if (scan.getAttribute(attrib))
                        return scan.getAttribute(attrib);
                    else if (scan.getAttribute(dattrib))
                        return scan.getAttribute(dattrib);
                    else scan=scan.parentNode;}
                else scan=scan.parentNode;}
            return false;};
        
        /* First and last elements */
        function getFirstElement(node){
            if (node.firstElementChild) return node.firstElementChild;
            else if ((node.children)&&(node.children.length))
                return node.children[0];
            else return false;}
        fdjtDOM.getFirstElement=getFirstElement;
        function getLastElement(node){
            if (node.lastElementChild) return node.lastElementChild;
            else if ((node.children)&&(node.children.length))
                return node.children[node.children.length-1];
            else return false;}
        fdjtDOM.getLastElement=getLastElement;
            


        /* Manipulating the DOM */

        fdjtDOM.replace=function(existing,replacement){
            var cur=existing;
            if (typeof existing === 'string')
                if (existing[0]==='#')
                    cur=document.getElementById(existing.slice(1));
            else cur=document.getElementById(existing);
            if (cur) {
                cur.parentNode.replaceChild(replacement,cur);
                if ((cur.id)&&(!(replacement.id))) replacement.id=cur.id;}
            else fdjtLog.uhoh("Can't find %o to replace it with %o",
                              existing,replacement);};
        function remove_node(node){
            if (node instanceof Array) {
                var i=0; var lim=node.length;
                while (i<lim) remove_node(node[i++]);
                return;}
            var cur=node;
            if (typeof node === 'string') {
                if (node[0]==='#') cur=document.getElementById(node.slice(1));
                else cur=document.getElementById(node);}
            if ((cur)&&(cur.parentNode))
                cur.parentNode.removeChild(cur);
            else if (cur)
                fdjtLog.uhoh("Looks like %o has already been removed (no parent)",cur);
            else fdjtLog.uhoh("Can't find %o to remove it",node);}
        fdjtDOM.remove=remove_node;
        
        function removeChildren(node){
            var children=node.childNodes, n=children.length-1;
            while (n>=0) node.removeChild(children[n--]);}
        fdjtDOM.removeChildren=removeChildren;

        fdjtDOM.append=function (node) {
            if (typeof node === 'string') node=document.getElementById(node);
            domappend(node,arguments,1);};
        fdjtDOM.prepend=function (node) {
            if (typeof node === 'string') node=document.getElementById(node);
            if (node.firstChild)
                dominsert(node.firstChild,arguments,1);
            else domappend(node,arguments,1);};

        fdjtDOM.insertBefore=function (before) {
            if (typeof before === 'string')
                before=document.getElementById(before);
            dominsert(before,arguments,1);};
        fdjtDOM.insertAfter=function (after) {
            if (typeof after === 'string')
                after=document.getElementById(after);
            if (after.nextSibling)
                dominsert(after.nextSibling,arguments,1);
            else domappend(after.parentNode,arguments,1);};
        
        /* DOM construction shortcuts */

        function tag_spec(spec,tag){
            if (!(spec)) return tag;
            else if (typeof spec === 'string') {
                var wordstart=spec.search(/\w/g);
                var puncstart=spec.search(/\W/g);
                if (puncstart<0) return tag+"."+spec;
                else if (wordstart!==0) return tag+spec;
                return spec;}
            else if (spec.tagName) return spec;
            else {
                spec.tagName=tag;
                return spec;}}

        fdjtDOM.Input=function(spec,name,value,title){
            if (spec.search(/\w/)!==0) spec='INPUT'+spec;
            var node=fdjtDOM(spec);
            node.name=name;
            if (value) node.value=value;
            if (title) node.title=title;
            return node;};
        fdjtDOM.Checkbox=function(name,value,checked){
            var node=fdjtDOM("INPUT");
            node.type="checkbox"
            node.name=name;
            if (value) node.value=value;
            if (checked) node.checked=true;
            else node.checked=false;
            return node;};
        fdjtDOM.Anchor=function(href,spec){
            spec=tag_spec(spec,"A");
            var node=fdjtDOM(spec); node.href=href;
            domappend(node,arguments,2);
            return node;};
        fdjtDOM.Image=function(src,spec,alt,title){
            spec=tag_spec(spec,"IMG");
            var node=fdjtDOM(spec); node.src=src;
            if (alt) node.alt=alt;
            if (title) node.title=title;
            domappend(node,arguments,4);
            return node;};

        function getInputs(root,name,type){
            var results=[];
            if (typeof root === 'string') {
                var root_elt=document.getElementById(root);
                if (!(root_elt)) fdjtLog.warn("Couldn't resolve %s to an object",root);
                root=root_elt;}
            if (!(root)) return results;
            var inputs=root.getElementsByTagName('input');
            var i=0; var lim=inputs.length;
            while (i<lim) {
                if (((!(name))||(inputs[i].name===name))&&
                    ((!(type))||(inputs[i].type===type)))
                    results.push(inputs[i++]); 
                else i++;}
            if ((!type)||(type==='textarea')||(type==='text')) {
                var inputs=root.getElementsByTagName('textarea');
                var i=0; var lim=inputs.length;
                while (i<lim) {
                    if (((!(name))||(inputs[i].name===name))&&
                        ((!(type))||(inputs[i].type===type)))
                        results.push(inputs[i++]); 
                    else i++;}}
            if ((!type)||(type==='button')||(type==='submit')) {
                var inputs=root.getElementsByTagName('button');
                var i=0; var lim=inputs.length;
                while (i<lim) {
                    if (((!(name))||(inputs[i].name===name))&&
                        ((!(type))||(inputs[i].type===type)))
                        results.push(inputs[i++]); 
                    else i++;}}
            if ((!type)||(type==='select')) {
                var inputs=root.getElementsByTagName('select');
                var i=0; var lim=inputs.length;
                while (i<lim) {
                    if ((!(name))||(inputs[i].name===name))
                        results.push(inputs[i++]); 
                    else i++;}}
            return results;}

        fdjtDOM.getInputs=getInputs;
        fdjtDOM.getInput=function(root,name,type){
            var results=getInputs(root,name||false,type||false);
            if ((results)&&(results.length===1))
                return results[0];
            else if ((results)&&(results.length)) {
                fdjtLog.warn(
                    "Ambiguous input reference name=%o type=%o under %o",
                    name,type,root);
                return results[0];}
            else return false;};
        
        function getInputValues(root,name){
            var results=[];
            var inputs=root.getElementsByTagName('input');
            var i=0; var lim=inputs.length;
            while (i<lim) {
                var input=inputs[i++];
                if (input.name!==name) continue;
                if ((input.type==='checkbox')||(input.type==='radio')) {
                    if (!(input.checked)) continue;}
                results.push(input.value);}
            return results;}
        fdjtDOM.getInputValues=getInputValues;

        function getInputsFor(root,name,value){
            if (typeof root === 'string')
                root=document.getElementById(root);
            if (!(root)) return [];
            var results=[];
            var inputs=root.getElementsByTagName('input');
            var i=0; var lim=inputs.length;
            while (i<lim) {
                var input=inputs[i++];
                if (input.name!==name) continue;
                else if (input.value!==value) continue;
                else results.push(input);}
            return results;}
        fdjtDOM.getInputsFor=getInputsFor;
        fdjtDOM.getInputFor=function(root,name,value){
            var results=getInputsFor(root,name||false,value||false);
            if ((results)&&(results.length===1))
                return results[0];
            else if ((results)&&(results.length)) {
                fdjtLog.warn(
                    "Ambiguous input reference name=%o type=%o under %o",
                    name,type,root);
                return results[0];}
            else return false;};


        /* Getting style information generally */

        function getStyle(elt,prop){
            if (typeof elt === 'string') elt=document.getElementById(elt);
            if (!(elt)) return elt;
            if (elt.nodeType!==1) throw "Not an element";
            try {
                var style=
                    ((window.getComputedStyle)&&
                     (window.getComputedStyle(elt,null)))||
                    (elt.currentStyle);
                if (!(style)) return false;
                else if (prop) return style[prop];
                else return style;}
            catch (ex) {
                fdjtLog("Unexpected style error %o",ex);
                return false;}}
        fdjtDOM.getStyle=getStyle;

        function styleString(elt){
            var style=elt.style; var result;
            if (!(style)) return false;
            var i=0; var lim=style.length;
            if (lim===0) return false;
            while (i<lim) {
                var p=style[i];
                var v=style[p];
                if (i===0) result=p+": "+v;
                else result=result+"; "+p+": "+v;
                i++;}
            return result;}
        fdjtDOM.styleString=styleString;

        /* Getting display style */

        var display_styles={
            "DIV": "block","P": "block","BLOCKQUOTE":"block",
            "H1": "block","H2": "block","H3": "block","H4": "block",
            "H5": "block","H6": "block","H7": "block","H8": "block",
            "UL": "block","LI": "list-item",
            "DL": "block","DT": "list-item","DD": "list-item",
            "SPAN": "inline","EM": "inline","STRONG": "inline",
            "TT": "inline","DEFN": "inline","A": "inline",
            "TD": "table-cell","TR": "table-row",
            "TABLE": "table", "PRE": "preformatted"};

        function getDisplayStyle(elt){
            if ((!(elt))||(!(elt.nodeType))||(elt.nodeType!==1))
                return false;
            return (((window.getComputedStyle)&&
                     (window.getComputedStyle(elt,null))&&
                     (window.getComputedStyle(elt,null).display))||
                    (display_styles[elt.tagName])||
                    "inline");}
        fdjtDOM.getDisplay=getDisplayStyle;

        /* Generating text from the DOM */

        function flatten(string){return string.replace(/\s+/," ");};

        function textify(arg,flat,depth,domarkup){
            if (typeof depth !== 'number') depth=0;
            if (arg.text) return flatten(arg.text);
            else if (arg.nodeType) {
                if (arg.nodeType===3) {
                    if (flat) return flatten(arg.nodeValue);
                    else return arg.nodeValue;}
                else if (arg.nodeType===1) {
                    var children=arg.childNodes;
                    var style=getStyle(arg);
                    var display_type=style.display;
                    var whitespace=style.whiteSpace;
                    var classname=arg.className;
                    var string=""; var suffix="";
                    if (whitespace!=="normal") flat=false;
                    if (display_type==='none') return "";
                    else if ((classname)&&
                             ((classname==='fdjtskiptext')||
                              (classname.search(/\bfdjtskiptext\b/)>=0)))
                        return "";
                    else if ((!(children))||(children.length===0)) {
                        if (!(domarkup)) return "";
                        else if (arg.alt) return "["+arg.alt+"]";
                        else return "[?]";}
                    // Figure out what suffix and prefix to use for this element
                    else if (!(display_type)) {}
                    else if (display_type==="inline") {}
                    else if (flat) suffix=" ";
                    else if ((display_type==="block") ||
                             (display_type==="table") ||
                             (display_type==="preformatted")) {
                        string="\n"; suffix="\n";}
                    else if (display_type==="table-row") suffix="\n";
                    else if (display_type==="table-cell") string="\t";
                    else {}
                    var i=0; while (i<children.length) {
                        var child=children[i++];
                        if (!(child.nodeType)) continue;
                        if (child.nodeType===3) {
                            if (flat) string=string+flatten(child.nodeValue);
                            else string=string+child.nodeValue;}
                        else if (child.nodeType===1) {
                            var stringval=textify(child,flat,true,domarkup);
                            if (stringval) string=string+stringval;}
                        else continue;}
                    return string+suffix;}
                else {}}
            else if (arg.toString)
                return arg.toString();
            else return arg.toString();}
        fdjtDOM.textify=textify;

        /* Geometry functions */

        function getGeometry(elt,root,extra,withstack){
            if (!(withstack)) withstack=false;
            if (typeof elt === 'string')
                elt=document.getElementById(elt);
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var stack = ((withstack) ? (new Array(elt)) : false);
            var width=elt.offsetWidth;
            var height=elt.offsetHeight;
            var rootp=((root)&&(root.offsetParent));
            var style=((extra)&&(getStyle(elt)));

            if (elt===root) 
                return {left: 0,top: 0,width:width,height: height,
                        bottom: height,right: width};
            elt=elt.offsetParent;
            while (elt) {
                if ((root)&&((elt===root)||(elt===rootp))) break;
                if (withstack) withstack.push(elt);
                top += elt.offsetTop;
                left += elt.offsetLeft;
                elt=elt.offsetParent;}
            
            if (style) {
                var t_margin=parsePX(style.marginTop);
                var r_margin=parsePX(style.marginRight);
                var b_margin=parsePX(style.marginBottom);
                var l_margin=parsePX(style.marginLeft);
                var t_padding=parsePX(style.paddingTop);
                var r_padding=parsePX(style.paddingRight);
                var b_padding=parsePX(style.paddingBottom);
                var l_padding=parsePX(style.paddingLeft);
                var t_border=parsePX(style.borderTopWidth);
                var r_border=parsePX(style.borderRightWidth);
                var b_border=parsePX(style.borderBottomWidth);
                var l_border=parsePX(style.borderLeftWidth);
                var outer_width=width+l_margin+r_margin;
                var outer_height=height+t_margin+b_margin;
                var inner_width=width-(l_border+l_padding+r_border+r_padding);
                var inner_height=height-(t_border+t_padding+b_border+b_padding);
                var lh=style.lineHeight, fs=style.fontSize, lhpx=false;
                if (lh==="normal") lhpx=parsePX(fs);
                else if (lh.search(/px$/)>0) lhpx=parsePX(lh);
                else if (lh.search(/%$/)>0) 
                    lhpx=(parseFloat(lh.slice(0,-1))/100)*(parsePX(fs));
                else lhpx=parsePX(fs);
                return {left: left, top: top, width: width,height: height,
                        right:left+width,bottom:top+height,
                        top_margin: t_margin, bottom_margin: b_margin,
                        left_margin: l_margin, right_margin: r_margin,
                        outer_height: outer_height,outer_width: outer_width,
                        inner_height: inner_height,outer_width: inner_width,
                        line_height: lhpx,stack:withstack};}
            else return {left: left, top: top, width: width,height: height,
                         right:left+width,bottom:top+height,
                         stack:withstack};}
        fdjtDOM.getGeometry=getGeometry;

        function geomString(geom){
            return +((typeof geom.width == 'number')?(geom.width):"?")+
                "x"+((typeof geom.height == 'number')?(geom.height):"?")+
                "@l:"+((typeof geom.left == 'number')?(geom.left):"?")+
                ",t:"+((typeof geom.top == 'number')?(geom.top):"?")+
                "/r:"+((typeof geom.right == 'number')?(geom.right):"?")+
                ",b:"+((typeof geom.bottom == 'number')?(geom.bottom):"?");}
        fdjtDOM.geomString=geomString;

        function isVisible(elt,partial){
            var start=elt;
            if (!(partial)) partial=false;
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var width = elt.offsetWidth;
            var height = elt.offsetHeight;
            var winx=(window.pageXOffset||document.documentElement.scrollLeft||0);
            var winy=(window.pageYOffset||document.documentElement.scrollTop||0);
            var winxedge=winx+(document.documentElement.clientWidth);
            var winyedge=winy+(document.documentElement.clientHeight);
            
            while(elt.offsetParent) {
                if (elt===window) break;
                elt = elt.offsetParent;
                top += elt.offsetTop;
                left += elt.offsetLeft;}

            if ((elt)&&(!((elt===window)||(elt===document.body)))) {
                // fdjtLog("%o l=%o t=%o",elt,elt.scrollLeft,elt.scrollTop);
                if ((elt.scrollTop)||(elt.scrollLeft)) {
                    fdjtLog("Adjusting for inner DIV");
                    winx=elt.scrollLeft; winy=elt.scrollTop;
                    winxedge=winx+elt.scrollWidth;
                    winyedge=winy+elt.scrollHeight;}}

            /*
              fdjtLog("fdjtIsVisible%s %o top=%o left=%o height=%o width=%o",
              ((partial)?("(partial)"):""),start,
              top,left,height,width);
              fdjtLog("fdjtIsVisible %o winx=%o winy=%o winxedge=%o winyedge=%o",
              elt,winx,winy,winxedge,winyedge);
            */
            
            if (partial)
                // There are three cases we check for:
                return (
                    // top of element in window
                    ((top > winy) && (top < winyedge) &&
                     (left > winx) && (left < winxedge)) ||
                        // bottom of element in window
                        ((top+height > winy) && (top+height < winyedge) &&
                         (left+width > winx) && (left+width < winxedge)) ||
                        // top above/left of window, bottom below/right of window
                        (((top < winy) || (left < winx)) &&
                         ((top+height > winyedge) && (left+width > winxedge))));
            else return ((top > winy) && (left > winx) &&
                         (top + height) <= (winyedge) &&
                         (left + width) <= (winxedge));}
        fdjtDOM.isVisible=isVisible;

        function isAtTop(elt,delta){
            if (!(delta)) delta=50;
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var width = elt.offsetWidth;
            var height = elt.offsetHeight;
            var winx=(window.pageXOffset||document.documentElement.scrollLeft||0);
            var winy=(window.pageYOffset||document.documentElement.scrollTop||0);
            var winxedge=winx+(document.documentElement.clientWidth);
            var winyedge=winy+(document.documentElement.clientHeight);
            
            while(elt.offsetParent) {
                elt = elt.offsetParent;
                top += elt.offsetTop;
                left += elt.offsetLeft;}

            return ((top>winx) && (top<winyedge) && (top<winx+delta));}
        fdjtDOM.isAtTop=isAtTop;

        function textwidth(node){
            if (node.nodeType===3) return node.nodeValue.length;
            else if (node.nodeType!==1) return 0;
            else if ((node.className==="fdjtskiptext")||
                     (node.className.search(/\bfdjtskiptext/)>=0))
                return 0;
            else if (node.childNodes) {
                var children=node.childNodes;
                var i=0; var lim=children.length; var width=0;
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===3) width=width+child.nodeValue.length;
                    else if (child.nodeType===1)
                        width=width+textwidth(child);
                    else {}}
                return width;}
            else if (node.alt) return node.alt.length+2;
            else return 3;}
        fdjtDOM.textWidth=textwidth;

        function countBreaks(arg){
            if (typeof arg === 'string') {
                return arg.match(/\W*\s+\W*/g).length;}
            else if (!(arg.nodeType)) return 0;
            else if (arg.nodeType===1) {}
            else if (arg.nodeType===3)
                return arg.nodeValue.match(/\W*\s+\W*/g).length;
            else return 0;}
        fdjtDOM.countBreaks=countBreaks;

        function wordOffset(arg){
            var scan=arg; var count=0;
            while (scan=(scan.previousSibling||scan.parentNode)) {
                if (scan.nodeType===3)
                    count=count+(scan.nodeValue.match(/\W*\s+\W*/g).length);
                else if (scan.nodeType===1)
                    count=count+countBreaks(scan);
                else {}}
            return count;}

        function hasContent(node,recur,test){
            if (node===recur) return false;
            else if (node.nodeType===3)
                return (child.nodeValue.search(/\w/g)>=0);
            else if (node.nodeType!==1) return false;
            else if ((test)&&(test.match)&&(test.match(node)))
                return true;
            else if ((test===true)&&
                     ((node.tagName==='IMG')||
                      (node.tagName==='OBJECT')||
                      (node.tagName==='HR')))
                return true;
            else if (node.childNodes) {
                var children=node.childNodes;
                var i=0; while (i<children.length) {
                    var child=children[i++];
                    if (child===recur) return false;
                    else if (child.nodeType===3) {
                        if (child.nodeValue.search(/\w/g)>=0) return true;
                        else continue;}
                    else if (child.nodeType!==1) continue;
                    else if (recur) {
                        if (hasContent(child,recur,test)) return true;
                        else continue;}
                    else continue;}
                return false;}
            else return false;}
        fdjtDOM.hasContent=hasContent;

        function hasText(node){
            if (node.childNodes) {
                var children=node.childNodes;
                var i=0; while (i<children.length) {
                    var child=children[i++];
                    if (child.nodeType===3)
                        if (child.nodeValue.search(/\w/g)>=0) return true;
                    else {}}
                return false;}
            else return false;}
        fdjtDOM.hasText=hasText;

        /* A 'refresh method' does a className eigenop to force IE redisplay */

        fdjtDOM.refresh=function(elt){
            elt.className=elt.className;};
        fdjtDOM.setAttrib=function(elt,attrib,val){
            if ((typeof elt === 'string')&&(fdjtID(elt)))
                elt=fdjtID(elt);
            elt.setAttribute(attrib,val);
            elt.className=elt.className;};
        fdjtDOM.dropAttrib=function(elt,attrib){
            if ((typeof elt === 'string')&&(fdjtID(elt)))
                elt=fdjtID(elt);
            elt.removeAttribute(attrib);
            elt.className=elt.className;};

        /* Determining if something has overflowed */
        fdjtDOM.overflowing=function(node){
            return (node.scrollHeight>node.clientHeight);}
        fdjtDOM.voverflow=function(node){
            return (node.scrollHeight/node.clientHeight);}
        fdjtDOM.hoverflow=function(node){
            return (node.scrollWidth/node.clientWidth);}

        /* Adjusting font sizes (wrappers for adjustfont.js) */
        fdjtDOM.adjustFont=function(elt,opts){
            return fdjt.UI.adjustFont.update(elt,opts);};
        fdjtDOM.adjustFonts=function(elt,opts){
            return fdjt.UI.adjustFont.update(elt,opts);};
        
        /* Sizing to fit */

        var default_trace_adjust=false;

        function getInsideBounds(container){
            var left=false; var top=false;
            var right=false; var bottom=false;
            var children=container.childNodes;
            var i=0; var lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (typeof child.offsetLeft !== 'number') continue;
                var style=getStyle(child);
                if (style.position!=='static') continue;
                var child_left=child.offsetLeft-parsePX(style.marginLeft);
                var child_top=child.offsetTop-parsePX(style.marginTop);
                var child_right=child.offsetLeft+child.offsetWidth+parsePX(style.marginRight);
                var child_bottom=child.offsetTop+child.offsetHeight+parsePX(style.marginBottom);
                if (left===false) {
                    left=child_left; right=child_right;
                    top=child_top; bottom=child_bottom;}
                else {
                    if (child_left<left) left=child_left;
                    if (child_top<top) top=child_top;
                    if (child_right>right) right=child_right;
                    if (child_bottom>bottom) bottom=child_bottom;}}
            return {left: left,right: right,top: top, bottom: bottom,
                    width: right-left,height:bottom-top};}
        fdjtDOM.getInsideBounds=getInsideBounds;
        function applyScale(container,scale,traced){
            var images=fdjtDOM.getChildren(container,"IMG");
            var ilim=images.length;
            var oldscale=container.scale||100;
            if (scale) {
                container.scale=scale;
                container.style.fontSize=scale+'%';
                var rounded=10*Math.round(scale/10);
                fdjtDOM.addClass(container,"fdjtscaled");
                fdjtDOM.swapClass(
                    container,/\bfdjtscale\d+\b/,"fdjtscale"+rounded);}
            else if (!(container.scale)) return;
            else {
                delete container.scale;
                container.style.fontSize="";
                fdjtDOM.dropClass(container,"fdjtscaled");
                fdjtDOM.dropClass(container,/\bfdjtscale\d+\b/);}
            var iscan=0; while (iscan<ilim) {
                var image=images[iscan++];
                if ((fdjtDOM.hasClass(image,"nofdjtscale"))||
                    (fdjtDOM.hasClass(image,"noautoscale")))
                    continue;
                // Reset dimensions to get real info
                image.style.maxWidth=image.style.width=
                    image.style.maxHeight=image.style.height='';
                if (scale) {
                    var width=image.offsetWidth;
                    var height=image.offsetHeight;
                    image.style.maxWidth=image.style.width=
                        Math.round(width*(scale/100))+'px';
                    image.style.maxHeight=image.style.height=
                        Math.round(height*(scale/100))+'px';}}}
        
        function adjustInside(elt,container,step,min,pad){
            var trace_adjust=(elt.traceadjust)||
                (container.traceadjust)||fdjtDOM.trace_adjust||
                ((elt.className)&&(elt.className.search(/\btraceadjust\b/)>=0))||
                ((container.className)&&
                 (container.className.search(/\btraceadjust\b/)>=0))||
                default_trace_adjust;
            if (!(step)) step=5;
            if (!(min)) min=50;
            if (!(pad)) pad=1;
            var scale=100;
            function adjust(){
                var outside=getGeometry(container);
                var inside=getGeometry(elt,container);
                var style=getStyle(container);
                var maxwidth=
                    outside.width-
                    (parsePX(style.paddingLeft,0)+
                     parsePX(style.borderLeft,0)+
                     parsePX(style.paddingRight,0)+
                     parsePX(style.borderRight,0));
                var maxheight=
                    outside.height-
                    (parsePX(style.paddingTop,0)+
                     parsePX(style.borderTop,0)+
                     parsePX(style.paddingBottom,0)+
                     parsePX(style.borderBottom,0));
                if (trace_adjust)
                    fdjtLog("adjustInside scale=%o step=%o min=%o pad=%o [l%o,t%o,r%o,b%o] << %ox%o < %ox%o",
                            scale,step,min,pad,
                            inside.left,inside.top,inside.right,inside.bottom,
                            maxwidth*pad,maxheight*pad,
                            maxwidth,maxheight);
                if ((inside.top>=0)&&(inside.bottom<=(pad*maxheight))&&
                    (inside.left>=0)&&(inside.right<=(pad*maxwidth)))
                    return;
                else if (scale<=min) return;
                else {
                    scale=scale-step;
                    applyScale(elt,scale,trace_adjust);
                    setTimeout(adjust,10);}}
            setTimeout(adjust,10);}
        function adjustToFit(container,threshold,padding){
            var trace_adjust=(container.traceadjust)||
                fdjtDOM.trace_adjust||
                ((container.className)&&
                 (container.className.search(/\btraceadjust\b/)>=0))||
                default_trace_adjust;
            var style=getStyle(container);
            var geom=getGeometry(container);
            var maxheight=((style.maxHeight)&&(parsePX(style.maxHeight)))||
                (geom.height);
            var maxwidth=((style.maxWidth)&&(parsePX(style.maxWidth)))||
                (geom.width);
            var goodenough=threshold||0.1;
            var scale=(container.scale)||100.0;
            var bounds=getInsideBounds(container);
            var hpadding=
                (fdjtDOM.parsePX(style.paddingLeft)||0)+
                (fdjtDOM.parsePX(style.paddingRight)||0)+
                (fdjtDOM.parsePX(style.borderLeftWidth)||0)+
                (fdjtDOM.parsePX(style.borderRightWidth)||0)+
                padding;
            var vpadding=
                (fdjtDOM.parsePX(style.paddingTop)||0)+
                (fdjtDOM.parsePX(style.paddingBottom)||0)+
                (fdjtDOM.parsePX(style.borderTopWidth)||0)+
                (fdjtDOM.parsePX(style.borderBottomWidth)||0)+
                padding;
            maxwidth=maxwidth-hpadding; maxheight=maxheight-vpadding; 
            var itfits=
                ((bounds.height/maxheight)<=1)&&((bounds.width/maxwidth)<=1);
            if (trace_adjust) 
                fdjtLog("Adjust (%o) %s cur=%o%s, best=%o~%o, limit=%ox%o=%o, box=%ox%o=%o, style=%s",
                        goodenough,fdjtDOM.nodeString(container),
                        scale,((itfits)?" (fits)":""),
                        container.bestscale||-1,container.bestfit||-1,
                        maxwidth,maxheight,maxwidth*maxheight,
                        bounds.width,bounds.height,bounds.width*bounds.height,
                        styleString(container));
            if (itfits) {
                /* Figure out how well it fits */
                var fit=Math.max((1-(bounds.width/maxwidth)),
                                 (1-(bounds.height/maxheight)));
                var bestfit=container.bestfit||1.5;
                if (!(trace_adjust)) {}
                else if (container.bestscale) 
                    fdjtLog("%s %o~%o vs. %o~%o",
                            ((fit<goodenough)?"Good enough!":
                             ((fit<bestfit)?"Better!":"Worse!")),
                            scale,fit,container.bestscale,container.bestfit);
                else fdjtLog("First fit %o~%o",scale,fit);
                if (fit<bestfit) {
                    container.bestscale=scale; container.bestfit=fit;}
                // If it's good enough, just return
                if (fit<goodenough) {
                    container.goodscale=scale; return;}}
            // Figure out the next scale factor to try
            var dh=bounds.height-maxheight; var dw=bounds.width-maxwidth;
            var rh=maxheight/bounds.height; var rw=maxwidth/bounds.width;
            var newscale=
                ((itfits)?
                 (scale*Math.sqrt
                  ((maxwidth*maxheight)/(bounds.width*bounds.height))):
                 (rh<rw)?(scale*rh):(scale*rw));
            if (trace_adjust)
                fdjtLog("[%fs] Trying newscale=%o, rw=%o rh=%o",
                        fdjtET(),newscale,rw,rh);
            applyScale(container,newscale,trace_adjust);}
        fdjtDOM.applyScale=applyScale;
        fdjtDOM.adjustToFit=adjustToFit;
        fdjtDOM.adjustInside=adjustInside;
        fdjtDOM.insideBounds=getInsideBounds;
        fdjtDOM.finishScale=function(container){
            var traced=(container.traceadjust)||
                fdjtDOM.trace_adjust||default_trace_adjust;
            if (!(container.bestscale)) {
                applyScale(container,false,traced);
                fdjtLog("No good scaling for %o style=%s",
                        fdjtDOM.nodeString(container),
                        fdjtDOM.styleString(container));
                return;}
            else if (container.scale===container.bestscale) {}
            else applyScale(container,container.bestscale,traced);
            if (traced)
                fdjtLog("Final scale %o~%o for %o style=%s",
                        container.bestscale,container.bestfit,
                        fdjtDOM.nodeString(container),
                        fdjtDOM.styleString(container));
            delete container.bestscale;
            delete container.bestfit;
            delete container.goodscale;};
        
        /* Getting various kinds of metadata */

        function getHTML(){
            var children=document.childNodes;
            var i=0; var lim=children.length;
            while (i<lim)
                if (children[i].tagName==='HTML') return children[i];
            else i++;
            return false;}
        fdjtDOM.getHTML=getHTML;

        function getHEAD(){
            var children=document.childNodes;
            var i=0; var lim=children.length;
            while (i<lim)
                if (children[i].tagName==='HTML') {
                    var grandchildren=children[i].childNodes;
                    i=0; lim=grandchildren.length;
                    while (i<lim)
                        if (grandchildren[i].tagName==='HEAD')
                            return grandchildren[i];
                    else i++;
                    return false;}
            else i++;
            return false;}
        fdjtDOM.getHEAD=getHEAD;

        var schema2tag={}, tag2schema={};
        var got_meta_schemas=false;
        function getMetaSchemas(){
            var links=
                ((document.getElementsByTagName)&&
                 (document.getElementsByTagName('link')))||
                ((document.head.getElementsByTagName)&&
                 (document.head.getElementsByTagName('link')))||
                (getChildren(document,'link'));
            var i=0, lim=links.length;
            while (i<lim) {
                var link=links[i++];
                if (!(link.rel)) continue;
                else if (!(link.href)) continue;
                else if (link.rel.search("schema.")===0) {
                    var tag=link.rel.slice(7);
                    var href=link.href;
                    // We let there be multiple references
                    schema2tag[href]=tag;
                    tag2schema[tag]=href;}
                else continue;}}
        var app_schemas={};
        fdjtDOM.addAppSchema=function(name,spec){
            app_schemas[name]=spec;};

        function getMeta(name,multiple,foldcase,dom){
            var results=[];
            var elts=((document.getElementsByTagName)?
                      (document.getElementsByTagName("META")):
                      (getChildren(document,"META")));
            var rx=((name instanceof RegExp)?(name):(false));
            if ((typeof name ==='string')&&
                (typeof foldcase==='undefined')) {
                if (name[0]==='^') {
                    foldcase=false; name=name.slice(1);}
                else if (name[0]==='~') {
                    foldcase=true; name=name.slice(1);}
                else {}}
            if (typeof name !== 'string') {}
            else if (name[0]==='{') {
                var schema_end=name.indexOf('}'), schema=false;
                if (schema_end>2) schema=name.slice(1,schema_end);
                var prefix=((schema)&&(schema2tag[schema]));
                if (prefix) name=prefix+"."+name.slice(schema_end+1);}
            else if (name[0]==='=') {
                // This overrides any schema expansion
                name=name.slice(1);}
            else if ((name[0]==='*')&&(name[1]==='.')) {
                // This overrides any schema expansion
                rx=new RegExp("[^.]\\."+name.slice(2),
                              ((foldcase)?("i"):("")));}
            else if (name.indexOf('.')>0) {
                var dot=name.indexOf('.');
                var prefix=name.slice(0,dot);
                var schema=app_schemas[prefix];
                if ((schema)&&(schema2tag[schema])) 
                    name=schema2tag[schema]+name.slice(dot);}
            else {}
            var matchname=((foldcase)&&
                           (typeof name === 'string')&&
                           (name.toUpperCase()));
            var i=0; while (i<elts.length) {
                var elt=elts[i++];
                if (!(elt)) continue;
                else if (!(elt.name)) continue;
                else if ((rx)?(rx.exec(elt.name)):
                         (matchname)?
                         (matchname===elt.name.toUpperCase()):
                         (name===elt.name)) {
                    if (multiple) {
                        if (dom) results.push(elt);
                        else results.push(elt.content);}
                    else if (dom) return elt;
                    else return elt.content;}
                else {}}
            if (multiple) return results;
            else return false;}
        fdjtDOM.getMeta=getMeta;
        fdjtDOM.getMetaElts=function(name){
            var matchcase;
            return getMeta(name,true,matchcase,true);};

        // This gets a LINK href field
        function getLink(name,multiple,foldcase,dom){
            var results=[];
            var elts=((document.getElementsByTagName)?
                      (document.getElementsByTagName("LINK")):
                      ((document.body)&&(document.body.getElementsByTagName))?
                      (document.body.getElementsByTagName("LINK")):
                      (getChildren(document,"LINK")));
            var rx=((name instanceof RegExp)?(name):(false));
            if ((typeof name ==='string')&&
                (typeof foldcase==='undefined')) {
                if (name[0]==='^') {
                    foldcase=false; name=name.slice(1);}
                else if (name[0]==='~') {
                    foldcase=true; name=name.slice(1);}
                else {}}
            if (typeof name !== 'string') {}
            else if (name[0]==='{') {
                var schema_end=name.indexOf('}'), schema=false;
                if (schema_end>2) schema=name.slice(1,schema_end);
                var prefix=((schema)&&(schema2tag[schema]));
                if (prefix) name=prefix+"."+name.slice(schema_end+1);}
            else if (name[0]==='=') {
                // This overrides any schema expansion and does
                //  just a literal string match
                name=name.slice(1);}
            else if ((name[0]==='*')&&(name[1]==='.')) {
                // Schema wildcard, not recommended
                rx=new RegExp("[^.]\\."+name.slice(2),
                              ((foldcase)?("i"):("")));}
            else if (name.indexOf('.')>0) {
                var dot=name.indexOf('.');
                var prefix=name.slice(0,dot);
                var schema=app_schemas[prefix];
                if ((schema)&&(schema2tag[schema])) 
                    name=schema2tag[schema]+name.slice(dot);}
            else {}
            var matchname=((foldcase)&&
                           (typeof name === 'string')&&
                           (name.toUpperCase()));
            var i=0; while (i<elts.length) {
                var elt=elts[i++];
                if (!(elt)) continue;
                else if (!(elt.rel)) continue;
                else if ((rx)?(rx.exec(elt.rel)):
                         (matchname)?
                         (matchname===elt.rel.toUpperCase()):
                         (name===elt.rel)) {
                    if (multiple) {
                        if (dom) results.push(elt);
                        else results.push(elt.href);}
                    else if (dom) return elt;
                    else return elt.href;}
                else {}}
            if (multiple) return results;
            else return false;}
        fdjtDOM.getLink=getLink;
        fdjtDOM.getLinks=function(name){return getLink(name,true);};
        fdjtDOM.getLinkElts=function(name){
            var matchcase;
            return getLink(name,true,matchcase,true);};

        /* Going forward */

        /* If there's a children property (childNodes which are elements),
           we assume that all the element-specific fields exist. */
        var havechildren=((document)&&
                          (document.body)&&
                          (document.body.childNodes)&&
                          (document.body.children));

        // NEXT goes to the next sibling or the parent's next sibling
        function next_node(node){
            while (node) {
                if (node.nextSibling)
                    return node.nextSibling;
                else node=node.parentNode;}
            return false;}
        function next_element(node){
            if (node.nextElementSibling)
                return node.nextElementSibling;
            else {
                var scan=node;
                while (scan=scan.nextSibling) {
                    if (!(scan)) return null;
                    else if (scan.nodeType===1) break;
                    else {}}
                return scan;}}
        function scan_next(node,test,justelts){
            if (!(test))
                if (justelts) {
                    if (havechildren) return node.nextElementSibling;
                    else return next_element(node);}
            else return next_node(node);
            var scan=((justelts)?
                      ((havechildren)?
                       (node.nextElementSibling):(next_element(node))):
                      ((node.nextSibling)||(next_node(node))));
            while (scan)
                if (test(scan)) return scan;
            else if (justelts)
                scan=((scan.nextElementSibling)||(next_element(scan)));
            else scan=((scan.nextSibling)||(next_node(scan)));
            return false;}

        // FORWARD goes to the first deepest child
        function forward_node(node){
            if ((node.childNodes)&&((node.childNodes.length)>0))
                return node.childNodes[0];
            else while (node) {
                if (node.nextSibling)
                    return node.nextSibling;
                else node=node.parentNode;}
            return false;}
        function forward_element(node,n){
            var scan;
            if (n) {
                var i=0; scan=node;
                while (i<n) {scan=forward_element(scan); i++;}
                return scan;}
            if (havechildren) {
                if ((node.children)&&(node.children.length>0)) {
                    return node.children[0];}
                if (scan=node.nextElementSibling) return scan;
                while (node=node.parentNode)
                    if (scan=node.nextElementSibling) return scan;
                return false;}
            else {
                if (node.childNodes) {
                    var children=node.childNodes; var i=0; var lim=children.length;
                    while (i<lim)
                        if ((scan=children[i++])&&(scan.nodeType===1)) return scan;}
                while (scan=node.nextSibling) if (scan.nodeType===1) return scan;
                while (node=node.parentNode)
                    if (scan=next_element(node)) return scan;
                return false;}}
        function scan_forward(node,test,justelts){
            if (!(test)) {
                if (justelts) return forward_element(node);
                else return forward_node(node);}
            var scan=((justelts)?(forward_element(node)):(forward_node(node)));
            while (scan) {
                if (test(scan)) return scan;
                else if (justelts) scan=next_element(scan);
                else scan=next_node(scan);}
            return false;}

        fdjtDOM.nextElt=next_element;
        fdjtDOM.forwardElt=forward_element;
        fdjtDOM.forward=scan_forward;
        fdjtDOM.next=scan_next;

        /* Scanning backwards */

        // PREV goes the parent if there's no previous sibling
        function prev_node(node){
            while (node) {
                if (node.previousSibling)
                    return node.previousSibling;
                else node=node.parentNode;}
            return false;}
        function previous_element(node){
            if (havechildren)
                return node.previousElementSibling;
            else {
                var scan=node;
                while (scan=scan.previousSibling) 
                    if (!(scan)) return null;
                else if (scan.nodeType===1) break;
                else {}
                if (scan) return scan;
                else return scan.parentNode;}}
        function scan_previous(node,test,justelts){
            if (!(test))
                if (justelts) {
                    if (havechildren) return node.previousElementSibling;
                    else return previous_element(node);}
            else return previous_node(node);
            var scan=((justelts)?
                      ((havechildren)?(node.previousElementSibling):
                       (previous_element(node))):
                      (previous_node(node)));
            while (scan)
                if (test(scan)) return scan;
            else if (justelts)
                scan=((havechildren)?(scan.previousElementSibling):(previous_element(scan)));
            else scan=prev_node(scan);
            return false;}

        // BACKWARD goes to the final (deepest last) child
        //  of the previous sibling
        function backward_node(node){
            if (node.previousSibling) {
                var scan=node.previousSibling;
                // If it's not an element, just return it
                if (scan.nodeType!==1) return scan;
                // Otherwise, return the last and deepest child
                while (scan) {
                    var children=scan.childNodes;
                    if (!(children)) return scan;
                    else if (children.length===0) return scan;
                    else scan=children[children.length-1];}
                return scan;}
            else return node.parentNode;}

        function backward_element(node){
            if (havechildren)
                return ((node.previousElementSibling)?
                        (get_final_child((node.previousElementSibling))):
                        (node.parentNode));
            else if ((node.previousElementSibling)||(node.previousSibling)) {
                var start=(node.previousElementSibling)||(node.previousSibling);
                if (start.nodeType===1) 
                    return get_final_child(start);
                else return start;}
            else return node.parentNode;}
        // We use a helper function because 
        function get_final_child(node){
            if (node.nodeType===1) {
                if (node.childNodes) {
                    var children=node.childNodes;
                    if (!(children.length)) return node;
                    var scan=children.length-1;
                    while (scan>=0) {
                        var child=get_final_child(children[scan--]);
                        if (child) return child;}
                    return node;}
                else return node;}
            else return false;}
        
        function scan_backward(node,test,justelts){
            if (!(test)) {
                if (justelts) return backward_element(node);
                else return backward_node(node);}
            var scan=((justelts)?
                      (backward_element(node)):
                      (backward_node(node)));
            while (scan) {
                if (test(scan)) return scan;
                else if (justelts) scan=next_element(scan);
                else scan=next_node(scan);}
            return false;}
        
        fdjtDOM.prevElt=previous_element;
        fdjtDOM.backwardElt=backward_element;
        fdjtDOM.backward=scan_backward;
        fdjtDOM.prev=scan_previous;

        /* Viewport/window functions */

        fdjtDOM.viewTop=function viewTop(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if ((!(win))||(win===window)||
                ((Window)&&(win instanceof Window))) {
                win=win||window;
                return (win.pageYOffset||win.scrollY||
                        win.document.documentElement.scrollTop||0);}
            else return win.scrollTop;};
        
        fdjtDOM.viewLeft=function viewLeft(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if ((!(win))||(win===window)||
                ((Window)&&(win instanceof Window))) {
                win=win||window;
                return (win.pageXOffset||win.scrollX||
                        win.document.documentElement.scrollLeft||0);}
            else return win.scrollLeft;};

        fdjtDOM.viewHeight=function viewHeight(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if ((!(win))||(win===window)||
                ((Window)&&(win instanceof Window))) {
                win=win||window;
                var docelt=((win.document)&&(win.document.documentElement));
                return (win.innerHeight)||((docelt)&&(docelt.clientHeight));}
            else return win.offsetHeight;};
        fdjtDOM.viewWidth=function viewWidth(win){
            if (typeof win==="string") {
                if (!(win=document.getElementById(win))) return;}
            if ((!(win))||(win===window)||
                ((Window)&&(win instanceof Window))) {
                win=win||window;
                var docelt=((win.document)&&(win.document.documentElement));
                return ((win.innerWidth)||((docelt)&&(docelt.clientWidth)));}
            else return win.offsetWidth;};

        /* Generating element IDs */

        var id_count=0; var unique=Math.floor(Math.random()*100000);
        function getNodeID(elt){
            var id=elt.id; var nelt;
            if (id) return id;
            else {
                id="TMPID_"+unique+"_"+(id_count++);
                while ((!(nelt=document.getElementById(id)))||
                       (nelt===elt)) {
                    id="TMPID_"+unique+"_"+(id_count++);
                    if ((!(nelt=document.getElementById(id)))||
                        (nelt===elt))
                        unique=Math.floor(Math.random()*100000);
                    id="TMPID_"+unique+"_"+(id_count++);}
                elt.id=id;
                return id;}}
        fdjtDOM.getNodeID=getNodeID;
                
        /* Stylesheet manipulation */

        // Adapted from 
        // http://www.hunlock.com/blogs/Totally_Pwn_CSS_with_Javascript

        // Return requested style object
        function getCSSRule(ruleName, deleteFlag) {
            ruleName=ruleName.toLowerCase();
            // If browser can play with stylesheets
            if (document.styleSheets) {
                // For each stylesheet
                for (var i=0; i<document.styleSheets.length; i++) {
                    var styleSheet=document.styleSheets[i];
                    var cssRule=false;
                    var cssRules=styleSheet.cssRules||styleSheet.rules;
                    var n_rules=((cssRules)&&(cssRules.length));
                    var ii=0; while (ii<n_rules) {
                        if (cssRules[ii])  {
                            var cssRule=cssRules[ii];
                            if (cssRule.selectorText.toLowerCase()==ruleName) {
                                if (deleteFlag=='delete') {
                                    if (styleSheet.cssRules) {
                                        styleSheet.deleteRule(ii);}
                                    // Delete rule IE style.
                                    return true;}
                                // found and not deleting.
                                else {return cssRule;}
                                // end found cssRule
                            }}   
                        ii++;}
                    /* end for stylesheets */ }
                return false;}
            return false;}
        fdjtDOM.getCSSRule=getCSSRule;

        function dropCSSRule(ruleName) {// Delete a CSS rule   
            return getCSSRule(ruleName,'delete');}
        fdjtDOM.dropCSSRule=dropCSSRule;

        function addCSSRule(selector,text,sheet) {// Create a new css rule
            if (!(sheet)) {
                var styles=fdjtID("FDJTSTYLES");
                if (!(styles)) {
                    var head=document.getElementsByTagName("HEAD");
                    if (head.length===0) return; else head=head[0];
                    styles=fdjtDOM("style#FDJTSTYLES");
                    head.appendChild(styles);}
                sheet=styles.sheet;}
            if (sheet.insertRule) {
                var rules=sheet.cssRules||sheet.rules;
                var i=0; var lim=rules.length;
                while (i<lim) {
                    var rule=rules[i];
                    if (rule.selectorText===selector) break;
                    else i++;}
                if (i<lim) {
                    if (sheet.deleteRule) sheet.deleteRule(i);
                    else if (sheet.removeRule) sheet.removeRule(i);
                    else {}}
                var rules=sheet.cssRules||sheet.rules;
                var ruletext=selector+' {'+text+'}';
                if (sheet.insertRule)
                    sheet.insertRule(ruletext, rules.length);
                else if (sheet.addRule)
                    sheet.addRule(selector,text);
                else return false;
                return ruletext;}
            else return false;}
        fdjtDOM.addCSSRule=addCSSRule;

        /* Listeners (should be in UI?) */

        function addListener(node,evtype,handler){
            if (!(node)) node=document;
            if (typeof node === 'string') {
                var elt=fdjtID(node);
                if (!(node)) {
                    fdjtLog("Can't find #%s",node)
                    return;}
                node=elt;}
            else if (node instanceof Array) {
                var i=0; var lim=node.length;
                while (i<lim) addListener(node[i++],evtype,handler);
                return;}
            // OK, actually do it
            if (evtype==='title') { 
                // Not really a listener, but helpful
                if (typeof handler === 'string') 
                    if (node.title)
                        node.title='('+handler+') '+node.title;
                else node.title=handler;}
            else if (evtype[0]==='=')
                node[evtype.slice(1)]=handler;
            else if (node.addEventListener)  {
                // fdjtLog("Adding listener %o for %o to %o",handler,evtype,node);
                return node.addEventListener(evtype,handler,false);}
            else if (node.attachEvent)
                return node.attachEvent('on'+evtype,handler);
            else fdjtLog.warn('This node never listens: %o',node);}
        fdjtDOM.addListener=addListener;

        function addListeners(node,handlers){
            if (handlers) 
                for (var evtype in handlers) {
                    if (handlers[evtype])
                        addListener(node,evtype,handlers[evtype]);}}
        fdjtDOM.addListeners=addListeners;

        fdjtDOM.T=function(evt) {
            evt=evt||event; return (evt.target)||(evt.srcElement);};

        fdjtDOM.cancel=function(evt){
            evt=evt||event;
            if (evt.preventDefault) evt.preventDefault();
            else evt.returnValue=false;
            evt.cancelBubble=true;};

        /* Check for SVG */
        var nosvg=true;

        function checkSVG(){
            if (nosvg) addClass(document.body,"NOSVG");
            else if (!(document.implementation.hasFeature(
                "http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")||
                  navigator.mimeTypes["image/svg+xml"]))
                addClass(document.body,"NOSVG");
            else dropClass(document.body,"NOSVG");}
        
        function checkChildren(){
            havechildren=((document)&&
                          (document.body)&&
                          (document.body.childNodes)&&
                          (document.body.children));}

        function useBMP(){
            var hasSuffix=fdjtString.hasSuffix;
            var images=fdjt.$("IMG");
            var i=0, lim=images.length;
            while (i<lim) {
                var image=images[i++]; var src=image.src;
                if (!(src)) continue;
                if ((hasSuffix(src,".svg"))||(hasSuffix(src,".svgz"))) {
                    var bmp=image.getAttribute('bmp');
                    if (bmp) {
                        image.setAttribute('svg',image.src);
                        image.src=bmp;}}}}
        function useSVG(){
            var hasSuffix=fdjtString.hasSuffix;
            var images=fdjt.$("IMG");
            var i=0, lim=images.length;
            while (i<lim) {
                var image=images[i++]; var src=image.src;
                if (!(src)) continue;
                if ((!((hasSuffix(src,".svg"))||(hasSuffix(src,".svgz"))))&&
                    (image.getAttribute('svg'))) {
                    var svg=image.getAttribute('svg');
                    image.setAttribute('bmp',image.src);
                    image.src=svg;}}}
        fdjtDOM.useSVG=useSVG;
        fdjtDOM.useBMP=useBMP;

        function goSVG(){
            if ((nosvg)||
                (!(document.implementation.hasFeature(
                    "http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")||
                   navigator.mimeTypes["image/svg+xml"]))) {
                useBMP();}}

        var inits_run=false;
        var inits=[checkChildren,checkSVG]; // ,fixSVG
        var init_names={
            checkChildren: checkChildren,checkSVG: checkSVG};

        fdjtDOM.init=fdjt.Init;
        fdjtDOM.addInit=fdjt.addInit;
        fdjt.addInit(checkChildren,"checkChildren");
        fdjt.addInit(checkSVG,"checkSVG");

        if (navigator.userAgent.search("WebKit")>=0) {
            if (!(fdjtDOM.transition)) fdjtDOM.transition='-webkit-transition';
            if (!(fdjtDOM.transitionProperty))
                fdjtDOM.transitionProperty='-webkit-transition-property';
            if (!(fdjtDOM.transitionDuration))
                fdjtDOM.transitionDuration='-webkit-transition-duration';
            if (!(fdjtDOM.transitionDelay))
                fdjtDOM.transitionDelay='-webkit-transition-delay';
            if (!(fdjtDOM.transitionTiming))
                fdjtDOM.transitionTiming='-webkit-transition-timing-function';
            if (!(fdjtDOM.transform)) fdjtDOM.transform='-webkit-transform';
            if (!(fdjtDOM.transformOrigin))
                fdjtDOM.transformOrigin='-webkit-transform-origin';
            if (!(fdjtDOM.columnWidth)) fdjtDOM.columnWidth='-webkit-column-width';
            if (!(fdjtDOM.columnGap)) fdjtDOM.columnGap='-webkit-column-gap';}
        else if (navigator.userAgent.search("Mozilla")>=0) {
            if (!(fdjtDOM.transition)) fdjtDOM.transition='-moz-transition';
            if (!(fdjtDOM.transitionProperty))
                fdjtDOM.transitionProperty='-moz-transition-property';
            if (!(fdjtDOM.transitionDuration))
                fdjtDOM.transitionDuration='-moz-transition-duration';
            if (!(fdjtDOM.transitionDelay))
                fdjtDOM.transitionDelay='-moz-transition-delay';
            if (!(fdjtDOM.transitionTiming))
                fdjtDOM.transitionTiming='-moz-transition-timing-function';
            if (!(fdjtDOM.transform)) fdjtDOM.transform='-moz-transform';
            if (!(fdjtDOM.transformOrigin))
                fdjtDOM.transformOrigin='-moz-transform-origin';
            if (!(fdjtDOM.columnWidth)) fdjtDOM.columnWidth='MozColumnWidth';
            if (!(fdjtDOM.columnGap)) fdjtDOM.columnGap='MozColumnGap';}
        else {
            if (!(fdjtDOM.transition)) fdjtDOM.transition='transition';
            if (!(fdjtDOM.transitionProperty))
                fdjtDOM.transitionProperty='transition-property';
            if (!(fdjtDOM.transitionDuration))
                fdjtDOM.transitionDuration='transition-duration';
            if (!(fdjtDOM.transitionDelay))
                fdjtDOM.transitionDelay='transition-delay';
            if (!(fdjtDOM.transitionTiming))
                fdjtDOM.transitionTiming='transition-timing-function';
            if (!(fdjtDOM.transform)) fdjtDOM.transform='transform';
            if (!(fdjtDOM.transformOrigin))
                fdjtDOM.transformOrigin='-moz-transform-origin';}
        
        /* Selection-y functions */

        fdjtDOM.getSelectedRange=function(){
            var sel;
            if (window.getSelection)
                sel=window.getSelection();
            else if (document.selection)
                sel=document.selection.createRange();
            else return false;
            if (!(sel)) return false;
            if (sel.getRangeAt)
                return sel.getRangeAt(0);
            else if (document.createRange) {
                var range=document.createRange();
                range.setStart(
                    selectionObject.anchorNode,selectionObject.anchorOffset);
                range.setEnd(
                    selectionObject.focusNode,selectionObject.focusOffset);
                return range;}
            else return false;}

        function node2text(node,accum){
            if (!(accum)) accum="";
            if ((!(node.nodeType))&&(node.length)) {
                var i=0, lim=node.length;
                while (i<lim) accum=node2text(node[i++],accum);
                return accum;}
            else if (node.nodeType===3) {
                var stringval=node.nodeValue;
                if (stringval) accum=accum+stringval;
                return accum;}
            else if (node.nodeType===1) {
                var children=node.childNodes;
                var i=0, lim=children.length;
                while (i<lim) {
                    accum=node2text(children[i++],accum);}
                return accum;}
            else return accum;}
        fdjtDOM.node2text=node2text;
        
        function get_text_pos(node,pos,cur,starting){
            if (cur>pos) return false;
            else if ((!(node.nodeType))&&(node.length)) {
                var i=0, lim=node.length;
                while (i<lim) {
                    cur=get_text_pos(node[i++],pos,cur,starting);
                    if (!(typeof cur === "number")) return cur;}
                return cur;}
            else if (node.nodeType===3) {
                var stringval=node.nodeValue;
                if (pos<(cur+stringval.length))
                    return { node: node, off: pos-cur};
                else if (pos===(cur+stringval.length))
                    return { node: node, off: pos-cur,atend: true};
                else return cur+stringval.length;}
            else if (node.nodeType===1) {
                var children=node.childNodes;
                var i=0, lim=children.length;
                while (i<lim) {
                    cur=get_text_pos(children[i++],pos,cur,starting);
                    if (!(typeof cur === 'number')) {
                        if ((starting)&&(cur.atend)) {
                            cur=pos; while (i<lim) {
                                var next=get_text_pos(
                                    children[i++],cur,pos,starting);
                                if ((next)&&(typeof next!=="number"))
                                    return next;}
                            return cur;}
                        else return cur;}}
                return cur;}
            else return cur;}

        function textPos(node,pos,sofar){
            var result=get_text_pos(node,pos,sofar||0);
            if (typeof result !== 'number') return result;
            else return {node: node,off: pos};}
        fdjtDOM.textPos=textPos;

        fdjtDOM.refineRange=function(range){
            if ((range.startContainer.nodeType===3)&&
                (range.endContainer.nodeType===3))
                return range;
            var start_info=textPos(range.startContainer,range.startOffset);
            var end_info=textPos(range.endContainer,range.endOffset);
            var newrange=document.createRange();
            newrange.setStart(start_info.node,start_info.off);
            newrange.setEnd(end_info.node,end_info.off);
            return newrange;}
        
        function get_text_off(scan,upto,sofar){
            if (!(sofar)) sofar=0;
            if (scan===upto) return [sofar];
            else if (scan.nodeType===3)
                return sofar+scan.nodeValue.length;
            else if (scan.nodeType===1) {
                var children=scan.childNodes;
                var i=0, lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    sofar=get_text_off(child,upto,sofar);
                    if (typeof sofar !== 'number') return sofar;}
                return sofar;}
            else return sofar;}
        function textOff(node,pos){
            var off=get_text_off(node,pos,0);
            if (off) return off[0]; else return false;}
        fdjtDOM.textOff=textOff;
        
        function getIDParent(scan) {
            while (scan) {
                if (scan.id) break;
                else scan=scan.parentNode;}
            return scan;}

        fdjtDOM.getRangeInfo=function(range,within){
            var start=range.startContainer;
            if (!(within)) within=getIDParent(start);
            var start_edge=textOff(within,start,0);
            var end=range.endContainer;
            var ends_in=((start===end)?(within):
                         (getParent(end,within))?(within):
                         (getIDParent(end)));
            var end_edge=((start===end)?(start_edge):
                          textOff(ends_in,end,0));
            return {start: start_edge+range.startOffset,
                    starts_in: within.id,ends_in: ends_in.id,
                    end: end_edge+range.endOffset};}

        function findString(node,needle,off,count){
            if (typeof off === 'undefined') off=0;
            if (typeof count === 'undefined') count=1;
            var match=false;
            var fulltext=node2text(node);
            var scan=((off===0)?(fulltext):(fulltext.slice(off)));
            var pat=((typeof needle === 'string')?
                     (new RegExp(needle.replace(/\s+/g,"(\\s+)"),"gm")):
                     (needle));
            while ((match=pat.exec(scan))) {
                if (count===1) {
                    var loc=match.index;
                    var absloc=loc+off;
                    var start=get_text_pos(node,absloc,0,true);
                    var end=get_text_pos(node,absloc+(match[0].length),0);
                    if ((!start)||(!end)) return false;
                    var range=document.createRange();
                    range.setStart(start.node,start.off);
                    range.setEnd(end.node,end.off);
                    return range;}
                else {count--;
                      off=match.index+match[0].length;
                      scan=scan.slice(off);}}
            return false;}
        fdjtDOM.findString=findString;

        function findMatches(node,needle,off,count){
            if (typeof off === 'undefined') off=0;
            if (typeof count === 'undefined') count=-1;
            var match=false; var results=[];
            var fulltext=node2text(node);
            var scan=((off===0)?(fulltext):(fulltext.slice(off)));
            var pat=((typeof needle === 'string')?
                     (new RegExp(needle.replace(/\s+/g,"(\\s+)"),"gm")):
                     (needle));
            while ((count!==0)&&(match=pat.exec(scan))) {
                var loc=match.index;
                var absloc=loc+off;
                var start=get_text_pos(node,absloc,0);
                var end=get_text_pos(node,absloc+match[0].length,0);
                if ((!start)||(!end)) return false;
                var range=document.createRange();
                range.setStart(start.node,start.off);
                range.setEnd(end.node,end.off);
                results.push(range);
                count--;
                off=match.index+match[0].length;
                scan=scan.slice(off);}
            return results;}
        fdjtDOM.findMatches=findMatches;

        /* Paragraph hashes */

        fdjtDOM.getParaHash=function(node){
            return paraHash(textify(node,true,false,false));}

        /* Getting transition event names */

        var transition_events=[
            'transitionend','webkitTransitionEnd',
            'mozTransitionEnd','oTransitionEnd',
            'msTransitionEnd'];

        function checkTransitionEvents(){
            var div = document.createElement('div');
            var handler = function(e) {
                fdjtDOM.transitionEnd = e.type;
                var i=0, lim=transition_events.length;
                this.removeEventListener(
                    transition_events[i++],arguments.callee);};
            div.setAttribute("style","position:absolute;top:0px;transition:top 1ms ease;-webkit-transition:top 1ms ease;-moz-transition:top 1ms ease;-o-transition:top 1ms ease;-ms-transition:top 1ms ease;");
            var i=0, lim=transition_events.length;
            while (i<lim) div.addEventListener(
                transition_events[i++], handler, false);
            document.documentElement.appendChild(div);
            setTimeout(function() {
                div.style.top = '100px';
                setTimeout(function() {
                    div.parentNode.removeChild(div);
                    div = handler = null;},
                           100);},
                       0);}
        fdjt.addInit(checkTransitionEvents,"checkTransitionEvents");

        /* Custom input types (number, date, email, url, etc) */

        var custom_input_types=
            ["email","number","range","tel","url",
             "datetime","datetime-local","date","time","week","month"];

        function setupCustomInputs(dom){
            if (!(dom)) dom=document.body;
            var input_elt=document.createElement("input");
            var i=0, ntypes=custom_input_types.length;
            while (i<ntypes) {
                var typename=custom_input_types[i++];
                try {input_elt.type=typename;} catch (err) {}
                if (input_elt.type===typename) {
                    var inputs=getChildren(
                        document.body,".fdjt"+typename+"input");
                    var j=0, lim=inputs.length;
                    while (j<lim) {
                        var input=inputs[j++];
                        if (input.tagName!=="INPUT") continue;
                        input.type=typename;}}}}
        fdjtDOM.setupCustomInputs=setupCustomInputs;
        fdjt.addInit(setupCustomInputs,"CustomInputs");
        fdjtDOM.text_types=
            /\b(text|email|number|range|tel|url|datetime|datetime-local|date|time|week|month)\b/i;

        /* Meta schemas */

        fdjt.addInit(getMetaSchemas,"MetaSchemas");

        /* Run inits on load */
        if ((!(fdjt.noinit))||
	    ((typeof _fdjt_init === 'undefined')||(!(_fdjt_init))))
            fdjtDOM.addListener(window,"load",fdjtDOM.init);
        
        return fdjtDOM;
    })();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/kb.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

/*
  _fdjtid: unique integer assigned to objects
  fdjtKB.register (assigns unique ID)
  fdjtKB.Pool (creates a pool of named objects)
  fdjtKB.Set (creates a sorted array for set operations)
  fdjtKB.Ref (objects created within a pool)
*/

if (window) {if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

if (!(fdjt.KB)) {
    fdjt.KB=(function(){
        var fdjtString=fdjt.String;
        var fdjtState=fdjt.State;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var JSON=(window.JSON)||(fdjt.JSON);

        // This is the top level object/module 
        var fdjtKB={};

        // These are typically set by subversion, but now we have
        //   git and haven't come up with a good replacement.
        // fdjtKB.revid="$Id$";
        // fdjtKB.version=parseInt("$Revision$".slice(10,-1));

        // Whether we can support local storage
        //  We'll shift this to indexedDB or a shim when we get a chance
        fdjtKB.persist=((window.localStorage)?(true):(false));

        // This turns on debugging, which may be further controlled
        //  by properties on pools
        var debug=0;
        fdjtKB.setDebug=function(flag){
            if (!(flag)) debug=0;
            else if (typeof flag === 'number')
                debug=flag;
            else debug=1;};

        // Various imports
        var warn=fdjt.Log.warn;
        var log=fdjt.Log;

        // Patterns for absolute references
        var uuidpat=
            /(U|#U|:#U|)[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}/;
        var oidpat=/(@|:@)([0-9A-Fa-f]+|\/[A-Za-z][A-Za-z0-9-_\.]+[A-Za-z])\/([0-9A-Fa-f]+)/;
        fdjtKB.oidpat=oidpat;
        fdjtKB.uuidpat=uuidpat;

        // This checks if a reference is a 'real object'
        // I.E., something which shouldn't be used as a key
        //  or fast set member and not an array either
        var arrayobjs=(typeof new Array(1,2,3) === 'object');
        var stringobjs=(typeof new String() === 'object');
        function isobject(x){
            return ((typeof x === 'object')&&
                    (!((arrayobjs)&&(x instanceof Array))));}
        function objectkey(x){
            if (typeof x !== 'object') return x;
            else if (x instanceof String) return x.toString();
            else return x._qid||x._id||x._fdjtid||register(x);}
        fdjtKB.objectkey=objectkey;
        fdjtKB.isobject=isobject;
        

        // We allocate 16 million IDs for miscellaneous objects
        //  and use counter to track them.
        var counter=0;
        function register(x){
            return (x._id)||(x._fdjtid)||(x._fdjtid=(++counter));}
        fdjtKB.register=register;
        
        // This lets us figure out what inits were run in this session.
        var init_start=fdjtTime();
        
        // Pools are uniquely named id->object mappings
        // This table maps those unique names to the objects themselves
        // Pools can have aliases, so the name->pool mapping is many to one
        var pools={};
        
        function Pool(name) {
            if (!(name)) return this;
            if (pools[name]) return pools[name];
            pools[name]=this; this.name=name; this.map={};
            this.index=false; this.storage=false;
            this.inits=false; this.effects=false; this.xforms={};
            // Whether _id fields in this pool are 'absolute' (globally unique)
            this.absref=false; 
            return this;}
        fdjtKB.Pool=Pool;
        fdjtKB.PoolRef=function(name,create){
            if (!(name)) return this;
            if (pools[name]) return pools[name];
            else if (!(create)) return false;
            else return new Pool(name);};
        
        Pool.prototype.reset=function(){
            this.map={}; this.index=Index(); this.xforms={};
            this.storage=false;};
        Pool.prototype.toJSON=function(){return "@@"+this.name;};
        
        // Check if a named pool exists
        Pool.probe=function(id) {return pools[id]||false;};

        Pool.prototype.addAlias=function(name) {
            if (pools[name])
                if (pools[name]===this) return this;
            else throw {error: "pool alias conflict"};
            else pools[name]=this;};

        Pool.prototype.addEffect=function(prop,handler) {
            var effects;
            if (!(effects=this.effects)) effects=this.effects={};
            effects[prop]=handler;};
        Pool.prototype.addInit=function(handler) {
            var inits;
            if (!(inits=this.inits)) inits=this.inits=[];
            inits.push(handler);};

        Pool.prototype.probe=function(id) {
            if (this.map[id]) return (this.map[id]);
            else return false;};

        Pool.prototype.load=function(ref) {
            if (typeof ref==='string') {
                var obj=this.map[ref];
                if (obj) {
                    if (obj._init) return obj;
                    else return obj.load();}
                else if (this.storage) {
                    var data=this.storage.probe(ref);
                    if (data) return this.ref(ref).init(data);
                    else return undefined;}
                else return undefined;}
            else return ref.load();};

        Pool.prototype.ref=function(id,cons) {
            if (id instanceof Ref) return id;
            if (this.map[id]) return this.map[id];
            if (!(cons)) cons=this.cons(id);
            else if (cons instanceof Ref) {}
            else if (cons.call) cons=new cons(id);
            else cons=this.cons(id);
            if (!(cons._id)) cons._id=id;
            this.map[id]=cons; cons.pool=this;
            if (!(cons._qid)) {
                if (id.search(oidpat)===0) cons._qid=id;
                else if (id.search(uuidpat)===0) cons._qid=id;
                else {}}
            return cons;};
        Pool.prototype.drop=function(qid) {
            var val=this.map[qid];
            if (!(val)) return;
            if ((val)&&(val.ondrop)) val.ondrop();
            if (this.storage) this.storage.drop(val||qid);
            delete this.map[qid];
            if (val._id) delete this.map[val._id];
            if (val._qid) delete this.map[val._qid];
            if (val.uuid) delete this.map[val.uuid];
            if (val.oid) delete this.map[val.oid];}
        
        Pool.prototype.Import=function(data) {
            if (data instanceof Array) {
                var i=0; var lim=data.length;
                while (i<lim) this.Import(data[i++]);
                return;}
            else if (typeof data === 'string') {
                var ref=this.ref(data);
                if ((!(ref._init))&&(ref.pool.storage))
                    ref.pool.storage.load(ref);
                return ref;}
            else {
                var qid=data._qid||data._id||data.oid||data.uuid;
                if (!(qid)) return data;
                var ref=((qid)&&(this.map[qid]));
                var cur=((this.storage)&&(this.storage.probe(qid)));
                if ((cur)&&(cur._modified)&&(data._modified)&&
                    (cur._modified>data._modified)) {
                    if (debug)
                        log("[%fs] Skipping out-of-date import to %s %o <== %o",
                            fdjtET(),qid,cur,data);
                    if ((ref)&&(ref._init)) return ref;
                    else if (ref) return ref.init(cur);
                    else return this.ref(qid).init(cur);}
                if ((ref)&&(ref._init)) ref.update(data);
                else if (ref) ref.init(data);
                else {
                    ref=this.ref(qid);
                    ref.init(data);}
                if (((debug)&&(this.traceimport))||(debug>1))
                    log("[%fs] Import to %s %o <== %o",
                        fdjtET(),qid,obj,data);
                if (this.storage) this.storage.Import(data);
                return ref;}};
        
        Pool.prototype.find=function(prop,val){
            if (!(this.index)) return [];
            return this.index(false,prop,val);};

        var uuid_pattern=
            /[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}/;
        var refmaps=[];
        fdjtKB.addRefMap=function(map){
            var i=0; var lim=refmaps.length;
            while (i<lim) if (refmaps[i++]===map) return false;
            refmaps.push(map);
            return refmaps.length;};

        function getPool(arg){
            if (arg instanceof Ref) return arg.pool;
            else if (typeof arg === 'number') return false;
            else if (typeof arg === 'string') {
                var ref=parseRef(arg);
                if (ref) return ref.pool;
                else return false;}
            else return false;}
        fdjtKB.getPool=getPool;

        // Ref Syntaxes:
        //   :@/pool/off
        //   :@base/off
        //   @/pool/off
        //   @base/off
        //   d16e2980-8e18-11e1-a50a-001a922d60ef
        //   #Ud16e2980-8e18-11e1-a50a-001a922d60ef
        //   :#Ud16e2980-8e18-11e1-a50a-001a922d60ef
        function parseRef(arg,pool,probe){
            var term=arg; var slash=false, atpos=false;
            if ((pool)&&(typeof pool === 'string'))
                pool=fdjtKB.PoolRef(pool);
            if ((pool)&&(pool.parseRef))
                return pool.parseRef(term,probe);
            // These are all qualified references of various sorts
            else if ((pool)&&(arg[0]==="@")&&(arg[1]==="@")) 
                term=term.slice(2);
            else if ((pool)&&(arg[0]===":")&&(arg[1]==="@")&&(arg[2]==="@"))
                term=term.slice(3);
            else if (((arg[0]===':')&&(arg[1]==='@'))&&
                     (((slash=arg.indexOf('/',3))>=0)))  {
                pool=fdjtKB.PoolRef(arg.slice(1,slash+1));
                term=term.slice(1);}
            else if (((arg[0]==='@'))&&
                     (((slash=arg.indexOf('/',2))>=0)))  {
                pool=fdjtKB.PoolRef(arg.slice(0,slash+1));}
            else if ((atpos=arg.indexOf('@'))>1)  {
                pool=fdjtKB.PoolRef(arg.slice(atpos+1));
                term=arg.slice(0,atpos);}
            else if (arg.search(uuid_pattern)===0) {
                var uuid_type=arg.slice(34);
                pool=fdjtKB.PoolRef("-UUIDTYPE="+uuid_type)||pool;}
            else if ((arg[0]==='#')&&(arg[1]==='U')&&
                     (arg.search(uuid_pattern)===2)) {
                var uuid_type=arg.slice(36);
                pool=fdjtKB.PoolRef("-UUIDTYPE="+uuid_type)||pool;
                term=arg.slice(3);}
            else if ((arg[0]===':')&&(arg[1]==='#')&&(arg[2]==='U')&&
                     (arg.search(uuid_pattern)===3)) {
                var uuid_type=arg.slice(37);
                pool=fdjtKB.PoolRef("-UUIDTYPE="+uuid_type)||pool;
                term=arg.slice(3);}
            else if (refmaps.length) {
                var i=0; var lim=refmaps.length;
                while (i<lim) {
                    var refmap=refmaps[i++];
                    var ref=((typeof refmap === 'function')?
                             (refmap(arg)):(refmap[arg]));
                    if (ref) return ref;}
                return false;}
            if ((pool)&&(term)) {
                if (probe) return pool.probe(term);
                else return pool.ref(term);}
            else return false;}
        
        function getRef(arg,pool){
            if (!(arg)) return false;
            else if (arg instanceof Ref) return arg;
            else if (typeof arg === 'number') return false;
            else if (typeof arg === 'string')
                return parseRef(arg,pool);
            else return false;}
        fdjtKB.ref=fdjtKB.getRef=getRef;
        function probeRef(arg,pool){
            if (!(arg)) return false;
            else if (arg instanceof Ref) return arg;
            else if (typeof arg === 'number') return false;
            else if (typeof arg === 'string')
                return parseRef(arg,pool,true);
            else return false;}
        fdjtKB.probe=fdjtKB.probeRef=probeRef;
        function loadRef(arg,pool){
            var obj=getRef(arg,pool);
            if (!(obj)) return undefined;
            else if (obj._init) return obj;
            else return obj.load();}
        fdjtKB.load=fdjtKB.loadRef=loadRef;
        
        function doimport(data){
            if (data instanceof Array) {
                var i=0; var lim=data.length; var results=[];
                while (i<lim) results.push(doimport(data[i++]));
                return results;}
            else {
                var qid=data._id||data.uuid||data.oid;
                if (qid) {
                    var pool=getPool(qid);
                    if (pool) return pool.Import(data);
                    else return data;}
                else return data;}}
        fdjtKB.Import=doimport;

        // Array utility functions
        function arr_contains(arr,val,start){
            return (arr.indexOf(val,start||0)>=0);}
        function arr_position(arr,val,start){
            return arr.indexOf(val,start||0);}

        /* Fast sets */
        function set_sortfn(a,b) {
            if (a===b) return 0;
            else if (typeof a === typeof b) {
                if (typeof a === "number")
                    return a-b;
                else if (typeof a === "string")
                    if (a<b) return -1;
                else return 1;
                else if (a._id)
                    if (b._id)
                        if (a._id<b._id) return -1;
                else if (a._id===b._id) return 0;
                else return 1;
                else return 1;
                else if (b._id) return -1;
                else if (a._fdjtid)
                    if (b._fdjtid) return a._fdjtid-b._fdjtid;
                else {
                    b._fdjtid=++counter;
                    return -1;}
                else if (b._fdjtid) {
                    a._fdjtid=++counter;
                    return 1;}
                else {
                    a._fdjtid=++counter;
                    b._fdjtid=++counter;
                    return -1;}}
            else if (typeof a < typeof b) return -1;
            else return 1;
        }

        function length_sortfn(a,b) {
            if (a.length===b.length) return 0;
            else if (a.length<b.length) return -1;
            else return 1;}

        function intersection(set1,set2){
            if (typeof set1 === 'string') set1=[set1];
            if (typeof set2 === 'string') set2=[set2];
            if ((!(set1))||(set1.length===0)) return [];
            if ((!(set2))||(set2.length===0)) return [];
            if (set1._sortlen!==set1.length) set1=Set(set1);
            if (set2._sortlen!==set2.length) set2=Set(set2);
            var results=new Array();
            var i=0; var j=0; var len1=set1.length; var len2=set2.length;
            var allstrings=set1._allstrings&&set2._allstrings;
            var new_allstrings=true;
            while ((i<len1) && (j<len2))
                if (set1[i]===set2[j]) {
                    if ((new_allstrings)&&(typeof set1[i] !== 'string'))
                        new_allstrings=false;
                    results.push(set1[i]);
                    i++; j++;}
            else if ((allstrings)?
                     (set1[i]<set2[j]):
                     (set_sortfn(set1[i],set2[j])<0)) i++;
            else j++;
            results._allstrings=new_allstrings;
            results._sortlen=results.length;
            return results;}
        fdjtKB.intersection=intersection;

        function difference(set1,set2){
            if (typeof set1 === 'string') set1=[set1];
            if (typeof set2 === 'string') set2=[set2];
            if ((!(set1))||(set1.length===0)) return [];
            if ((!(set2))||(set2.length===0)) return set1;
            if (set1._sortlen!==set1.length) set1=Set(set1);
            if (set2._sortlen!==set2.length) set2=Set(set2);
            var results=new Array();
            var i=0; var j=0; var len1=set1.length; var len2=set2.length;
            var allstrings=set1._allstrings&&set2._allstrings;
            var new_allstrings=true;
            while ((i<len1) && (j<len2)) {
                if (set1[i]===set2[j]) {
                    i++; j++;}
                else if ((allstrings)?
                         (set1[i]<set2[j]):
                         (set_sortfn(set1[i],set2[j])<0)) {
                    if ((new_allstrings)&&(typeof set1[i] !== 'string'))
                        new_allstrings=false;
                    results.push(set1[i]);
                    i++;}
                else j++;}
            results._allstrings=new_allstrings;
            results._sortlen=results.length;
            return results;}
        fdjtKB.difference=difference;
        
        function union(set1,set2){
            if (typeof set1 === 'string') set1=[set1];
            if (typeof set2 === 'string') set2=[set2];
            if ((!(set1))||(set1.length===0)) return set2;
            if ((!(set2))||(set2.length===0)) return set1;
            if (set1._sortlen!==set1.length) set1=Set(set1);
            if (set2._sortlen!==set2.length) set2=Set(set2);
            var results=new Array();
            var i=0; var j=0; var len1=set1.length; var len2=set2.length;
            var allstrings=set1._allstrings&&set2._allstrings;
            while ((i<len1) && (j<len2))
                if (set1[i]===set2[j]) {
                    results.push(set1[i]); i++; j++;}
            else if ((allstrings)?
                     (set1[i]<set2[j]):
                     (set_sortfn(set1[i],set2[j])<0))
                results.push(set1[i++]);
            else results.push(set2[j++]);
            while (i<len1) results.push(set1[i++]);
            while (j<len2) results.push(set2[j++]);
            results._allstrings=allstrings;
            results._sortlen=results.length;
            return results;}
        fdjtKB.union=union;

        function merge(set1,set2){
            if (typeof set1 === 'string') set1=[set1];
            if (typeof set2 === 'string') set2=[set2];
            if ((!(set1))||(set1.length===0)) {
                set1.concat(set2);
                set1._sortlen=set2._sortlen;
                set1._allstrings=set2._allstrings;
                return set1;}
            if ((!(set2))||(set2.length===0)) return set1;
            var results=set1;
            set1=[].concat(results);
            var i=0; var j=0; var len1=set1.length; var len2=set2.length;
            var allstrings=set1._allstrings&&set2._allstrings;
            while ((i<len1) && (j<len2))
                if (set1[i]===set2[j]) {
                    results.push(set1[i]); i++; j++;}
            else if ((allstrings)?
                     (set1[i]<set2[j]):
                     (set_sortfn(set1[i],set2[j])<0))
                results.push(set1[i++]);
            else results.push(set2[j++]);
            while (i<len1) results.push(set1[i++]);
            while (j<len2) results.push(set2[j++]);
            results._allstrings=allstrings;
            results._sortlen=results.length;
            return results;}
        fdjtKB.merge=merge;

        function overlaps(set1,set2){
            if (typeof set1 === 'string') set1=[set1];
            if (typeof set2 === 'string') set2=[set2];
            if ((!(set1))||(set1.length===0)) return false;
            if ((!(set2))||(set2.length===0)) return false;
            if (set1._sortlen!==set1.length) set1=Set(set1);
            if (set2._sortlen!==set2.length) set2=Set(set2);
            var i=0; var j=0; var len1=set1.length; var len2=set2.length;
            var allstrings=set1._allstrings&&set2._allstrings;
            var new_allstrings=true;
            while ((i<len1) && (j<len2))
                if (set1[i]===set2[j]) return true;
            else if ((allstrings)?
                     (set1[i]<set2[j]):
                     (set_sortfn(set1[i],set2[j])<0)) i++;
            else j++;
            return false;}
        fdjtKB.overlaps=overlaps;

        /* Sets */
        /* sets are really arrays that are sorted to simplify set operations.
           the ._sortlen property tells how much of the array is sorted */
        function Set(arg){
            if (arguments.length===0) return [];
            else if (arguments.length===1) {
                if (!(arg)) return [];
                else if (arg instanceof Array) {
                    if ((!(arg.length))||(arg._sortlen===arg.length))
                        return arg;
                    else if (arg._sortlen) return setify(arg);
                    else return setify([].concat(arg));}
                else {
                    var result=[arg]; 
                    if (typeof arg === 'string') result._allstrings=true;
                    result._sortlen=1;
                    return result;}}
            else {
                var result=[];
                for (arg in arguments)
                    if (!(arg)) {}
                else if (arg instanceof Array) result.concat(arg);
                else result.push(arg);
                return setify(result);}}
        fdjtKB.Set=Set;

        function setify(array) {
            var len;
            if (array._sortlen===(len=array.length)) return array;
            // else if ((array._sortlen)&&(array._sortlen>1))
            else if (len===0) return array;
            else if (len===1) {
                array._sortlen=1;
                array._allstrings=(typeof array[0] === 'string');
                return array;}
            else {
                var allstrings=true;
                for (elt in array)
                    if (typeof elt !== 'string') {allstrings=false; break;}
                array._allstrings=allstrings;
                if (allstrings) array.sort();
                else array.sort(set_sortfn);
                var read=1; var write=1; var lim=array.length;
                var cur=array[0];
                while (read<lim) {
                    if (array[read]!==cur) {
                        array[write++]=cur=array[read++];}
                    else read++;}
                array._sortlen=array.length=write;
                return array;}}
        
        function set_add(set,val) {
            if (val instanceof Array) {
                var changed=false;
                for (elt in val) 
                    if (set_add(set,elt)) changed=true;
                return changed;}
            else if (set.indexOf) {
                var pos=set.indexOf(val);
                if (pos>=0) return false;
                else set.push(val);
                return true;}
            else {
                var i=0; var lim=set.length;
                while (i<lim)
                    if (set[i]===val) return false; else i++;
                if (typeof val !== 'string') set._allstrings=false;
                set.push(val);
                return true;}}
        
        function set_drop(set,val) {
            if (val instanceof Array) {
                var changed=false;
                for (elt in val)
                    if (set_drop(set,elt)) changed=true;
                return changed;}
            else if (set.indexOf) {
                var pos=set.indexOf(val);
                if (pos<0) return false;
                else set.splice(pos,1);
                return true;}
            else {
                var i=0; var lim=set.length;
                while (i<lim)
                    if (set[i]===val) {
                        array.splice(i,1);
                        return true;}
                else i++;
                return false;}}
        
        /* Maps */
        function Map() {
            this.scalar_map={}; this.object_map={};
            return this;}
        Map.prototype.get=function(key) {
            if (isobject(key))
                return this.object_map
            [key._id||key.oid||key.uuid||key._fdjtid||register(key)];
            else return this.scalar_map[key];};
        Map.prototype.set=function(key,val) {
            if (isobject(key))
                this.object_map
            [key._id||key.oid||key.uuid||key._fdjtid||register(key)]=val;
            else this.scalar_map[key]=val;};
        Map.prototype.add=function(key,val) {
            if (isobject(key)) {
                var objkey=key._id||key.oid||key.uuid||key._fdjtid||
                    register(key);
                var cur=this.object_map[objkey];
                if (!(cur)) {
                    this.object_map[objkey]=[val];
                    return true;}
                else if (!(cur instanceof Array)) {
                    if (cur===val) return false;
                    else {
                        this.object_map[objkey]=[cur,val];
                        return true;}}
                else if (arr_contains(cur,val)) return false;
                else {
                    cur.push(val); return true;}}
            else  {
                var cur=this.scalar_map[key];
                if (!(cur)) {
                    this.scalar_map[key]=[val];
                    return true;}
                else if (!(cur instanceof Array)) {
                    if (cur===val) return false;
                    else {
                        this.scalar_map[key]=[cur,val];
                        return true;}}
                else if (arr_contains(cur,val)) return false;
                else {
                    cur.push(val); return true;}}};
        Map.prototype.drop=function(key,val) {
            if (!(val)) {
                if (isobject(key))
                    delete this.object_map
                [key._id||key.oid||key.uuid||key._fdjtid||register(key)];
                else delete this.scalar_map[key];}
            else if (isobject(key)) {
                var objkey=key._id||key.oid||key.uuid||key._fdjtid||
                    register(key);
                var cur=this.object_map[key];
                if (!(cur)) return false;
                else if (!(cur instanceof Array)) {
                    if (cur===val) {
                        delete this.object_map[objkey];
                        return true;}
                    else return false;}
                else if ((pos=arr_position(val,cur))>=0) {
                    if (cur.length===1) delete this.object_map[objkey];
                    else cur.splice(pos);
                    return true;}
                else return false;}
            else {
                var cur=this.scalar_map[key]; var pos=-1;
                if (!(cur)) return false;
                else if (!(cur instanceof Array)) {
                    if (cur===val) {
                        delete this.scalar_map[key];
                        return true;}
                    else return false;}
                else if ((pos=arr_position(val,cur))>=0) {
                    if (cur.length===1)
                        delete this.scalar_map[key];
                    else cur.splice(pos);
                    return true;}
                else return false;}};
        fdjtKB.Map=Map;

        /* Indices */

        function Index() {
            var scalar_indices={};
            var object_indices={};
            var dontindex=false;
            var index=function(item,prop,val,add){
                var valkey; var indices=scalar_indices;
                if (!(prop))
                    return {
                        scalars: scalar_indices,
                        objects: object_indices};
                else if ((dontindex)?(dontindex[prop]):(prop[0]==='_'))
                    return false;
                else if (!(val))
                    return {
                        scalars: scalar_indices[prop],
                        objects: object_indices[prop]};
                else if (isobject(val)) {
                    valkey=val._id||val.uuid||val.oid||val._fdjtid||
                        register(val);
                    indices=object_indices;}
                else valkey=val;
                var index=indices[prop];
                if (!(item))
                    if (!(index)) return [];
                else return Set(index[valkey]);
                var itemkey=
                    ((isobject(item))?
                     (item._id||item.uuid||item.oid||
                      item._fdjtid||register(item)):
                     (item));
                if (!(index))
                    if (add) {
                        indices[prop]=index={};
                        index[valkey]=[itemkey];
                        return true;}
                else return false;
                var curvals=index[valkey];
                if (curvals) {
                    var pos=arr_position(curvals,itemkey);
                    if (pos<0) {
                        if (add) {
                            curvals.push(itemkey);
                            return true;}
                        else return false;}
                    else if (add) return false;
                    else {
                        var sortlen=curvals._sortlen;
                        curvals.splice(pos,1);
                        if (pos<sortlen) curvals._sortlen--;
                        return true;}}
                else if (add) {
                    index[valkey]=Set(itemkey);
                    return true;}
                else return false;};
            return index;}
        fdjtKB.Index=Index;

        /* Refs */

        function Ref(pool,qid) {
            if (pool) this.pool=pool;
            if (qid) this._id=qid;
            return this;}
        fdjtKB.Ref=Ref;
        Pool.prototype.cons=function(qid){
            return new Ref(this,qid);};

        Ref.prototype.load=function(){
            if (this._init) return this;
            else if (this.pool.storage) 
                return this.pool.storage.load(this);
            else return undefined;};
        Ref.prototype.get=function(prop){
            if (this.hasOwnProperty(prop)) return this[prop];
            else if (this.pool.storage) {
                var fetched=this.pool.storage.get(this,prop);
                if (typeof fetched !== 'undefined') {
                    this[prop]=fetched;
                    return fetched;}
                else if (this.hasOwnProperty(prop))
                    return this[prop];
                else return fetched;}
            else return undefined;};
        Ref.prototype.getSet=function(prop){
            if (this.hasOwnProperty(prop)) {
                var val=this[prop];
                if (val instanceof Array) {
                    if (val._sortlen===val.length) return val;
                    else return setify(val);}
                else return [val];}
            else if (this.pool.storage) {
                var fetched=this.pool.storage.get(this,prop);
                if (typeof fetched !== 'undefined')
                    this[prop]=fetched;
                else fetched=this[prop]||[];
                return setify(fetched);}
            else return [];};
        Ref.prototype.getArray=function(prop){
            if (this.hasOwnProperty(prop)) {
                var val=this[prop];
                if (val instanceof Array) return val;
                else return [val];}
            else if (this.pool.storage) {
                var fetched=this.pool.storage.get(this,prop);
                if (typeof fetched !== 'undefined')
                    this[prop]=fetched;
                return [fetched];}
            else return [];};
        Ref.prototype.add=function(prop,val,restore){
            if (this.pool.xforms[prop])
                val=this.pool.xforms[prop](val)||val;
            if (this.hasOwnProperty(prop)) {
                var cur=this[prop];
                if (cur===val) return false;
                else if (cur instanceof Array)
                    if (!(set_add(cur,val))) return false;
                else {}
                else this[prop]=Set([cur,val]);}
            else this[prop]=val;
            if ((this.pool.storage)&&(!(restore)))
                this.pool.storage.add(this,prop,val);
            if ((this.pool.effects)&&(this.pool.effects[prop]))
                this.pool.effects[prop](this,prop,val);
            if (this.pool.index)
                this.pool.index(this,prop,val,true);
            return true;};
        Ref.prototype.drop=function(prop,val){
            if (typeof val === 'undefined') val=this[prop];
            if (this.pool.xforms[prop])
                val=this.pool.xforms[prop](val)||val;
            var vals=false;
            if (prop==='_id') {}
            else if (this.hasOwnProperty(prop)) {
                var cur=this[prop];
                if (cur===val) delete this[prop];
                else if (cur instanceof Array) {
                    if (!(set_drop(cur,val))) return false;
                    if (cur.length===0) delete this[prop];}
                else return false;
                if (this.pool.storage)
                    this.pool.storage.drop(this,prop,val);
                if (this.pool.index)
                    this.pool.index(this,prop,val,false);
                return true;}
            else return false;};
        Ref.prototype.test=function(prop,val){
            if (this.pool.xforms[prop])
                val=this.pool.xforms[prop](val)||val;
            if (this.hasOwnProperty(prop)) {
                if (typeof val === 'undefined') return true;
                var cur=this[prop];
                if (cur===val) return true;
                else if (cur instanceof Array)
                    if (arr_contains(cur,val)) return true;
                else return false;
                else return false;}
            else if (this.pool.storage) {
                var fetched=this.pool.storage.get(this,prop);
                if (typeof fetched !== 'undefined')
                    this[prop]=fetched;
                else return false;
                if (typeof val === 'undefined') return true;
                else return this.test(prop,val);}
            else return false;};
        Ref.prototype.ondrop=function(){
            for (var prop in this)
                if ((prop!=='pool')&&(prop!=='qid'))
                    this.drop(prop,this[prop]);};
        function init_ref(data){
            // If it's already been initialized, we're updating
            if (this._init) return this.update(data);
            // This is called initialize a reference the first time we
            //  get data for it
            var pool=this.pool; var map=pool.map;
            this._init=fdjtTime();
            if (((debug)&&(pool.traceref))||(debug>1))
                log("Initial reference to %o <== %o @%d",
                    this,data,this._init);
            for (var key in data) {
                // We assume that data doesn't inherit anything,
                //  so we don't need a 'hasOwnProperty' check
                if ((key==='qid')||(key==='pool')) {}
                else if ((key==='_id')||(key==='oid')||(key==='oid')) {
                    var value=data[key];
                    if (!(map[value])) map[value]=this;
                    else if (map[value]!==this)
                        warn("identifier conflict %o=%o for %o and %o",
                             key,value,map[value],this);
                    else {}}
                else if (key[0]==='_') {}
                else {
                    // We use the .add method to get any side effects
                    var value=data[key]; var qid;
                    if (value instanceof Array) {
                        var i=0; var len=value.length;
                        while (i<len) {
                            var v=value[i++]; /* back to here */
                            if ((!(v))&&(v!==false)&&(v!==0)) {}
                            else if (qid=((v._qid)||(v._id))) {
                                var pool=getPool(qid);
                                if (pool) this.add(key,pool.Import(v),true);
                                else this.add(key,v,true);}
                            else this.add(key,v,true);}}
                    else if (qid=((value._qid)||(value._id))) {
                        var pool=getPool(qid);
                        if (pool) this.add(key,pool.Import(value),true);
                        else this.add(key,v,true);}
                    else this.add(key,value,true);}}
            // Now we run the init procedures for the pool
            var inits=pool.inits;
            if (inits) {
                if (((debug)&&(pool.traceinit))||(debug>2))
                    log("Running pool inits for %o: %o",this,inits);
                var i=0; var lim=inits.length;
                while (i<lim) inits[i++](this);}
            // We now run local delayed inits
            var inits=this._inits; delete this._inits;
            if (inits) {
                if (((debug)&&(pool.traceinit))||(debug>2))
                    log("Running delayed inits for %o: %o",this,inits);
                delete this._inits;
                var i=0; var lim=inits.length;
                while (i<lim) inits[i++](this);}
            return this;}
        Ref.prototype.init=init_ref;

        function update_ref(data){
            if (!(this._init)) return this.init(data);
            var pool=this.pool; var map=pool.map;
            if ((this._modified)&&(data._modified)&&
                (this._modified>data._modified))
                return this;
            for (var key in data) {
                if ((key==="pool")||(key=="init")) continue;
                var val=data[key], cur=this[key];
                if (val===cur) continue;
                else if (!(cur)) {
                    if (val instanceof Array) {
                        var i=0, lim=val.length;
                        while (i<lim) this.add(key,val[i++],true);}
                    else this.add(key,val);}
                else if ((val instanceof Array)||
                         (cur instanceof Array)) {
                    var toadd=difference(val,cur);
                    var todrop=difference(cur,val);
                    var i=0; var lim=todrop.length;
                    while (i<lim) this.drop(key,todrop[i++],true);
                    var i=0; var lim=toadd.length;
                    while (i<lim) this.add(key,toadd[i++],true);}
                else {
                    this.drop(key,cur,true);
                    this.add(key,val,true);}}
            return this;}
        Ref.prototype.update=update_ref;
        Ref.prototype.oninit=function(fcn,name){
            var pool=this.pool;
            var debugging=(((debug)&&(pool.traceinit))||(debug>2));
            if (this._init) {
                // If it's already been initialized, just call the function
                if (debugging) {
                    if (name) 
                        log("Init/%s current %o with %o",name,this,fcn);
                    else log("Init current %o with %o",this,fcn);}
                fcn(this);
                return true;}
            else if (this._inits) {
                // Save up the init functions
                if (!(name)) {
                    if (this._inits.indexOf(fcn)<0) {
                        if (debugging) log("Delay init on %o: %o",this,fcn);
                        this._inits.push(fcn);}}
                // Don't do anything if the named init has already been added
                    /* Note that name can't be anything that an array object
                       might inherit (like 'length'). */ 
                else if (this._inits[name]===fcn) {
                    if (debugging)
                        log("Already added %s init on %o: %o",this,fcn);}
                else if (this._inits[name]) {
                    var oldfcn=this._inits[name];
                    var oldpos=this._inits.indexOf(oldfcn);
                    warn("Replacing existing %s init on %o with %o, old=%o",
                         name,this,fcn,oldfcn);
                    this._inits[name]=fcn;
                    if (oldpos<0) this._inits.push(fcn);
                    else this._inits[oldpos]=fcn;}
                else {
                    if (debugging)
                        fdjtLog("Delay %s init on %o: %o",name,this,fcn);
                    this._inits[name]=fcn;
                    this._inits.push(fcn);}}
            else if (name) {
                if (debugging)
                    fdjtLog("Delay %s init on %o: %o",name,this,fcn);
                this._inits=[fcn];
                this._inits[name]=fcn;}
            else {
                fdjtLog("Delay init on %o: %o",this,fcn);
                this._inits=[fcn];}
            return false;};

        Ref.prototype.toHTML=function(){
            var dom=false;
            return ((this.pool.forHTML)&&(this.pool.forHTML(this)))||
                ((this.pool.forDOM)&&(dom=this.pool.forDOM(this))&&
                 (dom.outerHTML))||
                this._id||this.oid||this.uuid;};
        Ref.prototype.toDOM=function(){
            return ((this.pool.forDOM)&&(this.pool.forDOM(this)))||
                ((this.pool.forHTML)&&(fdjtDOM(this.pool.forHTML(this))))||
                (fdjtDOM("span.fdjtref",this._id||this.oid||this.uuid));};


        /* Using offline storage to back up pools
           In the simplest model, the QID is just used as a key
           in local storage to store a JSON version of the object. */

        var getLocal=fdjtState.getLocal;
        var setLocal=fdjtState.setLocal;
        var dropLocal=fdjtState.dropLocal;
        var jsonString=JSON.stringify;

        function OfflineKB(pool){
            this.pool=pool; var map=pool.map;
            for (var key in map) {
                if (map.hasOwnProperty(key)) {
                    var obj=map[key];
                    var qid=obj._qid||obj.uuid||obj.oid||obj._id;
                    if (qid) setLocal(qid,jsonString(obj));};}
            return this;}
        function offline_get(obj,prop){
            var qid=obj._qid||obj.uuid||obj.oid||obj._id;
            var data=getLocal(qid);
            if (data) obj.init(data);
            return obj[prop];}
        OfflineKB.prototype.load=function(obj){
            var qid=obj._qid||obj.uuid||obj.oid||obj._id;
            var data=getLocal(qid,true);
            if (data) return obj.init(data);
            else return undefined;};
        OfflineKB.prototype.probe=function(qid){
            return getLocal(qid,true);};
        OfflineKB.prototype.get=offline_get;
        OfflineKB.prototype.add=function(obj,slotid,val){
            var qid=obj._qid||obj.uuid||obj.oid||obj._id;
            if ((slotid)&&(val))
                setLocal(qid,jsonString(obj));};
        OfflineKB.prototype.drop=function(obj,slotid,val){
            var qid=obj._qid||obj.uuid||obj.oid||obj._id;
            if (!(slotid)) dropLocal(qid);
            else setLocal(qid,jsonString(obj));};
        OfflineKB.prototype.Import=function(obj){
            var qid=obj._qid||obj.uuid||obj.oid||obj._id;
            setLocal(qid,obj,true);};
        fdjtKB.OfflineKB=OfflineKB;
        
        /* Miscellaneous array and table functions */

        fdjtKB.add=function(obj,field,val,nodup){
            if (arguments.length===2)
                return set_add(obj,field);
            else if (obj instanceof Ref)
                return obj.add.apply(obj,arguments);
            else if (nodup) 
                if (obj.hasOwnProperty(field)) {
                    var vals=obj[field];
                    if (!(arr_contains(vals,val))) obj[field].push(val);
                    else {}}
            else obj[field]=new Array(val);
            else if (obj.hasOwnProperty(field))
                obj[field].push(val);
            else obj[field]=new Array(val);
            if ((obj._all) && (!(arr_contains(obj._all,field))))
                obj._all.push(field);};

        fdjtKB.drop=function(obj,field,val){
            if (arguments.length===2)
                return set_drop(obj,field);
            else if (obj instanceof Ref)
                return obj.drop.apply(obj,arguments);
            else if (!(val))
                /* Drop all vals */
                obj[field]=new Array();
            else if (obj.hasOwnProperty(field)) {
                var vals=obj[field];
                var pos=arr_position(vals,val);
                if (pos<0) return;
                else vals.splice(pos,1);}
            else {}};

        fdjtKB.test=function(obj,field,val){
            if (arguments.length===2)
                return set_contains(obj,field);
            else if (obj instanceof Ref)
                return obj.test.apply(obj,arguments);
            else if (typeof val === "undefined")
                return (((obj.hasOwnProperty) ?
                         (obj.hasOwnProperty(field)) : (obj[field])) &&
                        ((obj[field].length)>0));
            else if (obj.hasOwnProperty(field)) { 
                if (arr_position(obj[field],val)<0)
                    return false;
                else return true;}
            else return false;};

        fdjtKB.insert=function(array,value){
            if (arr_position(array,value)<0) array.push(value);};

        fdjtKB.remove=function(array,value,count){
            var pos=arr_position(array,value);
            if (pos<0) return array;
            array.splice(pos,1);
            if (count) {
                count--;
                while ((count>0) &&
                       ((pos=arr_position(array,value,pos))>=0)) {
                    array.splice(pos,1); count--;}}
            return array;};

        fdjtKB.indexOf=function(array,elt,pos){
            if (pos) return array.indexOf(elt,pos);
            else return array.indexOf(elt);};

        fdjtKB.contains=arr_contains;
        fdjtKB.position=arr_position;

        return fdjtKB;})();}

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*
/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/state.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.State=
    (function(){

        var fdjtLog=fdjt.Log;

        function fdjtState(name,val,persist){
            if (arguments.length===1)
                return ((window.sessionStorage)&&(getSession(name)))||
                ((window.sessionStorage)&&(getLocal(name)))||
                getCookie(name);
            else if (persist)
                if (window.localStorage)
                    if (val) setLocal(name,val);
            else dropLocal(name);
            else {
                var domain=fdjtState.domain||location.hostname;
                var path=fdjtState.path||"/";
                var duration=fdjtState.duration||(3600*24*365*7);
                if (val) setCookie(name,val,duration,path,domain);
                else clearCookie(name,path,domain);}
            else if (val)
                if (window.sessionStorage) setSession(name,val);
            else setCookie(name,val);
            else if (window.sessionStorage) dropSession(name);
            else clearCookie(name);};
        fdjtState.domain=false;
        fdjtState.path=false;
        fdjtState.duration=false;

        /* Old-school cookies */

        function getCookie(name,parse){
            try {
                var cookies=document.cookie;
                var namepat=new RegExp("(^|(; ))"+name+"=","g");
                var pos=cookies.search(namepat);
                var valuestring;
                if (pos>=0) {
                    var start=cookies.indexOf('=',pos)+1;
                    var end=cookies.indexOf(';',start);
                    if (end>0) valuestring=cookies.slice(start,end);
                    else valuestring=cookies.slice(start);}
                else return false;
                if (parse)
                    return JSON.parse(decodeURIComponent(valuestring));
                else return decodeURIComponent(valuestring);}
            catch (ex) {
                return false;}}
        fdjtState.getCookie=getCookie;

        function setCookie(name,value,expires,path,domain){
            try {
                if (value) {
                    var valuestring=
                        ((typeof value === 'string') ? (value) :
                         (value.toJSON) ? (value.toJSON()) :
                         (value.toString) ? (value.toString()) : (value));
                    var cookietext=name+"="+encodeURIComponent(valuestring);
                    if (expires)
                        if (typeof(expires)==='string')
                            cookietext=cookietext+'; '+expires;
                    else if (expires.toGMTString)
                        cookietext=cookietext+"; expires="+expires.toGMTString();
                    else if (typeof(expires)==='number')
                        if (expires>0) {
                            var now=new Date();
                            now.setTime(now.getTime()+expires);
                            cookietext=cookietext+"; expires="+now.toGMTString;}
                    else cookietext=cookietext+"; expires=Sun 1 Jan 2000 00:00:00 UTC";
                    else {}
                    if (path) cookietext=cookietext+"; path="+path;
                    // This certainly doesn't work generally and might not work ever
                    if (domain) cookietext=cookietext+"; domain="+domain;
                    // fdjtTrace("Setting cookie %o cookietext=%o",name,cookietext);
                    document.cookie=cookietext;}
                else clearCookie(name,path,domain);}
            catch (ex) {
                fdjtLog.warn("Error setting cookie %s",name);}}
        fdjtState.setCookie=setCookie;
        
        function clearCookie(name,domain,path){
            try {
                var valuestring="ignoreme";
                var cookietext=name+"="+encodeURIComponent(valuestring)+
                    "; expires=Sun 1 Jan 2000 00:00:00 UTC";
                if (path) cookietext=cookietext+"; path="+path;
                // This certainly doesn't work generally and might not work ever
                if (domain) cookietext=cookietext+"; domain="+domain;
                // fdjtTrace("Clearing cookie %o: text=%o",name,cookietext);
                document.cookie=cookietext;}
            catch (ex) {
                fdjtLog.warn("Error clearing cookie %s",name);}}
        fdjtState.clearCookie=clearCookie;

        /* Session storage */

        function setSession(name,val,unparse){
            if (unparse) val=JSON.stringify(val);
            if (window.sessionStorage)
                window.sessionStorage[name]=val;
            else setCookie(name,val);}
        fdjtState.setSession=setSession;

        function getSession(name,parse){
            var val=((window.sessionStorage)?
                     (window.sessionStorage[name]):
                     (fdjtGetCookie(name)));
            if (val)
                if (parse) return JSON.parse(val); else return val;
            else return false;}
        fdjtState.getSession=getSession;

        function dropSession(name){
            if (window.sessionStorage)
                return window.sessionStorage.removeItem(name);
            else clearCookie(name);}
        fdjtState.dropSession=dropSession;

        /* Local storage (persists between sessions) */

        function setLocal(name,val,unparse){
            if (!(name)) throw { error: "bad name",name: name};
            if (unparse) val=JSON.stringify(val);
            if (window.localStorage)
                window.localStorage[name]=val;}
        fdjtState.setLocal=setLocal;

        function getLocal(name,parse){
            if (window.localStorage) {
                var val=window.localStorage[name];
                if (val)
                    if (parse) return JSON.parse(val); else return val;
                else return false;}
            else return false;}
        fdjtState.getLocal=getLocal;

        function dropLocal(name){
            if (window.localStorage)
                return window.localStorage.removeItem(name);
            else return false;}
        fdjtState.dropLocal=dropLocal;
        
        function listLocal(){
            var keys=[];
            if (window.localStorage) {
                var storage=window.localStorage;
                var i=0; var lim=storage.length;
                while (i<lim) keys.push(storage.key(i++));}
            return keys;}
        fdjtState.listLocal=listLocal;

        function clearLocal(){
            if (window.localStorage) {
                var storage=window.localStorage;
                var i=0; var lim=storage.length;
                var keys=[];
                while (i<lim) keys.push(storage.key(i++));
                i=0; while (i<lim) storage.removeItem(keys[i++]);}}
        fdjtState.clearLocal=clearLocal;

        /* Gets arguments from the query string */
        function getQuery(name,multiple,matchcase,verbatim){
            if (!(location.search))
                if (multiple) return [];
            else return false;
            var results=[];
            var ename=encodeURIComponent(name);
            var namepat=new RegExp("(&|^|\\?)"+ename+"(=|&|$)",
                                   ((matchcase)?"g":"gi"));
            var query=location.search;
            var start=query.search(namepat);
            while (start>=0) {
                // Skip over separator if non-initial
                if ((query[start]==='?')||(query[start]==='&')) start++;
                // Skip over the name
                var valstart=start+ename.length;
                var valstring=query.slice(valstart+1);
                var end=valstring.search(/(&|$)/g);
                if (query[valstart]==="=") {
                    if (end<=0) {
                        results.push("");
                        if (!(multiple)) break;}
                    else {
                        results.push(valstring.slice(0,end));
                        end=end+valstart+1;
                        if (!(multiple)) break;}}
                else if (multiple) 
                    results.push(query.slice(start,end));
                else if (verbatim) 
                    return query.slice(start,end);
                else return querydecode(query.slice(start,end));
                if (end>0) {
                    query=query.slice(end);
                    start=query.search(namepat);}}
            if (!(verbatim)) {
                var i=0; var lim=results.length;
                while (i<lim) {results[i]=querydecode(results[i]); i++;}}
            if (multiple) return results;
            else if (results.length)
                return results[0];
            else return false;}
        fdjtState.getQuery=getQuery;
        
        function querydecode(string){
            if (decodeURIComponent)
                return decodeURIComponent(string);
            else return 
            string.replace
            (/%3A/gi,":").replace
            (/%2F/gi,"/").replace
            (/%3F/gi,"?").replace
            (/%3D/gi,"=").replace
            (/%20/gi," ").replace
            (/%40/gi,"@").replace
            (/%23/gi,"#");}

        function test_opt(pos,neg){
            var pospat=((pos)&&(new RegExp("\\b"+pos+"\\b")));
            var negpat=((neg)&&negative_opt_pat(neg));
            var i=2; while (i<arguments.length) {
                var arg=arguments[i++];
                if (!(arg)) continue;
                else if (typeof arg === 'string')
                    if ((pospat)&&(arg.search(pospat)>=0)) return true;
                else if ((negpat)&&(arg.search(negpat)>=0)) return false;
                else continue;
                else if (arg.length) {
                    var j=0; var len=arg.length;
                    while (j<len)
                        if ((pos)&&(arg[j]===pos)) return true;
                    else if ((neg)&&(arg[j]===neg)) return false;
                    else j++;
                    return false;}
                else continue;}
            return false;}
        fdjtState.testOption=test_opt;

        function negative_opt_pat(neg){
            if (!(neg)) return neg;
            else if (typeof neg === 'string')
                return (new RegExp("\\b"+neg+"\\b","gi"));
            else if (neg.length) {
                var rule="\\b(";
                var i=0; while (i<neg.length) {
                    var name=neg[i];
                    if (i>0) rule=rule+"|";
                    rule=rule+"("+name+")";
                    i++;}
                rule=rule+")\\b";
                return new RegExp(rule,"gi");}
            else return false;}

        fdjtState.argVec=function(argobj,start){
            var i=start||0;
            var result=new Array(argobj.length-i);
            while (i<argobj.length) {
                result[i-start]=argobj[i]; i++;}
            return result;};

        var zeros="000000000000000000000000000000000000000000000000000000000000000";
        function zeropad(string,len){
            if (string.length===len) return string;
            else if (string.length>len) return string.slice(0,len);
            else return zeros.slice(0,len-string.length)+string;}
        
        // This is a random nodeid used to generate UUIDs
        //  We use it because we can't access the MAC address
        var nodeid=
            zeropad(((Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)).toString(16)+
                     (Math.floor(Math.random()*65536)|0x01)).toString(16),
                    12);
        
        var default_version=17; 
        var clockid=Math.floor(Math.random()*16384); var msid=1;
        var last_time=new Date().getTime();
        
        fdjtState.getNodeID=function(){return nodeid;};
        fdjtState.setNodeID=function(arg){
            if (typeof arg==='number')
                nodeid=zeropad(arg.toString(16),12);
            else if (typeof arg === 'string')
                if (arg.search(/[^0123456789abcdefABCDEF]/)<0)
                    nodeid=zeropad(arg,12);
            else throw {error: 'invalid node id',value: arg};
            else throw {error: 'invalid node id',value: arg};};

        function getUUID(node){
            var now=new Date().getTime();
            if (now<last_time) {now=now*10000; clockid++;}
            else if (now===last_time)   now=now*10000+(msid++);
            else {now=now*10000; msid=1;}
            now=now+122192928000000000;
            if (!(node)) node=nodeid;
            var timestamp=now.toString(16); var tlen=timestamp.length;
            if (tlen<15) timestamp=zeros.slice(0,15-tlen)+timestamp;
            return timestamp.slice(7)+"-"+timestamp.slice(3,7)+
                "-1"+timestamp.slice(0,3)+
                "-"+(32768+(clockid%16384)).toString(16)+
                "-"+((node)?
                     ((typeof node === 'number')?
                      (zeropad(node.toString(16),12)):
                      (zeropad(node,12))):
                     (nodeid));}
        fdjtState.getUUID=getUUID;
        
        // Getting version information
        function versionInfo(){
            var s=navigator.userAgent; var result={};
            var start;
            while ((start=s.search(/\w+\/\d/g))>=0) {
                var slash=s.indexOf('/',start);
                var afterslash=s.slice(slash+1);
                var num_end=afterslash.search(/\W/);
                var numstring=afterslash.slice(0,num_end);
                try {
                    result[s.slice(start,slash)]=parseInt(numstring);}
                catch (ex) {
                    result[s.slice(start,slash)]=numstring;}
                s=afterslash.slice(num_end);}
            if (result['Chrome']) result.browser='Chrome';
            else if (result['Opera']) result.browser='Opera';
            else if (result['Safari']) result.browser='Safari';
            else if ((result['Safari'])&&(result['Mobile']))
                result.browser='MobileSafari';
            else if (result['Firefox']) result.browser='Firefox';
            else if ((result['Explorer'])||(result['IE'])||
                     (result['InternetExplorer'])||(result['MSIE']))
                result.browser='IE';
            else if (result['Mozilla']) result.browser='Mozilla';
            else result.browser='Browser';
            result.platform=navigator.platform||"Turing";
            return result;}
        fdjtState.versionInfo=versionInfo;

        return fdjtState;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/*
    http://www.JSON.org/json2.js
    2009-06-29

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html

    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the object holding the key.

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*jslint evil: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON = JSON || {};

(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

if (!(fdjt.JSON)) fdjt.JSON=JSON;

/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ######################### fdjt/hash.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   It implements a method for breaking narrative HTML content
   across multiple pages, attempting to honor page break constraints,
   etc.

   Check out the 'mini manual' at the bottom of the file or read the
   code itself.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or any
   later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

   Use and redistribution (especially embedding in other CC licensed
   content) is also permitted under the terms of the Creative Commons
   "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

/*
 * A JavaScript implementation of various hashing algorithms, merged
 *   into a single object.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

if (window) {if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

if (!(fdjt.Hash))
    fdjt.Hash=(function(){
	/*
	 * Configurable variables. You may need to tweak these to be compatible with
	 * the server-side, but the defaults work in most cases.
	 */
	var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
	var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */
	var enc=false;

	function gethexcase(){ return hexcase;}
	function sethexcase(v){ hexcase=v;}
	function getpadchar(){ return b64pad;}
	function setpadchar(v){ b64pad=v;}

	function getenc(){ return ;}
	function setenc(v) {
	    if (typeof v === 'string')
		enc=fdjtHash[v]||false;
	    else enc=v;}

	/*
	 * Convert a raw string to a hex string
	 */
	function rstr2hex(input)
	{
	    try { hexcase } catch(e) { hexcase=0; }
	    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
	    var output = "";
	    var x;
	    for(var i = 0; i < input.length; i++)
	    {
		x = input.charCodeAt(i);
		output += hex_tab.charAt((x >>> 4) & 0x0F)
		    +  hex_tab.charAt( x        & 0x0F);
	    }
	    return output;
	}

	/*
	 * Convert a raw string to a base-64 string
	 */
	function rstr2b64(input)
	{
	    try { b64pad } catch(e) { b64pad=''; }
	    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	    var output = "";
	    var len = input.length;
	    for(var i = 0; i < len; i += 3)
	    {
		var triplet = (input.charCodeAt(i) << 16)
		    | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
		    | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
		for(var j = 0; j < 4; j++)
		{
		    if(i * 8 + j * 6 > input.length * 8) output += b64pad;
		    else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
		}
	    }
	    return output;
	}

	/*
	 * Convert a raw string to an arbitrary string encoding
	 */
	function rstr2any(input, encoding)
	{
	    if (!(encoding)) {
		if (enc) return enc(input);
		else return rstr2hex(input);}
	    var divisor = encoding.length;
	    var i, j, q, x, quotient;

	    /* Convert to an array of 16-bit big-endian values, forming the dividend */
	    var dividend = Array(Math.ceil(input.length / 2));
	    for(i = 0; i < dividend.length; i++)
	    {
		dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
	    }

	    /*
	     * Repeatedly perform a long division. The binary array forms the dividend,
	     * the length of the encoding is the divisor. Once computed, the quotient
	     * forms the dividend for the next step. All remainders are stored for later
	     * use.
	     */
	    var full_length = Math.ceil(input.length * 8 /
					(Math.log(encoding.length) / Math.log(2)));
	    var remainders = Array(full_length);
	    for(j = 0; j < full_length; j++)
	    {
		quotient = Array();
		x = 0;
		for(i = 0; i < dividend.length; i++)
		{
		    x = (x << 16) + dividend[i];
		    q = Math.floor(x / divisor);
		    x -= q * divisor;
		    if(quotient.length > 0 || q > 0)
			quotient[quotient.length] = q;
		}
		remainders[j] = x;
		dividend = quotient;
	    }

	    /* Convert the remainders to the output string */
	    var output = "";
	    for(i = remainders.length - 1; i >= 0; i--)
		output += encoding.charAt(remainders[i]);

	    return output;
	}

	/*
	 * Encode a string as utf-8.
	 * For efficiency, this assumes the input is valid utf-16.
	 */
	function str2rstr_utf8(input)
	{
	    var output = "";
	    var i = -1;
	    var x, y;

	    while(++i < input.length)
	    {
		/* Decode utf-16 surrogate pairs */
		x = input.charCodeAt(i);
		y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
		if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
		{
		    x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
		    i++;
		}

		/* Encode output as utf-8 */
		if(x <= 0x7F)
		    output += String.fromCharCode(x);
		else if(x <= 0x7FF)
		    output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
						  0x80 | ( x         & 0x3F));
		else if(x <= 0xFFFF)
		    output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
						  0x80 | ((x >>> 6 ) & 0x3F),
						  0x80 | ( x         & 0x3F));
		else if(x <= 0x1FFFFF)
		    output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
						  0x80 | ((x >>> 12) & 0x3F),
						  0x80 | ((x >>> 6 ) & 0x3F),
						  0x80 | ( x         & 0x3F));
	    }
	    return output;
	}

	/*
	 * Encode a string as utf-16
	 */
	function str2rstr_utf16le(input)
	{
	    var output = "";
	    for(var i = 0; i < input.length; i++)
		output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
					       (input.charCodeAt(i) >>> 8) & 0xFF);
	    return output;
	}

	function str2rstr_utf16be(input)
	{
	    var output = "";
	    for(var i = 0; i < input.length; i++)
		output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
					      input.charCodeAt(i)        & 0xFF);
	    return output;
	}

	/*
	 * Convert a raw string to an array of little-endian words
	 * Characters >255 have their high-byte silently ignored.
	 */
	function rstr2binl(input)
	{
	    var output = Array(input.length >> 2);
	    for(var i = 0; i < output.length; i++)
		output[i] = 0;
	    for(var i = 0; i < input.length * 8; i += 8)
		output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
	    return output;
	}

	/*
	 * Convert an array of little-endian words to a string
	 */
	function binl2rstr(input)
	{
	    var output = "";
	    for(var i = 0; i < input.length * 32; i += 8)
		output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
	    return output;
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	    return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	    return (num << cnt) | (num >>> (32 - cnt));
	}

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
	function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
	function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
	function hex_hmac_md5(k, d)
	{ return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function b64_hmac_md5(k, d)
	{ return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function any_hmac_md5(k, d, e)
	{ return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function md5_vm_test()
	{
	    return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
	}

	/*
	 * Calculate the MD5 of a raw string
	 */
	function rstr_md5(s)
	{
	    return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
	}

	/*
	 * Calculate the HMAC-MD5, of a key and some data (raw strings)
	 */
	function rstr_hmac_md5(key, data)
	{
	    var bkey = rstr2binl(key);
	    if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

	    var ipad = Array(16), opad = Array(16);
	    for(var i = 0; i < 16; i++)
	    {
		ipad[i] = bkey[i] ^ 0x36363636;
		opad[i] = bkey[i] ^ 0x5C5C5C5C;
	    }

	    var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
	    return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
	}

	/* Calculate the MD5 of an array of little-endian words, and a bit length.
	 */
	function binl_md5(x, len)
	{
	    /* append padding */
	    x[len >> 5] |= 0x80 << ((len) % 32);
	    x[(((len + 64) >>> 9) << 4) + 14] = len;

	    var a =  1732584193;
	    var b = -271733879;
	    var c = -1732584194;
	    var d =  271733878;

	    for(var i = 0; i < x.length; i += 16)
	    {
		var olda = a;
		var oldb = b;
		var oldc = c;
		var oldd = d;

		a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
		d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
		c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
		b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
		a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
		d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
		c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
		b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
		a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
		d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
		c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
		b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
		a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
		d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
		c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
		b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

		a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
		d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
		c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
		b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
		a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
		d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
		c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
		b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
		a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
		d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
		c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
		b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
		a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
		d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
		c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
		b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

		a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
		d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
		c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
		b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
		a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
		d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
		c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
		b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
		a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
		d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
		c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
		b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
		a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
		d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
		c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
		b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

		a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
		d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
		c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
		b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
		a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
		d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
		c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
		b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
		a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
		d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
		c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
		b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
		a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
		d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
		c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
		b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

		a = safe_add(a, olda);
		b = safe_add(b, oldb);
		c = safe_add(c, oldc);
		d = safe_add(d, oldd);
	    }
	    return Array(a, b, c, d);
	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	    return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * A JavaScript implementation of the RIPEMD-160 Algorithm
	 * Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 * Also http://www.ocf.berkeley.edu/~jjlin/jsotp/
	 */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_rmd160(s)    { return rstr2hex(rstr_rmd160(str2rstr_utf8(s))); }
	function b64_rmd160(s)    { return rstr2b64(rstr_rmd160(str2rstr_utf8(s))); }
	function any_rmd160(s, e) { return rstr2any(rstr_rmd160(str2rstr_utf8(s)), e); }
	function hex_hmac_rmd160(k, d)
	{ return rstr2hex(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function b64_hmac_rmd160(k, d)
	{ return rstr2b64(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function any_hmac_rmd160(k, d, e)
	{ return rstr2any(rstr_hmac_rmd160(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function rmd160_vm_test()
	{
	    return hex_rmd160("abc").toLowerCase() == "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc";
	}

	/*
	 * Calculate the rmd160 of a raw string
	 */
	function rstr_rmd160(s)
	{
	    return binl2rstr(binl_rmd160(rstr2binl(s), s.length * 8));
	}

	/*
	 * Calculate the HMAC-rmd160 of a key and some data (raw strings)
	 */
	function rstr_hmac_rmd160(key, data)
	{
	    var bkey = rstr2binl(key);
	    if(bkey.length > 16) bkey = binl_rmd160(bkey, key.length * 8);

	    var ipad = Array(16), opad = Array(16);
	    for(var i = 0; i < 16; i++)
	    {
		ipad[i] = bkey[i] ^ 0x36363636;
		opad[i] = bkey[i] ^ 0x5C5C5C5C;
	    }

	    var hash = binl_rmd160(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
	    return binl2rstr(binl_rmd160(opad.concat(hash), 512 + 160));
	}


	/*
	 * Calculate the RIPE-MD160 of an array of little-endian words, and a bit length.
	 */
	function binl_rmd160(x, len)
	{
	    /* append padding */
	    x[len >> 5] |= 0x80 << (len % 32);
	    x[(((len + 64) >>> 9) << 4) + 14] = len;

	    var h0 = 0x67452301;
	    var h1 = 0xefcdab89;
	    var h2 = 0x98badcfe;
	    var h3 = 0x10325476;
	    var h4 = 0xc3d2e1f0;

	    for (var i = 0; i < x.length; i += 16) {
		var T;
		var A1 = h0, B1 = h1, C1 = h2, D1 = h3, E1 = h4;
		var A2 = h0, B2 = h1, C2 = h2, D2 = h3, E2 = h4;
		for (var j = 0; j <= 79; ++j) {
		    T = safe_add(A1, rmd160_f(j, B1, C1, D1));
		    T = safe_add(T, x[i + rmd160_r1[j]]);
		    T = safe_add(T, rmd160_K1(j));
		    T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
		    A1 = E1; E1 = D1; D1 = bit_rol(C1, 10); C1 = B1; B1 = T;
		    T = safe_add(A2, rmd160_f(79-j, B2, C2, D2));
		    T = safe_add(T, x[i + rmd160_r2[j]]);
		    T = safe_add(T, rmd160_K2(j));
		    T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
		    A2 = E2; E2 = D2; D2 = bit_rol(C2, 10); C2 = B2; B2 = T;
		}
		T = safe_add(h1, safe_add(C1, D2));
		h1 = safe_add(h2, safe_add(D1, E2));
		h2 = safe_add(h3, safe_add(E1, A2));
		h3 = safe_add(h4, safe_add(A1, B2));
		h4 = safe_add(h0, safe_add(B1, C2));
		h0 = T;
	    }
	    return [h0, h1, h2, h3, h4];
	}

	function rmd160_f(j, x, y, z)
	{
	    return ( 0 <= j && j <= 15) ? (x ^ y ^ z) :
		(16 <= j && j <= 31) ? (x & y) | (~x & z) :
		(32 <= j && j <= 47) ? (x | ~y) ^ z :
		(48 <= j && j <= 63) ? (x & z) | (y & ~z) :
		(64 <= j && j <= 79) ? x ^ (y | ~z) :
		"rmd160_f: j out of range";
	}
	function rmd160_K1(j)
	{
	    return ( 0 <= j && j <= 15) ? 0x00000000 :
		(16 <= j && j <= 31) ? 0x5a827999 :
		(32 <= j && j <= 47) ? 0x6ed9eba1 :
		(48 <= j && j <= 63) ? 0x8f1bbcdc :
		(64 <= j && j <= 79) ? 0xa953fd4e :
		"rmd160_K1: j out of range";
	}
	function rmd160_K2(j)
	{
	    return ( 0 <= j && j <= 15) ? 0x50a28be6 :
		(16 <= j && j <= 31) ? 0x5c4dd124 :
		(32 <= j && j <= 47) ? 0x6d703ef3 :
		(48 <= j && j <= 63) ? 0x7a6d76e9 :
		(64 <= j && j <= 79) ? 0x00000000 :
		"rmd160_K2: j out of range";
	}
	var rmd160_r1 = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13
	];
	var rmd160_r2 = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11
	];
	var rmd160_s1 = [
	    11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7,  6,  8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	    11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6
	];
	var rmd160_s2 = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11
	];

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS 180-1
	 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }
	function b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }
	function any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }
	function hex_hmac_sha1(k, d)
	{ return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function b64_hmac_sha1(k, d)
	{ return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function any_hmac_sha1(k, d, e)
	{ return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function sha1_vm_test()
	{
	    return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
	}

	/*
	 * Calculate the SHA1 of a raw string
	 */
	function rstr_sha1(s)
	{
	    return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
	}

	/*
	 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
	 */
	function rstr_hmac_sha1(key, data)
	{
	    var bkey = rstr2binb(key);
	    if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

	    var ipad = Array(16), opad = Array(16);
	    for(var i = 0; i < 16; i++)
	    {
		ipad[i] = bkey[i] ^ 0x36363636;
		opad[i] = bkey[i] ^ 0x5C5C5C5C;
	    }

	    var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
	    return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
	}

	/*
	 * Calculate the SHA-1 of an array of big-endian words, and a bit length
	 */
	function binb_sha1(x, len)
	{
	    /* append padding */
	    x[len >> 5] |= 0x80 << (24 - len % 32);
	    x[((len + 64 >> 9) << 4) + 15] = len;

	    var w = Array(80);
	    var a =  1732584193;
	    var b = -271733879;
	    var c = -1732584194;
	    var d =  271733878;
	    var e = -1009589776;

	    for(var i = 0; i < x.length; i += 16)
	    {
		var olda = a;
		var oldb = b;
		var oldc = c;
		var oldd = d;
		var olde = e;

		for(var j = 0; j < 80; j++)
		{
		    if(j < 16) w[j] = x[i + j];
		    else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
		    var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
				     safe_add(safe_add(e, w[j]), sha1_kt(j)));
		    e = d;
		    d = c;
		    c = bit_rol(b, 30);
		    b = a;
		    a = t;
		}

		a = safe_add(a, olda);
		b = safe_add(b, oldb);
		c = safe_add(c, oldc);
		d = safe_add(d, oldd);
		e = safe_add(e, olde);
	    }
	    return Array(a, b, c, d, e);

	}

	/*
	 * Perform the appropriate triplet combination function for the current
	 * iteration
	 */
	function sha1_ft(t, b, c, d)
	{
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	}

	/*
	 * Determine the appropriate additive constant for the current iteration
	 */
	function sha1_kt(t)
	{
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
		(t < 60) ? -1894007588 : -899497514;
	}

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2 Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 * Also http://anmar.eu.org/projects/jssha2/
	 */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_sha256(s)    { return rstr2hex(rstr_sha256(str2rstr_utf8(s))); }
	function b64_sha256(s)    { return rstr2b64(rstr_sha256(str2rstr_utf8(s))); }
	function any_sha256(s, e) { return rstr2any(rstr_sha256(str2rstr_utf8(s)), e); }
	function hex_hmac_sha256(k, d)
	{ return rstr2hex(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function b64_hmac_sha256(k, d)
	{ return rstr2b64(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function any_hmac_sha256(k, d, e)
	{ return rstr2any(rstr_hmac_sha256(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function sha256_vm_test()
	{
	    return hex_sha256("abc").toLowerCase() ==
		"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad";
	}

	/*
	 * Calculate the sha256 of a raw string
	 */
	function rstr_sha256(s)
	{
	    return binb2rstr(binb_sha256(rstr2binb(s), s.length * 8));
	}

	/*
	 * Calculate the HMAC-sha256 of a key and some data (raw strings)
	 */
	function rstr_hmac_sha256(key, data)
	{
	    var bkey = rstr2binb(key);
	    if(bkey.length > 16) bkey = binb_sha256(bkey, key.length * 8);

	    var ipad = Array(16), opad = Array(16);
	    for(var i = 0; i < 16; i++)
	    {
		ipad[i] = bkey[i] ^ 0x36363636;
		opad[i] = bkey[i] ^ 0x5C5C5C5C;
	    }

	    var hash = binb_sha256(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
	    return binb2rstr(binb_sha256(opad.concat(hash), 512 + 256));
	}

	/*
	 * Main sha256 function, with its support functions
	 */
	function sha256_S (X, n) {return ( X >>> n ) | (X << (32 - n));}
	function sha256_R (X, n) {return ( X >>> n );}
	function sha256_Ch(x, y, z) {return ((x & y) ^ ((~x) & z));}
	function sha256_Maj(x, y, z) {return ((x & y) ^ (x & z) ^ (y & z));}
	function sha256_Sigma0256(x) {return (sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22));}
	function sha256_Sigma1256(x) {return (sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25));}
	function sha256_Gamma0256(x) {return (sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3));}
	function sha256_Gamma1256(x) {return (sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10));}
	function sha256_Sigma0512(x) {return (sha256_S(x, 28) ^ sha256_S(x, 34) ^ sha256_S(x, 39));}
	function sha256_Sigma1512(x) {return (sha256_S(x, 14) ^ sha256_S(x, 18) ^ sha256_S(x, 41));}
	function sha256_Gamma0512(x) {return (sha256_S(x, 1)  ^ sha256_S(x, 8) ^ sha256_R(x, 7));}
	function sha256_Gamma1512(x) {return (sha256_S(x, 19) ^ sha256_S(x, 61) ^ sha256_R(x, 6));}

	var sha256_K = new Array
	(
	    1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993,
		-1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987,
	    1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522,
	    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
		-1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585,
	    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
	    1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885,
		-1035236496, -949202525, -778901479, -694614492, -200395387, 275423344,
	    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
	    1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872,
		-1866530822, -1538233109, -1090935817, -965641998
	);

	function binb_sha256(m, l)
	{
	    var HASH = new Array(1779033703, -1150833019, 1013904242, -1521486534,
				 1359893119, -1694144372, 528734635, 1541459225);
	    var W = new Array(64);
	    var a, b, c, d, e, f, g, h;
	    var i, j, T1, T2;

	    /* append padding */
	    m[l >> 5] |= 0x80 << (24 - l % 32);
	    m[((l + 64 >> 9) << 4) + 15] = l;

	    for(i = 0; i < m.length; i += 16)
	    {
		a = HASH[0];
		b = HASH[1];
		c = HASH[2];
		d = HASH[3];
		e = HASH[4];
		f = HASH[5];
		g = HASH[6];
		h = HASH[7];

		for(j = 0; j < 64; j++)
		{
		    if (j < 16) W[j] = m[j + i];
		    else W[j] = safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]),
						  sha256_Gamma0256(W[j - 15])), W[j - 16]);

		    T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)),
                                           sha256_K[j]), W[j]);
		    T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c));
		    h = g;
		    g = f;
		    f = e;
		    e = safe_add(d, T1);
		    d = c;
		    c = b;
		    b = a;
		    a = safe_add(T1, T2);
		}

		HASH[0] = safe_add(a, HASH[0]);
		HASH[1] = safe_add(b, HASH[1]);
		HASH[2] = safe_add(c, HASH[2]);
		HASH[3] = safe_add(d, HASH[3]);
		HASH[4] = safe_add(e, HASH[4]);
		HASH[5] = safe_add(f, HASH[5]);
		HASH[6] = safe_add(g, HASH[6]);
		HASH[7] = safe_add(h, HASH[7]);
	    }
	    return HASH;
	}

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-512, as defined
	 * in FIPS 180-2
	 * Version 2.2 Copyright Anonymous Contributor, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_sha512(s)    { return rstr2hex(rstr_sha512(str2rstr_utf8(s))); }
	function b64_sha512(s)    { return rstr2b64(rstr_sha512(str2rstr_utf8(s))); }
	function any_sha512(s, e) { return rstr2any(rstr_sha512(str2rstr_utf8(s)), e);}
	function hex_hmac_sha512(k, d)
	{ return rstr2hex(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function b64_hmac_sha512(k, d)
	{ return rstr2b64(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d))); }
	function any_hmac_sha512(k, d, e)
	{ return rstr2any(rstr_hmac_sha512(str2rstr_utf8(k), str2rstr_utf8(d)), e);}

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function sha512_vm_test()
	{
	    return hex_sha512("abc").toLowerCase() ==
		"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" +
		"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f";
	}

	/*
	 * Calculate the SHA-512 of a raw string
	 */
	function rstr_sha512(s)
	{
	    return binb2rstr(binb_sha512(rstr2binb(s), s.length * 8));
	}

	/*
	 * Calculate the HMAC-SHA-512 of a key and some data (raw strings)
	 */
	function rstr_hmac_sha512(key, data)
	{
	    var bkey = rstr2binb(key);
	    if(bkey.length > 32) bkey = binb_sha512(bkey, key.length * 8);

	    var ipad = Array(32), opad = Array(32);
	    for(var i = 0; i < 32; i++)
	    {
		ipad[i] = bkey[i] ^ 0x36363636;
		opad[i] = bkey[i] ^ 0x5C5C5C5C;
	    }

	    var hash = binb_sha512(ipad.concat(rstr2binb(data)), 1024 + data.length * 8);
	    return binb2rstr(binb_sha512(opad.concat(hash), 1024 + 512));
	}

	/*
	 * Calculate the SHA-512 of an array of big-endian dwords, and a bit length
	 */
	var sha512_k;
	function binb_sha512(x, len)
	{
	    if(sha512_k == undefined)
	    {
		//SHA512 constants
		sha512_k = new Array(
		    new int64(0x428a2f98, -685199838), new int64(0x71374491, 0x23ef65cd),
		    new int64(-1245643825, -330482897), new int64(-373957723, -2121671748),
		    new int64(0x3956c25b, -213338824), new int64(0x59f111f1, -1241133031),
		    new int64(-1841331548, -1357295717), new int64(-1424204075, -630357736),
		    new int64(-670586216, -1560083902), new int64(0x12835b01, 0x45706fbe),
		    new int64(0x243185be, 0x4ee4b28c), new int64(0x550c7dc3, -704662302),
		    new int64(0x72be5d74, -226784913), new int64(-2132889090, 0x3b1696b1),
		    new int64(-1680079193, 0x25c71235), new int64(-1046744716, -815192428),
		    new int64(-459576895, -1628353838), new int64(-272742522, 0x384f25e3),
		    new int64(0xfc19dc6, -1953704523), new int64(0x240ca1cc, 0x77ac9c65),
		    new int64(0x2de92c6f, 0x592b0275), new int64(0x4a7484aa, 0x6ea6e483),
		    new int64(0x5cb0a9dc, -1119749164), new int64(0x76f988da, -2096016459),
		    new int64(-1740746414, -295247957), new int64(-1473132947, 0x2db43210),
		    new int64(-1341970488, -1728372417), new int64(-1084653625, -1091629340),
		    new int64(-958395405, 0x3da88fc2), new int64(-710438585, -1828018395),
		    new int64(0x6ca6351, -536640913), new int64(0x14292967, 0xa0e6e70),
		    new int64(0x27b70a85, 0x46d22ffc), new int64(0x2e1b2138, 0x5c26c926),
		    new int64(0x4d2c6dfc, 0x5ac42aed), new int64(0x53380d13, -1651133473),
		    new int64(0x650a7354, -1951439906), new int64(0x766a0abb, 0x3c77b2a8),
		    new int64(-2117940946, 0x47edaee6), new int64(-1838011259, 0x1482353b),
		    new int64(-1564481375, 0x4cf10364), new int64(-1474664885, -1136513023),
		    new int64(-1035236496, -789014639), new int64(-949202525, 0x654be30),
		    new int64(-778901479, -688958952), new int64(-694614492, 0x5565a910),
		    new int64(-200395387, 0x5771202a), new int64(0x106aa070, 0x32bbd1b8),
		    new int64(0x19a4c116, -1194143544), new int64(0x1e376c08, 0x5141ab53),
		    new int64(0x2748774c, -544281703), new int64(0x34b0bcb5, -509917016),
		    new int64(0x391c0cb3, -976659869), new int64(0x4ed8aa4a, -482243893),
		    new int64(0x5b9cca4f, 0x7763e373), new int64(0x682e6ff3, -692930397),
		    new int64(0x748f82ee, 0x5defb2fc), new int64(0x78a5636f, 0x43172f60),
		    new int64(-2067236844, -1578062990), new int64(-1933114872, 0x1a6439ec),
		    new int64(-1866530822, 0x23631e28), new int64(-1538233109, -561857047),
		    new int64(-1090935817, -1295615723), new int64(-965641998, -479046869),
		    new int64(-903397682, -366583396), new int64(-779700025, 0x21c0c207),
		    new int64(-354779690, -840897762), new int64(-176337025, -294727304),
		    new int64(0x6f067aa, 0x72176fba), new int64(0xa637dc5, -1563912026),
		    new int64(0x113f9804, -1090974290), new int64(0x1b710b35, 0x131c471b),
		    new int64(0x28db77f5, 0x23047d84), new int64(0x32caab7b, 0x40c72493),
		    new int64(0x3c9ebe0a, 0x15c9bebc), new int64(0x431d67c4, -1676669620),
		    new int64(0x4cc5d4be, -885112138), new int64(0x597f299c, -60457430),
		    new int64(0x5fcb6fab, 0x3ad6faec), new int64(0x6c44198c, 0x4a475817));
	    }

	    //Initial hash values
	    var H = new Array(
		new int64(0x6a09e667, -205731576),
		new int64(-1150833019, -2067093701),
		new int64(0x3c6ef372, -23791573),
		new int64(-1521486534, 0x5f1d36f1),
		new int64(0x510e527f, -1377402159),
		new int64(-1694144372, 0x2b3e6c1f),
		new int64(0x1f83d9ab, -79577749),
		new int64(0x5be0cd19, 0x137e2179));

	    var T1 = new int64(0, 0),
	    T2 = new int64(0, 0),
	    a = new int64(0,0),
	    b = new int64(0,0),
	    c = new int64(0,0),
	    d = new int64(0,0),
	    e = new int64(0,0),
	    f = new int64(0,0),
	    g = new int64(0,0),
	    h = new int64(0,0),
	    //Temporary variables not specified by the document
	    s0 = new int64(0, 0),
	    s1 = new int64(0, 0),
	    Ch = new int64(0, 0),
	    Maj = new int64(0, 0),
	    r1 = new int64(0, 0),
	    r2 = new int64(0, 0),
	    r3 = new int64(0, 0);
	    var j, i;
	    var W = new Array(80);
	    for(i=0; i<80; i++)
		W[i] = new int64(0, 0);

	    // append padding to the source string. The format is described in the FIPS.
	    x[len >> 5] |= 0x80 << (24 - (len & 0x1f));
	    x[((len + 128 >> 10)<< 5) + 31] = len;

	    for(i = 0; i<x.length; i+=32) //32 dwords is the block size
	    {
		int64copy(a, H[0]);
		int64copy(b, H[1]);
		int64copy(c, H[2]);
		int64copy(d, H[3]);
		int64copy(e, H[4]);
		int64copy(f, H[5]);
		int64copy(g, H[6]);
		int64copy(h, H[7]);

		for(j=0; j<16; j++)
		{
		    W[j].h = x[i + 2*j];
		    W[j].l = x[i + 2*j + 1];
		}

		for(j=16; j<80; j++)
		{
		    //sigma1
		    int64rrot(r1, W[j-2], 19);
		    int64revrrot(r2, W[j-2], 29);
		    int64shr(r3, W[j-2], 6);
		    s1.l = r1.l ^ r2.l ^ r3.l;
		    s1.h = r1.h ^ r2.h ^ r3.h;
		    //sigma0
		    int64rrot(r1, W[j-15], 1);
		    int64rrot(r2, W[j-15], 8);
		    int64shr(r3, W[j-15], 7);
		    s0.l = r1.l ^ r2.l ^ r3.l;
		    s0.h = r1.h ^ r2.h ^ r3.h;

		    int64add4(W[j], s1, W[j-7], s0, W[j-16]);
		}

		for(j = 0; j < 80; j++)
		{
		    //Ch
		    Ch.l = (e.l & f.l) ^ (~e.l & g.l);
		    Ch.h = (e.h & f.h) ^ (~e.h & g.h);

		    //Sigma1
		    int64rrot(r1, e, 14);
		    int64rrot(r2, e, 18);
		    int64revrrot(r3, e, 9);
		    s1.l = r1.l ^ r2.l ^ r3.l;
		    s1.h = r1.h ^ r2.h ^ r3.h;

		    //Sigma0
		    int64rrot(r1, a, 28);
		    int64revrrot(r2, a, 2);
		    int64revrrot(r3, a, 7);
		    s0.l = r1.l ^ r2.l ^ r3.l;
		    s0.h = r1.h ^ r2.h ^ r3.h;

		    //Maj
		    Maj.l = (a.l & b.l) ^ (a.l & c.l) ^ (b.l & c.l);
		    Maj.h = (a.h & b.h) ^ (a.h & c.h) ^ (b.h & c.h);

		    int64add5(T1, h, s1, Ch, sha512_k[j], W[j]);
		    int64add(T2, s0, Maj);

		    int64copy(h, g);
		    int64copy(g, f);
		    int64copy(f, e);
		    int64add(e, d, T1);
		    int64copy(d, c);
		    int64copy(c, b);
		    int64copy(b, a);
		    int64add(a, T1, T2);
		}
		int64add(H[0], H[0], a);
		int64add(H[1], H[1], b);
		int64add(H[2], H[2], c);
		int64add(H[3], H[3], d);
		int64add(H[4], H[4], e);
		int64add(H[5], H[5], f);
		int64add(H[6], H[6], g);
		int64add(H[7], H[7], h);
	    }

	    //represent the hash as an array of 32-bit dwords
	    var hash = new Array(16);
	    for(i=0; i<8; i++)
	    {
		hash[2*i] = H[i].h;
		hash[2*i + 1] = H[i].l;
	    }
	    return hash;
	}

	//A constructor for 64-bit numbers
	function int64(h, l)
	{
	    this.h = h;
	    this.l = l;
	    //this.toString = int64toString;
	}

	//Copies src into dst, assuming both are 64-bit numbers
	function int64copy(dst, src)
	{
	    dst.h = src.h;
	    dst.l = src.l;
	}

	//Right-rotates a 64-bit number by shift
	//Won't handle cases of shift>=32
	//The function revrrot() is for that
	function int64rrot(dst, x, shift)
	{
	    dst.l = (x.l >>> shift) | (x.h << (32-shift));
	    dst.h = (x.h >>> shift) | (x.l << (32-shift));
	}

	//Reverses the dwords of the source and then rotates right by shift.
	//This is equivalent to rotation by 32+shift
	function int64revrrot(dst, x, shift)
	{
	    dst.l = (x.h >>> shift) | (x.l << (32-shift));
	    dst.h = (x.l >>> shift) | (x.h << (32-shift));
	}

	//Bitwise-shifts right a 64-bit number by shift
	//Won't handle shift>=32, but it's never needed in SHA512
	function int64shr(dst, x, shift)
	{
	    dst.l = (x.l >>> shift) | (x.h << (32-shift));
	    dst.h = (x.h >>> shift);
	}

	//Adds two 64-bit numbers
	//Like the original implementation, does not rely on 32-bit operations
	function int64add(dst, x, y)
	{
	    var w0 = (x.l & 0xffff) + (y.l & 0xffff);
	    var w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16);
	    var w2 = (x.h & 0xffff) + (y.h & 0xffff) + (w1 >>> 16);
	    var w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);
	    dst.l = (w0 & 0xffff) | (w1 << 16);
	    dst.h = (w2 & 0xffff) | (w3 << 16);
	}

	//Same, except with 4 addends. Works faster than adding them one by one.
	function int64add4(dst, a, b, c, d)
	{
	    var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff);
	    var w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (w0 >>> 16);
	    var w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (w1 >>> 16);
	    var w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (w2 >>> 16);
	    dst.l = (w0 & 0xffff) | (w1 << 16);
	    dst.h = (w2 & 0xffff) | (w3 << 16);
	}

	//Same, except with 5 addends
	function int64add5(dst, a, b, c, d, e)
	{
	    var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff) + (e.l & 0xffff);
	    var w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (e.l >>> 16) + (w0 >>> 16);
	    var w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (e.h & 0xffff) + (w1 >>> 16);
	    var w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (e.h >>> 16) + (w2 >>> 16);
	    dst.l = (w0 & 0xffff) | (w1 << 16);
	    dst.h = (w2 & 0xffff) | (w3 << 16);
	}

	return {
	    "_get_hexcase_": gethexcase, "_set_hexcase_": sethexcase,
	    "_get_padchar_": getpadchar, "_set_padchar_": setpadchar,
	    "_get_outenc_": getenc, "_set_outenc_": setenc,
	    "hex": rstr2hex, b64: "rst2b64", base64: "rst2b64",
	    "array": rstr2binl, "binl": rstr2binl,
	    hex_md5: hex_md5,
	    b64_md5: b64_md5,
	    md5: any_md5,
	    hex_hmac_md5: hex_hmac_md5,
	    b64_hmac_md5: b64_hmac_md5,
	    hmac_md5: any_hmac_md5,
	    hex_rmd160: hex_rmd160,
	    b64_rmd160: b64_rmd160,
	    rmd160: any_rmd160,
	    hex_hmac_rmd160: hex_hmac_rmd160,
	    b64_hmac_rmd160: b64_hmac_rmd160,
	    hmac_rmd160: any_hmac_rmd160,
	    hex_sha1: hex_sha1,
	    b64_sha1: b64_sha1,
	    sha1: any_sha1,
	    hex_hmac_sha1: hex_hmac_sha1,
	    b64_hmac_sha1: b64_hmac_sha1,
	    hmac_sha1: any_hmac_sha1,
	    hex_sha256: hex_sha256,
	    b64_sha256: b64_sha256,
	    sha256: any_sha256,
	    hex_hmac_sha256: hex_hmac_sha256,
	    b64_hmac_sha256: b64_hmac_sha256,
	    hmac_sha256: any_hmac_sha256,
	    hex_sha512: hex_sha512,
	    b64_sha512: b64_sha512,
	    sha512: any_sha512,
	    hex_hmac_sha512: hex_hmac_sha512,
	    b64_hmac_sha512: b64_hmac_sha512,
	    hmac_sha512: any_hmac_sha512};

    })();
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ######################### fdjt/wsn.js ###################### */

/* Copyright (C) 2011 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   It implements a method for breaking narrative HTML content
   across multiple pages, attempting to honor page break constraints,
   etc.

   Check out the 'mini manual' at the bottom of the file or read the
   code itself.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or any
   later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

   Use and redistribution (especially embedding in other CC licensed
   content) is also permitted under the terms of the Creative Commons
   "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

var WSN=(function(){

    var fdjtString=fdjt.String;
    var fdjtHash=fdjt.Hash;

    var unicode_regex=/(\p{Mark})/g;
    
    function WSN(arg,sortfn,wordfn,keepdup){
	if (arg==="") return arg;
	else if ((!(arg))&&(this instanceof WSN)) {
	    // Assume we're being used as a constructor.
	    if (sortfn) this.sortfn=sortfn;
	    if (wordfn) this.wordfn=wordfn;
	    if (keepdup) this.keepdup=keepdup;
	    return this;}
	else if (!(arg)) return arg;
	if (typeof sortfn === 'undefined') sortfn=WSN.sortfn||false;
	if (typeof wordfn === 'undefined') wordfn=WSN.wordfn||false;
	if (typeof keepdup === 'undefined') keepdup=WSN.keepdup||false;
	if (typeof arg === 'string') {
	    var norm=
		((unicode_regex)?
		 (arg.toLowerCase().replace(unicode_regex,"")):
		 (arg.toLowerCase()));
	    if (norm.search(/\S/)>0)
		norm=norm.slice(norm.search(/\S/));
	    var words=norm.split(/\W*\s+\W*/g);
	    var nwords=words.length;
	    if (nwords===0) return "";
	    else words[0]=words[0].replace(/^\W+/,"");
	    if (nwords>1)
		words[nwords-1]=words[nwords-1].replace(/\W+$/,"");
	    if (wordfn) {
		if (typeof wordfn === 'number') {
		    var nwords=[];
		    var i=0; var lim=words.length;
		    while (i<lim) {
			var word=words[i++];
			if (word.length>wordfn) nwords.push(word);}
		    if (nwords.length) words=nwords;}
		else if (wordfn.call) {
		    var nwords=[];
		    var i=0; var lim=words.length;
		    while (i<lim) {
			var nword=wordfn(words[i++]);
			if (nword) nwords.push(nword);
			i++;}
		    if (nwords.length) words=nwords;}
		else  {
		    var nwords=[];
		    var i=0; var lim=words.length;
		    while (i<lim) {
			var word=words[i++];
			var nword=wordfn[word];
			if (nword==="") {}
			else if ((!(nword))||(typeof nword !== 'string'))
			    nwords.push(word);
			else nwords.push(nword);}
		    if (nwords.length) words=nwords;}}
	    var sorter=sortfn;
	    // By default, use lensort
	    // But if you're passed nativesort, just
	    //  pass false to sort()
	    if (sortfn===true) sorter=lensort;
	    else if (sortfn===nativesort) sorter=false;
	    else {}
	    if ((sortfn)&&(keepdup))
		return words.sort(sorter).join(" ");
	    else if (sortfn)
		return dedupfn(words.sort(sorter)).join(" ");
	    else return words.join(" ");}
	else if (!(arg.nodeType))
	    throw new Exception("bad arg to WSN");
	else if (arg.nodeType===3)
	    return WSN(arg.nodeValue);
	else if (arg.nodeType===1)
	    return WSN(textify(arg));
	else throw new Exception("bad arg to WSN");}
    
    function dedupfn(arr){
	var i=0; var lim=arr.length; var last=false;
	if (lim<2) return arr;
	else while (i<lim) {
	    if ((last)&&(arr[i]===last)) return dodedup(arr);
	    else last=arr[i++];}
	return arr;}
    function dodedup(arr){
	var last=arr[0]; var result=[last];
	var i=1; var lim=arr.length;
	while (i<lim) 
	    if (arr[i]===last) i++;
	    else result.push(last=arr[i++]);
	return result;}
    
    function lensort(x,y){
	var xl=x.length, yl=y.length;
	if (xl===yl) {
	    if (x>y) return -1;
	    else if (x<y) return 1;
	    else return 0;}
	else if (xl>yl) return -1;
	else return 1;}
    WSN.lensort=lensort;
    function nativesort(x,y){
	if (x>y) return -1;
	else if (x<y) return 1;
	else return 0;}
    WSN.nativesort=nativesort;

    function textify(arg,text){
	if (!(arg.nodeType)) return text||"";
	else if (arg.nodeType===3)
	    if (text) return text+arg.nodeValue; else return arg.nodeValue;
	else if (arg.nodeType===1) {
	    var children=arg.childNodes;
	    var style=((window.getComputedStyle)?
		       (window.getComputedStyle(arg)):
		       {position: 'static',display: 'block'});
	    if (style.position!=='static') return text||"";
	    if (style.display!=='inline')
		text="\n"+(text||"");
	    else if (!(text)) text="";
	    var i=0; var lim=children.length;
	    while (i<lim) {
		var child=children[i++];
		if (child.nodeType===3) text=text+child.nodeValue;
		else if (child.nodeType===1) text=textify(child,text);
		else {}}
	    return text;}
	else if (text) return text;
	else return "";}
    WSN.prototype.textify=WSN.textify=textify;

    function fuddle(arg,sortfn){return WSN(arg,sortfn||lensort);}
    WSN.fuddle=fuddle;

    function md5ID(arg){
	var wsn=WSN.apply(null,arguments);
	if (WSN.md5) return WSN.md5(wsn);
	else if ((fdjtHash)&&(fdjtHash.hex_md5))
	    return fdjtHash.hex_md5(wsn);
	else throw new Exception("No MD5 implementation");}
    WSN.md5ID=md5ID;
    
    function sha1ID(arg){
	var wsn=WSN.apply(null,arguments);
	if (WSN.sha1) return WSN.md5(wsn);
	else if ((fdjtHash)&&(fdjtHash.hex_sha1))
	    return fdjtHash.hex_sha1(wsn);
	else throw new Exception("No MD5 implementation");}
    WSN.sha1ID=sha1ID;

    function Hash(arg,hashfn,sortfn,wordfn,keepdups){
	if (typeof hashfn === 'undefined') hashfn=WSN.hashfn||false;
	if (typeof sortfn === 'undefined') sortfn=WSN.sortfn||false;
	if (typeof wordfn === 'undefined') wordfn=WSN.wordfn||false;
	if (typeof keepdup === 'undefined') keepdup=WSN.keepdup||false;
	var wsn=WSN(arg,sortfn,wordfn,keepdups);
	return ((hashfn)?(hashfn(wsn)):(wsn));}
    WSN.Hash=Hash;
    WSN.prototype.Hash=function(arg){
	return Hash(arg,this.hashfn||WSN.hashfn||false,
		    this.sortfn||WSN.sortfn||false,
		    this.wordfn||WSN.wordfn||false,
		    this.keepdup||WSN.keepdup||false);}

    function Map(nodes,hashfn,sortfn,wordfn,keepdups){
	if (typeof hashfn === 'undefined') hashfn=WSN.hashfn||false;
	if (typeof sortfn === 'undefined') sortfn=WSN.sortfn||false;
	if (typeof wordfn === 'undefined') wordfn=WSN.wordfn||false;
	if (typeof keepdup === 'undefined') keepdup=WSN.keepdup||false;
	var map={};
	var i=0; var lim=nodes.length;
	while (i<lim) {
	    var node=nodes[i++];
	    var wsn=WSN(node,sortfn,wordfn,keepdups);
	    var id=((hashfn)?(hashfn(wsn)):(wsn));
	    map[id]=node;}
	return map;}
    WSN.Map=Map;
    WSN.prototype.Map=function(arg){
	return Map(arg,this.hashfn||WSN.hashfn||false,
		   this.sortfn||WSN.sortfn||false,
		   this.wordfn||WSN.wordfn||false,
		   this.keepdup||WSN.keepdup||false);}
    
    function MapMD5(nodes,sortfn,wordfn,keepdups){
	var hashfn=WSN.md5||((fdjtHash)&&(fdjtHash.hex_md5));
	return Map(nodes,hashfn,sortfn,wordfn,keepdups);}
    function MapSHA1(nodes,sortfn,wordfn,keepdups){
	var hashfn=WSN.sha1||((fdjtHash)&&(fdjtHash.hex_sha1));
	return Map(nodes,hashfn,sortfn,wordfn,keepdups);}

    WSN.md5=((fdjtHash)&&(fdjtHash.hex_md5));
    WSN.sha1=((fdjtHash)&&(fdjtHash.hex_sha1));

    try {
	if (("A\u0300".search(unicode_regex))<0)
	    unicode_regex=false;}
    catch (ex) {
	unicode_regexes=false;}
    
    return WSN;})();

fdjt.WSN=WSN;


/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/ui.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}
if (!(fdjt.UI)) fdjt.UI={};
if (!(fdjt.UI.CoHi)) fdjt.UI.CoHi={classname: "cohi"};
if (!(fdjt.UI.AutoPrompt)) fdjt.UI.AutoPrompt={};
if (!(fdjt.UI.InputHelp)) fdjt.UI.InputHelp={};
if (!(fdjt.UI.Ellipsis)) fdjt.UI.Ellipsis={};
if (!(fdjt.UI.Expansion)) fdjt.UI.Expansion={};
if (!(fdjt.UI.Collapsible)) fdjt.UI.Collapsible={};
if (!(fdjt.UI.Tabs)) fdjt.UI.Tabs={};
if (!(fdjt.UI.MultiText)) fdjt.UI.MultiText={};
if (!(fdjt.UI.Reticle)) fdjt.UI.Reticle={};
if (!(fdjt.UI.FocusBlock)) fdjt.UI.FocusBlock={};


/* Co-highlighting */

/* When the mouse moves over a named element, the 'cohi' class is added to
   all elements with the same name. */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var highlights={};
    function highlight(namearg,classname_arg){
        var classname=((classname_arg) || (fdjtUI.CoHi.classname));
        var newname=(namearg.name)||(namearg);
        var cur=highlights[classname];
        if (cur===newname) return;
        if (cur) {
            var drop=document.getElementsByName(cur);
            var i=0, n=drop.length;
            while (i<n) fdjtDOM.dropClass(drop[i++],classname);}
        highlights[classname]=newname||false;
        if (newname) {
            var elts=document.getElementsByName(newname);
            var n=elts.length, i=0;
            while (i<n) fdjtDOM.addClass(elts[i++],classname);}}
    
    fdjtUI.CoHi.onmouseover=function cohi_onmouseover(evt,classname_arg){
        var target=fdjtDOM.T(evt);
        while (target)
            if ((target.tagName==='INPUT') || (target.tagName==='TEXTAREA') ||
                ((target.tagName==='A') && (target.href)))
                return;
        else if (target.name) break;  
        else target=target.parentNode;
        if (!(target)) return;
        highlight(target.name,classname_arg);};
    fdjtUI.CoHi.onmouseout=function cohi_onmouseout(evt,classname_arg){
        var target=fdjtDOM.T(evt);
        highlight(false,((classname_arg) || (fdjtUI.CoHi.classname)));};
})();


/* Text highlighting */

fdjt.UI.Highlight=(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var highlight_class="fdjthighlight";
    var hasClass=fdjtDOM.hasClass;
    var hasParent=fdjtDOM.getParent;

    function textnode(s){
        return document.createTextNode(s);}

    function clear_highlights(node,hclass){
        var h=fdjtDOM.getChildren(
            node||document.body,"."+(hclass||highlight_class));
        h=fdjtDOM.toArray(h);
        var i=0 , lim=h.length;
        while (i<lim) {
            var hnode=h[i++];
            if (hnode.firstChild)
                fdjtDOM.replace(hnode,hnode.firstChild);}}
    function highlight_node(node,hclass,htitle){
        if (!(hclass)) hclass=highlight_class;
        if (hasClass(node,hclass)) return node;
        var hispan=fdjtDOM("span."+hclass);
        if (htitle) hispan.title=htitle;
        fdjtDOM.replace(node,hispan);
        hispan.appendChild(node);}
    function highlight_text(text,hclass,htitle){
        var tnode=fdjtDOM("span."+(hclass||highlight_class),text);
        if (htitle) tnode.title=htitle;
        return tnode;}
    function highlight_node_range(node,start,end,hclass,htitle){
        var stringval=node.nodeValue;
        var parent=node.parentNode;
        if ((end===false)||(typeof end === 'undefined'))
            end=stringval.length;
        if (start===end) return;
        var beginning=((start>0)&&(textnode(stringval.slice(0,start))));
        var middle=highlight_text(stringval.slice(start,end),hclass,htitle);
        var ending=((end<stringval.length)&&
                    (textnode(stringval.slice(end))));
        if ((beginning)&&(ending)) {
            parent.replaceChild(ending,node);
            parent.insertBefore(middle,ending);
            parent.insertBefore(beginning,middle);}
        else if (beginning) {
            parent.replaceChild(middle,node);
            parent.insertBefore(beginning,middle);}
        else if (ending) {
            parent.replaceChild(ending,node);
            parent.insertBefore(middle,ending);}
        else parent.replaceChild(middle,node);
        return middle;}
    function highlight_range(range,hclass,htitle){
        range=fdjtDOM.refineRange(range);
        var starts_in=range.startContainer;
        var ends_in=range.endContainer;
        if (starts_in===ends_in)
            return [highlight_node_range(
                starts_in,range.startOffset,range.endOffset,
                hclass,htitle)];
        else {
            var highlights=[];
            var scan=starts_in;
            while ((scan)&&(!(scan.nextSibling)))
                scan=scan.parentNode;
            scan=scan.nextSibling;
            while (scan) {
                if (scan===ends_in) break;
                else if (hasParent(ends_in,scan))
                    scan=scan.firstChild;
                else {
                    highlights.push(highlight_node(scan,hclass,htitle));
                    while ((scan)&&(!(scan.nextSibling)))
                        scan=scan.parentNode;
                    scan=scan.nextSibling;}}
            // Do the ends
            highlights.push(
                highlight_node_range(
                    starts_in,range.startOffset,false,hclass,htitle));
            highlights.push(
                highlight_node_range(ends_in,0,range.endOffset,hclass,htitle));
            return highlights;}}

    highlight_range.clear=clear_highlights;
    highlight_range.highlight=highlight_range;
    return highlight_range;})();



/* CheckSpans:
   Text regions which include a checkbox where clicking toggles the checkbox. */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var toggleClass=fdjtDOM.toggleClass;
    var getParent=fdjtDOM.getParent;
    var getChildren=fdjtDOM.getChildren;
    var getChild=fdjtDOM.getChild;

    function CheckSpan(spec,varname,val,checked){
        var input=fdjtDOM.Input('input[type=checkbox]',varname,val);
        var span=fdjtDOM(spec||"span.checkspan",input);
        if (checked) {
            input.checked=true;
            fdjtDOM.addClass(span,"ischecked");}
        else input.checked=false;
        if (arguments.length>4) 
            fdjtDOM.appendArray(span,arguments,4);
        return span;}
    fdjtUI.CheckSpan=CheckSpan;

    function checkable(elt){
        return (elt.nodeType===1)&&
            (elt.tagName==='INPUT')&&
            ((elt.type=='checkbox')||(elt.type=='radio'));}
    function getcheckable(elt){
        if (checkable(elt)) return elt;
        var cb=getParent(elt,checkable);
        if (cb) return cb;
        cb=getChildren(elt,'input');
        if (cb.length) {
            var i=0; var lim=cb.length;
            while (i<lim)
                if (checkable(cb[i])) return cb[i]; else i++;
            return false;}
        else return false}

    function checkspan_set(target,checked) {
        if (typeof target === 'string') target=fdjtID(target);
        else if (target.length) {
            var i=0, lim=target.length;
            while (i<lim) checkspan_set(target[i++],checked);
            return;}
        if ((!(target))||(!(target.nodeType))) return;
        var checkspan=((hasClass(target,"checkspan"))?(target):
                       (getParent(target,".checkspan")));
        if (!(checkspan)) return false;
        var checkbox=((checkable(target))&&(target))||
            (getcheckable(target))||
            (getcheckable(checkspan));
        if (!(checkbox)) return false;
        if (hasClass(checkspan,"isdisabled")) {
            if (checkbox.disabled) return false;
            else dropClass(checkspan,"isdisabled");}
        else if (checkbox.disabled) {
            addClass(checkspan,"isdisabled");
            return false;}
        var ischecked=hasClass(checkspan,"ischecked");
        var changed=false; var unchecked=[];
        if (typeof checked === 'undefined') checked=ischecked;
        if (checkbox.checked!==checked) {
            checkbox.checked=checked; changed=true;}
        // If the checkspan is inconsistent, the checkbox was probably
        // just changed
        else if (ischecked!==checkbox.checked) changed=true;
        else {}
        // We change this anyway, just in case there's been a glitch
        if (checked) addClass(checkspan,"ischecked");
        else dropClass(checkspan,"ischecked");
        if ((changed)&&(checkbox.type==='radio')) {
            var form=checkbox.form;
            var name=checkbox.name;
            var tosync=getChildren(form,'input');
            var i=0; var lim=tosync.length;
            while (i<lim) {
                var input=tosync[i++];
                if (input===checkbox) continue;
                else if ((input.type==='radio')&&
                         (input.name===name)) {
                    var cspan=getParent(input,".checkspan");
                    if (cspan===checkspan) continue;
                    else if (hasClass(cspan,"ischecked"))
                        if (!(input.checked)) unchecked.push(input);}
                else {}}}
        if (changed) {
            var evt=document.createEvent("HTMLEvents");
            evt.initEvent("change",false,true);
            checkbox.dispatchEvent(evt);}
        if (unchecked.length) {
            var i=0, lim=unchecked.length;
            while (i<lim) {
                var uncheck=unchecked[i++];
                var altspan=getParent(uncheck,".checkspan");
                dropClass(altspan,"ischecked");
                var evt=document.createEvent("HTMLEvents");
                evt.initEvent("change",false,true);
                input.dispatchEvent(evt);}}}
    fdjtUI.CheckSpan.set=checkspan_set;

    function checkspan_onclick(evt) {
        evt=evt||event;
        var target=evt.target||evt.srcTarget;
        if ((target.tagName==='TEXTAREA')||
            (target.tagName==='SELECT')||
            (target.tagName==='OPTION')||
            ((target.tagName==='INPUT')&&
             (!((target.type==='checkbox')||
                (target.type==='radio')))))
            return;
        var anchor=((target.tagName==='A')?(target):
                    (getParent(target,'A')));
        if ((anchor)&&(anchor.href)) return;
        var checkspan=getParent(target,".checkspan");
        if (!(checkspan)) return;
        var checked=hasClass(checkspan,"ischecked");
        checkspan_set(target,(!(checked)));
        return false;}
    fdjtUI.CheckSpan.onclick=checkspan_onclick;    

    function changed(evt) {
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if ((target.type==='radio')||(target.type==='checkbox')) {
            var checkspan=getParent(target,'.checkspan');
            if (checkspan)
                ((target.checked)?(addClass):(dropClass))(
                    checkspan,"ischecked");}
        if (target.type==='radio') {
            var form=target.form;
            var others=document.getElementsByName(target.name);
            var i=0, lim=others.length;
            while (i<lim) {
                var other=others[i++];
                if (other===target) continue;
                else if (other.form!==form) continue;
                else if (other.type !== 'radio') continue;
                var ocs=fdjtDOM.getParent(other,'.checkspan');
                dropClass(ocs,"ischecked");}}}
    fdjtUI.CheckSpan.changed=changed;

    function initCheckspans(){
        var checkspans=fdjt.$(".checkspan");
        var i=0, lim=checkspans.length;
        while (i<lim) {
            var checkspan=checkspans[i++];
            var inputs=fdjtDOM.getInputs(checkspan);
            var j=0, jlim=inputs.length;
            while (j<jlim) {
                var input=inputs[j++];
                if ((input.type==='radio')||(input.type==='checkspan')) {
                    if (input.checked) addClass(checkspan,"ischecked");
                    if (input.disabled) addClass(checkspan,"isdisabled");
                    break;}}}}
    fdjtUI.CheckSpan.initCheckspans=initCheckspans;

    fdjt.addInit(initCheckspans,"CheckSpans",false);

})();


/* Progress boxes */

fdjt.UI.ProgressBar=(function(){
    var fdjtDOM=fdjt.DOM;
    function ProgressBar(arg){
        if (typeof arg==='undefined')
            arg=fdjtDOM("div.fdjtprogress",
                        fdjtDOM("div.indicator"),fdjtDOM("div.message"));
        else if (typeof arg==='string')
            arg=fdjtDOM("div.fdjtprogress",
                        fdjtDOM("HR"),fdjtDOM("div.message",arg));
        this.dom=arg;
        return this;}

    function setProgress(pb,progress,total){
        if (typeof pb==='string')
            pb=document.getElementById(pb);
        if (typeof total==='number')
            progress=100*(progress/total);
        var dom=((pb.dom)||(pb));
        var rule=fdjtDOM.getChildren(dom,"div.indicator")[0];
        rule.style.width=progress+"%";}
    function setMessage(pb){
        if (typeof pb==='string')
            pb=document.getElementById(pb);
        var dom=((pb.dom)||(pb));
        var oldmsg=fdjtDOM.getChildren(dom,".message")[0];
        var newmsg=fdjtDOM("div.message");
        fdjtDOM.appendArray(newmsg,fdjtDOM.Array(arguments,1));
        dom.replaceChild(newmsg,oldmsg);}
    
    ProgressBar.setProgress=setProgress;
    ProgressBar.setMessage=setMessage;
    ProgressBar.prototype.setProgress=function(progress,total){
        setProgress(this.dom,progress,total);};
    ProgressBar.prototype.setMessage=function(val){
        var dom=this.dom;
        var oldmsg=fdjtDOM.getChildren(dom,".message")[0];
        var newmsg=fdjtDOM("div.message");
        fdjtDOM.appendArray(newmsg,fdjtDOM.Array(arguments));
        dom.replaceChild(newmsg,oldmsg);};

    return ProgressBar;})();


/* Automatic help display on focus */

(function(){

    var fdjtString=fdjt.String;
    var fdjtDOM=fdjt.DOM;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;

    function show_help_onfocus(evt){
        var target=fdjtDOM.T(evt);
        while (target)
            if ((target.nodeType==1) &&
                ((target.tagName === 'INPUT') ||
                 (target.tagName === 'TEXTAREA')) &&
                (target.getAttribute('helptext'))) {
                var helptext=fdjtID(target.getAttribute('helptext'));
                if (helptext) fdjtDOM.addClass(helptext,"showhelp");
                return;}
        else target=target.parentNode;}
    function autoprompt_onfocus(evt){
        evt=evt||event||null;
        var elt=fdjtDOM.T(evt);
        if ((elt) && (hasClass(elt,'isempty'))) {
            elt.value=''; dropClass(elt,'isempty');}
        show_help_onfocus(evt);}

    function hide_help_onblur(evt){
        var target=fdjtDOM.T(evt);
        while (target)
            if ((target.nodeType==1) &&
                ((target.tagName === 'INPUT') || (target.tagName === 'TEXTAREA')) &&
                (target.getAttribute('HELPTEXT'))) {
                var helptext=fdjtID(target.getAttribute('HELPTEXT'));
                if (helptext) dropClass(helptext,"showhelp");
                return;}
        else target=target.parentNode;}
    function autoprompt_onblur(evt){
        var elt=fdjtDOM.T(evt);
        if (elt.value==='') {
            addClass(elt,'isempty');
            var prompt=(elt.prompt)||(elt.getAttribute('prompt'))||(elt.title);
            if (prompt) elt.value=prompt;}
        else dropClass(elt,'isempty');
        hide_help_onblur(evt);}
    
    // Removes autoprompt text from empty fields
    function autoprompt_cleanup(form) {
        var elements=fdjtDOM.getChildren(form,".isempty");
        if (elements) {
            var i=0; var lim=elements.length;
            while (i<elements.length) elements[i++].value="";}}
    function autoprompt_onsubmit(evt) {
        var form=fdjtDOM.T(evt);
        autoprompt_cleanup(form);}

    var isEmpty=fdjtString.isEmpty;
    // Adds autoprompt handlers to autoprompt classes
    function autoprompt_setup(arg,nohandlers) {
        var forms=
            ((arg.tagName==="FORM")?[arg]:
             (fdjtDOM.getChildren(arg||document.body,"FORM")));
        var i=0; var lim=forms.length;
        while (i<lim) {
            var form=forms[i++];
            var inputs=fdjtDOM.getChildren
            (form,"INPUT.autoprompt,TEXTAREA.autoprompt");
            if (inputs.length) {
                var j=0; var jlim=inputs.length;
                while (j<jlim) {
                    var input=inputs[j++];
                    input.blur();
                    if (isEmpty(input.value)) {
                        addClass(input,"isempty");
                        var prompt=(input.prompt)||
                            (input.getAttribute('prompt'))||(input.title);
                        if (prompt) input.value=prompt;}
                    if (!(nohandlers)) {
                        fdjtDOM.addListener(input,"focus",autoprompt_onfocus);
                        fdjtDOM.addListener(input,"blur",autoprompt_onblur);}}
                if (!(nohandlers))
                    fdjtDOM.addListener(form,"submit",autoprompt_onsubmit);}}}
    
    fdjt.UI.AutoPrompt.setup=autoprompt_setup;
    fdjt.UI.AutoPrompt.onfocus=autoprompt_onfocus;
    fdjt.UI.AutoPrompt.onblur=autoprompt_onblur;
    fdjt.UI.AutoPrompt.onsubmit=autoprompt_onsubmit;
    fdjt.UI.AutoPrompt.cleanup=autoprompt_cleanup;
    fdjt.UI.InputHelp.onfocus=show_help_onfocus;
    fdjt.UI.InputHelp.onblur=hide_help_onblur;})();



/* Focus blocks */

(function(){

    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var getParent=fdjtDOM.getParent;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;

    var blur_timeout=false;
    var blur_target=false;

    function focusblock_onfocus(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var block=getParent(target,".focusblock");
        if (block) {
            if (blur_target===block) {
                clearTimeout(blur_timeout);
                blur_target=false; blue_timeout=false;}
            addClass(block,'fdjtfocus');}}
    function focusblock_onblur(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var block=getParent(target,".focusblock");
        if (block) {
            blur_target=block;
            blur_timeout=setTimeout(function(){
                dropClass(block,'fdjtfocus');
                blur_target=false; blur_timeout=false;},
                                    2000);}}

    fdjt.UI.FocusBlock.onfocus=focusblock_onfocus;
    fdjt.UI.FocusBlock.onblur=focusblock_onblur;})();

/* Text input boxes which create checkspans on enter. */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    function multitext_keypress(evt,sepch){
        evt=(evt)||(event);
        var ch=evt.charCode;
        var target=fdjtUI.T(evt);
        if (typeof sepch === 'string') sepch=sepch.charCodeAt(0);
        if ((ch!==13)||((sepch)&&(sepch!=ch))) return;
        fdjtUI.cancel(evt);
        var checkspec=target.getAttribute("data-checkspec")||"div.checkspan";
        var checkbox=
            fdjtDOM.Input("[type=checkbox]",target.name,target.value);
        var checkelt=fdjtDOM(checkspec,checkbox,target.value);
        checkbox.checked=true;
        fdjtDOM.addClass(checkelt,"ischecked");
        fdjtDOM(target.parentNode," ",checkelt);
        target.value='';}
    fdjtUI.MultiText.keypress=multitext_keypress;})();


/* Tabs */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    
    function tab_onclick(evt,shownclass){
        var elt=fdjtUI.T(evt);
        if (!(shownclass)) {
            shownclass=
                fdjtDOM.findAttrib(elt,"shownclass","http://fdjt.org/")||
                "fdjtshown";}
        if (elt) {
            var content_id=false;
            while (elt.parentNode) {
                if (content_id=fdjtDOM.getAttrib(elt,"contentid")) break;
                else elt=elt.parentNode;}
            if (!(content_id)) return;
            var content=document.getElementById(content_id);
            var parent=fdjtDOM.getParent(elt,".tabs")||elt.parentNode;
            var sibs=fdjtDOM.getChildren(parent,".tab")||parent.childNodes;
            if (content===null) {
                fdjtLog("No content for "+content_id);
                return;}
            var i=0; while (i<sibs.length) {
                var node=sibs[i++]; var cid;
                if ((node.nodeType===1) &&
                    (cid=fdjtDOM.getAttrib(node,"contentid"))) {
                    if (!(cid)) continue;
                    var cdoc=document.getElementById(cid);
                    if (node===elt) {}
                    else if (hasClass(node,shownclass)) {
                        dropClass(node,shownclass);
                        if (cdoc) dropClass(cdoc,shownclass);}}}
            if (hasClass(elt,shownclass)) {
                dropClass(elt,shownclass);
                dropClass(content,shownclass);}
            else {
                addClass(elt,shownclass);
                addClass(content,shownclass);}
            var tabstate=fdjtDOM.findAttrib(elt,'tabstate');
            if (!(tabstate)) {}
            else if (tabstate==='#') {
                var scrollstate={};
                fdjtUI.scrollSave(scrollstate);
                document.location.hash=tabstate+content_id;
                fdjtUI.scrollRestore(scrollstate);}
            else fdjtState.setCookie(tabstate,content_id);
            // This lets forms pass tab information along
            return false;}}
    fdjtUI.Tabs.click=tab_onclick;
    
    function select_tab(tabbar,contentid,shownclass){
        if (!(shownclass)) {
            shownclass=
                fdjtDOM.findAttrib(tabbar,"shownclass","http://fdjt.org/")||
                "fdjtshown";}
        var tabseen=false;
        var tabs=fdjtDOM.getChildren(tabbar,".tab");
        var i=0; while (i<tabs.length) {
            var tab=tabs[i++];
            if ((tab.getAttribute("contentid"))===contentid) {
                addClass(tab,shownclass); tabseen=true;}
            else if (hasClass(tab,shownclass)) {
                dropClass(tab,shownclass);
                var cid=fdjtDOM.getAttrib(tab,"contentid");
                var content=(cid)&&fdjtID(cid);
                if (!(content))
                    fdjtWarn("No reference for tab content %o",cid);
                else dropClass(content,shownclass);}
            else dropClass(tab,shownclass);}
        if (fdjtID(contentid)) {
            if (tabseen) addClass(contentid,shownclass);
            else fdjtLog.warn("a tab for %s was not found in %o",
                              contentid,tabbar);}
        else fdjtLog.warn("No reference for tab content %o",contentid);}
    fdjtUI.Tabs.selectTab=select_tab;
    
    function setupTabs(elt){
        if (!(elt)) elt=fdjtDOM.$(".tabs[tabstate]");
        else if (typeof elt === 'string') elt=fdjtID(elt);
        if ((!(elt))||(!(elt.getAttribute("tabstate")))) return;
        var tabstate=elt.getAttribute("tabstate");
        var content_id=false;
        if (tabstate==='#') {
            content_id=document.location.hash;
            if (content_id[0]==='#') content_id=content_id.slice(1);
            var content=((content_id)&&(fdjtID(content_id)));
            if (!(content)) return;
            var ss={}; fdjtUI.scrollSave(ss);
            window.scrollTo(0,0);
            if (!(fdjtDOM.isVisible(content)))
                fdjtUI.scrollRestore(ss);}
        else content_id=fdjtState.getQuery(tabstate)||
            fdjtState.getCookie(tabstate);
        if (!(content_id)) return;
        if (content_id[0]==='#') content_id=content_id.slice(1);
        if (content_id) select_tab(elt,content_id);}
    fdjtUI.Tabs.setup=setupTabs;
    
    function selected_tab(tabbar){
        var tabs=fdjtDOM.getChildren(tabbar,".tab");
        var i=0; while (i<tabs.length) {
            var tab=tabs[i++];
            if (hasClass(tag,"shown"))
                return tag.getAttribute("contentid");}
        return false;}
    fdjtUI.Tabs.getSelected=selected_tab;}());



/* Collapse/Expand */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

   fdjtUI.Expansion.toggle=function(evt,spec,exspec){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var wrapper=fdjtDOM.getParent(target,spec||".fdjtexpands");
        if (wrapper) fdjtDOM.toggleClass(wrapper,exspec||"fdjtexpanded");};
    fdjtUI.Expansion.onclick=fdjtUI.Expansion.toggle;

    fdjtUI.Collapsible.click=function(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (fdjtUI.isDefaultClickable(target)) return;
        var wrapper=fdjtDOM.getParent(target,".collapsible");
        if (wrapper) {
            fdjtUI.cancel(evt);
            fdjtDOM.toggleClass(wrapper,"expanded");};};

    fdjtUI.Collapsible.focus=function(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var wrapper=fdjtDOM.getParent(target,".collapsible");
        if (wrapper) {
            fdjtDOM.toggleClass(wrapper,"expanded");};};})();


/* Temporary Scrolling */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var saved_scroll=false;
    var use_native_scroll=false;
    var preview_elt=false;

    function scroll_discard(ss){
        if (ss) {
            ss.scrollX=false; ss.scrollY=false;}
        else saved_scroll=false;}

    function scroll_save(ss){
        if (ss) {
            ss.scrollX=window.scrollX; ss.scrollY=window.scrollY;}
        else {
            if (!(saved_scroll)) saved_scroll={};
            saved_scroll.scrollX=window.scrollX;
            saved_scroll.scrollY=window.scrollY;}}
    
    function scroll_offset(wleft,eleft,eright,wright){
        var result;
        if ((eleft>wleft) && (eright<wright)) return wleft;
        else if ((eright-eleft)<(wright-wleft)) 
            return eleft-Math.floor(((wright-wleft)-(eright-eleft))/2);
        else return eleft;}

    function scroll_into_view(elt,topedge){
        if ((topedge!==0) && (!topedge) && (fdjtDOM.isVisible(elt)))
            return;
        else if ((use_native_scroll) && (elt.scrollIntoView)) {
            elt.scrollIntoView(top);
            if ((topedge!==0) && (!topedge) && (fdjtDOM.isVisible(elt,true)))
                return;}
        else {
            var top = elt.offsetTop;
            var left = elt.offsetLeft;
            var width = elt.offsetWidth;
            var height = elt.offsetHeight;
            var winx=(window.pageXOffset||document.documentElement.scrollLeft||0);
            var winy=(window.pageYOffset||document.documentElement.scrollTop||0);
            var winxedge=winx+(document.documentElement.clientWidth);
            var winyedge=winy+(document.documentElement.clientHeight);
            
            while(elt.offsetParent) {
                elt = elt.offsetParent;
                top += elt.offsetTop;
                left += elt.offsetLeft;}
            
            var targetx=scroll_offset(winx,left,left+width,winxedge);
            var targety=
                (((topedge)||(topedge===0)) ?
                 ((typeof topedge === "number") ? (top+topedge) : (top)) :
                 (scroll_offset(winy,top,top+height,winyedge)));
            
            var vh=fdjtDOM.viewHeight();
            var x=0; var y;
            var y_target=top+(height/3);
            if ((2*(height/3))<((vh/2)-50))
                y=y_target-vh/2;
            else if ((height)<(vh-100))
                y=top-(50+(height/2));
            else y=top-50;

            window.scrollTo(x,y);}}

    fdjtUI.scrollTo=function(target,id,context,discard,topedge){
        scroll_discard(discard);
        if (id) document.location.hash=id;
        if (context) {
            setTimeout(function() {
                scroll_into_view(context,topedge);
                if (!(fdjtDOM.isVisible(target))) {
                    scroll_into_view(target,topedge);}},
                       100);}
        else setTimeout(function() {scroll_into_view(target,topedge);},100);};

    function scroll_preview(target,context,delta){
        /* Stop the current preview */
        if (!(target)) {
            stop_preview(); return;}
        /* Already previewing */
        if (target===preview_elt) return;
        if (!(saved_scroll)) scroll_save();
        if (typeof target === 'number')
            window.scrollTo(((typeof context === 'number')&&(context))||0,target);
        else scroll_into_view(target,delta);
        preview_elt=target;}

    function scroll_restore(ss){
        if (preview_elt) {
            preview_elt=false;}
        if ((ss) && (typeof ss.scrollX === "number")) {
            // fdjtLog("Restoring scroll to %d,%d",ss.scrollX,ss.scrollY);    
            window.scrollTo(ss.scrollX,ss.scrollY);
            return true;}
        else if ((saved_scroll) &&
                 ((typeof saved_scroll.scrollY === "number") ||
                  (typeof saved_scroll.scrollX === "number"))) {
            // fdjtLog("Restoring scroll to %o",_fdjt_saved_scroll);
            window.scrollTo(saved_scroll.scrollX,saved_scroll.scrollY);
            saved_scroll=false;
            return true;}
        else return false;}

    function stop_preview(){
        fdjtDOM.dropClass(document.body,"preview");
        if ((preview_elt) && (preview_elt.className))
            fdjtDOM.dropClass(preview_elt,"previewing");
        preview_elt=false;}

    fdjtUI.scrollSave=scroll_save;
    fdjtUI.scrollRestore=scroll_restore;
    fdjtUI.scrollIntoView=scroll_into_view;
    fdjtUI.scrollPreview=scroll_preview;
    fdjtUI.scrollRestore=scroll_restore;}());


/* Smart (DOM-aware) scrolling */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var getGeometry=fdjtDOM.getGeometry;
    var getDisplay=fdjtDOM.getDisplay;
    var getStyle=fdjtDOM.getStyle;

    function smartScroll(win,off,content){
        if (typeof content==='undefined') content=win;
        if (off<=0) {win.scrollTop=0; return;}
        else {
            var block=findBreak(content,off,content);
            if (!(block)) {win.scrollTop=off; return;}
            var geom=getGeometry(block,content||win);
            if ((geom-top-off)<(win.offsetTop/4))
                win.scrollTop=geom.top;
            else win.scrollTop=off;}}
    function findBreak(node,off,container){
        var style=getStyle(node);
        var display=style.display;
        if ((display==='block')||(display==='table-row')||
            (display==='list-item')||(display==='preformatted')) {
            var geom=getGeometry(node,container);
            if (geom.top>off) return node;
            else if (geom.bottom>off) {
                if (style.pageBreakInside==='avoid')
                    return node;
                var children=node.childNodes;
                var i=0, lim=children.length;
                while (i<lim)  {
                    var child=children[i++];
                    var bk=((child.nodeType===1)&&
                            (findBreak(child,off,container)));
                    if (bk) return bk;}
                return node;}
            else return false;}
        else return false;}

    fdjtUI.smartScroll=smartScroll;})();


/* Delays */

(function(){
    var fdjtUI=fdjt.UI;

    var timeouts={};
    
    fdjt.UI.Delay=function(interval,name,fcn){
        window.setTimeout(fcn,interval);};
    fdjt.UI.Delayed=function(fcn,interval){
        if (!(interval)) interval=25;
        window.setTimeout(fcn,interval);};})();

/* Triggering submit events */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    function dosubmit(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var form=fdjtDOM.getParent(target,"FORM");
        var submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent('submit',false,true);
        form.dispatchEvent(submit_event);
        form.submit();}
    fdjtUI.dosubmit=dosubmit;

    function forceSubmit(form){
        var submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent('submit',false,true);
        form.dispatchEvent(submit_event);}
    fdjtUI.forceSubmit=forceSubmit;

    function submitOnEnter(evt){
        if ((evt.keyCode===13)||(evt.charCode===13)) {
            fdjtUI.cancel(evt);
            dosubmit(evt);}}
    fdjtUI.submitOnEnter=submitOnEnter;}());

/* Looking for vertical box overflow */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var getGeometry=fdjtDOM.getGeometry;
    var getInsideBounds=fdjtDOM.getInsideBounds;
    function checkOverflow(node){
        var geom=getGeometry(node);
        var inside=getInsideBounds(node);
        if (inside.bottom>geom.bottom) addClass(node,"overflow");
        else dropClass(node,"overflow");}
    fdjtUI.Overflow=checkOverflow;}());


/* Reticle based functions */

(function() {
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    var getGeometry=fdjtDOM.getGeometry;
    var vreticle=false;
    var hreticle=false;
    function setXY(x,y){
        if  (vreticle) (vreticle).style.left=x+'px';
        if  (hreticle) (hreticle).style.top=y+'px';}
    function setupReticle(){
        if (!(vreticle)) {
            vreticle=fdjtDOM("div.reticle.vertical#VRETICLE"," ")
            fdjtDOM.prepend(document.body,vreticle);}
        if (!(hreticle)) {
            hreticle=fdjtDOM("div.reticle.horizontal#HRETICLE"," ")
            fdjtDOM.prepend(document.body,hreticle);}
        fdjtDOM.addListener(document,"mousemove",mousemove);
        fdjtDOM.addListener(document,"click",doflash);
        fdjtUI.Reticle.live=true;}
    
    function doflash(evt){flash();}

    function mousemove(evt){
        var target=fdjtUI.T(evt);
        var x=evt.clientX, y=evt.clientY;
        var geom=getGeometry(target);
        /*
        fdjtLog("mousemove cx=%d,cy=%d,sx=%d,sy=%d t=%o geom=%j",
                evt.clientX,evt.clientY,evt.screenX,evt.screenY,
                target,geom);
        */
        setXY(evt.clientX,evt.clientY);}
    
    var highlighted=false;
    
    function highlight(flag){
        if (typeof flag === 'undefined') flag=(!(higlighted));
        if (flag) {
            if (vreticle) fdjtDOM.addClass(vreticle,"highlight");
            if (hreticle) fdjtDOM.addClass(hreticle,"highlight");
            highlighted=true;}
        else {
            if (vreticle) fdjtDOM.dropClass(vreticle,"highlight");
            if (hreticle) fdjtDOM.dropClass(hreticle,"highlight");
            highlighted=false;}}
    
    function flash(howlong){
        if (typeof howlong === 'undefined') howlong=1500;
        if (highlighted) return;
        else {
            highlight(true);
            setTimeout(function(){highlight(false);},howlong);}}

    fdjtUI.Reticle.setup=setupReticle;
    fdjtUI.Reticle.highlight=highlight;
    fdjtUI.Reticle.flash=flash;
    fdjtUI.Reticle.onmousemove=mousemove;
    fdjtUI.Reticle.setXY=setXY;
    fdjtUI.Reticle.live=false;})();


/* File uploader affirmation handling */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;

    fdjtUI.uploadSpecified=function(evt){
        evt=evt||event;
        var parent=fdjtDOM.getParent(fdjtUI.T(evt),'.fileuploader');
        if (parent) fdjtDOM.addClass(parent,'inuse');};})();


/* Image swapping */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    function ImageSwap(img,interval){
        if (typeof img==='string') img=fdjtID(img);
        if (!(img)) return false;
        if (!(interval))
            interval=((img.getAttribute('data-interval'))?
                      (parseInt((img.getAttribute('data-interval')))):
                      (ImageSwap.interval));
        if (!(img.getAttribute("data-images"))) {
            img.setAttribute("data-images",img.src);}
        if (!(img.defaultsrc)) img.defaultsrc=img.src;
        var images=(img.getAttribute('data-images')).split(';');
        if (images.length===0) return false;
        else if (images.length===1) {
            img.src=images[0];
            return false;}
        var counter=0;
        return setInterval(function(){
            img.src=images[counter++];
            if (counter>=images.length) counter=0;},
                           interval);}
            
    ImageSwap.reset=function(img){
        if (img.defaultsrc) img.src=img.defaultsrc;};
    ImageSwap.interval=1000;

    fdjtUI.ImageSwap=ImageSwap;})();


/* Miscellaneous event-related functions */

(function(){
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    
    fdjtUI.T=function(evt) {
        evt=evt||event; return (evt.target)||(evt.srcElement);};

    fdjtUI.noDefault=function(evt){
        evt=evt||event;
        if (evt.preventDefault) evt.preventDefault();
        else evt.returnValue=false;
        return false;};

    fdjtUI.isClickable=function(target){
        if (target instanceof Event) target=fdjtUI.T(target);
        while (target) {
            if (((target.tagName==='A')&&(target.href))||
                (target.tagName==="INPUT") ||
                (target.tagName==="TEXTAREA") ||
                (target.tagName==="SELECT") ||
                (target.tagName==="OPTION") ||
                (hasClass(target,"checkspan"))||
                (hasClass(target,"clickable"))||
                (hasClass(target,"isclickable")))
                return true;
            else if (target.onclick)
              return true;
            else target=target.parentNode;}
        return false;};

    fdjtUI.isDefaultClickable=function(target){
        if (target instanceof Event) target=fdjtUI.T(target);
        while (target) {
            if (((target.tagName==='A')&&(target.href))||
                (target.tagName==="INPUT") ||
                (target.tagName==="TEXTAREA") ||
                (target.tagName==="SELECT") ||
                (target.tagName==="OPTION") ||
                (hasClass(target,"isclickable")))
                return true;
            else target=target.parentNode;}
        return false;};

    fdjtUI.cancel=function(evt){
        evt=evt||event;
        if (evt.preventDefault) evt.preventDefault();
        else evt.returnValue=false;
        evt.cancelBubble=true;
        return false;};
    fdjtUI.noBubble=function(evt){
        evt=evt||event;
        evt.cancelBubble=true;};

    function submitEvent(arg){
        var form=((arg.nodeType)?(arg):(fdjtUI.T(arg)));
        while (form) {
            if (form.tagName==='FORM') break;
            else form=form.parentNode;}
        if (!(form)) return;
        var submit_evt = document.createEvent("HTMLEvents");
        submit_evt.initEvent("submit", true, true);
        form.dispatchEvent(submit_evt);
        return;}
    fdjtUI.submitEvent=submitEvent;

    function focusEvent(arg){
        var elt=((arg.nodeType)?(arg):(fdjtUI.T(arg)));
        var focus_evt = document.createEvent("HTMLEvents");
        focus_evt.initEvent("focus", true, true);
        elt.dispatchEvent(focus_evt);
        return;}
    fdjtUI.focusEvent=focusEvent;

    function disableForm(form){
        if (typeof form === 'string') form=fdjtID(form);
        if (!(form)) return;
        var elements=fdjtDOM.getChildren(
            form,"button,input,optgroup,option,select,textarea");
        var i=0; var lim=elements.length;
        while (i<lim) elements[i++].disabled=true;}
    fdjtUI.disableForm=disableForm;
    
}());

/* Ellipsis */

(function(){
    var fdjtString=fdjt.String;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;


    var ellipsize=fdjtString.ellipsize;
    var getParent=fdjtDOM.getParent;
    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var toggleClass=fdjtDOM.toggleClass;

    function Ellipsis(spec,string,lim,thresh,handler){
        var content=ellipsize(string,lim,thresh||0.2);
        var split=(!(typeof content === "string"));
        var len=string.length;
        if (!(handler)) handler=toggle;
        if ((typeof content === "string")&&(content.length===len)) {
            // No elision, just return the string
            if (spec) return fdjtDOM(spec,string);
            else return document.createTextNode(string);}
        var before=((split)?(content[0]):(content));
        var after=((split)?(content[1]):(""));
        var clen=before.length+after.length;
        var pct=Math.round((100*(clen))/len);
        if (spec) addClass(elt,"ellipsis");
        var remaining=((split)?
                       (string.slice(before.length,len-after.length)):
                       (string.slice(before.length)));
        var elided=fdjtDOM("span.elided",remaining);
        var elision=fdjtDOM(
            "span.elision",fdjtString(" …←%d%%→…",100-pct));
        var delision=fdjtDOM(
            "span.delision",fdjtString(" →…%d%%…← ",100-pct));
        elision.title="show elided text";
        delision.title="hide elided text";
        elision.onclick=handler; delision.onclick=handler;
        var elt=fdjtDOM(spec||"span.ellipsis",
                        before," ",elision,delision,elided," ",after);
        if (spec) addClass(elt,"ellipsis");
        elt.title=fdjtString.stdspace(string);
        return elt;}
    fdjtUI.Ellipsis=Ellipsis;

    function expand(node){
        if (typeof node === 'string') node=fdjtID(node);
        var ellipsis=getParent(node,".ellipsis");
        addClass(ellipsis,"expanded");
        dropClass(ellipsis,"compact");}
    Ellipsis.expand=expand;

    function contract(node){
        if (typeof node === 'string') node=fdjtID(node);
        var ellipsis=getParent(node,".ellipsis");
        addClass(ellipsis,"compact");
        dropClass(ellipsis,"expanded");}
    Ellipsis.contract=contract;
    
    function toggle(arg){
        var evt=false;
        if (!(arg)) {
            evt=event||false;
            if (evt) arg=fdjtUI.T(evt);
            else return;}
        else if (typeof arg === 'string') arg=fdjtID(arg);
        else if (arg.nodeType) {}
        else {
            evt=arg;
            arg=fdjtUI.T(arg);}
        var ellipsis=getParent(arg,".ellipsis");
        if (!(ellipsis)) return;
        if (evt) fdjtUI.cancel(evt);
        if (hasClass(ellipsis,"expanded")) {
            addClass(ellipsis,"compact");
            dropClass(ellipsis,"expanded");}
        else {
            addClass(ellipsis,"expanded");
            dropClass(ellipsis,"compact");}}
    Ellipsis.toggle=toggle;
    
})();

/* Non-blocking alerts and messages */

(function(){
    
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtID=fdjt.ID;

    var alert_ticker=false; var close_ticker=false;
    var max_z=false;

    var countdown_serial=1; var countdown_tickers={};

    function remove_alert(evt){
        evt=evt||event;
        var target=((evt)?((evt.nodeType)?(evt):(fdjtUI.T(evt))):(fdjtID("FDJTALERT")));
        var box=fdjtDOM.getParent(target,".fdjtalert");
        if (box) {
            clear_countdown(box);
            fdjtDOM.remove(box);}}
    
    function close_alert(evt){
        evt=evt||event;
        var target=((evt)?((evt.nodeType)?(evt):(fdjtUI.T(evt))):(fdjtID("FDJTALERT")));
        if ((evt)&&(!(evt.nodeType))) fdjtUI.cancel(evt);
        var box=fdjtDOM.getParent(target,".fdjtalert");
        if (box) {
            clear_countdown(box);
            if ((fdjtDOM.transitionEnd)&&
                (!(fdjtDOM.hasClass(box,"closing")))) {
                fdjtDOM.addListener(box,fdjtDOM.transitionEnd,function(){
                    fdjtDOM.remove(box);});
                fdjtDOM.addClass(box,"closing");}
            else fdjtDOM.remove(box);}}

    function clear_countdown(box){
        var countdown=fdjtDOM.getChild(box,".countdown");
        if (countdown) {
            var ticker=countdown_tickers[countdown.id];
            delete countdown_tickers[countdown.id];
            if (ticker) clearInterval(ticker);
            fdjtDOM.remove(countdown);}}

    function close_alert_handler(evt){
        evt=evt||event;
        fdjtUI.cancel(evt);
        close_alert(evt);}

    function stop_countdown_onclick(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var box=fdjtDOM.getParent(target,".fdjtalert");
        clear_countdown(box);
        box.style[fdjtDOM.transitionDelay]="";
        box.style[fdjtDOM.transitionDuration]="";
        fdjtDOM.dropClass(box,"countdown");
        fdjtDOM.dropClass(box,"closing");
        fdjtUI.cancel(evt);}

    function alertBox(){
        var close_button=fdjtDOM.Image(
            "https://beingmeta.s3.amazonaws.com/static/g/codex/redx40x40.png",
            "closebutton","Close");
        var countdown=fdjtDOM("div.countdown","Closing…");
        close_button.onclick=close_alert_handler;
        close_button.title="click to close";
        countdown.id="FDJTCOUNTDOWN"+(countdown_serial++);
        return fdjtDOM("div.fdjtalert",countdown,close_button,arguments);}
    fdjtUI.alertBox=alertBox;

    function alertfn(){
        var curbox=fdjtID("FDJTALERT");
        if (curbox) {
            curbox.id="";
            fdjtDOM.dropClass(curbox,"closing");
            remove_alert(curbox);}
        var box=alertBox(arguments);
        box.id="FDJTALERT"; fdjtDOM.prepend(document.body,box);
        return box;}
    fdjtUI.alert=alertfn;

    function setCountdown(box,timeout,whendone){
        var countdown=fdjtDOM.getChild(box,".countdown");
        countdown.innerHTML="Closing in "+timeout+"…";
        var n=timeout;
        box.style[fdjtDOM.transitionDelay]=(n/2)+"s";
        box.style[fdjtDOM.transitionDuration]=(n/2)+"s";
        var ticker=setInterval(function(){
            if (n<=0) {
                clearInterval(ticker); ticker=false;
                delete countdown_tickers[countdown.id];
                if (whendone) whendone();
                fdjtDOM.remove(box);}
            else countdown.innerHTML="Closing in "+(n--)+"…";},
                               1000);
        countdown_tickers[countdown.id]=ticker;
        fdjtDOM.addListener(box,"click",stop_countdown_onclick);
        setTimeout(function(){fdjtDOM.addClass(box,"closing");},10);
        return box;}
    fdjtUI.setCountdown=setCountdown;

    function alertFor(timeout){
        var curbox=fdjtID("FDJTALERT");
        if (curbox) {
            curbox.id="";
            fdjtDOM.dropClass(curbox,"closing");
            remove_alert(curbox);}
        var box=alertBox(fdjtDOM.slice(arguments,1));
        box.id="FDJTALERT"; fdjtDOM.prepend(document.body,box);
        setCountdown(box,timeout);
        return box;}
    fdjtUI.alertFor=alertFor;

    function makeChoice(spec,close_choice,i){
        var dom=spec.dom||
            ((spec.label)&&(fdjtDOM("button",spec.label)))||
            fdjtDOM("button","Choice "+i);
        dom.onmousedown=fdjtUI.cancel;
        dom.onmouseup=fdjtUI.cancel;
	dom.tabIndex=i;
        dom.onclick=function(evt){
            evt=evt||event;
            if (spec.handler) spec.handler();
            fdjtUI.cancel(evt);
            close_choice();};
        return dom;}

    function choose(spec){
	var box=false; var selection=-1, buttons=[];
        var close_button=false, countdown=false, timer=false;
        function close_choice(){
            var i=0, lim=buttons.length;
            while (i<lim) {
                buttons[i].onclick=null;
                buttons[i].onmousedown=null;
                buttons[i].onmouseup=null;
		i++;}
            if (close_button) close_button.onclick=null;
            if (box) box.onclick=null;
	    if (box) box.onkeydown=null;
            if (box) remove_alert(box);}
        if (typeof spec === "function") 
            choices=[{label: "Cancel"},
                     {label: "OK",handler: spec,isdefault: true}];
        else if (spec.constructor === Array) choices=spec;
        else if (spec.choices) choices=spec.choices;
        else if ((spec.label)&&(spec.handler)) 
            choices=[{label: "Cancel"},spec];
        else if (spec.handler) 
            choices=[{label: "Cancel"},
                     {label: "OK", handler: spec.handler,
                     isdefault: spec.isdefault}];
        else if (choices.length) choices=spec;
        else {
            fdjtLog.warn("Bad spec %o to fdjtUI.choose");
            return;}
        var i=0, lim=choices.length;
        while (i<lim) {
	    var choice=choices[i];
	    var button=makeChoice(choice,close_choice,i);
	    buttons.push(button);
	    if ((selection<0)&&(choice.isdefault)) {
		button.setAttribute("autofocus","autofocus");
		selection=i;}
	    i++;}
	if (selection<0) selection=0; 
        box=alertBox(fdjtDOM("div.message",fdjtDOM.slice(arguments,1)),
                     fdjtDOM("div.choices",buttons));
        close_button=fdjtDOM.getChild(box,".closebutton");
        if (spec.cancel) close_button.onclick=close_choice;
        else fdjtDOM.remove(close_button);

        var cancel=(spec.cancel)||false;

        // For accessibility, handle tab/enter
	box.onkeydown=function(evt){
	    evt=evt||event;
	    var kc=evt.keyCode;
	    if (kc===9) {
                if (evt.shiftKey) selection--; else selection++;
                if (selection<0) selection=buttons.length-1;
		else if (selection>=buttons.length) selection=0;
		buttons[selection].focus();
                fdjtUI.cancel(evt);}
	    else if (kc===13) {
		if (choices[selection].handler)
		    (choices[selection].handler)();
		close_choice();
                fdjtUI.cancel(evt);}
            else if ((cancel)&&(kc===27)) {
                close_choice();
                fdjtUI.cancel(evt);}};
        fdjtDOM.addClass(box,"fdjtconfirm"); box.id="FDJTALERT";
        fdjtDOM.prepend(document.body,box);
        if (spec.timeout)
            setCountdown(box,spec.timeout,function(){
                if (choices[selection].handler) choices[selection].handler();});
	buttons[selection].focus();}
    fdjtUI.choose=choose;

})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/taphold.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.

   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}
if (!(fdjt.UI)) fdjt.UI={};

fdjt.UI.TapHold=(function(){
    var fdjtString=fdjt.DOM;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtET=fdjt.ET;

    var trace_taps=false;
    var debug_taps=false;
    var window_setup=false;
    
    var touched=false;
    var pressed=false;
    var tap_target=false;
    var th_target=false;
    var th_targets=[];
    var th_timer=false;
    var mouse_down=false;
    var holdkey_down=false;
    var start_x=false;
    var start_y=false;
    var start_t=false;
    var touch_x=false;
    var touch_y=false;
    
    var getGeometry=fdjtDOM.getGeometry;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var hasClass=fdjtDOM.hasClass;
    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var reticle=fdjtUI.Reticle;
    var cancel=fdjtUI.cancel;
    // We disable the default behavior, which is usually selection
    // (where we do tap and hold)
    var noDefault=fdjtUI.noDefault;
    var dontcancel=function(evt){};

    var keynums={
        shift: 16, alt: 18, control: 17, meta: 224,
        os: 91, altgr: 225, fn: -1,
        numlock: 144, capslock: 20, scrolllock: 145};
    var keynames={};
    for (var akeyname in keynums)
        if (keynums.hasOwnProperty(akeyname)) {
            var akeynum=keynums[akeyname];
            if ((typeof akeynum === 'number')&&(akeynum>0))
                keynames[akeynum]=akeyname;}
    
    function getTarget(evt){
        if ((evt.changedTouches)&&((evt.changedTouches.length)))
            return evt.changedTouches[evt.changedTouches.length-1].target;
        else return fdjtUI.T(evt);}

    function getClientX(evt){
        if (typeof evt.clientX === "number") return evt.clientX;
        var touches=((evt.changedTouches)&&(evt.changedTouches.length)&&
                     (evt.changedTouches))||
            ((evt.touches)&&(evt.touches.length)&&(evt.touches));
        if (touches) return touches[0].screenX;
        else return false;}
    function getClientY(evt){
        if (typeof evt.clientY === "number") return evt.clientY;
        var touches=((evt.changedTouches)&&(evt.changedTouches.length)&&
                     (evt.changedTouches))||
            ((evt.touches)&&(evt.touches.length)&&(evt.touches));
        if (touches) return touches[0].screenY;
        else return false;}
    
    function dispatchEvent(target,etype,orig){
        if (!(target)) target=fdjtUI.T(orig);
        var evt = document.createEvent("UIEvent");
        var event_arg=
            (((orig)&&(orig.touches)&&(orig.touches.length))||
             ((orig)&&(orig.button))||
             0);
        evt.initUIEvent(etype, true, true,window,event_arg);
        evt.clientX=touch_x; evt.clientY=touch_y;
        if (trace_taps)
            fdjtLog("TapHold/Synthesizing %s on %o @%d,%d from %o",
                    etype,target,touch_x,touch_y,orig||"scratch");
	if (holdkey_down) evt.holdKey=true;
        if (orig) {
	    cancel(orig);
            if (!(hasParent(target,document.body)))
		target=fdjtUI.T(orig);}
        if ((!target)||(!(hasParent(target,document.body))))
            target=document.elementFromPoint(touch_x,touch_y);
        target.dispatchEvent(evt);}
    
    function tap_handler(evt){
        var target=fdjtUI.T(evt);
        var msgelt=fdjtID("TAPHOLDMESSAGE");
        if (msgelt) msgelt.innerHTML=fdjtString("Tapped %o",target);
        fdjtLog("Tapped %o",target);}
    function hold_handler(evt){
        var target=fdjtUI.T(evt);
        var msgelt=fdjtID("TAPHOLDMESSAGE");
        if (msgelt) msgelt.innerHTML=fdjtString("Held %o",target);
        fdjtLog("Held %o",target);}
    function release_handler(evt){
        var target=fdjtUI.T(evt);
        var msgelt=fdjtID("TAPHOLDMESSAGE");
        if (msgelt) msgelt.innerHTML=fdjtString("Released %o",target);
        fdjtLog("Released %o",target);}

    function tapped(target,evt){return dispatchEvent(target,"tap",evt);}
    function held(target,evt){return dispatchEvent(target,"hold",evt);}
    function released(target,evt){return dispatchEvent(target,"release",evt);}
    function slipped(target,evt){return dispatchEvent(target,"slip",evt);}
    function taptapped(target,evt){
        return dispatchEvent(target,"taptap",evt);}
    function tapheld(target,evt){
        return dispatchEvent(target,"taphold",evt);}
    
    function startpress(evt,holdthresh){
        evt=evt||event;
        if ((tap_target)&&(th_timer)) {
            clearTimeout(th_timer); th_timer=false;}
        if ((touched)||(pressed)||(th_timer)) return;
        else if (!(th_target)) return;
        else {touched=th_target; pressed=false;}
        if (trace_taps) fdjtLog("TapHold/startpress %o",evt);
        if (reticle.live) reticle.highlight(true);
        noDefault(evt);
        th_timer=setTimeout((function(){
            if (trace_taps) fdjtLog("TapHold/startpress/timeout %o",evt);
            if (th_targets.length>0) {
                var touched=th_targets;
                var i=0, lim=touched.length;
                while (i<lim) {
                    var elt=touched[i++];
                    if ((i===lim)&&(elt===th_target)) break;
                    held(elt); slipped(elt);}}
            pressed=th_target; th_targets=[];
            if (tap_target) {tapheld(th_target,evt); tap_target=false;}
            else held(th_target,evt);
            th_timer=false;
            touched=false;}),
                            holdthresh||TapHold.interval||100);}
    function endpress(evt,taptapthresh){
        if ((!(pressed))&&(!(touched))&&(!(th_timer))) return;
        if (trace_taps)
            fdjtLog("TapHold/endpress %o t=%o p=%o tch=%o tm=%o ttt=%o/%o",
                    evt,th_target,pressed,touched,th_timer,
                    tap_target,taptapthresh||false);
        if (th_timer) {
            clearTimeout(th_timer); th_timer=false;
            if (reticle.live) 
                setTimeout(function(){reticle.highlight(false);},1500);
            if (th_target===touched) {
                if ((tap_target)&&(tap_target===th_target)) {
                    tap_target=false;
                    taptapped(th_target,evt);}
                else if (taptapthresh) {
                    tap_target=th_target;
                    if (trace_taps)
                        fdjtLog("TapHold/taptap waiting %d on %o",
                                taptapthresh,tap_target);
                    th_timer=setTimeout(function(){
                        var tmp=tap_target; tap_target=false;
                        th_timer=false;
                        if (trace_taps)
                            fdjtLog("TapHold/singletap on %o",tmp);
                        tapped(tmp,evt);},
                                        taptapthresh);}
                else tapped(th_target,evt);}
            else slipped(th_target,evt);}
        else if (pressed) released(pressed,evt);
        if (reticle.live) reticle.highlight(false);
        if (evt) noDefault(evt);
        start_x=false; start_y=false; start_t=false;
        touched=false; pressed=false;
        th_targets=[];}
    function abortpress(evt){
        if (trace_taps)
            fdjtLog("TapHold/abort %o: th=%o t=%o p=%o",
                    evt,th_target,touched,pressed);
        if (th_timer) {
            clearTimeout(th_timer); th_timer=false;}
        else if (pressed) {released(pressed,evt);}
        if (reticle.live) reticle.highlight(false);
        touched=false; pressed=false; tap_target=false;
        th_targets=[];}
    function taphold_mouseout(evt){
        var to=evt.toElement||evt.relatedTarget;
        if ((pressed)&&(!(hasParent(to,".fdjtaphold")))) {
            if (!(holdkey_down)) {
                released(pressed,evt);
                touched=pressed=th_target=false;}
            mouse_down=false;}}

    function taphold_outer_move(evt){
        evt=evt||event;
        var target;
        if (evt.touches) {
            var x=evt.clientX||getClientX(evt);
            var y=evt.clientY||getClientY(evt);
            target=document.elementFromPoint(x,y);}
        else target=fdjtUI.T(evt);
        // If it doesn't have a parent, it's been removed from the DOM,
        //  so we can't tell if it *was* in a .fdjtaphold region, so we punt.
        if ((!(target))||(!(target.parentNode))) return;
        if ((pressed)&&(!(hasParent(target,".fdjtaphold")))) {
            if ((pressed)&&(trace_taps))
                fdjtLog("TapHold/slipout %o: t=%o p=%o",
                        evt,th_target,pressed);
            released(pressed);
            touched=pressed=th_target=false; th_targets=[];
            mouse_down=false;
            return;}}
    function taphold_outer_down(evt){mouse_down=true;};
    function taphold_outer_up(evt){mouse_down=false;};
    
    function taphold_move(evt,movethresh){
        evt=evt||event;
        var target;
        // if (target!==th_target) fdjtLog("New target %o",target);
        touch_x=evt.clientX||getClientX(evt);
        touch_y=evt.clientY||getClientY(evt);
        // If touched is false, the tap/hold was aborted somehow
        if (!(touched)) return;
        if (evt.touches)
            target=document.elementFromPoint(touch_x,touch_y);
        else target=fdjtUI.T(evt);
        if (trace_taps)
            fdjtLog("TapHold/move %o %o -> %o s=%d,%d t=%d,%d, thresh=%o",
                    evt,th_target,target,start_x,start_y,
                    touch_x,touch_y,movethresh);
        if ((movethresh)&&(start_x)&&(start_y)&&(th_timer)) {
            var distance=(Math.abs(touch_x-start_x))+
                (Math.abs(touch_y-start_y));
            if (distance>movethresh) {
                if (trace_taps)
                    fdjtLog("TapHold/move/cancel s=%d,%d t=%d,%d d=%d thresh=%o",
                            start_x,start_y,touch_x,touch_y,
                            distance,movethresh);
                abortpress(evt);
                touched=th_timer=pressed=th_target=false;
                th_targets=[];
                return;}
            else if (trace_taps)
                fdjtLog("TapHold/moved s=%d,%d t=%d,%d d=%d thresh=%o",
                        start_x,start_y,touch_x,touch_y,
                        distance,movethresh);}
        if (hasParent(target,".fdjtaphold")) th_target=target;
        if ((evt.touches)&&(touched)&&(!(pressed))&&
            (th_targets[th_targets.length-1]!==th_target))
            th_targets.push(th_target);
        if ((evt.touches)&&(evt.touches.length)&&(evt.touches.length>1))
            return;
        else {
            if (reticle.live) reticle.onmousemove(evt);
            if (th_target) noDefault(evt);}
        if ((pressed)&&(th_target!==pressed)) {
            slipped(pressed);
            pressed=th_target;
            held(pressed);}}
    
    function taphold_keydown(evt){
        evt=evt||event;
        if (!(TapHold.holdkey)) return;
        var holdkey=TapHold.holdkey, holdkeynum, holdkeyname;
        if (!(holdkey)) return;
        else if (holdkey===true) holdkey="Shift";
        if (typeof holdkey === 'number') {
            holdkeyname=keynames[holdkey];
            holdkeynum=holdkey;}
        else if (typeof holdkey === 'string') {
            holdkeynum=keynums[holdkey.toLowerCase()];
            holdkeyname=holdkey.toLowerCase();}
        else {
            fdjtLog.warn("Invalid holdkey specification %s",holdkey);
            return;}
        if ((evt.key===holdkeyname)||
            (evt.keyCode===holdkeynum)||
            ((evt.getModifierState)&&
             (evt.getModifierState(holdkeyname)))) {
            holdkey_down=true;
            var target=fdjtUI.T(evt);
            if ((target)&&(target.tagName)&&
                ((target.tagName==='INPUT')||
                 (target.tagName==='TEXTAREA')||
                 (hasParent(target,"input,textarea"))))
                return;
            else if (!(touched)) startpress(evt);}}
    function taphold_down(evt,holdthresh){
        evt=evt||event;
        if ((evt.ctrlKey)||
            (evt.altKey)||(evt.metaKey)||
            (evt.button)||
            ((evt.which)&&(evt.which>1)))
            return;
        mouse_down=true;
        th_target=fdjtUI.T(evt); th_targets=[th_target];
        start_x=touch_x=evt.clientX||getClientX(evt);
        start_y=touch_y=evt.clientY||getClientY(evt);
        start_t=fdjtET();
        if (trace_taps)
            fdjtLog("TapHold/down %o t=%o x=%o y=%o t=%o",
                    evt,th_target,start_x,start_y,start_t);
        if ((evt.touches)&&(evt.touches.length)&&
            (evt.touches.length>1))
            return;
        if (fdjtUI.isClickable(evt)) return;
        if (!(touched)) startpress(evt,holdthresh);
        noDefault(evt);}
    function fakePress(evt,holdthresh){
        var x=start_x=touch_x=evt.clientX||getClientX(evt);
        var y=start_y=touch_y=evt.clientY||getClientY(evt);
        start_t=fdjtET();
        var target=document.elementFromPoint(x,y);
        th_target=target; th_targets=[target];
        mouse_down=true;
        if (trace_taps)
            fdjtLog("TapHold/fakePress t=%o x=%o y=%o t=%o",
                    th_target,start_x,start_y,start_t);
        startpress(evt,holdthresh);}
    
    function taphold_keyup(evt){
        evt=evt||event;
        if (!(TapHold.holdkey)) return;
        var holdkey=TapHold.holdkey, holdkeynum, holdkeyname;
        if (!(holdkey)) return;
        else if (holdkey===true) holdkey="Shift";
        if (typeof holdkey === 'number') {
            holdkeyname=keynames[holdkey];
            holdkeynum=holdkey;}
        else if (typeof holdkey === 'string') {
            holdkeynum=keynums[holdkey.toLowerCase()];
            holdkeyname=holdkey.toLowerCase();}
        else {
            fdjtLog.warn("Invalid holdkey specification %s",holdkey);
            return;}
        if ((evt.key===holdkeyname)||
            (evt.keyCode===holdkeynum)||
            ((evt.getModifierState)&&
             (evt.getModifierState(holdkeyname)))) {
            holdkey_down=false;
            if ((!(holdkey_down))&&(!(mouse_down)))
                endpress();}}
    TapHold.keyup=taphold_keyup;
    function taphold_up(evt,taptapthresh){
        evt=evt||event;
        if (!(mouse_down)) return;
        mouse_down=false;
        touch_x=evt.clientX||getClientX(evt)||touch_x;
        touch_y=evt.clientY||getClientY(evt)||touch_y;
        if (trace_taps)
            fdjtLog("TapHold/up %o tht=%o s=%o,%o,%o t=%o,%o m=%o k=%o ttt=%o",
                    evt,th_target,start_x,start_y,start_t,touch_x,touch_y,
                    mouse_down,holdkey_down,
                    taptapthresh||false);
        if ((evt.touches)&&(evt.touches.length)&&
            (evt.touches.length>1))
            return;
        if (fdjtUI.isClickable(evt)) return;
        if ((!(holdkey_down))&&(!(mouse_down))&&(touched)) {
            fdjtUI.cancel(evt);
            endpress(evt,taptapthresh);}
        else {}}

    function get_down_handler(holdthresh){
        return function(evt){
            return taphold_down(evt,holdthresh);}}

    function get_move_handler(movethresh){
        return function(evt){
            return taphold_move(evt,movethresh);}}

    function get_up_handler(taptapthresh){
        return function(evt){
            return taphold_up(evt,taptapthresh);}}

    function TapHold(elt,fortouch,holdthresh,movethresh,taptapthresh){
        if (!(elt)) {
            fdjtLog.warn("TapHold with no argument!");
            return;}
        if ((fortouch)&&(fortouch.hasOwnProperty)) {
            var opts=fortouch;
            if (opts.hasOwnProperty("touch")) fortouch=opts.touch;
            else fortouch=false;
            if (!(holdthresh)) holdthresh=opts.hold||opts.holdthresh;
            if (!(movethresh)) movethresh=opts.move||opts.movethresh;
            if (!(taptapthresh)) taptapthresh=opts.taptap||opts.taptapthresh;}
        else if (!(fortouch)) fortouch=false;
        if (typeof holdthresh !== "number")
            holdthresh=TapHold.holdthresh||300;
        if (typeof movethresh !== "number")
            movethresh=TapHold.movethresh||20;
        if (typeof movethresh !== "number") 
        if ((taptapthresh)&&(typeof taptapthresh !== "number"))
            taptapthresh=TapHold.taptapthresh||200;
        addClass(elt,"fdjtaphold");
        var mm=((movethresh)?(get_move_handler(movethresh)):(taphold_move));
        if (!(fortouch)) fdjtDOM.addListener(elt,"mousemove",mm);
        fdjtDOM.addListener(elt,"touchmove",mm);
        var md=((holdthresh)?(get_down_handler(holdthresh)):(taphold_down));
        if (!(fortouch)) fdjtDOM.addListener(elt,"mousedown",md);
        if (!(fortouch)) fdjtDOM.addListener(elt,"mouseout",taphold_mouseout);
        fdjtDOM.addListener(elt,"touchstart",md);
        var mu=((taptapthresh)?(get_up_handler(taptapthresh)):(taphold_up));
        if (!(fortouch)) fdjtDOM.addListener(elt,"mouseup",mu);
        fdjtDOM.addListener(elt,"touchend",mu);
        fdjtDOM.addListener(elt,"touchcancel",abortpress);        
        if (!(window_setup)) {
            if (!(fortouch)) {
                // fdjtDOM.addListener(document,"mouseup",taphold_outer_up);
                // fdjtDOM.addListener(document,"mousedown",taphold_outer_down);
                fdjtDOM.addListener(document,"mousemove",taphold_outer_move);}
            fdjtDOM.addListener(document,"touchmove",taphold_outer_move);
            fdjtDOM.addListener(document,"keydown",taphold_keydown);
            fdjtDOM.addListener(document,"keyup",taphold_keyup);
            window_setup=window;}
        if (debug_taps) {
            fdjtDOM.addListener(elt,"tap",tap_handler);
            fdjtDOM.addListener(elt,"hold",hold_handler);
            fdjtDOM.addListener(elt,"release",release_handler);}}
    TapHold.mouseup=TapHold.up=taphold_up;
    TapHold.mousedown=TapHold.down=taphold_down;
    TapHold.keydown=taphold_keydown;
    TapHold.holdkey=16;
    TapHold.fakePress=fakePress;

    TapHold.traceTaps=function(flag){
        if (typeof flag === "undefined")
            trace_taps=(!(trace_taps));
        else trace_taps=flag;};

    TapHold.ispressed=function(){
        return (pressed);}

    return TapHold;})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/textselect.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.

   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.UI.Selecting=
    (function(){
        var fdjtString=fdjt.DOM;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        
        var dropClass=fdjtDOM.dropClass;
        var addClass=fdjtDOM.addClass;
        var getStyle=fdjtDOM.getStyle;
        var getParent=fdjtDOM.getParent;

        function position(elt,arr){
            if (arr.indexOf) return arr.indexOf(elt);
            else {
                var i=0, lim=arr.length;
                while (i<lim) {
                    if (arr[i]===elt) return i;
                    else i++;}
                return -1;}}

        var selectors={}; // Maps DOM ids to instances
        var serialnum=0;  // Tracks instances

        function fdjtSelecting(nodes,opts){
            if (!(this instanceof fdjtSelecting))
                return new fdjtSelecting(nodes,opts);
            else this.serial=++serialnum;
            if (typeof nodes==='string') {
                var elt=document.getElementById(nodes);
                if (!(elt)) return false;
                else this.nodes=nodes=[elt];}
            else if (nodes.nodeType) this.nodes=nodes=[nodes];
            else if (!(nodes.length)) return false;
            else this.nodes=nodes;
            var sel=this;
            var orig=this.orig=[], wrapped=this.wrapped=[];
            var words=this.words=[], wrappers=this.wrappers=[];
            var prefix=this.prefix="fdjtSel0"+this.serial;
            this.adjust=false; /* This will be 'start' or 'end' */
            selectors[prefix]=sel;
            var stripid=prefix.length+1;
            var k=0, n=nodes.length;
            while (k<n) {
                var node=nodes[k++];
                var style=getStyle(node);
                var wrapper=
                    ((style.display==='inline')?
                     (fdjtDOM("span.fdjtselecting")):
                     (fdjtDOM("div.fdjtselecting")));
                // Initialize the wrapper
                wrapper.id=prefix+"w"+k;
                wrapper.title=((opts)&&(opts.title))||
                    "Tap or hold/drag to move the ends of the text range";
                selectors[wrapper.id]=sel;
                wrappers.push(wrapper);
                addHandlers(wrapper,sel,opts);
                // Replace the node with the wrapper and then update
                // the node (replacing words with spans) while it's
                // outside of the DOM for performance.
                node.parentNode.replaceChild(wrapper,node);
                orig.push(node); wrapped.push(wrapper);
                // Actually wrap the words in spans
                wrapText(node,orig,wrapped,words,prefix,opts);
                // And put the node back into the DOM
                wrapper.appendChild(node);}
            // These track the state of the current selection
            //  for this instance
            this.start=false; this.end=false;
            this.min=-1; this.max=-1; this.n_words=0;
            this.onchange=((opts)&&(opts.onchange))||false;
            var over=false;
            // This gets the word offset for a particular target
            this.wordnum=function wordnum(target){
                var id=false;
                while ((target)&&(target.nodeType!==1))
                    target=target.parentNode;
                if ((target)&&((id=target.id))&&
                    (target.tagName==="SPAN")&&
                    (id.search(prefix)===0))
                    return parseInt(id.slice(stripid));
                else return false;};
            
            return this;}
        
        function wrapText(node,orig,wrapped,words,prefix,opts){
            if (node.nodeType===3) {
                var text=node.nodeValue;
                var sliced=text.split(/\b/), wordspans=[];
                var i=0, lim=sliced.length, count=0;
                while (i<lim) {
                    var word=sliced[i++];
                    if (word.length===0) continue;
                    else if ((word.search(/\S/)>=0)&&
                             (word.search(/\s/)>=0)) {
                        var scan=word;
                        while (scan.length) {
                            var space=scan.search(/\s/);
                            var notspace=scan.search(/\S/);
                            var split=((space<=0)?(notspace):
                                       (notspace<=0)?(space):
                                       (space<notspace)?(space):
                                       (notspace));
                            if (split<=0) split=scan.length;
                            var span=fdjtDOM(
                                "span.fdjtword",scan.slice(0,split));
                            span.id=prefix+"_"+(words.length);
                            words.push(span);
                            wordspans.push(span);
                            scan=scan.slice(split);}}
                    else {
                        var span=fdjtDOM("span.fdjtword",word);
                        span.id=prefix+"_"+(words.length);
                        words.push(span);
                        wordspans.push(span);}}
                return fdjtDOM("span.fdjtselectwrap",wordspans);}
            else if (node.nodeType!==1) return node;
            else if (node.className==='fdjtselectwrap') return node;
            else if (node.nodeType===1) {
                var children=node.childNodes;
                if (!(children)) return node;
                else if (children.length===0) return node;
                else if (node.className==='fdjtselectwrap') return node;
                else {
                    var i=0, lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        var wrap=wrapText(child,orig,wrapped,words,prefix);
                        if (child!==wrap) {
                            orig.push(child);
                            wrapped.push(wrap);
                            node.replaceChild(wrap,child);}}
                    return node;}}}

        /* Selecting ranges */

        function selectWords(words,start,end){
            var i=start; while (i<=end)
                words[i++].className="fdjtselected";}
        function deselectWords(words,start,end){
            var i=start; while (i<=end)
                words[i++].className="fdjtword";}

        fdjtSelecting.prototype.setRange=function(start,end){
            if (!(start)) {
                if ((this.start)&&(this.end)) {
                    deselectWords(this.words,this.min,this.max);}
                this.start=this.end=false;
                this.min=this.max=-1;
                this.n_words=0;
                if (this.onchange) this.onchange();
                return;}
            var words=this.words;
            var min=this.wordnum(start), max=this.wordnum(end);
            if (max<min) {
                var tmp=start; start=end; end=tmp;
                tmp=min; min=max; max=tmp;}
            if (!(this.start)) {
                // First selection
                selectWords(words,min,max);
                words[max].className='fdjtselectend';
                words[min].className='fdjtselectstart';}
            else if ((this.start===start)&&(this.end===end)) return;
            else {
                // Minimize the effort for a change in selection
                var cur_min=this.wordnum(this.start);
                var cur_max=this.wordnum(this.end);
                if ((min>cur_max)||(max<cur_min)) {
                    deselectWords(words,cur_min,cur_max);
                    selectWords(words,min,max);}
                else {
                    // Overlapping, just do the difference
                    if (min<cur_min) selectWords(words,min,cur_min);
                    else if (min>cur_min) deselectWords(words,cur_min,min);
                    else {}
                    if (max>cur_max) selectWords(words,cur_max,max);
                    else if (max<cur_max) deselectWords(words,max,cur_max);
                    else {}}
                words[max].className="fdjtselectend";
                words[min].className="fdjtselectstart";}
            this.min=min; this.max=max;
            this.start=start; this.end=end;
            this.n_words=(max-min)+1;
            if (this.onchange) this.onchange();}

        /* Handler support */
        
        function overWord(word){
            var sel=false, id=false;
            while ((word)&&(word.nodeType!==1)) word=word.parentNode;
            if ((word)&&((id=word.id))&&
                (word.tagName==='SPAN')&&
                (id.search("fdjtSel")===0)) {
                var split=id.indexOf("_");
                if (split) sel=selectors[id.slice(0,split)];}
            if (!(sel)) {
                var container=word; while (container) {
                    if ((container.className)&&(container.id)&&
                        (container.className.search(/\bfdjtselecting\b/)>=0))
                        break;
                    else container=container.parentNode;}
                if (!(container)) return false;
                else sel=selectors[container.id];}
            if (!(sel)) return false;
            if (!(sel.start))
                // We could have some smarts here
                sel.setRange(word,word);
            else if (sel.start===sel.end)
                // Just one word is selected, so use word as the 'end' and
                // let setRange sort out the correct order
                sel.setRange(sel.start,word);
            else {
                var off=sel.wordnum(word);
                var start=sel.start, end=sel.end;
                // Check that you're consistent with the end you're moving
                if ((sel.adjust==='start')&&(off>sel.max)) return;
                if ((sel.adjust==='end')&&(off<sel.min)) return;
                // Figure out whether you're moving the beginning or end
                if (sel.adjust==='start') start=word;
                else if (sel.adjust==='end') end=word;
                else if (off<=sel.min) {
                    start=word; sel.setAdjust('start');}
                else if (off>=sel.max) {
                    end=word; sel.setAdjust('end');}
                // Tried this implementation and it just doesn't feel right
                else if ((off-sel.min)<((sel.max-sel.min)/2)) {
                    start=word; sel.setAdjust('start');}
                // else if ((off-sel.min)<3) start=word;
                else {end=word; sel.setAdjust('end');}
                sel.setRange(start,end);}
            return true;}

        function getSelector(word){
            var id=false;
            if ((word)&&((id=word.id))&&
                (word.tagName==='SPAN')&&
                (id.search("fdjtSel")===0)) {
                var split=id.indexOf("_");
                if (split)
                    return selectors[id.slice(0,split)]||false;
                else return false;}
            else return false;}
        fdjtSelecting.getSelector=getSelector;

        // Getting the selection text
        // This tries to be consistent with textify functions in fdjtDOM
        fdjtSelecting.prototype.setString=function(string){
            var wrappers=this.wrappers;
            var whole=((wrappers.length===1)&&(wrappers[0]));
            if (!(whole)) {
                whole=fdjtDOM("div"); 
                var i=0, lim=wrappers.length;
                while (i<lim) {
                    var wrapper=wrappers[i++];
                    whole.appendChild(wrapper.cloneNode(true));}}
            var found=fdjtDOM.findString(whole,string);
            if (!(found)) return;
            var start=found.startContainer, end=found.endContainer;
            while ((start)&&(start.nodeType!==1)) start=start.parentNode;
            while ((end)&&(end.nodeType!==1)) end=end.parentNode;
            if ((start)&&(end)&&(start.id)&&(end.id)&&
                (start.id.search(this.prefix)===0)&&
                (end.id.search(this.prefix)===0)) {
                start=document.getElementById(start.id);
                end=document.getElementById(end.id);}
            else return;
            if ((start)&&(end)) this.setRange(start,end);}

        fdjtSelecting.prototype.getString=function(start,end){
            if (!(start)) start=this.start; if (!(end)) end=this.end;
            var words=this.words; var wrappers=this.wrappers; 
            var combine=[]; var prefix=this.prefix; var wpos=-1;
            var scan=start; while (scan) {
                if (scan.nodeType===1) {
                    var style=getStyle(scan);
                    if (style.display!=='inline') combine.push("\n");}
                if ((scan.nodeType===1)&&(scan.tagName==='SPAN')&&
                    (scan.id)&&(scan.id.search(prefix)===0)) {
                    combine.push(scan.firstChild.nodeValue);
                    if (scan===end) break;}
                if ((scan.firstChild)&&(scan.firstChild.nodeType!==3))
                    scan=scan.firstChild;
                else if (scan.nextSibling) scan=scan.nextSibling;
                else {
                    while (scan) {
                        if ((wpos=position(scan,wrappers))>=0) break;
                        else if (scan.nextSibling) {
                            scan=scan.nextSibling; break;}
                        else scan=scan.parentNode;}
                    if (wpos>=0) {
                        if ((wpos+1)<wrappers.length)
                            scan=wrappers[wpos+1];}}
                if (!(scan)) break;}
            return combine.join("");}

        fdjtSelecting.prototype.getOffset=function(){
            if (!(this.start)) return false;
            var selected=this.getString();
            var preselected=this.getString(this.words[0],this.end);
            return preselected.length-selected.length;}
        
        fdjtSelecting.prototype.setAdjust=function(val){
            // fdjt.Log("setAdjust %o",val);
            if (val) {
                this.adjust=val;
                fdjt.DOM.swapClass(
                    this.nodes,/\b(fdjtadjuststart|fdjtadjustend)\b/,
                    "fdjtadjust"+val);}
            else {
                this.adjust=false;
                fdjt.DOM.dropClass(
                    this.nodes,/\b(fdjtadjuststart|fdjtadjustend)\b/);}};


        // Life span functions

        fdjtSelecting.prototype.clear=function(){
            var wrappers=this.wrappers;
            var orig=this.orig, wrapped=this.wrapped;
            var i=orig.length-1;
            while (i>=0) {
                var o=orig[i], w=wrapped[i]; i--;
                w.parentNode.replaceChild(o,w);}
            var i=0, lim=wrappers.length;
            while (i<lim) {
                var wrapper=wrappers[i++];
                delete selectors[wrapper.id];}
            delete selectors[this.prefix];
            delete this.wrapped; delete this.orig;
            delete this.wrappers; delete this.nodes;
            delete this.words; delete this.wrappers;
            delete this.start; delete this.end;};
        
        // Handlers

        function hold_handler(evt){
            evt=evt||event;
            var target=fdjtUI.T(evt);
            while ((target)&&(target.nodeType!==1)) target=target.parentNode;
            if ((target)&&(target.id)&&(target.tagName==='SPAN')&&
                (target.id.search("fdjtSel")===0))
                if (overWord(target)) fdjtUI.cancel(evt);}
        fdjtSelecting.hold_handler=hold_handler;
        fdjtSelecting.handler=hold_handler;
        function tap_handler(evt){
            evt=evt||event;
            var target=fdjtUI.T(evt);
            while ((target)&&(target.nodeType!==1)) target=target.parentNode;
            if ((target)&&(target.id)&&(target.tagName==='SPAN')&&
                (target.id.search("fdjtSel")===0)) {
                var sel=getSelector(target);
                if ((target.className==="fdjtselectstart")||
                    (target.className==="fdjtselectend")) {
                    if (sel.n_words===1) sel.setRange(false);
                    else {
                        fdjtUI.cancel(evt);
                        sel.setRange(target,target);}}
                else if (overWord(target)) fdjtUI.cancel(evt);
                if (sel) sel.adjust=false;}}
        fdjtSelecting.tap_handler=tap_handler;
        function release_handler(evt){
            evt=evt||event;
            var target=fdjtUI.T(evt);
            while ((target)&&(target.nodeType!==1)) target=target.parentNode;
            if ((target)&&(target.id)&&(target.tagName==='SPAN')&&
                (target.id.search("fdjtSel")===0)) {
                var sel=getSelector(target);
                sel.setAdjust(false);}}
        fdjtSelecting.release_handler=release_handler;
        function get_release_handler(also){
            return function(evt){release_handler(evt); also(evt);}};
        
        function addHandlers(container,sel,opts){
            var fortouch=((typeof opts.fortouch !== "undefined")?
                          (opts.fortouch):
                          (fdjtSelecting.fortouch||false));
            fdjtUI.TapHold(container,fortouch,
                           ((opts)&&(opts.holdthresh)),
                           ((opts)&&(opts.movethresh)));
            fdjtDOM.addListener(container,"tap",
                                ((opts)&&(opts.ontap))||
                                tap_handler);
            fdjtDOM.addListener(container,"hold",
                                ((opts)&&(opts.onhold))||
                                hold_handler);
            if ((opts)&&(opts.onrelease))
                fdjtDOM.addListener(
                    container,"release",
                    get_release_handler(opts.onrelease));
            else fdjtDOM.addListener(container,"release",release_handler);}

        // Return the constructor
        return fdjtSelecting;})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/scrollever.js ###################### */

/* Copyright (C) 2011-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file implements a simple version of infinite scrolling.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use, modification, and redistribution of this program is permitted
    under either the GNU General Public License (GPL) Version 2 (or
    any later version) or under the GNU Lesser General Public License
    (version 3 or later).

    These licenses may be found at www.gnu.org, particularly:
      http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
      http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}
if (!(fdjt.UI)) fdjt.UI={};

fdjt.ScrollEver=fdjt.UI.ScrollEver=(function(){
    var fdjtDOM=fdjt.DOM, fdjtID=fdjt.ID;
    var fdjtState=fdjt.State, fdjtString=fdjt.String;
    var fdjtLog=fdjt.Log;
    
    function fdjtScrollEver(spec) {
        var busy=false, timer=false;
        if (!(spec)) spec={};
        var url=spec.url||
            fdjtDOM.getLink("~{http://fdjt.org/}scrollfetch")||
            fdjtDOM.getLink("~SCROLLFETCH");
        var off=spec.off||fdjtState.getQuery("OFF")||0;
        var win=spec.win||fdjtState.getQuery("WINDOW")||
            fdjtDOM.getMeta("~{http://fdjt.org/}scrollwindow")||
            fdjtDOM.getMeta("~SCROLLWINDOW")||
            7;
        var limit=spec.limit||fdjtState.getQuery("LIMIT")||
            fdjtDOM.getMeta("~{http://fdjt.org/}scrollmax")||
            fdjtDOM.getMeta("~scrollmax")||
            7;
        var container=spec.container||
            fdjtDOM.getMeta("~{http://fdjt.org/}scrollelement")||
            fdjtDOM.getMeta("~scrollelement")||
            "FDJTSCROLLCONTAINER";
        if (typeof container === 'string') {
            if (fdjtID(container)) container=fdjtID(container);
            else {
                fdjtLog.warn("No container %s",container);
                return;}}
        var thresh=spec.thresh||
            fdjtDOM.getMeta("~{http://fdjt.org/}scrollthresh")||
            fdjtDOM.getMeta("~scrollthresh")||
            100;
        var interval=spec.interval||
            fdjtDOM.getMeta("~{http://fdjt.org/}scrollinterval")||
            fdjtDOM.getMeta("~scrollinterval")||
            500;
        if (typeof off !== 'number') off=parseInt(off);
        if (typeof win !== 'number') win=parseInt(win);
        if (typeof limit !== 'number') limit=parseInt(limit);
        if (typeof thresh !== 'number') thresh=parseInt(thresh);
        if (typeof interval !== 'number') interval=parseInt(interval);
        
        if (fdjtScrollEver.debug) {
            fdjtLog("fdjtScrollEver called: %o/%o+%o, fetch=%s",
                    off,limit,win,url);
            fdjtLog("fdjtScrollEver scrolling on %opx, checking every %ous on %o",
                    thresh,interval,container);}

        function getMoreResults(){
            if (busy) return;
            if ((!(url))||(!(container))||(off>=limit)) {
                if (timer) clearTimeout(timer);
                return;}
            else busy=true;
            var call=url.replace("-off-",fdjtString(off+win));
            var req=new XMLHttpRequest();
            req.open("GET",call,true);
            req.withCredentials=true;
            req.onreadystatechange=function () {
                if ((req.readyState == 4) && (req.status == 200)) {
                    if (fdjtScrollEver.debug)
                        fdjtLog("fdjtScrollEver getMoreResults (response)");
                    var tbl=fdjtDOM(container.tagName);
                    var htmltext=req.responseText;
                    try {tbl.innerHTML=htmltext;}
                    catch (ex) {
                        var span=document.createElement("span");
                        span.style.display='none';
                        span.innerHTML="<"+container.tagName+">"+
                            htmltext+"</"+container.tagName+">";
                        tbl=span.childNodes[0];}
                    var add=[];
                    var children=tbl.childNodes;
                    var i=0; var lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        if ((child.nodeType===1)&&(child.id)) {
                            if (document.getElementById(child.id)) {}
                            else add.push(child);}
                        else add.push(child);}
                    fdjtDOM(container,add);
                    off=off+win;
                    var iscroll=spec.iscroll||window.iscroller||false;
                    if (iscroll)
                        setTimeout(function(){iscroll.refresh();},10);
                    busy=false;}};
            if (fdjtScrollEver.debug)
                fdjtLog("fdjtScrollEver getMoreResults (call)");
            req.send(null);}

        function scrollChecker(){
            if (busy) return;
            var iscroll=spec.iscroll||window.iscroller||false;
            var page_height=(iscroll)?(iscroll.scrollerH):
                (document.documentElement.scrollHeight);
            var scroll_pos=(iscroll)?(-iscroll.y):
                (window.pageYOffset);
            if ((!(iscroll))&&(typeof scroll_pos !== 'number'))
                scroll_pos=document.documentElement.scrollTop;
            var client_height=(iscroll)?(iscroll.wrapperH):
                (document.documentElement.clientHeight);
            if (((page_height-(scroll_pos+client_height))<thresh)||
                (page_height<client_height))
                getMoreResults();}
        return (timer=setInterval(scrollChecker,interval));}
    return fdjtScrollEver;})();

// fdjtScrollEver.debug=true;

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/adjustfont.js ###################### */

/* Copyright (C) 2012-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html


   This is based on the implementation by Charlie Park described at:
   http:://charlipark.org/hatchshow/

*/

/* To do:
   add maxheight constraints
   more documentation
*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}
if (!(fdjt.UI)) fdjt.UI={}

fdjt.UI.adjustFont=
    (function(){
	function setupContainer(elt,opts){
	    var parent=elt.parentNode, container;
	    if (parent.className==="adjustfont_wrapper")
		return parent;
	    var cstyle=getStyle(elt), style=elt.style;
	    if (((cstyle)&&(cstyle.display==='block'))||
		(style.display==='block')||(elt.tagName==='div')||
		(elt.tagName==='p')||(elt.tagName[0]==='h'))
		container=document.createElement("div");
	    else container=document.createElement("span");
	    container.className="adjustfont_wrapper";
	    parent.replaceChild(container,elt);
	    container.appendChild(elt);
	    container.style.display='block';
	    // Set up CSS valures if needed
	    if (!((cstyle)&&(cstyle.display==="inline-block"))) {
		try {style.display="inline-block;"} catch (ex) {};
		if (style.display!=="inline-block") style.display='inline';}
	    var white_space_value=((opts)&&(opts.wsval))||
		(adjustFont.wsval)||"nowrap";
	    if (!((cstyle)&&
		  ((cstyle.whiteSpace==="pre")||
		   (cstyle.whiteSpace==="nowrap"))))
		style.whiteSpace=white_space_value;
	    container.style.fontSize="100%";
	    return container;}

	function parsePct(arg){
	    // To be more clever and robust, we could handle units besides
	    // pixels
	    if (!(arg)) return arg;
	    else if (typeof arg === 'number') return arg;
	    // In many cases, this just works
	    else try { return parseFloat(arg); }
	    catch (ex) {}
	    var len=arg.length;
	    if ((len>2)&&((arg.slice(len-1))=="%")) {
		try { return parseFloat(arg.slice(0,len-1)); }
		catch (ex) {return false;}}}

	function parentWidth(parent){
	    var w=parent.offsetWidth;
	    if (w>0) return w;
	    else return ((parent.parentNode)&&
			 (parentWidth(parent.parentNode)));}

	function getStyle(elt){
	    return (elt)&&(elt.nodeType===1)&&
                (elt.currentStyle||
		 ((window.getComputedStyle)&&
		  (window.getComputedStyle(elt,null))));}

	// This is the core of the algorithm, adjusting the font size to
	//  put the inner element's size just outside or inside the outer
	//  element.
	function tweakFontSize(elt,delta,container,pct,minpct,maxpct,pw){
	    var parent=container.parentNode, pw=parentWidth(parent);
	    if (!(pct)) pct=parseFloat(container.style.fontSize);
	    var curpct=pct;
	    // This is where the real scaling happens
	    var w=elt.offsetWidth, pw=parentWidth(parent);
	    if ((w<pw)&&(pct<(maxpct-delta)))
		while ((w<pw)&&(pct<=(maxpct-delta))) {
		    pct=pct+delta;
		    container.style.fontSize=(pct)+"%";
		    w=elt.offsetWidth;}
	    else if ((w>pw)&&(pct>=(minpct-delta)))
		while (w>pw) {
		    pct=pct-delta;
		    container.style.fontSize=(pct)+"%";
		    w=elt.offsetWidth;}
	    return pct;}
	
	// This is the function to adjust an element, which starts by
	// setting up the DOM as neccessary and then using tweakFontSize
	// with different deltas (10, 1 and 0.1) to zero in on a pretty
	// good value.
	function adjustFont(elt,opts){
	    var container=setupContainer(elt,opts);
	    var pct=parsePct(container.style.fontSize);
	    var unhide=((opts)&&(opts.unhide))||(adjustFont.unhide);
	    var max=((opts)&&(opts.maxpct)), min=((opts)&&(opts.minpct));
            var saved_display=elt.style.display;
            var visualized=((elt.offsetWidth===0)&&(makeVisible(elt)));
	    if (!(max)) {
		max=parsePct(elt.getAttribute("data-maxfont"));
		if (!(max)) max=adjustFont.maxpct;
		else if (opts) opts.maxpct=max;
		else {}}
	    if (!(max)) max=1000;
	    if (!(min)) {
		min=parsePct(elt.getAttribute("data-minfont"));
		if (!(min)) min=adjustFont.minpct;
		else if (opts) opts.mincpt=min;
		else {}}
	    if (!(min)) min=5;
            elt.style.display='inline-block';
	    // Tweak the font percent size at progressively finer
	    // granularities
	    pct=tweakFontSize(elt,25,container,pct,min,max);
	    pct=tweakFontSize(elt,10,container,pct,min,max);
	    pct=tweakFontSize(elt,1,container,pct,min,max);
	    var w=elt.offsetWidth, pw=parentWidth(container.parentNode);
	    // If you're over, adjust it one last time to make it fit
	    if (w>pw) pct=tweakFontSize(elt,0.1,container,pct,min,max);
            if (visualized) restoreVisibility(visualized);
            elt.style.display=saved_display;
	    if (unhide) elt.style.visibility='visible';
	    return pct;}
	
        function makeVisible(elt){
            var results=[];
            while (elt) {
                var cstyle=getStyle(elt);
                var style=elt.style
                if (!(style)) elt=elt.parentNode; 
                else if (cstyle.display==='none') {
                    var tag=elt.tagName;
                    var saved={};
                    if ((style.opacity===0)||
                        ((style.opacity)&&(style.opacity!=='')))
                        saved.opacity=style.opacity;
                    if ((style.visibility)&&(style.visibility!==''))
                        saved.visibility=style.visibility;
                    if ((style.display)&&(style.display!==''))
                        saved.display=style.display;
                    style.visibility='hidden';
                    style.opacity=0.0;
                    if ((elt.tag==="TH")||(elt.tag==="TD"))
                        style.display="table-cell";
                    else if (elt.tag==="TR")
                        style.display="table-row";
                    else if (elt.tag==="LI")
                        style.display="list-item";
                    else if (elt.tag==="TBODY")
                        style.display="table-row-group";
                    else if (elt.tag==="TABLE")
                        style.display="table";
                    else style.display="block";
                    results.push([elt,saved]);
                    elt=elt.parentNode;}
                else elt=elt.parentNode;}
            return results;}
        function restoreVisibility(elements){
            var i=0, lim=elements.length;
            while (i<lim) {
                var entry=elements[i++];
                var elt=entry[0], saved=entry[1];
                if (saved.display)
                    elt.style.display=saved.display;
                else elt.style.display='';
                if (saved.visibility)
                    elt.style.visibility=saved.visibility;
                else elt.style.visibility=''; 
                if ((saved.opacity===0)||(saved.opacity))
                    elt.style.opacity=saved.opacity;
                else elt.style.opacity='';}}
                
        
	function classes2spec(classes){
	    var specs=[]; var i=0, lim=classes.length;
	    while (i<lim) {
		var classname=classes[i++];
		if (classname[0]===".") specs.push(classname);
		else specs.push("."+classname);}
	    return specs.join(",");}

	// This handles getting the elements to adjust and makes up for
	// not being able to count on jQuery or another selector library,
	// though it does check for some of those libraries.
	function getElements(elt){
	    var results=[];
	    var classes=adjustFont.classes;
	    if (classes.length===0) return [];
	    if (!(elt)) elt=document.body;
	    if (elt.querySelectorAll) {
		var spec=classes2spec(classes);
		return elt.querySelectorAll(spec);}
	    else if (window.jQuery) {
		var spec=classes2spec(classes);
		return jQuery(spec);}
	    else if (window.fdjtDOM) {
		var spec=classes2spec(classes);
		return fdjtDOM.$(spec);}
	    else if (window.Sizzle) {
		var spec=classes2spec(classes);
		return Sizzle(spec);}
	    else if (elt.getElementsByClassName) {
		if (classes.length===1)
		    return elt.getElementsByClassName(classes[0]);
		else {
		    var j=0, jlim=classes.length;
		    while (j<jlim) {
			var classname=classes[j++];
			results=results.concat(
			    elt.getElementsByClassName(classname));}
		    return results;}}
	    else {
		var regex_string=
		    ((classes.length===1)?("\\b"+classes[0]+"\\b"):
		     ("(\\b"+classes.join("\\b)|(\\b")+"\\b)"));
		var regex=new RegExp(regex_string);
		if (elt.children) {
		    var children=elt.children;
		    var i=0, lim=children.length;
		    while (i<lim) {
			var node=children[i++];
			if ((node.nodeType===1)&&(node.className)&&
			    (node.className.search(regex)>=0))
			    results.push(node);}
		    return results;}
		else {
		    slowZoneSearch(elt,regex,results);
		    return results;}}}

	// This does a laborious search for elements whose className
	// contains the given regex.
	function slowZoneSearch(elt,regex,results){
	    if (elt.nodeType!==1) return;
	    if ((elt.className)&&(node.className.search(regex)>=0))
		results.push(node);
	    var children=elt.childNodes;
	    var i=0, lim=children.length;
	    while (i<lim) {
		var child=children[i++];
		if (child.nodeType===1) slowZoneSearch(child,regex,results);}}
	
	// This sets up a DOM tree for use with the module; it's called by
	// the onload and onresize handlers and can also be called
	// explicitly if we're adding elements to the DOM.
	function update(elt,opts){
	    if (typeof elt === 'array') {
		var i=0, lim=elt.length;
		while (i<lim) adjustFont(elt[i++],opts||false);}
	    else {
		if (!(elt)) elt=document.body;
		var elts=getElements(elt);
		var i=0, lim=elts.length;
		while (i<lim) adjustFont(elts[i++],opts||false);}}
        adjustFont.update=update;
	adjustFont.setup=update;

	function adjustfont_onresize(){update(document.body);}
	function adjustfont_onload(){update(document.body);}

	function onload(evt){
	    if (adjustFont.onload) {
		if (adjustFont.delay)
		    adjustFont.delay=adjustfont_onload;
		else adjustfont_onload();}}
	function onresize(evt){
	    if (adjustFont.onresize) {
		if (adjustFont.delay)
		    adjustFont.delay=adjustfont_onresize;
		else adjustfont_onresize();}}
	
	adjustFont.onload=true;
	adjustFont.onresize=true;
	adjustFont.classes=["adjustfont","hatchshow"];
	adjustFont.wsval="nowrap";
	adjustFont.unhide=true;
	
	if (window.addEventListener) {
	    window.addEventListener("load",onload);
	    window.addEventListener("resize",onresize);}
	else if (window.attachEvent) {
	    window.attachEvent("onload",onload);
	    window.attachEvent("onload",onresize);}
	else {}
	
	return adjustFont;
    })();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/completions.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides extended Javascript utility functions
   of various kinds.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}
if (!(fdjt.UI)) fdjt.UI={};

(function(){
    var fdjtString=fdjt.String;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    var serial=0;

    /* Constants */
    // Always set to distinguish no options from false
    var FDJT_COMPLETE_OPTIONS=1;
    // Whether the completion element is a cloud (made of spans)
    var FDJT_COMPLETE_CLOUD=2;
    // Whether to require that completion match an initial segment
    var FDJT_COMPLETE_ANYWORD=4;
    // Whether to match case in keys to completions
    var FDJT_COMPLETE_MATCHCASE=8;
    // Whether to an enter character always picks a completion
    var FDJT_COMPLETE_EAGER=16;
    // Whether the key fields may contain disjoins (e.g. (dog|friend))
    // to be accomodated in matching
    var FDJT_COMPLETE_DISJOINS=32;
    // Default options
    var default_options=FDJT_COMPLETE_OPTIONS;
    // Max number of completions to show
    var maxcomplete=50;
    // Milliseconds to wait for auto complete
    var complete_delay=100;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var getChildren=fdjtDOM.getChildren;
    var getParent=fdjtDOM.getParent;
    var getStyle=fdjtDOM.getStyle;
    var position=fdjtKB.position;

    var isEmpty=fdjtString.isEmpty;
    var hasPrefix=fdjtString.hasPrefix;
    var prefixAdd=fdjtString.prefixAdd;
    var prefixFind=fdjtString.prefixFind;
    var commonPrefix=fdjtString.commonPrefix;

    fdjtUI.FDJT_COMPLETE_OPTIONS=FDJT_COMPLETE_OPTIONS;
    fdjtUI.FDJT_COMPLETE_CLOUD=FDJT_COMPLETE_CLOUD;
    fdjtUI.FDJT_COMPLETE_ANYWORD=FDJT_COMPLETE_ANYWORD;
    fdjtUI.FDJT_COMPLETE_MATCHCASE=FDJT_COMPLETE_MATCHCASE;
    fdjtUI.FDJT_COMPLETE_EAGER=FDJT_COMPLETE_EAGER;

    function Completions(dom,input,options) {
        this.dom=dom||false; this.input=input||false;
        this.options=options||default_options;
        this.nodes=[]; this.values=[]; this.serial=++serial;
        this.cues=[]; this.displayed=[];
        this.prefixtree={strings: []};
        this.bykey={}; this.byvalue=new fdjtKB.Map();
        this.selected=false; this.selclass=false;
        if (!(options&FDJT_COMPLETE_MATCHCASE)) this.stringmap={};
        this.initialized=false;
        return this;}

    // A completion is a DOM node with a 'key' string for matching
    //  and a 'value' for using.  A completion can include *variations*
    //  (with CSS class variation) which have different key values.
    
    // The key is either stored as a DOM property, attribute, 
    function getKey(node){
        return node.key||(node.getAttribute("key"))||
            ((hasClass(node,"variation"))&&(fdjtDOM.textify(node)))||
            ((hasClass(node,"completion"))&&(completionText(node,"")));}
    Completions.getKey=getKey;
    // This gets the text of a completion node, excluding variations
    // and any fdjtdecoration(s).
    function completionText(node,sofar){
        if (node.nodeType===3) return sofar+node.nodeValue;
        else if (hasClass(node,"variation")) return sofar;
        else if (hasClass(node,"fdjtskiptext")) return sofar;
        else if ((node.nodeType===1)&&(node.childNodes)) {
            var children=node.childNodes;
            var i=0; var lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (child.nodeType===3) sofar=sofar+child.nodeValue;
                else if (child.nodeType===1)
                    sofar=completionText(child,sofar);
                else {}}
            return sofar;}
        else return sofar;}

    /* You can add a node to a completions lookup table.  We update
     * bykey and the prefix table. */
    function addNodeKey(node,keystring,ptree,bykey,anywhere){
        var keys=((anywhere)?(keystring.split(/\W/g)):[]).concat(keystring);
        var i=0; var lim=keys.length;
        while (i<lim) {
            var key=keys[i++];
            prefixAdd(ptree,key,0);
            if ((bykey[key])&&(bykey.hasOwnProperty(key)))
                bykey[key].push(node);
            else bykey[key]=new Array(node);
            bykey._count++;}}

    /* Get nodes for a completion */
    function getNodes(string,ptree,bykey,matchcase){
        var result=[]; var direct=[]; var variations=[];
        var keystring=stdspace(string);
        if (isEmpty(keystring)) return [];
        if (!(matchcase)) keystring=string.toLowerCase();
        var strings=prefixFind(ptree,keystring,0);
        var prefix=false;
        var exact=[]; var exactheads=[]; var keys=[];
        var i=0; var lim=strings.length;
        while (i<lim) {
            var string=strings[i++];
            var isexact=(string===keystring);
            if (prefix) prefix=commonPrefix(prefix,string);
            else prefix=string;
            var completions=bykey[string];
            if (completions) {
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,"hidden")) {}
                    else if (hasClass(c,"completion")) {
                        if (isexact) {exactheads.push(c); exact.push(c);}
                        result.push(c); keys.push(string); direct.push(c);}
                    else {
                        var head=getParent(c,".completion");
                        if ((head)&&(hasClass(head,"hidden"))) {}
                        else if (head) {
                            if (isexact) exact.push(head);
                            result.push(head); keys.push(string);
                            variations.push(c);}}}}}
        if (exact.length) result.exact=exact;
        if (exactheads.length) result.exactheads=exactheads;
        result.prefix=prefix;
        result.strings=strings;
        result.matches=direct.concat(variations);
        return result;}

    function addCompletion(c,completion,key,value) {
        if (!(key)) key=completion.key||getKey(completion);
        if (!(value))
            value=(completion.value)||(completion.getAttribute('value'))||key;
        var pos=position(c.nodes,completion);
        if (pos<0) {
            c.nodes.push(completion); c.values.push(value);
            c.byvalue.add(value,completion);}
        else return;
        var opts=c.options;
        var container=c.dom;
        var ptree=c.prefixtree;
        var bykey=c.bykey;
        var smap=c.stringmap;
        var stdkey=stdspace(key);
        var matchcase=(opts&FDJT_COMPLETE_MATCHCASE);
        var anyword=(opts&FDJT_COMPLETE_ANYWORD);
        if (!(matchcase)) {
            var lower=stdkey.toLowerCase();
            smap[lower]=stdkey;
            stdkey=lower;}
        if (!(getParent(completion,container)))
            fdjtDOM.append(container,completion," ");
        addNodeKey(completion,stdkey,ptree,bykey,anyword);
        if (hasClass(completion,"cue")) c.cues.push(completion);
        var variations=getChildren(completion,".variation");
        var i=0; var lim=variations.length;
        while (i<lim) {
            var variation=variations[i++];
            var vkey=stdspace(variation.key||getKey(variation));
            if (!(matchcase)) {
                var lower=vkey.toLowerCase();
                smap[lower]=vkey;
                vkey=lower;}
            addNodeKey(variation,vkey,ptree,bykey,anyword);}}

    function initCompletions(c){
        var completions=getChildren(c.dom,".completion");
        var i=0; var lim=completions.length;
        while (i<lim) addCompletion(c,completions[i++]);
        c.initialized=true;}

    Completions.prototype.addCompletion=function(completion,key,value) {
        if (!(this.initialized)) initCompletions(this);
        addCompletion(this,completion,key,value);
        if (this.visible) this.visible=false;};

    function updateDisplay(c,todisplay){
        var displayed=c.displayed;
        if (displayed) {
            var i=0; var lim=displayed.length;
            while (i<lim) dropClass(displayed[i++],"displayed");
            c.displayed=displayed=[];}
        else c.displayed=displayed=[];
        if (todisplay) {
            var i=0; var lim=todisplay.length;
            while (i<lim) {
                var node=todisplay[i++];
                if (hasClass(node,"completion")) {
                    addClass(node,"displayed");
                    displayed.push(node);}
                else {
                    var head=getParent(node,".completion");
                    if ((head)&&(!(hasClass(head,"displayed")))) {
                        displayed.push(node); displayed.push(head);
                        addClass(head,"displayed");
                        addClass(node,"displayed");}}}}
        // Clear the visible ordered elements cache
        c.visible=false;
        // Move the selection if neccessary
        if ((this.selection)&&(!(hasClass(this.selection,"displayed"))))
            if (!(this.selectNext())) this.selectPrevious();}
    
    Completions.prototype.getCompletions=function(string) {
        if ((string===this.curstring)||(string===this.maxstring)||
            ((this.curstring)&&(this.maxstring)&&
             (hasPrefix(string,this.curstring))&&
             (hasPrefix(this.maxstring,string))))
            return this.result;
        else {
            var result;
            if (!(this.initialized)) initCompletions(this);
            if (isEmpty(string)) {
                result=[]; result.prefix=""; result.matches=[];
                if (this.dom) addClass(this.dom,"noinput");}
            else {
                result=getNodes(string,this.prefixtree,this.bykey);
                if (this.dom) dropClass(this.dom,"noinput");
                updateDisplay(this,result.matches);}
            if ((this.stringmap)&&(this.strings)) {
                var stringmap=this.stringmap;
                var strings=this.strings;
                var i=0; var lim=strings.length;
                while (i<lim) {
                    var s=strings[i]; var m=stringmap[s];
                    if (m) strings[i++]=m;
                    else i++;}}
            this.curstring=string;
            this.maxstring=result.prefix||string;
            this.result=result;
            return result;}};

    Completions.prototype.getValue=function(completion) {
        if (completion.value) return completion.value;
        else if (completion.getAttribute("value"))
            return completion.getAttribute("value");
        var pos=position(this.nodes,completion);
        if (pos<0) return false;
        else return this.values[pos];};
    Completions.prototype.getKey=function(completion) {
        if (completion.key) return completion.key;
        else if (completion.getAttribute("key"))
            return completion.getAttribute("key");
        else return getKey(completion);};

    Completions.prototype.complete=function(string){
        if (!(this.initialized)) initCompletions(this);
        // fdjtLog("Completing on %o",string);
        if ((!(string))&&(string!==""))
            string=((this.getText)?(this.getText(this.input)):
                    (hasClass(this.input,"isempty"))?(""):
                    (this.input.value));
        if (isEmpty(string)) {
            if (this.displayed) updateDisplay(this,false);
            addClass(this.dom,"noinput");
            dropClass(this.dom,"noresults");
            return [];}
        var result=this.getCompletions(string);
        if ((!(result))||(result.length===0)) {
            updateDisplay(this,false);
            dropClass(this.dom,"noinput");
            addClass(this.dom,"noresults");
            return [];}
        else {
            updateDisplay(this,result.matches);
            dropClass(this.dom,"noinput");
            dropClass(this.dom,"noresults");}
        return result;};

    Completions.prototype.getByValue=function(values,spec){
        if (!(this.initialized)) initCompletions(this);
        var result=[];
        var byvalue=this.byvalue;
        if (spec) spec=new fdjtDOM.Selector(spec);
        if (!(values instanceof Array)) values=[values];
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                if (spec) {
                    var j=0; var jlim=completions.length;
                    while (j<jlim) {
                        if (spec.match(completions[j]))
                            result.push(completions[j++]);
                        else j++;}}
                else result=result.concat(completions);}}
        return result;};
    Completions.prototype.getByKey=function(keys,spec){
        if (!(this.initialized)) initCompletions(this);
        var result=[];
        var byvalue=this.bykey;
        if (spec) spec=new fdjtDOM.Selector(spec);
        if (!(keys instanceof Array)) keys=[keys];
        var i=0; var lim=keys.length;
        while (i<lim) {
            var key=keys[i++];
            var completions=bykey.get(key);
            if (completions) {
                if (spec) {
                    var j=0; var jlim=completions.length;
                    while (j<jlim) {
                        if (spec.match(completions[j]))
                            result.push(completions[j++]);
                        else j++;}}
                else result=result.concat(completions);}}
        return result;};

    Completions.prototype.setCues=function(values,cueclass){
        if (!(this.initialized)) initCompletions(this);
        if (!(cueclass)) cueclass="cue";
        var cues=[];
        var byvalue=this.byvalue;
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,cueclass)) continue;
                    addClass(c,cueclass);
                    cues.push(c);}}}
        return cues;};

    Completions.prototype.setClass=function(values,classname){
        if (!(this.initialized)) initCompletions(this);
        var drop=fdjtDOM.getChildren(this.dom,".completion."+classname);
        if ((drop)&&(drop.length))
            dropClass(fdjtDOM.Array(drop),"hidden");
        var changed=[];
        var byvalue=this.byvalue;
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,classname)) continue;
                    addClass(c,classname);
                    changed.push(c);}}}
        return changed;}
    Completions.prototype.extendClass=function(values,classname){
        if (!(this.initialized)) initCompletions(this);
        var changed=[];
        var byvalue=this.byvalue;
        var i=0; var lim=values.length;
        while (i<lim) {
            var value=values[i++];
            var completions=byvalue.get(value);
            if (completions) {
                var j=0; var jlim=completions.length;
                while (j<jlim) {
                    var c=completions[j++];
                    if (hasClass(c,classname)) continue;
                    addClass(c,classname);
                    changed.push(c);}}}
        return changed;};
    
    Completions.prototype.dropClass=function(classname){
        var drop=fdjtDOM.getChildren(this.dom,".completion."+classname);
        if ((drop)&&(drop.length))
            dropClass(fdjtDOM.Array(drop),classname);};

    Completions.prototype.docomplete=function(input,callback){
        if (!(this.initialized)) initCompletions(this);
        if (!(input)) input=this.input;
        var delay=this.complete_delay||complete_delay;
        var that=this;
        if (this.timer) {
            clearTimeout(that.timer);
            that.timer=false;}
        this.timer=setTimeout(
            function(){
                if (!(input)) input=that.input;
                var completions=that.complete(input.value);
                if (callback) callback(completions);},
            delay);};

    function stdspace(string){
        return string.replace(/\s+/," ").replace(/(^\s)|(\s$)/,"");}

    fdjtUI.Completions=Completions;

    /* Selection from list/cloud */

    var Selector=fdjtDOM.Selector;

    function gatherVisible(root){
        var scan=root.firstChild; var displayed=[];
        while (scan!==root) {
            if (scan.nodeType===1) {
                var iscompletion=hasClass(scan,"completion");
                if ((iscompletion)&&(getStyle(scan).display!=="none")) 
                    displayed.push(scan);
                if ((scan.firstChild)&&(!(iscompletion))) {
                    scan=scan.firstChild; continue;}}
            while ((scan!==root)&&(!(scan.nextSibling)))
                scan=scan.parentNode;
            if (scan!==root) scan=scan.nextSibling;}
        return displayed;}

    // This gets visible nodes in their order of appearance, for which
    // we can't use .nodes or .displayed
    Completions.prototype.getVisible=function getVisible(){
        if (this.visible) return this.visible;
        else {
            var visible=this.visible=gatherVisible(this.dom);
            return visible;}}

    Completions.prototype.select=function select(completion){
        var pref=false; var displayed=this.getVisible();
        if (completion instanceof Selector) {
            pref=completion; completion=false;}
        if ((!(completion))&&(pref)) {
            var nodes=displayed;
            var i=0; var lim=nodes.length; while (i<lim) {
                var node=nodes[i++];
                if (hasClass(node,pref)) {completion=node; break;}
                else continue;}}
        if ((!(completion))&&(displayed.length))
            completion=displayed[0];
        if (this.selection) dropClass(this.selection,"selected");
        addClass(completion,"selected");
        this.selection=completion;
        return completion;};
    
    Completions.prototype.selectNext=function(selection){
        if (!(selection)) {
            if (this.selection) selection=this.selection;
            else selection=false;}
        var nodes=this.getVisible();
        var i=0, lim=nodes.length; while (i<lim) {
            var node=nodes[i++];
            if (!(selection)) {
                selection=node; break;}
            else if (node===selection) selection=false;
            else continue;}
        if (this.selection) dropClass(this.selection,"selected");
        addClass(selection,"selected");
        this.selection=selection;
        return selection;};

    Completions.prototype.selectPrevious=function(selection){
        var pref=false;
        if (!(selection)) {
            if (this.selection) selection=this.selection;
            else selection=false;}
        var nodes=this.getVisible();
        var i=nodes.length-1; while (i>=0) {
            var node=nodes[i--];
            if (!(selection)) {
                selection=node; break;}
            else if (node===selection) selection=false;
            else continue;}
        if (this.selection) dropClass(this.selection,"selected");
        if (selection) addClass(selection,"selected");
        this.selection=selection;
        return selection;};

    /* Options, handlers, etc */

    var cached_completions={};

    var default_options=
        FDJT_COMPLETE_OPTIONS|
        FDJT_COMPLETE_CLOUD|
        FDJT_COMPLETE_ANYWORD;

    function onkey(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var name=target.name;
        var completions=cached_completions[name];
        var compid=fdjtDOM.getAttrib(target,"completions");
        var dom=((compid)&&(fdjtID(compid)));
        if (!(dom)) return;
        if (!((completions)&&(completions.dom===dom))) {
            completions=new Completions(dom,target,default_options);
            cached_completions[name]=completions;}
        if (!(completions)) return;
        completions.docomplete(target);}
    fdjtUI.Completions.onkey=onkey;
    
    function update(evt){
        evt=evt||event;
        if (typeof evt==='string') evt=fdjtID(evt);
        if (!(evt)) return;
        var target=((evt.nodeType)?(evt):(fdjtUI.T(evt)));
        var name=target.name;
        var completions=cached_completions[name];
        var compid=fdjtDOM.getAttrib(target,"completions");
        var dom=((compid)&&(fdjtID(compid)));
        if (!(dom)) return;
        if (!((completions)&&(completions.dom===dom))) {
            completions=new Completions(dom,target,default_options);
            cached_completions[name]=completions;}
        if (!(completions)) return;
        completions.docomplete(target);}
    fdjtUI.Completions.update=update;

}());

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/*! syze v1.1.1 MIT/GPL2 @rezitech */
(function (win, docEl) {
	// syze variables
	var
	_sizes = [],
	_names = {},
	_from = 'browser',
	_debounceRate = 50,
	_callback;
	// add window event
	function addWinEvent(type, fn) {
		if (win.addEventListener) addEventListener(type, fn, false); else attachEvent('on' + type, fn);
	}
	// debouncer
	function debounce(fn) {
		var timeout;
		return function () {
			var obj = this, args = arguments;
			function delayed () {
				fn.apply(obj, args);
				timeout = null;
			}
			if (timeout) clearTimeout(timeout);
			timeout = setTimeout(delayed, _debounceRate); 
		};
	}
	// resizer
	function onResize() {
		var
		currentSize = 
			/^device$/i.test(String(_from)) ? !win.orientation || orientation == 180 ? screen.width : screen.height
			: /^browser$/i.test(String(_from)) ? docEl.clientWidth
			: (_from instanceof String) ? Function('return ' + _from)()
			: parseInt(_from, 10) || 0,
		docElClassNames = docEl.className.replace(/^\s+|(^|\s)(gt|is|lt)[^\s]+|\s+$/g, '').split(/\s+/),
		classNames = [], i = -1, e, arr = _sizes, len = arr.length;
		//
		arr.sort(function (a, b) { return(a - b); });
		//
		while (++i < len) if (currentSize < arr[i]) break;
		currentSize = arr[Math.max(Math.min(--i, len - 1), 0)];
		//
		i = -1;
		while (++i < len) {
			classNames.push((currentSize > arr[i] ? 'gt' : currentSize < arr[i] ? 'lt' : 'is') + (_names[arr[i]] || arr[i]));
		}
		//
		docEl.className = (!docElClassNames[0] ? [] : docElClassNames).concat(classNames).join(' ');
		//
		if (_callback) _callback(currentSize);
	}
	// syze controls
	win.syze = {
		sizes: function (val) { _sizes = [].concat.apply([], arguments); onResize(); return this; },
		names: function (val) { if (val instanceof Object) { _names = val; onResize(); } return this; },
		from: function (val) { _from = val; onResize(); return this; },
		debounceRate: function (val) { _debounceRate = parseInt(val, 10) || 0; onResize(); return this; },
		callback: function (val) { if (val instanceof Function) { _callback = val; onResize(); } return this; }
	};
	// start syze
	addWinEvent('resize', debounce(onResize));
	addWinEvent('orientationchange', onResize);
	onResize();
}(this, document.documentElement));/*!
 * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
 * Released under MIT license, http://cubiq.org/license
 */
(function(window, doc){
    function isClickable(evt){
	evt=evt||event;
	var target=evt.target||evt.srcElement;
	while (target) {
	    if ((target.nodeType===1)&& 
		(//(target.onclick)||
		 (target.tagName==='INPUT')||
		 (target.tagName==='TEXTAREA')||
		 ((target.tagName==='A')&&(target.href))||
		 ((target.className)&&
		  (target.className.search(/\b(clickable|checkspan)\b/)>=0))))
		return true;
	    target=target.parentNode;}
	return false;}
    var m = Math,
    dummyStyle = doc.createElement('div').style,
    vendor = (function () {
	var vendors = 't,webkitT,MozT,msT,OT'.split(','),
	t,
	i = 0,
	l = vendors.length;

	for ( ; i < l; i++ ) {
	    t = vendors[i] + 'ransform';
	    if ( t in dummyStyle ) {
		return vendors[i].substr(0, vendors[i].length - 1);
	    }
	}

	return false;
    })(),
    cssVendor = vendor ? '-' + vendor.toLowerCase() + '-' : '',

    // Style properties
    transform = prefixStyle('transform'),
    transitionProperty = prefixStyle('transitionProperty'),
    transitionDuration = prefixStyle('transitionDuration'),
    transformOrigin = prefixStyle('transformOrigin'),
    transitionTimingFunction = prefixStyle('transitionTimingFunction'),
    transitionDelay = prefixStyle('transitionDelay'),

    // Browser capabilities
    isAndroid = (/android/gi).test(navigator.appVersion),
    isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
    isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

    has3d = prefixStyle('perspective') in dummyStyle,
    hasTouch = 'ontouchstart' in window && !isTouchPad,
    hasTransform = vendor !== false,
    hasTransitionEnd = prefixStyle('transition') in dummyStyle,

    RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize',
    START_EV = hasTouch ? 'touchstart' : 'mousedown',
    MOVE_EV = hasTouch ? 'touchmove' : 'mousemove',
    END_EV = hasTouch ? 'touchend' : 'mouseup',
    CANCEL_EV = hasTouch ? 'touchcancel' : 'mouseup',
    TRNEND_EV = (function () {
	if ( vendor === false ) return false;

	var transitionEnd = {
	    ''			: 'transitionend',
	    'webkit'	: 'webkitTransitionEnd',
	    'Moz'		: 'transitionend',
	    'O'			: 'otransitionend',
	    'ms'		: 'MSTransitionEnd'
	};

	return transitionEnd[vendor];
    })(),

    nextFrame = (function() {
	return window.requestAnimationFrame ||
	    window.webkitRequestAnimationFrame ||
	    window.mozRequestAnimationFrame ||
	    window.oRequestAnimationFrame ||
	    window.msRequestAnimationFrame ||
	    function(callback) { return setTimeout(callback, 1); };
    })(),
    cancelFrame = (function () {
	return window.cancelRequestAnimationFrame ||
	    window.webkitCancelAnimationFrame ||
	    window.webkitCancelRequestAnimationFrame ||
	    window.mozCancelRequestAnimationFrame ||
	    window.oCancelRequestAnimationFrame ||
	    window.msCancelRequestAnimationFrame ||
	    clearTimeout;
    })(),

    // Helpers
    translateZ = has3d ? ' translateZ(0)' : '',
    // Constructor
    iScroll = function (el, options) {
	var that = this,
	i;

	that.wrapper = typeof el == 'object' ? el : doc.getElementById(el);
	that.wrapper.style.overflow = 'hidden';
	that.scroller = that.wrapper.children[0];

	// Default options
	that.options = {
	    hScroll: true,
	    vScroll: true,
	    x: 0,
	    y: 0,
	    bounce: true,
	    bounceLock: false,
	    momentum: true,
	    lockDirection: true,
	    useTransform: true,
	    useTransition: false,
	    topOffset: 0,
	    checkDOMChanges: false,		// Experimental
	    handleClick: true,
            fingers: false,
	    // Scrollbar
	    hScrollbar: true,
	    vScrollbar: true,
	    fixedScrollbar: isAndroid,
	    hideScrollbar: isIDevice,
	    fadeScrollbar: isIDevice && has3d,
	    scrollbarClass: '',

	    // Zoom
	    zoom: false,
	    zoomMin: 1,
	    zoomMax: 4,
	    doubleTapZoom: 2,
	    wheelAction: 'scroll',

	    // Snap
	    snap: false,
	    snapThreshold: 1,

	    // Events
	    onRefresh: null,
	    onBeforeScrollStart: function (e) { e.preventDefault(); },
	    onScrollStart: null,
	    onBeforeScrollMove: null,
	    onScrollMove: null,
	    onBeforeScrollEnd: null,
	    onScrollEnd: null,
	    onTouchEnd: null,
	    onDestroy: null,
	    onZoomStart: null,
	    onZoom: null,
	    onZoomEnd: null
	};

	// User defined options
	for (i in options) that.options[i] = options[i];
	
	// Set starting position
	that.x = that.options.x;
	that.y = that.options.y;

	// Normalize options
	that.options.useTransform = hasTransform && that.options.useTransform;
	that.options.hScrollbar = that.options.hScroll && that.options.hScrollbar;
	that.options.vScrollbar = that.options.vScroll && that.options.vScrollbar;
	that.options.zoom = that.options.useTransform && that.options.zoom;
	that.options.useTransition = hasTransitionEnd && that.options.useTransition;

	// Helpers FIX ANDROID BUG!
	// translate3d and scale doesn't work together!
	// Ignoring 3d ONLY WHEN YOU SET that.options.zoom
	if ( that.options.zoom && isAndroid ){
	    translateZ = '';
	}
	
	// Set some default styles
	that.scroller.style[transitionProperty] = that.options.useTransform ? cssVendor + 'transform' : 'top left';
	that.scroller.style[transitionDuration] = '0';
	that.scroller.style[transformOrigin] = '0 0';
	if (that.options.useTransition) that.scroller.style[transitionTimingFunction] = 'cubic-bezier(0.33,0.66,0.66,1)';
	
	if (that.options.useTransform) that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px)' + translateZ;
	else that.scroller.style.cssText += ';position:absolute;top:' + that.y + 'px;left:' + that.x + 'px';

	if (that.options.useTransition) that.options.fixedScrollbar = true;

	that.refresh();

	that._bind(RESIZE_EV, window);
	that._bind(START_EV);
	if (!hasTouch) {
	    if (that.options.wheelAction != 'none') {
		that._bind('DOMMouseScroll');
		that._bind('mousewheel');
	    }
	}

	if (that.options.checkDOMChanges) that.checkDOMTime = setInterval(function () {
	    that._checkDOMChanges();
	}, 500);
    };

    // Prototype
    iScroll.prototype = {
	enabled: true,
	x: 0,
	y: 0,
	steps: [],
	scale: 1,
	currPageX: 0, currPageY: 0,
	pagesX: [], pagesY: [],
	aniTime: null,
	wheelZoomCount: 0,
	
	handleEvent: function (e) {
	    var that = this;
	    switch(e.type) {
	    case START_EV:
		if (!hasTouch && e.button !== 0) {
		    /* (||(isClickable(e))) */
		    fdjt.Log("punting, e.button=%o, clickable=%o",
			     e.button,isClickable(e));
		    return;}
		that._start(e);
		break;
	    case MOVE_EV: that._move(e); break;
	    case END_EV:
	    case CANCEL_EV: that._end(e); break;
	    case RESIZE_EV: that._resize(); break;
	    case 'DOMMouseScroll': case 'mousewheel': that._wheel(e); break;
	    case TRNEND_EV: that._transitionEnd(e); break;
	    }
	},
	
	_checkDOMChanges: function () {
	    if (this.moved || this.zoomed || this.animating ||
		(this.scrollerW == this.scroller.offsetWidth * this.scale && this.scrollerH == this.scroller.offsetHeight * this.scale)) return;

	    this.refresh();
	},
	
	_scrollbar: function (dir) {
	    var that = this,
	    bar;

	    if (!that[dir + 'Scrollbar']) {
		if (that[dir + 'ScrollbarWrapper']) {
		    if (hasTransform) that[dir + 'ScrollbarIndicator'].style[transform] = '';
		    that[dir + 'ScrollbarWrapper'].parentNode.removeChild(that[dir + 'ScrollbarWrapper']);
		    that[dir + 'ScrollbarWrapper'] = null;
		    that[dir + 'ScrollbarIndicator'] = null;
		}

		return;
	    }

	    if (!that[dir + 'ScrollbarWrapper']) {
		// Create the scrollbar wrapper
		bar = doc.createElement('div');

		if (that.options.scrollbarClass) bar.className = that.options.scrollbarClass + dir.toUpperCase();
		else bar.style.cssText = 'position:absolute;z-index:100;' + (dir == 'h' ? 'height:7px;bottom:1px;left:2px;right:' + (that.vScrollbar ? '7' : '2') + 'px' : 'width:7px;bottom:' + (that.hScrollbar ? '7' : '2') + 'px;top:2px;right:1px');

		bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:opacity;' + cssVendor + 'transition-duration:' + (that.options.fadeScrollbar ? '350ms' : '0') + ';overflow:hidden;opacity:' + (that.options.hideScrollbar ? '0' : '1');

		that.wrapper.appendChild(bar);
		that[dir + 'ScrollbarWrapper'] = bar;

		// Create the scrollbar indicator
		bar = doc.createElement('div');
		if (!that.options.scrollbarClass) {
		    bar.style.cssText = 'position:absolute;z-index:100;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);' + cssVendor + 'background-clip:padding-box;' + cssVendor + 'box-sizing:border-box;' + (dir == 'h' ? 'height:100%' : 'width:100%') + ';' + cssVendor + 'border-radius:3px;border-radius:3px';
		}
		bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:' + cssVendor + 'transform;' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1);' + cssVendor + 'transition-duration:0;' + cssVendor + 'transform: translate(0,0)' + translateZ;
		if (that.options.useTransition) bar.style.cssText += ';' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1)';

		that[dir + 'ScrollbarWrapper'].appendChild(bar);
		that[dir + 'ScrollbarIndicator'] = bar;
	    }

	    if (dir == 'h') {
		that.hScrollbarSize = that.hScrollbarWrapper.clientWidth;
		that.hScrollbarIndicatorSize = m.max(m.round(that.hScrollbarSize * that.hScrollbarSize / that.scrollerW), 8);
		that.hScrollbarIndicator.style.width = that.hScrollbarIndicatorSize + 'px';
		that.hScrollbarMaxScroll = that.hScrollbarSize - that.hScrollbarIndicatorSize;
		that.hScrollbarProp = that.hScrollbarMaxScroll / that.maxScrollX;
	    } else {
		that.vScrollbarSize = that.vScrollbarWrapper.clientHeight;
		that.vScrollbarIndicatorSize = m.max(m.round(that.vScrollbarSize * that.vScrollbarSize / that.scrollerH), 8);
		that.vScrollbarIndicator.style.height = that.vScrollbarIndicatorSize + 'px';
		that.vScrollbarMaxScroll = that.vScrollbarSize - that.vScrollbarIndicatorSize;
		that.vScrollbarProp = that.vScrollbarMaxScroll / that.maxScrollY;
	    }

	    // Reset position
	    that._scrollbarPos(dir, true);
	},
	
	_resize: function () {
	    var that = this;
	    setTimeout(function () { that.refresh(); }, isAndroid ? 200 : 0);
	},
	
	_pos: function (x, y) {
	    if (this.zoomed) return;

	    x = this.hScroll ? x : 0;
	    y = this.vScroll ? y : 0;

	    if (this.options.useTransform) {
		this.scroller.style[transform] = 'translate(' + x + 'px,' + y + 'px) scale(' + this.scale + ')' + translateZ;
	    } else {
		x = m.round(x);
		y = m.round(y);
		this.scroller.style.left = x + 'px';
		this.scroller.style.top = y + 'px';
	    }

	    this.x = x;
	    this.y = y;

	    this._scrollbarPos('h');
	    this._scrollbarPos('v');
	},

	_scrollbarPos: function (dir, hidden) {
	    var that = this,
	    pos = dir == 'h' ? that.x : that.y,
	    size;

	    if (!that[dir + 'Scrollbar']) return;

	    pos = that[dir + 'ScrollbarProp'] * pos;

	    if (pos < 0) {
		if (!that.options.fixedScrollbar) {
		    size = that[dir + 'ScrollbarIndicatorSize'] + m.round(pos * 3);
		    if (size < 8) size = 8;
		    that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
		}
		pos = 0;
	    } else if (pos > that[dir + 'ScrollbarMaxScroll']) {
		if (!that.options.fixedScrollbar) {
		    size = that[dir + 'ScrollbarIndicatorSize'] - m.round((pos - that[dir + 'ScrollbarMaxScroll']) * 3);
		    if (size < 8) size = 8;
		    that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
		    pos = that[dir + 'ScrollbarMaxScroll'] + (that[dir + 'ScrollbarIndicatorSize'] - size);
		} else {
		    pos = that[dir + 'ScrollbarMaxScroll'];
		}
	    }

	    that[dir + 'ScrollbarWrapper'].style[transitionDelay] = '0';
	    that[dir + 'ScrollbarWrapper'].style.opacity = hidden && that.options.hideScrollbar ? '0' : '1';
	    that[dir + 'ScrollbarIndicator'].style[transform] = 'translate(' + (dir == 'h' ? pos + 'px,0)' : '0,' + pos + 'px)') + translateZ;
	},
	
	_start: function (e) {
	    var that = this,
	    point = hasTouch ? e.touches[0] : e,
	    matrix, x, y,
	    c1, c2;

	    if (!that.enabled) return;

             if ((that.options.fingers)&&(e.touches)&&
                 (e.touches.length!==that.options.fingers))
                 return;

	    if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);

	    if (that.options.useTransition || that.options.zoom) that._transitionTime(0);

	    that.moved = false;
	    that.animating = false;
	    that.zoomed = false;
	    that.distX = 0;
	    that.distY = 0;
	    that.absDistX = 0;
	    that.absDistY = 0;
	    that.dirX = 0;
	    that.dirY = 0;

	    // Gesture start
	    if (that.options.zoom && hasTouch && e.touches.length > 1) {
		c1 = m.abs(e.touches[0].pageX-e.touches[1].pageX);
		c2 = m.abs(e.touches[0].pageY-e.touches[1].pageY);
		that.touchesDistStart = m.sqrt(c1 * c1 + c2 * c2);

		that.originX = m.abs(e.touches[0].pageX + e.touches[1].pageX - that.wrapperOffsetLeft * 2) / 2 - that.x;
		that.originY = m.abs(e.touches[0].pageY + e.touches[1].pageY - that.wrapperOffsetTop * 2) / 2 - that.y;

		if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
	    }

	    if (that.options.momentum) {
		if (that.options.useTransform) {
		    // Very lame general purpose alternative to CSSMatrix
		    matrix = getComputedStyle(that.scroller, null)[transform].replace(/[^0-9\-.,]/g, '').split(',');
		    x = +(matrix[12] || matrix[4]);
		    y = +(matrix[13] || matrix[5]);
		} else {
		    x = +getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, '');
		    y = +getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, '');
		}
		
		if (x != that.x || y != that.y) {
		    if (that.options.useTransition) that._unbind(TRNEND_EV);
		    else cancelFrame(that.aniTime);
		    that.steps = [];
		    that._pos(x, y);
		    if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);
		}
	    }

	    that.absStartX = that.x;	// Needed by snap threshold
	    that.absStartY = that.y;

	    that.startX = that.x;
	    that.startY = that.y;
	    that.pointX = point.pageX;
	    that.pointY = point.pageY;

	    that.startTime = e.timeStamp || Date.now();

	    if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

	    that._bind(MOVE_EV, window);
	    that._bind(END_EV, window);
	    that._bind(CANCEL_EV, window);
	},
	
	_move: function (e) {
	    var that = this,
	    point = hasTouch ? e.touches[0] : e,
	    deltaX = point.pageX - that.pointX,
	    deltaY = point.pageY - that.pointY,
	    newX = that.x + deltaX,
	    newY = that.y + deltaY,
	    c1, c2, scale,
	    timestamp = e.timeStamp || Date.now();

	    if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

	    // Zoom
	    if (that.options.zoom && hasTouch && e.touches.length > 1) {
		c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
		c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
		that.touchesDist = m.sqrt(c1*c1+c2*c2);

		that.zoomed = true;

		scale = 1 / that.touchesDistStart * that.touchesDist * this.scale;

		if (scale < that.options.zoomMin) scale = 0.5 * that.options.zoomMin * Math.pow(2.0, scale / that.options.zoomMin);
		else if (scale > that.options.zoomMax) scale = 2.0 * that.options.zoomMax * Math.pow(0.5, that.options.zoomMax / scale);

		that.lastScale = scale / this.scale;

		newX = this.originX - this.originX * that.lastScale + this.x,
		newY = this.originY - this.originY * that.lastScale + this.y;

		this.scroller.style[transform] = 'translate(' + newX + 'px,' + newY + 'px) scale(' + scale + ')' + translateZ;

		if (that.options.onZoom) that.options.onZoom.call(that, e);
		return;
	    }

	    that.pointX = point.pageX;
	    that.pointY = point.pageY;

	    // Slow down if outside of the boundaries
	    if (newX > 0 || newX < that.maxScrollX) {
		newX = that.options.bounce ? that.x + (deltaX / 2) : newX >= 0 || that.maxScrollX >= 0 ? 0 : that.maxScrollX;
	    }
	    if (newY > that.minScrollY || newY < that.maxScrollY) {
		newY = that.options.bounce ? that.y + (deltaY / 2) : newY >= that.minScrollY || that.maxScrollY >= 0 ? that.minScrollY : that.maxScrollY;
	    }

	    that.distX += deltaX;
	    that.distY += deltaY;
	    that.absDistX = m.abs(that.distX);
	    that.absDistY = m.abs(that.distY);

	    if (that.absDistX < 6 && that.absDistY < 6) {
		return;
	    }

	    // Lock direction
	    if (that.options.lockDirection) {
		if (that.absDistX > that.absDistY + 5) {
		    newY = that.y;
		    deltaY = 0;
		} else if (that.absDistY > that.absDistX + 5) {
		    newX = that.x;
		    deltaX = 0;
		}
	    }

	    that.moved = true;
	    that._pos(newX, newY);
	    that.dirX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
	    that.dirY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

	    if (timestamp - that.startTime > 300) {
		that.startTime = timestamp;
		that.startX = that.x;
		that.startY = that.y;
	    }
	    
	    if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
	},
	
	_end: function (e) {
	    if (hasTouch && e.touches.length !== 0) return;

	    var that = this,
	    point = hasTouch ? e.changedTouches[0] : e,
	    target, ev,
	    momentumX = { dist:0, time:0 },
	    momentumY = { dist:0, time:0 },
	    duration = (e.timeStamp || Date.now()) - that.startTime,
	    newPosX = that.x,
	    newPosY = that.y,
	    distX, distY,
	    newDuration,
	    snap,
	    scale;

	    that._unbind(MOVE_EV, window);
	    that._unbind(END_EV, window);
	    that._unbind(CANCEL_EV, window);

	    if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

	    if (that.zoomed) {
		scale = that.scale * that.lastScale;
		scale = Math.max(that.options.zoomMin, scale);
		scale = Math.min(that.options.zoomMax, scale);
		that.lastScale = scale / that.scale;
		that.scale = scale;

		that.x = that.originX - that.originX * that.lastScale + that.x;
		that.y = that.originY - that.originY * that.lastScale + that.y;
		
		that.scroller.style[transitionDuration] = '200ms';
		that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + that.scale + ')' + translateZ;
		
		that.zoomed = false;
		that.refresh();

		if (that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
		return;
	    }

	    if (!that.moved) {
		if (hasTouch) {
		    if (that.doubleTapTimer && that.options.zoom) {
			// Double tapped
			clearTimeout(that.doubleTapTimer);
			that.doubleTapTimer = null;
			if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
			that.zoom(that.pointX, that.pointY, that.scale == 1 ? that.options.doubleTapZoom : 1);
			if (that.options.onZoomEnd) {
			    setTimeout(function() {
				that.options.onZoomEnd.call(that, e);
			    }, 200); // 200 is default zoom duration
			}
		    } else if (this.options.handleClick) {
			that.doubleTapTimer = setTimeout(function () {
			    that.doubleTapTimer = null;

			    // Find the last touched element
			    target = point.target;
			    while (target.nodeType != 1) target = target.parentNode;

			    if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
				ev = doc.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1,
						  point.screenX, point.screenY, point.clientX, point.clientY,
						  e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
						  0, null);
				ev._fake = true;
				target.dispatchEvent(ev);
			    }
			}, that.options.zoom ? 250 : 0);
		    }
		}

		that._resetPos(400);

		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
		return;
	    }

	    if (duration < 300 && that.options.momentum) {
		momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
		momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY < 0 ? that.scrollerH - that.wrapperH + that.y - that.minScrollY : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

		newPosX = that.x + momentumX.dist;
		newPosY = that.y + momentumY.dist;

		if ((that.x > 0 && newPosX > 0) || (that.x < that.maxScrollX && newPosX < that.maxScrollX)) momentumX = { dist:0, time:0 };
		if ((that.y > that.minScrollY && newPosY > that.minScrollY) || (that.y < that.maxScrollY && newPosY < that.maxScrollY)) momentumY = { dist:0, time:0 };
	    }

	    if (momentumX.dist || momentumY.dist) {
		newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

		// Do we need to snap?
		if (that.options.snap) {
		    distX = newPosX - that.absStartX;
		    distY = newPosY - that.absStartY;
		    if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) { that.scrollTo(that.absStartX, that.absStartY, 200); }
		    else {
			snap = that._snap(newPosX, newPosY);
			newPosX = snap.x;
			newPosY = snap.y;
			newDuration = m.max(snap.time, newDuration);
		    }
		}

		that.scrollTo(m.round(newPosX), m.round(newPosY), newDuration);

		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
		return;
	    }

	    // Do we need to snap?
	    if (that.options.snap) {
		distX = newPosX - that.absStartX;
		distY = newPosY - that.absStartY;
		if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) that.scrollTo(that.absStartX, that.absStartY, 200);
		else {
		    snap = that._snap(that.x, that.y);
		    if (snap.x != that.x || snap.y != that.y) that.scrollTo(snap.x, snap.y, snap.time);
		}

		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
		return;
	    }

	    that._resetPos(200);
	    if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
	},
	
	_resetPos: function (time) {
	    var that = this,
	    resetX = that.x >= 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x,
	    resetY = that.y >= that.minScrollY || that.maxScrollY > 0 ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

	    if (resetX == that.x && resetY == that.y) {
		if (that.moved) {
		    that.moved = false;
		    if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);		// Execute custom code on scroll end
		}

		if (that.hScrollbar && that.options.hideScrollbar) {
		    if (vendor == 'webkit') that.hScrollbarWrapper.style[transitionDelay] = '300ms';
		    that.hScrollbarWrapper.style.opacity = '0';
		}
		if (that.vScrollbar && that.options.hideScrollbar) {
		    if (vendor == 'webkit') that.vScrollbarWrapper.style[transitionDelay] = '300ms';
		    that.vScrollbarWrapper.style.opacity = '0';
		}

		return;
	    }

	    that.scrollTo(resetX, resetY, time || 0);
	},

	_wheel: function (e) {
	    var that = this,
	    wheelDeltaX, wheelDeltaY,
	    deltaX, deltaY,
	    deltaScale;

	    if ('wheelDeltaX' in e) {
		wheelDeltaX = e.wheelDeltaX / 12;
		wheelDeltaY = e.wheelDeltaY / 12;
	    } else if('wheelDelta' in e) {
		wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;
	    } else if ('detail' in e) {
		wheelDeltaX = wheelDeltaY = -e.detail * 3;
	    } else {
		return;
	    }
	    
	    if (that.options.wheelAction == 'zoom') {
		deltaScale = that.scale * Math.pow(2, 1/3 * (wheelDeltaY ? wheelDeltaY / Math.abs(wheelDeltaY) : 0));
		if (deltaScale < that.options.zoomMin) deltaScale = that.options.zoomMin;
		if (deltaScale > that.options.zoomMax) deltaScale = that.options.zoomMax;
		
		if (deltaScale != that.scale) {
		    if (!that.wheelZoomCount && that.options.onZoomStart) that.options.onZoomStart.call(that, e);
		    that.wheelZoomCount++;
		    
		    that.zoom(e.pageX, e.pageY, deltaScale, 400);
		    
		    setTimeout(function() {
			that.wheelZoomCount--;
			if (!that.wheelZoomCount && that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
		    }, 400);
		}
		
		return;
	    }
	    
	    deltaX = that.x + wheelDeltaX;
	    deltaY = that.y + wheelDeltaY;

	    if (deltaX > 0) deltaX = 0;
	    else if (deltaX < that.maxScrollX) deltaX = that.maxScrollX;

	    if (deltaY > that.minScrollY) deltaY = that.minScrollY;
	    else if (deltaY < that.maxScrollY) deltaY = that.maxScrollY;
	    
	    if (that.maxScrollY < 0) {
		that.scrollTo(deltaX, deltaY, 0);
	    }
	},
	
	_transitionEnd: function (e) {
	    var that = this;

	    if (e.target != that.scroller) return;

	    that._unbind(TRNEND_EV);
	    
	    that._startAni();
	},


	/**
	 *
	 * Utilities
	 *
	 */
	_startAni: function () {
	    var that = this,
	    startX = that.x, startY = that.y,
	    startTime = Date.now(),
	    step, easeOut,
	    animate;

	    if (that.animating) return;
	    
	    if (!that.steps.length) {
		that._resetPos(400);
		return;
	    }
	    
	    step = that.steps.shift();
	    
	    if (step.x == startX && step.y == startY) step.time = 0;

	    that.animating = true;
	    that.moved = true;
	    
	    if (that.options.useTransition) {
		that._transitionTime(step.time);
		that._pos(step.x, step.y);
		that.animating = false;
		if (step.time) that._bind(TRNEND_EV);
		else that._resetPos(0);
		return;
	    }

	    animate = function () {
		var now = Date.now(),
		newX, newY;

		if (now >= startTime + step.time) {
		    that._pos(step.x, step.y);
		    that.animating = false;
		    if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that);			// Execute custom code on animation end
		    that._startAni();
		    return;
		}

		now = (now - startTime) / step.time - 1;
		easeOut = m.sqrt(1 - now * now);
		newX = (step.x - startX) * easeOut + startX;
		newY = (step.y - startY) * easeOut + startY;
		that._pos(newX, newY);
		if (that.animating) that.aniTime = nextFrame(animate);
	    };

	    animate();
	},

	_transitionTime: function (time) {
	    time += 'ms';
	    this.scroller.style[transitionDuration] = time;
	    if (this.hScrollbar) this.hScrollbarIndicator.style[transitionDuration] = time;
	    if (this.vScrollbar) this.vScrollbarIndicator.style[transitionDuration] = time;
	},

	_momentum: function (dist, time, maxDistUpper, maxDistLower, size) {
	    var deceleration = 0.0006,
	    speed = m.abs(dist) / time,
	    newDist = (speed * speed) / (2 * deceleration),
	    newTime = 0, outsideDist = 0;

	    // Proportinally reduce speed if we are outside of the boundaries
	    if (dist > 0 && newDist > maxDistUpper) {
		outsideDist = size / (6 / (newDist / speed * deceleration));
		maxDistUpper = maxDistUpper + outsideDist;
		speed = speed * maxDistUpper / newDist;
		newDist = maxDistUpper;
	    } else if (dist < 0 && newDist > maxDistLower) {
		outsideDist = size / (6 / (newDist / speed * deceleration));
		maxDistLower = maxDistLower + outsideDist;
		speed = speed * maxDistLower / newDist;
		newDist = maxDistLower;
	    }

	    newDist = newDist * (dist < 0 ? -1 : 1);
	    newTime = speed / deceleration;

	    return { dist: newDist, time: m.round(newTime) };
	},

	_offset: function (el) {
	    var left = -el.offsetLeft,
	    top = -el.offsetTop;
	    
	    while (el = el.offsetParent) {
		left -= el.offsetLeft;
		top -= el.offsetTop;
	    }
	    
	    if (el != this.wrapper) {
		left *= this.scale;
		top *= this.scale;
	    }

	    return { left: left, top: top };
	},

	_snap: function (x, y) {
	    var that = this,
	    i, l,
	    page, time,
	    sizeX, sizeY;

	    // Check page X
	    page = that.pagesX.length - 1;
	    for (i=0, l=that.pagesX.length; i<l; i++) {
		if (x >= that.pagesX[i]) {
		    page = i;
		    break;
		}
	    }
	    if (page == that.currPageX && page > 0 && that.dirX < 0) page--;
	    x = that.pagesX[page];
	    sizeX = m.abs(x - that.pagesX[that.currPageX]);
	    sizeX = sizeX ? m.abs(that.x - x) / sizeX * 500 : 0;
	    that.currPageX = page;

	    // Check page Y
	    page = that.pagesY.length-1;
	    for (i=0; i<page; i++) {
		if (y >= that.pagesY[i]) {
		    page = i;
		    break;
		}
	    }
	    if (page == that.currPageY && page > 0 && that.dirY < 0) page--;
	    y = that.pagesY[page];
	    sizeY = m.abs(y - that.pagesY[that.currPageY]);
	    sizeY = sizeY ? m.abs(that.y - y) / sizeY * 500 : 0;
	    that.currPageY = page;

	    // Snap with constant speed (proportional duration)
	    time = m.round(m.max(sizeX, sizeY)) || 200;

	    return { x: x, y: y, time: time };
	},

	_bind: function (type, el, bubble) {
	    (el || this.scroller).addEventListener(type, this, !!bubble);
	},

	_unbind: function (type, el, bubble) {
	    (el || this.scroller).removeEventListener(type, this, !!bubble);
	},


	/**
	 *
	 * Public methods
	 *
	 */
	destroy: function () {
	    var that = this;

	    that.scroller.style[transform] = '';

	    // Remove the scrollbars
	    that.hScrollbar = false;
	    that.vScrollbar = false;
	    that._scrollbar('h');
	    that._scrollbar('v');

	    // Remove the event listeners
	    that._unbind(RESIZE_EV, window);
	    that._unbind(START_EV);
	    that._unbind(MOVE_EV, window);
	    that._unbind(END_EV, window);
	    that._unbind(CANCEL_EV, window);
	    
	    if (!that.options.hasTouch) {
		that._unbind('DOMMouseScroll');
		that._unbind('mousewheel');
	    }
	    
	    if (that.options.useTransition) that._unbind(TRNEND_EV);
	    
	    if (that.options.checkDOMChanges) clearInterval(that.checkDOMTime);
	    
	    if (that.options.onDestroy) that.options.onDestroy.call(that);
	},

	refresh: function () {
	    var that = this,
	    offset,
	    i, l,
	    els,
	    pos = 0,
	    page = 0;

	    if (that.scale < that.options.zoomMin) that.scale = that.options.zoomMin;
	    that.wrapperW = that.wrapper.clientWidth || 1;
	    that.wrapperH = that.wrapper.clientHeight || 1;

	    that.minScrollY = -that.options.topOffset || 0;
	    that.scrollerW = m.round(that.scroller.offsetWidth * that.scale);
	    that.scrollerH = m.round((that.scroller.offsetHeight + that.minScrollY) * that.scale);
	    that.maxScrollX = that.wrapperW - that.scrollerW;
	    that.maxScrollY = that.wrapperH - that.scrollerH + that.minScrollY;
	    that.dirX = 0;
	    that.dirY = 0;

	    if (that.options.onRefresh) that.options.onRefresh.call(that);

	    that.hScroll = that.options.hScroll && that.maxScrollX < 0;
	    that.vScroll = that.options.vScroll && (!that.options.bounceLock && !that.hScroll || that.scrollerH > that.wrapperH);

	    that.hScrollbar = that.hScroll && that.options.hScrollbar;
	    that.vScrollbar = that.vScroll && that.options.vScrollbar && that.scrollerH > that.wrapperH;

	    offset = that._offset(that.wrapper);
	    that.wrapperOffsetLeft = -offset.left;
	    that.wrapperOffsetTop = -offset.top;

	    // Prepare snap
	    if (typeof that.options.snap == 'string') {
		that.pagesX = [];
		that.pagesY = [];
		els = that.scroller.querySelectorAll(that.options.snap);
		for (i=0, l=els.length; i<l; i++) {
		    pos = that._offset(els[i]);
		    pos.left += that.wrapperOffsetLeft;
		    pos.top += that.wrapperOffsetTop;
		    that.pagesX[i] = pos.left < that.maxScrollX ? that.maxScrollX : pos.left * that.scale;
		    that.pagesY[i] = pos.top < that.maxScrollY ? that.maxScrollY : pos.top * that.scale;
		}
	    } else if (that.options.snap) {
		that.pagesX = [];
		while (pos >= that.maxScrollX) {
		    that.pagesX[page] = pos;
		    pos = pos - that.wrapperW;
		    page++;
		}
		if (that.maxScrollX%that.wrapperW) that.pagesX[that.pagesX.length] = that.maxScrollX - that.pagesX[that.pagesX.length-1] + that.pagesX[that.pagesX.length-1];

		pos = 0;
		page = 0;
		that.pagesY = [];
		while (pos >= that.maxScrollY) {
		    that.pagesY[page] = pos;
		    pos = pos - that.wrapperH;
		    page++;
		}
		if (that.maxScrollY%that.wrapperH) that.pagesY[that.pagesY.length] = that.maxScrollY - that.pagesY[that.pagesY.length-1] + that.pagesY[that.pagesY.length-1];
	    }

	    // Prepare the scrollbars
	    that._scrollbar('h');
	    that._scrollbar('v');

	    if (!that.zoomed) {
		that.scroller.style[transitionDuration] = '0';
		that._resetPos(400);
	    }
	},

	scrollTo: function (x, y, time, relative) {
	    var that = this,
	    step = x,
	    i, l;

	    that.stop();

	    if (!step.length) step = [{ x: x, y: y, time: time, relative: relative }];
	    
	    for (i=0, l=step.length; i<l; i++) {
		if (step[i].relative) { step[i].x = that.x - step[i].x; step[i].y = that.y - step[i].y; }
		that.steps.push({ x: step[i].x, y: step[i].y, time: step[i].time || 0 });
	    }

	    that._startAni();
	},

	scrollToElement: function (el, time) {
	    var that = this, pos;
	    el = el.nodeType ? el : that.scroller.querySelector(el);
	    if (!el) return;

	    pos = that._offset(el);
	    pos.left += that.wrapperOffsetLeft;
	    pos.top += that.wrapperOffsetTop;

	    pos.left = pos.left > 0 ? 0 : pos.left < that.maxScrollX ? that.maxScrollX : pos.left;
	    pos.top = pos.top > that.minScrollY ? that.minScrollY : pos.top < that.maxScrollY ? that.maxScrollY : pos.top;
	    time = time === undefined ? m.max(m.abs(pos.left)*2, m.abs(pos.top)*2) : time;

	    that.scrollTo(pos.left, pos.top, time);
	},

	scrollToPage: function (pageX, pageY, time) {
	    var that = this, x, y;
	    
	    time = time === undefined ? 400 : time;

	    if (that.options.onScrollStart) that.options.onScrollStart.call(that);

	    if (that.options.snap) {
		pageX = pageX == 'next' ? that.currPageX+1 : pageX == 'prev' ? that.currPageX-1 : pageX;
		pageY = pageY == 'next' ? that.currPageY+1 : pageY == 'prev' ? that.currPageY-1 : pageY;

		pageX = pageX < 0 ? 0 : pageX > that.pagesX.length-1 ? that.pagesX.length-1 : pageX;
		pageY = pageY < 0 ? 0 : pageY > that.pagesY.length-1 ? that.pagesY.length-1 : pageY;

		that.currPageX = pageX;
		that.currPageY = pageY;
		x = that.pagesX[pageX];
		y = that.pagesY[pageY];
	    } else {
		x = -that.wrapperW * pageX;
		y = -that.wrapperH * pageY;
		if (x < that.maxScrollX) x = that.maxScrollX;
		if (y < that.maxScrollY) y = that.maxScrollY;
	    }

	    that.scrollTo(x, y, time);
	},

	disable: function () {
	    this.stop();
	    this._resetPos(0);
	    this.enabled = false;

	    // If disabled after touchstart we make sure that there are no left over events
	    this._unbind(MOVE_EV, window);
	    this._unbind(END_EV, window);
	    this._unbind(CANCEL_EV, window);
	},
	
	enable: function () {
	    this.enabled = true;
	},
	
	stop: function () {
	    if (this.options.useTransition) this._unbind(TRNEND_EV);
	    else cancelFrame(this.aniTime);
	    this.steps = [];
	    this.moved = false;
	    this.animating = false;
	},
	
	zoom: function (x, y, scale, time) {
	    var that = this,
	    relScale = scale / that.scale;

	    if (!that.options.useTransform) return;

	    that.zoomed = true;
	    time = time === undefined ? 200 : time;
	    x = x - that.wrapperOffsetLeft - that.x;
	    y = y - that.wrapperOffsetTop - that.y;
	    that.x = x - x * relScale + that.x;
	    that.y = y - y * relScale + that.y;

	    that.scale = scale;
	    that.refresh();

	    that.x = that.x > 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x;
	    that.y = that.y > that.minScrollY ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

	    that.scroller.style[transitionDuration] = time + 'ms';
	    that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + scale + ')' + translateZ;
	    that.zoomed = false;
	},
	
	isReady: function () {
	    return !this.moved && !this.zoomed && !this.animating;
	}
    };

    function prefixStyle (style) {
	if ( vendor === '' ) return style;

	style = style.charAt(0).toUpperCase() + style.substr(1);
	return vendor + style;
    }

    dummyStyle = null;	// for the sake of it

    if (typeof exports !== 'undefined') exports.iScroll = iScroll;
    else window.iScroll = iScroll;

})(window, document);


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* ######################### fdjt/ajax.js ###################### */

/* Copyright (C) 2007-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   This file provides an abstraction layer for Ajax calls

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use, modification, and redistribution of this program is permitted
    under either the GNU General Public License (GPL) Version 2 (or
    any later version) or under the GNU Lesser General Public License
    (version 3 or later).

    These licenses may be found at www.gnu.org, particularly:
      http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
      http://www.gnu.org/licenses/lgpl-3.0-standalone.html
*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.Ajax=
    (function(){
        
        var fdjtDOM=fdjt.DOM, fdjtUI=fdjt.UI, fdjtLog=fdjt.Log;

        function compose_uri(base_uri,args){
            var uri=base_uri; var need_amp=false;
            if (base_uri[-1]==='&') need_amp=false;
            else if (base_uri.indexOf('?')>=0) need_amp=true;
            else uri=base_uri+"?";
            if (typeof args === 'string')
                uri=uri+((need_amp) ? ("&") : (""))+args;
            else if (args.length) {
                var i=0; while (i<args.length) {
                    if (!(args[i])) {i=i+2; continue;}
                    uri=uri+((need_amp) ? ("&") : (""))+
                        encodeURIComponent(args[i])+
                        "="+encodeURIComponent(args[i+1]);
                    need_amp=true;
                    i=i+2;}}
            else {
                for (var key in args) {
                    if (args.hasOwnProperty(key)) {
                        uri=uri+((need_amp) ? ("&") : (""))+
                            encodeURIComponent(key)+
                            "="+encodeURIComponent(args[key]);
                        need_amp=true;}}}
            return uri;}

        var trace_ajax=false;
        
        function fdjtAjax(success_callback,base_uri,args,other_callback){
            var req=((window.XDomainRequest)?
                     (new XDomainRequest()):
                     (new XMLHttpRequest()));
            var uri=((args)?(compose_uri(base_uri,args)):(base_uri));
            req.withCredentials=true;
            req.onreadystatechange=function () {
                if ((req.readyState == 4) && (req.status == 200)) {
                    success_callback(req);}
                else if (other_callback) other_callback(req);};
            req.open("GET",uri);
            req.send(null);
            return req;}

        fdjtAjax.textCall=function(callback,base_uri){
            return fdjtAjax(function(req) {callback(req.responseText);},
                            base_uri,fdjtDOM.Array(arguments,2));};

        fdjtAjax.jsonCall=function(callback,base_uri){
            return fdjtAjax(function(req) {
                callback(JSON.parse(req.responseText));},
              base_uri,fdjtDOM.Array(arguments,2));};

        fdjtAjax.xmlCall=function(callback,base_uri){
            return fdjtAjax(function(req) {callback(req.responseXML);},
                            base_uri,fdjtDOM.Array(arguments,2));};
        
        fdjtAjax.jsonpCall=function(uri,id,cleanup){
            if ((id)&&($ID(id))) return false;
            var script_elt=fdjtNewElement("SCRIPT");
            if (id) script_elt.id=id;
            if (cleanup) script_elt.oncleanup=cleanup;
            script_elt.language='javascript';
            script_elt.src=uri;
            document.body.appendChild(script_elt);};

        fdjtAjax.jsonpFinish=function(id){
            var script_elt=$ID(id);
            if (!(script_elt)) return;
            if (script_elt.oncleanup) script_elt.oncleanup();
            fdjtDOM.remove(script_elt);};

        function add_query_param(parameters,name,value){
            return ((parameters)?(parameters+"&"):(""))+
                name+"="+encodeURIComponent(value);}

        function formParams(form) {
            fdjtUI.AutoPrompt.cleanup(form);
            var parameters=false;
            var inputs=fdjtDOM.getChildren(form,"INPUT");
            var i=0; while (i<inputs.length) {
                var input=inputs[i++];
                if ((!(input.disabled))&&
                    (((/(radio)|(checkbox)/i).exec(input.type))?
                     (input.checked):(true)))
                    parameters=add_query_param(
                        parameters,input.name,input.value);}
            var textareas=fdjtDOM.getChildren(form,"TEXTAREA");
            i=0; while (i<textareas.length) {
                var textarea=textareas[i++];
                if (!(textarea.disabled)) {
                    parameters=add_query_param(
                        parameters,textarea.name,textarea.value);}}
            var selectboxes=fdjtDOM.getChildren(form,"SELECT");
            i=0; while (i<selectboxes.length) {
                var selectbox=selectboxes[i++]; var name=selectbox.name;
                var options=fdjtDOM.getChildren(selectbox,"OPTION");
                var j=0; while (j<options.length) {
                    var option=options[j++];
                    if (option.selected)
                        parameters=add_query_param(
                            parameters,name,option.value);}}
            return parameters;}
        fdjtAjax.formParams=formParams;

        function add_field(result,name,value,multifields,downcase) {
            if (downcase) name=name.toLowerCase();
            if ((multifields)&&(fdjtKB.contains(multifields,name))) {
                if (result[name]) result[name].push(value);
                else result[name]=[value];}
            else {
                var cur=result[name];
                if (!cur) result[name]=value;
                else if (cur instanceof Array) cur.push(value);
                else result[name]=[cur,value];}}

        function formJSON(form,multifields,downcase) {
            fdjtUI.AutoPrompt.cleanup(form);
            var result={};
            var inputs=fdjtDOM.getChildren(form,"INPUT");
            var i=0; while (i<inputs.length) {
                var input=inputs[i++];
                if ((!(input.disabled)) &&
                    (((input.type==="radio") || (input.type==="checkbox")) ?
                     (input.checked) : (true)))
                    add_field(result,input.name,input.value,
                              multifields,downcase||false);}
            var textareas=fdjtDOM.getChildren(form,"TEXTAREA");
            i=0; while (i<textareas.length) {
                var textarea=textareas[i++];
                if (!(textarea.disabled)) 
                    add_field(result,textarea.name,textarea.value,
                              multifields,downcase||false);}
            var selectboxes=fdjtDOM.getChildren(form,"SELECT");
            i=0; while (i<selectboxes.length) {
                var selectbox=selectboxes[i++]; var name=selectbox.name;
                var options=fdjtDOM.getChildren(selectbox,"OPTION");
                var j=0; while (j<options.length) {
                    var option=options[j++];
                    if (option.selected)
                        add_field(result,name,option.value,
                                  multifields,downcase||false);}}
            return result;}
        fdjtAjax.formJSON=formJSON;

        function ajaxSubmit(form,callback,cbctype){
            var ajax_uri=form.getAttribute("ajaxaction")||form.action;
            if (!(ajax_uri)) return false;
            // Whether to do AJAX synchronously or not.
            var syncp=form.getAttribute("synchronous");
            if (!(callback)) {
                if (form.oncallback) callback=form.oncallback;
                else if (form.getAttribute("ONCALLBACK")) {
                    callback=new Function
                    ("req","form",input_elt.getAttribute("ONCALLBACK"));
                    form.oncallback=callback;}}
            if (trace_ajax)
                fdjtLog("Direct %s AJAX submit to %s for %o with callback %o",
                        ((syncp)?("synchronous"):("asynchronous")),
                        ajax_uri,form,callback);
            // Firefox doesn't run the callback on synchronous calls
            var success=false; var callback_run=false;
            var req=(((window.XDomainRequest)&&(!(syncp)))?
                     (new XDomainRequest()):
                     (new XMLHttpRequest()));
            var params=formParams(form);
            fdjtDOM.addClass(form,"submitting");
            if (syncp) {
                if (form.method==="GET")
                    req.open('GET',ajax_uri+"?"+params,false);
                else if (form.method==="PUT")
                    req.open('PUT',ajax_uri,false);
                else req.open('POST',ajax_uri,false);}
            else {
                if (form.method==="GET")
                    req.open('GET',ajax_uri+"?"+params);
                else if (form.method==="PUT")
                    req.open('PUT',ajax_uri);
                else req.open('POST',ajax_uri);}
            if (cbctype) req.setRequestHeader("Accept",cbctype);
            req.withCredentials=true;
            req.onreadystatechange=function () {
                if (trace_ajax)
                    fdjtLog("Got callback (%d,%d) %o for %o, callback=%o",
                            req.readyState,req.status,req,ajax_uri,callback);
                if ((req.readyState === 4) && (req.status>=200) &&
                    (req.status<300)) {
                    if ((callback)&&(trace_ajax))
                        fdjtLog("Got callback (%d,%d) %o for %o, calling %o",
                                req.readyState,req.status,req,ajax_uri,callback);
                    fdjtDOM.dropClass(form,"submitting");
                    success=true; 
                    if (callback) callback(req,form);
                    callback_run=true;}
                else {
                    if (trace_ajax)
                        fdjtLog("Got callback (%d,%d) %o for %o, not calling %o",
                                req.readyState,req.status,req,ajax_uri,callback);
                    callback_run=false;}};
            try {
                if (form.method==="GET") req.send();
                else {
                    req.setRequestHeader(
                        "Content-type", "application/x-www-form-urlencoded");
                    req.send(params);}
                success=true;}
            catch (ex) {}
            if ((syncp) && (!(callback_run))) {
                if (trace_ajax)
                    fdjtLog("Running callback (rs=%d,status=%d) %o for %o, calling %o",
                            req.readyState,req.status,req,ajax_uri,callback);
                if ((req.readyState === 4) && (req.status>=200) &&
                    (req.status<300)) {
                    fdjtDOM.dropClass(form,"submitting");
                    success=true;
                    if (callback) callback(req,form);}};
            return success;}
        fdjtAjax.formSubmit=ajaxSubmit;

        function jsonpSubmit(form){
            var jsonp_uri=form.getAttribute("jsonpuri");
            if (!(jsonp_uri)) return false;
            var success=false;
            var jsonid=((form.id)?("JSONP"+form.id):("FORMJSONP"));
            var params=formParams(form);
            fdjtDOM.addClass(form,"submitting");
            try {
                jsonpCall(jsonp_uri+"?"+params,jsonid,
                          function(){fdjtDropClass(form,"submitting")});}
            catch (ex) {
                jsonpFinish(jsonid);
                fdjtLog.warn("Attempted JSONP call signalled %o",ex);
                return false;}
            return true;}

        function form_submit(evt,callback){
            evt=evt||event||null;
            var form=fdjtUI.T(evt);
            fdjtUI.AutoPrompt.cleanup(form);
            if (fdjtDOM.hasClass(form,"submitting")) {
                fdjtDOM.dropClass(form,"submitting");
                return;}
            // if (form.fdjtlaunchfailed) return;
            form.fdjtsubmit=true;
            fdjtDOM.addClass(form,"submitting");
            if (ajaxSubmit(form,callback)) {
                // fdjtLog("Ajax commit worked");
                fdjtUI.cancel(evt);
                return false;}
            else if (jsonpSubmit(form)) {
                // fdjtLog("Json commit worked");
                fdjtUI.cancel(evt);
                return false;}
            else return;}

        function copy_args(args,i){
            var lim=args.length; if (!(i)) i=0;
            var copy=new Array(lim-i);
            while (i<lim) {copy[i]=args[i]; i++;}
            return copy;}

        /* Synchronous calls */
        function sync_get(callback,base_uri,args){
            var req=new XMLHttpRequest();
            var uri=compose_uri(base_uri,args);
            req.open("GET",uri,false);
            req.send(null);
            if (callback) return callback(req);
            else return req;}
        fdjtAjax.get=function(base_uri){
            return sync_get(false,base_uri,copy_args(arguments,1));};
        fdjtAjax.getText=function(base_uri) {
            return sync_get(function (req) { return req.responseText; },
                            base_uri,copy_args(arguments,1));};
        fdjtAjax.getJSON=function(base_uri) {
            return sync_get(function (req) {
                return JSON.parse(req.responseText); },
                            base_uri,fdjtDOM.Array(arguments,1));};
        fdjtAjax.getXML=function(base_uri) {
            return fdjtAjaxGet(function (req) {
                return JSON.parse(req.responseXML); },
                               base_uri,fdjtDOM.Array(arguments,1));};
        
        fdjtAjax.onsubmit=form_submit;

        return fdjtAjax;})();

/* Emacs local variables
;;;  Local variables: ***
;;;  compile-command: "make; if test -f ../makefile; then cd ..; make; fi" ***
;;;  indent-tabs-mode: nil ***
;;;  End: ***
*/
/* -*- Mode: Javascript; -*- */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file was created from several component files and is
   part of the FDJT web toolkit (www.fdjt.org)

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   The copyright notice of the individual files are all prefixed by
   a copyright notice of the form "Copyright (C) ...".

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or
   any later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

*/

fdjt.useGlobals=function(){
    if (!(window.fdjtDOM)) window.fdjtDOM=fdjt.DOM;
    if (!(window.fdjtUI)) window.fdjtUI=fdjt.UI;
    if (window.fdjtTime) window.fdjtTime=fdjt.Time;
    if (!(window.fdjtString)) window.fdjtString=fdjt.String;
    if (!(window.fdjtState)) window.fdjtState=fdjt.State;
    if (!(window.fdjtLog)) window.fdjtLog=fdjt.Log;
    if (!(window.fdjtHash)) window.fdjtHash=fdjt.Hash;
    if (!(window.fdjtAjax)) window.fdjtAjax=fdjt.Ajax;
    if (!(window.CodexLayout)) window.CodexLayout=fdjt.CodexLayout;
    if (!(window.fdjtKB)) window.fdjtKB=fdjt.KB;};

    
/*
if (!(window.((typeof _declare_fdjt_globals !== "undefined")&&(_declare_fdjt_globals)))) window.(((typeof _declare_fdjt_globals !== "undefined")&&(_declare_fdjt_globals)) {
var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtTime=fdjt.Time;
    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtLog=fdjt.Log;
    var fdjtHash=fdjt.Hash;
    var fdjtAjax=fdjt.Ajax;
    var CodexLayout=fdjt.CodexLayout;
    var fdjtKB=fdjt.KB;}

*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ##################### knodules/knodules.js ####################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file provides a Javascript/ECMAScript of KNODULES, 
   a lightweight knowledge representation facility.

   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library is built on the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification and redistribution of this program is permitted
   under the GNU General Public License (GPL) Version 2:

   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@biz.beingmeta.com

   Enjoy!

*/

var Knodule=(function(){
    var fdjtString=fdjt.String;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM, fdjtID=fdjt.ID;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB;
    
    var knodules={};
    var all_knodules=[];
    var knodule=false;
    var trace_parsing=0;
    var trace_edits=false;

    var kno_simple_oidpat=/@[0-9A-Fa-f]+\/[0-9A-Fa-f]+/;
    var kno_named_oidpat=/@[0-9A-Fa-f]+\/[0-9A-Fa-f]+(\x22([^\x22]+)\x22)*/;
    var kno_atbreak=/[^\\]@/g;
    
    function Knodule(id,lang) {
        // Raw cons
        if (!(id)) return this;
        // Do lookup
        if (knodules[id])
            if ((lang)&&(lang!==knodules[id].language))
                throw { error: "language mismatch" };
        else return knodules[id];
        if (fdjtKB.Pool.probe(id))
            throw { error: "pool/knodule conflict"};
        if (this instanceof Knodule)
            knodule=fdjtKB.Pool.call(this,id);
        else knodule=fdjtKB.Pool.call((new Knodule()),id);
        // The name of the knodule
        knodule.name=id;
        knodules[id]=knodule;
        // The default language for this knodule
        if (lang) knodule.language=lang.toUpperCase();
        else knodule.language='EN';
        // Mapping dterms (univocal references) to KNode objects
        // (many-to-one)
        knodule.dterms={};
        // A vector of all dterms local to this knodule
        knodule.alldterms=[];
        // Prime (important) dterms
        knodule.prime=[]; knodule.primescores={};
        // Inverse indices for relations, rules, etc.
        knodule.index=fdjtKB.Index();
        // Whether to validate asserted relations
        knodule.validate=true;
        // Whether the knodule is 'strict'
        // (requiring dterm definitions for all references)
        knodule.strict=false;
        // Whether the knodule is 'finished' (all references declared)
        knodule.finished=false;
        // Terms which are assumed unique.  This is used in non-strict
        // knodules to catch terms that become ambiguous.
        knodule.assumed_dterms=[];
        // Mapping external dterms to their knodes
        knodule.xdterms={};
        // A vector of all foreign knode references
        knodule.allxdterms=[];
        // Mapping natural language terms to arrays of of KNodes
        // (ambiguous, many to many)
        knodule.terms={};
        // Mapping hook terms to arrays of of KNodes (ambiguous)
        knodule.hooks={};
        // Inverted index for genls in particular (useful for
        // faster search, inferences, etc)
        knodule.genlsIndex={};
        // This maps external OIDs to knodes
        knodule.oidmap={};
        // DRULES (disambiguation rules)
        knodule.drules={};
        return knodule;}
    Knodule.prototype=new fdjtKB.Pool();

    function KNode(knodule,string,lang){
        if (!(knodule)) return this;
        var weak=false; var prime=
            ((string[0]==='*')&&(string.search(/[^*]/)));
        var newprime=false;
        if (string[0]==='~') {weak=true; string=string.slice(1);}
        else if (prime) {
            string=string.slice(prime);
            if (!(knodule.primescores[string])) {
                if (prime>(knodule.primescores[string]))
                    knodule.primescores[string]=prime;
                newprime=true;}}
        if (string.search(/[a-zA-Z]\$/)===0) {
            lang=string.slice(0,2).toUpperCase();
            string=string.slice(3);}
        else if (lang) lang=lang.toUpperCase();
        else lang=knodule.language;
        var term=string; var absref=false;
        var knode=((this instanceof KNode)?
                   (knodule.ref(term,this)):
                   (knodule.ref(term)));
        if (!(knode._qid)) {
            if (knodule.language!==lang) term=lang+"$"+string;
            if (knodule.dterms.hasOwnProperty(term))
                return knodule.dterms[term];
            knode._qid=term+"@"+(knodule.absref||knodule.name);}
        // It's already initialized
        if (this!==knode) return knode;
        knode.dterm=term;
        knode._init=fdjtTime();
        if (weak) knode.weak=true;
        if (prime) knode.prime=prime;
        if ((prime)&&(newprime)) knodule.prime.push(knode);
        knodule.dterms[knode.dterm]=knode;
        knodule.dterms[term]=knode;
        knodule.alldterms.push(knode);
        if ((lang)&&(lang!==knodule.language)) knode.language=lang;
        knode._always=fdjtKB.Set();
        knode.knodule=knodule;
        knode.addTerm(string,lang);
        return knode;}
    KNode.prototype=new fdjtKB.Ref();

    Knodule.KNode=KNode;
    Knodule.prototype.KNode=function(string,lang) {
        if (string instanceof KNode) {
            if (string.pool===this)
                // Should this do some kind of import?
                return string;
            else return string;}
        else return new KNode(this,string,lang);};
    Knodule.prototype.cons=function(string,lang) {
        return new KNode(this,string,lang);};
    Knodule.prototype.probe=function(string,langid) {
        if ((this.language===langid)||(!(langid)))
            return this.dterms[string]||false;
        else return this.dterms[langid+"$"+string]||false;};
    
    KNode.prototype.add=function(prop,val){
        if ((fdjtKB.Ref.prototype.add.call(this,prop,val))&&
            (prop==='genls')) {
            fdjtKB.add(this._always,val);
            this._always=fdjtKB.merge(this._always,val._always);
            return true;}
        else return false;}
    KNode.prototype.addTerm=function(val,field){
        if (typeof val === 'string') {
            var langspec=val.search(/[a-zA-Z][a-zA-Z_]+[a-zA-Z]\$/);
            var lang=this.knodule.language;
            var term=false;
            if (langspec===0) {
                var dollar=val.indexOf('$');
                lang=val.slice(0,dollar);
                if (field) field=lang+"$"+field;
                else field=lang;
                term=val.slice(dollar+1);}
            else if (field) term=val;
            else {
                field=lang; term=val;}
            this.add(field,term);}
        else this.add(field,val);}
    KNode.prototype.tagString=function(kno) {
        if (this.oid) return this.oid;
        else if (this.uuid) return this.uuid;
        else if (this._qid) return this._qid;
        if (!(kno)) kno=Knodule.current||false;
        if (kno===this.knodule) return "@@"+this.dterm;
        else return this.dterm+"@"+
            (this.knodule.absref||this.knodule.name);};
    
    /* Text processing utilities */
    function stdspace(string) {
        return string.replace(/\s+/," ").
            replace(/^\s/,"").replace(/\s$/,"");}
    
    function trimspace(string) {
        return string.replace(/^\s/,"").replace(/\s$/,"");}

    function findBreak(string,brk,start) {
        var pos=string.indexOf(brk,start||0);
        while (pos>0)
            if (string[pos-1]!="\\")
                return pos;
        else pos=string.indexOf(brk,pos+1);
        return pos;}

    var _knodule_oddpat=/(\\)|(\s\s)|(\s;)|(\s;)/g;
    
    function segmentString(string,brk,start,keepspace) {
        if (start)
            if (string.slice(start).search(_knodule_oddpat)<0)
                return string.slice(start).split(brk);
        else {}
        else if (string.search(_knodule_oddpat)<0)
            return string.split(brk);
        else {}
        var result=[]; var i=0, pos=start||0;
        var nextpos=findBreak(string,brk,pos);
        while (nextpos>=0) {
            var item=((keepspace) ? (string.slice(pos,nextpos)) :
                      (stdspace(string.slice(pos,nextpos))));
            if ((item) && (item !== "")) result.push(item);
            pos=nextpos+1;
            nextpos=findBreak(string,brk,pos);}
        result.push(string.slice(pos));
        return result;}
    function stripComments(string) {
        return string.replace(/^\s*#.*$/g,"").
            replace(/^\s*\/\/.*$/g,"");}

    /* Processing the PLAINTEXT microformat */
    function handleClause(clause,subject) {
        if (clause.indexOf('\\')>=0) clause=fdjtString.unEscape(clause);
        if (trace_parsing>2)
            fdjtLog("Handling clause '%s' for %o",clause,subject);
        if ((clause.length===0)||(clause.search(/[^\n\t ]/g)<0))
            return;
        switch (clause[0]) {
        case '^':
            if (clause[1]==='~') 
                subject.add('sometimes',this.KNode(clause.slice(2)));
            else if (clause[2]==='*') 
                subject.add('commonly',this.KNode(clause.slice(2)));
            else {
                var pstart=findBreak(clause,"(");
                if (pstart>0) {
                    var pend=findBreak(clause,")",pstart);
                    if (pend<0) {
                        fdjtLog.warn(
                            "Invalid Knodule clause '%s' for %o (%s)",
                            clause,subject,subject.dterm);}
                    else {
                        var role=this.KNode(clause.slice(1,pstart));
                        var object=this.KNode(clause.slice(pstart+1,pend));
                        object.add(role.dterm,subject);
                        subject.add('genls',role);}}
                else subject.add('genls',this.KNode(clause.slice(1)));}
            break;
        case '_': {
            var object=this.KNode(clause.slice(1));
            subject.add('examples',object);
            object.add('genls',subject);
            break;}
        case '-':
            subject.add('never',this.KNode(clause.slice(1)));
            break;
        case '&': {
            var value=clause.slice((clause[1]==="-") ? (2) : (1));
            var assoc=this.KNode(value);
            if (clause[1]==="-")
                subject.add('antiassocs',assoc);
            else subject.add('assocs',assoc);
            break;}
        case '@': 
            if (clause[1]==="#") 
                subject.add('tags',clause.slice(2));
            else subject.add('uri',clause.slice(1));
            break;
        case '=':
            if (clause[1]==='@')
                subject.oid=clause.slice(1);
            else if (clause[1]==='*')
                subject.add('equiv',this.KNode(clause.slice(2)));
            else if (clause[1]==='~')
                subject.add('kinda',this.KNode(clause.slice(2)));
            else 
                subject.add('identical',this.KNode(clause.slice(1)));
            break;
        case '+': {
            if (clause[1]==="*") {
                subject.gloss=gloss.slice(2);
                subject.addTerm(subject.gloss,'glosses');}
            else if (clause[1]==="~") {
                subject.addTerm(subject.gloss,'glosses');}
            else {
                subject.addTerm(gloss,"glosses");}
            break;}
        case '%': {
            var mirror=this.KNode(clause.slice(1));
            if (subject.mirror===mirror) break;
            else {
                var omirror=subject.mirror;
                fdjtLog.warn("Inconsistent mirrors for %s: +%s and -%s",
                             subject,mirror,omirror);
                omirror.mirror=false;}
            if (mirror.mirror) {
                var oinvmirror=mirror.mirror;
                fdjtLog.warn("Inconsistent mirrors for %s: +%s and -%s",
                             mirror,subject,oinvmirror);
                omirror.mirror=false;}
            subject.mirror=mirror; mirror.mirror=subject;
            break;}
        case '.': {
            var brk=findBreak(clause,'=');
            if (!(brk))
                throw {name: 'InvalidClause', irritant: clause};
            var role=this.KNode(clause.slice(1,brk));
            var object=this.KNode(clause.slice(brk+1));
            this.add(role.dterm,object);
            object.add('genls',role);
            break;}
        case '~': {
            var hook=clause.slice(1);
            subject.addTerm(hook,'hooks');
            if (knodule.hooks[hook])
                knodule.hooks[hook].push(subject);
            else knodule.hooks[hook]=[subject];
            break;}
        default: {
            var brk=findBreak(clause,'=');
            if (brk>0) {
                var role=this.KNode(clause.slice(0,brk));
                var object=this.KNode(clause.slice(brk+1));
                subject.add(role.dterm,object);
                object.add('genls',role);}
            else subject.addTerm(clause);}}
        return subject;}
    Knodule.prototype.handleClause=handleClause;

    function handleSubjectEntry(entry){
        var clauses=segmentString(entry,"|");
        var subject=this.KNode(clauses[0]);
        if (this.trace_parsing>2)
            fdjtLog("Processing subject entry %s %o %o",
                    entry,subject,clauses);
        var i=1; while (i<clauses.length)
            this.handleClause(clauses[i++],subject);
        if (this.trace_parsing>2)
            fdjtLog("Processed subject entry %o",subject);
        return subject;}
    Knodule.prototype.handleSubjectEntry=handleSubjectEntry;

    function handleEntry(entry){
        var weak=false;
        entry=trimspace(entry);
        if (entry.length===0) return false;
        var starpower=entry.search(/[^*]/);
        if (starpower>0) entry=entry.slice(starpower);
        var bar=fdjtString.findSplit(entry,'|');
        var atsign=fdjtString.findSplit(entry,'@');
        var subject;
        if ((atsign>0) && ((bar<0)||(atsign<bar))) {
            // This is a foreign dterm reference (+def), e.g.
            //  dog@beingmeta.com|doggy|^mammal
            var term=entry.slice(0,atsign);
            var knostring=((bar<0) ? (entry.slice(atsign+1)) :
                           (entry.slice(atsign+1,bar)));
            var knodule=Knodule(knostring);
            subject=((bar<0)?(knodule.KNode(term)):
                     (knodule.handleEntry(term+entry.slice(bar))));}
        else subject=this.handleSubjectEntry(entry);
        if (starpower) {
            var id=subject._id;
            var prime=this.prime; var scores=this.primescores;
            var score;
            if (score=scores[id]) {
                if (starpower>score) scores[id]=starpower;}
            else {
                prime.push(id); scores[id]=starpower;}}
        return subject;}
    Knodule.prototype.handleEntry=handleEntry;

    function handleEntries(block){
        if (typeof block === "string") {
            var nocomment=stripComments(block);
            var segmented=segmentString(nocomment,';');
            if (this.trace_parsing>1)
                fdjtLog("Handling %d entries",segmented.length);
            return this.handleEntries(segmented);}
        else if (block instanceof Array) {
            var results=[];
            var i=0; while (i<block.length) {
                results[i]=this.handleEntry(block[i]); i++;}
            return results;}
        else throw {name: 'TypeError', irritant: block};}
    Knodule.prototype.handleEntries=handleEntries;

    Knodule.prototype.def=handleSubjectEntry;

    Knodule.def=function(string,kno){
        if (!(kno)) kno=Knodule.knodule;
        return kno.def(string);};

    Knodule.prototype.trace_parsing=0;

    return Knodule;})();

var KNode=Knodule.KNode;


var KnoduleIndex=(function(){
    var fdjtString=fdjt.String;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM, fdjtID=fdjt.ID;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB;

    var isobject=fdjtKB.isobject;
    var objectkey=fdjtKB.objectkey;
    
    function KnoduleIndex(knodule) {
        if (knodule) this.knodule=knodule;
        this.items={}; this.tags={}; this._alltags=[]; this._allitems=[];
        this._ranked=false; this.ranks=false;
        this.tagscores={}; this.tagfreqs={}; this.maxscore=0; this.maxfreq=0;
        return this;}
    
    KnoduleIndex.prototype.add=function(item,tag,weight,kno){
        var itemkey=((typeof item === 'object')?(objectkey(item)):(item));
        if ((typeof tag === 'string')&&(kno)) tag=kno.probe(tag)||tag;
        var tagkey=(((typeof tag === 'string')&&(tag))||
                    ((tag.tagString)&&(tag.tagString()))||
                    (objectkey(tag)));
        var items=this.items, tags=this.tags;
        var alltags=this._alltags, allitems=this._allitems;
        var tagfreqs=this.tagfreqs;
        var tagscores=this.tagscores;
        var itemv=false, tagv=false, iscores=false, tscores=false;
        if ((weight)&&(typeof weight !== 'number')) weight=1;
        else if (!(weight)) weight=0;
        // items maps tagkeys to arrays of items
        if (items.hasOwnProperty(tagkey)) {
            itemv=items[tagkey];
            iscores=itemv.scores;
            if (iscores[itemkey])
                iscores[itemkey]+=weight;
            else {
                itemv.push(itemkey);
                iscores[itemkey]=weight;}
            var freq=tagfreqs[tagkey]+1;
            if (freq>this.maxfreq) this.maxfreq=freq;
            tagfreqs[tagkey]=freq;}
        else {
            items[tagkey]=itemv=[itemkey];
            itemv.scores={};
            itemv.scores[itemkey]=weight;
            tagfreqs[tagkey]=1;
            if (this.maxfreq===0) this.maxfreq=1;
            alltags.push(tagkey);
            if (tag!==tagkey) alltags[tagkey]=tag;}
        // Initialize the scores property
        // tags maps items to their tags
        if (tags.hasOwnProperty(itemkey)) {
            tagv=tags[itemkey];
            tscores=tagv.scores;
            if (tscores[tagkey])
                tscores[tagkey]+=weight||1;
            else {
                tagv.push(tagkey);
                tscores[tagkey]=weight||1;}}
        else {
            tags[itemkey]=tagv=[tagkey];
            tagv.scores={tagkey:weight||1};
            allitems.push(itemkey);}
        if (weight) {
            var tscores=tagv.scores;
            if (!(tscores)) tagv.scores=tscores={};
            var tagscore=(tagscores[tagkey]||0)+weight;
            tagscores[tagkey]=tagscore;
            if (tagscore>this.maxscore) this.maxscore=tagscore;
            if (tscores[itemkey]) tscores[itemkey]+=weight;
            else tscores[itemkey]=weight;}
        if ((tag)&&(tag._always)) {
            var always=tag._always;
            var i=0; var len=always.length;
            while (i<len) {
                var genl=always[i++];
                var gkey=(((typeof genl === 'string')&&(genl))||
                          ((genl.tagString)&&(genl.tagString()))||
                          (objectkey(genl)));
                this.add(itemkey,gkey,((weight)&&(weight>i)&&(weight-i)));}}
        // Invalidate ranks.  In the future, this might do something
        // more incremental
        this.ranks=false;};

    var Set=fdjtKB.Set;

    KnoduleIndex.prototype.freq=function(tag){
        if (this.items.hasOwnProperty(tag)) {
            var set=this.items[tag]=Set(this.items[tag]);
            return set.length;}
        else return 0;};
    KnoduleIndex.prototype.find=function(tag){
        if (this.items.hasOwnProperty(tag)) return this.items[tag];
        else return [];};
    
    KnoduleIndex.prototype.rankTags=function(){
        if (this.ranks) return this.ranks;
        else {
            var ranked=[].concat(this._alltags);
            var ranks={};
            var tagscores=this.tagscores, tagfreqs=this.tagfreqs;
            ranked.sort(function(tag1,tag2){
                var tscore1=tagscores[tag1], tscore2=tagscores[tag2];
                if ((tscore1)&&(tscore2)) {
                    if (tscore1>tscore2) return -1;
                    else if (tscore1<tscore2) return 1;}
                else if (tscore1) return -1;
                else if (tscore2) return 1;
                /* Nothing based on tagscores */
                var freq1=tagfreqs[tag1], freq2=tagfreqs[tag2];
                if (freq1>freq2) return -1;
                else if (freq2>freq1) return 1;
                else return 0;});
            tagscores._maxscore=this.maxscore;
            var i=0; var lim=ranked.length;
            while (i<lim) {ranks[ranked[i]]=i; i++;}
            this._ranked=ranked;
            this.ranks=ranks;
            return ranks;}};

    // This takes an array of tags (with possible .scores)
    //  and combines them into an array with unique elements
    //  and combined scores
    function combineTags(tagsets,weights){
        var tags=[]; var scores={};
        var tagscores=[];
        var i=0; var lim=tagsets.length;
        while (i<lim) {
            if ((tagsets[i])&&(tagsets[i].scores))
                tagscores.push(tagsets[i].scores);
            i++;}
        var i=0; var lim=tagsets.length;
        while (i<lim) {
            var taglist=tagsets[i++];
            if (!(taglist)) continue;
            var j=0; var jlim=taglist.length;
            while (j<jlim) {
                var tag=taglist[j]; var score=0;
                if (typeof tag !== 'string') tag=tag._qid||tag;
                if (!(scores[tag])) {
                    tags.push(tag);
                    var k=0; var klim=tagscores.length;
                    while (k<klim) {
                        var tscore=tagscores[k++][tag];
                        if (tscore) score=score+tscore;}}
                scores[tag]=(((weights)&&(weights[i]))||1)+score;
                j++;}}
        tags.scores=tagscores;
        return tags;}
    KnoduleIndex.combineTags=combineTags;
    KnoduleIndex.prototype.combineTags=combineTags;
    Knodule.combineTags=combineTags;

    KnoduleIndex.Trace={clouds:false};

    return KnoduleIndex;})();


/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ##################### knodules/query.js ####################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file provides a Javascript/ECMAScript of KNODULES, 
     a lightweight knowledge representation facility.

   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library is built on the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use, modification and redistribution of this program is permitted
    under the GNU General Public License (GPL) Version 2:

          http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

    Use and redistribution (especially embedding in other
      CC licensed content) is permitted under the terms of the
      Creative Commons "Attribution-NonCommercial" license:

          http://creativecommons.org/licenses/by-nc/3.0/ 

    Other uses may be allowed based on prior agreement with
      beingmeta, inc.  Inquiries can be addressed to:

       licensing@biz.beingmeta.com

   Enjoy!

*/

KnoduleIndex.Query=
    (function(){
        var fdjtString=fdjt.String;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;
        
        function Query(index,query) {
            if (!(index)) return this;
            if (!(this instanceof Query)) return new Query(this,index);
            if (typeof query === "string") query=this.string2query(query);
            var qstring=this.query2string(query);
            var cached=((index.cache)&&(index.cache[qstring]));
            if (cached) return cached;
            // Construct the results object
            this.index=index; this._query=query; this._qstring=qstring;
            this._results=[]; this._scores={}; this._counts={};
            if (query.length===0) {
                this._refiners={_results: index._alltags};
                return this;}
            this._start=new Date();
            // Do the search
            this.do_search();
            this._done=new Date();
            if (this._refiners) {}
            else this._refiners=this.get_refiners();
            this._refined=new Date();
            if (this.index.trace)
                fdjtLog("In %f secs, %o yielded %d results: %o",
                        ((this._done.getTime()-this._start.getTime())/1000),
                        query,result._results.length,result._results);
            if (this.index.trace)
                fdjtLog("In %f secs, query %o yielded %d refiners: %o",
                        ((this._refined.getTime()-this._done.getTime())/1000),
                        query,result._refiners._results.length,
                        result._refiners._results);
            if (index.cache) index.cache[qstring]=this;
            return this;}
        Knodule.Query=Query;
        KnoduleIndex.Query=Query;
        KnoduleIndex.prototype.Query=function(query){
            return new Query(this,query);}

        // Queries are sets of terms and interchangable between vectors
        // and strings with semi-separated tag names

        function string2query(string) {
            if (typeof string === "string") {
                var lastsemi=string.lastIndexOf(';');
                if (lastsemi>0)
                    return string.slice(0,lastsemi).split(';');
                else return [];}
            else return string;}
        Query.string2query=string2query;
        Query.prototype.string2query=string2query;

        function query2string(query){
            if (!(query)) query=this.query;
            if ((typeof query === "object") && (query instanceof Array)) {
                if (query.length===0) return "";
                else {
                    var i=0, lim=query.length; var result="";
                    while (i<lim) {
                        if (i>0) result=result+";";
                        var elt=query[i++], id=false;
                        if (typeof elt === 'string')
                            result=result+elt;
                        else if (id=((elt._qid)||(elt.oid)||
                                     (elt.uuid)||(elt._id)))
                            result=result+id;
                        else result=result+elt;}
                    return result;}}
            else return query;}
        Query.prototype.cache={};
        Query.prototype.query2string=query2string;
        Query.prototype.getString=query2string;
        Query.query2string=query2string;

        function do_search(results) {
            if (!(results)) results=this;
            var query=results._query;
            var scores=results._scores; var counts=results._counts;
            var matches=[]; var counted=[];
            var allitems=[];
            // A query is an array of terms.  In a simple query,
            // the results are simply all elements which are tagged
            // with all of the query terms.  In a linear scored query,
            // a score is based on how many of the query terms are matched,
            // possibly with weights based on the basis of the match.
            var i=0, lim=query.length; while (i<lim) {
                var term=query[i];
                if (typeof term !== 'string')
                    term=(((term.tagString)&&(term.tagString()))||
                          term._id||term.dterm);
                var items=matches[i]=results.index.find(term);
                var j=0; var jlim=items.length;
                while (j<jlim) {
                    var item=items[j++];
                    // if (scores[item]) scores[item]++; else scores[item]=1;
                    if (counts[item]) counts[item]++;
                    else {counted.push(item); counts[item]=1;}}
                if (results.index.trace)
                    fdjtLog("Query element '%s' matches %d items",
                            term,items.length);
                i++;}
            if (query.length===1) allitems=fdjtKB.Set(matches[0]);
            else {
                var i=0, lim=counted.length;
                while (i<lim) {
                    var item=counted[i++];
                    if (counts[item]>=2) allitems.push(item);}}
            // Now we apply the tagscores where they're assigned
            results._results=allitems;
            var seen_tags={};
            i=0; var n_items=allitems.length;
            while (i<n_items) {
                var item=allitems[i++];
                var tags=results.index.tags[item];
                var tagscores=tags.scores;
                var j=0; var lim=query.length; var score=0;
                if (tagscores) {
                    while (j<lim) {
                        var tag=query[j++];
                        if (!(seen_tags[tag])) seen_tags=true;
                        if (tagscores[tag])
                            score=score+(tagscores[tag]*2);
                        else score++;}}
                scores[item]=score;}
            return results;}
        Query.do_search=do_search;
        Query.prototype.do_search=function() { return do_search(this);};

        function get_refiners(results) {
            if (!(results)) results=this;
            // This gets terms which can refine this search, particularly
            // terms which occur in most of the results.
            if (results._refiners) return results._refiners;
            var query=results._query;
            var qterms=[];
            var rvec=(results._results);
            var refiners={};
            var scores=(results._scores)||false; var freqs={};
            var max_score=0, max_freq=0;
            var alltags=[];
            var i=0; while (i<query.length) {
                var q=query[i++];
                qterms.push(q);
                if (q.dterm) qterms.push(q.dterm);
                if (q.dterms) {
                    var dterms=q.dterms; var j=0;
                    while (j<dterms.length) qterms.push(dterms[j++]);}}
            var i=0, lim=rvec.length; while (i<lim) {
                var item=rvec[i++];
                var item_score=((scores)&&(scores[item]));
                var tags=results.index.tags[item]||[];
                if (typeof tags === 'string') tags=[tags];
                if (tags) {
                    var j=0; var len=tags.length; while (j<len) {
                        var tag=tags[j++]; var freq, score;
                        // If the tag is already part of the query, we
                        // ignore it.
                        if (fdjtKB.contains(qterms,tag)) {}
                        // If the tag has already been seen, we
                        // increase its frequency and its general
                        // score
                        else if (freq=freqs[tag]) {
                            freq++; freqs[tag]=freq;
                            if (freq>max_freq) max_freq=freq;
                            if (item_score) {
                                var score=(refiners[tag]||0)+item_score;
                                if (score>max_score) max_score=score;
                                refiners[tag]=score;}}
                        else {
                            // If the tag hasn't been counted, we
                            // initialize its frequency and score,
                            // adding it to the list of all the tags
                            // we've found
                            alltags.push(tag); freqs[tag]=1;
                            if (max_score<item_score) max_score=item_score;
                            if (item_score) refiners[tag]=item_score;}}}}
            refiners._count=freqs._count=alltags.length;
            refiners._freqs=freqs;
            refiners._maxfreq=max_freq;
            refiners._maxscore=max_score;
            results._refiners=refiners;
            alltags.sort(function(x,y) {
                if (freqs[x]>freqs[y]) return -1;
                else if (freqs[x]===freqs[y]) return 0;
                else return 1;});
            refiners._results=alltags;
            if ((results.index.trace)&&(results.index.trace>1))
                fdjtLog("Refiners for %o are (%o) %o",
                        results._query,refiners,alltags);
            return refiners;}
        Query.get_refiners=get_refiners;
        Query.prototype.get_refiners=function() {return get_refiners(this);};

        return Query;
    })();


/* Emacs local variables
;;;  Local variables: ***
;;;  compile-command: "cd ..; make" ***
;;;  indent-tabs-mode: nil ***
;;;  End: ***
*/

/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ##################### dules/html.js ####################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file provides for HTML documents using KNODULES, including
   the extraction and processing of embedded KNODULE definitions
   or references and interaction with interactive parts of the
   FDJT library.

   For more information on knodules, visit www.knodules.net
   This library is built on the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification and redistribution of this program is permitted
   under the GNU General Public License (GPL) Version 2:

   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@biz.beingmeta.com

   Enjoy!

*/

(function(){

    var fdjtString=fdjt.String;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    var addClass=fdjtDOM.addClass;

    /* Getting knowdes into HTML */

    var KNode=Knodule.KNode;
    Knodule.KNode.prototype.toDOM=
        Knodule.KNode.prototype.toHTML=function(lang){
            var spec=((this.prime)?("span.dterm.prime"):
                      (this.weak)?("span.dterm.weak"):
                      "span.dterm");
            var span=fdjtDOM(spec,this.dterm);
            if (this.gloss) 
                span.title=fdjtString.strip_markup(this.gloss);
            span.dterm=this.dterm;
            return span;};
    
    /* Making DTERM descriptions */

    function html2dom(html){
        if (!(html)) return false;
        else if (typeof html === 'string') {
            if (html[0]==='<') return fdjtDOM(html);
            else fdjtDOM("span",html);}
        else return html;}

    function knoduleHTML(arg,knodule,varname,lang){
        var checkbox=false; var variations=[];
        var knode=false, text=false, tag=false, title=false;
        var def=false, obj=false;
        // If needed, provide a default knodule based on the current
        // document
        var default_knodule=knodule||Kindule.current||
            (Knodule.current=(new Knodule(location.href)));
        if (typeof arg === 'string') {
            // Try to convert a string arg into a knode
            if (arg.indexOf('|')>0) {
                // We'll save the def to attach to any tag string
                var pos=arg.indexOf('|'); def=arg.slice(pos);
                obj=knode=default_knodule.handleSubjectEntry(arg);}
            else if (arg.indexOf('@')>0)
                obj=knode=default_knodule.ref(arg);
            else knode=default_knodule.probe(arg);}
        else if (arg instanceof KNode) obj=knode=arg;
        else obj=arg;
        if ((knode)&&(!(knode._init))) knode.load();
        // A non-false language arg means generate a FDJT completion
        // node; if the language arg isn't a string, just use the
        // default knodule's default language to generate the text.
        if ((lang)&&(typeof lang !== 'string')) {
            if (default_knodule) lang=default_knodule.language;
            else lang='EN';}
        // This figures out the core text for the DOM node which is
        // returned.
        text=((knode)?
              // This should probably look for a dterm in the target
              // language, but we'll skip that for now
              (knode.dterm):
              ((obj)?
               // Use the toHuman, toDOM, and toHTML methods when
               // available (in that order)
               (((obj.toDOM)&&(obj.toDOM()))||
                ((obj.toHTML)&&(html2dom(obj.toHTML())))||
                ((obj.toHuman)&&(html2dom(obj.toHuman(lang))))||
                obj.name||obj._name||obj._id||obj):
               arg));
        if ((knode)&&(knode.literal)) text="“"+text+"”";
        // Figure out the 'tag' which is a string reference to the
        //  value
        tag=((obj)&&(obj.tagString)&&(obj.tagString()))||
            ((knode)&&(knode.knodule===knodule)&&(knode.dterm))||
            ((knode)&&(knode.dterm+"@"+knode.knodule.name))||
            (obj._qid)||(obj.oid)||(obj.uuid)||
            ((obj._id)&&(obj.pool)&&
             (obj._id+"@"+obj.pool.name));
        if ((tag)&&(def)) tag=tag+def;
        if ((varname)&&(tag)) {
            checkbox=fdjtDOM(
                {tagName: "INPUT",type: "CHECKBOX",
                 name: varname,value: tag});}
        // Add variations for synonyms in the given language.
        if ((lang)&&(knode)) {
            var dterm=knode.dterm;
            var synonyms=knode[lang];
            if ((synonyms)&&(typeof synonyms === 'string'))
                synonyms=[synonyms];
            if (synonyms) {
                var i=0; while (i<synonyms.length) {
                    var synonym=synonyms[i++];
                    if (synonym===dterm) continue;
                    var variation=fdjtDOM("span.variation",synonym,"=");
                    variation.setAttribute("key",synonym);
                    variations.push(variation);}}}
        // This is the actual returned DOM node
        var span=fdjtDOM("span",checkbox,variations,text);
        // Declare as a dterm
        if (knode) addClass(span,"dterm");
        // Say if it's a "weak" dterm
        if ((knode)&&(knode.weak)) addClass(span,"weak");
        // Set up as a clickable checkspan
        if (varname) addClass(span,"checkspan");
        if (lang) {
            // Set up as a FDJT completion
            fdjtDOM.addClass(span,"completion");
            if (typeof text === 'string')
                span.setAttribute('key',text);
            else if ((obj)&&(obj.dterm))
                span.setAttribute('key',obj.dterm);
            else if ((obj)&&(obj.name))
                span.setAttribute('key',obj.name);
            else if (tag) span.setAttribute('key',tag);
            else {}
            if (tag) span.setAttribute('value',tag);}
        if (!(knode)) fdjtDOM.addClass(span,"rawterm");
        var from=(((knode)&&(knode.pool.description))?
                  (" (from "+knode.pool.description+")"):(""))
        if ((knode)&&(knode.gloss)) title=knode.gloss+from;
        else if ((knode)&&(knode.about)) title=knode.about+from;
        else if ((obj)&&(obj.about)) title=obj.about+from;
        else if ((knode)&&(knode.dterm)) title=knode.dterm+from;
        else if (tag) title=tag+from;
        else {}
        if ((knode)&&(knode._always)) {
            var seen={};
            var always=knode._always;
            var i=0, lim=always.length;
            while (i<lim) {
                var a=always[i++];
                if (seen[a._qid]) continue;
                title=title+" ^"+a.dterm;}}
        if (tag) span.setAttribute('tag',tag);
        span.title=title;
        return span;};
    Knodule.HTML=knoduleHTML;
    Knodule.prototype.HTML=function(dterm){
        var args=new Array(arguments.length+1);
        args[0]=arguments[0]; args[1]=this;
        var i=1; var lim=arguments.length; while (i<lim) {
            args[i+1]=arguments[i]; i++;}
        return knoduleHTML.apply(this,args);};

    /* Getting Knodules out of HTML */

    var _knodulesHTML_done=false;

    function KnoduleLoad(elt,knodule){
        var src=((typeof elt === 'string')?(elt):(elt.src));
        var text=fdjtAjax.getText(src);
        var knowdes=knodule.handleEntries(text);
        if ((knodule.trace_load)||(Knodule.trace_load))
            fdjtLog("Parsed %d entries from %s",knowdes.length,elt.src);}

    function knoduleSetupHTML(knodule){
        if (!(knodule)) knodule=Knodule(document.location.href);
        var doing_the_whole_thing=false;
        var start=new Date();
        var links=fdjtDOM.getLinks("SBOOK.knodule",true,true).
            concat(fdjtDOM.getLink("knodule",true,true));
        var i=0; while (i<links.length) KnoduleLoad(links[i++],knodule);
        var elts=fdjtDOM.getMeta("SBOOK.knowdef");
        var i=0; while (i<elts.length) {
            var elt=elts[i++];
            if (elt.name==="KNOWDEF") knodule.handleEntry(elt.content);}
        elts=document.getElementsByTagName("META");
        var i=0; while (i<elts.length) {
            var elt=elts[i++];
            if (elt.name==="KNOWDEF") knodule.handleEntry(elt.content);}
        elts=document.getElementsByTagName("SCRIPT");
        i=0; while (i<elts.length) {
            var elt=elts[i++];
            var lang=elt.getAttribute("language");
            var type=elt.type;
            if ((type==="text/knodule")||(type==="application/knodule")||
                ((lang) &&
                 ((lang==="knodule") ||(lang==="KNODULE")||
                  (lang==="knowlet"||(lang==="KNOWLET"))))) {
                if (elt.src) KnoduleLoad(elt,knodule);
                else if (elt.text) {
                    var txt=elt.text;
                    var cdata=txt.search("<!\\[CDATA\\[");
                    if (cdata>=0) {
                        var cdend=txt.search("]]>");
                        txt=txt.slice(cdata+9,cdend);}
                    var dterms=knodule.handleEntries(txt);
                    if ((knodule.trace_load)||(Knodule.trace_load))
                        fdjtLog("Parsed %d inline knodule entries",
                                dterms.length);}
                else {}}}
        var finished=new Date();
        if ((knodule.trace_load)||(Knodule.trace_load))
            fdjtLog("Processed knodules in %fs",
                    ((finished.getTime()-start.getTime())/1000));}
    Knodule.HTML.Setup=knoduleSetupHTML;

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ######################### fdjt/codex.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file is a part of the FDJT web toolkit (www.fdjt.org)
   It implements a method for breaking narrative HTML content
   across multiple pages, attempting to honor page break constraints,
   etc.

   Check out the 'mini manual' at the bottom of the file or read the
   code itself.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use, modification, and redistribution of this program is permitted
   under either the GNU General Public License (GPL) Version 2 (or any
   later version) or under the GNU Lesser General Public License
   (version 3 or later).

   These licenses may be found at www.gnu.org, particularly:
   http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   http://www.gnu.org/licenses/lgpl-3.0-standalone.html

   Use and redistribution (especially embedding in other CC licensed
   content) is also permitted under the terms of the Creative Commons
   "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

if (window) {
    if (!(window.fdjt)) window.fdjt={};}
else if (typeof fdjt === "undefined") fdjt={};
else {}

fdjt.CodexLayout=
    (function(){

	var fdjtDOM=fdjt.DOM;
	var fdjtString=fdjt.String;
	var fdjtLog=fdjt.Log;
	var fdjtTime=fdjt.Time;
	var fdjtState=fdjt.State;
	var fdjtID=fdjt.ID;

	var hasContent=fdjtDOM.hasContent;
	var getGeometry=fdjtDOM.getGeometry;
	var getDisplay=fdjtDOM.getDisplay;
	var hasParent=fdjtDOM.hasParent;
	var getParent=fdjtDOM.getParent;
	var getStyle=fdjtDOM.getStyle;
	var parsePX=fdjtDOM.parsePX;
	var geomString=fdjtDOM.geomString;
	var insertBefore=fdjtDOM.insertBefore;
	var hasClass=fdjtDOM.hasClass;
	var addClass=fdjtDOM.addClass;
	var dropClass=fdjtDOM.dropClass;
	var swapClass=fdjtDOM.swapClass;
	var nextElt=fdjtDOM.nextElt;
	var forward=fdjtDOM.forward;
	var TOA=fdjtDOM.toArray;
	var getElementValue=fdjtDOM.getElementValue;
	
	var floor=Math.floor;

	function appendChildren(node,children,start){
	    var lim=children.length; var i=(start)||0;
	    var frag=document.createDocumentFragment();
	    while (i<lim) {
		if (children[i])
		    frag.appendChild(children[i++]);
		else i++;}
	    node.appendChild(frag);}

	function getGeom(elt,root,extra){
	    var top = elt.offsetTop;
	    var left = elt.offsetLeft;
	    var width=elt.offsetWidth;
	    var height=elt.offsetHeight;
	    var rootp=((root)&&(root.offsetParent));
	    var style=((extra)&&(getStyle(elt)));

	    if (elt===root) 
		return {left: 0,top: 0,width:width,height: height};
	    elt=elt.offsetParent;
	    while (elt) {
		if ((root)&&((elt===root)||(elt===rootp))) break;
		top += elt.offsetTop;
		left += elt.offsetLeft;
		elt=elt.offsetParent;}
	    
	    if (extra) {
		var t_margin=parsePX(style.marginTop);
		var r_margin=parsePX(style.marginRight);
		var b_margin=parsePX(style.marginBottom);
		var l_margin=parsePX(style.marginLeft);
		var t_padding=parsePX(style.paddingTop);
		var r_padding=parsePX(style.paddingRight);
		var b_padding=parsePX(style.paddingBottom);
		var l_padding=parsePX(style.paddingLeft);
		var t_border=parsePX(style.borderTopWidth);
		var r_border=parsePX(style.borderRightWidth);
		var b_border=parsePX(style.borderBottomWidth);
		var l_border=parsePX(style.borderLeftWidth);
		var outer_width=width+l_margin+r_margin;
		var outer_height=height+t_margin+b_margin;
		var inner_width=width-(l_border+l_padding+r_border+r_padding);
		var inner_height=height-(t_border+t_padding+b_border+b_padding);
		var lh=style.lineHeight, fs=style.fontSize, lhpx=false;
		if (lh==="normal") lhpx=parsePX(fs);
		else if (lh.search(/px$/)>0) lhpx=parsePX(lh);
		else if (lh.search(/%$/)>0) 
		    lhpx=(parseFloat(lh.slice(0,-1))/100)*(parsePX(fs));
		else lhpx=parsePX(fs);
		return {left: left, top: top, width: width,height: height,
			right:left+width,bottom:top+height,
			top_margin: t_margin, bottom_margin: b_margin,
			left_margin: l_margin, right_margin: r_margin,
			outer_height: outer_height,outer_width: outer_width,
			inner_height: inner_height,outer_width: inner_width,
			line_height: lhpx};}
	    else return {left: left, top: top, width: width,height: height,
			 right:left+width,bottom:top+height};}

	/* Node testing */

	var spacechars=" \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000\uf3ff";
	
	function isEmpty(string){
	    if (typeof string === "string")  {
		var i=0; var lim=string.length;
		if (lim===0) return true;
		while (i<lim) {
		    if (spacechars.indexOf(string[i])>=0) i++;
		    else return false;}
		return true;}
	    else return false;}
	
	    function optimizeLayoutRule(rule,dflt){
		if (!(rule)) return rule;
		else if (typeof rule === "string") {
		    if ((rule[0]===".")&&
			(rule.slice(1).search(/\.|#|\[/)<0)) 
			return new RegExp("\\b"+rule.slice(1)+"\\b");
		    else return new Selector(rule);}
		else if (rule instanceof RegExp) return rule;
		else if (rule.match) return rule;
		else if (rule.length) {
		    var newrules=[]; var firstrules=[];
		    var classes=[]; var selectors=[];
		    var i=0, lim=rule.length;
		    while (i<lim) {
			var r=rule[i++];
			if (typeof r !== "string") newrules.push(rule);
			else if (r[0]===".") {
			    if (r.slice(1).search(/\.|#|\[/)>=0)
				// complex selector (not just a classname)
				selectors.push(r);
			    else classes.push(r.slice(1));}
			else if ((r[0]==="#")||(r[0]==="["))
			    selectors.push(r);
			else classes.push(r);}
		    if (classes.length)
			firstrules.push(new RegExp("\\b("+classes.join("|")+")\\b"));
		    if (selectors.length)
			firstrules.push(new fdjtDOM.Selector(selectors.join(", ")));
		    return firstrules.concat(newrules);}
		else return rule;}

	function testNode(node,test) {
	    var tests;
	    if (!(test)) return true;
	    if (typeof test === 'string') tests=[test];
	    else if (test instanceof Array) tests=test;
	    else tests=[test];
	    var i=0; var lim=tests.length;
	    while (i<lim) {
		var atest=tests[i++];
		if (node===test) return true;
		else if (atest instanceof RegExp) {
		    if (!(node.className)) continue;
		    // Handle inadvertant use of selector syntax
		    if (node.className.search(atest)>=0) return true;}
		else if (typeof atest === 'string') {
		    if (!(node.className)) continue;
		    // Handle inadvertant use of selector syntax
		    if (atest[0]==='.') atest=atest.slice(1);
		    var classrx=new RegExp("\\b"+atest+"\\b");
		    if (node.className.search(classrx)>=0) return true;}
		else if ((atest.match)&&(atest.match(node)))
		    // This should get most versions of CSS selectors
		    return true;
		else {}}
	    return false;}

	function insideBounds(box){
	    var top=false, right=false, bottom=false, left=false;
	    function gatherBounds(node){
		if ((!(node))||(node.nodeType!==1)) return;
		var style=getStyle(node); var children;
		if ((style.position==='static')&&
		    ((node.tagName==='img')||(style.display!=='inline'))) {
		    var geom=getGeom(node,box);
		    if ((left===false)||(geom.left<left)) left=geom.left;
		    if ((top===false)||(geom.top<top)) top=geom.top;
		    if ((right===false)||(geom.right>right)) right=geom.right;
		    if ((bottom===false)||(geom.bottom>bottom))
			bottom=geom.bottom;}
		if ((children=node.childNodes)&&(children.length)) {
		    var i=0; var len=children.length;
		    while (i<len) gatherBounds(children[i++]);}}
	    var nodes=box.childNodes;
	    var j=0; var jlim=nodes.length;
	    while (j<jlim) gatherBounds(nodes[j++]);
	    return { left: left, top: top, right: right, bottom: bottom,
		     width: right-left, height: bottom-top};}
	
	var alerted=false;
	function default_logfn() {
	    if (alerted) return;
	    alert("Layout needs to log but cannot");
	    alerted=true;}
	
	/* Duplicating nodes */

	var tmpid_count=1;

	// This recreates a node and it's DOM context (containers) on
	//  a new page, calling itself recursively as needed
	function dupContext(node,page,dups,crumbs){
	    if ((node===document.body)||(node.id==="CODEXCONTENT")||
		(node.id==="CODEXROOT")||(hasClass(node,"codexroot"))||
		(hasClass(node,"codexpage")))
		return false;
	    else if (hasParent(node,page)) return node;
	    else if ((node.className)&&
		     (node.className.search(/\bcodexwraptext\b/)>=0))
		// We don't bother duplicating text wrapping convenience
		//  classes
		return dupContext(node.parentNode,page,dups,crumbs);
	    // Now we actually duplicate it.  
	    var id=node.id;
	    if (!(id)) id=node.getAttribute("data-baseid");
	    // If it doesn't have an ID, we give it one, because we'll want
	    //  to refer to it later while wanting to avoid DOM cycles
	    if (!(id)) id=node.id="CODEXTMPID"+(tmpid_count++);
	    else {
		// See if it's already been duplicated
		var dup=dups[id];
		if ((dup)&&(hasParent(dup,page))) return dup;}
	    // Duplicate it's parent
	    var copy=node.cloneNode(false);
	    var parent=dupContext(node.parentNode,page,dups,crumbs);
	    var nodeclass=node.className||"";
	    var duplicated=(nodeclass.search(/\bcodexdup.*\b/)>=0);
	    // Jigger the class name
	    copy.className=
		((nodeclass.replace(/\b(codexrelocated|codexdup.*)\b/,""))+
		 " codexdup").replace(/\s+/," ").trim();
	    if (!(duplicated)) {
		if (nodeclass.search(/\bcodexdupstart\b/)<0)
		    node.className=nodeclass+" codexdupstart";}
	    // If the original had an ID, save it in various ways
	    if (id) {
		copy.codexbaseid=id;
		copy.setAttribute("data-baseid",id);
		copy.id=null;}
	    // Record the copy you've made (to avoid recreation)
	    dups[id]=copy;
	    // If it's got a copied context, append it to the context;
	    //   otherwise, just append it to the page
	    if (parent) parent.appendChild(copy);
	    else page.appendChild(copy);
	    return copy;}

	/* Moving nodes */

	var codex_reloc_serial=1;
	
	function getFirstContent(node){
	    var child=node.firstChild;
	    while (child) {
		if (child.nodeType===3) {
		    if (!(isEmpty(child.nodeValue))) return child;}
		else if (child.nodeType!==1) {}
		else return child;
		child=child.nextSibling;}
	    return false;}
		    
	// This moves a node into another container, leaving
	// a back pointer for restoration
	function moveNode(arg,into,blockp,crumbs){
	    var baseclass; var node=arg;
	    if (hasParent(node,into)) return node;
	    if (node.nodeType===1) baseclass=node.className;
	    else if (node.nodeType===3) {
		// Wrap text nodes in elements before moving
		var wrapnode=fdjtDOM(
		    ((blockp)?"div.codexwraptext":"span.codexwraptext"));
		if (node.parentNode)
		    node.parentNode.replaceChild(wrapnode,node);
		wrapnode.appendChild(node);
		baseclass="codexwraptext";
		node=wrapnode;}
	    if ((node.parentNode)&&((!(node.id))||(!(crumbs[node.id])))) {
		// If the node has a parent and hasn't been moved before,
		//  we leave a "crumb" (a placeholder) in the original
		//  location.
		if (!(node.id)) node.id="CODEXTMPID"+(tmpid_count++);
		// Record origin information; we'll use this to revert
		//  the layout if we need to (for example, before
		//  laying out again under different constraints)
		var crumb=document.createTextNode("");
		crumbs[node.id]=crumb;
		if (baseclass) node.className=baseclass+" codexrelocated";
		else node.className="codexrelocated";
		node.parentNode.replaceChild(crumb,node);}
	    into.appendChild(node);
	    return node;}
	
	// This moves a node onto a page, recreating (as far as
	// possible) its original DOM context on the new page.
	function moveNodeToPage(node,page,dups,crumbs){
	    if (hasParent(node,page)) return node;
	    var scan=node, parent=scan.parentNode;
	    // If we're moving a first child, we might as well move the parent
	    while ((parent)&&
		   (parent!==document.body)&&
		   (parent!==Codex.content)&&
		   (!(hasClass(parent,"codexpage")))&&
		   (scan===getFirstContent(parent))) {
		scan=parent; parent=scan.parentNode;}
	    var istop=(!hasContent(page));
	    if ((!(parent))||(parent===document.body)||
		(parent.id==="CODEXCONTENT")||(parent.id==="CODEXROOT")||
		(hasClass(parent,"codexroot"))||(hasClass(parent,"codexpage"))) {
		// You don't need to dup the parent on the new page
		moveNode(scan,page,false,crumbs);}
	    else {
		var dup_parent=dupContext(parent,page,dups,crumbs);
		moveNode(scan,dup_parent||page,false,crumbs);}
	    if (istop) {scan=node; while ((scan)&&(scan!==page)) {
		addClass(scan,"codexpagetop");
		scan=scan.parentNode;}}
	    return node;}

	// Reverting layout

	function restoreNode(node,info,crumbs,texts){
	    var id=node.id;
	    if (!(id)) return;
	    var origin=crumbs[id];
	    if (origin) {
		var parent=origin.parentNode;
		if (hasClass(node,/\bcodexwraptext\b/g)) {
		    if (hasClass(node,/\bcodexwraptextsplit\b/g))
			parent.replaceChild(texts[id],origin);
		    else parent.replaceChild(node.childNodes[0],origin);}
		else origin.parentNode.replaceChild(node,origin);}
	    dropClass(node,"codexrelocated");}
	
	function revertLayout(layout) {
	    var crumbs=layout.crumbs;
	    var textsplits=layout.textsplits;
	    var tweaked=TOA(
		layout.container.getElementsByClassName("codextweaked"));
	    if ((tweaked)&&(tweaked.length)) {
		layout.logfn("Dropping tweaks of %d relocated nodes",
			     tweaked.length);
		var i=0; var lim=tweaked.length;
		while (i<lim) {
		    var node=tweaked[i++]; node.style='';
		    dropClass(node,"codextweaked");
		    if ((node.tagName==='img')||(node.tagName==='IMG')) {
			node.width=''; node.height='';}}}
	    var pagescaled=TOA(
		layout.container.getElementsByClassName("codexpagescaled"))
	    var i=0, lim=pagescaled.length; while (i<lim) {
		var elt=pagescaled[i++];
		swapClass(elt,"codexpagescaled","codexpagescale");}
	    var cantsplit=TOA(
		layout.container.getElementsByClassName("codextweaked"));
	    dropClass(cantsplit,"codexcantsplit");
	    var split=TOA(
		layout.container.getElementsByClassName("codexsplitstart"));
	    var i=0, lim=split.length;
	    while (i<lim) {
		var node=split[i++];
		var nodeid=node.id;
		var text=textsplits[nodeid];
		node.parentNode.replaceChild(text,node);}
	    var shards=TOA(
		layout.container.getElementsByClassName("codextextsplit"));
	    var i=0, lim=shards.length;
	    while (i<lim) {
		var node=shards[i++];
		node.parentNode.removeChild(node);}
	    var moved=TOA(
		layout.container.getElementsByClassName("codexrelocated"));
	    if ((moved)&&(moved.length)) {
		layout.logfn(
		    "Restoring original layout of %d nodes and %d texts",
		    moved.length);
		var i=0; var lim=moved.length;
		while (i<lim)
		    restoreNode(moved[i++],layout,crumbs,textsplits);}
	    layout.textsplits={}; layout.crumbs={};}
	
	/* Codex trace levels */
	/* 0=notrace
	   1=trace tracked nodes
	   2=trace addition of top level chunks
	   3=trace insertion of page breaks
	   4=trace every node consideration
	*/

	function CodexLayout(init){
	    if (!(init)) init={};

	    var layout=this;

	    // Layout rules
	    var forcebreakbefore=this.forcebreakbefore=
		optimizeLayoutRule(init.forcebreakbefore||false);
	    var forcebreakafter=this.forcebreakafter=
		optimizeLayoutRule(init.forcebreakafter||false);
	    var avoidbreakinside=this.avoidbreakinside=
		optimizeLayoutRule(init.avoidbreakinside||false);
	    var avoidbreakafter=this.avoidbreakafter=
		optimizeLayoutRule(init.avoidbreakafter||false);
	    var avoidbreakbefore=this.avoidbreakbefore=
		optimizeLayoutRule(init.avoidbreakbefore||false);
	    var scaletopage=this.scaletopage=
		optimizeLayoutRule(init.scaletopage||false);
	    var fullpages=this.fullpages=
		optimizeLayoutRule(init.fullpages||false);
	    var singlepages=this.singlepages=
		optimizeLayoutRule(init.singlepages||false);
	    var floatpages=this.floatpages=
		optimizeLayoutRule(init.floatpages||false);

	    var pageprefix=this.pageprefix=init.pageprefix||"CODEXPAGE";

	    // Layout Dimensions
	    var page_height=this.height=init.page_height||fdjtDOM.viewHeight();
	    var page_width=this.width=init.page_width||fdjtDOM.viewWidth();
	    
	    // Break 'paragraphs' (anything with just text and inline nodes)
	    var break_blocks=this.break_blocks=
		((typeof init.break_blocks === 'undefined')?(true):
		 (init.break_blocks));

	    // Atomic nodes can't be broken.  Specifying this can
	    // speed up page layout in some cases.
	    var atomic=init.atomic||false;
	    if (typeof atomic === "string") atomic=fdjtDOM.selector(atomic);
	    else if ((atomic.length)&&(atomic.join))
		// Arrays of selector strings
		atomic=fdjtDOM.selector(atomic.join(","));
	    else {}
	    this.atomic=atomic;

	    var use_scaling=
		((typeof init.use_scaling === 'undefined')?(true):
		 (init.use_scaling))

	    // Scale pages (use CSS to shrink pages to fit)
	    var scale_pages=this.scale_pages=
		((use_scaling)&&
		 ((typeof init.scale_pages === 'undefined')?(true):
		  (init.scale_pages)));
	    this.scaledpages=[];

	    // This keeps track of item scaling
	    var scaled=this.scaled=[];

	    // This is the node DOM container where we place new pages
	    var container=this.container=
		init.container||fdjtDOM("div.codexpages");
	    
	    var logfn=this.logfn=
		init.logfn||CodexLayout.logfn||
		((typeof fdjtLog !== 'undefined')?(fdjtLog):(noop));

	    // STATE variables

	    var pagenum=this.pagenum=0; // Tracks current page number
	    var pages=this.pages=[]; // Array of all pages generated, in order
	    var dups=this.dups={}; // Tracks nodes/contexts already duplicated
	    // Maps IDs to text nodes left behind as placeholders when
	    //  the original nodes were moved.
	    var crumbs=this.crumbs={}; 
	    var cur_root=this.root=false; // The root currently being added

	    // Tracks text nodes which have been split, keyed by the
	    // temporary IDs assigned to them
	    var textsplits=this.textsplits={};

	    var page=this.page=init.page; // Contains the currently open page

	    var prev=this.prev=false; // The last terminal block we processed
	    var prevstyle=this.prevstyle=false;

	    // this.drag[] contains nodes which will go on the next
	    // page when we get there.  The nodes in this.drag[] have
	    // already been placed on pages, but we keep track of them
	    // in case we need to move them to a new page to honor
	    // nobreak constraints.
	    var drag=this.drag=[];

	    // this.float_pages contains fully-assembled page nodes to
	    // placed in pages after this one; it is intended for
	    // out-of-flow or 'too bit to fit' content
	    var float_pages=this.float_pages=[];

	    // this.float_blocks is an array of blocks to place into
	    // the flow there is a chance.  This is intended for use
	    // by figures/tables/etc which we don't want to embed
	    var float_blocks=this.float_blocks=[];

	    // Startup

	    this.started=false; // When we started
	    var trace=this.tracelevel=  // How much to trace
		init.tracelevel||CodexLayout.tracelevel||
		(fdjtState.getLocal("codexlayout.trace",true))||0;
	    var track=init.track||CodexLayout.track||
		(fdjtState.getLocal("codexlayout.track"))||false;
	    if (track) {
		this.track=track=fdjtDOM.Selector(track);
		if (!(trace)) trace=this.tracelevel=1;}
	    else this.track=false;
	    this.roots=init.roots||false; // Where all roots can be bracked
	    this.root_count=0; // Number of root nodes added
	    this.block_count=0;
	    this.lastid=false;
	    
	    var pagerule=this.pagerule=init.pagerule||false;
	    
	    function move2page(node,page){
		if (trace) {
		    if ((trace>3)||((track)&&(track.match(node))))
			logfn("Moving node %o to page %o",node,page);}
		return moveNodeToPage(node,page,dups,crumbs);}
	    function moveNode(node){
		if (trace) {
		    if ((trace>3)||((track)&&(track.match(node))))
			logfn("Moving node %o to page %o",node,page);}
		return moveNodeToPage(node,page,dups,crumbs);}

	    function parseScale(s){
		if (s.search(/%$/g)>0) {
		    var pct=parseFloat(s.slice(0,s.len-1));
		    return pct/100;}
		else return parseFloat(s);}

	    function scaleToPage(elt){
		if (typeof elt === "string") elt=fdjtID(elt);
		if ((!(elt))||(elt.length===0)) return;
		else if (elt.nodeType) {
		    var ps=elt.getAttribute("data-pagescale")||
			elt.getAttribute("data-pagescale")||
			getElementValue(elt,"xdatapagescale");
		    var style=getStyle(elt);
		    if (!(ps)) return;
		    if (elt.style[fdjtDOM.transform]) return;
		    var psv=ps.split(/ |,|x/g);
		    var psw=1, psh=1;
		    if (psv.length===2) {
			psw=parseScale(psv[0]);
			psh=parseScale(psv[1]);}
		    else psh=parseScale(psv[0]);
		    var pw=page_width*psw, ph=page_height*psh;
		    var w=elt.offsetWidth, h=elt.offsetHeight;
		    var sw=pw/w, sh=ph/h;
		    var scale=((sw<sh)?(sw):(sh));
		    if (elt.tagName==="IMG") {
			var nw=w*scale, nh=h*scale;
			elt.style.width=nw+"px";
			elt.style.height=nh+"px";}
		    else {
			var scalestring="scale("+scale+","+scale+")";
			var current=(style.transform)||style[fdjtDOM.transform];
			if ((!current)||(current==="none")||(current.length===0)) {
			    elt.style.transformOrigin="center top";
			    elt.style[fdjtDOM.transformOrigin]="center top";
			    elt.style.transform=scalestring;
			    elt.style[fdjtDOM.transform]=scalestring;}}}
		else if (elt.length) {
		    var i=0, lim=elt.length;
		    while (i<lim) scaleToPage(elt[i++]);}
		else {}}


	    //  addContent calls loop() exactly once to set up the
	    //   actual loop to be timesliced with repeated calls
	    //   setTimeout and a final call to doneFn.  The real
	    //   inner function is step(), which relies on state
	    //   stored in its closure.
	    
	    function addContent(root,timeslice,timeskip,
				trace,progressfn,donefn) {

		var newpage=false;
		var start=fdjtTime();
		if (!(page)) {newPage(); newpage=true;}

		if (typeof trace === 'undefined') trace=layout.tracelevel;
		if (typeof progressfn === 'undefined')
		    progressfn=layout.progressfn||false;
		if (!(layout.started)) layout.started=start;
		// If it's already been added to a page, don't do it again.
		if (getParent(root,".codexpage")) {
		    if (donefn) donefn(layout);
		    return false;}
		layout.root_count++;

		// If we can use layout properties of the root, we do
		// so immediately, and synchronously
		if ((hasClass(root,/\b(codexfullpage|codexsinglepage)\b/))||
		    ((fullpages)&&(testNode(root,fullpages)))||
		    ((singlepages)&&(testNode(root,singlepages)))) {
		    if (newpage) moveNode(root); else newPage(root);
		    // Scale any embedded items
		    if ((hasClass(root,/\bcodexscaletopage\b/))||
			(testNode(root,scaletopage)))
			scaleToPage(root);
		    scaleToPage(fdjtDOM.getChildren(root,scaletopage));
		    scaleToPage(fdjtDOM.getChildren(root,/\bcodexscaletopage\b/));
		    newPage();
		    prev=this.prev=root;
		    prevstyle=this.prevstyle=getStyle(root);
		    if (donefn) donefn(layout);
		    return;}
		else {
		    if ((forcedBreakBefore(root))||
			((prev)&&(forcedBreakAfter(prev)))) {
			root=newPage(root); newpage=true;}
		    else root=moveNode(root);
		    // Scale any embedded items
		    if (testNode(root,scaletopage)) scaleToPage(root);
		    scaleToPage(fdjtDOM.getChildren(root,scaletopage));
		    var geom=getGeom(root,page);
		    if (geom.bottom<=page_height) {
			prev=this.prev=root;
			prevstyle=this.prevstyle=getStyle(root);
			if (donefn) donefn(layout);
			return;}
		    else if (((atomic)&&(atomic.match(root)))||
			     (avoidBreakInside(root))) {
			if (!(newpage)) newPage(root);
			prev=this.prev=root;
			prevstyle=this.prevstyle=getStyle(root);
			if (donefn) donefn(layout);
			return;}}

		var blocks=[], terminals=[], styles=[];
		// gather all of the block-level elements
		// (recursively) in the node, noting which ones are
		// terminals.  This should be pretty fast, so we do it
		// synchronously
		gatherBlocks(root,blocks,terminals,styles);
		layout.block_count=layout.block_count+blocks.length;
		if (trace>1)
		    logfn("Laying out %d blocks from %o; page=%o",
			  blocks.length,root,page);

		// If there aren't any blocks, we try adding the
		//  content to the current page and, if it goes over,
		//  create a new page for it and call the donefn.  At
		//  the top level, we only split blocks.
		if (blocks.length===0) {
		    if (!(newpage)) newPage(root);
		    layout.root=cur_root=false;
		    if (donefn) donefn(layout);
		    return;}
		
		layout.root=cur_root=root;

		var ni=0, nblocks=blocks.length; 
		    
		function step(){
		    var block=blocks[ni]; var style=styles[ni];
		    var terminal=terminals[ni]||false;
		    var tracing=false;
		    if (block.id) layout.lastid=block.id;

		    if ((trace)&&(block)&&
			((trace>3)||((track)&&(track.match(block))))) {
			logfn("Considering block %o (#%d from %o); page=%o",
			      block,ni,root,page);
			tracing=true;}
		    
		    // FIRST, HANDLE DRAGGING

		    // If this block is terminal and we don't want to
		    // break before this block or after the preceding
		    // block, drag along the previous block to the new
		    // page.

		    // NOTE that dragged blocks have already been
		    // placed, so the previous page will end up short.
		    // Them's the breaks.
		    if ((block)&&(terminal)&&(prev)&&
			((avoidBreakBefore(block,style))||
			 (avoidBreakAfter(prev,prevstyle)))) {
			if (tracing) logfn("Possibly dragging %o",prev);
			drag.push(prev);}
		    else if ((block)&&(terminal)&&(drag)&&(drag.length)) {
			// Otherwise, we don't have to worry about
			// what we've been dragging along so far,
			// so we clear it.
			if (tracing) logfn("Dropping %d drags",layout.drag.length);
			layout.drag=drag=[];}
		    else {}
		    
		    // If a block is false, continue
		    if (!(block)) {ni++; return;}
		    else if ((hasClass(block,/\bcodexfloatpage\b/))||
			     ((floatpages)&&(testNode(block,floatpages)))) {
			// Float pages just get pushed (until newPage below)
			if (tracing) logfn("Pushing float page %o",block);
			float_pages.push[block]; ni++; return;}
		    else if ((hasClass(block,/\b(codexfullpage|codexsinglepage)\b/))||
			     ((fullpages)&&(testNode(block,fullpages)))||
			     ((singlepages)&&(testNode(block,singlepages)))) {
			// Full pages automatically get their own page
			if (tracing) logfn("Full single page for %o",block);
			block=newPage(block); newPage();
			ni++; return;}
		    else if ((page.childNodes.length)&&
			     ((forcedBreakBefore(block,style))||
			      ((prev)&&(forcedBreakAfter(prev,prevstyle)))||
			      ((prev)&&
			       ((hasClass(prev,/\b(codexfullpage|codexsinglepage)\b/))||
				((fullpages)&&(testNode(prev,fullpages)))||
				((singlepages)&&(testNode(prev,singlepages))))))) {
			// This is the easy case.  Note that we don't
			// force a page break if the current page is
			// empty.
			if (tracing) logfn("Forced new page for %o",block);
			layout.drag=drag=[];
		    	block=newPage(block);}
		    else block=moveNode(block);

		    // Finally, we check if everything fits.  We're
		    // walking through the blocks[] but only advance
		    // when an element fits or can't be split or
		    // tweaked Note that we may process an element [i]
		    // more than once if we split the node and part of
		    // the split landed back in [i].
		    var geom=getGeom(block,page);
		    if ((trace)&&((trace>3)||((track)&&(track.match(block)))))
			logfn("Layout/geom %o %j",block,geom);
		    if ((terminal)&&(geom.bottom>page_height)) {
			// We're a terminal node and we extend
			// below the bottom of the page
			if (geom.top>page_height)
			    // If our top is also over the bottom of the page,
			    //  we just start a new page
			    block=newPage(block);
			else if (((!(break_blocks))||
				  ((atomic)&&(atomic.match(block)))||
				  (avoidBreakInside(block,style))||
				  (hasClass(block,"codexcantsplit")))) {
			    var curpage=page;
			    block=newPage(block);
			    if (page===curpage) {
				if (geom.bottom>page_height)
				    addClass(page,"codexoversize");
				ni++;}}
			else {
			    // Now we try to split the block, we store
			    // the 'split block' back in the blocks
			    // variable because we might need to split
			    // it again.
			    if (tracing) logfn("Splitting block %o",block);
			    blocks[ni]=splitBlock(block);}}
		    // We fit on the page, so we'll look at the next block.
		    else {
			if (tracing) logfn("Fits on page: %o",block);
			ni++;}
		    // Update the prev pointer for terminals
		    if (terminal) {
			layout.prev=prev=block;
			layout.prevstyle=prevstyle=style;}}

		// Gather all the block-level elements inside a node,
		// recording which ones are terminals (don't have any
		// blocks within them)
		function gatherBlocks(node,blocks,terminals,styles){
		    if (node.nodeType!==1) return;
		    if (node.codexui) return;
		    var style=getStyle(node); 
		    if ((atomic)&&(atomic.match(node))) {
			blocks.push(node); styles.push(node);
			terminals.push(node);
			return;}
		    var disp=style.display;
		    if ((style.position==='static')&&(disp!=='inline')) {
			var loc=blocks.length;
			blocks.push(node);
			styles.push(style);
			if (avoidBreakInside(node,style))
			    terminals[loc]=true;
			else if ((disp==='block')||(disp==='table')) {
			    var children=node.childNodes;
			    var total_blocks=blocks.length;
			    var i=0; var len=children.length;
			    while (i<len) {
				gatherBlocks(children[i++],
					     blocks,terminals,styles);}
			    if (blocks.length==total_blocks)
				terminals[loc]=true;}
			else terminals[loc]=true;}}

		// Whether we need to create a new page to have 'node'
		//  at the page top We don't need a new page if the
		//  current page has no content or no content up until
		//  the node in question
		function needNewPage(node){
		    if (!(page)) return true;
		    else if (!(node))
			return hasContent(page,true,true);
		    else if (!(hasParent(node,page)))
			return hasContent(page,true,true);
		    else if (page.firstChild===node)
			return false;
		    else if (hasContent(page,node,true))
			return true;
		    else return false;}

		// Create a new page
		// If node is passed, it is the first element on the new page
		function newPage(node,forcepage){
		    if ((float_pages)&&(float_pages.length)) {
			// First add any floating pages that may have
			// accumulated
			var i=0; var lim=float_pages.length;
			while (i<lim) newPage(float_pages[i++]);
			float_pages=[];
			forcepage=true;}
		    var newpage="pagetop";
		    if ((node)&&(node.nodeType===3)) {
			var parent=node.parentNode;
			if ((parent)&&(parent.childNodes.length===1)&&
			    (parent!==document.body)&&
			    (parent!==Codex.content)&&
			    (!(hasClass(parent,"codexpage"))))
			    node=parent;}
		    if ((!(node))||(forcepage)||(needNewPage(node))) {
			// If we really need to create a new page, do so,
			//  starting by dropping the curpage class from the
			//  current page
			if (page) dropClass(page,"curpage");
			layout.page=page=fdjtDOM("div.codexpage.curpage");
			if (!(pagerule)) {
			    page.style.height=page_height+'px';
			    page.style.width=page_width+'px';}
			pagenum++; layout.pagenum=pagenum;
			page.id=pageprefix+(pagenum);
			page.setAttribute("data-pagenum",pagenum);
			fdjtDOM(container,page);
			layout.prev=prev=false;
			pages.push(page);
			newpage="newpage";}
		    
		    if (trace) {
			if ((trace>2)||
			    ((track)&&(node)&&(track.match(node)))) {
			    if (node) logfn("Layout/%s %o at %o",
					    newpage,page,node);
			    else logfn("Layout/%s %o",newpage,page);}}
			
		    // If there are things we are dragging along, move
		    // them to the new page
		    if ((drag)&&(drag.length)) {
			var i=0; var lim=drag.length;
			while (i<lim) moveNode(drag[i++],crumbs);
			layout.prev=prev=drag[drag.length-1];
			layout.drag=drag=[];}
		    // Finally, move the node to the page
		    if (node) return moveNode(node);
		    else return false;}

		var getLineHeight=fdjtDOM.getLineHeight;

		// This gets a little complicated
		function splitBlock(node){
		    if ((!(break_blocks))||(avoidBreakInside(node))||
			(!(node.childNodes))||(node.childNodes.length===0)) {
			// Simplest case, if we can't split, we just
			// make a new page starting with the node.
			addClass(node,"codexcantsplit");
			newPage(node);
			return node;}
		    // Otherwise, we remove all of the node's children
		    // and then add back just enough to reach the
		    // edge, potentially splitting some children to
		    // make this work.
		    var init_geom=getGeom(node,page,true);
		    var line_height=init_geom.line_height||12;
		    if ((init_geom.top+init_geom.top_margin+(line_height*2))>page_height) {
			// If the top is too close to the bottom of the page, just push it over.
			return newPage(node);}
		    var children=TOA(node.childNodes);
		    var i=children.length-1;
		    while (i>=0) node.removeChild(children[i--]);
		    var geom=getGeom(node,page);
		    if (geom.bottom>page_height) {
			// If the version without any children is
			// already over the edge, just start a new
			// page on the node (after restoring all the
			// children to the node).
			i=0; var n=children.length;
			appendChildren(node,children);
			addClass(node,"codexcantsplit");
			newPage(node);
			return node;}
		    var push=splitChildren(node,children,init_geom,line_height);
		    if (!(push)) {
			/* Doesn't need to be split after all.
			   Not sure when this will happen, if ever. */
			fdjtLog("Tried to break %o which didn't need breaking",
				node);
			appendChildren(node,children);
			return node;}
		    else if (push===node) {
			appendChildren(node,children);
			addClass(node,"codexcantsplit");
			newPage(node);
			return node;}
		    else { 
			var page_break=push[0]; i=1; n=push.length;
			// Finally, we create a new page
			newPage(page_break);
			var dup=page_break.parentNode;
			// This (dup) is the copied parent of the page
			// break.  We append all the remaining children
			// to this duplicated parent on the new page.
			appendChildren(dup,push,1);
			if (trace>1)
			    logfn("Layout/splitBlock %o @ %o into %o on %o",
				  node,page_break,dup,page);
			return dup;}}

		function isTextyNode(node){
		    return ((node.childNodes)&&
			    (node.childNodes.length===1)&&
			    (node.childNodes[0].nodeType===3));}

		var removeChildren=fdjtDOM.removeChildren;

		function splitChildren(node,children,init_geom,line_height){
		    /* node is a node and children are its children,
		       which have been removed from it.  We return an
		       array of children which should go onto the next
		       page, possibly synthesizing a new child by
		       splitting some text.  */
		    var page_break=node; var use_page_height=page_height;
		    var geom=init_geom||getGeom(node,page);
		    if (!(line_height))
			line_height=getLineHeight(node)||12;
		    if ((geom.bottom-(line_height*2))<page_height)
			/* If the node is just a little bit over the
			   bottom, we tweak the page height to avoid
			   leaving single lines on the other side. */
			use_page_height=page_height-line_height;
		    // We add children back until we go over the edge
		    // and then figure out if there's a way to split
		    // the child that broke the page.
		    var i=0, n=children.length, childtype=false;
		    while (i<n) {
			var child=children[i++];
			childtype=child.nodeType;
			// Add the child back and get the geometry
			node.appendChild(child); geom=getGeom(node,page);
			if (geom.bottom>use_page_height) {
			    page_break=child; break;}
			else continue;}
		    if (page_break===node) // Never went over the edge
			return false;
		    // This child pushed the node over the edge
		    else if ((childtype!==3)&&(childtype!==1)) {
			// This is probably an error
			if (i===1) return node;
			else return children.slice(i-1);}
		    else if ((childtype===1)&&
			     (!((hasContent(node,child,true)))))
			// This indicates that the whole node should
			// be pushed
			return node;
		    else if ((childtype===1)&&
			     ((!(child.childNodes))||
			      ((child.childNodes.length===0))||
			      (!(isTextyNode(child))))) {
                        // We don't try to break nodes that don't have
                        // children or (for now) nodes that have non
                        // textual children.
			if (i===1) return node;
			else return children.slice(i-1);}
		    // If it's text, split it into words, then try to
		    // find the length at which one more word pushes
		    // it over the edge.
		    var probenode=page_break, text=false;
		    var original=page_break, outer=node;
		    if (childtype===1) {
			// This is the case where it's an inline
			//  element rather than a text object.  In
			//  this case, we do our probing on the
			//  element rather than the top level node
			//  that we're considering.
			probenode=original=page_break.firstChild;
			outer=page_break;
			text=probenode.nodeValue;}
		    else text=page_break.nodeValue;
		    // Now, break the text up at possible page breaks
		    var breaks=text.split(/\b/g), words=[], word=false;
		    var bi=0, blen=breaks.length;
		    while (bi<blen) {
			var s=breaks[bi++]; var ws;
			if ((ws=s.search(/\s/))>=0) { /* Includes whitespace */
			    if (ws===0) { /* Starts with whitespace */
				if (word) words.push(word);
				if (bi<blen) word=s+breaks[bi++];
				else word=s;}
			    else {
				if (word) words.push(word+s);
				else words.push(s);
				word=false;}}
			else if (word) word=word+s;
			else word=s;}
		    if (word) words.push(word);
		    // If there aren't many words, don't bother
		    //  splitting and just push the whole node onto
		    //  the next page
		    if (words.length<2) {
			if (i===1) return node;
			else return children.slice(i-1);}
		    // Now we do a binary search to find the word
		    //  which pushes the node below the page height.
		    //  That's where we'll break.
		    var w=0; var wlen=words.length;
		    var wbreak=floor(wlen/2);
		    var foundbreak=false;
		    var wtop=wlen; var wbot=0;
		    while ((wbreak>=wbot)&&(wbreak<wtop)) {
			var newprobe=document.createTextNode(
			    words.slice(0,wbreak).join(""));
			outer.replaceChild(newprobe,probenode);
			probenode=newprobe;
			geom=getGeom(node,page);
			if (geom.bottom>use_page_height) {
			    /* Already over, wrap back */
			    wtop=wbreak;
			    wbreak=wbot+floor((wbreak-wbot)/2);}
			else {
			    /* Add one more work to see if we break the page. */
			    var nextw=document.createTextNode(words[wbreak]);
			    outer.appendChild(nextw);
			    var ngeom=getGeom(node,page);
			    outer.removeChild(nextw);
			    if (ngeom.bottom>use_page_height) {
				foundbreak=true; break;}
			    else {
				wbot=wbreak+1;
				wbreak=wbreak+floor((wtop-wbreak)/2);}}}
		    if (wbreak+1===wtop) foundbreak=true;
		    // We're done searching for the word break
		    if ((wbreak===0)||(wbreak===wlen-1)) {
			// If the break is at the beginning or end
			// use the page_break as a whole
			if (childtype===1)
			    outer.replaceChild(original,probenode);
			else node.replaceChild(page_break,probenode);
			if (i===1) return node;
			else return children.slice(i-1);}
		    else { // Do the split
			var keeptext=words.slice(0,wbreak).join("");
			var pushtext=words.slice(wbreak).join("");
			var keepnode, pushnode, id=false;
			if ((page_break.nodeType===1)&&
			    (hasClass(page_break,"codextextsplit"))) {
			    keepnode=page_break;
			    pushnode=page_break.cloneNode(true);}
			else if (page_break.nodeType===1) {
			    if (!(id=page_break.id))
				page_break.id=id="CODEXTMPID"+(tmpid_count++);
			    keepnode=page_break;
			    pushnode=page_break.cloneNode(true);}
			else {
			    keepnode=fdjtDOM("span.codexsplitstart");
			    keepnode.id=id="CODEXTMPID"+(tmpid_count++);
			    pushnode=fdjtDOM("span.codextextsplit");}
			removeChildren(keepnode);
			removeChildren(pushnode);
			keepnode.appendChild(
			    document.createTextNode(keeptext));
			pushnode.appendChild(
			    document.createTextNode(pushtext));
			if (childtype===3)
			    node.replaceChild(keepnode,probenode);
			else node.replaceChild(keepnode,page_break);
			// Put the page break back in context for copying
			node.appendChild(pushnode);
			var move_children=children.slice(i-1);
			// Put the children back into context for copying
			appendChildren(node,children,i);
			move_children[0]=pushnode;
			if (id) textsplits[id]=original;
			return move_children;}}
	
		function loop(){
		    var loop_start=fdjtTime();
		    while ((ni<nblocks)&&
			   ((fdjtTime()-loop_start)<timeslice))
			step();
		    if (progressfn) progressfn(layout);
		    if (ni<nblocks) layout.timer=
			setTimeout(loop,timeskip||timeslice);
		    else {
			var last_block=blocks[nblocks-1];
			if ((forcedBreakAfter(last_block))||
			    (hasClass(last_block,/\bcodexfullpage\b/))||
			    ((fullpages)&&(testNode(last_block,fullpages))))
			    newPage();
			if (layout.timer) clearTimeout(layout.timer);
			layout.timer=false;
			layout.root=cur_root=false;
			if (donefn) setTimeout(function(){donefn(layout);},10);}}

		// This is the inner loop
		if (!(timeslice)) {
		    while (ni<nblocks) step();
		    if (donefn) donefn(layout);}
		else loop();
		
		return this;}
	    this.addContent=addContent;

	    /* Finishing the page */

	    function finishPage(completed) {
		var bounds=insideBounds(completed);
		var fullpage=hasClass(completed,"codexfullpage");
		if (!((page_width)&&(page_height))) {
		    var geom=getGeom(completed);
		    if (!(page_width)) page_width=geom.width;
		    if (!(page_height)) page_height=geom.height;}
		var oversize=((bounds.right>page_width)||(bounds.bottom>page_height));
		var undersize=((fullpage)&&((bounds.right<(page_width*0.95))&&
					    (bounds.bottom<(page_height*0.95))));
			       
		if (((oversize)||(undersize))&&(scale_pages)) {
		    var boxed=fdjtDOM("div.codexscalebox",completed.childNodes);
		    completed.appendChild(boxed);
		    var scalex=page_width/bounds.right;
		    var scaley=page_height/bounds.bottom;
		    var scale=((scalex<scaley)?(scalex):(scaley));
		    if ((scale<1)||(fullpage)) {
			var transform='scale('+scale+','+scale+')';
			this.scaledpages.push(boxed);
			boxed.style.transform=transform
			boxed.style[fdjtDOM.transform]=transform;
			boxed.style.transformOrigin='center top';
			boxed.style[fdjtDOM.transformOrigin]='center top';
			addClass(completed,"codexscaledpage");}
		    else if (oversize)
			addClass(completed,"codexoversizepage");
		    else {}}
		else if (oversize)
		    addClass(completed,"codexoversizepage");
		else {}
		if (this.pagedone) this.pagedone(completed);
		dropClass(completed,"curpage");}
	    this.finishPage=finishPage;

	    /* Finishing the overall layout */

	    function Finish(){
		for (var dupid in dups) {
		    var dup=dups[dupid];
		    dup.className=dup.className.replace(
			    /\bcodexdup\b/,"codexdupend");}
		dropClass(page,"curpage");
		var i=0; var lim= pages.length;
		while (i<lim) this.finishPage(pages[i++]);
		layout.done=fdjtTime();}
	    this.Finish=Finish;

	    /* page break predicates */
	    
	    function forcedBreakBefore(elt,style){
		if (!(elt)) return false;
		if (!(style)) style=getStyle(elt);
		return (style.pageBreakBefore==='always')||
		    ((elt.className)&&
		     (elt.className.search(
			     /\b(forcebreakbefore|alwaysbreakbefore)\b/)>=0))||
		    ((forcebreakbefore)&&(testNode(elt,forcebreakbefore)));}
	    this.forcedBreakBefore=forcedBreakBefore;
	    
	    var getLastElement=fdjtDOM.getLastElement;

	    function forcedBreakAfter(elt,style){ 
		if (!(elt)) return false;
		if (!(style)) style=getStyle(elt);
		var force=(style.pageBreakAfter==='always')||
		    ((elt.className)&&
		     (elt.className.search(
			     /\b(forcebreakafter|alwaysbreakafter)\b/)>=0))||
		    ((forcebreakafter)&&(testNode(elt,forcebreakafter)));
		if (force) return force;
		if (elt===cur_root) return false;
		if (!(cur_root)) return false;
		var parent=elt.parentNode;
		if ((!(parent))||(parent===document))
		    return false;
		var last=(parent.lastElementChild)||
		    ((parent.children[parent.children.length-1]));
		if (elt===last)
		    return forcedBreakAfter(parent);
		else return false;}
	    this.forcedBreakAfter=forcedBreakAfter;

	    // We explicitly check for these classes because some browsers
	    //  which should know better (we're looking at you, Firefox) don't
	    //  represent (or handle) page-break 'avoid' values.  Sigh.
	    var page_block_classes=/\b(avoidbreakinside)|(sbookpage)\b/;
	    function avoidBreakInside(elt,style){
		if (!(elt)) return false;
		if (elt.tagName==='IMG') return true;
		if (!(style)) style=getStyle(elt);
		return (style.pageBreakInside==='avoid')||
		    ((elt.className)&&
		     (elt.className.search(page_block_classes)>=0))||
		    ((avoidbreakinside)&&(testNode(elt,avoidbreakinside)));}
	    this.avoidBreakInside=avoidBreakInside;
	    
	    function avoidBreakBefore(elt,style){
		if (!(elt)) return false;
		if (!(style)) style=getStyle(elt);
		return ((style.pageBreakBefore==='avoid')||
			((elt.className)&&(elt.className.search(/\bavoidbreakbefore\b/)>=0))||
			((avoidbreakbefore)&&(testNode(elt,avoidbreakbefore))));}
	    this.avoidBreakBefore=avoidBreakBefore;

	    function avoidBreakAfter(elt,style){
		var avoid=false;
		if (!(elt)) return false;
		// Avoid breaks after headings
		if (/H\d/.exec(elt.tagName)) return true;
		if (!(style)) style=getStyle(elt);
		// Use the style information
		if (style.pageBreakAfter==='avoid') return true;
		else if ((style.pageBreakAfter)&&
			 (style.pageBreakAfter!=="auto"))
		    return false;
		else avoid=((avoidbreakafter)&&(testNode(elt,avoidbreakafter)));
		if (avoid) return avoid;
		if (elt===cur_root) return false;
		if (!(cur_root)) return false;
		var parent=elt.parentNode;
		if ((!(parent))||(parent===document))
		    return false;
		var last=(parent.lastElementChild)||
		    ((parent.children[parent.children.length-1]));
		if (elt===last)
		    return avoidBreakAfter(parent);
		else return false;}
	    this.avoidBreakAfter=avoidBreakAfter;
	    
	    function getPage(spec) {
		if (!(spec)) return false;
		else if (typeof spec === 'number')
		    return fdjtID(pageprefix+spec);
		else if (spec.nodeType) {
		    if (hasClass(spec,"codexpage")) return spec;
		    else return getParent(spec,".codexpage");}
		else if (typeof spec === "string")
		    return getPage(fdjtID(spec));
		else {
		    logfn("Can't determine page from %o",spec);
		    return false;}}
	    this.getPage=getPage;

	    function getDup(node,page){
		if (typeof node === 'string')
		    node=document.getElementById(node);
		if (!(node)) return false;
		if (hasParent(node,page)) return node;
		var nodeid=node.id;
		var duptable=Codex.paginated.dups;
		var dups=duptable[nodeid];
		var i=0; var lim=dups.length;
		while (i<lim) {
		    if (hasParent(dups[i]),page) return dups[i];
		    else i++;}
		return false;}
	    this.getDup=getDup;

	    function gotoPage(spec) {
		var newpage=false;
		if (!(spec)) return false;
		else if (typeof spec === 'number')
		    newpage=document.getElementById(pageprefix+spec);
		else if (spec.nodeType) {
		    if (hasClass(spec,"codexpage")) newpage=spec;
		    else newpage=getParent(spec,".codexpage");}
		else if (typeof spec === "string")
		    newpage=getPage(document.getElementById(spec));
		else {
		    logfn("Can't determine page from %o",spec);
		    return false;}
		if (!(newpage)) return;
		var oldpage=container.getChildrenByClassName('curpage');
		dropClass(oldpage,"curpage");
		addClass(newpage,"curpage");}
	    this.gotoPage=gotoPage;

	    this.Revert=function(){
		// Remove any scaleboxes (save the children)
		if (this.scaledpages) {
		    var scaled=this.scaledpages;
		    var i=0, lim=scaled.length;
		    while (i<lim) {
			var scalebox=scaled[i++];
			var children=fdjtDOM.toArray(scalebox.childNodes);
			var parent=scalebox.parentNode;
			fdjtDOM.remove(scalebox);
			fdjtDOM(parent,children);}}
		this.scaledpages=[];
		var pagetops=fdjtDOM.$(".codexpagetop");
		var i=0, lim=pagetops.length;
		while (i<lim) dropClass(pagetops[i++],"codexpagetop");
		revertLayout(this);}

	    /* Finally return the layout */
	    return this;};
	
	CodexLayout.tracelevel=0;
	CodexLayout.prototype.getDups=function getDups4ID(id){
	    if (!(id)) return [];
	    else if (id.nodeType) id=id.id;
	    var base=fdjtID(id);
	    var dups=this.dups[id];
	    if (dups) return [base].concat(dups);
	    else return base;}
	
	return CodexLayout;})();


/* Mini Manual */
/*
  var layout=new CodexLayout();
  layout.addContent(node);
  layout.Finish();
  layout.Revert();

  var layout=new CodexLayout({
  page_width: 500, page_height: 500, // Dimensions
  // Where to add new pages; by default this creates a
  //  new div#CODEXPAGES.codexpages at the bottom of the BODY
  container: document.getElementByID("MYPAGES"),
  // Prefix for page element IDs, e.g. page 42 would have id MYCODEXPAGE42
  pageprefix: "MYCODEXPAGE",
  logfn: console.log, // how to log notable events
  // Layout rules:
  // Always put H1 elements on a new page
  forcebreakbefore: "H1",
  // Always follow div.signature with a page break
  forcebreakafter: "div.signature",
  // Avoid breaking inside
  avoidbreakinside: "div.code",
  // Avoid breaking before these elements
  avoidbreakbefore: "div.signature,div.attribution",
  // Avoid breaking after these elements
  avoidbreakafter: "h1,h2,h3,h4,h5,h6,h7",
  // Put this element on a page by itself
  codexfullpage: "div.titlepage",
  // Put this element on a page by itself, but don't interrupt the
  // narrative flow
  codexfloatpage: "div.illustration"});
*/

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/core.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

var Codex=
    {mode: false,hudup: false,scrolling: false,query: false,
     head: false,target: false,glosstarget: false,location: false,
     root: false,start: false,HUD: false,dosync: true,
     user: false, loggedin: false, cxthelp: false,
     _setup: false,_user_setup: false,_gloss_setup: false,_social_setup: false,
     // Whether we have a real connection to the server
     connected: false,
     // Keeping track of paginated context
     curpage: false,curoff: false,curinfo: false, curbottom: false,
     // For tracking UI state
     last_mode: false, last_heartmode: "about", demo: false,
     // How long it takes a gesture to go from tap to hold
     taptapmsecs: 500, holdmsecs: 200, edgeclick: 50, pagesize: 250,
     dontanimate: false,
     glossmodes: /(addtag)|(addlink)|(excerpt)|(editnote)|(sharing)/,
     updatehash: true, iscroll: false,
     // Whether to store glosses, etc for offline/faster access
     persist: false,
     // This is the base URI for this document, also known as the REFURI
     // A document (for instance an anthology or collection) may include
     // several refuri's, but this is the default.
     refuri: false,
     // These are the refuris used in this document
     refuris: [],
     // This is the document URI, which is usually the same as the REFURI.
     docuri: false,
     // This is the unique signed DOC+USER identifier used by myCopy
     // social DRM
     mycopyid: false, 
     // This is the time of the last update
     syncstamp: false,
     // Whether to use native scrolling for body content
     nativescroll: true,
     // Whether to use native scrolling for embedded DIVs
     scrolldivs: true,
     // Dominant interaction mode
     mouse: true,touch: false,kbd: false,
     // Restrictions on excerpts
     min_excerpt: 3, max_excerpt: false,
     // How many past page layouts to cache
     cachelayouts: 0,
     // Various handlers, settings, and status information for the
     // Codex interface
     UI: {
         // This maps device types into sets of node->event handlers
         handlers: {mouse: {}, kbd: {}, ios: {}}},
     Debug: {},
     /* This is where HTML source strings for UI components are placed */
     HTML: {},
     /* This is where we store pointers into the dom */
     DOM: {},
     Trace: {
         startup: 0,    // Whether to debug startup
         config: 0,     // Whether to trace config setup/modification/etc
         mode: false,   // Whether to trace mode changes
         nav: false,    // Whether to trace book navigation
         scan: false,   // Whether to trace DOM scanning
         search: 0,     // How much to trace searches
         clouds: 0,     // How much to trace cloud generation
         focus: false,  // Whether to trace target changes
         toc: false,    // Whether we're debugging TOC tracking
         storage: 0,    // How much to trace offline persistence
         network: 0,    // How much to trace server interaction
         glosses: 0,    // How much we're tracing gloss processing
         layout: 0,     // How much to trace document layout
         knodules: 0,   // How much to trace knodule processing
         dosync: false, // Whether to trace state saves
         state: false,  // Whether to trace set state
         flips: false,  // Whether to trace page flips (movement by pages)
         messages: false, // Whether to trace inter-window messages
         iscroll: false, // Whether to trace HUD scrolling with iScroll
         highlight: 0,  // Whether to trace highlighting
         indexing: 0,   // How much to trace document indexing
         gestures: 0}   // How much to trace gestures
    };

(function(){

    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var hasParent=fdjtDOM.hasParent;

    function initDB() {
        if (Codex.Trace.start>1) fdjtLog("Initializing DB");
        var refuri=(Codex.refuri||document.location.href);
        if (refuri.indexOf('#')>0) refuri=refuri.slice(0,refuri.indexOf('#'));

        // Global lists
        Codex.allglosses=[];
        Codex.allsources=[];
        // These are all references outside of the glosses
        Codex.etc=[];

        var docinfo=Codex.DocInfo=new fdjtKB.Pool(refuri+"#");
        fdjtKB.addRefMap(docinfo.map);
        fdjtKB.addRefMap(function(ref){
            return ((typeof ref === 'string')&&(ref[0]==='#')&&
                    (docinfo.ref(ref.slice(1))));});
        
        var knodule_name=
            fdjtDOM.getMeta("SBOOK.knodule")||
            fdjtDOM.getMeta("~KNODULE")||
            refuri;
        Codex.knodule=new Knodule(knodule_name);
        Codex.index=new KnoduleIndex(Codex.knodule);
        Codex.query=Codex.empty_query=Codex.index.Query([]);
        Codex.BRICO=new Knodule("BRICO");
        Codex.BRICO.addAlias(":@1/");
        Codex.BRICO.addAlias("@1/");
        Codex.glosses=new fdjtKB.Pool("glosses"); {
            var superadd=Codex.glosses.add;
            Codex.glosses.addAlias("glossdb");
            Codex.glosses.addAlias("-UUIDTYPE=61");
            Codex.glosses.addAlias(":@31055/");
            Codex.glosses.addAlias("@31055/");
            Codex.glosses.addInit(function initGloss(item) {
                var elt=document.getElementById(item.frag);
                var info=Codex.docinfo[item.frag];
                if (!(info)) {
                    fdjtLog("Gloss refers to nonexistent '%s': %o",
                            item.frag,item);
                    return;}
                if ((info)&&(info.starts_at)) {item.starts_at=info.starts_at;}
                if ((info)&&(info.starts_at)) {item.ends_at=info.ends_at;}
                var maker=Codex.sourcekb.ref(item.maker);
                Codex.index.add(item,maker,1);
                Codex.addTag2GlossCloud(maker);
                Codex.addTag2SearchCloud(maker);
                Codex.UI.addGlossSource(maker,true);
                var maker_knodule=Codex.getMakerKnodule(item.maker);
                var tags=item.tags; var knodes=[];
                if (tags) {
                    if ((typeof tags === 'string')||(!(tags.length)))
                        tags=[tags];
                    if ((tags)&&(tags.length)) {
                        var i=0; var lim=tags.length; var score=false;
                        while (i<lim) {
                            var tag=tags[i++]; 
                            if (tag[0]==='*') {
                                score=tag.search(/[^*]/);
                                tag=tag.slice(score);}
                            else score=false;
                            var knode=
                                ((tag.indexOf('@')>=0)&&
                                 (fdjtKB.ref(tag,Codex.knodule)))||
                                (maker_knodule.handleEntry(tag));
                            if (info.glosstags)
                                info.glosstags.push(knode);
                            else info.glosstags=[knode];
                            knodes.push(knode);
                            if (score) score=score*2; else score=1;
                            Codex.index.add(item,knode,score);
                            Codex.index.add(info,knode,score);
                            Codex.addTag2SearchCloud(knode);
                            Codex.addTag2GlossCloud(knode);}}
                    item.tags=knodes;}
                var sources=item.sources;
                if (sources) {
                    if (typeof sources === 'string') sources=[sources];
                    if ((sources)&&(sources.length)) {
                        var i=0; var lim=sources.length;
                        while (i<lim) {
                            var source=sources[i++];
                            var ref=fdjtKB.ref(source);
                            Codex.index.add(item,ref,1);
                            Codex.UI.addGlossSource(ref,true);}}}});
            Codex.glosses.index=new fdjtKB.Index();
            if (Codex.persist)
                Codex.glosses.storage=new fdjtKB.OfflineKB(Codex.glosses);}
        Codex.sourcekb=new fdjtKB.Pool("sources");{
            Codex.sourcekb.addAlias("@1961/");
            Codex.sourcekb.index=new fdjtKB.Index();
            Codex.sourcekb.forDOM=function(source){
                var spec="span.source"+((source.kind)?".":"")+
                    ((source.kind)?(source.kind.slice(1).toLowerCase()):"");
                var name=source.name||source.oid||source.uuid||source.uuid;
                var span=fdjtDOM(spec,name);
                if (source.about) span.title=source.about;
                return span;};
            if (Codex.persist)
                Codex.sourcekb.storage=new fdjtKB.OfflineKB(Codex.sourcekb);}
        if (Codex.Trace.start>1) fdjtLog("Initialized DB");}
    Codex.initDB=initDB;

    function getMakerKnodule(arg){
        var result;
        if (!(arg)) arg=Codex.user;
        if (!(arg)) return (Codex.knodule);
        else if ((arg.maker)&&(arg.maker._qid))
            result=new Knodule(arg.maker._qid);
        else if (arg._qid)
            result=new Knodule(arg._qid);
        else if (arg._id)
            result=new Knodule(arg._i);
        else result=Codex.knodule;
        result.description=arg.name;
        return result;}
    Codex.getMakerKnodule=getMakerKnodule;

    var trace1="%s %o in %o: mode%s=%o, target=%o, head=%o scanning=%o";
    var trace2="%s %o: mode%s=%o, target=%o, head=%o scanning=%o";
    function sbook_trace(handler,cxt){
        var target=((cxt.nodeType)?(cxt):(fdjtUI.T(cxt)));
        if (target)
            fdjtLog(trace1,handler,cxt,target,
                    ((Codex.scanning)?("(scanning)"):""),Codex.mode,
                    Codex.target,Codex.head,Codex.scanning);
        else fdjtLog(trace2,handler,cxt,
                     ((Codex.scanning)?("(scanning)"):""),Codex.mode,
                     Codex.target,Codex.head,Codex.scanning);}
    Codex.trace=sbook_trace;

    // This is the hostname for the sbookserver.
    Codex.server=false;
    // This is an array for looking up sbook servers.
    Codex.servers=[[/.sbooks.net$/g,"glosses.sbooks.net"]];
    //Codex.servers=[];
    // This is the default server
    Codex.default_server="glosses.sbooks.net";
    // There be icons here!
    Codex.root="http://static.beingmeta.com/g/codex/";
    Codex.withsvg=document.implementation.hasFeature(
        "http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")||
        navigator.mimeTypes["image/svg+xml"];
    Codex.svg=false;
    if (fdjtState.getQuery("nosvg")) Codex.svg=false;
    else if (fdjtState.getQuery("withsvg")) Codex.svg=true;
    Codex.icon=function(base,width,height){
        return Codex.root+base+
            ((Codex.svg)?(".svgz"):
             ((((width)&&(height))?(width+"x"+height):
               (width)?(width+"w"):(height)?(height+"h"):"")+
              ".png"));}

    Codex.getRefURI=function(target){
        var scan=target;
        while (scan)
            if (scan.refuri) return scan.refuri;
        else scan=scan.parentNode;
        return Codex.refuri;}

    Codex.getDocURI=function(target){
        var scan=target;
        while (scan) {
            var docuri=
                (((scan.getAttributeNS)&&
                  (scan.getAttributeNS("docuri","http://sbooks.net/")))||
                 ((scan.getAttribute)&&(scan.getAttribute("docuri")))||
                 ((scan.getAttribute)&&(scan.getAttribute("data-docuri"))));
            if (docuri) return docuri;
            else scan=scan.parentNode;}
        return Codex.docuri;}

    Codex.getRefID=function(target){
        if (target.getAttributeNS)
            return (target.getAttributeNS('sbookid','http://sbooks.net/'))||
            (target.getAttributeNS('sbookid'))||
            (target.getAttributeNS('data-sbookid'))||
            (target.codexbaseid)||(target.id);
        else return target.id;};

    function getHead(target){
        /* First, find some relevant docinfo */
        var targetid=(target.codexbaseid)||(target.id);
        if ((targetid)&&(Codex.docinfo[targetid]))
            target=Codex.docinfo[targetid];
        else if (targetid) {
            while (target)
                if ((target.id)&&(Codex.docinfo[targetid])) {
                    target=Codex.docinfo[targetid]; break;}
            else target=target.parentNode;}
        else {
            /* First, try scanning forward to find a non-empty node */
            var scan=target.firstChild; var scanid=false;
            var next=target.nextNode;
            while ((scan)&&(scan!=next)) {
                if ((scan.id)||(scan.codexbaseid)) break;
                if ((scan.nodeType===3)&&
                    (!(fdjtString.isEmpty(scan.nodeValue)))) break;
                scan=fdjtDOM.forward(scan);}
            /* If you found something, use it */
            if ((scan)&&(scan.id)&&(scan!=next))
                target=Codex.docinfo[scanid];
            else {
                while (target)
                    if ((targetid=((target.codexbaseid)||(target.id)))&&
                        (Codex.docinfo[targetid])) {
                        target=Codex.docinfo[targetid]; break;}
                else target=target.parentNode;}}
        if (target)
            if (target.level)
                return target.elt||document.getElementById(target.frag);
        else if (target.head)
            return target.head.elt||
            document.getElementById(target.head.frag);
        else return false;
        else return false;}
    Codex.getHead=getHead;

    Codex.getRef=function(target){
        while (target)
            if (target.about) break;
        else if ((target.getAttribute)&&(target.getAttribute("about"))) break;
        else target=target.parentNode;
        if (target) {
            var ref=((target.about)||(target.getAttribute("about")));
            if (!(target.about)) target.about=ref;
            if (ref[0]==='#')
                return document.getElementById(ref.slice(1));
            else return document.getElementById(ref);}
        else return false;}
    Codex.getRefElt=function(target){
        while (target)
            if ((target.about)||
                ((target.getAttribute)&&(target.getAttribute("about"))))
                break;
        else target=target.parentNode;
        return target||false;}

    Codex.checkTarget=function(){
        if ((Codex.target)&&(Codex.mode==='glosses'))
            if (!(fdjtDOM.isVisible(Codex.target))) {
                Codex.setMode(false); Codex.setMode(true);}};

    function getDups(id){
        if (!(id)) return false;
        else if (typeof id === "string") {
            if ((Codex.layout)&&(Codex.layout.dups)) {
                var dups=Codex.layout.dups;
                var d=dups[id];
                if (d) return [document.getElementById(id)].concat(d);
                else return [document.getElementById(id)];}
            else return [document.getElementById(id)];}
        else return getDups(id.codexbaseid||id.id);}
    Codex.getDups=getDups;

    function getTarget(scan,closest){
        scan=((scan.nodeType)?(scan):(scan.target||scan.srcElement||scan));
        var target=false;
        var id=false;
        var prefix=Codex.baseid;
        while (scan) {
            if (scan.codexui) return false;
            else if (scan===Codex.docroot) return target;
	    else if (scan===document.body) return target;
            else if (id=(scan.id||scan.codexbaseid)) {
                if (id.search("CODEXTMP")===0) {}
                else if (hasParent(scan,Codex.HUD)) return false;
                else if (hasParent(scan,".codexmargin")) return false;
                else if ((hasClass(scan,"sbooknofocus"))||
                         ((Codex.nofocus)&&(Codex.nofocus.match(scan)))) {}
                else if ((hasClass(scan,"sbookfocus"))||
                         ((Codex.focus)&&(Codex.focus.match(scan))))
                    return scan;
                else if (closest) return scan;
                else if (!(target)) target=scan;
                else {}}
            else {}
            scan=scan.parentNode;}
        return target;}
    Codex.getTarget=getTarget;
    
    var isEmpty=fdjtString.isEmpty;

    function notEmpty(arg){
        if (typeof arg === 'string') {
            if (isEmpty(arg)) return false;
            else return arg;}
        else return false;}

    Codex.getTitle=function(target,tryhard) {
        var targetid;
        return target.sbooktitle||
            (((targetid=((target.codexbaseid)||(target.id)))&&
              (Codex.docinfo[targetid]))?
             (notEmpty(Codex.docinfo[targetid].title)):
             (notEmpty(target.title)))||
            ((tryhard)&&
             (fdjtDOM.textify(target)).
             replace(/\n\n+/g,"\n").
             replace(/^\n+/,"").
             replace(/\n+$/,"").
             replace(/\n+/g," // ").
             replace(/^\s*\/\//,""));};

    function getinfo(arg){
        if (arg)
            if (typeof arg === 'string')
                return Codex.docinfo[arg]||fdjtKB.ref(arg,Codex.glosses)||fdjtKB.ref(arg);
        else if (arg._id) return arg;
        else if (arg.codexbaseid)
            return Codex.docinfo[arg.codexbaseid];
        else if (arg.id) return Codex.docinfo[arg.id];
        else return false;
        else return false;}
    Codex.Info=getinfo;

    /* Navigation functions */

    function setHead(head){
        if (head===null) head=Codex.content;
        else if (typeof head === "string") 
            head=getHead(fdjtID(head))||Codex.content;
        else {}
        var headid=head.codexbaseid||head.id;
        var headinfo=Codex.docinfo[headid];
        while ((headinfo)&&(!(headinfo.level))) {
            headinfo=headinfo.head;
            head=headinfo.elt;
            headid=headinfo.frag;}
        if (Codex.Trace.nav)
            fdjtLog("Codex.setHead #%s",headid);
        if (head===Codex.head) {
            if (Codex.Trace.focus) fdjtLog("Redundant SetHead");
            return;}
        else if (headinfo) {
            if (Codex.Trace.focus)
                Codex.trace("Codex.setHead",head);
            Codex.TOC.setHead(headinfo);
            window.title=headinfo.title+" ("+document.title+")";
            if (Codex.head) dropClass(Codex.head,"sbookhead");
            addClass(head,"sbookhead");
            Codex.setLocation(Codex.location);
            Codex.head=fdjtID(headid);
            Codex.TOC.setHead(headinfo);}
        else {
            if (Codex.Trace.focus)
                Codex.trace("Codex.setFalseHead",head);
            Codex.TOC.setHead(headinfo);
            Codex.head=false;}}
    Codex.setHead=setHead;

    function setLocation(location,force){
        if ((!(force)) && (Codex.location===location)) return;
        if (Codex.Trace.toc)
            fdjtLog("Setting location to %o",location);
        var info=Codex.Info(Codex.head);
        while (info) {
            var tocelt=document.getElementById("CODEXTOC4"+info.frag);
            var flytocelt=document.getElementById("CODEXFLYTOC4"+info.frag);
            var start=info.starts_at; var end=info.ends_at;
            var progress=((location-start)*100)/(end-start);
            var bar=false, appbar=false;
            if (tocelt) {
                bar=fdjtDOM.getFirstChild(tocelt,".progressbar");
                tocelt.title=Math.round(progress)+"%";}
            if (flytocelt) {
                appbar=fdjtDOM.getFirstChild(flytocelt,".progressbar");
                flytocelt.title=Math.round(progress)+"%";}
            if (Codex.Trace.toc)
                fdjtLog("For tocbar %o/%o loc=%o start=%o end=%o progress=%o",
                        bar,appbar,location,start,end,progress);
            if ((progress>=0) && (progress<=100)) {
                if (bar) bar.style.width=(progress)+"%";
                if (appbar) appbar.style.width=(progress)+"%";}
            info=info.head;}
        var spanbars=fdjtDOM.$(".spanbar");
        var i=0; while (i<spanbars.length) {
            var spanbar=spanbars[i++];
            var width=spanbar.ends-spanbar.starts;
            var ratio=(location-spanbar.starts)/width;
            if (Codex.Trace.toc)
                fdjtLog("ratio for spanbar %o[%d] is %o [%o,%o,%o]",
                        spanbar,spanbar.childNodes[0].childNodes.length,
                        ratio,spanbar.starts,location,spanbar.ends);
            if ((ratio>=0) && (ratio<=1)) {
                var progressbox=fdjtDOM.$(".progressbox",spanbar);
                if (progressbox.length>0) {
                    progressbox[0].style.left=((Math.round(ratio*10000))/100)+"%";}}}
        Codex.location=location;}
    Codex.setLocation=setLocation;

    function location2pct(location) {
        var max_loc=Codex.ends_at;
        var pct=(100*location)/max_loc;
        // This is (very roughly) intended to be the precision needed
        //  for line level (40 character) accuracy.
        var prec=Math.round(Math.log(max_loc/40)/Math.log(10))-2;
        if (prec<0) prec=0;
        return fdjtString.precString(pct,prec)+"%";}
    Codex.location2pct=location2pct;

    function setTarget(target){
        if (Codex.Trace.focus) Codex.trace("Codex.setTarget",target);
        if (target===Codex.target) return;
        else if ((Codex.target)&&
                 (Codex.target.id===target.codexbaseid))
            return;
        if (Codex.target) {
            var old_target=Codex.target, oldid=old_target.id;
            var old_targets=getDups(oldid);
            dropClass(old_target,"codextarget");
            dropClass(old_target,"codexnewtarget");
            dropClass(old_targets,"codextarget");
            dropClass(old_targets,"codexnewtarget");
            clearHighlights(old_targets);
            Codex.target=false;}
        if (!(target)) {
            if (Codex.UI.setTarget) Codex.UI.setTarget(false);
            return;}
        else if ((inUI(target))||(!(target.id||target.codexbaseid)))
            return;
        else {}
        var targetid=target.codexbaseid||target.id;
        var primary=((targetid)&&(fdjtID(targetid)))||target;
        var targets=getDups(targetid);
        addClass(targets,"codextarget");
        addClass(targets,"codexnewtarget");
        setTimeout(function(){
            dropClass(targets,"codexnewtarget");},
                   5000);
        fdjtState.setCookie(
            "codextarget",targetid||target.getAttribute('data-sbookid'));
        Codex.target=primary;
        if (Codex.UI.setTarget) Codex.UI.setTarget(primary);
        if (Codex.search_cloud)
            Codex.setCloudCuesFromTarget(Codex.search_cloud,primary);}
    Codex.setTarget=setTarget;

    function clearHighlights(target){
        if (typeof target === "string") target=fdjtID(target);
        if (!(target)) return;
        else if (target.length) {
            dropClass(target,"highlightpassage");
            var i=0, lim=target.length;
            while (i<lim) {
                var node=target[i++];
                fdjtUI.Highlight.clear(node,"highlightexcerpt");
                fdjtUI.Highlight.clear(node,"highlightsearch");}}
        else {
            dropClass(target,"highlightpassage");
            fdjtUI.Highlight.clear(target,"highlightexcerpt");
            fdjtUI.Highlight.clear(target,"highlightsearch");}}
    Codex.clearHighlights=clearHighlights;

    function findExcerpt(node,excerpt,off){
        if (typeof node === "string") node=document.getElementById(node);
        if (!(node)) return false;
        if (node.nodeType) node=getDups(node);
        var found=fdjtDOM.findString(node,excerpt,off||0);
        if (found) return found;
        var trimmed=fdjtString.trim(excerpt);
        var regex_string=trimmed.replace(/\s+/g,"(\\s+)");
        var pattern=new RegExp("(\\s*)"+regex_string+"(\\s*)","g");
        var matches=fdjtDOM.findMatches(node,pattern,off||0,1);
        if ((matches)&&(matches.length)) return matches[0];
        // We could do this more intelligently
        if (off>7) matches=fdjtDOM.findMatches(node,pattern,off-7,1);
        if ((matches)&&(matches.length)) return matches[0];
        else return false;}
    Codex.findExcerpt=findExcerpt;

    /* Navigation */

    function resizeBody(){
        if (Codex.nativescroll) {}
        else {
            /*
            var curx=x_offset-fdjtDOM.parsePX(Codex.pages.style.left);
            var cury=y_offset-fdjtDOM.parsePX(Codex.pages.style.top);
            // Codex.body.style.left=''; Codex.body.style.top='';
            var geom=fdjtDOM.getGeometry(Codex.body,Codex.body);
            x_offset=geom.left; y_offset=geom.top;
            Codex.bodyoff=[x_offset,y_offset];
            Codex.pages.style.left='0px';
            Codex.pages.style.top=(y_offset)+'px';
            */
        }}
    Codex.resizeBody=resizeBody;

    Codex.viewTop=function(){
        if (Codex.nativescroll) return fdjtDOM.viewTop();
        else return -(fdjtDOM.parsePX(Codex.pages.style.top));}
    var sbookUIclasses=
        /(\bhud\b)|(\bglossmark\b)|(\bleading\b)|(\bcodexmargin\b)/;

    function inUI(elt){
        if (elt.codexui) return true;
        else if (hasParent(elt,Codex.HUD)) return true;
        else while (elt)
            if (elt.codexui) return true;
        else if (hasClass(elt,sbookUIclasses)) return true;
        else elt=elt.parentNode;
        return false;}

    function displayOffset(){
        var toc;
        if (Codex.mode)
            if (toc=fdjtID("CODEXTOC"))
                return -((toc.offsetHeight||50)+15);
        else return -60;
        else return -40;}

    function setHashID(target){
        var targetid=target.codexbaseid||target.id;
        if ((!(targetid))||(window.location.hash===targetid)||
            ((window.location.hash[0]==='#')&&
             (window.location.hash.slice(1)===targetid)))
            return;
        if ((target===Codex.body)||(target===document.body)) return;
        window.location.hash=targetid;}
    Codex.setHashID=setHashID;

    var syncing=false;
    
    function setState(state){
        if ((Codex.state===state)||
            ((Codex.state)&&
             (Codex.state.target===state.target)&&
             (Codex.state.location===state.location)&&
             (Codex.state.page===state.page)))
            return;
        if (syncing) return;
        if (!(Codex.dosync)) return;
        if (!(state.tstamp)) state.tstamp=fdjtTime.tick();
        if (!(state.refuri)) state.refuri=Codex.refuri;
        Codex.state=state;
        if (Codex.Trace.state) fdjtLog("Setting state to %j",state);
        var statestring=JSON.stringify(state);
        var uri=Codex.docuri||Codex.refuri;
        fdjtState.setLocal("state("+uri+")",statestring);}
    Codex.setState=setState;
    
    function setConnected(val){
        if ((val)&&(!(Codex.connected))) {
            var onconnect=Codex._onconnect;
            Codex._onconnect=false;
            if ((onconnect)&&(onconnect.length)) {
                var i=0; var lim=onconnect.length;
                while (i<lim) (onconnect[i++])();}}
        if (((val)&&(!(Codex.connected)))||
            ((!(val))&&(Codex.connected)))
            fdjtDOM.swapClass(document.body,/\bcx(CONN|DISCONN)\b/,
                              ((val)?("cxCONN"):("cxDISCONN")));
        Codex.connected=val;}
    Codex.setConnected=setConnected;

    function serverSync(){
        if ((Codex.user)&&(Codex.dosync)&&(navigator.onLine)) {
            var state=Codex.state; var synced=Codex.syncstate;
            // Warning when syncing doesn't return?
            if (syncing) return;
            if (!(state)) {
                var uri=Codex.docuri||Codex.refuri;
                var statestring=fdjtState.getLocal("state("+uri+")");
                if (statestring) Codex.state=state=JSON.parse(statestring);
                else state={};}
            if ((synced)&&
                (synced.target===state.target)&&
                (synced.location===state.location)&&
                (synced.page===state.page))
                return;
            var refuri=((Codex.target)&&(Codex.getRefURI(Codex.target)))||
                (Codex.refuri);
            var uri="https://"+Codex.server+"/v1/sync?ACTION=save"+
                "&DOCURI="+encodeURIComponent(Codex.docuri)+
                "&REFURI="+encodeURIComponent(refuri);
            if (Codex.user)
                uri=uri+"&SYNCUSER="+encodeURIComponent(Codex.user._id);
            if (Codex.deviceId)
                uri=uri+"&deviceid="+encodeURIComponent(Codex.deviceId);
            if (Codex.deviceName)
                uri=uri+"&devicename="+encodeURIComponent(Codex.deviceName);
            if (state.target) uri=uri+"&target="+encodeURIComponent(state.target);
            if ((state.location)||(state.hasOwnProperty('location')))
                uri=uri+"&location="+encodeURIComponent(state.location);
            if (Codex.ends_at)
                uri=uri+"&maxloc="+encodeURIComponent(Codex.ends_at);
            if ((state.page)||(state.hasOwnProperty('page')))
                uri=uri+"&page="+encodeURIComponent(state.page);
            if (typeof Codex.pagecount === 'number')
                uri=uri+"&maxpage="+encodeURIComponent(Codex.pagecount);
            if ((Codex.Trace.dosync)||(Codex.Trace.state))
                fdjtLog("syncState(call) %s: %j",uri,state);
            var req=new XMLHttpRequest();
            syncing=state;
            req.onreadystatechange=function(evt){
                if ((req.readyState===4)&&(req.status>=200)&&(req.status<300)) {
                    Codex.syncstate=syncing;
                    setConnected(true);
                    syncing=false;}
                else if ((req.readyState===4)&&
                         (navigator.onLine))
                    setConnected(false);
                else {}
                if ((Codex.Trace.dosync)||(Codex.Trace.state))
                    fdjtLog("serverSync(callback) %o ready=%o status=%o %j",
                            evt,req.readyState,req.status,syncing);};
            req.withCredentials=true;
            try {
                req.open("GET",uri,true);
                req.send();}
            catch (ex) {Codex.dosync=false;}}}
    Codex.serverSync=serverSync;

    function forceSync(){
        if (Codex.connected) Codex.update();
        else if (Codex._onconnect)
            Codex._onconnect.push(function(){Codex.update();});
        else Codex._onconnect=[function(){Codex.update();}];
        if (!(Codex.syncstart)) Codex.syncLocation();
        else serverSync();}
    Codex.forceSync=forceSync;

    function getLocInfo(elt){
        var eltid=false;
        var counter=0; var lim=200;
        var forward=fdjtDOM.forward;
        while ((elt)&&(counter<lim)) {
            eltid=elt.codexbaseid||elt.id;
            if ((eltid)&&(Codex.docinfo[eltid])) break;
            else {counter++; elt=forward(elt);}}
        if ((eltid)&&(Codex.docinfo[eltid])) {
            var info=Codex.docinfo[eltid];
            return {start: info.starts_at,end: info.ends_at,
                    len: info.ends_at-info.starts_at};}
        else return false;}
    Codex.getLocInfo=getLocInfo;

    function resolveLocation(loc){
        var allinfo=Codex.docinfo._allinfo;
        var i=0; var lim=allinfo.length;
        while (i<lim) {
            if (allinfo[i].starts_at<loc) i++;
            else break;}
        while (i<lim)  {
            if (allinfo[i].starts_at>loc) break;
            else i++;}
        return fdjtID(allinfo[i-1].frag);}
    Codex.resolveLocation=resolveLocation;

    // This moves within the document in a persistent way
    function CodexGoTo(arg,caller,istarget,pushstate){
        if (typeof istarget === 'undefined') istarget=true;
        if (typeof pushstate === 'undefined') pushstate=true;
        var target; var location;
        if (typeof arg === 'string') {
            target=document.getElementById(arg);
            var info=getLocInfo(target);
            location=info.start;}
        else if (typeof arg === 'number') {
            location=arg;
            target=(((istarget.nodeType)&&(istarget.id))?(istarget):
                    (resolveLocation(arg)));}
        else if (arg.nodeType) {
            var info=getLocInfo(arg);
            if (arg.id) target=arg;
            else if (arg.codexbaseid) target=arg;
            else target=getTarget(arg);
            location=info.start;}
        else {
            fdjtLog.warn("Bad CodexGoTo %o",arg);
            return;}
        if (!(target)) {
            if (Codex.layout instanceof fdjt.CodexLayout)
                Codex.GoToPage(arg,caller,pushstate);
            else if (arg.nodeType) {
                var scan=arg;
                while (scan) {
                    if (scan.offsetTop) break;
                    else scan=scan.parentNode;}
                if (scan) Codex.content.style.offsetTop=-(scan.offsetTop);}
            else {}
            return;}
        var page=((Codex.bypage)&&(Codex.layout)&&
                  (Codex.pagecount)&&(Codex.getPage(target)));
        var targetid=target.codexbaseid||target.id;
        var info=((targetid)&&(Codex.docinfo[targetid]));
        if (Codex.Trace.nav)
            fdjtLog("Codex.GoTo%s() #%o@P%o/L%o %o",
                    ((caller)?("/"+caller):""),targetid,page,
                    ((info)&&(info.starts_at)),target);
        setHead(target);
        setLocation(location);
        if ((istarget)&&(targetid)&&(!(inUI(target)))) setTarget(target);
        if ((pushstate)&&(istarget))
            Codex.setState({
                target: ((Codex.target)&&(Codex.targetid)),
                location: location,page: page});
        else if (pushstate)
            Codex.setState({location: location,page: page});
        else {}
        if (page)
            Codex.GoToPage(target,caller||"CodexGoTo",false);
        else {
            if (Codex.previewing) Codex.stopPreview();
            var offinfo=fdjtDOM.getGeometry(target,Codex.content);
            var use_top=offinfo.top-((fdjtDOM.viewHeight()-50)/2);
            if (use_top<0) use_top=0;
            window.scrollTo(0,use_top);}
        Codex.location=location;}
    Codex.GoTo=CodexGoTo;

    function anchorFn(evt){
        var target=fdjtUI.T(evt);
        while (target)
            if (target.href) break; else target=target.parentNode;
        if ((target)&&(target.href)&&(target.href[0]==='#')) {
            var elt=document.getElementById(target.href.slice(1));
            if (elt) {CodexGoTo(elt,"anchorFn"); fdjtUI.cancel(evt);}}}
    Codex.anchorFn=anchorFn;

    // This jumps and disables the HUD at the same time
    function CodexJumpTo(target){
        if (Codex.hudup) Codex.setMode(false);
        CodexGoTo(target,"JumpTo");}
    Codex.JumpTo=CodexJumpTo;

    // This jumps and disables the HUD at the same time
    // We try to animate the transition
    function CodexScanTo(target){
        if (Codex.hudup) { // Figure out what mode to go to
            var headinfo=Codex.docinfo[target]||Codex.docinfo[target.id];
            if ((headinfo)&&((!(headinfo.sub))||(headinfo.sub.length===0)))
                Codex.setMode("tocscan");}
        CodexGoTo(target,"CodexScanTo");}
    Codex.ScanTo=CodexScanTo;

    // Preview functions
    var oldscroll=false; var oldsect=false;
    function CodexStartPreview(spec,caller){
        var target=((spec.nodeType)?(spec):(fdjtID(spec)));
        if (Codex.Trace.flips)
            fdjtLog("startPreview %o (%s)",target,caller);
        if (Codex.layout instanceof fdjt.CodexLayout) 
            Codex.startPagePreview(spec,caller);
        else {
            // This is the scrolling-based version
            var yoff=window.scrollTop||0;
            if (!(oldscroll)) oldscroll={x: 0,y: yoff};
            var offinfo=fdjtDOM.getGeometry(target,Codex.content);
            if (Codex.Trace.flips)
                fdjtLog("startPreview/%s to %d for %o",
                        caller||"nocaller",offinfo.top-100,spec);
            // Codex.content.style.top=(-offinfo.top)+"px";
            var use_top=offinfo.top-((fdjtDOM.viewHeight()-50)/2);
            if (use_top<0) use_top=0;
            window.scrollTo(0,use_top);
            Codex.previewing=target;}
        if (Codex.previewTarget) {
            var drop=Codex.getDups(Codex.previewTarget);
            dropClass(drop,"codexpreviewtarget");}
        Codex.previewTarget=target;
        addClass(document.body,"cxPREVIEW");
        var dups=Codex.getDups(target);
        addClass(dups,"codexpreviewtarget");
        return target;}
    Codex.startPreview=CodexStartPreview;
    function CodexStopPreview(caller){
        if (Codex.bypage) 
            Codex.stopPagePreview(caller);
        else {
            if ((Codex.Trace.flips)&&(oldscroll))
                fdjtLog("stopPreview/%s returning to %d",
                        caller||"nocaller",oldscroll.x,oldscroll.y);
            else if (Codex.Trace.flips)
                fdjtLog("stopPreview/%s, no saved position",
                        caller||"nocaller");
            // if (oldscroll) Codex.content.style.top=oldscroll.y+"px";
            window.scrollTo(0,oldscroll.y);}
        dropClass(document.body,"cxPREVIEW");
        Codex.previewing=false;
        if (Codex.previewTarget) {
            var targets=getDups(Codex.previewTarget);
            dropClass(targets,"codexpreviewtarget");
            dropClass(targets,"highlightpassage");
            Codex.clearHighlights(targets);
            Codex.previewTarget=false;}
        oldscroll=false;}
    Codex.stopPreview=CodexStopPreview;

    function getLevel(elt){
        if (elt.toclevel) {
            if (elt.toclevel==='none')
                return elt.toclevel=false;
            else return elt.toclevel;}
        var attrval=
            ((elt.getAttributeNS)&&
             (elt.getAttributeNS('toclevel','http://sbooks.net')))||
            (elt.getAttribute('toclevel'))||
            (elt.getAttribute('data-toclevel'));
        if (attrval) {
            if (attrval==='none') return false;
            else return parseInt(attrval);}
        if (elt.className) {
            var cname=elt.className;
            var tocloc=cname.search(/sbook\dhead/);
            if (tocloc>=0) return parseInt(cname.slice(5,6));}
        if (elt.tagName.search(/H\d/)==0)
            return parseInt(elt.tagName.slice(1,2));
        else return false;}
    Codex.getTOCLevel=getLevel;
    
    function getCover(){
        if (Codex.cover) return Codex.cover;
        var cover=fdjtID("CODEXCOVERPAGE")||
            fdjtID("SBOOKCOVERPAGE")||
            fdjtID("COVERPAGE");
        if (cover) {}
        else if (Codex.coverpage) {
            cover=fdjtDOM.Image(
                Codex.coverpage,"img.codexfullpage.codexcoverpage.sbookpage#CODEXCOVERPAGE");
            fdjtDOM.prepend(Codex.content,cover);}
        // This should generate a textual cover page
        else if ((!(fdjt.ID("CODEXTITLEPAGE")))&&
                 (!(fdjt.ID("SBOOKTITLEPAGE")))) {
            cover=fdjtDOM("div.codexcoverpage.codexfullpage#CODEXCOVERPAGE","\n",
                          ((Codex.booktitle)?
                           (fdjtDOM("h1.title",Codex.booktitle)):
                           null),
                          "\n",
                          ((Codex.bookauthor)?
                           (fdjtDOM("h1.author",Codex.bookauthor)):
                           null));
            fdjtDOM.prepend(Codex.content,cover);}
        if (cover) Codex.cover=cover;
        return cover;}
    Codex.getCover=getCover;

})();

/* Adding qricons */

/*
  function sbookAddQRIcons(){
  var i=0;
  while (i<Codex.heads.length) {
  var head=Codex.heads[i++];
  var id=head.id;
  var title=(head.sbookinfo)&&sbook_get_titlepath(head.sbookinfo);
  var qrhref="https://"+Codex.server+"/glosses/qricon.png?"+
  "URI="+encodeURIComponent(Codex.docuri||Codex.refuri)+
  ((id)?("&FRAG="+head.id):"")+
  ((title) ? ("&TITLE="+encodeURIComponent(title)) : "");
  var qricon=fdjtDOM.Image(qrhref,".sbookqricon");
  fdjtDOM.prepend(head,qricon);}}
*/

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/startup.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

/* Newer startup model:
   gotInfo(info)
   info has { user: {}, outlets: [], glosses: [] }
   if _sbook_loadinfo, do loadInfo(_sbook_loadinfo);
   else do a JSONP call.
*/

Codex.Startup=
    (function(){

        var fdjtString=fdjt.String;
        var fdjtState=fdjt.State;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;
        
        var sbook_faketouch=false;

        var sbook_heading_qricons=false;

        var https_root="https://beingmeta.s3.amazonaws.com/static/g/codex/";

        // Imported functions
        var cxicon=Codex.icon;

        var getLocal=fdjtState.getLocal;
        var setLocal=fdjtState.setLocal;
        var getQuery=fdjtState.getQuery;
        var getCookie=fdjtState.getCookie;
        var getMeta=fdjtDOM.getMeta;
        var getLink=fdjtDOM.getLink;
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var TOA=fdjtDOM.Array;

        var saveprops=Codex.saveprops=
            ["sources","outlets","etc","overlays","sync",
             "sync","nodeid","state"];
        
        /* Initialization */
        
        var _sbook_setup_start=false;
        
        function startupLog(){
            if (!(Codex.Trace.startup)) return;
            var args=TOA(arguments);
            fdjtLog.apply(null,arguments);}

        function startupMessage(){
            var args=TOA(arguments);
            if ((Codex.Trace.startup)&&
                (typeof Codex.Trace.startup === "number")&&
                (Codex.Trace.startup>1))
                fdjtLog.apply(null,arguments);}
        Codex.startupMessage=startupMessage;

        /* Configuration information */

        var config_handlers={};
        var default_config=
            {layout: 'bypage',
             bodysize: 'normal',bodyfamily: 'serif',
             uisize: 'normal',showconsole: false,
             animatecontent: true,animatehud: true,
             hidesplash: false,keyboardhelp: true,
             holdmsecs: 750,taptapmsecs: 500};
        var current_config={};
        var saved_config={};

        var setCheckSpan=fdjtUI.CheckSpan.set;

        function addConfig(name,handler){
            if (Codex.Trace.config>1)
                fdjtLog("Adding config handler for %s: %s",name,handler);
            config_handlers[name]=handler;}
        Codex.addConfig=addConfig;

        function getConfig(name){
            if (!(name)) return current_config;
            else return current_config[name];}
        Codex.getConfig=getConfig;

        function setConfig(name,value,save){
            if (arguments.length===1) {
                var config=name;
                Codex.postconfig=[];
                if (Codex.Trace.config) fdjtLog("batch setConfig: %s",config);
                for (var setting in config) {
                    if (config.hasOwnProperty(setting))
                        setConfig(setting,config[setting]);}
                var dopost=Codex.postconfig;
                Codex.postconfig=false;
                if ((Codex.Trace.config>1)&&(!((dopost)||(dopost.length===0))))
                    fdjtLog("batch setConfig, no post processing",config);
                var i=0; var lim=dopost.length;
                while (i<lim) {
                    if (Codex.Trace.config>1)
                        fdjtLog("batch setConfig, post processing %s",dopost[i]);
                    dopost[i++]();}
                return;}
            if (Codex.Trace.config) fdjtLog("setConfig %o=%o",name,value);
            var input_name="CODEX"+(name.toUpperCase());
            var inputs=document.getElementsByName(input_name);
            var i=0; var lim=inputs.length;
            while (i<lim) {
                var input=inputs[i++];
                if (input.tagName!=='INPUT') continue;
                if (input.type==='checkbox') {
                    if (value) setCheckSpan(input,true);
                    else setCheckSpan(input,false);}
                else if (input.type==='radio') {
                    if (value===input.value) setCheckSpan(input,true);
                    else setCheckSpan(input,false);}
                else input.value=value;}
            if (!((current_config[name])&&
                  (current_config[name]===value))) {
                if (config_handlers[name]) {
                    if (Codex.Trace.config)
                        fdjtLog("setConfig (handler=%s) %o=%o",
                                config_handlers[name],name,value);
                    config_handlers[name](name,value);}}
            current_config[name]=value;
            if (save) {
                saved_config[name]=value;
                saveConfig(saved_config);}}
        Codex.setConfig=setConfig;

        function saveConfig(config){
            if (Codex.Trace.config) {
                fdjtLog("saveConfig %o",config);
                fdjtLog("saved_config=%o",saved_config);}
            if (!(config)) config=saved_config;
            // Save automatically applies (seems only fair)
            else setConfig(config);
            var saved={};
            for (var setting in config) {
                if ((!(default_config.hasOwnProperty(setting)))||
                    (config[setting]!==default_config[setting])) {
                    saved[setting]=config[setting];}}
            if (Codex.Trace.config) fdjtLog("Saving config %o",saved);
            setLocal("codex.config",JSON.stringify(saved));
            saved_config=saved;}
        Codex.saveConfig=saveConfig;

        function initConfig(){
            var config=saved_config=
                getLocal("codex.config",true)||{};
            Codex.postconfig=[];
            if (Codex.Trace.config) fdjtLog("initConfig (saved) %o",config);
            if (config) {
                for (var setting in config) {
                    if ((config.hasOwnProperty(setting))&&
                        (!(getQuery(setting))))
                        setConfig(setting,config[setting]);}}
            else config={};
            if (Codex.Trace.config)
                fdjtLog("initConfig (default) %o",default_config);
            for (var setting in default_config) {
                if (!(config.hasOwnProperty(setting)))
                    if (default_config.hasOwnProperty(setting)) {
                        if (getQuery(setting))
                            setConfig(setting,getQuery(setting));
                        else if (getMeta("Codex."+setting))
                            setConfig(setting,getMeta("Codex."+setting));
                        else setConfig(setting,default_config[setting]);}}
            var dopost=Codex.postconfig;
            Codex.postconfig=false;
            var i=0; var lim=dopost.length;
            while (i<lim) dopost[i++]();
            
            var deviceid=current_config.deviceid;
            var devicename=current_config.devicename;
            if (!(deviceid)) {
                deviceid=fdjtState.getUUID();
                setConfig("deviceid",deviceid,true);}
            Codex.deviceId=deviceid;
            if (!(devicename)) {
                var vi=fdjtState.versionInfo(); var now=new Date();
                devicename=vi.browser+"/"+vi.platform+"/0"+
                    (now.getFullYear())+"/"+
                    ((now.getMonth())+1)+"/"+
                    (now.getDate())+"-"+(Math.floor(Math.random()*1000000));
                setConfig('devicename',devicename,true);}
            Codex.deviceName=devicename;

            saveConfig();}

        var getParent=fdjtDOM.getParent;
        var getChild=fdjtDOM.getChild;

        function updateConfig(name,id,save){
            if (typeof save === 'undefined') save=true;
            var elt=((typeof id === 'string')&&(document.getElementById(id)))||
                ((id.nodeType)&&(getParent(id,'input')))||
                ((id.nodeType)&&(getChild(id,'input')))||
                ((id.nodeType)&&(getChild(id,'textarea')))||
                ((id.nodeType)&&(getChild(id,'select')))||
                (id);
            if (Codex.Trace.config) fdjtLog("Update config %s",name);
            if ((elt.type=='radio')||(elt.type=='checkbox'))
                setConfig(name,elt.checked||false,save);
            else setConfig(name,elt.value,save);}
        Codex.updateConfig=updateConfig;

        Codex.addConfig("hidesplash",function(name,value){
            Codex.hidesplash=value;
            fdjtUI.CheckSpan.set(
                document.getElementsByName("CODEXHIDESPLASH"),
                value);});
        Codex.addConfig("keyboardhelp",function(name,value){
            Codex.keyboardhelp=value;
            fdjtUI.CheckSpan.set(
                document.getElementsByName("CODEXKEYBOARDHELP"),
                value);});
        Codex.addConfig("devicename",function(name,value){
            Codex.deviceName=value;});
        Codex.addConfig("deviceid",function(name,value){
            Codex.deviceId=value;});

        Codex.addConfig("holdmsecs",function(name,value){
            Codex.holdmsecs=value;
            fdjtUI.TapHold.interval=value;});
        Codex.addConfig("taptapmsecs",function(name,value){
            Codex.taptapmsecs=value;});

        function syncStartup(){
            // This is the startup code which is run
            //  synchronously, before the time-sliced processing
            fdjtLog.console="CODEXCONSOLELOG";
            fdjtLog.consoletoo=true;
            if (!(Codex._setup_start)) Codex._setup_start=new Date();
            fdjtLog("This is Codex version %s, built %s on %s, launched %s",
                    Codex.version,Codex.buildtime,Codex.buildhost,
                    Codex._setup_start.toString());
            if (navigator.appVersion)
                fdjtLog("Navigator App version: %s (%s)",
                        navigator.appVersion,navigator.userAgent);
            // This lets trace configurations be passed as query
            // arguments, for handy debugging.
            if (getQuery("cxtrace")) readTraceSettings();

            deviceSetup();
            appSetup();
            userSetup();

            if (Codex.Trace.startup)
                fdjtLog("Done with synchronous startup");

            // Hide the loading splash page, if any
            if (fdjtID("CODEXSPLASH"))
                fdjtID("CODEXSPLASH").style.display='none';

            Codex.setMode("splash");

            fdjtDOM.adjustFonts(fdjtID("CODEXHUD"));}

        function appSetup() {

            if (Codex.Trace.startup) fdjtLog("Starting app setup");

            // Initialize domain and origin for browsers which care
            try {document.domain="sbooks.net";}
            catch (ex) {fdjtLog.warn("Error setting document.domain");};
            try {document.origin="sbooks.net";}
            catch (ex) {fdjtLog.warn("Error setting document.origin");};

            // Execute any FDJT initializations
            fdjt.Init();

            fdjtDOM.addAppSchema("SBOOK","http://sbooks.net/");
            fdjtDOM.addAppSchema("Codex","http://codex.sbooks.net/");
            fdjtDOM.addAppSchema("DC","http://purl.org/dc/elements/1.1/");
            fdjtDOM.addAppSchema("DCTERMS","http://purl.org/dc/terms/");
            fdjtDOM.addAppSchema("OLIB","http://openlibrary.org/");
            
            // Get various settings for the sBook from the HTML (META
            // tags, etc), including settings or guidance for
            // scanning, graphics, layout, glosses, etc.
            readSettings();

            // Initialize the databases
            Codex.initDB();

            // Modifies the DOM in various ways
            initBody();
            // This initializes the book tools (the HUD/Heads Up Display)
            Codex.initHUD();

            if (Codex.coverpage) {
                var status_cover=fdjtID("CODEXSTATUSCOVER");
                status_cover.src=Codex.coverpage;
                status_cover.style.display='block';}

            addConfig(
                "persist",
                function(name,value){
                    var refuri=Codex.refuri;
                    if ((value)&&(Codex.persist)) return;
                    else if ((!(value))&&(!(Codex.persist))) return;
                    else if (value) {
                        if (!(Codex.sourcekb.storage))
                            Codex.sourcekb.storage=
                            new fdjtKB.OfflineKB(Codex.sourcekb);
                        if (!Codex.glosses.storage)
                            Codex.glosses.storage=
                            new fdjtKB.OfflineKB(Codex.glosses);
                        var props=saveprops, i=0, lim=props.length;
                        while (i<lim) {
                            var prop=saveprops[i++];
                            if (Codex[prop]) setLocal(
                                prop+"("+refuri+")",Codex[prop],true);}
                        if ((Codex.allglosses)&&(Codex.allglosses.length))
                            setLocal("glosses("+refuri+")",Codex.allglosses,
                                     true);}
                    else if (!(value)) {
                        if (getConfig("persist"))
                            clearOffline(Codex.refuri);
                        else clearOffline();}
                    Codex.persist=value;
                    setCheckSpan(fdjtID("CODEXLOCALCHECKBOX"),value);});

            // Get any local saved configuration information
            //  We do this after the HUD is setup so that the settings
            //   panel gets initialized appropriately.
            initConfig();
            Codex.persist=
                ((!(Codex.force_online))&&
                 ((Codex.force_offline)||(workOffline())));

            // Setup the UI components for the body and HUD
            Codex.setupGestures();
            
            // Setup the reticle (if desired)
            if ((typeof (document.body.style["pointer-events"])
                 != "undefined")&&
                ((Codex.demo)||(fdjtState.getLocal("codex.demo"))||
                 (fdjtState.getCookie("sbooksdemo"))||
                 (getQuery("demo")))) {
                fdjtUI.Reticle.setup();}

            // Initialize page information, etc
            initState();

            // Set up what the user sees during setup
            appsplash();
        }
        
        function userSetup(){
            if (Codex.Trace.startup) fdjtLog("Starting user setup");
            // Start JSONP call to get initial or updated glosses, etc
            if (Codex.nologin) {}
            else if (getLocal("codex.user")) {
                initUserOffline();
                Codex.sync=getLocal("sync("+Codex.refuri+")",true);
                if (Codex.Trace.storage) 
                    fdjtLog("Local info for %o (%s) from %o",
                            Codex.user._id,Codex.user.name,Codex.sync);
                // If we have local glosses, ignore any cached
                // _sbook_loadinfo because we've already processed it
                if ((Codex.sync)&&
                    (getLocal("glosses("+Codex.refuri+")"))&&
                    (window._sbook_loadinfo))
                    window._sbook_loadinfo=false;}
            else if (window._sbook_loadinfo) {
                var info=window._sbook_loadinfo;
                if (info.userinfo)
                    setUser(info.userinfo,
                            info.outlets,info.overlays,
                            info.sync);
                if (info.nodeid) setNodeID(info.nodeid);
                Codex.sync=info.sync;
                if (Codex.Trace.storage>1) 
                    fdjtLog("Cached loadinfo.js for %o (%s) from %o: %j",
                            Codex.user._id,Codex.user.name,Codex.sync,
                            Codex.user);
                if (Codex.Trace.storage) 
                    fdjtLog("Cached loadinfo.js for %o (%s) from %o",
                            Codex.user._id,Codex.user.name,Codex.sync);}
            else {}
            if (Codex.nologin) return;
            else if (window.navigator.onLine) {
                if ((Codex.user)&&(Codex.sync))
                    fdjtLog("Getting new (> %s (%d)) glosses from %s for %s",
                            fdjtTime.timeString(Codex.sync),Codex.sync,
                            Codex.server,Codex.user._id,Codex.user.name);
                else if (Codex.user)
                    fdjtLog("Getting glosses from %s for %s (%s)",
                            Codex.server,Codex.user._id,Codex.user.name);
                else fdjtLog("Getting glosses from %s",Codex.server);
                updateInfo();
                setInterval(updateInfo,300000);
                return;}
            else return;}
        Codex.userSetup=userSetup;

        function readTraceSettings(){
            var tracing=getQuery("cxtrace",true);
            var i=0; var lim=tracing.length;
            while (i<lim) {
                var trace_spec=tracing[i++];
                var colon=trace_spec.indexOf(":");
                if (colon<0) {
                    if (typeof Codex.Trace[trace_spec] === 'number')
                        Codex.Trace[trace_spec]=1;
                    else Codex.Trace[trace_spec]=true;}
                else {
                    var trace_name=trace_spec.substr(0,colon);
                    var trace_val=trace_spec.substr(colon+1);
                    if (typeof Codex.Trace[trace_name] === 'number')
                        Codex.Trace[trace_name]=parseInt(trace_val);
                    else Codex.Trace[trace_name]=trace_val;}}}

        function Startup(force){
            var metadata=false;
            if (Codex._setup) return;
            if ((!force)&&(getQuery("nocodex"))) return;
            // This is all of the startup that we need to do synchronously
            syncStartup();
            // The rest of the stuff we timeslice
            fdjtTime.timeslice
            ([  // Scan the DOM for metadata.  This is surprisingly fast,
                //  so we don't currently try to timeslice it, though we could
                function(){
                    var scanmsg=fdjtID("CODEXSTARTUPSCAN");
                    addClass(scanmsg,"running");
                    metadata=new Codex.DOMScan(Codex.content);
                    // fdjtDOM.addClass(metadata._heads,"avoidbreakafter");
                    Codex.docinfo=Codex.DocInfo.map=metadata;
                    Codex.ends_at=Codex.docinfo[Codex.content.id].ends_at;
                    dropClass(scanmsg,"running");
                    if (Codex.scandone) {
                        var donefn=Codex.scandone;
                        delete Codex.scandone;
                        donefn();}},
                // Now you're ready to lay out the book, which is
                //  timesliced and runs on its own.  We wait to do
                //  this until we've scanned the DOM because we may
                //  use results of DOM scanning in layout (for example,
                //  heading information).
                function(){
                    if (Codex.bypage) Codex.Paginate("initial");
                    else addClass(document.body,"cxSCROLL");},
                // Build the display TOC, both the dynamic (top of
                // display) and the static (inside the hudheart)
                function(){
                    var tocmsg=fdjtID("CODEXSTARTUPTOC");
                    if (tocmsg) {
                        tocmsg.innerHTML=fdjtString(
                            "Building table of contents based on %d heads",
                            Codex.docinfo._headcount);
                        addClass(tocmsg,"running");}
                    startupLog("Building table of contents based on %d heads",
                               Codex.docinfo._headcount);
                    Codex.setupTOC(metadata[Codex.content.id]);
                    dropClass(tocmsg,"running");},
                // Read knowledge bases (knodules) used by the book
                ((Knodule)&&(Knodule.HTML)&&
                 (Knodule.HTML.Setup)&&(Codex.knodule)&&
                 (function(){
                     var knomsg=fdjtID("CODEXSTARTUPKNO");
                     var knodetails=fdjtID("CODEXSTARTUPKNODETAILS");
                     if (knodetails) {
                         knodetails.innerHTML=fdjtString(
                             "Processing knodule %s",Codex.knodule.name);}
                     addClass(knomsg,"running");
                     startupLog("Processing knodule %s",Codex.knodule.name);
                     Knodule.HTML.Setup(Codex.knodule);
                     dropClass(knomsg,"running");})),
                // Process locally stored (offline data) glosses
                ((getLocal("sync("+Codex.refuri+")"))&&initGlossesOffline),
                // Process any preloaded (app cached) glosses
                ((window._sbook_loadinfo)&&(function(){
                    loadInfo(window._sbook_loadinfo);
                    window._sbook_loadinfo=false;})),
                // Process anything we got via JSONP ahead of processing
                //  _sbook_loadinfo
                ((window._sbook_newinfo)&&(function(){
                    loadInfo(window._sbook_newinfo);
                    window._sbook_newinfo=false;})),
                function(){
                    startupLog("Finding and applying Technorati-style tags");
                    applyAnchorTags();},
                function(){
                    startupLog("Finding and applying tags spans");
                    applyTagSpans();},
                function(){
                    if (window._sbook_autoindex) {
                        startupLog("Processing precompiled index");
                        Codex.useIndexData(
                            window._sbook_autoindex,
                            Codex.knodule,false,
                            function(){
                                startupLog("Indexing assigned tags");
                                Codex.indexAssignedTags(metadata,indexingDone);});
                        window._sbook_autoindex=false;}
                    else {
                        startupLog("Indexing assigned tags");
                        Codex.indexAssignedTags(metadata,indexingDone);}},
                // Figure out which mode to start up in, based on
                // query args to the book.
                function(){
                    if (!(Codex.bypage)) startupDone();
                    else if (Codex.layout) startupDone();
                    else Codex.layoutdone=startupDone;}],
             100,25);}
        Codex.Startup=Startup;
        
        function appsplash(){
            var intro=fdjtID("CODEXINTRO");
            // Take any message passed along as a query string
            //  and put it in the top of the help window, then
            //  display the help window
            if (getQuery("congratulations"))
                fdjtDOM(intro,fdjtDOM("strong","Congratulations, "),
                        getQuery("congratulations"));
            else if (getQuery("sorry"))
                fdjtDOM(intro,fdjtDOM("strong","Sorry, "),
                        getQuery("sorry"));
            else if (getQuery("weird")) 
                fdjtDOM(intro,fdjtDOM("strong","Weird, "),
                        getQuery("weird"));
            // This is the case where we're accessing the book but
            //  have arguments to pass to the flyleaf app.  The most
            //  common case here is accepting an invitation to join a
            //  group.  It will probably be common for people to use
            //  the invitation link to get to the book, but we don't
            //  want to always present them with the invitation.  So
            //  this gets a little hairy.
            if ((getQuery("ACTION"))||
                (getQuery("JOIN"))||
                (getQuery("OVERLAY"))) {
                // We have args to pass to the flyleaf app, 
                // so we initialize it:
                Codex.initFlyleafApp();
                var appframe=fdjtID("SBOOKSAPP");
                var appwindow=((appframe)&&(appframe.contentWindow));
                if ((Codex.overlays)&&(getQuery("JOIN"))&&
                    (fdjtKB.contains(Codex.overlays,getQuery("JOIN")))) {
                    // Check that it's not redundant
                    var ref=fdjtKB.ref(getQuery("JOIN"));
                    if (ref.name)
                        fdjtDOM(intro,"You've already added the overlay "+
                                ref.name);
                    fdjtDOM(intro,"You've already added the overlay.");}
                // If you have postMessage, it will be used to change
                //  modes when the sbook app actually loads
                else if (appwindow.postMessage) {}
                else {
                    Codex.joining=getQuery("JOIN");
                    Codex.setMode("sbooksapp");}}
            else if (getQuery("GLOSS"))
                Codex.glosshash=getQuery("GLOSS")[0];
            else if ((location.hash)&&(location.hash.length>=36)) {
                var hash=location.hash;
                if (hash[0]==="#") hash=hash.slice(1);
                if (hash.search("X")===0)
                    Codex.glosshash=hash.slice(2);
                else if (hash.search("GL")===0)
                    Codex.glosshash=hash.slice(2);
                else if ((hash.search("FBX")===0)||(hash.search("TWX")===0)||
                         (hash.search("GPX")===0))
                    Codex.glosshash=hash.slice(3);
                else Codex.glosshash=hash;}
                
            // This makes the splash page visible and applies some
            // other styling
            fdjtDOM.addClass(document.body,"codexstartup");
            window.focus();}
        
        function startupDone(mode){
            if ((Codex.glosshash)&&(Codex.glosses.ref(Codex.glosshash))) {
                if (Codex.showGloss(Codex.glosshash))
                    Codex.glosshash=false;
                else initLocation();}
            else initLocation();
            if (fdjtID("CODEXREADYSPLASH"))
                fdjtID("CODEXREADYSPLASH").style.display='none';
            Codex.displaySync();
            setInterval(Codex.serverSync,60000);
            fdjtDOM.dropClass(document.body,"codexstartup");
            fdjtDOM.dropClass(document.body,"codexappsplash");
            if (mode) {}
            else if (getQuery("startmode"))
                mode=getQuery("startmode");
            else if (Codex.hidesplash) 
                Codex.setMode(false);
            else {}
            if (mode) Codex.setMode(mode);
            Codex._setup=new Date();
            var msg=false;
            if (msg=getQuery("APPMESSAGE")) {
                var uuid_end=false;
                if ((msg.slice(0,2)==="#{")&&
                    ((uuid_end=msg.indexOf('}'))>0)) {
                    var msgid="MSG_"+msg.slice(2,uuid_end);
                    if (fdjtState.getLocal(msgid)) {}
                    else {
                        fdjtState.setLocal(msgid,"seen");
                        fdjtUI.alertFor(10,msg.slice(uuid_end+1));}}
                else fdjtUI.alertFor(10,msg);}
            if (msg=getQuery("SBOOKSMESSAGE")) {
                var uuid_end=false;
                if ((msg.slice(0,2)==="#{")&&
                    ((uuid_end=msg.indexOf('}'))>0)) {
                    var msgid="MSG_"+msg.slice(2,uuid_end);
                    if (fdjtState.getLocal(msgid)) {}
                    else {
                        fdjtState.setLocal(msgid,"seen");
                        fdjtUI.alertFor(10,msg.slice(uuid_end+1));}}
                else fdjtUI.alertFor(10,msg);}
            if (msg=getCookie("APPMESSAGE")) {
                fdjtUI.alertFor(10,msg);
                fdjtState.clearCookie("APPMESSAGE","sbooks.net","/");}
            if (msg=getCookie("SBOOKSMESSAGE")) {
                fdjtUI.alertFor(10,msg);
                fdjtState.clearCookie("SBOOKSMESSAGE","sbooks.net","/");}}
        
        /* Application settings */

        var optrules=
            {"paginate":["scrolling"],
             "scrolling":["paginate"],
             "touch":["mouse","kbd"],
             "mouse":["touch","kbd"],
             "kbd":["touch","mouse"]};

        function setopt(opt,flag){
            if (typeof flag === 'undefined') flag=true;
            if ((flag)&&(sbook[opt])) return;
            else if ((!(flag))&&(!(sbook[opt]))) return;
            var unset=optrules[opt];
            sbook[opt]=true;
            if (unset) {
                var i=0; var lim=unset.length;
                sbook[unset[i++]]=false;}}

        function workOffline(refuri){
            if (Codex.force_online) return false;
            else if (Codex.force_offline) return true;
            var config_val=getConfig("persist");
            if (typeof config_val !== 'undefined') return config_val;
            var value=(getMeta("Codex.offline"))||(getMeta("SBOOK.offline"));
            if ((value===0)||(value==="0")||
                (value==="no")||(value==="off")||
                (value==="never"))
                return false;
            else fdjtUI.choose(
                [{label: "No, thanks",
                  handler: function(){
                      setConfig("persist",false,true);}},
                 {label: "Yes, keep locally",
                  handler:
                  function(){
                      setConfig("persist",true,true);}},
                {label: "Ask me later",
                  handler:
                  function(){setConfig("persist",false,false);}}],
                "Store glosses on this computer?");
            return false;}
        
        var glossref_classes=false;

        function readSettings(){
            // Basic stuff
            var useragent=navigator.userAgent;
            var refuri=_getsbookrefuri();
            document.body.refuri=Codex.refuri=refuri;
            Codex.docuri=_getsbookdocuri();
            Codex.devinfo=fdjtState.versionInfo();
            
            if (fdjtState.getQuery("offline")) {
                var qval=fdjtState.getQuery("offline");
                if ((qval===false)||(qval===0)||(qval==="no")||(qval==="off")||
                    (qval==="never")||(qval==="0"))
                    Codex.force_online=true;
                else Codex.force_offline=true;}
            else if (fdjtDOM.getMeta("SBOOK.offline")) {
                var mval=fdjtDOM.getMeta("SBOOK.offline");
                if ((mval===false)||(mval===0)||(mval==="no")||(mval==="off")||
                    (mval==="never")||(mval==="0"))
                    Codex.force_online=true;
                else Codex.force_offline=true;}

            var refuris=getLocal("codex.refuris",true)||[];

            // Get the settings for scanning the document structure
            getScanSettings();

            /* Where to get your images from, especially to keep
               references inside https */
            if ((Codex.root==="http://static.beingmeta.com/g/codex/")&&
                (window.location.protocol==='https:'))
                Codex.root=https_root;
            
            // Whether to suppress login, etc
            if ((getLocal("codex.nologin"))||(getQuery("nologin")))
                Codex.nologin=true;
            Codex.bypage=(Codex.page_style==='bypage'); 
            Codex.max_excerpt=getMeta("SBOOK.maxexcerpt")||(Codex.max_excerpt);
            Codex.min_excerpt=getMeta("SBOOK.minexcerpt")||(Codex.min_excerpt);
            var sbooksrv=getMeta("SBOOK.server")||getMeta("SBOOKSERVER");
            if (sbooksrv) Codex.server=sbooksrv;
            else if (fdjtState.getCookie["SBOOKSERVER"])
                Codex.server=fdjtState.getCookie["SBOOKSERVER"];
            else Codex.server=lookupServer(document.domain);
            if (!(Codex.server)) Codex.server=Codex.default_server;
            
            refuris.push(refuri);

            var coverpage=fdjtDOM.getLink("SBOOK.coverpage",false,true)||
                fdjtDOM.getLink("coverpage",false,true);
            if (coverpage) Codex.coverpage=coverpage;
            
            var baseid=getMeta("SBOOK.baseid")||getMeta("SBOOK.prefix");
            if (baseid) Codex.baseid=baseid;
            var prefix=getMeta("SBOOK.prefix")||baseid;
            if (prefix) Codex.prefix=prefix;
            
            if (!((Codex.nologin)||(Codex.force_online))) {
                Codex.mycopyid=getMeta("SBOOK.mycopyid")||
                    (getLocal("mycopy("+refuri+")"))||
                    false;}
            setLocal("codex.refuris",refuris,true);
            
        }

        function deviceSetup(){
            var useragent=navigator.userAgent;
            var body=document.body;

            var isiPhone = (/iphone/gi).test(navigator.appVersion);
            var isTouchPad = (/Touchpad/gi).test(navigator.appVersion);
            var isiPad = (/ipad/gi).test(navigator.appVersion);
            var isAndroid = (/android/gi).test(navigator.appVersion);
            var isWebKit = navigator.appVersion.search("WebKit")>=0;
            var isWebTouch = isiPhone || isiPad || isAndroid || isTouchPad;

            if (isWebTouch) {
                fdjtDOM.addClass(body,"cxTOUCH");
                viewportSetup();
                Codex.ui="webtouch";
                Codex.touch=true;}
            if ((useragent.search("Safari/")>0)&&
                (useragent.search("Mobile/")>0)) { 
                hide_mobile_safari_address_bar();
                Codex.nativescroll=false;
                Codex.scrolldivs=false;
                Codex.updatehash=false;
                // Animation seems to increase crashes in iOS
                Codex.dontanimate=true;
                // default_config.layout='fastpage';
                default_config.keyboardhelp=false;
                // Have fdjtLog do it's own format conversion for the log
                fdjtLog.doformat=true;}
            else if (useragent.search(/Android/gi)>0) {
                default_config.keyboardhelp=false;
                Codex.nativescroll=false;
                Codex.updatehash=false;
                Codex.scrolldivs=false;}
            else if (sbook_faketouch) {
                fdjtDOM.addClass(body,"cxTOUCH");
                viewportSetup();
                Codex.ui="faketouch";}
            else {
                fdjtDOM.addClass(body,"cxMOUSE");
                Codex.ui="mouse";}
            if (!(Codex.nativescroll)) fdjtDOM.addClass(body,"cxISCROLL");
            var opt_string=
                fdjtString.stdspace(
                    ((isiPhone)?(" iPhone"):(""))+
                        ((isTouchPad)?(" TouchPad"):(""))+
                        ((isiPad)?(" iPad"):(""))+
                        ((isAndroid)?(" Android"):(""))+
                        ((isWebKit)?(" WebKit"):(""))+
                        ((isWebTouch)?(" touch"):(""))+
                        ((!(isWebTouch))?(" mouse"):(""))+
                        ((Codex.nativescroll)?(" nativescroll"):
                         (" iscroll"))+
                        ((Codex.updatehash)?(" updatehash"):
                         (" leavehash"))+
                        ((Codex.scrolldivs)?(" scrolldivs"):
                         (" noscrolldivs")));
            fdjtLog("Device: %s %dx%d ui=%s, body=\"%s\"",
                    opt_string,fdjtDOM.viewWidth(),fdjtDOM.viewHeight(),
                    Codex.ui,body.className);}

        function initUserOffline(){
            var refuri=Codex.refuri;
            var user=getLocal("codex.user");
            var sync=getLocal("sync("+refuri+")",true);
            var nodeid=getLocal("nodeid("+refuri+")");
            var userinfo=user&&getLocal(user,true);
            if (Codex.Trace.storage)
                fdjtLog("initOffline user=%s sync=%s nodeid=%s info=%j",
                        user,sync,nodeid,userinfo);
            if (!(sync)) return;
            if (!(user)) return;
            var outlets=Codex.outlets=getLocal("outlets("+refuri+")",true)||[];
            var overlays=Codex.overlays=
                getLocal("overlays("+refuri+")",true)||[];
            if (Codex.Trace.startup)
                fdjtLog("initOffline userinfo=%j",userinfo);
            Codex.allsources=getLocal("sources("+refuri+")",true)||[];
            Codex.sourcekb.Import(Codex.allsources);
            if (userinfo) setUser(userinfo,outlets,overlays,sync);
            if (nodeid) setNodeID(nodeid);
            Codex.sync=sync;}

        var offline_init=false;

        function initGlossesOffline(){
            if (offline_init) return false;
            else offline_init=true;
            var refuri=Codex.refuri;
            var sync=getLocal("sync("+refuri+")",true);
            if (!(sync)) return;
            if (Codex.Trace.glosses)
                fdjtLog("Starting initializing glosses from offline storage");
            var localglosses=getLocal("glosses("+refuri+")",true)||[];
            var queuedglosses=getLocal("queued("+refuri+")",true)||[];
            var allglosses=Codex.allglosses||[];
            localglosses=localglosses.concat(queuedglosses);
            Codex.localglosses=localglosses;
            Codex.allglosses=allglosses.concat(localglosses);
            Codex.etc=getLocal("etc("+refuri+")",true)||[];
            Codex.outlets=getLocal("outlets("+refuri+")",true)||[];
            // Load everything in etc
            var etc=Codex.etc; var outlets=Codex.outlets;
            var i=0; var lim=etc.length;
            var sourcekb=Codex.sourcekb;
            while (i<lim) sourcekb.load(etc[i++]);
            i=0; lim=outlets.length; while (i<lim) sourcekb.load(outlets[i++]);
            // Load all the glosses
            var i=0; var lim=localglosses.length;
            var glossdb=Codex.glosses;
            while (i<lim) {
                var glossid=localglosses[i++];
                var gloss=glossdb.load(glossid);
                if (Codex.Trace.storage>1)
                    fdjtLog("Restored %o: %j",glossid,gloss);}
            if ((localglosses.length)||(etc.length))
                fdjtLog("Initialized %d glosses (%d etc) from offline storage",
                        localglosses.length,etc.length);}

        /* Viewport setup */

        var viewport_spec=
            "width=device-width,initial-scale=1.0,user-scalable=no";
        function viewportSetup(){
            var head=fdjtDOM.getHEAD();
            var viewport=getMeta("viewport",false,false,true);
            if (!(viewport)) {
                viewport=document.createElement("META");
                viewport.setAttribute("name","viewport");
                viewport.setAttribute("content",viewport_spec);
                head.appendChild(viewport);}
            var isapp=getMeta("apple-mobile-web-app-capable",false,false,true);
            if (!(isapp)) {
                isapp=document.createElement("META");
                isapp.setAttribute("name","apple-mobile-web-app-capable");
                isapp.setAttribute("content","yes");
                head.appendChild(isapp);}}

        function hide_mobile_safari_address_bar(){
            window.scrollTo(0,1);
            setTimeout(function(){window.scrollTo(0,0);},0);}

        /* Getting settings */

        function _getsbookrefuri(){
            var refuri=fdjtDOM.getLink("SBOOK.refuri",false,true)||
                fdjtDOM.getLink("refuri",false,true)||
                getMeta("SBOOK.refuri",false,true)||
                getMeta("refuri",false,true)||
                getLink("canonical",false,true);
            if (refuri) return decodeURI(refuri);
            else {
                var locref=document.location.href;
                var qstart=locref.indexOf('?');
                if (qstart>=0) locref=locref.slice(0,qstart);
                var hstart=locref.indexOf('#');
                if (hstart>=0) locref=locref.slice(0,hstart);
                return decodeURI(locref);}}
        function _getsbookdocuri(){
            return fdjtDOM.getLink("SBOOK.docuri",false)||
                fdjtDOM.getLink("docuri",false)||
                fdjtDOM.getLink("canonical",false)||
                location.href;}

        function lookupServer(string){
            var sbook_servers=Codex.servers;
            var i=0;
            while (i<sbook_servers.length) 
                if (sbook_servers[i][0]===string)
                    return sbook_servers[i][1];
            else if (string.search(sbook_servers[i][0])>=0)
                return sbook_servers[i][1];
            else if ((sbook_servers[i][0].call) &&
                     (sbook_servers[i][0].call(string)))
                return sbook_servers[i][1];
            else i++;
            return false;}

        function hasTOCLevel(elt){
            if ((elt.toclevel)||
                ((elt.getAttributeNS)&&
                 (elt.getAttributeNS('toclevel','http://sbooks.net/')))||
                (elt.getAttribute('toclevel'))||
                (elt.getAttribute('data-toclevel'))||
                ((elt.className)&&
                 ((elt.className.search(/\bsbook\dhead\b/)>=0)||
                  (elt.className.search(/\bsbooknotoc\b/)>=0)||
                  (elt.className.search(/\bsbookignore\b/)>=0))))
                return true;
            else return false;}
        Codex.hasTOCLevel=hasTOCLevel;

        var headlevels=["not","A","B","C","D","E","F","G","H","I","J","K","L"];

        function getScanSettings(){
            if (!(Codex.docroot))
                if (getMeta("SBOOK.root"))
                    Codex.docroot=fdjtID(getMeta("SBOOK.root"));
            else Codex.docroot=fdjtID("SBOOKCONTENT")||document.body;
            if (!(Codex.start))
                if (getMeta("SBOOK.start"))
                    Codex.start=fdjtID(getMeta("SBOOK.start"));
            else if (fdjtID("SBOOKSTART"))
                Codex.start=fdjtID("SBOOKSTART");
            else {}
            var i=0; while (i<9) {
                var rules=getMeta("sbookhead"+i,true).
                    concat(getMeta("sbook"+i+"head",true)).
                    concat(getMeta("sbook"+headlevels[i]+"head",true));
                if ((rules)&&(rules.length)) {
                    var j=0; var lim=rules.length;
                    var elements=fdjtDOM.getChildren(document.body,rules[j++]);
                    var k=0; var n=elements.length;
                    while (k<n) {
                        var elt=elements[k++];
                        if (!(hasTOCLevel(elt))) elt.toclevel=i;}}
                i++;}
            var ignored=false;
            // These are all meta class definit6ions, which is why
            //  they don't have regular schema prefixes
            if (getMeta("sbookignore")) 
                Codex.ignore=new fdjtDOM.Selector(getMeta("sbookignore"));
            if (getMeta("sbooknotoc")) 
                Codex.notoc=new fdjtDOM.Selector(getMeta("sbooknotoc"));
            if (getMeta("sbookterminal"))
                Codex.terminals=new fdjtDOM.Selector(getMeta("sbookterminal"));
            if ((getMeta("sbookfocus"))) 
                Codex.focus=new fdjtDOM.Selector(getMeta("sbookfocus"));
            if (getMeta("sbooknofocus"))
                Codex.nofocus=new fdjtDOM.Selector(getMeta("sbooknofocus"));}

        function applyMetaClass(name){
            var meta=getMeta(name,true);
            var i=0; var lim=meta.length;
            while (i<lim) fdjtDOM.addClass(fdjtDOM.$(meta[i++]),name);}

        var note_count=1;
        function initBody(){
            var body=document.body;
            var content=fdjtDOM("div#CODEXCONTENT");
            // Get any author provided splash page
            var splash=fdjtID("CODEXSPLASH");
        
            body.setAttribute("tabindex",1);

            // Save those DOM elements in a handy place
            Codex.content=content;

            // Move the publisher-provided splash page directly into
            //  the body (if neccessary)
            if ((splash)&&(splash.parentNode!==body))
                fdjtDOM.prepend(body,splash);
            var children=body.childNodes, nodes=[];
            var i=0, lim=children.length;
            if (splash) {
                // Gather all of the nodes before the splash page.
                //   There should really be any, but we'll check anyway.
                while (i<lim) {
                    //  We're trying to minimize display artifacts during
                    //   startup and this shuffling about might help in
                    //   some browsers.
                    var child=children[i++];
                    if (child===splash) {i++; break;}
                    else nodes.push(child);}}
            // Now copy the rest of the nodes into the array
            while (i<lim) nodes.push(children[i++]);
            
            // Create a custom stylesheet for the app
            var style=fdjtDOM("STYLE");
            fdjtDOM(document.head,style);
            Codex.stylesheet=style.sheet;

            // Initialize cover and titlepage (if specified)
            Codex.cover=Codex.getCover();
            Codex.titlepage=fdjtID("SBOOKTITLEPAGE");

            var i=0; var lim=nodes.length;
            // Now, move all of the body nodes into the content element
            while (i<lim) {
                var node=nodes[i++];
                if (node.nodeType===1) {
                    if ((node.tagName!=='LINK')&&(node.tagName!=='META')&&
                        (node.tagName!=='SCRIPT'))
                        content.appendChild(node);}
                else content.appendChild(node);}

            // Gather special content
            var allnotes=fdjtID("SBOOKNOTES");
            var allasides=fdjtID("SBOOKASIDES");
            var alldetails=fdjtID("SBOOKDETAILS");
            if (!(alldetails)) {
                var alldetails=fdjtDOM("div#SBOOKDETAILS");
                fdjtDOM(content,alldetails);}
            if (!(allasides)) {
                var allasides=fdjtDOM("div#SBOOKASIDES");
                fdjtDOM(content,allasides);}
            if (!(allnotes)) {
                var allnotes=fdjtDOM("div.sbookbackmatter#SBOOKNOTES");
                fdjtDOM(content,allnotes);}
            
            var pages=Codex.pages=fdjtID("CODEXPAGES")||
                fdjtDOM("div#CODEXPAGES");
            var page=Codex.page=fdjtDOM(
                "div#CODEXPAGE",
                fdjtDOM("div#CODEXPAGINATING","Laid out ",
                        fdjtDOM("span#CODEXPAGEPROGRESS",""),
                        " pages"),
                pages);
            
            fdjtDOM(body,content,page);
            fdjtDOM.addClass(body,"sbook");
            sizePage(page,content);
            applyMetaClass("sbookdetails");
            applyMetaClass("sbooknoteref");
            applyMetaClass("sbookbibref");
            applyMetaClass("sbookxnote");
            applyMetaClass("sbookaside");
            applyMetaClass("sbookbackmatter");
            var sbookxnotes=fdjtDOM.$("sbookxnote");
            // Add refs for all of the xnotes
            var i=0; var lim=sbookxnotes.length;
            while (i<lim) {
                var note=sbookxnotes[i++];
                var anchor=fdjtDOM("A.sbooknoteref","\u2193");
                var count=note_count++;
                anchor.id="SBOOKNOTEREF"+count;
                if (!(note.id)) note.id="SBOOKNOTE"+count;
                anchor.href="#"+note.id;
                fdjtDOM.insertBefore(note,anchor);}
            // Move all the notes to the end
            var noterefs=fdjtDOM.$(".sbooknoteref,.sbookbibref");
            var i=0; var lim=noterefs.length;
            while (i<lim) {
                var noteref=noterefs[i++];
                var idcontext=Codex.getTarget(noteref.parentNode);
                if ((noteref.href)&&(noteref.href[0]==='#')) {
                    var noteid=noteref.href.slice(1);
                    var notenode=fdjtID(noteid);
                    if (!(notenode)) continue;
                    if ((noteref.id)||(idcontext)) {
                        var backanchor=fdjtDOM("A.sbooknotebackref","\u2191");
                        backanchor.href="#"+noteref.id||(idcontext.id);
                        fdjtDOM.prepend(notenode,backanchor);}
                    if ((idcontext)&&(fdjtDOM.hasClass(noteref,"sbooknoteref")))
                        notenode.codextocloc=idcontext.id;
                    if ((fdjtDOM.hasClass(noteref,"sbooknoteref"))&&
                        (!(fdjtDOM.hasParent(notenode,".sbookbackmatter"))))
                        fdjtDOM.append(allnotes,notenode);}}
            // Move all the details to the end
            var details=fdjtDOM.$("detail,.sbookdetail");
            var i=0; var lim=details.length;
            while (i<lim) {
                var detail=details[i++];
                var head=fdjtDOM.getChild(detail,"summary,.sbooksummary");
                var detailhead=
                    ((head)?(fdjtDOM.clone(head)):
                     fdjtDIV("div.sbookdetailstart",
                             (fdjtString.truncate(fdjtDOM.textify(detail),42))));
                var anchor=fdjtDOM("A.sbookdetailref",detailhead);
                var count=detail_count++;
                if (!(detail.id)) detail.id="SBOOKDETAIL"+count;
                anchor.href="#"+detail.id; anchor.id="SBOOKDETAILREF"+count;
                fdjtDOM.replace(detail,anchor);
                detail.codextocloc=anchor.id;
                fdjtDOM.append(alldetails,detail);}
            // Move all the asides to the end
            var asides=fdjtDOM.$("aside,.sbookaside");
            var i=0; var lim=asides.length;
            while (i<lim) {
                var aside=asides[i++];
                var head=fdjtDOM.getChild(aside,".sbookasidehead")||
                    fdjtDOM.getChild(aside,"HEADER")||
                    fdjtDOM.getChild(aside,"H1")||
                    fdjtDOM.getChild(aside,"H2")||
                    fdjtDOM.getChild(aside,"H3")||
                    fdjtDOM.getChild(aside,"H4")||
                    fdjtDOM.getChild(aside,"H5")||
                    fdjtDOM.getChild(aside,"H6");
                var asidehead=
                    ((head)?(fdjtDOM.clone(head)):
                     fdjtDIV("div.sbookasidestart",
                             (fdjtString.truncate(fdjtDOM.textify(aside),42))));
                var anchor=fdjtDOM("A.sbookasideref",asidehead);
                var count=aside_count++;
                if (!(aside.id)) aside.id="SBOOKASIDE"+count;
                anchor.href="#"+aside.id; anchor.id="SBOOKASIDEREF"+count;
                fdjtDOM.insertBefore(aside,anchor);
                aside.codextocloc=anchor.id;
                fdjtDOM.append(allasides,aside);}
            // Initialize the margins
            initMargins();
            if (Codex.Trace.startup>1)
                fdjtLog("Initialized body");}

        function sizePage(page,content){
            content.style.left=page.style.left='';
            content.style.right=page.style.right='';
            var page_width=fdjtDOM.getGeometry(page).width;
            var page_height=fdjtDOM.getGeometry(page).height;
            var content_width=fdjtDOM.getGeometry(content).width;
            var view_width=fdjtDOM.viewWidth();
            var page_margin=(view_width-page_width)/2;
            var content_margin=(view_width-content_width)/2;
            if (page_margin>=50) {
                page.style.left=(page_margin+15)+'px';
                page.style.right=(page_margin-15)+'px';}
            if (content_margin>=50) {
                content.style.left=content_margin+'px';
                content.style.right=content_margin+'px';}}
        Codex.sizePage=sizePage;
        
        /* Margin creation */

        function initMargins(){
            var topleading=fdjtDOM("div#SBOOKTOPLEADING.leading.top"," ");
            var bottomleading=fdjtDOM("div#SBOOKBOTTOMLEADING.leading.bottom"," ");
            topleading.codexui=true; bottomleading.codexui=true;
            
            var pagehead=fdjtDOM("div.codexmargin#CODEXPAGEHEAD"," ");
            var pageright=fdjtDOM("div#CODEXPAGERIGHT");
            var pageleft=fdjtDOM("div#CODEXPAGELEFT");
            
            var pageinfo=
                fdjtDOM("div#CODEXPAGEINFO",
                        fdjtDOM("div.textfoot",
                                fdjtDOM("span#CODEXPAGENO",
                                        fdjtDOM("span#CODEXPAGENOTEXT","p/n")),
                                fdjtDOM("span.locoff#CODEXLOCOFF","??%")),
                        fdjtDOM("div.pagespans#CODEXPAGESPANS"));
            var pagefoot=fdjtDOM("div.codexmargin#CODEXPAGEFOOT",pageinfo," ");
            pagehead.codexui=true; pagefoot.codexui=true;
            Codex.pagehead=pagehead; Codex.pagefoot=pagefoot;
            
            fdjtDOM.prepend(document.body,pagehead,pagefoot,pageleft,pageright);

            for (var pagelt in [pagehead,pageright,pageleft,pagefoot,pageinfo]) {
                fdjtDOM.addListeners(
                    pageinfo,Codex.UI.handlers[Codex.ui]["#"+pagelt.id]);}

            window.scrollTo(0,0);
            
            // The better way to do this might be to change the stylesheet,
            //  but fdjtDOM doesn't currently handle that 
            var bgcolor=getBGColor(document.body)||"white";
            Codex.backgroundColor=bgcolor;
            if (bgcolor==='transparent')
                bgcolor=fdjtDOM.getStyle(document.body).backgroundColor;
            if ((bgcolor)&&(bgcolor.search("rgba")>=0)) {
                if (bgcolor.search(/,\s*0\s*\)/)>0) bgcolor='white';
                else {
                    bgcolor=bgcolor.replace("rgba","rgb");
                    bgcolor=bgcolor.replace(/,\s*((\d+)|(\d+.\d+))\s*\)/,")");}}
            else if (bgcolor==="transparent") bgcolor="white";
            pagehead.style.backgroundColor=bgcolor;
            pagefoot.style.backgroundColor=bgcolor;
            fdjtDOM.addListener(window,"resize",function(evt){
                if (Codex.dont_resize) return;
                Codex.resizeBody();
                Codex.sizePage(Codex.page,Codex.content);
                Codex.resizeHUD();
                if ((Codex.layout)&&(Codex.layout.onresize))
                    Codex.layout.onresize(evt||event);});}
        
        function getBGColor(arg){
            var color=fdjtDOM.getStyle(arg).backgroundColor;
            if (!(color)) return false;
            else if (color==="transparent") return false;
            else if (color.search(/rgba/)>=0) return false;
            else return color;}

        /* Loading meta info (user, glosses, etc) */

        function loadInfo(info) {
            if ((window._sbook_loadinfo!==info)&&(Codex.user))
                Codex.setConnected(true);
            if (!(Codex.user)) {
                if (info.userinfo)
                    setUser(info.userinfo,
                            info.outlets,info.overlays,
                            info.sync);
                else addClass(document.body,"cxNOUSER");
                if (info.nodeid) setNodeID(info.nodeid);
                if (info.sync) Codex.sync=info.sync;}
            else if (info.wronguser) {
                Codex.clearOffline(Codex.refuri);
                window.location=window.location.href;
                return;}
            if (info.mycopyid) {
                if ((Codex.mycopyid)&&
                    (info.mycopid!==Codex.mycopyid))
                    fdjtLog.warn("Mismatched mycopyids");
                else Codex.mycopyid=info.mycopyid;}
            if (!(Codex.docinfo)) { /* Scan not done */
                Codex.scandone=function(){loadInfo(info);};
                return;}
            else if (info.loaded) return;
            if (window._sbook_loadinfo) {
                // This means that we have more information from the gloss
                // server before the local app has gotten around to
                // processing  the app-cached loadinfo.js
                // In this case, we put it in _sbook_new_loadinfo
                window._sbook_newinfo=info;
                return;}
            var refuri=Codex.refuri;
            if ((Codex.persist)&&
                (info)&&(info.userinfo)&&(Codex.user)&&
                (info.userinfo._id!==Codex.user._id)) {
                clearOffline(refuri);}
            var persist=((Codex.persist)&&(navigator.onLine));
            info.loaded=fdjtTime();
            if ((!(Codex.localglosses))&&
                ((getLocal("sync("+refuri+")"))||
                 (getLocal("queued("+refuri+")"))))
                initGlossesOffline();
            if (Codex.Trace.glosses) {
                fdjtLog("loadInfo for %d %sglosses and %d refs (sync=%d)",
                        ((info.glosses)?(info.glosses.length):(0)),
                        ((Codex.sync)?("updated "):("")),
                        ((info.etc)?(info.etc.length):(0)),
                        info.sync)
                fdjtLog("loadInfo got %d sources, %d outlets, and %d overlays",
                        ((info.sources)?(info.sources.length):(0)),
                        ((info.outlets)?(info.outlets.length):(0)),
                        ((info.overlays)?(info.overlays.length):(0)));}
            if ((info.glosses)||(info.etc))
                initGlosses(info.glosses,info.etc);
            if (info.etc) gotInfo("etc",info.etc,persist);
            if (info.sources) gotInfo("sources",info.sources,persist);
            if (info.outlets) gotInfo("outlets",info.outlets,persist);
            if (info.overlays) gotInfo("overlays",info.overlays,persist);
            Codex.addOutlets2UI(info.outlets);
            if ((info.sync)&&((!(Codex.sync))||(info.sync>=Codex.sync))) {
                if (Codex.persist) setLocal("sync("+refuri+")",info.sync);
                Codex.sync=info.sync;}
            Codex.loaded=info.loaded=fdjtTime();
            if (Codex.glosshash) {
                if (Codex.showGloss(Codex.glosshash))
                    Codex.glosshash=false;}}
        Codex.loadInfo=loadInfo;

        var updating=false;
        Codex.updatedInfo=function(data){
            loadInfo(data);
            updating=false;};
        function updateInfo(callback){
            if (updating) return;
            if (!(navigator.onLine)) return;
            if (!(callback)) callback="Codex.updatedInfo";
            var elt=fdjtID("CODEXUPDATEINFO");
            var update_script=fdjtDOM("script#CODEXUPDATEINFO");
            var uri="https://"+Codex.server+"/v1/loadinfo.js?REFURI="+
                encodeURIComponent(Codex.refuri)+"&CALLBACK=Codex.updatedInfo";
            var glosses=fdjtState.getQuery("GLOSS");
            if ((glosses)&&(glosses.length)) {
                var i=0, lim=glosses.length; while (i<lim)
                    uri=uri+"&GLOSS="+glosses[i++];}
            if (Codex.mycopyid)
                uri=uri+"&MCOPYID="+encodeURIComponent(Codex.mycopyid);
            if (Codex.sync) uri=uri+"&SYNC="+(Codex.sync+1);
            if (Codex.user) uri=uri+"&SYNCUSER="+Codex.user._id;
            update_script.language="javascript";
            update_script.type="text/javascript";
            update_script.setAttribute("charset","utf-8");
            update_script.setAttribute("async","async");
            if (Codex.mycopyid)
                update_script.setAttribute("crossorigin","anonymous");
            else update_script.setAttribute("crossorigin","use-credentials");
            update_script.src=uri;
            updating=true;
            if (elt) fdjtDOM.replace(elt,update_script);
            else document.body.appendChild(update_script);}

        function getUser() {
            var refuri=Codex.refuri;
            var loadinfo=window._sbook_loadinfo||false;
            if (Codex.Trace.startup>1)
                fdjtLog("Getting user for %o cur=%o",refuri,Codex.user);
            if (Codex.user) return Codex.user;
            else if (Codex.nologin) return false;
            if ((loadinfo)&&(gotUser(loadinfo)))
                return Codex.user;
            else if ((typeof _sbook_userinfo !== 'undefined')&&
                     gotUser(_sbook_userinfo))
                return Codex.user;
            if (getLocal("codex.user")) {
                var user=getLocal("codex.user");
                if (Codex.Trace.startup)
                    fdjtLog("Restoring offline user info for %o reading %o",
                            user,refuri);
                var userinfo=JSON.parse(getLocal(user));
                var sources=getLocal("sources("+refuri+")",true);
                var outlets=getLocal("outlets("+refuri+")",true);
                var nodeid=getLocal("nodeid("+refuri+")");
                var sync=getLocal("codex.usersync",true);
                gotUser(userinfo,nodeid,sources,outlets,etcinfo,sync);
                return;}
            else if ((!(fdjtID("SBOOKLOADINFO")))&&
                     (!(fdjtID("CODEXLOADINFO")))) {
                updateInfo("Codex.gotInfo");
                fdjtDOM.addClass(document.body,"cxNOUSER");}
            else fdjtDOM.addClass(document.body,"cxNOUSER");}
        
        function setUser(userinfo,outlets,overlays,sync){
            var persist=((Codex.persist)&&(navigator.onLine));
            var refuri=Codex.refuri;
            if (userinfo) {
                fdjtDOM.dropClass(document.body,"cxNOUSER");
                fdjtDOM.addClass(document.body,"cxUSER");}
            if (Codex.user)
                if (userinfo._id===Codex.user._id) {}
            else throw { error: "Can't change user"};
            var cursync=Codex.sync;
            if ((cursync)&&(cursync>=sync)) {
                fdjtLog.warn(
                    "Cached user information is newer (%o) than loaded (%o)",
                    cursync,sync);
                return false;}
            Codex.user=fdjtKB.Import(userinfo);
            if (persist) setConfig("persist",true,true);
            if (outlets) Codex.outlets=outlets;
            if (overlays) Codex.overlays=overlays;
            if (persist) {
                setLocal(Codex.user._id,Codex.user,true);
                setLocal("codex.user",Codex.user._id);}
            setupUI4User();
            return Codex.user;}
        Codex.setUser=setUser;
        
        function setNodeID(nodeid){
            var refuri=Codex.refuri;
            if (!(Codex.nodeid)) {
                Codex.nodeid=nodeid;
                if ((nodeid)&&(Codex.persist))
                    setLocal("nodeid("+refuri+")",nodeid);}}
        Codex.setNodeID=setNodeID;

        function setupUI4User(){
            if (Codex._user_setup) return;
            if (!(Codex.user)) {
                fdjtDOM.addClass(document.body,"cxNOUSER");
                return;}
            fdjtDOM.dropClass(document.body,"cxNOUSER");
            var username=Codex.user.name;
            if (fdjtID("CODEXUSERNAME"))
                fdjtID("CODEXUSERNAME").innerHTML=username;
            var names=document.getElementsByName("CODEXUSERNAME");
            if (names) {
                var i=0, lim=names.length;
                while (i<lim) names[i++].innerHTML=username;}
            if (fdjtID("SBOOKMARKUSER"))
                fdjtID("SBOOKMARKUSER").value=Codex.user._id;

            // Initialize the splashform, which provides easy login
            // and social features
            var splashform=fdjtID("CODEXSPLASHFORM");
            var docinput=fdjtDOM.getInput(splashform,"DOCURI");
            if (docinput) docinput.value=Codex.docuri;
            var refinput=fdjtDOM.getInput(splashform,"REFURI");
            if (refinput) refinput.value=Codex.refuri;
            var topinput=fdjtDOM.getInput(splashform,"TOPURI");
            if (topinput) topinput.value=document.location.href;
            var xquery=fdjtDOM.getInput(splashform,"XQUERY");
            var query=document.location.query;
            if (xquery) xquery.value=(((query)&&(query!=="?"))?(query):"");

            /* Initialize add gloss prototype */
            var ss=Codex.stylesheet;
            var form=fdjtID("CODEXADDGLOSSPROTOTYPE");
            var buttons=fdjtID("CODEXNETWORKBUTTONS");
            var getChild=fdjtDOM.getChild;
            if (Codex.user.fbid)  
                ss.insertRule(
                    "div#CODEXHUD span.facebook_share { display: inline;}",
                    ss.cssRules.length);
            if (Codex.user.twitterid) 
                ss.insertRule(
                    "div#CODEXHUD span.twitter_share { display: inline;}",
                    ss.cssRules.length);
            if (Codex.user.linkedinid) 
                ss.insertRule(
                    "div#CODEXHUD span.linkedin_share { display: inline;}",
                    ss.cssRules.length);
            if (Codex.user.googleid) 
                ss.insertRule(
                    "div#CODEXHUD span.google_share { display: inline;}",
                    ss.cssRules.length);
            var pic=
                (Codex.user.pic)||
                ((Codex.user.fbid)&&
                 ("https://graph.facebook.com/"+Codex.user.fbid+
                  "/picture?type=square"));
            if (pic) {
                if (fdjtID("SBOOKMARKIMAGE")) fdjtID("SBOOKMARKIMAGE").src=pic;
                if (fdjtID("CODEXUSERPIC")) fdjtID("CODEXUSERPIC").src=pic;
                var byname=document.getElementsByName("CODEXUSERPIC");
                if (byname) {
                    var i=0; var lim=byname.length;
                    while (i<lim) byname[i++].src=pic;}}
            var idlinks=document.getElementsByName("IDLINK");
            if (idlinks) {
                var i=0; var len=idlinks.length;
                while (i<len) {
                    var idlink=idlinks[i++];
                    idlink.target='_blank';
                    idlink.title='click to edit your personal information';
                    idlink.href='https://auth.sbooks.net/my/profile';}}
            if (Codex.user.friends) {
                var friends=Codex.user.friends;
                var i=0; var lim=friends.length;
                while (i<lim) {
                    var friend=fdjtKB.ref(friends[i++]);
                    Codex.addTag2GlossCloud(friend);}}
            Codex._user_setup=true;}
        
        // Processes info loaded remotely
        function gotInfo(name,info,persist) {
            var refuri=Codex.refuri;
            if (info) {
                if (info instanceof Array) {
                    var i=0; var lim=info.length; var qids=[];
                    while (i<lim) {
                        if (typeof info[i] === 'string') {
                            var qid=info[i++];
                            if (Codex.persist) fdjtKB.load(qid);
                            qids.push(qid);}
                        else {
                            var obj=fdjtKB.Import(info[i++]);
                            if (persist) 
                                setLocal(obj._id,obj,true);
                            qids.push(obj._id);}}
                    Codex[name]=qids;
                    if (Codex.persist)
                        setLocal(name+"("+refuri+")",qids,true);}
                else {
                    var obj=fdjtKB.Import(info);
                    if (persist) 
                        setLocal(obj._id,obj,true);
                    Codex[name]=obj._id;
                    if (persist)
                        setLocal(name+"("+refuri+")",qid,true);}}}

        function setupGlosses(newglosses) {
            var allglosses=Codex.allglosses||[];
            Codex.glosses.Import(newglosses);
            if (newglosses.length) {
                var n=newglosses.length; var i=0; while (i<n) {
                    var gloss=newglosses[i++];
                    var id=gloss._id;
                    var tstamp=gloss.syncstamp||gloss.tstamp;
                    if (tstamp>latest) latest=tstamp;
                    allglosses.push(id);}}
            Codex.syncstamp=latest;
            Codex.allglosses=allglosses;
            if (Codex.persist) {
                setLocal("etc("+Codex.refuri+")",Codex.etc,true);
                setLocal("glosses("+Codex.refuri+")",allglosses,true);}}

        function initGlosses(glosses,etc){
            var msg=fdjtID("CODEXNEWGLOSSES");
            var allglosses=Codex.allglosses;
            if (msg) {
                msg.innerHTML=fdjtString(
                    "Assimilating %d new glosses",glosses.length);
                addClass(msg,"running");}
            if (etc) {
                startupLog("Assimilating %d new glosses/%d sources...",
                           glosses.length,etc.length);}
            else {
                startupLog("Assimilating %d new glosses...",glosses.length);}
            fdjtKB.Import(etc);
            Codex.glosses.Import(glosses);
            var i=0; var lim=glosses.length;
            var latest=Codex.syncstamp||0;
            while (i<lim) {
                var gloss=glosses[i++]; var id=gloss._id;
                var tstamp=gloss.syncstamp||gloss.tstamp;
                if (tstamp>latest) latest=tstamp;
                allglosses.push(id);}
            Codex.syncstamp=latest;
            Codex.allglosses=allglosses;
            startupLog("Done assimilating %d new glosses...",glosses.length);
            if (Codex.persist) {
                setLocal("glosses("+Codex.refuri+")",allglosses,true);
                setLocal("etc("+Codex.refuri+")",etc,true);}
            dropClass(msg,"running");}
        Codex.Startup.initGlosses=initGlosses;
        
        function go_online(evt){return offline_update();}
        function offline_update(){
            Codex.writeGlosses(); updateInfo();}
        function offline_import(results){
            fdjtKB.Import(results);
            var i=0; var lim=results.length;
            var syncstamp=Codex.syncstamp; var tstamp=false;
            while (i<lim) {
                tstamp=results[i++].tstamp;
                if ((tstamp)&&(tstamp>syncstamp)) syncstamp=tstamp;}
            Codex.syncstamp=syncstamp;
            setLocal("syncstamp("+Codex.refuri+")",syncstamp);}
        Codex.update=offline_update;
        
        fdjtDOM.addListener(window,"online",go_online);

        function initState() {
            var uri=Codex.docuri||Codex.refuri;
            var statestring=getLocal("state("+uri+")");
            if (statestring)
                Codex.state=state=JSON.parse(statestring);}
        
        /* This initializes the sbook state to the initial location with the
           document, using the hash value if there is one. */ 
        function initLocation() {
            var state=Codex.state;
            if (!(state)) {
                var uri=Codex.docuri||Codex.refuri;
                var statestring=getLocal("state("+uri+")");
                if (statestring) {
                    Codex.state=state=JSON.parse(statestring);
                    if (Codex.Trace.state)
                        fdjtLog("Got state from local storage: %j",
                                state);}
                else state={};}
            var hash=window.location.hash; var target=false;
            if ((typeof hash === "string") && (hash.length>0)) {
                if ((hash[0]==='#') && (hash.length>1))
                    target=document.getElementById(hash.slice(1));
                else target=document.getElementById(hash);
                if (Codex.Trace.startup>1)
                    fdjtLog("sbookInitLocation hash=%s=%o",hash,target);}
            if (target) Codex.GoTo(target,"initLocation/hash",true,true);
            else if ((state)&&(state.location)) {
                Codex.GoTo(state.location,"initLocation/state.locaion",
                           false,false);
                if (state.target) Codex.setTarget(state.target);}
            else if ((state)&&(state.target)&&(fdjtID(state.target)))
                Codex.GoTo(state.target,"initLocation/state.target",true,true);
            else if (Codex.start||Codex.cover||Codex.titlepage)
                Codex.GoTo((Codex.start||Codex.cover||Codex.titlepage),
                           "initLocation/start/cover/titlepage",
                           false,false);
            if ((Codex.user)&&(Codex.dosync)&&(navigator.onLine))
                syncLocation();}
        
        function syncLocation() {
            if (!(Codex.user)) return;
            var uri="https://"+Codex.server+"/v1/sync"+
                "?DOCURI="+encodeURIComponent(Codex.docuri)+
                "&REFURI="+encodeURIComponent(Codex.refuri);
            if (Codex.Trace.dosync)
                fdjtLog("syncLocation(call) %s",uri);
            try {
                fdjt.Ajax(function(req){
                    var d=JSON.parse(req.responseText);
                    Codex.setConnected(true);
                    Codex.syncstart=true;
                    if (Codex.Trace.dosync)
                        fdjtLog("syncLocation(callback) %s: %j",uri,d);
                    if ((!(d))||(!(d.location))) {
                        if (!(Codex.state))
                            Codex.GoTo(Codex.start||Codex.docroot||Codex.body,
                                       "syncLocation",false,false);
                        return;}
                    else if ((!(Codex.state))||(Codex.state.tstamp<d.tstamp)) {
                        if ((d.location)&&(d.location<=Codex.location)) return;
                        if (d.page===Codex.curpage) return;
                        var msg1="Sync to L"+Codex.location2pct(d.location);
                        var msg2=((d.page)&&("(page "+d.page+")"));
                        fdjtUI.choose([
                            {label: "No"},
                            {label: "Yes, sync",selected: true,
                             handler: function() {
                                 if ((d.location)&&(d.target)) {
                                     Codex.GoTo(
                                         d.location,"sync",d.target,true);
                                     Codex.setState(d);}}}],
                                      fdjtDOM("div",msg1),
                                      fdjtDOM("div.smaller",msg2));}},
                          uri,false,
                          function(req){
                              if ((req.readyState == 4)&&(navigator.onLine))
                                  Codex.setConnected(false);});}
            catch (ex) {Codex.dosync=false;}}
        Codex.syncLocation=syncLocation;

        /* Indexing tags */
        
        function indexingDone(){
            startupLog("Content indexing is completed");
            if (Codex.loaded) {
                startupLog("Setting up tag clouds");
                initClouds();}
            else {
                Codex.whenloaded=function(){
                    startupLog("Setting up tag clouds");
                    initClouds();};}}
        
        /* Using the autoindex generated during book building */
        function useIndexData(autoindex,knodule,baseweight,whendone){
            var sbook_index=Codex.index;
            if (!(autoindex)) return;
            if (!(sbook_index)) return;
            for (var tag in autoindex) {
                if (!(autoindex.hasOwnProperty(tag))) continue;
                var ids=autoindex[tag];
                var starpower=tag.search(/[^*]/);
                // all stars or empty string, just ignore
                if (starpower<0) continue;
                var weight=((tag[0]==='~')?(0):(2*starpower));
                var literal=(tag[0]==='~');
                var knode=((tag.indexOf('|')>=0)?
                           (knodule.handleSubjectEntry(tag)):
                           (tag[0]==='~')?(tag.slice(1)):
                           (knodule.handleSubjectEntry(tag)));
                if ((literal)&&(typeof knode !== 'string'))
                    knode.literal=knode.weak=true;
                var i=0; var lim=ids.length;
                while (i<lim) {
                    var idinfo=ids[i++];
                    var frag=((typeof idinfo === 'string')?
                              (idinfo):(idinfo[0]));
                    var info=Codex.docinfo[frag];
                    // Pointer to non-existent node.  Warn here?
                    if (!(info)) continue;
                    var tagval=((typeof knode === 'string')?(knode):
                                (knode._qid||knode.dterm));
                    if (info.autotags) info.autotags.push(tagval);
                    else info.autotags=[tagval];
                    if (typeof knode !== 'string') {
                        if (info.knodes) info.knodes.push(knode);
                        else info.knodes=[knode];}
                    if (typeof idinfo === 'string') {}
                    // When the idinfo is an array, the first
                    // element is the id itself and the remaining
                    // elements are the text strings which
                    // actually matches the tag (we use this for
                    // highlighting).
                    else {
                        var knodeterms=info.knodeterms, terms;
                        // If it's the regular case, we just assume that
                        if (!(info.knodeterms)) {
                            knodeterms=info.knodeterms={};
                            knodeterms[tagval]=terms=[];}
                        else if (terms=knodeterms[tagval]) {}
                        else knodeterms[tagval]=terms=[];
                        var j=1; var jlim=idinfo.length;
                        while (j<jlim) {terms.push(idinfo[j++]);}}
                    sbook_index.add(
                        info._id,knode,starpower||baseweight||0,
                        knodule);}}
            if (whendone) whendone();}
        Codex.useIndexData=useIndexData;
        
        /* Applying various tagging schemes */

        function applyTagSpans() {
            startupMessage("Applying inline tags");
            var tags=fdjtDOM.$(".sbooktags");
            var i=0; var lim=tags.length;
            while (i<lim) {
                var tagelt=tags[i++];
                var target=Codex.getTarget(tagelt);
                var info=Codex.docinfo[target.id];
                var tagtext=fdjtDOM.textify(tagelt);
                var tagsep=tagelt.getAttribute("tagsep")||";";
                var tagstrings=tagtext.split(tagsep);
                if (tagstrings.length) {
                    if (info.tags)
                        info.tags=info.tags.concat(tagstrings);
                    else info.tags=tagstrings;}}
            var tags=fdjtDOM.$(".sbooktag");
            var i=0; var lim=tags.length;
            while (i<lim) {
                var tagelt=tags[i++];
                var target=Codex.getTarget(tagelt);
                var info=Codex.docinfo[target.id];
                var tagtext=fdjtDOM.textify(tagelt);
                if (info.tags)
                    info.tags=info.tags.concat(tagtext);
                else info.tags=[tagtext];}}
        
        function applyAnchorTags(kno) {
            var sbook_index=Codex.index; var docinfo=Codex.docinfo;
            var getTarget=Codex.getTarget;
            var getNodeID=fdjtDOM.getNodeID;
            var anchors=document.getElementsByTagName("A");
            if (!(anchors)) return;
            var i=0; var len=anchors.length;
            while (i<len) {
                if (anchors[i].rel==='tag') {
                    var elt=anchors[i++];
                    var cxt=elt;
                    while (cxt) if (cxt.id) break; else cxt=cxt.parentNode;
                    // Nowhere to store it?
                    if (!(cxt)) return;
                    var eltid=elt.id||getNodeID(elt);
                    var href=elt.href; var name=elt.name; var tag=false;
                    if (name) { // DTerm style
                        var def=elt.getAttribute('data-def')||
                            elt.getAttribute('data-def');
                        var title=elt.title;
                        if (def) {
                            if (def[0]==='|') tag=tag+def;
                            else tag=tag+"|"+def;}
                        else if (title) {
                            if (title[0]==='|') tag=name+title;
                            else if (title.indexOf('|')>0) {
                                tag=name+"|"+title;}
                            else tag=name+"|~"+title;}
                        else tag=name;}
                    else if (href) {
                        // Technorati style
                        var tagstart=(href.search(/[^\/]+$/));
                        tag=((tagstart<0)?(href):(href.slice(tagstart)));}
                    else {}
                    if (tag) {
                        var info=docinfo[cxt.id];
                        if (info.tags) info.tags.push(tag);
                        else info.tags=[tag];}}
                else i++;}}
        
        /* Indexing tags */
        
        function indexAssignedTags(docinfo,whendone){
            var ix=Codex.index; var knodule=Codex.knodule;
            /* One pass processes all of the inline KNodes and
               also separates out primary and auto tags. */
            var tagged=[]; var toindex=[];
            for (var eltid in docinfo) {
                var info=docinfo[eltid], tags=info.tags;
                if (tags) tagged.push(tags);
                if ((tags)||(info.sectags)||
                    ((info.head)&&(info.head.sectags)))
                    toindex.push(info);}
            if ((Codex.Trace.indexing)&&
                ((Codex.Trace.indexing>1)||
                 (tagged.length>7)))
                fdjtLog("Indexing inline tags for %d nodes (%d assigned)",
                        toindex.length,tagged.length);
            fdjtTime.slowmap(
                process_inline_tags,
                tagged,false,
                function(){
                    if ((Codex.Trace.indexing>1)&&(tagged.length))
                        fdjtLog("Finished processing inline tags for %d nodes",
                                tagged.length);
                    fdjtTime.slowmap(
                        index_inline_tags(ix,knodule),
                        toindex,false,
                        function(){
                            if ((Codex.Trace.indexing)&&
                                ((Codex.Trace.indexing>1)||
                                 (tagged.length>7)))
                                fdjtLog("Done inline indexing for %d nodes",
                                        toindex.length);
                            whendone();});});}
        Codex.indexAssignedTags=indexAssignedTags;
        
        function process_inline_tags(tags){
            var k=0; var ntags=tags.length;
            var scores=tags.scores||false;
            var knodes=tags.knodes||false;
            var knodule=Codex.knodule;
            if (!(scores)) tags.scores=scores={};
            if (!(knodes)) tags.knodes=knodes={};
            while (k<ntags) {
                var tag=tags[k]; var score=1; var tagbase=false;
                if (tag[0]==='*') {
                    var tagstart=tag.search(/[^*]+/);
                    score=2*(tagstart+1);
                    tagbase=tag.slice(tagstart);}
                else if (tag[0]==='~') {
                    var tagstart=tag.search(/[^~]+/);
                    tag=tag.slice(tagstart);
                    if (tagstart>1) {
                        if (!(scores)) tags.scores=scores={};
                        score=1/tagstart;}
                    else score=1;}
                else {
                    tagbase=tag;
                    score=2;}
                if (tagbase) {
                    var knode=((tagbase.indexOf('|')>0)?
                               (knodule.handleSubjectEntry(tagbase)):
                               (knodule.ref(tagbase)));
                    if ((knode)&&(knode.tagString))
                        tag=knode.tagString();
                    if (knode) knodes[tag]=knode;}
                tags[k]=tag;
                scores[tag]=score;
                k++;}
            if (scores) {
                tags.sort(function(t1,t2){
                    var s1=scores[t1]||1; var s2=scores[t2]||1;
                    if (s1>s2) return -1;
                    else if (s1<s2) return 1;
                    else if (t1<t2) return -1;
                    else if (t1>t2) return 1;
                    else return 0;});}
            else tags.sort();}

        function index_inline_tags(ix,knodule){
            return function (info){
                var eltid=info.frag;
                var tags=info.tags||[]; 
                if (tags) {
                    var scores=tags.scores;
                    var knodes=tags.knodes;
                    var k=0; var ntags=tags.length;
                    while (k<ntags) {
                        var tag=tags[k++], knode=knodes[tag];
                        if (knode) {
                            if (info.knodes) info.knodes.push(knode);
                            else info.knodes=[knode];}
                        if (scores)
                            ix.add(eltid,tag,scores[tag]||1,knodule);
                        else ix.add(eltid,tag,1,knodule);}}
                var sectags=info.sectags||((info.head)&&(info.head.sectags));
                if (sectags) {
                    var k=0, ntags=sectags.length;
                    while (k<ntags) {
                        var tag=sectags[k++];
                        ix.add(eltid,tag,0,knodule);}}};}
        
        /* Setting up the clouds */
        
        function initClouds(){
            startupMessage("setting up search cloud...");
            fdjtDOM.replace("CODEXSEARCHCLOUD",Codex.searchCloud().dom);
            startupMessage("setting up glossing cloud...");
            Codex.glossCloud();
            startupMessage("setting up outlet cloud...");
            Codex.outletCloud();
            if (Codex.gloss_cloud_queue) {
                if (Codex.Trace.clouds)
                    fdjtLog("Starting to sync gloss cloud");
                fdjtTime.slowmap(
                    Codex.addTag2GlossCloud,Codex.gloss_cloud_queue,false,
                    function(){
                        Codex.cloud_queue=false;
                        if (Codex.Trace.clouds)
                            fdjtLog("Gloss cloud synced");});}
            if (Codex.outlet_cloud_queue) {
                if (Codex.Trace.clouds)
                    fdjtLog("Starting to sync outlet cloud");
                fdjtTime.slowmap(
                    Codex.addOutlets2UI,Codex.outlet_cloud_queue,false,
                    function(){
                        Codex.cloud_queue=false;
                        if (Codex.Trace.clouds)
                            fdjtLog("Outlet cloud synced");});}
            if (Codex.knodule) {
                if (Codex.Trace.knodules)
                    fdjtLog("Beginning knodule integration");
                fdjtTime.slowmap(Codex.addTag2GlossCloud,
                                 Codex.knodule.alldterms,false,
                                 function(){
                                     if (Codex.Trace.knodules)
                                         fdjtLog("Knodule integrated");});}
            Codex.sizeCloud(Codex.search_cloud);
            Codex.sizeCloud(Codex.gloss_cloud);}
        
        /* Clearing offline data */

        function clearOffline(refuri,global){
            var dropLocal=fdjtState.dropLocal;
            if (refuri) {
                var glosses=getLocal("glosses("+refuri+")",true);
                var i=0; var lim=glosses.length;
                while (i<lim) fdjtState.dropLocal(glosses[i++]);
                var props=saveprops, i=0, lim=props.length;
                while (i<lim) dropLocal(props[i++]+"("+refuri+")");
                var refuris=getLocal("codex.refuris",true);
                refuris=fdjtKB.remove(refuris,refuri);
                setLocal("codex.refuris",refuris,true);}
            else {
                var refuris=getLocal("codex.refuris",true);
                var i=0; var lim=refuris.length;
                while (i<lim) clearOffline(refuris[i++]);
                dropLocal("codex.config");
                dropLocal("codex.user");
                dropLocal("codex.refuris");
                var local=fdjtState.listLocal();
                i=0; lim=local.length; while (i<lim) {
                    var key=local[i++];
                    if (key[0]==='@') dropLocal(key);}}}
        Codex.clearOffline=clearOffline;

        /* Other setup */
        
        function setupGlossServer(){}

        Codex.StartupHandler=function(evt){
            Startup();};

        return Startup;})();
sbookStartup=Codex.StartupHandler;
Codex.Setup=Codex.StartupHandler;
sbook={Start: Codex.Startup,
       setUser: Codex.setUser,
       Startup: Codex.Startup};

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/domscan.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

/* Scanning the document for Metadata */

Codex.DOMScan=(function(){
    var fdjtString=fdjt.String;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;

    function CodexDOMScan(root,docinfo){
        var fdjtID=fdjt.ID;
        var md5ID=fdjt.WSN.md5ID;
        var stdspace=fdjtString.stdspace;
        var flatten=fdjtString.flatten;
        var hasClass=fdjtDOM.hasClass;
        var hasPrefix=fdjtString.hasPrefix;
        var getChildren=fdjtDOM.getChildren;
        var textWidth=fdjtDOM.textWidth;
        var prefix=Codex.prefix;
        
        var start=false;

        if (typeof root === 'undefined') return this;
        if (!(docinfo))
            if (this instanceof CodexDOMScan)
                docinfo=this;
        else docinfo=new CodexDOMScan();
        if (!(root)) root=Codex.docroot||document.body;
        var start=new Date();
        var allheads=[], allids=[];
        docinfo._root=root;
        docinfo._heads=allheads;
        docinfo._ids=allids;
        if (!(root.id)) root.id="SBOOKROOT";
        if (Codex.Trace.startup) {
            if (root.id) 
                fdjtLog("Scanning %s#%s for structure and metadata",
                        root.tagName,root.id);
            else fdjtLog("Scanning DOM for structure and metadata: %o",root);}
        var nodefn=docinfo.nodeFn||false;
        var children=root.childNodes, level=false;
        var scanstate=
            {curlevel: 0,idserial:0,location: 0,
             nodecount: 0,eltcount: 0,headcount: 0,
             tagstack: [],taggings: [],allinfo: [],locinfo: [],
             idstate: {prefix: false,count: 0},
             idstack: [{prefix: false,count: 0}],
             pool: Codex.DocInfo};
        var rootinfo=(((nodefn)&&(nodeFn(root)))||(docinfo[root.id])||
                      (docinfo[root.id]=new scanInfo(root.id,scanstate)));
        scanstate.curhead=root; scanstate.curinfo=rootinfo;
        // Location is an indication of distance into the document
        var location=0;
        rootinfo.pool=scanstate.pool;
        rootinfo.title=root.title||document.title;
        rootinfo.starts_at=0;
        rootinfo.level=0; rootinfo.sub=new Array();
        rootinfo.head=false; rootinfo.heads=new Array();
        rootinfo.frag=root.id;
        rootinfo._id="#"+root.id;
        rootinfo.elt=root;
        scanstate.allinfo.push(rootinfo);
        scanstate.allinfo.push(0);
        /* Build the metadata */
        var i=0; while (i<children.length) {
            var child=children[i++];
            if (!((child.sbookskip)||(child.codexui)))
                scanner(child,scanstate,docinfo,docinfo.nodeFn||false);} 
        docinfo._nodecount=scanstate.nodecount;
        docinfo._headcount=scanstate.headcount;
        docinfo._eltcount=scanstate.eltcount;
        docinfo._maxloc=scanstate.location;
        docinfo._allinfo=scanstate.allinfo;
        docinfo._locinfo=scanstate.locinfo;
        var scaninfo=scanstate.curinfo;
        /* Close off all of the open spans in the TOC */
        while (scaninfo) {
            scaninfo.ends_at=scanstate.location;
            scaninfo=scaninfo.head;}
        var done=new Date();
        if (Codex.Trace.startup)
            fdjtLog('Gathered metadata in %f secs over %d/%d heads/nodes',
                    (done.getTime()-start.getTime())/1000,
                    scanstate.headcount,scanstate.eltcount);
        return docinfo;

        function scanInfo(id,scanstate) {
            if (docinfo[id]) return docinfo[id];
            this.pool=scanstate.pool;
            this.frag=id;
            // this._id="#"+id;
            this._id=id;
            docinfo[id]=this;
            scanstate.allinfo.push(this);
            scanstate.locinfo.push(scanstate.location);
            return this;}
        CodexDOMScan.scanInfo=scanInfo;

        function getTitle(head) {
            var title=
                (head.toctitle)||
                ((head.getAttributeNS)&&
                 (head.getAttributeNS('toctitle','http://sbooks.net')))||
                (head.getAttribute('toctitle'))||
                (head.getAttribute('data-toctitle'))||
                (head.title);
            if (!(title)) {
                var head1=fdjtDOM.getFirstChild(head,"H1,H2,H3,H4,H5,H6");
                if (head1) title=head1.toctitle||
                    ((head1.getAttributeNS)&&
                     (head1.getAttributeNS('toctitle','http://sbooks.net')))||
                    (head1.getAttribute('toctitle'))||
                    (head1.getAttribute('data-toctitle'))||
                    (head1.title);
                if ((!(title))&&(head1)) title=gatherText(head1);
                else title=gatherText(head);}
            if (typeof title === "string") {
                var std=stdspace(title);
                if (std==="") return false;
                else return std;}
            else return fdjtDOM.textify(title,true);}

        function gatherText(head,s) {
            if (!(s)) s="";
            if (head.nodeType===3)
                return s+head.nodeValue;
            else if (head.nodeType!==1) return s;
            else {
                var children=head.childNodes;
                var i=0; var len=children.length;
                while (i<len) {
                    var child=children[i++];
                    if (child.nodeType===3) s=s+child.nodeValue;
                    else if (child.nodeType===1)
                        s=gatherText(child,s);
                    else {}}
                return s;}}

        function textWidth(elt){
            if (elt.nodeType===3) return elt.nodeValue.length;
            else if (elt.nodeType!==1) return 0;
            else if (elt.getAttribute("data-loclen"))
                return parseInt(elt.getAttribute("data-loclen"));
            else {
                var children=elt.childNodes; var width=0;
                var i=0; var len=children.length;
                while (i<len) {
                    var child=children[i++];
                    if (child.nodeType===3)
                        width=width+child.nodeValue.length;
                    else if (child.nodeType===1)
                        width=width+textWidth(child);
                    else {}}
                return width;}}

        function getLevel(elt){
            if (elt.toclevel) {
                if (elt.toclevel==='none')
                    return elt.toclevel=false;
                else return elt.toclevel;}
            var attrval=
                ((elt.getAttributeNS)&&
                 (elt.getAttributeNS('toclevel','http://sbooks.net')))||
                (elt.getAttribute('toclevel'))||
                (elt.getAttribute('data-toclevel'));
            if (attrval) {
                if (attrval==='none') return false;
                else return parseInt(attrval);}
            if (elt.className) {
                var cname=elt.className;
                if (cname.search(/\bsbooknotoc\b/)>=0) return 0;
                if (cname.search(/\bsbookignore\b/)>=0) return 0;
                var tocloc=cname.search(/\bsbook\dhead\b/);
                if (tocloc>=0) return parseInt(cname.slice(5,6));}
            if ((Codex.notoc)&&(Codex.notoc.match(elt))) return 0;
            if ((Codex.ignore)&&(Codex.ignore.match(elt))) return 0;
            if ((elt.tagName==='HGROUP')||(elt.tagName==='HEADER'))
                return getFirstTocLevel(elt,true);
            if (elt.tagName.search(/H\d/)==0)
                return parseInt(elt.tagName.slice(1,2));
            else return false;}

        function getFirstTocLevel(node,notself){
            if (node.nodeType!==1) return false;
            var level=((!(notself))&&(getLevel(node)));
            if (level) return level;
            var children=node.childNodes;
            var i=0; var lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (child.nodeType!==1) continue;
                level=getFirstTocLevel(child);
                if (level) return level;}
            return false;}

        function handleHead(head,docinfo,scanstate,level,
                            curhead,curinfo,curlevel,nodefn){
            var headid=head.id;
            var headinfo=((nodefn)&&(nodefn(head)))||docinfo[headid]||
                (docinfo[headid]=new scanInfo(headid,scanstate));
            scanstate.headcount++;
            allheads.push(head);
            if ((headinfo.elt)&&(headinfo.elt!==head)) {
                var newid=headid+"x"+scanstate.location;
                fdjtLog.warn("Duplicate ID=%o newid=%o",headid,newid);
                head.id=headid=newid;
                headinfo=((nodefn)&&(nodefn(head)))||docinfo[headid]||
                    (docinfo[headid]=new scanInfo(headid,scanstate));}
            if (Codex.Trace.scan)
                fdjtLog("Scanning head item %o under %o at level %d w/id=#%s ",
                        head,curhead,level,headid);
            /* Iniitalize the headinfo */
            headinfo.starts_at=scanstate.location;
            headinfo.elt=head; headinfo.level=level;
            headinfo.sub=new Array();
            headinfo.frag=headid; headinfo._id="#"+headid;
            headinfo.title=getTitle(head);
            headinfo.next=false; headinfo.prev=false;
            if (headinfo.title)
                headinfo.sectag="\u00a7"+stdspace(headinfo.title);
            else headinfo.sectag="\u00a7Anonymous Section";
            if (level>curlevel) {
                /* This is the simple case where we are a subhead
                   of the current head. */
                headinfo.head=curinfo;
                if (!(curinfo.intro_ends_at))
                    curinfo.intro_ends_at=scanstate.location;
                curinfo.sub.push(headinfo);
                /* There is one special case here, were there is a
                   previous head/section (created by a whole block
                   wrapped in a section/article/etc block. */
                if (scanstate.lastlevel===level) {
                    headinfo.prev=scanstate.lastinfo;
                    scanstate.lastinfo.next=headinfo;
                    delete scanstate.lastlevel;
                    delete scanstate.lasthead;
                    delete scanstate.lastinfo;}}
            else { /* We're not a subhead, so
                      we're popping up at least one level. */
                var scan=curhead;
                var scaninfo=curinfo;
                var scanlevel=curinfo.level;
                /* Climb the stack of headers, closing off entries and setting up
                   prev/next pointers where needed. */
                while (scaninfo) {
                    if (Codex.Trace.scan)
                        fdjtLog("Finding head: scan=%o, info=%o, sbook_head=%o, cmp=%o",
                                scan,scaninfo,scanlevel,scaninfo.head,
                                (scanlevel<level));
                    if (scanlevel<level) break;
                    if (level===scanlevel) {
                        headinfo.prev=scaninfo;
                        scaninfo.next=headinfo;}
                    scaninfo.ends_at=scanstate.location;
                    scanstate.tagstack=scanstate.tagstack.slice(0,-1);
                    scaninfo=scaninfo.head; scan=scaninfo.elt;
                    scanlevel=((scaninfo)?(scaninfo.level):(0));}
                if (Codex.Trace.scan)
                    fdjtLog("Found parent: up=%o, upinfo=%o, atlevel=%d, sbook_head=%o",
                            scan,scaninfo,scaninfo.level,scaninfo.head);
                /* We've found the enclosing head for this head, so we
                   establish the links. */
                headinfo.head=scaninfo;
                scaninfo.sub.push(headinfo);}
            /* If we have a head, we get its tags. */
            var supinfo=headinfo.head;
            if ((supinfo)&&(supinfo.sectags))
                headinfo.sectags=supinfo.sectags.concat([headinfo.sectag]);
            else headinfo.sectags=[headinfo.sectag];
            
            /* We create an array of all the heads, which lets us
               replace many recursions with iterations. */
            var newheads=new Array();
            if (supinfo.heads) newheads=newheads.concat(supinfo.heads);
            if (supinfo) newheads.push(supinfo);
            headinfo.heads=newheads;
            if (Codex.Trace.scan)
                fdjtLog("@%d: Found head=%o, headinfo=%o, sbook_head=%o",
                        scanstate.location,head,headinfo,headinfo.head);
            /* Update the toc state */
            scanstate.curhead=head;
            scanstate.curinfo=headinfo;
            scanstate.curlevel=level;
            if (headinfo)
                headinfo.ends_at=scanstate.location+textWidth(head);
            scanstate.location=scanstate.location+textWidth(head);}

        function scanner(child,scanstate,docinfo,nodefn){
            var location=scanstate.location;
            var curhead=scanstate.curhead;
            var curinfo=scanstate.curinfo;
            var curlevel=scanstate.curlevel;
            scanstate.nodecount++;
            // Location tracking and TOC building
            if (child.nodeType===3) {
                var content=stdspace(child.nodeValue);
                var width=content.length;
                // Need to regularize whitespace
                scanstate.location=scanstate.location+width;
                return 0;}
            else if (child.nodeType!==1) return 0;
            else {}
            var tag=child.tagName, classname=child.className, id=child.id;
            if ((Codex.ignore)&&(Codex.ignore.match(child))) return;
            if ((classname)&&(classname.search(/\bsbookignore\b/)>=0))
                return;
            if ((child.codexui)||((id)&&(id.search("CODEX")===0))) return;
            else if ((!(id))&&(!(Codex.baseid))&&
                     (tag.search(/p|h\d|blockquote|li/i)===0)) {
                var baseid="WSN_"+md5ID(child), id=baseid, count=1;
                while (document.getElementById[id])
                    id=baseid+"_"+(count++);
                child.id=id;}
            else {}
            // Get the location in the TOC for this out of context node
            //  These get generated, for example, when the content of an
            //  authorial footnote is moved elsewhere in the document.
            var tocloc=(child.codextocloc)||(child.getAttribute("data-tocloc"));
            if ((tocloc)&&(docinfo[tocloc])) {
                var tocinfo=docinfo[tocloc];
                var curlevel=scanstate.curlevel;
                var curhead=scanstate.curhead;
                var curinfo=scanstate.curinfo;
                var notoc=scanstate.notoc;
                var headinfo=tocinfo.head;
                scanstate.curinfo=headinfo;
                scanstate.curhead=headinfo.elt;
                scanstate.curlevel=headinfo.level;
                scanstate.notoc=true;
                var children=child.childNodes;
                var i=0; var lim=children.length;
                while (i<lim) {
                    var child=children[i++];
                    if (child.nodeType===1)
                        scanner(child,scanstate,docinfo,nodefn);}
                // Put everything back
                scanstate.curlevel=curlevel; scanstate.notoc=notoc;
                scanstate.curhead=curhead; scanstate.curinfo=curinfo;
                return;}
            var toclevel=((child.id)&&(getLevel(child)));
            // The header functionality (for its contents too) is handled by the
            // section
            if ((scanstate.notoc)||(tag==='header')) {
                scanstate.notoc=true; toclevel=0;}
            scanstate.eltcount++;
            var info=((nodefn)&&(nodefn(child)))||(id&&(docinfo[id]));
            if ((!(info))&&(id)) {
                allids.push(id); info=new scanInfo(id,scanstate);
                docinfo[id]=info;}
            if ((info)&&(info.elt)&&(id)&&(info.elt!==child)) {
                var newid=child.id+"x"+scanstate.location;
                fdjtLog.warn("Duplicate ID=%o newid=%o",child.id,newid);
                child.id=id=newid;
                info=((nodefn)&&(nodefn(head)))||docinfo[id]||
                    (docinfo[id]=new scanInfo(id,scanstate));}
            if (info) {
                info.starts_at=scanstate.location;
                info.sbookhead=curhead.id;
                info.headstart=curinfo.starts_at;}
            if (info) info.head=curinfo;
            // Set the first content node
            if ((id)&&(info)&&(!start)) Codex.start=start=child;
            // And the initial content level
            if ((info)&&(toclevel)&&(!(info.toclevel))) info.toclevel=toclevel;
            if ((id)&&(info)) {
                var tags=
                    ((child.getAttributeNS)&&
                     (child.getAttributeNS('tags','http://sbooks.net/')))||
                    (child.getAttribute('tags'))||
                    (child.getAttribute('data-tags'));
                if (tags) info.tags=tags.split(';');}
            if (((classname)&&(classname.search(/\bsbookignore\b/)>=0))||
                ((Codex.ignore)&&(Codex.ignore.match(child))))
                return;
            if ((toclevel)&&(!(info.tocdone)))
                handleHead(child,docinfo,scanstate,toclevel,
                           curhead,curinfo,curlevel,nodefn);
            if (((classname)&&(classname.search(/\bsbookterminal\b/)>=0))||
                ((classname)&&(Codex.terminals)&&
                 (Codex.terminals.match(child)))||
                (tag.search(/p|h\d|pre/i)===0)) {
                scanstate.location=scanstate.location+textWidth(child);}
            else {
                var children=child.childNodes;
                var i=0; var len=children.length;
                while (i<len) {
                    var grandchild=children[i++];
                    if (grandchild.nodeType===3) {
                        var content=stdspace(grandchild.nodeValue);
                        scanstate.location=scanstate.location+
                            content.length;}
                    else if (grandchild.nodeType===1) {
                        scanner(grandchild,scanstate,docinfo,nodefn);}}}
            if (info) info.ends_at=scanstate.location;
            if ((info)&&((info.ends_at-info.starts_at)<5000)) 
                info.wsnid=md5ID(child);
            if ((toclevel)&&
                ((child.tagName==='SECTION')||(child.tagName==='ARTICLE'))) {
                scanstate.lasthead=child; scanstate.lastinfo=info;
                scanstate.lastlevel=toclevel;
                scanstate.curhead=curhead; scanstate.curinfo=curinfo;
                scanstate.curlevel=curlevel;}
            else if (toclevel) {
                scanstate.lasthead=child; scanstate.lastinfo=info;
                scanstate.lastlevel=toclevel;}}}
    return CodexDOMScan;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/hud.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

Codex.setMode=
    (function(){
        var fdjtString=fdjt.String;
        var fdjtState=fdjt.State;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        var fdjtKB=fdjt.KB;
        var fdjtID=fdjt.ID;
        
        // Helpful dimensions
        var head_height=false, foot_height=false;
        var help_top=false, help_bottom=false;
        // The BOX HUD (contains scrollable content) and its margins
        var box_top=false; var box_bottom=false;
        // This is the HUD where all glosses are displayed
        var sbookGlossesHUD=false;
        // This is the HUD for tag searching
        var sbookSearchHUD=false;
        // How long to let messages flash up
        var message_timeout=5000;
        // Whether to call displaySync on mode changes
        var display_sync=false;
        
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var hasClass=fdjtDOM.hasClass;
        var getParent=fdjtDOM.getParent;
        var getGeometry=fdjtDOM.getGeometry;
        var getChild=fdjtDOM.getChild;
        var hasSuffix=fdjtString.hasSuffix;
        var Ref=fdjtKB.Ref;

        var CodexHUD=false;

        // This will contain the interactive input console (for debugging)
        var input_console;
        var input_button;

        function initHUD(){
            if (fdjtID("CODEXHUD")) return;
            var messages=fdjtDOM("div.startupmessages");
            messages.innerHTML=fixStaticRefs(Codex.HTML.messages);
            var hud=Codex.HUD=CodexHUD=fdjtDOM("div#CODEXHUD");
            hud.codexui=true;
            hud.innerHTML=fixStaticRefs(Codex.HTML.hud);
            fdjtDOM.prepend(document.body,
                            messages,
                            fdjtDOM("div.fdjtprogress#CODEXLAYOUTMESSAGE",
                                    fdjtDOM("div.indicator"),
                                    fdjtDOM("div.message")),
                            fdjtID("HUMANE"),
                            hud);
            // Fill in the HUD help
            var hudhelp=fdjtID("CODEXHUDHELP");
            hudhelp.innerHTML=fixStaticRefs(Codex.HTML.hudhelp);
            // Set up the start page and the reader help
            var startpage=Codex.HUD.startpage=fdjtID("CODEXSTARTPAGE");
            // Set up the help page
            var help=Codex.DOM.help=fdjtID("CODEXHELP");
            help.innerHTML=fixStaticRefs(Codex.HTML.help);
            // Set up the app splash/status page
            var splash=Codex.DOM.appsplash=fdjtID("CODEXAPPSPLASH");
            splash.innerHTML=fixStaticRefs(Codex.HTML.splash);
            // Setup heart
            var heart=fdjtID("CODEXHEART");
            heart.innerHTML=fixStaticRefs(Codex.HTML.hudheart);
            Codex.DOM.heart=heart;
            // Setup settings
            var settings=fdjtID("CODEXSETTINGS");
            settings.innerHTML=fixStaticRefs(Codex.HTML.settings);
            Codex.DOM.settings=settings;
            // Other HUD parts
            Codex.DOM.head=fdjtID("CODEXHEAD");
            Codex.DOM.heart=fdjtID("CODEXHEART");
            Codex.DOM.foot=fdjtID("CODEXFOOT");
            Codex.DOM.tabs=fdjtID("CODEXTABS");
            // Initialize search UI
            var search=fdjtID("CODEXSEARCH");
            search.innerHTML=fixStaticRefs(Codex.HTML.searchbox);
            Codex.empty_cloud=
                new fdjtUI.Completions(fdjtID("CODEXSEARCHCLOUD"));
            // Setup addgloss prototype
            var addgloss=fdjtID("CODEXADDGLOSSPROTOTYPE");
            addgloss.innerHTML=fixStaticRefs(Codex.HTML.addgloss);

            Codex.DOM.sbooksapp=fdjtID("SBOOKSAPP");
            Codex.DOM.allglosses=fdjtID("CODEXALLGLOSSES");
            
            if (!(Codex.svg)) {
                var images=fdjtDOM.getChildren(hud,"img");
                var i=0; var lim=images.length;
                while (i<lim) {
                    var img=images[i++];
                    if ((img.src)&&
                        ((hasSuffix(img.src,".svg"))||
                         (hasSuffix(img.src,".svgz")))&&
                        (img.getAttribute('bmp')))
                        img.src=img.getAttribute('bmp');}}

            Codex.hudtick=fdjtTime();

            fdjtID("SBOOK_RETURN_TO").value=location.href;

            // Initialize gloss UI
            var glosses=fdjtID("CODEXALLGLOSSES");
            Codex.UI.setupSummaryDiv(glosses);
            Codex.glosses.addEffect("maker",function(f,p,v){
                Codex.sourcekb.ref(v).oninit
                (Codex.UI.addGlossSource,"newsource");});
            Codex.glosses.addEffect("sources",function(f,p,v){
                Codex.sourcekb.ref(v).oninit
                (Codex.UI.addGlossSource,"newsource");});

            function addGloss2UI(item){
                if (document.getElementById(item.frag)) {
                    var addGlossmark=Codex.UI.addGlossmark;
                    Codex.UI.addToSlice(item,glosses,false);
                    var nodes=Codex.getDups(item.frag);
                    addClass(nodes,"glossed");
                    var i=0, lim=nodes.length; while (i<lim) {
                        addGlossmark(nodes[i++],item);}
                    if (item.tstamp>Codex.syncstamp)
                        Codex.syncstamp=item.tstamp;}}
            Codex.glosses.addInit(addGloss2UI);

            var tagHTML=Knodule.HTML;

            function addTag2GlossCloud(tag){
                if (!(tag)) return;
                else if (tag instanceof Array) {
                    var i=0; var lim=tag.length;
                    while (i<lim) addTag2GlossCloud(tag[i++]);
                    return;}
                else if (!(Codex.gloss_cloud)) {
                    // If the HUD hasn't been initialized, add the tag
                    //  to queues for addition.
                    var queue=Codex.gloss_cloud_queue;
                    if (!(queue)) queue=Codex.gloss_cloud_queue=[];
                    queue.push(tag);}
                else if ((tag instanceof Ref)&&(!(tag._init)))
                    // If it's uninitialized, delay adding it
                    tag.oninit(addTag2GlossCloud,"addTag2GlossCloud");
                // Skip weak tags
                else if ((tag instanceof Ref)&&(tag.weak)) return;
                else {
                    var gloss_cloud=Codex.glossCloud();
                    var search_cloud=Codex.searchCloud();
                    var ref=((tag instanceof Ref)?(tag):
                             ((fdjtKB.probe(tag,Codex.knodule))||
                              (fdjtKB.ref(tag,Codex.knodule))));
                    var ref_tag=(((ref)&&(ref.tagString))&&
                                 (ref.tagString(Codex.knodule)))||
                        ((ref)&&((ref._id)||(ref.uuid)||(ref.oid)))||
                        (tag);
                    var gloss_tag=gloss_cloud.getByValue(ref_tag,".completion");
                    if (!((gloss_tag)&&(gloss_tag.length))) {
                        gloss_tag=tagHTML(tag,Codex.knodule,false,true);
                        if ((ref)&&(ref.pool===Codex.sourcekb))
                            fdjtDOM(fdjtID("CODEXGLOSSCLOUDSOURCES"),
                                    gloss_tag," ");
                        else fdjtDOM(fdjtID("CODEXGLOSSCLOUDTAGS"),
                                     gloss_tag," ");
                        gloss_cloud.addCompletion(gloss_tag);}}}
            Codex.addTag2GlossCloud=addTag2GlossCloud;
            
            function addOutlets2UI(outlets){
                if (typeof outlets === 'string')
                    outlets=Codex.sourcekb.ref(outlets);
                if (!(outlets)) return;
                if (!(outlets instanceof Array)) outlets=[outlets];
                if (!(Codex.outlet_cloud)) {
                    // If the HUD hasn't been initialized, add the tag
                    //  to queues for addition.
                    var queue=Codex.outlet_cloud_queue;
                    if (!(queue)) queue=Codex.outlet_cloud_queue=[];
                    queue=Codex.outlet_cloud_queue=queue.concat(outlets);
                    return;}
                else {
                    var i=0; var lim=outlets.length;
                    var loaded=[];
                    while (i<lim) {
                        var outlet=outlets[i++];
                        if (typeof outlet === 'string')
                            outlet=fdjtKB.ref(outlet);
                        if ((outlet instanceof Ref)&&(!(outlet._init)))
                            outlet.oninit(addOutlets2UI,"addOutlets2UI");
                        else loaded.push(outlet);}
                    var cloud=Codex.outletCloud()
                    var form=fdjtID("CODEXADDGLOSSPROTOTYPE");
                    i=0; lim=loaded.length; while (i<lim) {
                        var outlet=loaded[i++];
                        if (i<=5)
                            Codex.addOutlet2Form(form,outlet,false);
                        addOutlet2Cloud(outlet,cloud);}
                    return;}}
            Codex.addOutlets2UI=addOutlets2UI;
            
            /* Initializing outlets */
            
            function addOutlet2Cloud(outlet,cloud) {
                if (typeof outlet === 'string')
                    outlet=fdjtKB.load(outlet);
                var humid=outlet.humid;
                var sourcetag=fdjtID("cxOUTLET"+humid);
                if (!(sourcetag)) { // Add entry to the share cloud
                    var completion=fdjtDOM(
                        "span.completion.source",outlet.name);
                    completion.id="cxOUTLET"+humid;
                    completion.setAttribute("value",outlet._id);
                    completion.setAttribute("key",outlet.name);
                    if ((outlet.description)&&(outlet.nick))
                        completion.title=outlet.name+": "+
                        outlet.description;
                    else if (outlet.description)
                        completion.title=outlet.description;
                    else if (outlet.nick) completion.title=outlet.name;
                    fdjtDOM(cloud.dom,completion," ");
                    if (cloud) cloud.addCompletion(completion);}}
            
            var cloudEntry=Codex.cloudEntry;

            function addTag2SearchCloud(tag){
                if (!(tag)) return;
                else if (tag instanceof Array) {
                    var i=0; var lim=tag.length;
                    while (i<lim) addTag2SearchCloud(tag[i++]);
                    return;}
                else if (!(Codex.search_cloud)) {
                    // If the HUD hasn't been initialized, add the tag
                    //  to queues for addition.
                    var queue=Codex.search_cloud_queue;
                    if (!(queue)) queue=Codex.search_cloud_queue=[];
                    queue.push(tag);}
                else if ((tag instanceof Ref)&&(!(tag._init)))
                    // If it's uninitialized, delay adding it
                    tag.oninit(addTag2SearchCloud,"addTag2SearchCloud");
                else {
                    var search_cloud=Codex.searchCloud();
                    var div=search_cloud.dom;
                    var tagstring=((tag.tagString)?(tag.tagString()):(tag));
                    var search_tag=
                        search_cloud.getByValue(tagstring,".completion");
                    var container=div;
                    var ref=((typeof tag === 'string')?
                             (fdjtKB.ref(tag,Codex.knodule)):
                             (tag));
                    if (!(ref)) {
                        if (tag[0]==="\u00a7")
                            container=getChild(div,".sections")||container;
                        else container=getChild(div,".words")||div;}
                    else if (ref.weak)
                        container=getChild(div,".weak");
                    else if (ref.prime)
                        container=getChild(div,".prime");
                    else if (ref.pool===Codex.sourcekb)
                        container=getChild(div,".sources");
                    else {}
                    if (!(container)) container=div;
                    if (!((search_tag)&&(search_tag.length))) {
                        search_tag=cloudEntry(tag,Codex.knodule,false,true);
                        fdjtDOM(container,search_tag," ");
                        search_cloud.addCompletion(search_tag,false,tag);}}}
            Codex.addTag2SearchCloud=addTag2SearchCloud;
            
            var console=fdjtID("CODEXCONSOLE");
            input_console=fdjtDOM.getChild(console,"TEXTAREA");
            input_button=fdjtDOM.getChild(console,"span.button");
            input_button.onclick=consolebutton_click;
            input_console.onkeypress=consoleinput_keypress;

            var appframe=fdjtID("SBOOKSAPP");
            var appwindow=((appframe)&&(appframe.contentWindow));
            if (appwindow.postMessage) {
                if (Codex.Trace.messages)
                    fdjtLog("Setting up message listener");
                fdjtDOM.addListener(window,"message",function(evt){
                    var origin=evt.origin;
                    if (Codex.Trace.messages)
                        fdjtLog("Got a message from %s with payload %s",
                                origin,evt.data);
                    if (origin.search(/https:\/\/[^\/]+.sbooks.net/)!==0) {
                        fdjtLog.warn("Rejecting insecure message from %s",
                                     origin);
                        return;}
                    if (evt.data==="sbooksapp") {
                        CodexMode("sbooksapp");}
                    else if (evt.data==="loggedin") {
                        if (!(Codex.user)) Codex.userSetup();}
                    else if (evt.data)
                        fdjtDOM("CODEXINTRO",evt.data);
                    else {}});}


            // Set up the splash form
            var splashform=fdjtID("CODEXSPLASHFORM");
            var docinput=fdjtDOM.getInput(splashform,"DOCURI");
            if (docinput) docinput.value=Codex.docuri;
            var refinput=fdjtDOM.getInput(splashform,"REFURI");
            if (refinput) refinput.value=Codex.refuri;
            var topinput=fdjtDOM.getInput(splashform,"TOPURI");
            if (topinput) topinput.value=document.location.href;
            if ((Codex.user)&&(Codex.user.email)) {
                var nameinput=fdjtDOM.getInput(splashform,"USERNAME");
                if (nameinput) nameinput.value=Codex.user.email;}
            var query=document.location.search||"?";
            var appuri="https://"+Codex.server+"/flyleaf"+query;
            var refuri=Codex.refuri;
            if (query.search("REFURI=")<0)
                appuri=appuri+"&REFURI="+encodeURIComponent(refuri);
            if (query.search("TOPURI=")<0)
                appuri=appuri+"&TOPURI="+
                encodeURIComponent(document.location.href);
            if (document.title) {
                appuri=appuri+"&DOCTITLE="+encodeURIComponent(document.title);}
            fdjtID("CODEXSPLASH_RETURN_TO").value=appuri;
                    
            fdjtUI.TapHold(Codex.DOM.foot,Codex.touch);

            fillinTabs();
            resizeHUD();

            Codex.scrollers={};
            updateScroller("CODEXGLOSSTAGS");
            updateScroller("CODEXSEARCHCLOUD");
            fdjtDOM.setupCustomInputs(fdjtID("CODEXHUD"));}
        Codex.initHUD=initHUD;
        
        function fixStaticRefs(string){
            if (Codex.root==="http://static.beingmeta.com/g/codex/")
                return string;
            else return string.replace(
                    /http:\/\/static.beingmeta.com\/g\/codex\//g,
                Codex.root);}

        function resizeHUD(){}
        Codex.resizeHUD=resizeHUD;

        /* This is used for viewport-based browser, where the HUD moves
           to be aligned with the viewport */
        
        var sbook_sync_off=false;
        var sbook_sync_height=false;
        
        function getBounds(elt){
            var style=fdjtDOM.getStyle(elt);
            return { top: fdjtDOM.parsePX(style.marginTop)||0+
                     fdjtDOM.parsePX(style.borderTop)||0+
                     fdjtDOM.parsePX(style.paddingTop)||0,
                     bottom: fdjtDOM.parsePX(style.marginBottom)||0+
                     fdjtDOM.parsePX(style.borderBottom)||0+
                     fdjtDOM.parsePX(style.paddingBottom)||0};}
        fdjtDOM.getBounds=getBounds;
        
        /* Creating the HUD */
        
        function setupTOC(root_info){
            var navhud=createNavHUD("div#CODEXTOC.hudpanel",root_info);
            var toc_button=fdjtID("CODEXTOCBUTTON");
            toc_button.style.visibility='';
            Codex.DOM.toc=navhud;
            fdjtDOM.replace("CODEXTOC",navhud);
            var flytoc=createStaticTOC("div#CODEXFLYTOC.hudpanel",root_info);
            Codex.Flytoc=flytoc;
            fdjtDOM.replace("CODEXFLYTOC",flytoc);}
        Codex.setupTOC=setupTOC;

        function createNavHUD(eltspec,root_info){
            var scan=root_info;
            while (scan) {
                if ((!(scan.sub))||(scan.sub.length===0)) break;
                else if (scan.sub.length>1) {
                    root_info=scan; break;}
                else scan=scan.sub[0];}
            var toc_div=Codex.TOC(root_info,0,false,"CODEXTOC4",true);
            var div=fdjtDOM(eltspec||"div#CODEXTOC.hudpanel",toc_div);
            Codex.UI.addHandlers(div,"toc");
            return div;}

        function createStaticTOC(eltspec,root_info){
            var toc_div=Codex.TOC(root_info,0,false,"CODEXFLYTOC4");
            var div=fdjtDOM(eltspec||"div#CODEXFLYTOC",toc_div);
            Codex.UI.addHandlers(div,"toc");
            return div;}

        /* HUD animation */

        function setHUD(flag,clearmode){
            if (typeof clearmode === 'undefined') clearmode=true;
            // clearmode=((Codex.mode!=='scanning')&&(Codex.mode!=='tocscan'));
            if ((Codex.Trace.gestures)||(Codex.Trace.mode))
                fdjtLog("setHUD %o mode=%o hudup=%o bc=%o hc=%o",
                        flag,Codex.mode,Codex.hudup,
                        document.body.className,
                        CodexHUD.className);
            if (flag) {
                Codex.hudup=true;
                addClass(document.body,"hudup");}
            else {
                Codex.hudup=false;
                Codex.scrolling=false;
                if (Codex.previewing) Codex.stopPreview();
                dropClass(document.body,"cxSHRINK");
                if (clearmode) {
                    var wait=false;
                    dropClass(CodexHUD,"openheart");
                    dropClass(CodexHUD,"openhead");
                    dropClass(CodexHUD,"full");
                    dropClass(CodexHUD,CodexMode_pat);
                    Codex.mode=false;}
                dropClass(document.body,"hudup");
                document.body.focus();}}
        Codex.setHUD=setHUD;

        /* Mode controls */
        
        var CodexMode_pat=/\b((splash)|(device)|(sbooksapp)|(scanning)|(tocscan)|(search)|(searchresults)|(toc)|(glosses)|(allglosses)|(context)|(flytoc)|(about)|(console)|(minimal)|(addgloss)|(editexcerpt)|(gotoloc)|(gotopage))\b/g;
        var codexHeartMode_pat=/\b((device)|(sbooksapp)|(flytoc)|(about)|(console)|(search)|(searchresults)|(allglosses)|(login))\b/g;
        var codexHeadMode_pat=/\b((toc)|(search)|(searchresults)|(glosses)|(allglosses)|(addgloss)|(gotopage)|(gotoloc)|(tocscan))\b/g;
        var codex_mode_scrollers=
            {allglosses: "CODEXALLGLOSSES",
             searchresults: "CODEXSEARCHRESULTS",
             search: "CODEXSEARCHCLOUD",
             console: "CODEXCONSOLE",
             // sbooksapp: "SBOOKSAPP",
             device: "CODEXSETTINGS",
             flytoc: "CODEXFLYTOC",
             about: "CODEXABOUTBOOK"};
        var codex_mode_foci=
            {gotopage: "CODEXPAGEINPUT",
             gotoloc: "CODEXLOCINPUT",
             search: "CODEXSEARCHINPUT"};
        var hide_startup_help=true;
        
        function CodexMode(mode){
            var oldmode=Codex.mode;
            if (typeof mode === 'undefined') return oldmode;
            if (mode==='last') mode=Codex.last_mode;
            if (mode==='none') mode=false;
            if (mode==='heart') mode=Codex.heart_mode||"about";
            if (Codex.Trace.mode)
                fdjtLog("CodexMode %o, cur=%o dbc=%o",
                        mode,Codex.mode,document.body.className);
            if ((mode!==Codex.mode)&&(Codex.previewing))
                Codex.stopPreview();
            if (mode) {
                if (mode==="addgloss") {}
                else dropClass(document.body,"cxSHRINK");
                if (mode===Codex.mode) {}
                else if (mode===true) {
                    /* True just puts up the HUD with no mode info */
                    if (codex_mode_foci[Codex.mode]) {
                        var input=fdjtID(codex_mode_foci[Codex.mode]);
                        input.blur();}
                    Codex.mode=false;
                    Codex.last_mode=true;}
                else if (typeof mode !== 'string') 
                    throw new Error('mode arg not a string');
                else {
                    if (codex_mode_foci[Codex.mode]) {
                        var input=fdjtID(codex_mode_foci[Codex.mode]);
                        input.blur();}
                    Codex.mode=mode;}
                // If we're switching to the inner app but the iframe
                //  hasn't been initialized, we do it now.
                if ((mode==="sbooksapp")&&
                    (!(fdjtID("SBOOKSAPP").src))&&
                    (!(Codex.appinit)))
                    initFlyleafApp();
                // Update Codex.scrolling which is the scrolling
                // element in the HUD for this mode
                if (!(typeof mode === 'string'))
                    Codex.scrolling=false;
                else if (codex_mode_scrollers[mode]) 
                    Codex.scrolling=(codex_mode_scrollers[mode]);
                else Codex.scrolling=false;

                // Scanning is a funny mode in that the HUD is down
                //  for it.  We handle all of this stuff here.
                if ((mode==='scanning')||
                    (mode==='tocscan')||
                    (mode==='status')) {
                    if (mode!==oldmode) {
                        Codex.hudup=false;
                        dropClass(CodexHUD,"openheart");
                        dropClass(CodexHUD,"full");
                        dropClass(document.body,"hudup");}}
                else if (mode==='addgloss') {}
                // And if we're not scanning, we just raise the hud
                else setHUD(true);
                // Actually change the class on the HUD object
                if (mode===true) {
                    fdjtDOM.swapClass(CodexHUD,CodexMode_pat,"minimal");
                    dropClass(CodexHUD,"openhead");
                    dropClass(CodexHUD,"openheart");}
                else {
                    if (mode.search(codexHeartMode_pat)<0) {
                        dropClass(CodexHUD,"openheart");}
                    if (mode.search(codexHeadMode_pat)<0)
                        dropClass(CodexHUD,"openhead");
                    if (mode.search(codexHeartMode_pat)>=0) {
                        Codex.heart_mode=mode;
                        addClass(CodexHUD,"openheart");}
                    if (mode.search(codexHeadMode_pat)>=0) {
                        Codex.head_mode=mode;
                        addClass(CodexHUD,"openhead");}}
                
                changeMode(mode);}
            else {
                // Clearing the mode is a lot simpler, in part because
                //  setHUD clears most of the classes when it brings
                //  the HUD down.
                fdjtLog.HumaneHide();
                Codex.last_mode=Codex.mode;
                if (Codex.liveinput) {
                    Codex.liveinput.blur();
                    Codex.liveinput=false;}
                document.body.focus();
                dropClass(CodexHUD,"openheart");
                dropClass(CodexHUD,"openhead");
                dropClass(document.body,"dimmed");
                dropClass(document.body,"codexhelp");
                dropClass(document.body,"cxPREVIEW");
                dropClass(document.body,"cxSHRINK");
                Codex.cxthelp=false;
                if (display_sync) Codex.displaySync();
                setHUD(false);}}

        function focus(input){
            input.focus(); Codex.liveinput=input;}
        Codex.setFocus=focus;

        function changeMode(mode){      
            fdjtDOM.dropClass(CodexHUD,CodexMode_pat);
            fdjtDOM.addClass(CodexHUD,mode);
            // This updates scanning state
            if ((Codex.scanning)&&(mode!=="scanning")) {
                // Scroll the scanned content (glosses, search
                // results, etc) to reflect any motion
                var heart=Codex.DOM.heart;
                var height=heart.offsetHeight;
                var scanning=Codex.scanning;
                var content=getParent(scanning,".hudpanel");
                var scrolltop=content.scrollTop;
                var scrollbottom=content.scrollTop+height;
                var inner=getGeometry(scanning,content);
                
                if (inner.height<=0) {} /* Not displayed */
                else if ((inner.top<scrolltop)||(inner.bottom>scrollbottom)) {
                    // Scroll into view
                    if (inner.height>height) content.scrollTop=inner.top;
                    else if (inner.height>height/2)
                        content.scrollTop=Math.floor(inner.top-(height/2));
                    else {
                        var gap=height-inner.height;
                        content.scrollTop=Math.floor(inner.top-(gap/2));}}
                else {} // Already in view
                Codex.scanning=false;}
            
            // This updates scroller dimensions, we delay it
            //  because apparently, on some browsers, the DOM
            //  needs to catch up with CSS
            if ((Codex.scrolling)&&(!(Codex.scrolldivs))) {
                var scroller=fdjtID(Codex.scrolling);
                if (Codex.Trace.iscroll)
                    fdjtLog("Updating scroller for #%s s=%o",
                            Codex.scrolling,scroller);
                setTimeout(function(){updateScroller(scroller);},
                           2000);}
            
            // We autofocus any input element appropriate to the
            // mode
            if (codex_mode_foci[mode]) {
                var input=fdjtID(codex_mode_foci[mode]);
                if (input) focus(input);}
            // Moving the focus back to the body lets keys work
            else document.body.focus();
            
            if (display_sync) Codex.displaySync();}

        function fadeUpHUD(){
            fdjtLog("Setting properties");
            CodexHUD.style.opacity=0.001;
            setTimeout(function(){
                fdjtLog("Changing opacity");
                CodexHUD.style.opacity=1.00;
                setTimeout(function(){
                    fdjtLog("Clearing setup");
                    CodexHUD.style.opacity='';},
                           1500);},
                       1500);}
        Codex.fadeUpHUD=fadeUpHUD;

        // function updateScroller(elt){}
        function updateScroller(elt){
            if (Codex.scrolldivs) return;
            if (Codex.Trace.iscroll) fdjtLog("updateScroller elt=%o",elt);
            if (typeof elt === 'string') elt=fdjtID(elt);
            if (!(elt)) return;
            var eltid=elt.id;
            while ((elt)&&(!(eltid))) {
                elt=elt.parentNode; eltid=elt.id;}
            if (!(eltid)) return;
            if ((Codex.scrollers[eltid])&&
                (Codex.scrollers[eltid].scroller===elt)) {
                var scroller=Codex.scrollers[eltid];
                if (Codex.Trace.iscroll)
                    fdjtLog("updateScroller/refresh %o",scroller);
                scroller.refresh();}
            else {
                var newid=eltid+"_WRAPPER";
                var wrapper=fdjtID(newid);
                if (!(wrapper)) {
                    wrapper=fdjtDOM("div#"+newid);
                    elt.parentNode.replaceChild(wrapper,elt);
                    wrapper.appendChild(elt);}
                if (hasClass(elt,"hudpanel")) {
                    addClass(wrapper,"hudpanel");
                    dropClass(elt,"hudpanel");}
                var scroller=new iScroll(wrapper);
                if (Codex.Trace.iscroll)
                    fdjtLog("updateScroller/create %o for %o around %o",
                            scroller,wrapper,elt);
                Codex.scrollers[eltid]=scroller;}}
        function updateScroller(elt){
            if (Codex.scrolldivs) return;
            if (Codex.heartscroller) Codex.heartscroller.refresh();
            else {
                var heart=fdjtID("CODEXHEART");
                var contents=fdjtID("CODEXHEARTCONTENTS")
                if (!(contents)) {
                    contents=fdjtDOM("div#CODEXHEARTCONTENTS");
                    fdjtDOM(contents,fdjtDOM.Array(heart.childNodes));
                    fdjtDOM(heart,contents);}
                Codex.heartscroller=new iScroll(heart);
                Codex.heartscroller.refresh();}}
        Codex.UI.updateScroller=updateScroller;

        function CodexHUDToggle(mode,keephud){
            if (!(Codex.mode)) CodexMode(mode);
            else if (mode===Codex.mode)
                if (keephud) CodexMode(true); else CodexMode(false);
            else if ((mode==='heart')&&
                     (Codex.mode.search(codexHeartMode_pat)===0))
                if (keephud) CodexMode(true); else CodexMode(false);
            else CodexMode(mode);}
        CodexMode.toggle=CodexHUDToggle;

        Codex.dropHUD=function(){return CodexMode(false);}
        Codex.toggleHUD=function(evt){
            evt=evt||event;
            if ((evt)&&(fdjtUI.isClickable(fdjtUI.T(evt)))) return;
            fdjtLog("toggle HUD %o hudup=%o",evt,Codex.hudup);
            if (Codex.hudup) setHUD(false,false);
            else setHUD(true);};
        
        /* The App HUD */
        
        function fillinTabs(){
            var hidehelp=fdjtID("SBOOKHIDEHELP");
            var dohidehelp=fdjtState.getCookie("sbookhidehelp");
            if (!(hidehelp)) {}
            else if (dohidehelp==='no') hidehelp.checked=false;
            else if (dohidehelp) hidehelp.checked=true;
            else hidehelp.checked=false;
            if (hidehelp)
                hidehelp.onchange=function(evt){
                    if (hidehelp.checked)
                        fdjtState.setCookie("sbookhidehelp",true,false,"/");
                    else fdjtState.setCookie("sbookhidehelp","no",false,"/");};
            var refuris=document.getElementsByName("REFURI");
            if (refuris) {
                var i=0; var len=refuris.length;
                while (i<len)
                    if (refuris[i].value==='fillin')
                        refuris[i++].value=Codex.refuri;
                else i++;}
            fillinAboutInfo();
            /* Get various external APPLINK uris */
            var offlineuri=fdjtDOM.getLink("Codex.offline")||altLink("offline");
            var epuburi=fdjtDOM.getLink("Codex.epub")||altLink("ebub");
            var mobiuri=fdjtDOM.getLink("Codex.mobi")||altLink("mobi");
            var zipuri=fdjtDOM.getLink("Codex.mobi")||altLink("mobi");
            if (offlineuri) {
                var elts=document.getElementsByName("SBOOKOFFLINELINK");
                var i=0; while (i<elts.length) {
                    var elt=elts[i++];
                    if (offlineuri!=='none') elt.href=offlineuri;
                    else {
                        elt.href=false;
                        addClass(elt,"deadlink");
                        elt.title='this sBook is not available offline';}}}
            if (epuburi) {
                var elts=document.getElementsByName("SBOOKEPUBLINK");
                var i=0; while (i<elts.length) {
                    var elt=elts[i++];
                    if (epuburi!=='none') elt.href=epuburi;
                    else {
                        elt.href=false;
                        addClass(elt,"deadlink");
                        elt.title='this sBook is not available as an ePub';}}}
            if (mobiuri) {
                var elts=document.getElementsByName("SBOOKMOBILINK");
                var i=0; while (i<elts.length) {
                    var elt=elts[i++];
                    if (mobiuri!=='none') elt.href=mobiuri;
                    else {
                        elt.href=false;
                        addClass(elt,"deadlink");
                        elt.title=
                            'this sBook is not available as a MOBIpocket format eBook';}}}
            if (zipuri) {
                var elts=document.getElementsByName("SBOOKZIPLINK");
                var i=0; while (i<elts.length) {
                    var elt=elts[i++];
                    if (zipuri!=='none') elt.href=zipuri;
                    else {
                        elt.href=false;
                        addClass(elt,"deadlink");
                        elt.title=
                            'this sBook is not available as a ZIP bundle';}}}
            /* If the book is offline, don't bother showing the link
               to the offline version. */
            if (Codex.persist) addClass(document.body,"sbookoffline");}

        function altLink(type,uri){
            uri=uri||Codex.refuri;
            if (uri.search("http://")===0)
                return "http://offline."+uri.slice(7);
            else if (uri.search("https://")===0)
                return "https://offline."+uri.slice(8);
            else return false;}

        function _sbookFillTemplate(template,spec,content){
            if (!(content)) return;
            var elt=fdjtDOM.$(spec,template);
            if ((elt)&&(elt.length>0)) elt=elt[0];
            else return;
            if (typeof content === 'string')
                elt.innerHTML=fixStaticRefs(content);
            else if (content.cloneNode)
                fdjtDOM.replace(elt,content.cloneNode(true));
            else fdjtDOM(elt,content);}

        function fillinAboutInfo(){
            var about=fdjtID("CODEXABOUTBOOK");
            var bookabout=fdjtID("SBOOKABOUTPAGE")||fdjtID("SBOOKABOUT");
            var authorabout=fdjtID("SBOOKAUTHORPAGE")||
                fdjtID("SBOOKABOUTAUTHOR");
            var acknowledgements=
                fdjtID("SBOOKACKNOWLEDGEMENTSPAGE")||
                fdjtID("SBOOKACKNOWLEDGEMENTS");
            var metadata=fdjtDOM.Anchor(
                "https://www.sbooks.net/publish/metadata?REFURI="+
                    encodeURIComponent(Codex.refuri),
                "metadata",
                "edit metadata");
            metadata.target="_blank";
            metadata.title=
                "View (and possibly edit) the metadata for this book";
            var reviews=fdjtDOM.Anchor(
                null,
                // "https://www.sbooks.net/publish/reviews?REFURI="+
                //                  encodeURIComponent(Codex.refuri),
                "reviews",
                "see/add reviews");
            reviews.target="_blank";
            reviews.title="Sorry, not yet implemented";
            // fdjtDOM(about,fdjtDOM("div.links",metadata,reviews));

            if (bookabout) fdjtDOM(about,bookabout);
            else {
                var title=
                    fdjtID("SBOOKTITLE")||
                    fdjtDOM.getMeta("Codex.title")||
                    fdjtDOM.getMeta("SBOOK.title")||
                    fdjtDOM.getMeta("DC.title")||
                    fdjtDOM.getMeta("~TITLE")||
                    document.title;
                var byline=
                    fdjtID("SBOOKBYLINE")||fdjtID("SBOOKAUTHOR")||
                    fdjtDOM.getMeta("Codex.byline")||
                    fdjtDOM.getMeta("Codex.author")||
                    fdjtDOM.getMeta("SBOOK.byline")||
                    fdjtDOM.getMeta("SBOOK.author")||
                    fdjtDOM.getMeta("BYLINE")||
                    fdjtDOM.getMeta("AUTHOR");
                var copyright=
                    fdjtID("SBOOKCOPYRIGHT")||
                    fdjtDOM.getMeta("Codex.copyright")||
                    fdjtDOM.getMeta("Codex.rights")||
                    fdjtDOM.getMeta("SBOOK.copyright")||
                    fdjtDOM.getMeta("SBOOK.rights")||
                    fdjtDOM.getMeta("COPYRIGHT")||
                    fdjtDOM.getMeta("RIGHTS");
                var publisher=
                    fdjtID("SBOOKPUBLISHER")||
                    fdjtDOM.getMeta("Codex.publisher")||
                    fdjtDOM.getMeta("SBOOK.publisher")||                    
                    fdjtDOM.getMeta("PUBLISHER");
                var description=
                    fdjtID("SBOOKDESCRIPTION")||
                    fdjtDOM.getMeta("Codex.description")||
                    fdjtDOM.getMeta("SBOOK.description")||
                    fdjtDOM.getMeta("DESCRIPTION");
                var digitized=
                    fdjtID("SBOOKDIGITIZED")||
                    fdjtDOM.getMeta("Codex.digitized")||
                    fdjtDOM.getMeta("SBOOK.digitized")||
                    fdjtDOM.getMeta("DIGITIZED");
                var sbookified=fdjtID("SBOOK.converted")||
                    fdjtDOM.getMeta("SBOOK.converted");
                _sbookFillTemplate(about,".title",title);
                _sbookFillTemplate(about,".byline",byline);
                _sbookFillTemplate(about,".publisher",publisher);
                _sbookFillTemplate(about,".copyright",copyright);
                _sbookFillTemplate(about,".description",description);
                _sbookFillTemplate(about,".digitized",digitized);
                _sbookFillTemplate(about,".sbookified",sbookified);
                _sbookFillTemplate(about,".about",fdjtID("SBOOKABOUT"));
                var cover=fdjtDOM.getLink("cover");
                if (cover) {
                    var cover_elt=fdjtDOM.$(".cover",about)[0];
                    if (cover_elt) fdjtDOM(cover_elt,fdjtDOM.Image(cover));}}
            if (authorabout) fdjtDOM(about,authorabout);
            if (acknowledgements) {
                var clone=acknowledgements.cloneNode(true);
                clone.id=null;
                fdjtDOM(about,clone);}}

        var flyleaf_app_init=false;
        function initFlyleafApp(){
            if (flyleaf_app_init) return;
            if (Codex.appinit) return;
            var query=document.location.search||"?";
            var refuri=Codex.refuri;
            var appuri="https://"+Codex.server+"/flyleaf"+query;
            if (query.search("REFURI=")<0)
                appuri=appuri+"&REFURI="+encodeURIComponent(refuri);
            if (query.search("TOPURI=")<0)
                appuri=appuri+"&TOPURI="+
                encodeURIComponent(document.location.href);
            if (document.title) {
                appuri=appuri+"&DOCTITLE="+encodeURIComponent(document.title);}
            fdjtID("SBOOKSAPP").src=appuri;
            flyleaf_app_init=true;}
        Codex.initFlyleafApp=initFlyleafApp;

        CodexMode.selectApp=function(){
            if (Codex.mode==='sbooksapp') CodexMode(false);
            else CodexMode('sbooksapp');}

        /* Scanning */

        function CodexScan(elt,src,backward){
            var cxt=false;
            var body=document.body;
            var pelt=Codex.scanning;
            if (Codex.Trace.mode)
                fdjtLog("CodexScan() %o (src=%o) mode=%o scn=%o/%o",
                        elt,src,Codex.mode,Codex.scanning,Codex.target);
            // Copy the description of what we're scanning into the
            // scanner (at the top of the page during scanning and
            // preview)
            if (Codex.scanning!==src) {
                var clone=src.cloneNode(true);
                clone.id="CODEXSCAN";
                fdjtDOM.replace("CODEXSCAN",clone);
                // This all makes sure that the >| and |< buttons
                // appear appropriately
                if (Codex.nextSlice(src))
                    dropClass("CODEXHUD","scanend");
                else addClass("CODEXHUD","scanend");
                if (Codex.prevSlice(src))
                    dropClass("CODEXHUD","scanstart");
                else addClass("CODEXHUD","scanstart");
                // This marks where we are currently scanning
                if (pelt) dropClass(pelt,"codexscanpoint");
                if (src) addClass(src,"codexscanpoint");
                Codex.scanning=src;}
            else {}
            var highlights=[];
            if (Codex.target)
                Codex.clearHighlights(Codex.getDups(Codex.target));
            if ((src)&&(hasClass(src,"gloss"))) {
                var glossinfo=Codex.glosses.ref(src.name);
                if (glossinfo.excerpt) {
                    var searching=Codex.getDups(elt.id);
                    var range=Codex.findExcerpt(
                        searching,glossinfo.excerpt,glossinfo.exoff);
                    if (range) highlights=
                        fdjtUI.Highlight(range,"highlightexcerpt");}
                else {
                    var about=src.about, target=fdjtID(about);
                    addClass(target,"highlightpassage");}}
            else if ((src)&&(getParent(src,".sbookresults"))) {
                var about=src.about, target=fdjtID(about);
                if (target) {
                    var info=Codex.docinfo[target.id];
                    var terms=Codex.query._query;
                    var spellings=info.knodeterms;
                    var i=0; var lim=terms.length;
                    if (lim===0) addClass(target,"highlightpassage");
                    else while (i<lim) {
                        var term=terms[i++];
                        var h=Codex.highlightTerm(term,target,info,spellings);
                        highlights=highlights.concat(h);}}}
            Codex.setTarget(elt);
            delete Codex.scanpoints;
            delete Codex.scanoff;
            if ((highlights)&&(highlights.length===1)&&
                (getParent(highlights[0],elt)))
                Codex.GoTo(elt,"Scan");
            else if ((highlights)&&(highlights.length)) {
                var possible=Codex.getDups(elt.id);
                if (possible.length) {
                    var scanpoints=[];
                    var i=0, lim=possible.length;
                    while (i<lim) {
                        var poss=possible[i++];
                        var j=0, jlim=highlights.length;
                        while (j<jlim) {
                            if (getParent(highlights[j++],poss)) {
                                scanpoints.push(poss); break;}}}
                    if (scanpoints.length)
                        Codex.scanpoints=scanpoints;
                    else Codex.scanpoints=possible;
                    if (backward) 
                        Codex.scanoff=Codex.scanpoints.length-1;
                    else Codex.scanoff=0;
                    Codex.GoTo(Codex.scanpoints[Codex.scanoff]);}
                else Codex.GoTo(elt,"Scan");}
            else Codex.GoTo(elt,"Scan");
            CodexMode("scanning");}
        Codex.Scan=CodexScan;
        
        Codex.addConfig("uisize",function(name,value){
            fdjtDOM.swapClass(CodexHUD,/codexuifont\w+/,"codexuifont"+value);});
        Codex.addConfig("showconsole",function(name,value){
            if (value) addClass(CodexHUD,"codexshowconsole");
            else dropClass(CodexHUD,"codexshowconsole");});
        Codex.addConfig("animatecontent",function(name,value){
            if (Codex.dontanimate) {}
            else if (value) addClass(document.body,"cxANIMATE");
            else dropClass(Codex.page,"cxANIMATE");});
        Codex.addConfig("animatehud",function(name,value){
            if (Codex.dontanimate) {}
            else if (value) addClass(Codex.HUD,"cxANIMATE");
            else dropClass(Codex.HUD,"cxANIMATE");});

        /* Settings apply/save handlers */

        function getSettings(){
            var result={};
            var settings=fdjtID("CODEXSETTINGS");
            var layout=fdjtDOM.getInputValues(settings,"CODEXLAYOUT");
            result.layout=
                ((layout)&&(layout.length)&&(layout[0]))||false;
            var bodysize=fdjtDOM.getInputValues(settings,"CODEXBODYSIZE");
            if ((bodysize)&&(bodysize.length))
                result.bodysize=bodysize[0];
            var bodyfamily=fdjtDOM.getInputValues(settings,"CODEXBODYFAMILY");
            if ((bodyfamily)&&(bodyfamily.length))
                result.bodyfamily=bodyfamily[0];
            var uisize=fdjtDOM.getInputValues(settings,"CODEXUISIZE");
            if ((uisize)&&(uisize.length))
                result.uisize=uisize[0];
            var hidesplash=fdjtDOM.getInputValues(settings,"CODEXHIDESPLASH");
            result.hidesplash=((hidesplash)&&(hidesplash.length))||false;
            var showconsole=fdjtDOM.getInputValues(settings,"CODEXSHOWCONSOLE");
            result.showconsole=
                ((showconsole)&&(showconsole.length)&&(true))||false;
            var isoffline=fdjtDOM.getInputValues(settings,"CODEXLOCAL");
            result.persist=
                ((isoffline)&&(isoffline.length)&&(isoffline[0]))||false;
            var animatecontent=fdjtDOM.getInputValues(
                settings,"CODEXANIMATECONTENT");
            result.animatecontent=
                ((animatecontent)&&(animatecontent.length)&&
                 (animatecontent[0]))||
                false;
            var animatehud=fdjtDOM.getInputValues(
                settings,"CODEXANIMATEHUD");
            result.animatehud=
                ((animatehud)&&(animatehud.length)&&
                 (animatehud[0]))||
                false;
            
            return result;}

        Codex.UI.settingsOK=function(){
            var settings=getSettings();
            Codex.setConfig(settings);
            Codex.saveConfig(settings);
            fdjtDOM.replace("CODEXSETTINGSMESSAGE",
                            fdjtDOM("span#CODEXSETTINGSMESSAGE",
                                    "Your settings have been saved."));};
        
        Codex.UI.settingsCancel=function(){
            Codex.setConfig(Codex.getConfig());
            fdjtDOM.replace("CODEXSETTINGSMESSAGE",
                            fdjtDOM("span#CODEXSETTINGSMESSAGE",
                                    "Your changes have been discarded."));};

        /* Console methods */
        function console_eval(){
            fdjtLog("Executing %s",input_console.value);
            var result=eval(input_console.value);
            var string_result=
                ((result.nodeType)?
                 (fdjtString("%o",result)):
                 (fdjtString("%j",result)));
            fdjtLog("Result is %s",string_result);}
        function consolebutton_click(evt){console_eval();}
        function consoleinput_keypress(evt){
            evt=evt||event;
            var target=fdjtUI.T(evt);
            if (evt.keyCode===13) {
                if (!(evt.ctrlKey)) {
                    fdjtUI.cancel(evt);
                    console_eval();
                    if (evt.shiftKey) input_console.value="";}}}

        function keyboardHelp(arg,force){
            if (arg===true) {
                if (Codex.keyboardHelp.timer) {
                    clearTimeout(Codex.keyboardHelp.timer);
                    Codex.keyboardHelp.timer=false;}
                dropClass("CODEXKEYBOARDHELPBOX","closing");
                dropClass("CODEXKEYBOARDHELPBOX","closed");
                return;}
            else if (arg===false) {
                if (Codex.keyboardHelp.timer) {
                    clearTimeout(Codex.keyboardHelp.timer);
                    Codex.keyboardHelp.timer=false;}
                addClass("CODEXKEYBOARDHELPBOX","closed");
                dropClass("CODEXKEYBOARDHELPBOX","closing");
                return;}
            if ((!force)&&(!(Codex.keyboardhelp))) return;
            if (typeof arg === 'string') arg=fdjtID(arg);
            if ((!(arg))||(!(arg.nodeType))) return;
            var box=fdjtID("CODEXKEYBOARDHELPBOX");
            var content=arg.cloneNode(true);
            content.id="CODEXKEYBOARDHELP";
            fdjtDOM.replace("CODEXKEYBOARDHELP",content);
            fdjtDOM.dropClass(box,"closed");
            Codex.keyboardHelp.timer=
                setTimeout(function(){
                    fdjtDOM.addClass(box,"closing");
                    Codex.keyboardHelp.timer=
                        setTimeout(function(){
                            Codex.keyboardHelp.timer=false;
                            fdjtDOM.swapClass(box,"closing","closed");},
                                   5000);},
                           5000);};
        Codex.keyboardHelp=keyboardHelp;

        /* Showing a particular gloss */

        Codex.showGloss=function showGloss(uuid){
            if (!(Codex.glosses.ref(uuid))) return false;
            var elts=document.getElementsByName(uuid);
            if (!(elts)) return false;
            else if (!(elts.length)) return false;
            else {
                var allglosses=fdjtID("CODEXALLGLOSSES");
                var hasParent=fdjtDOM.hasParent;
                var i=0, lim=elts.length;
                while (i<lim) {
                    var src=elts[i++];
                    if (hasParent(src,allglosses)) {
                        var elt=fdjtID(src.about);
                        CodexMode("allglosses");
                        Codex.Scan(elt,src);
                        return true;}}
                return false;}};

        /* Setting/clearing help mode */
        Codex.hideHelp=function(){
            fdjtDOM.dropClass(document.body,"codexhelp");};
        Codex.showHelp=function(){
            fdjtDOM.addClass(document.body,"codexhelp");};

        /* Button methods */

        function LoginButton_ontap(evt){
            evt=evt||event||null;
            if (Codex.mode==="sbooksapp") CodexMode(false);
            else CodexMode("sbooksapp");
            evt.cancelBubble=true;}

        return CodexMode;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/interaction.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

/* There are four basic display modes:
    reading (minimal decoration, with 'minimal' configurable)
    scanning (card at top, buttons on upper edges)
    addgloss (addgloss form at top, text highlighted)
    tool (lots of tools unfaded)

   Tap on content:
    if not hudup and no mode, raise the HUD;
    if not hudup and mode, clear the mode
    if hudup, drop the HUD
   Hold on content:
    if adding gloss to target, raise the hud
    otherwise, start adding gloss to target
*/

(function(){

    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    // Imports (kind of )
    var addClass=fdjtDOM.addClass;
    var hasClass=fdjtDOM.hasClass;
    var dropClass=fdjtDOM.dropClass;
    var swapClass=fdjtDOM.swapClass;
    var toggleClass=fdjtDOM.toggleClass;
    var getTarget=Codex.getTarget;
    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var isClickable=fdjtUI.isClickable;
    var getGeometry=fdjtDOM.getGeometry;
    var getChild=fdjtDOM.getChild;

    var parsePX=fdjtDOM.parsePX;
    var atoi=parseInt;

    var submitEvent=fdjtUI.submitEvent;

    var reticle=fdjtUI.Reticle;

    /* For tracking gestures */
    var start_x=-1; var start_y=-1; var last_x=-1; var last_y=-1;
    var start_t=-1; var last_t=-1;
    var cxicon=Codex.icon;
    
    var addgloss_timer=false;
    var preview_timer=false;

    /* Setup for gesture handling */

    function addHandlers(node,type){
        var mode=Codex.ui;
        fdjtDOM.addListeners(node,Codex.UI.handlers[mode][type]);}
    Codex.UI.addHandlers=addHandlers;

    function setupGestures(domnode){
        var mode=Codex.ui;
        if (!(mode)) Codex.ui=mode="mouse";
        if (!(domnode)) {
            addHandlers(false,'window');
            addHandlers(document,'document');
            addHandlers(document.body,'body');
            if (Codex.bypage) {
                // fdjtUI.TapHold(Codex.page,Codex.touch);
                addHandlers(fdjtID("CODEXPAGE"),'content');}
            else {
                // fdjtUI.TapHold(Codex.content,Codex.touch);
                addHandlers(fdjtID("CODEXCONTENT"),'content');}
            fdjtUI.TapHold(Codex.pagefoot,Codex.touch);
            fdjtUI.TapHold(fdjtID("CODEXEXPANDSCANNER"),Codex.touch);
            addHandlers(Codex.HUD,'hud');}
        var handlers=Codex.UI.handlers[mode];
        if (mode)
            for (var key in handlers)
                if ((key.indexOf('.')>=0)||(key.indexOf('#')>=0)) {
                    var nodes=fdjtDOM.$(key,domnode);
                    var h=handlers[key];
                    fdjtDOM.addListeners(nodes,h);}}
    Codex.setupGestures=setupGestures;

    var dont=fdjtUI.noBubble;
    function passmultitouch(evt){
        if ((evt.touches)&&(evt.touches.length>1)) return;
        else fdjtUI.noBubble(evt);}

    /* New simpler UI */

    function inUI(node){
        while (node)
            if (!(node)) return false;
        else if (node.codexui) return true;
        else node=node.parentNode;
        return false;}

    var gloss_focus=false;
    var gloss_blurred=false;
    function addgloss_focus(evt){
        evt=evt||event;
        gloss_blurred=false;
        var target=fdjtUI.T(evt);
        var form=getParent(target,"FORM");
        if (form) addClass(form,"focused");
        var div=((form)&&(getParent(form,".codexglossform")));
        if (!(Codex.hudup)) Codex.setHUD(true,false);
        gloss_focus=form;}
    function addgloss_blur(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var form=getParent(target,"FORM");
        if (form) dropClass(form,"focused");
        gloss_blurred=fdjtTime();
        gloss_focus=false;}
    Codex.UI.addgloss_focus=addgloss_focus;
    Codex.UI.addgloss_blur=addgloss_blur;

    /* Adding a gloss button */

    function addGlossButton(target){
        var passage=getTarget(target);
        if (!(passage)) return;
        var img=fdjtDOM.getChild(passage,".codexglossbutton");
        if (img) return;
        img=fdjtDOM.Image(cxicon("remark",64,64),".codexglossbutton",
                          "+","click to add a gloss to this passage");
        Codex.UI.addHandlers(img,"glossbutton");
        fdjtDOM.prepend(passage,img);}
    
    function glossbutton_ontap(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var passage=getTarget(target);
        if ((Codex.mode==="addgloss")&&
            (Codex.glosstarget===passage)) {
            fdjtUI.cancel(evt);
            Codex.setMode(true);}
        else if (passage) {
            fdjtUI.cancel(evt);
            var form=Codex.setGlossTarget(passage);
            if (!(form)) return;
            Codex.setMode("addgloss");
            Codex.setGlossForm(form);}}

    /* Functionality:
       on selection:
       save but keep selection,
       set target (if available)
       if hud is down, raise it
       on tap: (no selection)
       if hud is down, set target and raise it
       if no target, raise hud
       if tapping target, lower HUD
       if tapping other, set target, drop mode, and raise hud
       (simpler) on tap:
       if hudup, drop it
       otherwise, set target and raise HUD
    */

    /*
      Tap on content:
      if not hudup and no mode, raise the HUD;
      if not hudup and mode, clear the mode
      if hudup, drop the HUD
      Hold on content:
      if adding gloss to target, raise the hud
      otherwise, start adding gloss to target
    */

    /* Holding */

    var held=false; var handled=false;

    function clear_hold(caller){
        if (held) {
            clearTimeout(held); held=false;
            if (Codex.Trace.gestures)
                fdjtLog("clear_hold from %s",(caller||"somewhere"));}}

    /* Generic content interaction handler */

    var isEmpty=fdjtString.isEmpty;
    var gesture_start=false;
    var tap_target=false;
    var tap_timer=false;
    var last_text=false;

    function content_mousedown(evt){
        evt=evt||event;
        var sX=evt.screenX, sY=evt.screenY;
        var cX=evt.clientX, cY=evt.clientY;
        var now=fdjtTime();
        var addgloss=false;
        var target=fdjtUI.T(evt);

        if ((evt.changedTouches)&&(evt.changedTouches.length)) {
            var touch=evt.changedTouches[0];
            var sX=touch.screenX, sY=touch.screenY;
            var cX=touch.clientX, cY=touch.clientY;}

        // Don't capture modified events, except with shift key
        if ((evt.ctrlKey)||(evt.altKey)||(evt.button)) {
            gesture_start=false;
            return;}

        var passage=getTarget(target);
        // We get the passage here so we can include it in the trace message
        if (Codex.Trace.gestures)
            fdjtLog("content_mousedown (%o) on %o p=%o m=%o x=%o/%o y=%o/%o",
                    evt,target,passage,Codex.mode,cX,sX,cY,sY);

        var anchor=getParent(target,"A"), href;
        // If you tap on a relative anchor, move there using Codex
        // rather than the browser default
        if ((anchor)&&(anchor.href)&&
            (href=anchor.getAttribute("href"))&&(href[0]==='#')&&
            (document.getElementById(href.slice(1)))) {
            if (Codex.Trace.gestures) fdjtLog("cdown: follow link");
            var elt=document.getElementById(href.slice(1));
            // This would be the place to provide smarts for
            // asides/notes/etc, so they (for example) pop up
            Codex.JumpTo(elt);
            fdjtUI.cancel(evt);
            gesture_start=false;
            return;}

        if (fdjtUI.isClickable(target)) {
            if (Codex.Trace.gestures) fdjtLog("cdown: skip clickable");
            return;}

        var id=((passage)&&(passage.codexbaseid||passage.id));
        // Update our location
        if ((id)&&(Codex.docinfo[id])) {
            var info=Codex.docinfo[id];
            if (info.starts_at) {
                // If we were really clever, we might look at the
                //  selection object to get an even more precise
                //  location.  Not now.
                Codex.setLocation(info.starts_at);
                if (Codex.updatePageDisplay)
                    Codex.updatePageDisplay(Codex.curpage,Codex.location);}}
        
        // If there's a mode, clear it
        if (((Codex.hudup)||(Codex.mode))&&(Codex.mode!=="addgloss")) {
            if (Codex.Trace.gestures)
                fdjtLog("cdown:clearmode h=%o m=%o",Codex.hudup,Codex.mode);
            Codex.setMode(false);
            fdjtUI.cancel(evt);
            return;}
        else if (Codex.previewing) {
            if (Codex.Trace.gestures)
                fdjtLog("cdown:stopPreview p=%o t=%o",
                        Codex.previewing,Codex.previewTarget);
            Codex.stopPreview("content_mousedown");
            fdjtUI.cancel(evt);
            return;}
        // If there isn't a passage, move forward or backward
        else if ((Codex.mode!=="addgloss")&&
                 ((!(passage))||(passage===document.body)||
                 (passage===Codex.content)||
                 (hasClass(passage,"codexpage"))||
                  (inUI(passage)))) {
            if (Codex.Trace.gestures)
                fdjtLog("cdown/nopassage (%o) %o, m=%o, @%o,%o, vw=%o",
                        evt,target,Codex.mode,cX,cY,fdjtDOM.viewWidth());
            if (Codex.mode) {Codex.setMode(false); return;}
            if (cX>(fdjtDOM.viewWidth()/2))
                Codex.Forward(evt);
            else Codex.Backward(evt);
            gesture_start=false;
            fdjtUI.cancel(evt);
            return;}
        // If there's a live reply (gloss target/form) but the passage
        // isn't related to it's passage, move the target/form to the
        // new passage.  This enables threads which reference
        // different passages.
	else if ((passage)&&(Codex.glosstarget)&&(Codex.glossform)&&
		 (hasClass(Codex.glossform,"glossreply"))&&
		 (!((hasParent(passage,Codex.glosstarget))||
                    (hasParent(Codex.glosstarget,passage))))) {
            if (Codex.Trace.gestures)
                fdjtLog("cdown/newtarget, current reply to %o",
                        Codex.glosstarget);
	    Codex.setGlossTarget(passage,Codex.glossform);
	    fdjtUI.cancel(evt);
            fdjtUI.TapHold.fakePress(evt,250);
	    Codex.setMode("addgloss");
	    return;}
        else if ((Codex.glosstarget)&&
		 (!((hasParent(passage,Codex.glosstarget))||
                    (hasParent(Codex.glosstarget,passage))))) {
            // If we're adding a (non-reply) gloss and tap an
            // unrelated, we either lower the HUD (shrinking the gloss
            // form and growing the page), or we cancel the gloss.
            if (Codex.Trace.gestures)
                fdjtLog("cdown/current gloss %o",Codex.glosstarget);
            if (Codex.hudup) {
                if (Codex.Trace.gestures) fdjtLog("cdown/lower HUD");
                Codex.setHUD(false,false);
                fdjtUI.cancel(evt);}
            else {
                var live=fdjtID("CODEXLIVEGLOSS");
                if ((live)&&(hasClass(live,"modified"))) {
                    fdjtUI.choose([
                        {label: "Discard",
                         handler: function(){
                             Codex.cancelGloss(live);
                             Codex.setMode(false);}},
                        {label: "Save",
                         handler: function(){
                             var form=fdjtDOM.getChild(live,"form");
                             fdjtUI.forceSubmit(form);}}],
                                  "Save the changes to this gloss?");}
                else if (live) {
                    Codex.cancelGloss(live);
                    Codex.setMode(false);}
                else Codex.setMode(false);
                if (Codex.Trace.gestures) fdjtLog("cdown: cancel gloss");
                fdjtUI.cancel(evt);
                return;}}
        else if (Codex.glosstarget) {
            /* This case should be handled by the fdjtselecting wrapper
               on the passage */}
        // Finally, we open a gloss unless the action is a simple tap
        else {
            if (Codex.Trace.gestures) fdjtLog("cdown: start addgloss timer");
            addgloss_timer=
                setTimeout(function(){
                    var form_div=Codex.setGlossTarget(passage);
                    var form=fdjtDOM.getChild(form_div,"form");
                    addgloss_timer=false;
                    if (!(form)) return;
                    else fdjtUI.cancel(evt);
                    if (Codex.Trace.gestures)
                        fdjtLog("content_mousedown/addgloss (%o) %o, p=%o f=%o/%o",
                                evt,target,passage,form_div,form);
                    var mode=((evt.shiftKey)?("addtag"):("editnote"));
                    fdjtUI.TapHold.fakePress(evt,250);
                    form.className=mode;
                    Codex.setGlossForm(form_div);
                    Codex.setMode("addgloss");},
                          200);}}
 
    function content_mouseup(evt){
        evt=evt||event;
	fdjtUI.cancel(evt);
        if (addgloss_timer) {
            clearTimeout(addgloss_timer); addgloss_timer=false;
            if (Codex.hudup) {
                if (Codex.Trace.gestures)
                    fdjtLog("content_mousedown: %o, clearing hudup",evt);
                Codex.setHUD(false);}
            else if (Codex.mode==="addgloss") {
                if (Codex.Trace.gestures)
                    fdjtLog("content_mousedown: %o, addgloss ignore",evt);}
            else {
                var x=getOffX(evt); var w=fdjtDOM.viewWidth();
                if (Codex.Trace.gestures)
                    fdjtLog("content_mousedown: %s page %s x=%o, w=%o",
                            evt,((x<w/2)?("forward"):("back")),
                            x,w);
                if (x<w/2) Codex.pageBackward();
                else if (x>w/2) Codex.pageForward();
                else if (false) {
                    var target=fdjtUI.T(evt);
                    var passage=getTarget(target);
                    if (passage) Codex.setTarget(passage);
                    Codex.setHUD(true);}
                else {}}}
        if ((Codex.hudup)&&(Codex.Trace.gestures))
            fdjtLog("content_mousedown: %o: initGlossMode",evt);
        if (Codex.hudup) initGlossMode();}
    Codex.UI.content_release=content_mouseup;

    function initGlossMode(){
        var form=fdjtDOM.getChild("CODEXLIVEGLOSS","form");
        if (form) {
            var input=fdjtDOM.getInput(form,"NOTE");
            if (input) input.focus();
            Codex.setGlossMode(form.className);}}
    Codex.initGlossMode=initGlossMode;

        // This overrides the default_tap handler
    function content_click(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (isClickable(target)) return;
        else fdjtUI.cancel(evt);}


    /* TOC handlers */

    function getAbout(elt){
        while (elt) {
            if ((elt.name)&&(elt.name.search("SBR")===0))
                return elt;
            else elt=elt.parentNode;}
        return false;}

        function getTitleSpan(toc,ref){
            var titles=fdjtDOM.getChildren(toc,".codextitle");
            var i=0; var lim=titles.length;
            while (i<lim) {
                var title=titles[i++];
                if (title.name===ref) return title;}
            return false;}

    function toc_tapped(evt){
        evt=evt||event;
        var tap_target=fdjtUI.T(evt);
        var about=getAbout(tap_target);
        var cur_target=Codex.target;
        if (about) {
            var ref=about.name.slice(3);
            var target=fdjtID(ref);
            var info=Codex.docinfo[ref];
            var toc=getParent(tap_target,".codextoc");
            var show_fulltoc=
                ((info.sub)&&(info.sub.length>2))&&
                (info.elt!==Codex.head);
            if (Codex.Trace.gestures)
                fdjtLog("toc_tapped %o about=%o ref=%s",evt,about,ref);
            Codex.JumpTo(target);
            if (show_fulltoc) Codex.setMode("toc");
            else Codex.setMode("tocscan");
            return fdjtUI.cancel(evt);}
        else if (Codex.Trace.gestures) fdjtLog("toc_tapped %o noabout", evt);
        else {}}
    function toc_held(evt){
        evt=evt||event;
        var about=getAbout(fdjtUI.T(evt));
        if (preview_timer) {
            clearTimeout(preview_timer); preview_timer=false;}
        if (about) {
            var ref=about.name.slice(3);
            var toc=getParent(about,".codextoc");
            var title=getTitleSpan(toc,about.name);
            if (Codex.Trace.gestures)
                fdjtLog("toc_held %o about=%o ref=%s toc=%o title=%s",
                        evt,about,ref,toc,title);
            addClass(title,"codexpreviewtitle");
            addClass(about.parentNode,"codexheld");
            addClass(getParent(about,".spanbar"),"codexvisible");
            addClass(toc,"codexheld");
            Codex.startPreview(fdjtID(ref),"codexheld");
            return fdjtUI.cancel(evt);}
        else if (Codex.Trace.gestures) fdjtLog("toc_held %o noabout", evt);
        else {}}
    function toc_released(evt){
        evt=evt||event;
        var about=getAbout(fdjtUI.T(evt));
        if (preview_timer) {
            clearTimeout(preview_timer); preview_timer=false;}
        if (about) {
            var toc=getParent(about,".codextoc");
            var title=getTitleSpan(toc,about.name);
            if (Codex.Trace.gestures)
                fdjtLog("toc_released %o about=%o toc=%o title=%s",
                        evt,about,toc,title);
            dropClass(title,"codexpreviewtitle");
            dropClass(about.parentNode,"codexheld");
            dropClass(getParent(about,".spanbar"),"codexvisible");
            dropClass(toc,"codexheld");
            Codex.stopPreview("toc_released");}
        else if (Codex.Trace.gestures)
            fdjtLog("toc_released %o noabout",evt);
        else {}}
    function toc_slipped(evt){
        evt=evt||event;
        var about=getAbout(fdjtUI.T(evt));
        if ((!about)&&(Codex.Trace.gestures))
            fdjtLog("toc_slipped %o noabout",evt);
        if (about) {
            var toc=getParent(about,".codextoc");
            var title=getTitleSpan(toc,about.name);
            if (Codex.Trace.gestures)
                fdjtLog("toc_slipped %o about=%o toc=%o title=%s",
                        evt,about,toc,title);
            dropClass(title,"codexpreviewtitle");
            dropClass(getParent(about,".spanbar"),"codexvisible");
            dropClass(about.parentNode,"codexheld");
            dropClass(toc,"codexheld");}
        else if (Codex.Trace.gestures)
            fdjtLog("toc_slipped %o noabout",evt);
        else {}}

    /* Slice handlers */

    function getCard(target){
        return ((hasClass(target,"codexcard"))?(target):
                (getParent(target,".codexcard")))||
            getChild(target,".codexcard");}

    var scroll_pos={};

    function getScrollPos(slice){
        if ((!(slice))||(!(slice.id))) return false;
        else if (Codex.scrollers[slice.id])
            return Codex.scrollers[slice.id].scrollStartY;
        else return slice.scrollTop;}

    function slice_tapped(evt){
        var target=fdjtUI.T(evt);
        var slice=getParent(card,".codexslice");
        // if (scrolled(slice)) return;
        if (Codex.Trace.gestures)
            fdjtLog("slice_held %o: %o",evt,target);
        if (getParent(target,".ellipsis")) {
            fdjtUI.Ellipsis.toggle(target);
            fdjtUI.cancel(evt);
            return;}
        var card=getCard(target);
        if ((!(getParent(target,".tool")))&&
            (getParent(card,".codexslice"))) {
            Codex.Scan(fdjtID(card.about),card);
            return fdjtUI.cancel(evt);}
        else if ((card.name)||(card.getAttribute("name"))) {
            var name=(card.name)||(card.getAttribute("name"));
            var gloss=fdjtKB.ref(name,Codex.glosses);
            if (!(gloss)) return;
            var form=Codex.setGlossTarget(gloss);           
            if (!(form)) return;
            Codex.setMode("addgloss");}
        else if (card.about) {
            Codex.JumpTo(card.about);}}
    function slice_held(evt){
        var card=getCard(fdjtUI.T(evt||event));
        if (Codex.Trace.gestures)
            fdjtLog("slice_held %o: %o, scanning=%o",
                    evt,card,Codex.scanning);
        if (!(card)) return;
        if (Codex.scanning===card) return;
        var slice=getParent(card,".codexslice");
        var clone=card.cloneNode(true);
        clone.id="CODEXSCAN";
        fdjtDOM.replace("CODEXSCAN",clone);
        if (Codex.previewTarget) {
            var drop=Codex.getDups(Codex.previewTarget);
            dropClass(drop,"codexpreviewtarget");
            Codex.clearHighlights(drop);
            Codex.previewTarget=false;}
        if (card.about) {
            var target=Codex.previewTarget=fdjtID(card.about);
            var dups=Codex.getDups("codexpreviewtarget");
            addClass(dups,"codexpreviewtarget");}
        if (hasClass(card,"gloss")) {
            var glossinfo=Codex.glosses.ref(card.name);
            if (!(target))
                Codex.previewTarget=target=fdjtID(glossinfo.frag);
            else Codex.previewTarget=target;
            if (glossinfo.excerpt) {
                var searching=Codex.getDups(target.id);
                var range=Codex.findExcerpt(
                    searching,glossinfo.excerpt,glossinfo.exoff);
                if (range) {
                    var starts=range.startContainer;
                    if (!(getParent(starts,target)))
                        target=getTargetDup(starts,target);
                    if (!(hasClass(starts,"highlightexcerpt"))) {
                        fdjtUI.Highlight(range,"highlightexcerpt");}}
                else addClass(searching,"highlightpassage");}
            else {
                var dups=Codex.getDups(target);
                addClass(dups,"highlightpassage");}}
        else if (getParent(card,".sbookresults")) {
            var about=card.about;
            Codex.previewTarget=target=fdjtID(about);
            if (about) {
                var info=Codex.docinfo[target.id];
                var terms=Codex.query._query;
                var spellings=info.knodeterms;
                var i=0; var lim=terms.length;
                var dup_target=false;
                while (i<lim) {
                    var term=terms[i++];
                    var highlights=highlightTerm(term,target,info,spellings);
                    if (!(dup_target))
                        if ((highlights)&&(highlights.length)&&
                            (!(getParent(highlights[0],target))))
                            dup_target=getTargetDup(highlights[0],target);}
                if (dup_target) target=dup_target;}}
        else {}
        Codex.startPreview(target,"slice_held");
        return fdjtUI.cancel(evt);}
    function slice_released(evt){
        var card=getCard(fdjtUI.T(evt||event));
        if (Codex.Trace.gestures) {
            var card=getCard(fdjtUI.T(evt||event));
            fdjtLog("slice_released %o: %o, scanning=%o",evt,card);}
        Codex.stopPreview("slice_released");}

    function getTargetDup(scan,target){
        var targetid=target.id;
        while (scan) {
            if (hasClass(scan,"codexpage")) return scan;
            else if ((scan.getAttribute)&&
                     ((scan.id===targetid)||
                      (scan.getAttribute("data-baseid")===targetid))) 
                return scan;
            else scan=scan.parentNode;}
        return target;}

    /* Highlighting terms in passages (for scanning, etc) */

    function highlightTerm(term,target,info,spellings){
        var words=[]; var highlights=[];
        if (typeof term === 'string')
            words=((spellings)&&(spellings[term]))||[term];
        else {
            var knodes=info.knodes;
            var i=0; var lim=knodes.length;
            while (i<lim) {
                var knode=knodes[i++];
                if ((knode===term)||
                    (fdjtKB.contains(knode._always,term))) {
                    var qid=knode._qid; var dterm=knode.dterm;
                    var spelling=
                        ((spellings)&&
                         ((spellings[qid])||(spellings[dterm])));
                    if (!(spelling)) {
                        var synonyms=knode.EN;
                        if (!(synonyms)) {}
                        else if (typeof synonyms === 'string')
                            words.push(synonyms);
                        else words=words.concat(synonyms);
                        var hooks=knode.hooks;
                        if (!(hooks)) {}
                        else if (typeof hooks === 'string')
                            words.push(hooks);
                        else words=words.concat(hooks);}
                    else if (typeof spelling === 'string')
                        words.push(spelling);
                    else words=words.concat(spelling);}}
            if (words.length===0) words=false;}
        if (!(words)) return [];
        if (typeof words === 'string') words=[words];
        var j=0; var jlim=words.length;
        while (j<jlim) {
            var word=words[j++];
            var pattern=new RegExp(word.replace(/\s+/g,"(\\s+)"),"gm");
            var searching=Codex.getDups(target);
            var ranges=fdjtDOM.findMatches(searching,pattern);
            if (Codex.Trace.highlight)
                fdjtLog("Trying to highlight %s (using %o) in %o, ranges=%o",
                        word,pattern,target,ranges);
            if ((ranges)&&(ranges.length)) {
                var k=0; while (k<ranges.length) {
                    var h=fdjtUI.Highlight(
                        ranges[k++],"highlightsearch");
                    highlights=highlights.concat(h);}}}
        return highlights;}
    Codex.highlightTerm=highlightTerm;

    /* HUD handlers */

    function hud_tapped(evt,target){
        if (!(target)) target=fdjtUI.T(evt);
        if (Codex.Trace.gestures)
            fdjtLog("hud_tapped %o: %o",evt,target);
        if (isClickable(target)) return;
        else if (getParent(target,".helphud")) {
            var mode=fdjtDOM.findAttrib(target,"data-hudmode")||
                fdjtDOM.findAttrib(target,"hudmode");
            if (mode) Codex.setMode(mode)
            else Codex.setMode(false);
            return fdjtUI.cancel(evt);}
        var card=((hasClass(target,"codexcard"))?(target):
                  (getParent(target,".codexcard")));
        if (card) {
            if ((!(getParent(target,".tool")))&&
                (getParent(card,".codexslice"))) {
                Codex.Scan(fdjtID(card.about),card);
                return fdjtUI.cancel(evt);}
            else if ((card.name)||(card.getAttribute("name"))) {
                var name=(card.name)||(card.getAttribute("name"));
                var gloss=fdjtKB.ref(name,Codex.glosses);
                if (!(gloss)) return;
                var form=Codex.setGlossTarget(gloss);       
                if (!(form)) return;
                Codex.setMode("addgloss");}
            else if (card.about) {
                Codex.JumpTo(card.about);}
            fdjtUI.cancel(evt);
            return;}
        var scan=target, about=false, frag=false, gloss=false;
        while (scan) {
            if (about=scan.about) break;
            else if (frag=scan.frag) break;
            else scan=scan.parentNode;}
        if (frag) {Codex.ScanTo(frag); fdjtUI.cancel(evt);}
        else if ((about)&&(about[0]==='#')) {
            Codex.ScanTo(about.slice(0)); fdjtUI.cancel(evt);}
        else if ((about)&&(gloss=Codex.glosses.ref(about))) {
            var form=Codex.setGlossTarget(gloss);           
            if (!(form)) return;
            Codex.setMode("addgloss");
            fdjtUI.cancel(evt);}
        else {}}
    
    /* Keyboard handlers */

    // We use keydown to handle navigation functions and keypress
    //  to handle mode changes
    function onkeydown(evt){
        evt=evt||event||null;
        var kc=evt.keyCode;
        // fdjtLog("sbook_onkeydown %o",evt);
        if (evt.keyCode===27) { /* Escape works anywhere */
            if (Codex.mode) {
                Codex.last_mode=Codex.mode;
                Codex.setMode(false);
                Codex.setTarget(false);
                fdjtID("CODEXSEARCHINPUT").blur();}
            else if (Codex.last_mode) Codex.setMode(Codex.last_mode);
            else {}
            return;}
        else if ((evt.altKey)||(evt.ctrlKey)||(evt.metaKey)) return true;
        else if (kc===34) Codex.pageForward(evt);   /* page down */
        else if (kc===33) Codex.pageBackward(evt);  /* page up */
        else if (kc===40) { /* arrow down */
            Codex.setHUD(false);
            Codex.pageForward(evt);}
        else if (kc===38) {  /* arrow up */
            Codex.setHUD(false);
            Codex.pageBackward(evt);}
        else if (kc===37) Codex.scanBackward(evt); /* arrow left */
        else if (kc===39) Codex.scanForward(evt); /* arrow right */
        // Don't interrupt text input for space, etc
        else if (fdjtDOM.isTextInput(fdjtDOM.T(evt))) return true;
        else if ((!(Codex.mode))&&(kc===32)) // Space
            Codex.Forward(evt);
        // backspace or delete
        else if ((!(Codex.mode))&&((kc===8)||(kc===45)))
            Codex.Backward(evt);
        // Home goes to the current head.
        else if (kc===36) Codex.JumpTo(Codex.head);
        else if (Codex.mode==="addgloss") {
            var mode=Codex.getGlossMode();
            if (mode) return;
            var formdiv=fdjtID("CODEXLIVEGLOSS");
            var form=(formdiv)&&(fdjtDOM.getChild(formdiv,"FORM"));
            if (!(form)) return;
            if (kc===13) { // return/newline
                submitEvent(form);}
            else if ((kc===35)||(kc===91)) // # or [
                Codex.setGlossMode("addtag",form);
            else if (kc===32) // Space
                Codex.setGlossMode("editnote",form);
            else if ((kc===47)||(kc===58)) // /or :
                Codex.setGlossMode("addlink",form);
            else if ((kc===64)) // @
                Codex.setGlossMode("sharing",form);
            else {}}
        else return;
        fdjtUI.cancel(evt);}

    // At one point, we had the shift key temporarily raise/lower the HUD.
    //  We might do it again, so we keep this definition around
    function onkeyup(evt){
        evt=evt||event||null;
        var kc=evt.keyCode;
        // Codex.trace("sbook_onkeyup",evt);
        if (fdjtDOM.isTextInput(fdjtDOM.T(evt))) return true;
        else if ((evt.ctrlKey)||(evt.altKey)||(evt.metaKey)) return true;
        else {}}
    Codex.UI.handlers.onkeyup=onkeyup;

    /* Keypress handling */

    // We have a big table of command characters which lead to modes
    var modechars={
        63: "searching",102: "searching",
        65: "openheart", 97: "openheart",
        83: "searching",115: "searching",
        80: "gotopage",112: "gotopage",
        76: "gotoloc",108: "gotoloc",
        70: "searching",
        100: "device",68: "device",
        110: "toc",78: "toc",
        116: "flytoc",84: "flytoc",
        72: "help", 104: "humane",
        103: "allglosses",71: "allglosses",
        67: "console", 99: "console"};

    // Handle mode changes
    function onkeypress(evt){
        var modearg=false; 
        evt=evt||event||null;
        var ch=evt.charCode||evt.keyCode;
        // Codex.trace("sbook_onkeypress",evt);
        if (fdjtDOM.isTextInput(fdjtDOM.T(evt))) return true;
        else if ((evt.altKey)||(evt.ctrlKey)||(evt.metaKey)) return true;
        else if ((ch===72)||(ch===104)) { // 'H' or 'h'
            fdjtDOM.toggleClass(document.body,'codexhelp');
            return false;}
        else modearg=modechars[ch];
        if (modearg==="openheart")
            modearg=Codex.last_heartmode||"about";
        if (modearg==="humane") {
            fdjtLog.Humane();
            return;}
        var mode=Codex.setMode();
        if (modearg) {
            if (mode===modearg) {
                Codex.setMode(false); mode=false;}
            else {
                Codex.setMode(modearg); mode=modearg;}}
        else {}
        if (mode==="searching")
            Codex.setFocus(fdjtID("CODEXSEARCHINPUT"));
        else fdjtID("CODEXSEARCHINPUT").blur();
        fdjtDOM.cancel(evt);}
    Codex.UI.handlers.onkeypress=onkeypress;

    function goto_keypress(evt){
        evt=evt||event||null;
        var target=fdjtUI.T(evt);
        var ch=evt.charCode||evt.keyCode;
        var max=false; var min=false;
        var handled=false;
        if (target.name==='GOTOLOC') {
            min=0; max=Math.floor(Codex.ends_at/128);}
        else if (target.name==='GOTOPAGE') {
            min=1; max=Codex.pagecount;}
        else if (ch===13) fdjtUI.cancel(evt);
        if (ch===13) {
            if (target.name==='GOTOPAGE') {
                var num=parseInt(target.value);
                if (typeof num === 'number') {
                    handled=true; Codex.GoToPage(num);}
                else {}}
            else if (target.name==='GOTOLOC') {
                var locstring=target.value;
                var pct=parseFloat(locstring);
                if ((typeof pct === 'number')&&(pct>=0)&&(pct<=100)) {
                    var loc=Math.floor((pct/100)*Codex.ends_at);
                    Codex.JumpTo(loc); handled=true;}}
            else {}
            if (handled) {
                target.value="";
                Codex.setMode(false);}}}
    Codex.UI.goto_keypress=goto_keypress;

    /* ADDGLOSS interaction */

    function delete_ontap(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        fdjtUI.cancel(evt);
        var block=getParent(target,".codexglossform");
        if (!(block)) return;
        var glosselt=fdjtDOM.getInput(block,'UUID');
        if (!(glosselt)) return;
        var qref=glosselt.value;
        var gloss=Codex.glosses.ref(qref);
        if (!(gloss)) return;
        fdjtUI.choose([
            {label: "No"},
            {label: "Yes, delete it",selected: true,
             handler: function(){
                 var frag=gloss.get("frag");
                 fdjtAjax.jsonCall(
                     function(response){glossdeleted(response,qref,frag);},
                     "https://"+Codex.server+"/v1/delete",
                     "gloss",qref);}}],
                      "Really delete this gloss?");
        return;}
    Codex.UI.delete_ontap=delete_ontap;
    
    function respond_ontap(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        fdjtUI.cancel(evt);
        var block=getParent(target,".codexglossform");
        if (!(block)) return;
        var glosselt=fdjtDOM.getInput(block,'UUID');
        if (!(glosselt)) return;
        var qref=glosselt.value;
        var gloss=Codex.glosses.ref(qref);
        if (!(gloss)) return;
        var form=Codex.setGlossTarget(gloss,Codex.getGlossForm(gloss,true));
        if (!(form)) return;
        Codex.setMode("addgloss");}
    Codex.UI.respond_ontap=respond_ontap;

    function glossdeleted(response,glossid,frag){
        if (response===glossid) {
            Codex.glosses.drop(glossid);
            Codex.allglosses=fdjtKB.remove(Codex.allglosses,glossid);
            if (Codex.persist)
                fdjtState.setLocal("glosses("+Codex.refuri+")",
                                   Codex.allglosses,true);
            var editform=fdjtID("CODEXEDITGLOSS_"+glossid);
            if (editform) {
                var editor=editform.parentNode;
                if (editor===fdjtID('CODEXLIVEGLOSS')) {
                    Codex.glosstarget=false;
                    Codex.setMode(false);}
                fdjtDOM.remove(editor);}
            var renderings=fdjtDOM.Array(document.getElementsByName(glossid));
            if (renderings) {
                var i=0; var lim=renderings.length;
                while (i<lim) {
                    var rendering=renderings[i++];
                    if (rendering.id==='CODEXSCAN')
                        fdjtDOM.replace(
                            rendering,fdjtDOM("div.codexcard.deletedgloss"));
                    else fdjtDOM.remove(rendering);}}
            var glossmark=fdjtID("SBOOK_GLOSSMARK_"+frag);
            if (glossmark) {
                var newglosses=fdjtKB.remove(glossmark.glosses,glossid);
                if (newglosses.length===0) fdjtDOM.remove(glossmark);
                else glossmark.glosses=newglosses;}}
        else fdjtUI.alert(response);}

    function addoutlet_keydown(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var content=target.value;
        var glossdiv=fdjtID("CODEXLIVEGLOSS");
        if (!(glossdiv)) return;
        var form=getChild(glossdiv,"FORM");
        var outlet_cloud=Codex.outletCloud();
        var ch=evt.keyCode||evt.charCode;
        if ((fdjtString.isEmpty(content))&&(ch===13)) {
            if (outlet_cloud.selection) 
                Codex.addOutlet2Form(
                    form,outlet_cloud.selection.getAttribute("value"));
            else Codex.setGlossMode("editnote");
            return;}
        else if ((ch===13)&&(outlet_cloud.selection)) {
            Codex.addOutlet2Form(form,outlet_cloud.selection);
            outlet_cloud.complete("");
            target.value="";}
        else if (ch===13) {
            var completions=outlet_cloud.complete(content);
            if (completions.length)
                Codex.addOutlet2Form(
                    form,completions[0].getAttribute("value"));
            else Codex.addOutlet2Form(form,content);
            fdjtUI.cancel(evt);
            target.value="";
            outlet_cloud.complete("");}
        else if (ch===9) { /* tab */
            var completions=outlet_cloud.complete(content);
            fdjtUI.cancel(evt);
            if ((outlet_cloud.prefix)&&
                (outlet_cloud.prefix!==content)) {
                target.value=outlet_cloud.prefix;
                fdjtDOM.cancel(evt);
                setTimeout(function(){
                    Codex.UI.updateScroller("CODEXGLOSSOUTLETS");},
                           100);
                return;}
            else if (evt.shiftKey) outlet_cloud.selectPrevious();
            else outlet_cloud.selectNext();}
        else setTimeout(function(evt){
            outlet_cloud.complete(target.value);},
                        100);}

    function addtag_keydown(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var content=target.value;
        var glossdiv=fdjtID("CODEXLIVEGLOSS");
        if (!(glossdiv)) return;
        var form=getChild(glossdiv,"FORM");
        var gloss_cloud=Codex.glossCloud();
        var ch=evt.keyCode||evt.charCode;
        if ((fdjtString.isEmpty(content))&&(ch===13)) {
            if (gloss_cloud.selection) 
                Codex.addTag2Form(form,gloss_cloud.selection);
            else Codex.setGlossMode("editnote");
            return;}
        else if ((ch===13)&&(gloss_cloud.selection)) {
            Codex.addTag2Form(form,gloss_cloud.selection);
            gloss_cloud.complete("");
            target.value="";}
        else if (ch===13) {
            var completions=gloss_cloud.complete(content);
            if ((content.indexOf('|')>=0)||
                (content.indexOf('@')>=0)||
                (completions.length===0)||
                (evt.shiftKey))
                Codex.addTag2Form(form,content);
            else {
                if (completions.length)
                    Codex.addTag2Form(form,completions[0]);
                else Codex.addTag2Form(form,content);}
            fdjtUI.cancel(evt);
            target.value="";
            gloss_cloud.complete("");}
        else if (ch===9) { /* tab */
            var completions=gloss_cloud.complete(content);
            fdjtUI.cancel(evt);
            if ((gloss_cloud.prefix)&&
                (gloss_cloud.prefix!==content)) {
                target.value=gloss_cloud.prefix;
                fdjtDOM.cancel(evt);
                setTimeout(function(){
                    Codex.UI.updateScroller("CODEXGLOSSTAGS");},
                           100);
                return;}
            else if (evt.shiftKey) gloss_cloud.selectPrevious();
            else gloss_cloud.selectNext();}
        else setTimeout(function(evt){
            gloss_cloud.complete(target.value);},
                        100);}

    function addlink_action(evt){
        var linkinput=fdjtID("CODEXATTACHURL");
        var titleinput=fdjtID("CODEXATTACHTITLE");
        var livegloss=fdjtID("CODEXLIVEGLOSS");
        if (!(livegloss)) return;
        var form=getChild(livegloss,"FORM");
        Codex.addLink2Form(form,linkinput.value,titleinput.value);
        linkinput.value="";
        titleinput.value="";
        Codex.setGlossMode("editnote");}
    function addlink_submit(evt){
        fdjtUI.cancel(evt);
        var linkinput=fdjtID("CODEXATTACHURL");
        var titleinput=fdjtID("CODEXATTACHTITLE");
        var livegloss=fdjtID("CODEXLIVEGLOSS");
        if (!(livegloss)) return;
        var form=getChild(livegloss,"FORM");
        Codex.addLink2Form(form,linkinput.value,titleinput.value);
        linkinput.value="";
        titleinput.value="";
        Codex.setGlossMode("editnote");}
    function addlink_cancel(evt){
        var linkinput=fdjtID("CODEXATTACHURL");
        var titleinput=fdjtID("CODEXATTACHTITLE");
        var livegloss=fdjtID("CODEXLIVEGLOSS");
        if (!(livegloss)) return;
        linkinput.value="";
        titleinput.value="";
        Codex.setGlossMode("editnote");}
    function addlink_keydown(evt){
        evt=evt||event;
        var ch=evt.keyCode||evt.charCode;
        if (ch!==13) return;
        fdjtUI.cancel(evt);
        var linkinput=fdjtID("CODEXATTACHURL");
        var titleinput=fdjtID("CODEXATTACHTITLE");
        var livegloss=fdjtID("CODEXLIVEGLOSS");
        if (!(livegloss)) return;
        var form=getChild(livegloss,"FORM");
        Codex.addLink2Form(form,linkinput.value,titleinput.value);
        linkinput.value="";
        titleinput.value="";
        Codex.setGlossMode("editnote");}

    /* HUD button handling */

    var mode_hud_map={
        "toc": "CODEXTOC",
        "searching": "CODEXSEARCH",
        "allglosses": "CODEXSOURCES"};
    
    function hudbutton(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var mode=target.getAttribute("hudmode");
        if ((Codex.Trace.gestures)&&
            ((evt.type==='tap')||
             (evt.type==='click')||
             (evt.type==='touchend')||
             (evt.type==='release')||
             (Codex.Trace.gestures>1)))
            fdjtLog("hudbutton() %o mode=%o cl=%o scan=%o sbh=%o mode=%o",
                    evt,mode,(isClickable(target)),
                    Codex.scanning,Codex.hudup,Codex.setMode());
        if (reticle.live) reticle.flash();
        fdjtUI.cancel(evt);
        if (!(mode)) return;
        var hudid=((mode)&&(mode_hud_map[mode]));
        var hud=fdjtID(hudid);
        if ((evt.type==='click')||(evt.type==='tap')||
            (evt.type==='touchend')||(evt.type==='release')) {
            if (hud) dropClass(hud,"hover");
            if ((Codex.scanning)&&(!(Codex.hudup))) {
                if (mode==="search") {
                    Codex.setMode("searchresults"); return;}
                else if (mode==="allglosses") {
                    Codex.setMode("allglosses"); return;}}
            if (fdjtDOM.hasClass(Codex.HUD,mode)) Codex.setMode(false);
            else Codex.setMode(mode);}
        else if ((evt.type==='mouseover')&&(Codex.mode))
            return;
        else {
            if (!(hud)) {}
            else if (evt.type==='mouseover')
                addClass(hud,"hover");
            else if (evt.type==='mouseout')
                dropClass(hud,"hover");
            else {}}}
    Codex.UI.hudbutton=hudbutton;

    Codex.UI.dropHUD=function(evt){
        var target=fdjtUI.T(evt);
        if (isClickable(target)) {
            if (Codex.Trace.gestures)
                fdjtLog("Clickable: don't dropHUD %o",evt);
            return;}
        if (Codex.Trace.gestures) fdjtLog("dropHUD %o",evt);
        fdjtUI.cancel(evt); Codex.setMode(false);};

    /* Gesture state */

    var touch_started=false; var touch_ref=false;
    var page_x=-1; var page_y=-1; var sample_t=-1;
    var touch_moves=0;
    var touch_held=false;
    var touch_moved=false;
    var touch_scrolled=false;
    var n_touches=0;

    /* Touch handling */

    var touch_moves=0, touch_moved=false;
    var touch_x, touch_y, n_touches=0;
    var start_x, start_y;

    function content_touchstart(evt){
        touch_moves=0; touch_moved=false;
        var touches=evt.touches;
        var touch=(((touches)&&(touches.length))?(touches[0]):(evt));
        touch_x=start_x=touch.screenX;
        touch_y=start_y=touch.screenY;
        if ((touches)&&(touches.length)) n_touches=touches.length;
        if (Codex.Trace.gestures>1) tracetouch("touchstart",evt);
        gesture_start=fdjtTime();
        touch_moved=false;
        if (n_touches===1) content_mousedown(evt);
        return;}

    function content_touchmove(evt){
        fdjtUI.cancel(evt);
        touch_moves++; touch_moved=true;
        var touches=evt.touches;
        var touch=(((touches)&&(touches.length))?(touches[0]):(evt));
        touch_x=touch.screenX;
        touch_y=touch.screenY;
        if ((touches)&&(touches.length)&&
            (touches.length>n_touches))
            n_touches=touches.length;
        if (Codex.Trace.gestures>2) tracetouch("touchmove",evt);
        return;}
    
    function content_touchend(evt){
        var target=fdjtUI.T(evt);
        if (isClickable(target)) return;
        // Identify swipes
        if (touch_moved) {
            var dx=touch_x-start_x; var dy=touch_y-start_y;
            var adx=((dx<0)?(-dx):(dx)); var ady=((dy<0)?(-dy):(dy));
            var ad=((adx<ady)?(ady-adx):(adx-ady));
            if (Codex.Trace.gestures)
                fdjtLog("touchend/gesture l=%o,%o s=%o,%o d=%o,%o |d|=%o,%o",
                        last_x,last_y,start_x,start_y,dx,dy,adx,ady);
            if (adx>(ady*3)) { /* horizontal */
                fdjtUI.cancel(evt);
                if (n_touches===1) {
                    if (dx<0) Codex.Forward(evt);
                    else Codex.Backward(evt);}
                else {
                    if (dx<0) Codex.scanForward(evt);
                    else Codex.scanBackward(evt);}}
            else content_mouseup(evt);
            return;}
        else content_mouseup(evt);}

    /* Tracing touch */
    
    function tracetouch(handler,evt){
        evt=evt||event;
        var touches=evt.touches;
        var touch=(((touches)&&(touches.length))?(touches[0]):(evt));
        var target=fdjtUI.T(evt); var ref=Codex.getRef(target);
        if (touch_started)
            fdjtLog("%s(%o) n=%o %sts=%o %s@%o\n\t+%o %s%s%s%s%s%s%s s=%o,%o l=%o,%o p=%o,%o d=%o,%o ref=%o tm=%o",
                    handler,evt,((touches)&&(touches.length)),
                    ((!(touch))?(""):
                     ("c="+touch.clientX+","+touch.clientY+";s="+touch.screenX+","+touch.screenY+" ")),
                    touch_started,evt.type,target,
                    fdjtTime()-touch_started,
                    ((Codex.mode)?(Codex.mode+" "):""),
                    ((Codex.scanning)?"scanning ":""),
                    ((touch_held)?("held "):("")),
                    ((touch_moved)?("moved "):("")),
                    ((touch_scrolled)?("scrolled "):("")),
                    ((isClickable(target))?("clickable "):("")),
                    ((touch)?"":"notouch "),
                    start_x,start_y,last_x,last_y,page_x,page_y,
                    (((touch)&&(touch.screenX))?(touch.screenX-page_x):0),
                    (((touch)&&(touch.screenY))?(touch.screenY-page_y):0),
                    touch_ref,touch_moves);
        else fdjtLog("%s(%o) n=%o %s%s c=%o,%o p=%o,%o ts=%o %s@%o ref=%o",
                     handler,evt,((touches)&&(touches.length)),
                     ((Codex.mode)?(Codex.mode+" "):""),
                     ((Codex.scanning)?"scanning ":""),
                     touch.clientX,touch.clientY,touch.screenX,touch.screenY,
                     touch_started,evt.type,target,ref);
        if (ref) fdjtLog("%s(%o) ref=%o from %o",handler,evt,ref,target);}


    /* HUD touch */

    function hud_touchmove(evt){
        var target=fdjtUI.T(evt);
        if (isClickable(target)) return;
        fdjtUI.cancel(evt);
        touch_moves++;
        var touch=
            (((evt.touches)&&(evt.touches.length))?(evt.touches[0]):(evt));
        var dx=touch.screenX-page_x; var dy=touch.screenY-page_y;
        var adx=((dx<0)?(-dx):(dx)); var ady=((dy<0)?(-dy):(dy));
        if (page_x<0) page_x=touch.screenX;
        if (page_y<0) page_y=touch.screenY;
        if (Codex.Trace.gestures>1) tracetouch("hud_touchmove",evt);
        last_x=touch.clientX; last_y=touch.clientY;
        touch_moved=true;
        page_x=touch.screenX; page_y=touch.screenY;
        touch_scrolled=true;}

    function hud_touchend(evt){
        if (Codex.Trace.gestures) tracetouch("hud_touchend",evt);
        var target=fdjtUI.T(evt);
        var scroller=((Codex.scrolling)&&(Codex.scrollers)&&
                      (Codex.scrollers[Codex.scrolling]));
        if ((scroller)&&(scroller.motion)&&(scroller.motion>10)) return;
        else if (isClickable(target)) {
            if (Codex.ui==="faketouch") {
                // This happens automatically when faking touch
                fdjtUI.cancel(evt);
                return;}
            else {
                var click_evt = document.createEvent("MouseEvents");
                while (target)
                    if (target.nodeType===1) break;
                else target=target.parentNode;
                if (!(target)) return;
                if (Codex.Trace.gestures)
                    fdjtLog("Synthesizing click on %o",target);
                click_evt.initMouseEvent("click", true, true, window,
                                         1,page_x,page_y,last_x, last_y,
                                         false, false, false, false, 0, null);
                fdjtUI.cancel(evt);
                target.dispatchEvent(click_evt);
                return;}}
        else return hud_tapped(evt);}

    /* Default click/tap */
    function default_tap(evt){
        var target=fdjtUI.T(evt);
        if (((Codex.hudup)||(Codex.mode))&&
            (!(getParent(target,Codex.HUD))))
            Codex.setMode(false);}

    /* Glossmarks */
    
    function glossmark_tapped(evt){
        evt=evt||event||null;
        if (held) clear_hold("glossmark_tapped");
        var target=fdjtUI.T(evt);
        var glossmark=getParent(target,".codexglossmark");
        var passage=getTarget(glossmark.parentNode,true);
        if (Codex.Trace.gestures)
            fdjtLog("glossmark_tapped (%o) on %o gmark=%o passage=%o mode=%o target=%o",
                    evt,target,glossmark,passage,Codex.mode,Codex.target);
        if (!(glossmark)) return false;
        fdjtUI.cancel(evt);
        if ((Codex.mode==='glosses')&&(Codex.target===passage)) {
            Codex.setMode(false);
            return;}
        else Codex.showGlosses(passage);}

    var glossmark_animated=false;
    var glossmark_image=false;
    function animate_glossmark(target,enable){
        if (glossmark_animated) {
            clearInterval(glossmark_animated);
            glossmark_animated=false;
            if (glossmark_image)
                fdjtUI.ImageSwap.reset(glossmark_image);}
        if ((target)&&(enable)) {
            var glossmark=((hasClass(target,"codexglossmark"))?(target):
                           (getParent(target,".codexglossmark")));
            if (!(glossmark)) return;
            var bigimage=fdjtDOM.getChild(glossmark,"img.big");
            if (!(bigimage)) return;
            glossmark_image=bigimage;
            glossmark_animated=fdjtUI.ImageSwap(bigimage,750);}}

    function glossmark_hoverstart(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (!(fdjtDOM.getParent(target,".codextarget")))
            animate_glossmark(target,true);}

    function glossmark_hoverdone(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (!(fdjtDOM.getParent(target,".codextarget")))
            animate_glossmark(target,false);}

    function setTargetUI(target){
        if (target) {
            var glossmark=fdjtDOM.getChild(target,".codexglossmark");
            if (glossmark) animate_glossmark(glossmark,true);
            else animate_glossmark(false,false);}
        else animate_glossmark(false,false);}
    Codex.UI.setTarget=setTargetUI;

    /* Various actions */

    function clearOfflineAction(evt){
        evt=evt||event;
        fdjtUI.cancel(evt);
        Codex.clearOffline(Codex.refuri);
        fdjtUI.alertFor(5,"Cleared locally stored glosses and other information");
        return false;}
    Codex.UI.clearOfflineAction=clearOfflineAction;

    function forceSyncAction(evt){
        evt=evt||event;
        fdjtUI.cancel(evt);
        Codex.forceSync();
        if (!(navigator.onLine))
            fdjtUI.alertFor(
                15,"You're currently offline; information will be synchronized when you're back online");
        else if (!(Codex.connected))
            fdjtUI.alertFor(
                15,"You're not currently logged into sBooks.  Information will be synchronized when you've logged in.");
        else fdjtUI.alertFor(7,"Sychronizing gloses, etc with the remote server");
        return false;}
    Codex.UI.forceSyncAction=forceSyncAction;


    /* Moving forward and backward */

    var last_motion=false;

    function Forward(evt){
        var now=fdjtTime();
        if (!(evt)) evt=event||false;
        if (evt) fdjtUI.cancel(evt);
        if ((last_motion)&&((now-last_motion)<100)) return;
        else last_motion=now;
        if (Codex.Trace.nav)
            fdjtLog("Forward e=%o h=%o t=%o",evt,Codex.head,Codex.target);
        /* 
        if ((Codex.mode==="glosses")||(Codex.mode==="addgloss"))
        Codex.setMode(true); else */
        Codex.setMode(false);
        if (((evt)&&(evt.shiftKey))||(n_touches>1))
            scanForward();
        else pageForward();}
    Codex.Forward=Forward;
    function right_margin(evt){
        if (Codex.Trace.gestures) tracetouch("right_margin",evt);
        if (Codex.hudup) Codex.setMode(false);
        else Forward(evt);}

    function Backward(evt){
        var now=fdjtTime();
        if (!(evt)) evt=event||false;
        if (evt) fdjtUI.cancel(evt);
        if ((last_motion)&&((now-last_motion)<100)) return;
        else last_motion=now;
        /* if ((Codex.mode==="glosses")||(Codex.mode==="addgloss"))
           Codex.setMode(true); else */
        Codex.setMode(false);
        if (Codex.Trace.nav)
            fdjtLog("Backward e=%o h=%o t=%o",evt,Codex.head,Codex.target);
        if (((evt)&&(evt.shiftKey))||(n_touches>1))
            scanBackward();
        else pageBackward();}
    Codex.Backward=Backward;
    function left_margin(evt){
        if (Codex.Trace.gestures) tracetouch("left_margin",evt);
        if (Codex.hudup) Codex.setMode(false);
        else Backward(evt);}


    function pageForward(){
        if (Codex.Trace.gestures)
            fdjtLog("pageForward c=%o n=%o",Codex.curpage,Codex.pagecount);
        if ((Codex.mode==="scanning")||(Codex.mode==="tocscan"))
            Codex.setMode(false);
        if ((Codex.bypage)&&(Codex.pagecount)) {
            var newpage=false;
            if (Codex.mode==="glosses") Codex.setMode(true);
            if (Codex.curpage===Codex.pagecount) {}
            else Codex.GoToPage(newpage=Codex.curpage+1,"pageForward",true);}
        else {
            var delta=fdjtDOM.viewHeight()-50;
            if (delta<0) delta=fdjtDOM.viewHeight();
            var newy=fdjtDOM.viewTop()+delta;
            window.scrollTo(fdjtDOM.viewLeft(),newy);}}
    Codex.pageForward=pageForward;

    function pageBackward(){
        if (Codex.Trace.gestures)
            fdjtLog("pageBackward c=%o n=%o",Codex.curpage,Codex.pagecount);
        if ((Codex.mode==="scanning")||(Codex.mode==="tocscan"))
            Codex.setMode(false);
        if ((Codex.bypage)&&(Codex.pagecount)) {
            var newpage=false;
            if (Codex.mode==="glosses") Codex.setMode(true);
            if (Codex.curpage===0) {}
            else {
                Codex.GoToPage(newpage=Codex.curpage-1,"pageBackward",true);}}
        else {
            var delta=fdjtDOM.viewHeight()-50;
            if (delta<0) delta=fdjtDOM.viewHeight();
            var newy=fdjtDOM.viewTop()-delta;
            window.scrollTo(fdjtDOM.viewLeft(),newy);}}
    Codex.pageBackward=pageBackward;

    function scanForward(){
        if (Codex.mode==="scanning") {}
        else if (Codex.mode==="tocscan") {}
        else if (Codex.mode==="glosses") {
            var ids=Codex.docinfo._ids;
            var id=((Codex.target)&&(Codex.target.id));
            var glosses=Codex.glosses;
            var i, lim=ids.length;
            if ((id)&&((i=fdjtKB.position(ids,id))>0)) {
                i++; while (i<lim) {
                    var g=glosses.index(false,'frag',ids[i]);
                    if ((g)&&(g.length)) {
                        var passage=fdjtID(ids[i]);
                        Codex.GoTo(passage,"scanForward/glosses",true);
                        Codex.showGlosses(passage);
                        return;}
                    else i++;}}
            Codex.setMode(false);
            return;}
        else if (Codex.scanning) Codex.setMode("scanning");
        else Codex.setMode("tocscan");
        if (Codex.mode==="tocscan") {
            var head=Codex.head;
            var headid=head.codexbaseid||head.id;
            var headinfo=Codex.docinfo[headid];
            if (Codex.Trace.nav) 
                fdjtLog("scanForward/toc() head=%o info=%o n=%o h=%o",
                        head,headinfo,headinfo.next,headinfo.head);
            if (headinfo.next) Codex.GoTo(headinfo.next.elt,"scanForward");
            else if ((headinfo.head)&&(headinfo.head.next)) {
                Codex.GoTo(headinfo.head.next.elt,"scanForward");
                Codex.setMode("toc");}
            else if ((headinfo.head)&&(headinfo.head.head)&&
                     (headinfo.head.head.next)) 
                Codex.GoTo(headinfo.head.head.next.elt,"scanForward");
            else Codex.setMode(false);
            return;}
        if ((Codex.scanpoints)&&
            ((Codex.scanoff+1)<Codex.scanpoints.length)) {
            Codex.scanoff++;
            Codex.GoTo(Codex.scanpoints[Codex.scanoff]);
            return;}
        var start=Codex.scanning;
        var scan=Codex.nextSlice(start);
        var ref=((scan)&&(Codex.getRef(scan)));
        if (Codex.Trace.nav) 
            fdjtLog("scanForward() from %o/%o to %o/%o under %o",
                    start,Codex.getRef(start),scan,ref,Codex.scanning);
        if ((ref)&&(scan)) Codex.Scan(ref,scan);
        return scan;}
    Codex.scanForward=scanForward;

    function scanBackward(){
        if (Codex.mode==="scanning") {}
        else if (Codex.mode==="tocscan") {}
        else if (Codex.mode==="glosses") {
            var ids=Codex.docinfo._ids;
            var id=((Codex.target)&&(Codex.target.id));
            var glosses=Codex.glosses;
            var i, lim=ids.length;
            if ((id)&&((i=fdjtKB.position(ids,id))>0)) {
                i--; while (i>=0) {
                    var g=glosses.index(false,'frag',ids[i]);
                    if ((g)&&(g.length)) {
                        var passage=fdjtID(ids[i]);
                        Codex.GoTo(passage,"scanBackward/glosses",true);
                        Codex.showGlosses(passage);
                        return;}
                    else i--;}}
            Codex.setMode(false);
            return;}
        else if (Codex.scanning) Codex.setMode("scanning");
        else Codex.setMode("tocscan");
        if (Codex.mode==="tocscan") {
            var head=Codex.head;
            var headid=head.codexbaseid||head.id;
            var headinfo=Codex.docinfo[headid];
            if (Codex.Trace.nav) 
                fdjtLog("scanBackward/toc() head=%o info=%o p=%o h=%o",
                        head,headinfo,headinfo.prev,headinfo.head);
            if (headinfo.prev) Codex.GoTo(headinfo.prev.elt,"scanBackward");
            else if (headinfo.head) 
                Codex.GoTo(headinfo.head.elt,"scanBackward");
            else Codex.setMode(false);
            return;}
        if ((Codex.scanpoints)&&(Codex.scanoff>0)) {
            Codex.scanoff--;
            Codex.GoTo(Codex.scanpoints[Codex.scanoff]);
            return;}
        var scan=Codex.prevSlice(Codex.scanning);
        var ref=((scan)&&(Codex.getRef(scan)));
        if (Codex.Trace.nav) 
            fdjtLog("scanBackward() from %o/%o to %o/%o under %o",
                    start,Codex.getRef(start),scan,ref,Codex.scanning);
        if ((ref)&&(scan)) Codex.Scan(ref,scan,true);
        return scan;}
    Codex.scanBackward=scanBackward;

    function scanner_tapped(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (isClickable(target)) return;
        if (hasParent(target,fdjt.ID("CODEXEXPANDSCANNER"))) return;
        if ((getParent(target,".tool"))) {
            var card=getCard(target);
            if ((card)&&((card.name)||(card.getAttribute("name")))) {
                var name=(card.name)||(card.getAttribute("name"));
                var gloss=fdjtKB.ref(name,Codex.glosses);
                if (!(gloss)) return;
                var form=Codex.setGlossTarget(gloss);
                if (!(form)) return;
                Codex.setMode("addgloss");
                return;}
            else return;}
        if ((hasClass(target,"ellipsis"))||
            (getParent(target,".ellipsis"))) {
            var ellipsis=getParent(target,".ellipsis");
            if (ellipsis) {
                if (hasClass(ellipsis,"expanded")) {
                    dropClass(ellipsis,"expanded");}
                else {
                    addClass(ellipsis,"expanded");
                    fdjtDOM.addClass("CODEXSCANNER","expanded");}
                fdjtUI.cancel(evt);
                return;}}
        // Tapping the tochead returns to results/glosses/etc
        var scanning=Codex.scanning;
        if (!(scanning)) return;
        if (getParent(scanning,fdjtID("CODEXALLGLOSSES"))) {
            Codex.setMode("allglosses");
            fdjtUI.cancel(evt);}
        else if (getParent(scanning,fdjtID("CODEXSEARCHRESULTS"))) {
            Codex.setMode("searchresults");
            fdjtUI.cancel(evt);}
        else {}
        return;}

    /* Entering page numbers and locations */

    function enterPageNum(evt) {
        evt=evt||event;
        if ((Codex.hudup)||(Codex.mode)||(Codex.cxthelp)) {
            fdjtUI.cancel(evt);
            Codex.setMode(false);
            return;}
        fdjtUI.cancel(evt);
        if (Codex.hudup) {Codex.setMode(false); return;}
        Codex.setMode.toggle("gotopage");}
    function enterLocation(evt) {
        evt=evt||event;
        if ((Codex.hudup)||(Codex.mode)||(Codex.cxthelp)) {
            fdjtUI.cancel(evt);
            Codex.setMode(false);
            return;}
        fdjtUI.cancel(evt);
        if (Codex.hudup) {Codex.setMode(false); return;}
        Codex.setMode.toggle("gotoloc");}
    
    /* Other handlers */

    function flyleaf_tap(evt){
        if (isClickable(evt)) return;
        else Codex.setMode(false);}

    function getOffX(evt){
        evt=evt||event;
        var pinfo=fdjtID("CODEXPAGEINFO");
        if (evt.clientX) 
            return evt.clientX-pinfo.offsetLeft;
        var touches=((evt.changedTouches)&&(evt.changedTouches.length)&&
                     (evt.changedTouches))||
            ((evt.touches)&&(evt.touches.length)&&(evt.touches));
        if (touches) return touches[0].screenX-pinfo.offsetLeft; 
        else return false;}

    var hasParent=fdjtDOM.hasParent;

    function head_tap(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (Codex.Trace.gestures) fdjtLog("head_tap %o t=%o",evt,target);
        if (!((target===Codex.DOM.head)||
              (target===Codex.DOM.tabs)))
            return;
        else if (Codex.mode) {
            fdjtUI.cancel(evt);
            Codex.setMode(false);}
        else if (fdjtDOM.hasClass(document.body,"codexhelp")) {
            fdjtUI.cancel(evt);
            fdjtDOM.dropClass(document.body,"codexhelp");}
        else if (Codex.hudup) {
            fdjtUI.cancel(evt);
            Codex.setMode(false);}
        else {
            fdjtUI.cancel(evt);
            Codex.setMode(true);}}
    function foot_tap(evt){
        if (Codex.Trace.gestures) fdjtLog("foot_tap %o",evt);
        if (isClickable(evt)) return;
        else if ((Codex.hudup)||(Codex.mode)||(Codex.cxthelp)) {
            fdjtUI.cancel(evt);
            Codex.setMode(false);
            return;}}


    var previewing_page=false;
    function pageinfo_hold(evt){
        var pageinfo=fdjtID("CODEXPAGEINFO");
        if (preview_timer) {
            clearTimeout(preview_timer);
            preview_timer=false;}
        if ((Codex.hudup)||(Codex.mode)) {
            fdjtUI.cancel(evt);
            Codex.setMode(false);
            return;}
        var target=fdjtUI.T(evt);
        if (target.nodeType===3) target=target.parentNode;
        if (((hasParent(target,pageinfo))&&(target.tagName==="span")))
            return;
        var gopage=parseInt(target.innerHTML);
        if (previewing_page===gopage) return;
        if ((Codex.Trace.gestures)||(hasClass(pageinfo,"codextrace")))
            fdjtLog("pageinfo_span_hold %o t=%o gopage: %o=>%o/%o",
                    evt,target,previewing_page,gopage,Codex.pagecount);
        previewing_page=gopage;
        pageinfo.title=
            fdjtString("Release to return to page %d",Codex.curpage);
        Codex.startPreview(gopage,"pageinfo_span_hold");}
    function pageinfo_tap(evt){
        var pageinfo=fdjtID("CODEXPAGEINFO");
        if (preview_timer) {
            clearTimeout(preview_timer);
            preview_timer=false;}
        if ((Codex.hudup)||(Codex.mode)||(Codex.cxthelp)) {
            fdjtUI.cancel(evt);
            Codex.setMode(false);
            return;}
        var target=fdjtUI.T(evt);
        if (target.nodeType===3) target=target.parentNode;
        if (((hasParent(target,pageinfo))&&(target.tagName==="span")))
            return;
        var gopage=parseInt(target.innerHTML);
        if (previewing_page===gopage) return;
        Codex.GoToPage(gopage,"pageinfo_tap",true);
        Codex.setMode(false);}
    function pageinfo_slip(evt){
        preview_timer=setTimeout(function(){
            var pageinfo=fdjtID("CODEXPAGEINFO");
            pageinfo.title=""; preview_timer=false;
            Codex.stopPagePreview("pageinfo_slip");},
                                 400);}
    
    /* Gloss form handlers */

    /**** Clicking on outlets *****/
    
    function glossform_outlets_tapped(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (getParent(target,".checkspan"))
            return fdjt.UI.CheckSpan.onclick(evt);
        else if (getParent(target,".sharing"))
            toggleClass(getParent(target,".sharing"),"expanded");
        else {}}
    Codex.UI.outlets_tapped=glossform_outlets_tapped;

    function outlet_tapped(evt){
        var target=fdjtUI.T(evt);
        var outletspan=fdjtDOM.getParent(target,'.outlet');
        if (!(outletspan)) return;
        var live=fdjtID("CODEXLIVEGLOSS");
        var form=((live)&&(fdjtDOM.getChild(live,"form")));
        var outlet=outletspan.value;
        Codex.addOutlet2Form(form,outlet);
        fdjtUI.cancel(evt);}

    var glossmodes=Codex.glossmodes;

    function glossmode_button(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var alt=target.alt;
        
        var form=fdjtDOM.getParent(target,'form');
        if (!(alt)) return;
        if (alt==="tag") {
            altclass="addtag";
            input=fdjtID("CODEXTAGINPUT");}
        else if (alt==="link") {
            altclass="addlink";
            input=fdjtID("CODEXATTACHURL");}
        else if (alt==="excerpt") {
            altclass="excerpt";
            input=fdjtDOM.getInput(form,'EXCERPT');}
        else if (alt==="note") {
            altclass="editnote";
            input=fdjtDOM.getInput(form,'NOTE');}
        else if (alt==="sharing") {
            altclass="sharing";
            input=fdjtID("CODEXOUTLETINPUT");}
        else return;
        // fdjtLog("glossmode_button gm=%s input=%o",altclass,input);
        fdjtUI.cancel(evt);
        if (!(hasClass(form,altclass))) {
            if (alt==="tag") {
                addClass("CODEXHEART","tagging");
                Codex.UI.updateScroller("CODEXGLOSSTAGS");}
            else dropClass("CODEXHEART","tagging");
            if (alt==="sharing") {
                addClass("CODEXHEART","showoutlets");
                Codex.UI.updateScroller("CODEXGLOSSOUTLETS");}
            else dropClass("CODEXHEART","showoutlets");
            if (alt==="link") 
                addClass("CODEXHEART","addlink");
            else dropClass("CODEXHEART","addlink");
            swapClass(form,glossmodes,altclass);
            Codex.setHUD(true);
            Codex.setFocus(input);}
        else {
            dropClass("CODEXHEART","tagging");
            dropClass("CODEXHEART","showoutlets");
            dropClass("CODEXHEART","addlink");
            dropClass(form,glossmodes);}}

    function submitGloss(evt){
        fdjtUI.cancel(evt);
        return fdjtUI.submitEvent(evt);}

    /* Changing gloss networks */

    function changeGlossNetwork(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var alternate=((fdjtDOM.hasParent(target,".codexglossform"))?
                       ("CODEXNETWORKBUTTONS"):(("CODEXLIVEGLOSS")));
        var doppels=fdjtDOM.getInputsFor(alternate,'NETWORKS',target.value);
        fdjtUI.CheckSpan.set(doppels,target.checked);}
    Codex.UI.changeGlossNetwork=changeGlossNetwork;

    function changeGlossPosting(evt){
        var target=fdjtUI.T(evt=(evt||event));
        var glossdiv=fdjtDOM.getParent(target,".codexglossform");
        if (target.checked) fdjtDOM.addClass(glossdiv,"posted");
        else fdjtDOM.dropClass(glossdiv,"posted");}
    Codex.UI.changeGlossPosting=changeGlossPosting;

    function changeGlossPrivacy(evt){
        var target=fdjtUI.T(evt=(evt||event));
        var glossdiv=fdjtDOM.getParent(target,".codexglossform");
        var postgloss=fdjtDOM.getChild(glossdiv,".postgloss");
        var postinput=(postgloss)&&(fdjtDOM.getInput(postgloss,"POSTGLOSS"));
        if (postgloss) {
            if (target.checked) {
                if (postinput) postinput.disabled=true;}
            else {
                if (postinput) postinput.disabled=false;}}
        if (target.checked) fdjtDOM.addClass(glossdiv,"private");
        else fdjtDOM.dropClass(glossdiv,"private");}
    Codex.UI.changeGlossPrivacy=changeGlossPrivacy;

    /* Back to the text */

    function back_to_reading(evt){
        evt=evt||event;
        fdjtUI.cancel(evt);
        Codex.setMode(false);
        fdjtDOM.dropClass(document.body,"codexhelp");}

    function scanner_expand_hold(evt){
        fdjtDOM.addClass("CODEXSCANNER","expanded");}
    function scanner_expand_tap(evt){
        fdjtDOM.toggleClass("CODEXSCANNER","expanded");}
    function scanner_expand_release(evt){
        fdjtDOM.dropClass("CODEXSCANNER","expanded");}

    /* Tracking text input */

    function codexfocus(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var input=getParent(target,'textarea');
        if (!(input)) input=getParent(target,'input');
        if ((!(input))||(typeof input.type !== "string")||
            (input.type.search(fdjtDOM.text_types)!==0))
            return;
        Codex.textinput=input;
        if (Codex.touch) Codex.dont_resize=true;}
    function codexblur(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var input=getParent(target,'textarea');
        if (!(input)) input=getParent(target,'input');
        if ((!(input))||(typeof input.type !== "string")||
            (input.type.search(fdjtDOM.text_types)!==0))
            return;
        if ((input)&&(input===Codex.textinput)) {
            Codex.textinput=false;
            if (Codex.touch) Codex.dont_resize=false;}}

    /* Rules */

    var noBubble=fdjtUI.noBubble;
    var cancel=fdjtUI.cancel;

    function hideSplash(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        if (fdjtUI.isClickable(target)) return;
        else Codex.setMode(false);}

    function hideSplashToggle(evt) {
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var newval=(!(Codex.hidesplash));
        var input=getParent(target,"input");
        if (input)
            setTimeout(function(){
                Codex.setConfig("hidesplash",input.checked);
                Codex.saveConfig();},
                       100);
        else {
            Codex.setConfig("hidesplash",newval);
            Codex.saveConfig();}
        if ((newval)&&(Codex._setup)&&
            ((fdjtTime()-(Codex._setup.getTime()))<30000))
            Codex.setMode(false);}

    function toggleHelp(evt){
        evt=evt||event;
        fdjtUI.cancel(evt);
        if (Codex.cxthelp) {
            fdjtDOM.dropClass(document.body,"codexhelp");
            Codex.cxthelp=false;}
        else {
            fdjtDOM.addClass(document.body,"codexhelp");
            Codex.cxthelp=true;}
        return false;}
    Codex.toggleHelp=toggleHelp;

    function editglossnote(evt){
        evt=evt||event;
        setGlossMode("editnote");
        fdjtUI.cancel(evt);}

    Codex.UI.handlers.mouse=
        {window: {
            keyup: onkeyup,
            keydown: onkeydown,
            keypress: onkeypress,
            click: default_tap,
            focus: codexfocus,
            blur: codexblur},
         content: {mousedown: content_mousedown,
                   mouseup: content_mouseup,
                   click: content_click},
         toc: {tap: toc_tapped,hold: toc_held,
               release: toc_released, slip: toc_slipped,
               mouseover: fdjtUI.CoHi.onmouseover,
               mouseout: fdjtUI.CoHi.onmouseout,
               click: cancel},
         glossmark: {mouseup: glossmark_tapped,
		     click: cancel, mousedown: cancel,
                     mouseover: glossmark_hoverstart,
                     mouseout: glossmark_hoverdone},
         glossbutton: {mouseup: glossbutton_ontap,mousedown: cancel},
         summary: {tap: slice_tapped, hold: slice_held,
                   release: slice_released},
         "#CODEXSTARTPAGE": {click: Codex.UI.dropHUD},
         "#CODEXHUDHELP": {click: Codex.UI.dropHUD},
         ".helphud": {click: Codex.UI.dropHUD},
         ".codexheart": {tap: flyleaf_tap},
         "#CODEXPAGEINFO": {tap: pageinfo_tap,
                            hold: pageinfo_hold,
                            release: pageinfo_slip,
                            slip: pageinfo_slip},
         "#CODEXPAGENOTEXT": {tap: enterPageNum},
         "#CODEXLOCOFF": {tap: enterLocation},
         // Return to scan
         "#CODEXSCANNER": {click: scanner_tapped},
         // Expanding/contracting the scanner
         "#CODEXEXPANDSCANNER": {
             tap: scanner_expand_tap,
             hold: scanner_expand_hold,
             release: scanner_expand_release},
         // Raise and lower HUD
         "#CODEXPAGEHEAD": {click: head_tap},
         "#CODEXTABS": {click: head_tap},
         "#CODEXHEAD": {click: head_tap},
         "#CODEXPAGEFOOT": {tap: foot_tap},
         // Forward and backwards
         "#CODEXPAGELEFT": {click: left_margin},
         "#CODEXPAGERIGHT": {click: right_margin},
         "#HIDESPLASHCHECKSPAN" : {click: hideSplashToggle},
         "#CODEXTAGINPUT": {keydown: addtag_keydown},
         "#CODEXOUTLETINPUT": {keydown: addoutlet_keydown},
         "#CODEXATTACHFORM": {submit: addlink_submit},
         "#CODEXATTACHURL": {click: addlink_keydown},
         "#CODEXATTACHTITLE": {click: addlink_keydown},
         "#CODEXATTACHOK": {click: addlink_action},
         "#CODEXATTACHCANCEL": {click: addlink_cancel},
         "#CODEXOUTLETCLOUD": {tap: outlet_tapped},
         "#CODEXHELPBUTTON": {
             click: toggleHelp, mousedown: cancel,mouseup: cancel},
         "#CODEXHELP": {
             click: toggleHelp, mousedown: cancel,mouseup: cancel},
         "#CODEXSHOWTEXT": {click: back_to_reading},
         "#CODEXAPPSPLASH": {click: hideSplash},
         ".hudmodebutton": {click:hudbutton,mouseup:cancel,mousedown:cancel},
         // GLOSSFORM rules
         "span.codexglossdelete": { click: delete_ontap },
         "span.codexglossrespond": { click: respond_ontap },
         "span.codexsharegloss": {tap: fdjt.UI.CheckSpan.onclick},
         ".codexclosehud": {click: back_to_reading},
         ".glossexposure": {click: fdjt.UI.CheckSpan.onclick},
         ".submitbutton": {click: submitGloss },
         "div.glossetc": {click: fdjt.UI.CheckSpan.onclick},
         "div.glossetc div.sharing": {click: glossform_outlets_tapped},
         "div.glossetc span.modebuttons": {click: glossmode_button},
         "div.glossetc div.notetext": {click: editglossnote}};

    Codex.UI.handlers.webtouch=
        {window: {
            keyup: onkeyup,
            keydown: onkeydown,
            keypress: onkeypress,
            focus: codexfocus,
            blur: codexblur},
         content: {touchstart: content_touchstart,
                   touchmove: content_touchmove,
                   touchend: content_touchend},
         toc: {tap: toc_tapped,hold: toc_held,
               slip: toc_slipped, release: toc_released},
         glossmark: {touchstart: glossmark_tapped,
                     touchend: cancel},
         // glossbutton: {mouseup: glossbutton_ontap,mousedown: cancel},
         summary: {tap: slice_tapped,
                   hold: slice_held,
                   release: slice_released},
         "#CODEXSTARTPAGE": {click: Codex.UI.dropHUD},
         "#CODEXHUDHELP": {click: Codex.UI.dropHUD},
         ".helphud": {click: Codex.UI.dropHUD},
         "#CODEXPAGEFOOT": {},
         "#CODEXPAGEINFO": {tap: pageinfo_tap,
                            hold: pageinfo_hold,
                            release: pageinfo_slip,
                            slip: pageinfo_slip},
         "#CODEXPAGENOTEXT": {tap: enterPageNum},
         "#CODEXLOCOFF": {tap: enterLocation},
         // Return to scan
         "#CODEXSCANNER": {touchstart: scanner_tapped},
         // Expanding/contracting the scanner
         "#CODEXEXPANDSCANNER": {
             tap: scanner_expand_tap,
             hold: scanner_expand_hold,
             release: scanner_expand_release},
         // Raise and lower HUD
         "#CODEXPAGEHEAD": {touchstart: head_tap},
         "#CODEXTABS": {touchstart: head_tap},
         "#CODEXHEAD": {click: head_tap},
         "#CODEXFOOT": {tap: foot_tap},
         // Forward and backwards
         "#CODEXPAGELEFT": {touchstart: left_margin},
         "#CODEXPAGERIGHT": {touchstart: right_margin},
         "#CODEXTAGINPUT": {keydown: addtag_keydown},
         "#CODEXOUTLETINPUT": {keydown: addoutlet_keydown},
         "#CODEXATTACHFORM": {submit: addlink_submit},
         "#CODEXATTACHURL": {click: addlink_keydown},
         "#CODEXATTACHTITLE": {click: addlink_keydown},
         "#CODEXATTACHOK": {click: addlink_action},
         "#CODEXATTACHCANCEL": {click: addlink_cancel},
         "#CODEXOUTLETCLOUD": {tap: outlet_tapped},
         "#HIDESPLASHCHECKSPAN" : {tap: hideSplashToggle},
         "#CODEXHELPBUTTON": {click: toggleHelp},
         "#CODEXHELP": {click: toggleHelp},
         "#CODEXSHOWTEXT": {click: back_to_reading},
         "#CODEXAPPSPLASH": {click: hideSplash},
         /* ".hudbutton": {mouseover:hudbutton,mouseout:hudbutton}, */
         ".hudmodebutton": {click: hudbutton},
         // GLOSSFORM rules
         "span.codexglossdelete": { click: delete_ontap },
         "span.codexglossrespond": { click: respond_ontap },
         "span.codexsharegloss": {click: fdjt.UI.CheckSpan.onclick},
         ".codexclosehud": {click: back_to_reading},
         ".submitbutton": {click: submitGloss },
         ".glossexposure": {click: fdjt.UI.CheckSpan.onclick},
         "div.glossetc span.links": {click: fdjt.UI.CheckSpan.onclick},
         "div.glossetc span.tags": {click: fdjt.UI.CheckSpan.onclick},
         "div.glossetc div.sharing": {click: glossform_outlets_tapped},
         "div.glossetc span.modebuttons": {click: glossmode_button},
         "div.glossetc div.notetext": {click: editglossnote}};
    
})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/

/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/toc.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

/* New NAV hud design
   One big DIV for the whole TOC, use CSS to change what's visible
   General structure:
   div.codextoc.toc0
   div.head (contains section name)
   div.spanbar (contains spanbar)
   div.sub (contains all the subsections names)
   div.codextoc.toc1 (tree for first section)
   div.codextoc.toc1 (tree for second section)
   Controlling display:
   .cur class on current head
   .live class on div.codextoc and parents
*/

/* Building the DIV */

Codex.TOC=
    (function(){
        var fdjtString=fdjt.String;
        var fdjtState=fdjt.State;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;
        
        var cxicon=Codex.icon;
        function navicon(kind){
            switch (kind) {
            case 'right': return cxicon("scan_right",64,64);
            case 'left': return cxicon("scan_left",64,64);
            case 'start': return cxicon("scan_left_stop",64,64);
            case 'end': return cxicon("scan_right_stop",64,64);
            default: return false;}}
        Codex.navicon=navicon;

        function CodexTOC(headinfo,depth,tocspec,prefix,headless){
            var progressbar=fdjtDOM("HR.progressbar");
            var head=((headless)?(false):
                      (fdjtDOM("A.sectname",headinfo.title)));
            var spec=tocspec||"DIV.codextoc";
            var next_button=
                ((head)&&
                 ((headinfo.next)?
                  (fdjtDOM.Image(navicon("right"),false,"next")):
                  (fdjtDOM.Image(navicon("end"),false,"nextstop"))));
            if ((next_button)&&(headinfo.next))
                next_button.frag=headinfo.next.frag;
            var back_button=
                ((head)&&
                 ((headinfo.prev)?
                  (fdjtDOM.Image(navicon("left"),false,"back")):
                  (fdjtDOM.Image(navicon("start"),false,"backstop"))));
            if ((back_button)&&(headinfo.prev))
                back_button.frag=headinfo.prev.frag;
            var toc=fdjtDOM(spec,
                            next_button,back_button,
                            ((head)&&(fdjtDOM("DIV.head",progressbar,head))),
                            generate_spanbar(headinfo),
                            generate_subsections(headinfo));
            var sub=headinfo.sub;
            if (!(depth)) depth=0;
            if (head) {
                head.name="SBR"+headinfo.frag;
                head.frag=headinfo.frag;}
            toc.sbook_start=headinfo.starts_at;
            toc.sbook_end=headinfo.ends_at;
            fdjtDOM.addClass(toc,"toc"+depth);
            toc.id=(prefix||"CODEXTOC4")+headinfo.frag;
            if ((!(sub))||(!(sub.length))) {
                fdjtDOM.addClass(toc,"codextocleaf");
                return toc;}
            var i=0; var n=sub.length;
            while (i<n) {
                toc.appendChild(CodexTOC(sub[i++],depth+1,spec,prefix,headless));}
            if (depth===0) {
                toc.title="Tap to go to this section; hold to preview it";
                fdjtUI.TapHold(toc,Codex.touch);
                Codex.UI.addHandlers(toc,'toc');}
            return toc;}
        
        function generate_subsections(headinfo) {
            var sub=headinfo.sub;
            if ((!(sub)) || (!(sub.length))) return false;
            var div=fdjtDOM("div.sub");
            var i=0; var n=sub.length;
            while (i<n) {
                var subinfo=sub[i];
                var subspan=fdjtDOM("A.sectname",subinfo.title);
                subspan.frag=subinfo.frag;
                subspan.name="SBR"+subinfo.frag;
                fdjtDOM(div,((i>0)&&" \u00b7 "),subspan);
                i++;}
            return div;}
        
        function generate_spanbar(headinfo){
            var spanbar=fdjtDOM("div.spanbar.codexslice");
            var spans=fdjtDOM("div.spans");
            var start=headinfo.starts_at;
            var end=headinfo.ends_at;
            var len=end-start;
            var subsections=headinfo.sub; var last_info;
            var sectnum=0; var percent=0;
            var head=headinfo.elt;
            spanbar.starts=start; spanbar.ends=end;
            if ((!(subsections)) || (subsections.length===0))
                return false;
            var progress=fdjtDOM("div.progressbox","\u00A0");
            var range=false; var lastspan=false;
            fdjtDOM(spanbar,progress,spans);
            fdjtDOM(spans,range);
            progress.style.left="0%";
            if (range) range.style.left="0%";
            var i=0; while (i<subsections.length) {
                var spaninfo=subsections[i++];
                var subsection=document.getElementById(spaninfo.frag);
                var spanstart; var spanend; var addname=true;
                if ((sectnum===0) && ((spaninfo.starts_at-start)>0)) {
                    /* Add 'fake section' for the precursor of the
                     * first actual section */
                    spanstart=start;  spanend=spaninfo.starts_at;
                    spaninfo=headinfo;
                    subsection=document.getElementById(headinfo.frag);
                    i--; sectnum++; addname=false;}
                else {
                    spanstart=spaninfo.starts_at; spanend=spaninfo.ends_at;
                    sectnum++;}
                var span=generate_span(
                    sectnum,subsection,spaninfo.title,spanstart,spanend,len,
                    ((addname)&&("SBR"+spaninfo.frag)),start);
                lastspan=span;
                spans.appendChild(span);
                if (addname) {
                    var anchor=fdjtDOM("A.codextitle",spaninfo.title);
                    anchor.name="SBR"+spaninfo.frag;
                    spans.appendChild(anchor);}
                last_info=spaninfo;}
            if ((end-last_info.ends_at)>0) {
                /* Add 'fake section' for the content after the last
                 * actual section */
                var span=generate_span
                (sectnum,head,headinfo.title,last_info.ends_at,end,len,start);
                spanbar.appendChild(span);}    
            return spanbar;}

        function generate_span(sectnum,subsection,title,
                               spanstart,spanend,len,name,pstart){
            var spanlen=spanend-spanstart;
            var anchor=fdjtDOM("A.brick","\u00A0");
            var span=fdjtDOM("DIV.codexhudspan",anchor);
            var width=(Math.round(100000000*(spanlen/len))/1000000);
            var left=(Math.round(100000000*((spanstart-pstart)/len))/1000000);
            span.style.left=left+"%";
            span.style.width=width+"%";
            span.title=(title||"section")+
                " ("+Math.round(left)+"%-"+(Math.round(left+width))+"%); "+
                "tap to jump here, hold to preview";
            span.frag=subsection.id;
            if (name) anchor.name=name;
            return span;}

        function getTOCPrefix(string){
            var fourpos=string.indexOf("4");
            if (fourpos) return string.slice(0,fourpos+1);
            else return string;}

        var hasClass=fdjtDOM.hasClass;
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var getChildren=fdjtDOM.getChildren;

        function updateTOC(head,tocroot){
            var prefix=getTOCPrefix(tocroot.id);
            var cur=(getChildren(tocroot,".codexcurhead"));
            var live=(getChildren(tocroot,".codexlivehead"));
            var cxt=(getChildren(tocroot,".codexcxthead"));
            dropClass(tocroot,"codexcxthead");
            dropClass(tocroot,"codexcurhead");
            dropClass(cur,"codexcurhead");
            dropClass(live,"codexlivehead");
            dropClass(cxt,"codexcxthead");
            if (!(head)) return;
            var base_elt=document.getElementById(prefix+head.frag);
            var toshow=[]; var base_info=head;
            while (head) {
                var tocelt=document.getElementById(prefix+head.frag);
                if (tocelt) toshow.push(tocelt);
                head=head.head;}
            var n=toshow.length-1;
            if ((base_info.sub)&&(base_info.sub.length))
                addClass(base_elt,"codexcxthead");
            else if (toshow[1]) addClass(toshow[1],"codexcxthead");
            else {}
            // Go backwards to accomodate some redisplayers
            while (n>=0) {
                var show=toshow[n--];
                if ((show.tagName==='A')&&
                    (show.className.search(/\bbrick\b/)>=0))
                    addClass(show.parentNode,"codexlivehead");
                addClass(show,"codexlivehead");}
            addClass(base_elt,"codexcurhead");}
        CodexTOC.updateTOC=updateTOC;

        CodexTOC.setHead=function setHead(headinfo){
            var livetitles=(fdjtDOM.$("a.codexlivehead.codextitle"));
            var i=0; var lim=livetitles.length;
            while (i<lim) livetitles[i++].style.fontSize='';
            var tocs=fdjtDOM.$(".toc0");
            var i=0; var lim=tocs.length;
            while (i<lim) { updateTOC(headinfo,tocs[i++]);}
            if (!(headinfo)) {
                addClass(tocs,"codexlivehead");
                addClass(tocs,"codexcurhead");
                return;}
            var head=headinfo;
            while (head) {
                var refs=document.getElementsByName("SBR"+head.frag);
                addClass(refs,"codexlivehead");
                var j=0; var jlim=refs.length;
                while (j<jlim) {
                    var ref=refs[j++];
                    if ((ref.tagName==='A')&&(ref.className)&&
                        (ref.className.search(/\bbrick\b/)>=0))
                        addClass(ref.parentNode,"codexlivehead");}
                head=head.head;}
            setTimeout(function(){scaleTitles(headinfo);},200);}

        function scaleTitles(headinfo){
            // Now, autosize the titles
            var head=headinfo;
            while (head) {
                var refs=document.getElementsByName("SBR"+head.frag);
                var j=0; var nrefs=refs.length;
                while (j<nrefs) {
                    var elt=refs[j++];
                    if ((elt.tagName==='A')&&(hasClass(elt,"codextitle"))) {
                        var cw=elt.clientWidth, sw=elt.scrollWidth;
                        if (sw>cw) elt.style.fontSize=(80*(cw/sw))+"%";}}
                head=head.head;}}
            
        return CodexTOC;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/slices.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements the search component of a 
   Javascript/DHTML UI for reading large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.
   This file assumes that the sbooks.js file has already been loaded.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

(function () {

    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    var div_threshold=7;
    var debug_locbars=false;
    var odq="\u201c"; var cdq="\u201d";

    var cxicon=Codex.icon;
    var Ellipsis=fdjtUI.Ellipsis;
    var addListener=fdjtDOM.addListener;

    function renderCard(info,query,idprefix,standalone){
        var key=info._id;
        var target_id=(info.frag)||(info.id);
        var target=((target_id)&&(fdjtID(target_id)));
        var target_info=Codex.docinfo[target_id];
        var head_info=target_info.head;
        var head=((head_info)&&(head_info.elt));
        var refiners=((query) && (query._refiners));
        var score=((query)&&(query[key]));
        var excerpt_len=((info.excerpt)?(info.excerpt.length):(0));
        var note_len=((info.note)?(info.note.length):(0));
        var overdoc=getoverdoc(info);
        var shared=(info.shared);
        if (typeof shared === 'string') shared=[shared];
        if (overdoc) shared=fdjtKB.remove(shared,(overdoc._qid||overdoc._id));
        var body=
            fdjtDOM("div.codexcardbody",
                    // (makelocrule(target_info,target_info.head)),
                    ((info.maker)?(showglossinfo(info)):(showdocinfo(info)))," ",
                    ((standalone)&&(showtocloc(target_info))),
                    ((score)&&(showscore(score))),
                    ((excerpt_len<note_len)?
                     ((excerpt_len>0)&&(showexcerpts(info.excerpt))):
                     ((note_len>0)&&(Ellipsis("span.note",info.note,140))))," ",
                    ((excerpt_len>=note_len)?
                     ((excerpt_len>0)&&(showexcerpts(info.excerpt))):
                     ((note_len>0)&&(Ellipsis("span.note",info.note,140))))," ",
                    (((info.tags)||(info.autotags))&&(showtags(info)))," ",
                    ((info.links)&&(showlinks(info.links)))," ",
                    ((info.attachments)&&
                     (showlinks(info.attachments,"span.attachments")))," ",
                    ((shared)&&(shared.length)&&(showaudience(shared))));
        var div=
            fdjtDOM(((info.maker) ?
                     "div.codexcard.gloss" :
                     "div.codexcard.passage"),
                    ((head)&&(makeTOCHead(head))),
                    ((head_info)&&(makeIDHead(target,head_info,true))),
                    ((standalone)&&(makelocbar(target_info))),
                    body,
		    fdjtDOM("fdjtclearfloats"));
        var makerinfo=((info.maker)&&(Codex.sourcekb.load(info.maker)));
        var tstamp=info.tstamp||info.modified||info.created;
        if (tstamp)
            body.title=
            "gloss from "+(((makerinfo)&&(makerinfo.name))||"someone")+
            " at "+fdjtTime.shortString(tstamp);
        else div.title=Codex.getTitle(target,true);
        div.about="#"+info.frag;
        // div.setAttribute('about',"#"+info.id);
        if (idprefix) div.id=idprefix+info.id;
        if (info._id) {
            div.name=div.qref=info._id;
            div.setAttribute("name",info._id);}
        return div;}
    Codex.renderCard=renderCard;
    
    var prime_thresh=7;
    function getprimetags(info){
        if (info.primetags) return info.primetags;
        var tags=info.tags;
        if (typeof tags==='string') tags=[tags];
        if (tags.length<=prime_thresh) return tags;
        var tagscores=Codex.index.tagscores;
        var prime=[].concat(info.tags);
        prime.sort(function(t1,t2){
            var s1=tagscores[t1]; var s2=tagscores[t2];
            if ((s1)&&(s2)) {
                if (s1<s2) return -1;
                else if (s1>s2) return 1;
                else return 0;}
            else if (s1) return -1;
            else if (s3) return 1;
            else return 0;});
        info.primetags=prime.slice(0,prime_thresh);
        return info.primetags;}

    var show_tag_thresh=7;

    var expander_toggle=fdjtUI.Expansion.toggle;
    function tagexpand_click(evt){
        return expander_toggle(evt);}

    var combineTags=Knodule.combineTags;
    
    function showtags(info){
        var ctags=info.tags;
        var gtags=info.glosstags;
        var knodes=info.knodes;
        var dterms=[];
        var atags=info.autotags;
        var tags; var scores;
        if (knodes) {
            var i=0; var lim=knodes.length;
            while (i<lim) dterms.push(knodes[i++].tagString());}
        if ((typeof ctags === 'string')||(ctags instanceof String))
            ctags=[ctags];
        if (!((atags)||(gtags))) {
            tags=ctags; scores=tags.scores;}
        else if (info.alltags) {
            // This is where the combination of tags is cached
            tags=info.alltags; scores=tags.scores;}
        else {
            // Sort the automatic tags if needed
            if ((atags)&&(!(atags.sorted))) {
                var weights=Codex.index.tagscores;
                atags.sort(function(t1,t2){
                    var v1=weights[t1], v2=weights[t2];
                    if ((v1)&&(v2)) {
                        if (v1<v2) return -1;
                        else if (v1>v2) return 1;
                        else return 0;}
                    else if (v1) return 1;
                    else return -1;});
                atags.sorted=true;}
            tags=info.alltags=combineTags([ctags,dterms,gtags,atags]);
            scores=tags.scores;}
        var tagcount=0;
        var countspan=fdjtDOM("span.count");
        var tagicon=fdjtDOM.Image(cxicon("tagicon",64,64),
                                  "img.tagicon","tags");
        var span=fdjtDOM("span.tags.fdjtexpands",tagicon);
        var tagspan=span;
        var controller=false;
        var i=0; var lim=tags.length;
        while (i<tags.length) {
            var tag=tags[i]; var score=((scores)&&(scores[tag]))||false;
            if ((typeof tag === 'string')&&(tag.indexOf('@')>=0))
                tag=fdjtKB.ref(tag)||tag;
            var togo=tags.length-i;
            if ((!controller)&&((!(score))||(score<=1))&&
                (i>show_tag_thresh)&&(togo>4)) {
                controller=fdjtDOM("span.controller.clickable",
                                   fdjtDOM("span.whenexpanded","-"),
                                   fdjtDOM("span.whencollapsed","+"),
                                   "all ",tags.length," tags");
                var subspan=fdjtDOM("span.whenexpanded");
                controller.setAttribute(
                    "onclick","fdjt.UI.Expansion.toggle(event);");
                fdjtDOM(span," ",controller," ",subspan);
                tagspan=subspan;}
            fdjtDOM.append(tagspan,((i>0)?" \u00b7 ":" "),
                           Knodule.HTML(tag,Codex.knodule));
            i++;}
        return span;}
    function showaudience(outlets,spec){
        if (!(outlets instanceof Array)) outlets=[outlets];
        if (outlets.length===0) return false;
        var span=fdjtDOM(
            spec||((outlets.length>1)?("div.audience"):("span.audience")),
            ((outlets.length>1)&&
             (fdjtDOM("span.count",outlets.length, " outlets"))),
            " ");
        var i=0; var lim=outlets.length;
        // This might do some kind of more/less controls and sorted
        // or cloudy display
        while (i<outlets.length) {
            var outlet=outlets[i]; var info=fdjtKB.load(outlet);
            var outlet_span=fdjtDOM("span.outlet",info.name);
            if (info.about) 
                outlet_span.title="Shared with “"+info.name+"” — "+info.about;
            else outlet_span.title="Shared with “"+info.name+"”";
            fdjtDOM.append(span," ",outlet_span);
            i++;}
        return span;}
    function showlinks(refs,spec){
        var count=0;
        for (var url in refs) if (url[0]==='_') continue; else count++;
        if (count===0) return false;
        var span=fdjtDOM(spec||((count>1)?("div.links"):("span.links")),
                         ((count>1)&&(fdjtDOM("span.count",count, " links"))),
                         " ");
        for (url in refs) {
            if (url[0]==='_') continue;
            var urlinfo=refs[url];
            var title; var icon=cxicon("diaglink",64,64);
            if (typeof urlinfo === 'string') title=urlinfo;
            else {
                title=urlinfo.title;
                icon=urlinfo.icon;}
            var image=fdjtDOM.Image(icon);
            var anchor=(fdjtDOM.Anchor(url,{title:"Link to "+url},image,title));
            anchor.target='_blank';
            fdjtDOM(span,anchor,"\n");}
        return span;}
    function showexcerpts(excerpts){
        if (typeof excerpts==='string')
            return Ellipsis("span.excerpt",excerpts,140);
        else if (excerpts.length===1)
            return Ellipsis("span.excerpt",excerpts[0],140);
        else {
            var ediv=fdjtDOM("div.excerpts");
            var i=0; var lim=excerpts.length;
            while (i<lim)
                fdjtDOM(ediv,
                        ((i>0)&&" "),
                        fdjtDOM("span.excerpt",odq,excerpts[i++],cdq));
            return ediv;}}
    function showscore(score){
        var scorespan=fdjtDOM("span.score");
        var score=query[key]; var k=0;
        while (k<score) {fdjtDOM(scorespan,"*"); k++;}
        return scorespan;}
    function showglossinfo(info) {
        var user=info.maker;
        var feed=info.feed||false;
        var userinfo=(user)&&(Codex.sourcekb.load(user));
        var feedinfo=(feed)&&(Codex.sourcekb.load(feed));
        var agestring=timestring(info.modified||info.created);
        var tool=fdjtDOM(
            "span.tool",
            fdjtDOM.Image(
                (((user===Codex.user)||(user===Codex.user._id))?
                 (cxicon("remark_edit_titled",40,40)):
                 (cxicon("remark_respond_titled",40,40))),
                "img.button",
                (((user===Codex.user)||(user===Codex.user._id))?
                 ("edit"):("reply")),
                (((user===Codex.user)||(user===Codex.user._id))?
                 ("tap to edit this gloss, hold to reply"):
		 ("relay/reply to this gloss"))),
            ((info.private)&&(fdjtDOM("span.private","Private")))," ",
            fdjtDOM("span.age",agestring));
        addListener(tool,"tap",relayoredit_gloss);
	// addListener(tool,"hold",relayoredit_gloss);
        
        var picinfo=getpicinfo(info);
        var overdoc=getoverdoc(info);
        
        return [((picinfo)?
                 (fdjtDOM.Image(picinfo.src,picinfo.classname,picinfo.alt)):
                 (getfakepic(info.maker,"div.sourcepic"))),
                ((overdoc)&&(overdoc.name)&&
                 (fdjtDOM("span.overdoc",(overdoc.name)))),
                /* ((overdoc)&&(overdoc.name)&&(" \u00b7 ")), */
                (((!(overdoc))&&(userinfo)&&
                  ((userinfo.name)||(userinfo.userid)))&&
                 (fdjtDOM("span.user",((userinfo.name)||(userinfo.userid))))),
                ((!(overdoc))&&(userinfo)&&
                 ((userinfo.name)||(userinfo.userid))&&
                 (" \u2014 ")),
                tool];}
    function showdocinfo(info) {
        return fdjtDOM("span.marker",((info.toclevel)?("\u00a7"):("\u00b6")));}

    function getoverdoc(info){
        if (info.sources) {
            var sources=info.sources;
            if (typeof sources === 'string') sources=[sources];
            var i=0; var lim=sources.length;
            while (i<lim) {
                var source=fdjtKB.load(sources[i++]);
                if ((source)&&(source.kind===':OVERDOC'))
                    return source;}
            return false;}
        else return false;}

    function getfakepic(maker,spec){
        var userinfo=fdjtKB.load(maker);
        var pic=fdjtDOM(spec||"div.sbooksourcepic",
                        ((userinfo.name)?
                         (fdjtString.getInitials(userinfo.name)):
                         "?"));
        fdjtDOM.addClass(pic,"sbooknopic");
        return pic;}

    function getpicinfo(info){
        if (info.pic) return {src: info.pic,alt: info.pic};
        if (info.sources) {
            var sources=info.sources;
            if (typeof sources==='string') sources=[sources];
            var i=0; var lim=sources.length;
            while (i<lim) {
                var source=fdjtKB.load(sources[i++]);
                if ((source)&&(source.kind===':OVERDOC')&&(source.pic))
                    return { src: source.pic, alt: source.name,
                             classname: "img.glosspic.sourcepic"};}}
        if (info.links) {
            var links=info.links;
            var i=0; var lim=links.length;
            while (i<lim) {
                var link=links[i++];
                if (link.href.search(/\.(jpg|png|gif|jpeg)$/i)>0)
                    return { src: link.href, alt: "graphic",
                             classname: "img.glosspic"};}}
        if (info.shared) {
            var outlets=info.shared;
            if (typeof outlets==='string') outlets=[outlets];
            var i=0; var lim=outlets.length;
            while (i<lim) {
                var outlet=fdjtKB.load(outlets[i++]);
                if ((outlet)&&(outlet.kind===':OVERLAY')&&(outlet.pic))
                    return { src: outlet.pic, alt: outlet.name,
                             classname: "img.glosspic.sourcepic"};}}
        if (info.maker) {
            var userinfo=fdjtKB.load(info.maker);
            if (userinfo.pic)
                return { src: userinfo.pic, alt: userinfo.name,
                         classname: "img.glosspic.userpic"};
            else if (userinfo.fbid)
                return {
                    src: "https://graph.facebook.com/"+
                        userinfo.fbid+"/picture?type=square",
                    classname: "img.glosspic.userpic.fbpic"};
            else return false;}
        else return false;}

    var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    function timestring(tick){
        var now=fdjtTime.tick();
        if ((now-tick)<(12*3600)) {
            var date=new Date(1000*tick);
            var hour=date.getHours();
            var minute=date.getMinutes();
            return ""+hour+":"+((minute<10)?"0":"")+minute;}
        else {
            var date=new Date(1000*tick);
            var year=date.getFullYear();
            var month=date.getMonth();
            var date=date.getDate();
            var shortyear=year%100;
            if (year<10)
                return ""+date+"/"+months[month]+"/0"+year;
            else return ""+date+"/"+months[month]+"/"+year;}}

    function makelocbar(target_info,cxt_info){
        var locrule=fdjtDOM("HR");
        var locbar=fdjtDOM("DIV.locbar",locrule);
        var target_start=target_info.starts_at;
        var target_end=target_info.ends_at;
        var target_len=target_end-target_start;
        if (!(cxt_info)) cxt_info=Codex.docinfo[document.body.id];
        var cxt_start=cxt_info.starts_at;
        var cxt_end=cxt_info.ends_at;
        var cxt_len=cxt_end-cxt_start;
        if (debug_locbars)
            locbar.setAttribute(
                "debug","ts="+target_start+"; te="+target_end+"; cl="+cxt_len);
        locrule.style.width=((target_len/cxt_len)*100)+"%";
        locrule.style.left=(((target_start-cxt_start)/cxt_len)*100)+"%";
        var id=target_info.id||target_info.frag;
        if (id) {
            locbar.about="#"+id;
            locbar.title=sumText(fdjtID(id));}
        return locbar;}
    function showtocloc(target_info){
        var head=((target_info.toclevel)?(target_info):(target_info.head));
        var heads=head.heads;
        var anchor=fdjtDOM.Anchor(
            "javascript:Codex.JumpTo('"+(head.frag||head.id)+"');","a.headref",
            fdjtDOM("span.spacer","\u00A7"),
            head.title);
        var title="jump to "+head.title;
        var i=heads.length-1; 
        while (i>0) {
            var head=heads[i--]; title=title+"// "+head.title;}
        anchor.title=title;
        return [" ",anchor];}

    function makelocspan(target_info,cxtinfo){
        if (!(cxtinfo)) cxtinfo=Codex.docinfo[(Codex.body||document.body).id];
        var locrule=fdjtDOM("div.locrule");
        var cxt_start=cxtinfo.starts_at;
        var cxt_end=cxtinfo.ends_at;
        var cxt_len=cxt_end-cxt_start;
        var location_start=target_info.starts_at-cxt_start;
        var location_len=target_info.ends_at-target_info.starts_at;
        locrule.setAttribute("about","#"+(target_info.id||target_info.frag));
        locrule.title='click or hold to glimpse';
        locrule.style.width=((location_len/cxt_len)*100)+"%";
        locrule.style.left=((location_start/cxt_len)*100)+"%";
        return locrule;}
    function makelocrule(target_info,cxtinfo,spec){
        if (!(cxtinfo)) cxtinfo=Codex.docinfo[Codex.content.id];
        var locrule=fdjtDOM(spec||"hr.locrule");
        var cxt_start=cxtinfo.starts_at;
        var cxt_end=cxtinfo.ends_at;
        var cxt_len=cxt_end-cxt_start;
        var target_start=target_info.starts_at-cxt_start;
        var target_len=target_info.ends_at-target_info.starts_at;
        var locstring="~"+Math.ceil(target_len/5)+ " words long ~"+
            Math.ceil((target_start/cxt_len)*100)+"% along";
        locrule.setAttribute("about","#"+(target_info.id||target_info.frag));
        locrule.locstring=locstring+".";
        locrule.title=locstring+": click or hold to glimpse";
        locrule.style.width=((target_len/cxt_len)*100)+"%";
        locrule.style.left=((target_start/cxt_len)*100)+"%";
        return locrule;}

    function editicon_ontap(evt){
        var target=fdjtUI.T(evt);
        var card=fdjtDOM.getParent(target,'.codexcard');
        var gloss=((card)&&(card.name)&&(fdjtKB.load(card.name,Codex.glosses)));
        var form=Codex.setGlossTarget(gloss);
        if (!(form)) return;
        Codex.setMode("addgloss");}
    function replyicon_ontap(evt){
        var target=fdjtUI.T(evt);
        var card=fdjtDOM.getParent(target,'.codexcard');
        var gloss=((card)&&(card.name)&&(fdjtKB.load(card.name,Codex.glosses)));
        var form=Codex.setGlossTarget(gloss,Codex.getGlossForm(gloss,true));
        if (!(form)) return;
        Codex.setMode("addgloss");}

    function relayoredit_gloss(evt){
        var scan=fdjtUI.T(evt);
        fdjtUI.cancel(evt);
        while (scan) {
            if (scan.qref) break;
            else scan=scan.parentNode;}
        if (!(scan)) return;
        var qref=scan.qref;
        var gloss=Codex.glosses.ref(qref);
        var form=Codex.setGlossTarget(gloss,evt.type==="hold");
        if (!(form)) return;
        Codex.setMode("addgloss");}

    function sourceIcon(info){
        if (info) return info.pic;}
    
    // Displayings sets of notes organized into threads

    function sortbyloctime(x,y){
        if (x.frag===y.frag) {
            if ((x.tstamp)&&(y.tstamp)) {
                if (x.tstamp<y.tstamp) return -1;
                else if (x.tstamp>y.tstamp) return 1;
                else return 0;}
            else if (x.tstamp) return 1;
            else if (y.tstamp) return -1;
            else return 0;}
        else if (x.ends_at<=y.starts_at) return 1;
        else if (x.starts_at>=y.ends_at) return -1;
        else if ((x.ends_at-x.starts_at)>(y.ends_at-y.starts_at))
            return 1;
        else return -1;}

    var scanInfo=Codex.DOMScan.scanInfo;

    function showSlice(results,div,scores,sort,cardclass){
        var notes=new Array(results.length);
        var i=0; var lim=results.length;
        while (i<lim) {
            var r=results[i];
            if (typeof r === 'string') {
                var ref=Codex.docinfo[r]||Codex.glosses.ref(r);
                if (!(ref)) fdjtLog("No resolution for %o",r);
                notes[i]=ref;}
            else notes[i]=r;
            i++;}
        if (!(sort)) {}
        else if (scores)
            notes.sort(function sortbyscore(n1,n2){
                // Sort by score first (any score beats no score)
                //  and then by location within the book and then
                //  by timestamp.
                var s1=(scores[n1._id]);
                var s2=(scores[n2._id]);
                if ((s1)&&(s2)) {
                    if (s1>s2) return -1;
                    else if (s2>s1) return 1;}
                else if (s1) return -1;
                else if (s2) return 1;
                // This should put passage matches first, so that they
                // appear just beneath the idhead
                if (n1.frag===n2.frag) {
                    if (n1 instanceof scanInfo) return -1;
                    else if (n2 instanceof scanInfo) return 1;}
                if (n1.starts_at<n2.starts_at) return -1;
                else if (n1.starts_at>n2.starts_at) return 1;
                else if (n1.ends_at<n2.ends_at) return -1;
                else if (n1.ends_at>n2.ends_at) return 1;
                else if ((n1.tstamp)&&(n2.tstamp)) {
                    if (n1.tstamp>n2.tstamp) return -1;
                    else if (n1.tstamp>n2.tstamp) return 1;
                    else return 0;}
                else if (n1.tstamp) return 1;
                else if (n2.tstamp) return -1;
                else return 0;});
        else notes.sort(function(n1,n2){
            // This puts passage matches first, so that they
            // appear just beneath the passage reference.
            if (n1.frag===n2.frag) {
                if (n1 instanceof scanInfo) return -1;
                else if (n2 instanceof scanInfo) return 1;}
            if (n1.starts_at<n2.starts_at) return -1;
            else if (n1.starts_at>n2.starts_at) return 1;
            else if (n1.ends_at<n2.ends_at) return -1;
            else if (n1.ends_at>n2.ends_at) return 1;
            else if ((n1.tstamp)&&(n2.tstamp)) {
                if (n1.tstamp>n2.tstamp) return -1;
                else if (n1.tstamp>n2.tstamp) return 1;
                else return 0;}
            else if (n1.tstamp) return 1;
            else if (n2.tstamp) return -1;
            else return 0;});
        
        var headelt=false; var threadelt=false;
        var curhead=false; var curinfo=false;
        var i=0; var len=notes.length; while (i<len) {
            var note=notes[i++];
            var frag=note.id||note.frag;
            if (!(frag)) continue;
            var target=fdjtID(frag);
            var docinfo=Codex.docinfo[target.id];
            var headinfo=docinfo.head;
            var head=document.getElementById(headinfo.frag);
            // var tochead=makeTOCHead(head);
            if (curinfo!==docinfo) {
                if (headinfo!==curhead) {
                    headelt=fdjtDOM("div.codexthread.tocthread"); // ,tochead
                    headelt.frag=headinfo.frag;
                    fdjtDOM.append(div,headelt);
                    curhead=headinfo;}
                threadelt=fdjtDOM("div.codexthread.idthread");
                // ,makeIDHead(target,headinfo,true)
                threadelt.about="#"+frag;
                threadelt.title=Codex.getTitle(target,true);
                fdjtDOM.append(headelt,threadelt);
                curinfo=docinfo;}
            fdjtDOM.append(threadelt,renderCard(note));}
        return div;}
    Codex.UI.showSlice=showSlice;

    function sumText(target){
        var title=Codex.getTitle(target,true);
        if (title.length<40) return title;
        /* title.slice(0,40)+"\u22ef "; */
        else return title;}
    
    function makeTOCHead(target,head){
        if (!(head)) head=Codex.getHead(target);
        var basespan=fdjtDOM("span");
        basespan.title='this location in the structure of the book';
        var title=Codex.getTitle(target,true);
        var info=Codex.docinfo[target.id];
        var head_info=Codex.docinfo[head.id];
        if (target!==head) {
            var paratext=
                fdjtDOM.Anchor("javascript:Codex.JumpTo('"+target.id+"');",
                               "a.paratext",
                               fdjtDOM("span.spacer","\u00B6"),
                               sumText(target));
            paratext.title='(click to jump to this passage) '+title;
            fdjtDOM(basespan,paratext," ");}
        if (head) {
            var text=sumText(head);
            var headtext=
                fdjtDOM.Anchor("javascript:Codex.JumpTo('"+head.id+"');",
                               "a.headtext",
                               fdjtDOM("span.spacer","\u00A7"),
                               text);
            var curspan=fdjtDOM("span.head",headtext);
            headtext.title='jump to the section: '+text;
            fdjtDOM.append(basespan," ",curspan);
            var heads=Codex.Info(head).heads;
            if (heads) {
                var j=heads.length-1; while (j>=0) {
                    var hinfo=heads[j--]; var elt=fdjtID(hinfo.frag);
                    if ((!(elt))||(!(hinfo.title))||
                        (elt===Codex.docroot)||(elt===document.body))
                        continue;
                    var anchor=
                        fdjtDOM.Anchor(
                            "javascript:Codex.JumpTo('"+hinfo.frag+"');",
                            "a.headtext",
                            fdjtDOM("span.spacer","\u00A7"),
                            hinfo.title);
                    var newspan=fdjtDOM("span.head"," ",anchor);
                    anchor.title=
                        ((hinfo.title)?('jump to the section: '+hinfo.title):
                         "(jump to this section)");
                    if (target===head) fdjtDOM(curspan,newspan);
                    else fdjtDOM(curspan," \u22ef ",newspan);
                    curspan=newspan;}}}
        var tochead=fdjtDOM("div.tochead",
                            makelocrule(info,false),
                            basespan);
        return tochead;}

    function makeIDHead(target,headinfo,locrule){
        var info=Codex.docinfo[target.id];
        var headinfo=info.head;
        var tochead=fdjtDOM("div.idhead",
                            makelocrule(info,headinfo),
                            fdjtDOM("span.spacer","\u00b6"),
                            fdjtDOM("span",sumText(target)));
        var title=Codex.getTitle(target,true);
        return tochead;}

    function findTOCref(div,ref,loc) {
        var children=div.childNodes;
        if (!(children)) return false;
        var i=0; var lim=children.length;
        while (i<lim) {
            var child=children[i++];
            if (!(child.nodeType===1)) continue;
            else if (child.tocref===ref) return child;
            else if (child.starts>loc) return child;
            else continue;}
        return false;}

    function addToSlice(note,div,query){
        var frag=(note.id||note.frag);
        var eltinfo=Codex.docinfo[frag];
        if (!(eltinfo)) return;
        var about=document.getElementById(frag);
        if (!(about)) return;
        var headinfo=((eltinfo.toclevel)?(eltinfo):(eltinfo.head));
        var headid=headinfo.frag;
        var head=document.getElementById(headid);
        var starts=eltinfo.starts_at;
        var head_starts=headinfo.starts_at;
        var insertion=false; var insdiff=0;
        var headthread=findTOCref(div,headid,head_starts);
        if ((!(headthread))||(headthread.tocref!==headid)) {
            var insertbefore=headthread;
            headthread=fdjtDOM("div.codexthread.tocthread");
            // ,makeTOCHead(head,head)
            headthread.tocref=headid; headthread.starts=head_starts;
            if (insertbefore) fdjtDOM.insertBefore(insertbefore,headthread);
            else fdjtDOM.append(div,headthread);}
        var idthread=((frag===headid)?(headthread):
                      (findTOCref(headthread,frag,starts)));
        if ((!(idthread))||(idthread.tocref!==frag)) {
            var insertbefore=idthread;
            idthread=fdjtDOM("div.codexthread.idthread");
            idthread.tocref=frag; idthread.starts=starts; idthread.about="#"+frag;
            idthread.title=Codex.getTitle(about,true);
            idthread.setAttribute("locref",frag);
            idthread.setAttribute("locinfo",starts);
            if (insertbefore) fdjtDOM.insertBefore(insertbefore,idthread);
            else fdjtDOM.append(headthread,idthread);}
        var tstamp=note.tstamp; var qid=note._id;
        var children=headthread.childNodes;
        var ishead=(frag===headid);
        var i=0; var lim=children.length;
        while (i<lim) {
            var child=children[i++];
            if (child.nodeType!==1) continue;
            if ((ishead)&&(fdjtDOM.hasClass(child,"codexthread"))) {
                fdjtDOM.insertBefore(child,renderCard(note));
                return;}
            // If unrelated, continue
            if (!((fdjtDOM.hasClass(child,"codexcard"))||
                  (fdjtDOM.hasClass(child,"codexthread"))))
                continue;
            // If the same thing, replace
            if (child.qref===qid) {
                fdjtDOM.replace(child,renderCard(note));
                return;}
            // if you're earlier, insert yourself and return
            if (tstamp<=child.tstamp) {
                fdjtDOM.insertBefore(child,renderCard(note));
                return;}
            else continue;}
        fdjtDOM.append(idthread,renderCard(note));}
    Codex.UI.addToSlice=addToSlice;

    Codex.nextSlice=function(start){
        var slice=fdjtDOM.getParent(start,".codexslice");
        var scan=fdjtDOM.forwardElt(start); var ref=false;
        while (scan) {
            if (((scan.about)||
                 ((scan.getAttribute)&&(scan.getAttribute("about"))))&&
                ((fdjtDOM.hasClass(scan,"codexcard"))||
                 (fdjtDOM.hasClass(scan,"passage"))))
                break;
            else scan=fdjtDOM.forwardElt(scan);}
        if (fdjtDOM.hasParent(scan,slice)) return scan;
        else return false;};
    Codex.prevSlice=function(start){
        var slice=fdjtDOM.getParent(start,".codexslice");
        var scan=fdjtDOM.backwardElt(start); var ref=false;
        while (scan) {
            if (((scan.about)||
                 ((scan.getAttribute)&&(scan.getAttribute("about"))))&&
                ((fdjtDOM.hasClass(scan,"codexcard"))||
                 (fdjtDOM.hasClass(scan,"passage"))))
                break;
            else scan=fdjtDOM.backwardElt(scan);}
        if (fdjtDOM.hasParent(scan,slice)) return scan;
        else return false;};

    /* Selecting a subset of glosses to display */

    var hasClass=fdjtDOM.hasClass;

    function selectSourcesRecur(thread,sources){
        var empty=true; var children=thread.childNodes;
        var i=0; var lim=children.length;
        while (i<children.length) {
            var child=children[i++];
            if (child.nodeType!==1) continue;
            if (hasClass(child,"codexcard")) {
                var gloss=(child.qref)&&Codex.glosses.map[child.qref];
                if (!(gloss)) fdjtDOM.dropClass(child,"sourced");
                else if ((fdjtKB.contains(sources,gloss.maker))||
                         (fdjtKB.overlaps(sources,gloss.sources))||
                         (fdjtKB.overlaps(sources,gloss.shared))) {
                    fdjtDOM.addClass(child,"sourced");
                    empty=false;}
                else fdjtDOM.dropClass(child,"sourced");}
            else if (hasClass(child,"codexthread")) {
                if (!(selectSourcesRecur(child,sources)))
                    empty=false;}
            else {}}
        if (!(empty)) fdjtDOM.addClass(thread,"sourced");
        else fdjtDOM.dropClass(thread,"sourced");
        return empty;}

    function selectSources(results_div,sources){
        if (!(sources)) {
            fdjtDOM.dropClass(results_div,"sourced");
            fdjtDOM.dropClass(fdjt.$(".sourced",results_div),"sourced");
            return;}
        selectSourcesRecur(results_div,sources);
        if (Codex.target) scrollGlosses(Codex.target,results_div);}
    Codex.UI.selectSources=selectSources;

    /* Scrolling slices */

    function scrollGlosses(elt,glosses,top){
        if (!(elt.id)) elt=getFirstID(elt);
        var info=Codex.docinfo[elt.id];
        var targetloc=((info)&&(info.starts_at))||(elt.starts_at);
        if (targetloc) {
            var scrollto=getFirstElt(glosses,targetloc);
            if ((scrollto)&&((top)||(!(fdjtDOM.isVisible(scrollto))))) {
                if ((Codex.scrollers)&&(glosses.id)&&
                    (Codex.scrollers[glosses.id])) {
                    var scroller=Codex.scrollers[glosses.id];
                    scroller.scrollToElement(scrollto);}
                else scrollto.scrollIntoView(true);}}}
    Codex.UI.scrollGlosses=scrollGlosses;
    
    function getFirstID(node){
        if (node.id) return node;
        else if (node.childNodes) {
            var children=node.childNodes;
            var i=0; var lim=children.length;
            while (i<lim) {
                var child=children[i++];
                if (child.nodeType===1) {
                    var found=getFirstID(child);
                    if (found) return found;}}
            return false;}
        else return false;}

    function getFirstElt(glosses,location){
        var children=glosses.childNodes; var last=false;
        var i=0; var lim=children.length;
        while (i<lim) {
            var child=children[i++];
            if (child.nodeType!==1) continue;
            else if (!(child.starts)) continue;
            else if (child.starts===location)
                return child;
            else if (child.starts>location) {
                if (last)
                    return getFirstElt(last,location)||last;
                else return last;}
            else last=child;}
        if (last) getFirstElt(last,location);
        return false;}
    
    function getScrollOffset(elt,inside){
        if (elt.parentNode===inside) {
            var children=inside.childNodes;
            var i=0; var lim=children.length; var off=0;
            while (i<lim) {
                var child=children[i++];
                if (child===elt) return off;
                if (child.offsetHeight) off=off+child.offsetHeight;}
            return off;}
        else return getScrollOffset(elt,elt.parentNode)+
            getScrollOffset(elt.parentNode,inside);}

    /* Results handlers */

    function setupSummaryDiv(div){
        fdjtUI.TapHold(div,Codex.touch,500,20);
        Codex.UI.addHandlers(div,'summary');}
    Codex.UI.setupSummaryDiv=setupSummaryDiv;
    
})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/social.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
    large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

    Use and redistribution (especially embedding in other
      CC licensed content) is permitted under the terms of the
      Creative Commons "Attribution-NonCommercial" license:

          http://creativecommons.org/licenses/by-nc/3.0/ 

    Other uses may be allowed based on prior agreement with
      beingmeta, inc.  Inquiries can be addressed to:

       licensing@beingmeta.com

   Enjoy!

*/

(function(){

    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    var sbook_sources=false;
    var sbook_glosses_target=false;
    var sbookGlossesHUD=false;
    var sbookSourceHUD=false;

    // The highlighted glossmark
    var sbook_glossmark=false;
    var sbook_glossmark_qricons=false;

    var hasClass=fdjtDOM.hasClass;
    var addClass=fdjtDOM.addClass;
    var dropClass=fdjtDOM.dropClass;
    var cxicon=Codex.icon;

    /* Social UI components */

    function addSource(info,withgloss){
        if (typeof info === 'string') info=fdjtKB.ref(info);
        var humid=info.humid;
        if (!(info.name)) return;
        if (withgloss) {
            var icon=fdjtID("SBOOKSOURCEICON"+humid);
            if (!(icon)) { // Add icon to the sources bar
                var pic=(info.pic)||
                    ((info.fbid)&&
                     ("https://graph.facebook.com/"+info.fbid+
                      "/picture?type=square"));
                if ((pic)&&(window.applicationCache)) {
                    var cache=window.applicationCache;
                    if (cache.add) cache.add(pic);
                    // This gets an "operation is insecure error.
                    else if (cache.mozAdd) {} // cache.mozAdd(pic);
                    // We could probably use local storage to handle this
                    // case, but that would be hairy.
                    else {}}
                var kind=info.kind;
                if (pic) {}
                else if (kind===':CIRCLE')
                    pic=cxicon("readingcircle",64,64);
                else if (kind===':OVERDOC')
                    pic=cxicon("sideguide",64,64);
                else {}
                if (pic)
                  icon=fdjtDOM.Image
                    (pic,".button.source",info.name|info.kind,
                     ("click to show/hide glosses from "+info.name));
                else {
                  icon=fdjtDOM("div.button.source",
                               fdjtString.getInitials(info.name));}
                var title=
                    ((kind===':CIRCLE')?("the reading circle "):
                     (kind===':OVERDOC')?("the reading guide "):
                     ("the overlay "))+
                    ((info.name)?("“"+(info.name)+"”"):"")+
                    ((info.about)?": ":"")+
                    ((info.about)?(info.about):"");
                icon.title=title; icon.oid=info._id;
                icon.id="SBOOKSOURCEICON"+humid;
                fdjtDOM(fdjtID("CODEXSOURCES")," ",icon);}}
        return info;};
    Codex.UI.addSource=addSource;
    Codex.UI.addGlossSource=function(info){addSource(info,true);};

    function everyone_ontap(evt){
        evt=evt||event||null;
        var target=fdjtDOM.T(evt);
        // var sources=fdjtDOM.getParent(target,".codexsources");
        // var glosses=fdjtDOM.getParent(target,".sbookglosses");
        var sources=fdjtID("CODEXSOURCES");
        var glosses=fdjtID("CODEXALLGLOSSES");
        var new_sources=[];
        if ((!(sources))||(!(glosses)))
            return; /* Warning? */
        if (fdjtDOM.hasClass(target,"selected")) {
            Codex.setMode(false);
            fdjtDOM.cancel(evt);
            return;}
        var selected=fdjtDOM.$(".selected",sources);
        fdjtLog("Everyone click sources=%o glosses=%o selected=%o/%d",
                sources,glosses,selected,selected.length);
        fdjtDOM.toggleClass(selected,"selected");
        fdjtDOM.addClass(target,"selected");
        Codex.UI.selectSources(glosses,false);
        fdjtDOM.cancel(evt);}
    Codex.UI.handlers.everyone_ontap=everyone_ontap;

    function sources_ontap(evt){
        evt=evt||event||null;
        // if (!(Codex.user)) return;
        var target=fdjtDOM.T(evt);
        // var sources=fdjtDOM.getParent(target,".codexsources");
        // var glosses=fdjtDOM.getParent(target,".sbookglosses");
        var sources=fdjtID("CODEXSOURCES");
        var glosses=fdjtID("CODEXALLGLOSSES");
        var new_sources=[];
        if ((!(sources))||(!(glosses))||(!(target.oid)))
            return; /* Warning? */
        if ((evt.shiftKey)||(fdjtDOM.hasClass(target,"selected"))) {
            fdjtDOM.toggleClass(target,"selected");
            var selected=fdjtDOM.$(".selected",sources);
            var i=0; var len=selected.length;
            while (i<len) {
                var oid=selected[i++].oid;
                if (oid) new_sources.push(oid);}}
        else {
            var selected=fdjtDOM.$(".selected",sources);
            var i=0; var len=selected.length;
            while (i<len) fdjtDOM.dropClass(selected[i++],"selected");
            fdjtDOM.addClass(target,"selected");
            new_sources=[target.oid];}
        var everyone=fdjtDOM.$(".everyone",sources)[0];
        if (new_sources.length) {
            if (everyone) fdjtDOM.dropClass(everyone,"selected");
            Codex.UI.selectSources(glosses,new_sources);}
        else {
            if (everyone) fdjtDOM.addClass(everyone,"selected");
            Codex.UI.selectSources(glosses,false);}
        fdjtDOM.cancel(evt);}
    Codex.UI.handlers.sources_ontap=sources_ontap;

    function geticon(source){
        return ((source.pic)||(source.fb_pic)||
                (source.twitter_pic)||(source.gplus_pic)||
                ((source.fbid)&&
                 ("https://graph.facebook.com/"+
                  source.fbid+"/picture?type=square")));}

    function extendGlossmark(glossmark,glosses,bigimage){
        var Sources=Codex.sourcekb; var Glosses=Codex.glosses;
        if (!(bigimage)) bigimage=fdjtDOM.getChild(glossmark,".big");
        var images=bigimage.getAttribute("data-images").split(";");
        if ((images.length===1)&&(images[0]==="")) images=[];
        var i=0; var lim=glosses.length;
        while (i<lim) {
            var gloss=Glosses.ref(glosses[i++]);
            var maker=Sources.ref(gloss.maker);
            var maker_img=geticon(maker);
            if (maker_img) images.push(maker_img);
            var outlets=gloss.sources||[];
            if (typeof outlets === 'string') outlets=[outlets];
            var j=0, jlim=outlets.length; while (j<jlim) {
                var outlet=Sources.ref(outlets[j++]);
                var outlet_img=geticon(outlet);
                if (outlet_img) images.push(outlet_img);}}
        bigimage.setAttribute("data-images",images.join(";"));
        return glossmark;}
    
    Codex.UI.addGlossmark=function(passage,gloss){
        var Glosses=Codex.glosses;
        var glossmark=fdjtDOM.getChild(passage,".codexglossmark");
        if ((glossmark)&&(glossmark.parentNode===passage)) {
            if (gloss) extendGlossmark(glossmark,[gloss]);
            return glossmark;}
        var imgsrc=(cxicon("sbwedge",64,64));
        var bigimage=fdjtDOM.Image(imgsrc,"big","glosses");
        var glossmark=fdjtDOM(
            "span.codexglossmark.fdjtskiptext",
            bigimage,fdjtDOM.Image(cxicon("sbwedge",64,64),"tiny","*"));
        // Get all the glosses from the index
        var glosses=Glosses.index(false,"frag",passage.id);
        glossmark.title=
            ((glosses.length>1)?
             ("See "+glosses.length+" glosses on this passage"):
             ("See the gloss on this passage"));
        bigimage.defaultsrc=imgsrc;
        bigimage.setAttribute("data-images","");
        extendGlossmark(glossmark,glosses,bigimage);
        Codex.UI.addHandlers(glossmark,"glossmark");
        fdjtDOM.addClass(passage,"glossed");
        fdjtDOM.prepend(passage,glossmark);
        return glossmark;};
    
    function showGlosses(target) {
        var glosses=Codex.glosses.find('frag',target.codexbaseid||target.id);
        var sumdiv=fdjtDOM("div.codexglosses.hudpanel#CODEXGLOSSES");
        var excerpt=false;
        if ((!(glosses))||(!(glosses.length)))
            fdjtDOM.addClass(sumdiv,"noglosses");
        Codex.UI.setupSummaryDiv(sumdiv);
        if (Codex.target) Codex.clearHighlights(Codex.target);
        if (glosses) {
            var i=0; var n=glosses.length;
            while (i<n) {
                var gloss=fdjtKB.ref(glosses[i++],Codex.glosses);
                if ((!(gloss))||(!(gloss.frag))) continue;
                if ((!excerpt)&&(gloss.excerpt)) excerpt=gloss.excerpt;
                var card=Codex.renderCard(gloss);
                fdjtDOM(sumdiv,card);}}
        fdjtDOM.replace("CODEXGLOSSES",sumdiv);
        Codex.setTarget(target);
        if (excerpt) {
            var range=fdjtDOM.findString(target,excerpt);
            if (range) fdjtUI.Highlight(range,"highlightexcerpt");}
        else addClass(target,"highlightpassage");
        Codex.setMode("glosses");}
    Codex.showGlosses=showGlosses;

})();

/* Emacs local variables
;;;  Local variables: ***
;;;  compile-command: "cd ..; make" ***
;;;  indent-tabs-mode: nil ***
;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/search.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements the search component of a 
   Javascript/DHTML UI for reading large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.
   This file assumes that the sbooks.js file has already been loaded.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

(function(){
    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    Codex.search_cloud=false;
    if (!(Codex.empty_cloud)) Codex.empty_cloud=false;
    if (!(Codex.show_refiners)) Codex.show_refiners=25;
    if (!(Codex.search_gotlucky)) Codex.search_gotlucky=7;
    
    var cxicon=Codex.icon;

    var Completions=fdjtUI.Completions;
    var addClass=fdjtDOM.addClass;
    var getChildren=fdjtDOM.getChildren;
    var getChild=fdjtDOM.getChild;
    var log=fdjtLog;
    var kbref=fdjtKB.ref;

    /* Query functions */

    /* Set on main search input */
    // id="CODEXSEARCHINPUT" 
    // completions="CODEXSEARCHCLOUD"

    var Query=KnoduleIndex.Query;
    var KNode=Knodule.KNode;

    Codex.getQuery=function(){return Codex.query;}
    
    function setQuery(query){
        if (Codex.Trace.search) log("Setting working query to %o",query);
        var query=Codex.query=useQuery(query,fdjtID("CODEXSEARCH"));
        if (Codex.mode==="search") {
            if (query._results.length===0) {}
            else if (query._results.length<7)
                showSearchResults();
            else {fdjtID("CODEXSEARCHINPUT").focus();}}}

    Codex.setQuery=setQuery;

    function useQuery(query,box_arg){
        var result;
        if (query instanceof Query) result=query;
        else result=Codex.index.Query(query);
        var qstring=result.getString();
        if ((box_arg)&&(typeof box_arg === 'string'))
            box_arg=document.getElementById(box_arg);
        var box=box_arg||result._box||fdjtID("CODEXSEARCH");
        if ((query.dom)&&(box)&&(box!==query.dom))
            fdjtDOM.replace(box_arg,query.dom);
        if (qstring===box.getAttribute("qstring")) {
            log("No change in query for %o to %o: %o/%o (%o)",
                box,result._query,result,result._refiners,qstring);
            return;}
        if (Codex.Trace.search>1)
            log("Setting query for %o to %o: %o/%o (%o)",
                box,result._query,result,result._refiners,qstring);
        else if (Codex.Trace.search)
            log("Setting query for %o to %o: %d results/%d refiners (%o)",
                box,result._query,result._results.length,
                result._refiners._results.length,qstring);
        var input=getChild(box,".searchinput");
        var cloudid=input.getAttribute("completions");
        var resultsid=input.getAttribute("results");
        var qtags=getChild(box,".qtags");
        var cloud=((cloudid)&&(fdjtID(cloudid)))||
            getChild(box,".searchcloud");
        var results=((resultsid)&&(fdjtID(resultsid)))||
            getChild(box,".searchresults");
        var resultcount=getChild(box,".resultcount");
        var refinecount=getChild(box,".refinecount");
        // Update (clear) the input field
        input.value='';
        var elts=result._query; var i=0; var lim=elts.length;
        // Update 'notags' class
        if (elts.length) fdjtDOM.dropClass(box,"notags");
        else addClass(box,"notags");
        // Update the query tags
        var newtags=fdjtDOM("span.qtags");
        while (i<lim) {
            var tag=elts[i];
            if (typeof tag === 'string') tag=kbref(tag)||tag;
            if (i>0) fdjtDOM(newtags," \u00B7 ");
            // Handle section references as tags
            if ((typeof tag === "string")&&(tag[0]==="\u00A7")) {
                var showname=tag;
                if (tag.length>20) {
                    var start=tag.indexOf(' ',8);
                    var end=tag.lastIndexOf(' ',showname.length-8);
                    if (start<0) start=8; if (end<0) end=showname.length-8;
                    if (start<(showname.length-end)) {
                        showname=showname.slice(0,start)+" \u2026 "+
                            showname.slice(end);}}
                var span=fdjtDOM("span.completion",
                                 fdjtDOM("span.sectname",showname));
                fdjtDOM(newtags,span);}
            else if (typeof tag === "string")
                fdjtDOM(newtags,fdjtDOM("span.rawterm",tag));
            else fdjtDOM(newtags,tag);
            i++;}
        if (qtags.id) newtags.id=qtags.id;
        fdjtDOM.replace(qtags,newtags);
        // Update the results display
        if (result._results.length) {
            resultcount.innerHTML=result._results.length+
                " result"+((result._results.length===1)?"":"s");
            fdjtDOM.dropClass(box,"noresults");}
        else {
            resultcount.innerHTML="no results";
            addClass(box,"noresults");}
        // Update the search cloud
        var n_refiners=
            ((result._refiners)&&(result._refiners._results.length))||0;
        var completions=Codex.queryCloud(result);
        refinecount.innerHTML=n_refiners+
            ((n_refiners===1)?(" associated tag"):(" associated tags"));
        fdjtDOM.dropClass(box,"norefiners");
        if (cloudid) completions.id=cloudid;
        if (Codex.Trace.search>1)
            log("Setting search cloud for %o to %o",box,completions.dom);
        cloudid=cloud.id;
        addClass(completions.dom,"hudpanel");
        fdjtDOM.replace(cloud,completions.dom);
            completions.complete("");
        if (n_refiners===0) {
            addClass(box,"norefiners");
            refinecount.innerHTML="no refiners";}
        result._box=box; box.setAttribute(qstring,qstring);
        Codex.UI.updateScroller(completions.dom);
        return result;}
    Codex.useQuery=useQuery;

    function extendQuery(query,elt){
        var elts=[].concat(query._query);
        if (typeof elt === 'string') 
            elts.push(kbref(elt)||elt);
        else elts.push(elt);
        return useQuery(query.index.Query(elts),query._box);}
    Codex.extendQuery=extendQuery;

    Codex.updateQuery=function(input_elt){
        var q=Knodule.Query.string2query(input_elt.value);
        if ((q)!==(Codex.query._query))
            Codex.setQuery(q,false);};

    function showSearchResults(){
        var results=Codex.query.showResults();
        addClass(results,"hudpanel");
        fdjtDOM.replace("CODEXSEARCHRESULTS",results);
        Codex.setMode("searchresults");
        fdjtID("CODEXSEARCHINPUT").blur();
        fdjtID("CODEXSEARCHRESULTS").focus();
        Codex.UI.updateScroller(fdjtID("CODEXSEARCHRESULTS"));}
    Codex.showSearchResults=showSearchResults;

    /* Call this to search */

    function startSearch(tag){
        setQuery([tag]);
        Codex.setMode("search");}
    Codex.startSearch=startSearch;

    /* Text input handlers */

    var _sbook_searchupdate=false;
    var _sbook_searchupdate_delay=200;
    var Selector=fdjtDOM.Selector;
    
    function searchInput_keyup(evt){
        evt=evt||event||null;
        var ch=evt.charCode||evt.keyCode;
        var target=fdjtDOM.T(evt);
        // fdjtLog("Input %o on %o",evt,target);
        // Clear any pending completion calls
        if ((ch===13)||(ch===13)||(ch===59)||(ch===93)) {
            var qstring=target.value;
            if (fdjtString.isEmpty(qstring)) showSearchResults();
            else {
                var completeinfo=queryCloud(Codex.query);
                if (completeinfo.timer) {
                    clearTimeout(completeinfo.timer);
                    completeinfo.timer=false;}
                var completions=completeinfo.complete(qstring);
                var completion=(completeinfo.selection)||
                    completeinfo.select(new Selector(".cue"))||
                    completeinfo.select();
                // Signal error?
                if (!(completion)) return;
                var value=completeinfo.getValue(completion);
                setQuery(extendQuery(Codex.query,value));}
            fdjtDOM.cancel(evt);
            if ((Codex.search_gotlucky) && 
                (Codex.query._results.length>0) &&
                (Codex.query._results.length<=Codex.search_gotlucky))
                showSearchResults();
            else {
                /* Handle new info */
                var completeinfo=queryCloud(Codex.query);
                completeinfo.complete("");}
            return false;}
        else if (ch===9) { /* tab */
            var qstring=target.value;
            var completeinfo=queryCloud(Codex.query);
            var completions=completeinfo.complete(qstring);
            fdjtUI.cancel(evt);
            if (completions.prefix!==qstring) {
                target.value=completions.prefix;
                fdjtDOM.cancel(evt);
                setTimeout(function(){
                    Codex.UI.updateScroller("CODEXSEARCHCLOUD");},
                           100);
                return;}
            else if (evt.shiftKey) completeinfo.selectPrevious();
            else completeinfo.selectNext();}
        else {
            var completeinfo=queryCloud(Codex.query);
            completeinfo.docomplete(target);
            setTimeout(function(){
                Codex.UI.updateScroller("CODEXSEARCHCLOUD");},
                       100);}}
    Codex.UI.handlers.search_keyup=searchInput_keyup;

    function searchUpdate(input,cloud){
        if (!(input)) input=fdjtID("CODEXSEARCHINPUT");
        if (!(cloud)) cloud=queryCloud(Codex.query);
        cloud.complete(input.value);}
    Codex.searchUpdate=searchUpdate;

    function searchInput_focus(evt){
        evt=evt||event||null;
        var input=fdjtDOM.T(evt);
        sbook_search_focus=true;
        if ((Codex.mode)&&(Codex.mode==='searchresults'))
            Codex.setMode("search");
        searchUpdate(input);}
    Codex.UI.handlers.search_focus=searchInput_focus;

    function searchInput_blur(evt){
        evt=evt||event||null;
        sbook_search_focus=false;}
    Codex.UI.handlers.search_blur=searchInput_blur;

    function clearSearch(evt){
        var target=fdjtUI.T(evt||event);
        var box=fdjtDOM.getParent(target,".searchbox");
        var input=getChild(box,".searchinput");
        fdjtUI.cancel(evt);
        if (Codex.query._query.length===0) {
            Codex.setMode(false); return;}
        else setQuery(Codex.empty_query);
        input.focus();}
    Codex.UI.handlers.clearSearch=clearSearch;
    
    Codex.toggleSearch=function(evt){
        evt=evt||event;
        if ((Codex.mode==="search")||
            (Codex.mode==="searchresults"))
            Codex.setMode(false);
        else {
            Codex.setMode("search");
            fdjtID("CODEXSEARCHINPUT").focus();}
        fdjtUI.cancel(evt);};
    
    /* Show search results */

    function makelocrule(target_info,cxtinfo_arg,cxtname){
        var cxtinfo=cxtinfo_arg||Codex.docinfo[(Codex.body||document.body).id];
        if (!(cxtname)) {
            if (cxtinfo_arg) cxtname="into the section";
            else cxtname="into the book";}
        var locrule=fdjtDOM("hr.locrule");
        var cxt_start=cxtinfo.starts_at;
        var cxt_end=cxtinfo.ends_at;
        var cxt_len=cxt_end-cxt_start;
        var target_start=target_info.starts_at-cxt_start;
        var target_len=target_info.ends_at-target_info.starts_at;
        var locstring="~"+Math.ceil(target_len/5)+ " words long ~"+
            Math.ceil((target_start/cxt_len)*100)+"% "+cxtname;
        locrule.setAttribute("about","#"+(target_info.id||target_info.frag));
        locrule.locstring=locstring+".";
        locrule.title=locstring+": click or hold to glimpse";
        locrule.style.width=((target_len/cxt_len)*100)+"%";
        locrule.style.left=((target_start/cxt_len)*100)+"%";
        return locrule;}

    function showResults(result){
        if (result._results_div) return result._results_div;
        var results=result._results; var rscores=result._scores;
        var scores={}; var sorted=[];
        var i=0; var lim=results.length;
        var scores=new Array(lim);
        while (i<lim) {
            var r=results[i++];
            var ref=Codex.docinfo[r]||Codex.glosses.map[r]||kbref(r)||r;
            if (!(ref)) continue;
            var frag=ref.frag;
            if (!(frag)) continue;
            sorted.push(ref);
            if (scores[frag]) 
                scores[frag]=scores[frag]+(rscores[r]||1);
            else {
                scores[frag]=rscores[r];}
            i++;}
        sorted.sort(function(x,y){
            var xfrag=x.frag; var yfrag=y.frag;
            if (xfrag===yfrag) {}
            else if (scores[x.frag]>scores[yfrag]) return -1;
            else if (scores[xfrag]<scores[yfrag]) return 1;
            var xqid=x._id; var yqid=y._id;
            if (rscores[xqid]>rscores[yqid]) return -1;
            else if (rscores[xqid]<rscores[yqid]) return 1;
            var xstart=x.starts_at; var ystart=y.starts_at;
            if (xstart<ystart) return -1;
            else if (xstart>ystart) return 1;
            var xend=x.ends_at; var yend=y.ends_at;
            if (xend<yend) return -1;
            else if (xend>yend) return 1;
            else return 0;});
        if (!(result)) result=Codex.query;
        var div=fdjtDOM("div.codexslice.sbookresults");
        fdjtUI.TapHold(div,Codex.touch);
        Codex.UI.addHandlers(div,'summary');
        Codex.UI.showSlice(result._results,div,rscores);
        result._results_div=div;
        return div;}
    KnoduleIndex.Query.prototype.showResults=
        function(){return showResults(this);};
    
    /* Getting query cloud */

    function queryCloud(query){
        if (query._cloud) return query._cloud;
        else if ((query._query.length)===0) {
            query._cloud=searchCloud();
            return query._cloud;}
        else if (!(query._refiners)) {
            query._cloud=Codex.empty_cloud;
            return query._cloud;}
        else {
            var refiners=query._refiners;
            var completions=makeCloud(
                refiners._results,refiners,refiners._freqs);
            var cloud=completions.dom;
            cloud.onclick=cloud_ontap;
            var n_refiners=query._refiners._results.length;
            var hide_some=(n_refiners>Codex.show_refiners);
            if (hide_some) {
                var cues=fdjtDOM.$(".cue",cloud);
                if (!((cues)&&(cues.length))) {
                    var compelts=fdjtDOM.$(".completion",cloud);
                    var i=0; var lim=((compelts.length<Codex.show_refiners)?
                                      (compelts.length):(Codex.show_refiners));
                    while (i<lim) addClass(compelts[i++],"cue");}}
            else addClass(cloud,"showempty");
            query._cloud=completions;
            return query._cloud;}}
    Codex.queryCloud=queryCloud;
    KnoduleIndex.Query.prototype.getCloud=function(){return queryCloud(this);};

    function cloud_ontap(evt){
        evt=evt||event;
        var target=fdjtDOM.T(evt);
        var completion=fdjtDOM.getParent(target,".completion");
        if (Codex.Trace.gestures) log("cloud tap on %o",completion);
        if (completion) {
            var cinfo=Codex.query._cloud;
            var value=cinfo.getValue(completion);
            if (typeof value !== 'string') add_searchtag(value);
            else  if (value.length===0) {}
            else if (value.indexOf('@')>=0)
                add_searchtag(kbref(value));
            else if ((Codex.knodule)&&(Codex.knodule.probe(value)))
                add_searchtag(Codex.knodule.probe(value));
            else add_searchtag(value);
            fdjtUI.cancel(evt);}
        else if (fdjtDOM.inherits(target,".resultcounts")) {
            showSearchResults(Codex.query);
            Codex.setMode("searchresults");
            fdjtID("CODEXSEARCHINPUT").blur();
            fdjtID("CODEXSEARCHRESULTS").focus();
            fdjtUI.cancel(evt);}
        else if (fdjtDOM.inherits(target,".refinercounts")) {
            var completions=fdjtDOM.getParent(target,".completions");
            fdjtDOM.toggleClass(completions,"showempty");
            fdjtDOM.cancel(evt);}
        else if (fdjtDOM.inherits(target,".maxcompletemsg")) {
            var completions=fdjtDOM.getParent(target,".completions");
            fdjtID("CODEXSEARCHINPUT").focus();
            fdjtDOM.toggleClass(container,"showall");
            fdjtDOM.cancel(evt);}
        else {}}
    Codex.UI.handlers.cloud_ontap=cloud_ontap;

    function makeCloud(dterms,scores,freqs,ranks_arg,noscale,
                       completions,init_cloud) {
        var start=new Date();
        var sbook_index=Codex.index;
        var sourcekb=Codex.sourcekb;
        var knodule=Codex.knodule;
        var cloud=init_cloud||false;
        var i=0; var n_terms=dterms.length;
        // Move it out of the flow
        var placeholder=false;
        if ((init_cloud)&&(init_cloud.parentNode)) {
            placeholder=document.createTextNode("");
            init_cloud.parentNode.replaceChild(placeholder,init_cloud);}
        var info=organize_dterms(dterms,scores,knodule,sourcekb);
        if (Codex.Trace.clouds)
            log("Making cloud from %d dterms w/scores=%o [%d,%d] and freqs=%o",
                dterms.length,scores,info.max,info.min,freqs);
        // We use cues when there are no inputs if:
        var usecues=(n_terms>17)&& (// lots of terms AND
            (info.n_primes>0) || // there are prime terms OR
            (info.max!==info.min) || // scores are different OR
            // there are a small number of real concepts to use
            ((info.normals._count)<17) ||
                // there's are a lot of weak terms
                ((n_terms/info.normals._count)>4));
        if (cloud) {
            fdjtDOM.addClass(cloud,"completions");
            if (!(getChild(cloud,".showall")))
                fdjtDOM.prepend(cloud,getShowAll(usecues,n_terms));}
        else cloud=newCloud(getShowAll(usecues,n_terms));
        if (!(usecues)) fdjtDOM.addClass(cloud,"showempty");
        var prime=getChild(cloud,".prime")||cloud;
        var normal=getChild(cloud,".normal")||cloud;
        var weak=getChild(cloud,".weak")||cloud;
        var sources=getChild(cloud,".sources")||cloud;
        var words=getChild(cloud,".words")||cloud;
        var sections=getChild(cloud,".sections")||cloud;
        if (!(completions)) completions=new Completions(cloud);
        dterms=sort_dterms(dterms,sbook_index,ranks_arg);
        var nspans=0; var sumscale=0;
        var minscale=false; var maxscale=false;
        var domnodes=[]; var nodescales=[];
        var count=scores._count;
        var cuelim=scores._maxscore/2;
        var cscores=sbook_index.tagscores;
        var cfreqs=sbook_index.tagfreqs;
        var ctotal=sbook_index._allitems.length;
        var normals=((info.n_primes<17)&&(info.normals));
        var topcloud=(freqs===cfreqs)
        i=0; while (i<dterms.length) {
            var dterm=dterms[i++]; 
            var container=words; // The default
            var ref=kbref(dterm,knodule);
            var span=dtermSpan(completions,
                               dterm,ref,freqs,cfreqs,scores,
                               (info.n_primes>17),
                               cuelim);
            if (!(span)) continue;
            var scaling=
                ((scores[dterm])?(1+Math.log(scores[dterm])):
                 (freqs[dterm])?(1+Math.log(freqs[dterm])):
                 (1));
            /*
            if (topcloud) {
                if (scores[dterm]) scaling=Math.log(scores[dterm]);
                else if (freqs[dterm]) scaling=Math.log(freqs[dterm]);
                else scaling=1;}
            else if (scores[dterm]) scaling=scores[dterm]/cscores[dterm];
            else if (freqs[dterm]) scaling=freqs[dterm]/cfreqs[dterm];
            else scaling=1;
            */
            domnodes.push(span);
            if ((scores)&&(!(noscale))) {
                if ((!(minscale))||(scaling<minscale)) minscale=scaling;
                if ((!(maxscale))||(scaling>maxscale)) maxscale=scaling;
                nodescales.push(scaling);}
            if (!(ref)) {
                if (dterm[0]==="\u00A7") container=sections;
                else container=words;}
            else if (ref.pool===sourcekb) container=sources;
            else if (ref.prime) container=prime;
            else if (ref.weak) container=weak;
            else container=normal;
            if ((completions)&&(!(span.parentNode)))
                completions.addCompletion(span,false,ref||dterm);
            container.appendChild(span);
            container.appendChild(document.createTextNode(" "));}
        // fdjtLog("minscale=%o, maxscale=%o",minscale,maxscale);
        var scalespan=maxscale-minscale;
        if (nodescales.length) {
            var j=0; var jlim=domnodes.length;
            while (j<jlim) {
                var node=domnodes[j];
                var scale=nodescales[j];
                node.style.fontSize=
                    (100+(100*((scale-minscale)/scalespan)))+'%';
                j++;}}
        var maxmsg=fdjtDOM
        ("div.maxcompletemsg",
         "There are a lot ","(",fdjtDOM("span.completioncount","really"),")",
         " of completions.  ");
        fdjtDOM.prepend(cloud,maxmsg);
        var end=new Date();
        if (Codex.Trace.clouds)
            fdjtLog("Made cloud for %d dterms in %f seconds",
                    dterms.length,(end.getTime()-start.getTime())/1000);
        // Put it back in the flow if neccessary
        if (placeholder)
            placeholder.parentNode.replaceChild(cloud,placeholder);
        return completions;}
    Codex.makeCloud=makeCloud;

    function newCloud(preamble){
        var spans=[fdjtDOM("span.prime")," ",
                   fdjtDOM("span.normal")," ",
                   fdjtDOM("span.sections")," ",
                   fdjtDOM("span.weak")," ",
                   fdjtDOM("span.words")," ",
                   fdjtDOM("span.sources")];
        return fdjtDOM("div.completions",preamble,spans);}

    function dtermSpan(completions,
                       dterm,ref,freqs,cfreqs,scores,
                       justprime,min_score){
        var freq=freqs[dterm]||1;
        var cfreq=cfreqs[dterm]||1;
        var score=scores[dterm]||freq;
        var title=((freq===cfreq)?
                   ("score="+score+"; "+freq+" items"):
                   ("score="+score+"; "+freq+"/"+cfreq+" items"));
        var tagstring=((ref)?(ref._qid||ref.tagString()):(dterm));
        var known=completions.getByValue(tagstring);
        if (known.length) known=known[0]; else known=false;
        var span=known||cloudEntry(ref||dterm,title);
        if (!(span)) return span;
        if (!(known)) span.setAttribute("value",tagstring);
        if (freq===1) addClass(span,"singleton");
        if (justprime) {
            if (ref.prime) addClass(span,"cue");}
        else if ((ref instanceof KNode)&&(!(ref.weak)))
            addClass(span,"cue");
        else {}
        if ((min_score)&&(scores[dterm])&&
                 (scores[dterm]>min_score))
            addClass(span,"cue");
        return span;}

    function getShowAll(use_cues,how_many){
        var showall=(use_cues)&&
            fdjtDOM(
                "span.showall",
                fdjtDOM("span.showmore","more",
                        ((how_many)&&(" ("+how_many+")"))),
                fdjtDOM("span.showless","fewer"));
        if (showall) showall.onclick=showempty_ontap;
        return showall;}

    function sort_dterms(dterms,sbook_index,ranks_arg){
        var copied=[].concat(dterms);
        var ranks=(((ranks_arg===true)||(typeof ranks_arg==='undefined'))?
                   (sbook_index.rankTags()):
                   (ranks_arg));
        // We sort the keys by absolute frequency
        if (ranks===false) copied.sort();
        else copied.sort(function (x,y) {
            var xrank=ranks[x]||0;
            var yrank=ranks[y]||0;
            if (xrank===yrank) {
                if (x<y) return -1;
                else if (x===y) return 0;
                else return 1;}
            else if (xrank<yrank) return -1;
            else return 1;})
        return copied;}

    function organize_dterms(dterms,scores,knodule,sourcekb){
        var min_score=false, max_score=false;
        var normals={}, n_normal=0, n_primes=0;
        var probeRef=fdjtKB.probeRef;
        var i=0; while (i<dterms.length) {
            var dterm=dterms[i++];
            var knode=fdjtKB.probeRef(dterm,knodule);
            if ((knode)&&(knode.prime)) n_primes++;
            if ((knode)&&(knode.pool!==sourcekb)&&(!(knode.weak))) {
                normals[dterm]=true; n_normal++;}
            if (scores) {
                var score=scores[dterm];
                if (score) {
                    if (min_score===false) min_score=score;
                    else if (score<min_score) min_score=score;
                    if (score>max_score) max_score=score;}}}
        normals._count=n_normal;
        return {normals: normals, n_primes: n_primes,
                min: min_score, max: max_score};}

    function showempty_ontap(evt){
        var target=fdjtUI.T(evt);
        var completions=fdjtDOM.getParent(target,".completions");
        if (completions) {
            fdjtUI.cancel(evt);
            fdjtDOM.toggleClass(completions,"showempty");
            setTimeout(function(){
                Codex.UI.updateScroller(completions);},
                       100);}}

    function cloudEntry(term,title){
        var sbook_index=Codex.index; var showname=term;
        var knodule=Codex.knodule; var title=false;
        if ((typeof term === "string") && (term[0]==="\u00A7")) {
            // Handle section references as tags
            if (showname.length>20) {
                var start=showname.indexOf(' ',8);
                var end=showname.lastIndexOf(' ',showname.length-8);
                if (start<0) start=8; if (end<0) end=showname.length-8;
                if (start<(showname.length-end)) {
                    showname=showname.slice(0,start)+" \u2026 "+
                        showname.slice(end);}
                title=term;}
            var span=fdjtDOM("span.completion",
                             fdjtDOM("span.sectname",showname));
            span.key=term; span.value=term; span.anymatch=true;
            span.title=""+sbook_index.freq(term)+" items: "+term;
            if (title) span.title=span.title+"; "+title;
            return span;}
        var span=Knodule.HTML(term,knodule,false,true);
        var knode=((term instanceof KNode)?(term):(knodule.probe(term)));
        var freq=((knode)?(sbook_index.freq(knode._qid)):
                  (sbook_index.freq(term)));
        span.title=(""+freq+" items; ")+
            (((span.title)&&(span.title.length))?(span.title):
             (Completions.getKey(span)));
        return span;}
    Codex.cloudEntry=cloudEntry;
    
    function add_searchtag(value){
        setQuery(Codex.extendQuery(Codex.query,value));}

    function searchCloud(){
        if (Codex.search_cloud) return Codex.search_cloud;
        else {
            var tagscores=Codex.index.tagscores;
            var alltags=Codex.index._alltags;
            var tagfreqs=Codex.index.tagfreqs;
            var completions=Codex.makeCloud(
                alltags,tagscores,tagfreqs,true,false,false,
                fdjtID("CODEXSEARCHCLOUD"));
            completions.dom.onclick=cloud_ontap;
            Codex.search_cloud=completions;
            return Codex.search_cloud;}}
    Codex.searchCloud=searchCloud;

    function sizeCloud(completions,container,index){
        if (!(index)) index=Codex.index;
        if (!(container)) container=completions.dom;
        var nodes=getChildren(container,".completion");
        var tagscores=index.tagscores;
        var max_score=index.maxscore;
        var alltags=index._alltags;
        var i=0; var lim=nodes.length;
        while (i<lim) {
            var tagnode=nodes[i++];
            var tag=tagnode.value||completions.getValue(tagnode);
            if (!(tag)) continue;
            if ((typeof tag === "string") && (tag[0]==="\u00A7")) continue;
            var score=tagscores[tag];
            if (score) tagnode.style.fontSize=(100+(100*(score/max_score)))+"%";}}
    Codex.sizeCloud=sizeCloud;

    Codex.UI.searchCloudToggle=function(){
        fdjtDOM.toggleClass(fdjtID('CODEXSEARCHCLOUD'),'showempty');
        Codex.UI.updateScroller(fdjtID('CODEXSEARCHCLOUD'));};

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/glosses.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements the search component of a 
   Javascript/DHTML UI for reading large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.
   This file assumes that the sbooks.js file has already been loaded.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

(function () {

    var fdjtString=fdjt.String;
    var fdjtState=fdjt.State;
    var fdjtTime=fdjt.Time;
    var fdjtLog=fdjt.Log;
    var fdjtDOM=fdjt.DOM;
    var fdjtUI=fdjt.UI;
    var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;

    var addClass=fdjtDOM.addClass;
    var hasClass=fdjtDOM.hasClass;
    var dropClass=fdjtDOM.dropClass;
    var swapClass=fdjtDOM.swapClass;
    var toggleClass=fdjtDOM.toggleClass;
    var getParent=fdjtDOM.getParent;
    var hasParent=fdjtDOM.hasParent;
    var getChildren=fdjtDOM.getChildren;
    var getChild=fdjtDOM.getChild;
    var getInput=fdjtDOM.getInput;
    var getInputs=fdjtDOM.getInputs;
    var getInputFor=fdjtDOM.getInputFor;
    var getInputsFor=fdjtDOM.getInputsFor;
    var Ellipsis=fdjtUI.Ellipsis;

    var setCheckSpan=fdjtUI.CheckSpan.set;

    var submitEvent=fdjtUI.submitEvent;

    var glossmodes=Codex.glossmodes;

    var cxicon=Codex.icon;

    function getGlossMode(arg){
        if (!(arg)) arg=fdjtID("CODEXLIVEGLOSS");
        if (typeof arg === 'string') arg=fdjtID(arg);
        if ((!(arg))||(!(arg.nodeType))) return false;
        if (arg.tagName!=="FORM") arg=getChild(arg,"FORM");
        var classname=arg.className;
        var match=glossmodes.exec(classname);
        if ((!(match))||(match.length==0)||(!(match[0])))
            return false;
        else return match[0];}
    Codex.getGlossMode=getGlossMode;

    function setGlossMode(mode,arg,toggle){
        if (!(arg)) arg=fdjtID("CODEXLIVEGLOSS");
        if (typeof arg === 'string') arg=fdjtID(arg);
        if ((!(arg))||(!(arg.nodeType))) return;
        var form=((arg.tagName==="FORM")?(arg):
                  ((fdjtDOM.getParent(arg,"form"))||
                   (fdjtDOM.getChild(arg,"form"))));
        var modeclass=false; var input=false;
        if (!(form)) return;
	if (Codex.Trace.mode) {
	    var frag=fdjtDOM.getInput(form,"FRAG");
	    var uuid=fdjtDOM.getInput(form,"UUID");
	    fdjtLog("setGlossMode %o%s: #%s #U%s",
		    mode,((toggle)?(" (toggle)"):("")),
		    ((frag)&&(frag.value)),
		    ((uuid)&&(uuid.value)));}
        if (!(mode)) {
            dropClass(form,glossmodes);
            return;}
        if ((mode==="tag")||(mode==="addtag")) {
            modeclass="addtag";
            input=fdjtID("CODEXTAGINPUT");}
        else if ((mode==="link")||(mode==="addlink")) {
            modeclass="addlink";
            input=fdjtID("CODEXATTACHURL");}
        else if ((mode==="note")||(mode==="editnote")) {
            modeclass="editnote";
            input=fdjtDOM.getInput(form,'NOTE');}
        else if ((mode==="sharing")||(mode==="share")) {
            modeclass="sharing";
            input=fdjtID("CODEXOUTLETINPUT");}
        else {
            dropClass(form,glossmodes);
            return;}
        if (Codex.Trace.mode)
            fdjtLog("setGlossMode gm=%s input=%o",modeclass,input);
        if ((!(modeclass))||((toggle)&&(hasClass(form,modeclass)))) {
            dropClass("CODEXHEART","tagging");
            dropClass("CODEXHEART","showoutlets");
            dropClass("CODEXHEART","addlink");
            dropClass(form,glossmodes);}
        else {
            if (modeclass==="addtag") {
                addClass("CODEXHEART","tagging");
                Codex.UI.updateScroller("CODEXGLOSSTAGS");}
            else dropClass("CODEXHEART","tagging");
            if (modeclass==="sharing") {
                addClass("CODEXHEART","showoutlets");
                Codex.UI.updateScroller("CODEXGLOSSOUTLETS");}
            else dropClass("CODEXHEART","showoutlets");
            if (modeclass==="addlink") {
                addClass("CODEXHEART","addlink");}
            else dropClass("CODEXHEART","addlink");
            swapClass(form,glossmodes,modeclass);
            Codex.setHUD(true);
            if (input) Codex.setFocus(input);}}
    Codex.setGlossMode=setGlossMode;

    function _getbracketed(input,erase){
        var string=input.value;
        if ((!(string))||(string.length==0)) return false;
        var pos=input.selectionStart||0;
        var start=pos, end=pos, lim=string.length;
        while (start>=0) {
            if (string[start]==='[') {
                if ((start>0)&&(string[start-1]==='\\')) {
                    start--; continue;}
                break;}
            else start--;}
        if (start<0) return false;
        while (end<lim) {
            if (string[end]===']') break;
            else if (string[end]==='\\') end=end+2;
            else end++;}
        if (start===end) return false;
        if (erase) {
            input.value=string.slice(0,start)+string.slice(end+1);}
        return string.slice(start+1,end);}

    function getbracketed(input,erase){
        var bracketed=_getbracketed(input,erase);
        if (bracketed) {
            addClass("CODEXHEART","tagging");
            Codex.UI.updateScroller("CODEXGLOSSTAGS");}
        else dropClass("CODEXHEART","tagging");
        return bracketed;}

    // set the gloss target for a particular passage
    function getGlossForm(arg,response) {
        if (typeof arg === 'string')
            arg=fdjtID(arg)||Codex.glosses.ref(arg)||false;
        if (!(arg)) return false;
        var gloss=((!(arg.nodeType))&&(arg.maker)&&(arg));
        if (!(gloss)) response=false;
        else if ((arg.maker)&&(arg.maker!==Codex.user._id))
            response=true;
        else {}
        var passage=((gloss)?(fdjtID(gloss.frag)):(arg));
        var passageid=((passage.codexbaseid)||(passage.id));
        var formid=((gloss)?
                    ((response)?
                     ("CODEXRESPONDGLOSS_"+gloss._id):
                     ("CODEXEDITGLOSS_"+gloss._id)):
                    ("CODEXADDGLOSS_"+passageid));
        var form=fdjtID(formid);
        var div=((form)&&(form.parentNode));
        var proto=fdjtID("CODEXADDGLOSSPROTOTYPE");
        if (!(div)) {
            div=proto.cloneNode(true); div.id=null;
            fdjtDOM(fdjtID("CODEXGLOSSFORMS"),div);
            Codex.setupGestures(div);
            form=getChildren(div,"form")[0];
            form.id=formid;
            form=setupGlossForm(form,passage,gloss,response||false);}
        else form=getChildren(div,"form")[0];
        if (gloss) {
            if (response) addClass(div,"glossreply");
            else addClass(div,"glossedit");}
        if (form) return div; else return false;}
    Codex.getGlossForm=getGlossForm;
    
    function setupGlossForm(form,passage,gloss,response){
        var passageid=((passage.codexbaseid)||(passage.id));
        var info=Codex.docinfo[passageid];
        if (form.getAttribute("sbooksetup")) return false;;
        if (!(info)) return false;
        form.onsubmit=submitGloss;
        getInput(form,"REFURI").value=Codex.refuri;
        getInput(form,"USER").value=Codex.user._id;
        getInput(form,"DOCTITLE").value=document.title;
        getInput(form,"DOCURI").value=document.location.href;
        getInput(form,"FRAG").value=passageid;
        if (info.wsnid) getInput(form,"WSNID").value=info.wsnid;
        if (Codex.mycopyid)
            getInput(form,"MYCOPYID").value=Codex.mycopyid;
        if (gloss) {
            var date_elt=getChild(form,".respdate");
            fdjtDOM(date_elt,fdjtTime.shortString(gloss.created));}
        var noteinput=getInput(form,"NOTE");
        var notespan=getChild(form,".notespan");
        if (noteinput) {
            noteinput.onkeypress=noteinput_keypress;
            noteinput.onkeydown=noteinput_keydown;
            if ((gloss)&&(!(response))) {
                noteinput.value=gloss.note||"";
                if (notespan) notespan.innerHTML=noteinput.value;}
            else noteinput.value="";}
        if (Codex.syncstamp)
            getInput(form,"SYNC").value=(Codex.syncstamp+1);
        var loc=getInput(form,"LOCATION");
        var loclen=getInput(form,"LOCLEN");
        var tagline=getInput(form,"TAGLINE");
        var respondsto=getInput(form,"RE");
        var thread=getInput(form,"THREAD");
        var uuidelt=getInput(form,"UUID");
        var response_elt=getChild(form,"div.response");
        if ((response_elt)&&(response)&&(gloss)) {
            var maker_elt=getChild(response_elt,".respmaker");
            var date_elt=getChild(response_elt,".respdate");
            var note_elt=getChild(response_elt,".respnote");
            var makerinfo=fdjtKB.ref(gloss.maker);
            fdjtDOM(maker_elt,makerinfo.name);
            fdjtDOM(date_elt,fdjtTime.shortString(gloss.created));
            if (gloss.note) {
                if (gloss.note.length>42) 
                    fdjtDOM(note_elt,gloss.note.slice(0,42)+"…");
                else fdjtDOM(note_elt,gloss.note);
                note_elt.title=gloss.note;}
            else fdjtDOM.remove(note_elt);}
        else {
            fdjtDOM.remove(response_elt); response_elt=false;}
        if (loc) {loc.value=info.starts_at;}
        if (loclen) {loclen.value=info.ends_at-info.starts_at;}
        if ((response)&&(gloss)) {
	    thread.disabled=false; respondsto.disabled=false;
            thread.value=gloss.thread||gloss._id;
            respondsto.value=gloss._id;}
        else {
	    respondsto.disabled=true;
	    thread.disabled=true;}
        var tagline=getTagline(passage);
        if (tagline) tagline.value=tagline;
        if ((gloss)&&(gloss.tags)) {
            var tagselt=getChild(form,".tags");
            var resptags=getChild(response_elt,".resptags");
            var tags=gloss.tags;
            if (typeof tags === 'string') tags=[tags];
            var i=0; var lim=tags.length;
            while (i<lim) {
                // if (resptags) gloss;
                addTag(form,tags[i],false);
                i++;}}
        if ((gloss)&&(!(response))&&(gloss.posted)) {
            var wasposted=getChild(form,".wasposted");
            if (wasposted) wasposted.disabled=false;
            var postgloss=getChild(form,".postgloss");
            fdjtUI.setCheckspan(postgloss,true);}
        if ((gloss)&&(!(response))&&(gloss.links)) {
            var links=getChild(form,".links");
            var resplinks=getChild(response_elt,".resplinks");
            var links=gloss.links;
            for (url in links) {
                if (url[0]==='_') continue;
                var urlinfo=links[url];
                var title;
                if (typeof urlinfo === 'string') title=urlinfo;
                else title=urlinfo.title;
                // if (resplinks) addLink();
                addLink(form,url,title);}}
        if ((gloss)&&(gloss.share)) {
            var tags=gloss.share;
            if (typeof tags === 'string') tags=[tags];
            var i=0; var lim=tags.length;
            while (i<lim) addTag(form,tags[i++],"SHARE");}
        if ((!(response))&&(gloss)&&(gloss._id)) {
            uuidelt.value=gloss._id;}
        else uuidelt.value=fdjtState.getUUID(Codex.nodeid);
        if (gloss) {
            // Set the default outlets to unchecked before
            //  adding/setting the assigned outlets.
            resetOutlets(form);
            var shared=((gloss)&&(gloss.shared))||[];
            if (typeof shared === 'string') shared=[shared];
            var i=0, lim=shared.length;
            while (i<lim) addOutlet(form,shared[i++],"SHARE",true);
            var private_span=getChild(form,".private");
            setCheckSpan(private_span,gloss.private);}
        if (((gloss)&&(gloss.excerpt)))
            Codex.setExcerpt(form,gloss.excerpt,gloss.exoff);
        var cancel_button=fdjtDOM.getChild(form,".cancelbutton");
        if (cancel_button)
            fdjtDOM.addListener(
                cancel_button,"click",cancelGloss_handler);
        form.setAttribute("sbooksetup","yes");
        updateForm(form);
        var container=getParent(form,".codexglossform");
        if (container) dropClass(container,"modified");
        return form;}
    Codex.setupGlossForm=setupGlossForm;

    function updateForm(form){
        var glossetc=getChild(form,".glossetc");
        fdjtUI.Overflow(glossetc);}

    function getTagline(target){
        var attrib=
            target.getAttributeNS("tagline","https://sbooks.net/")||
            target.getAttribute("data-tagline")||
            target.getAttribute("tagline");
        if (attrib) return attrib;
        var text=fdjtDOM.textify(target);
        if (!(text)) return false;
        text=fdjtString.stdspace(text);
        if (text.length>40) return text.slice(0,40)+"...";
        else return text;}
    
    /***** Adding outlets ******/
    function addOutlet(form,outlet,formvar,checked) {
        if (typeof checked === 'undefined') checked=true;
        var wrapper=getParent(form,".codexglossform");
        addClass(wrapper,"modified");
        var outletspan=getChild(form,".outlets");
        var outlet_id=((typeof outlet === 'string')?(outlet):(outlet._id));
        if (typeof outlet === 'string') {
            if ((outlet[0]==='@')||
                ((outlet[0]===':')&&(outlet[0]==='@')))
                outlet=Codex.sourcekb.ref(outlet);
            else {
                outlet={name: outlet};
                spanspec="span.checkspan.email";
                if (!(formvar)) formvar="EMAIL";}}
        else if (outlet.nodeType) {
            if (!(formvar)) formvar="NETWORK";
            outlet_id=outlet.getAttribute("value");
            outlet={name: outlet.getAttribute("key")||outlet_id};}
        else {}
        if (!(formvar)) formvar="SHARE";
        var inputs=getInputs(outletspan,formvar);
        var i=0; var lim=inputs.length;
        while (i<lim) {
            if (inputs[i].value===outlet_id) {
                var checkspan=getParent(inputs[i],".checkspan");
                setCheckSpan(checkspan,checked);
                return checkspan;}
            else i++;}
        var spanspec=("span.checkspan.outlet."+formvar.toLowerCase());
        var checkspan=fdjtUI.CheckSpan(
            spanspec,formvar||"SHARE",outlet_id,checked,
            "→",outlet.nick||outlet.name);
        if ((outlet.nick)&&(outlet.description))
            checkspan.title=outlet.name+": "+outlet.description;
        else if (outlet.description)
            checkspan.title=outlet.description;
        else checkspan.title=outlet.name;
        fdjtDOM(outletspan,checkspan," ");
        dropClass(outletspan,"empty");
        return checkspan;}
    Codex.addOutlet2Form=addOutlet;

    function clearOutlets(form){
        var outletspan=getChild(form,".outlets");
        fdjtDOM.replace(outletspan,fdjtDOM("span.outlets"));}
    function resetOutlets(form){
        var outletspan=getChild(form,".outlets");
        var outlets=getChildren(outletspan,".checkspan");
        var i=0, lim=outlets.length;
        while (i<lim) {
            var span=outlets[i++];
            setCheckSpan(span,false);}}
    
    /***** Adding links ******/
    function addLink(form,url,title) {
        var linkselt=getChild(form,'.links');
        var linkval=((title)?(url+" "+title):(url));
        var img=fdjtDOM.Image(cxicon("diaglink",32,32),"img");
        var anchor=fdjtDOM.Anchor(url,"a.glosslink",((title)||url));
        var checkbox=fdjtDOM.Checkbox("LINKS",linkval,true);
        var aspan=fdjtDOM("span.checkspan.ischecked.waschecked.anchor",
                          img,checkbox,anchor,
                          fdjtDOM.Image(cxicon("redx",32,32),"img.redx","x"));
        var wrapper=getParent(form,".codexglossform");
        addClass(wrapper,"modified");
        aspan.title=url; anchor.target='_blank';
        fdjtDOM(linkselt,aspan," ");
        dropClass(linkselt,"empty");
        updateForm(form);
        return aspan;}
    Codex.addLink2Form=addLink;

    /***** Adding excerpts ******/
    function setExcerpt(form,excerpt,off) {
        var checkspan=getChild(form,'.excerpt');
        var input=getInput(checkspan,'EXCERPT');
        var exoff=getInput(form,'EXOFF');
        var text=getChild(checkspan,'.text');
        if (fdjtString.isEmpty(excerpt)) excerpt=false;
        if (excerpt) {
            input.value=excerpt;
            if (exoff) {
                if (off) exoff.value=off;
                else exoff.value="";}
            dropClass(checkspan,"empty");
            fdjtDOM.replace(text,Ellipsis("span.text",excerpt,[25,15]));
            setCheckSpan(checkspan,true);}
	else if ((off)&&(off<0)) {
	    // This clears the entry altogether
            addClass(checkspan,"empty");
            if (exoff) exoff.value="";
	    input.value="";
	    if (text) fdjtDOM.replace(text,fdjtDOM("span.text"));
            setCheckSpan(checkspan,false);}
        else {
            addClass(checkspan,"empty");
            if (exoff) exoff.value="";
            setCheckSpan(checkspan,false);}
        var wrapper=getParent(form,".codexglossform");
        // addClass(wrapper,"modified");
        updateForm(form);}
    Codex.setExcerpt=setExcerpt;

    var Ref=fdjtKB.Ref;

    /***** Adding tags ******/
    function addTag(form,tag,varname,checked,knodule) {
        // fdjtLog("Adding %o to tags for %o",tag,form);
        if (!(tag)) tag=form;
        if (form.tagName!=='FORM')
            form=getParent(form,'form')||form;
        if (!(knodule)) knodule=Codex.getMakerKnodule(Codex.user);
        var wrapper=getParent(form,".codexglossform");
        addClass(wrapper,"modified");
        var tagselt=getChild(form,'.tags');
        var info; var title=false; var textspec='span.term';
        if (!(varname)) varname='TAGS';
        if ((tag.nodeType)&&(hasClass(tag,'completion'))) {
            if (hasClass(tag,'outlet')) {
                varname='SHARED'; textspec='span.outlet';}
            else if (hasClass(tag,'source')) {
                varname='SHARE'; textspec='span.source';}
            else {}
            if (tag.title) title=tag.title;
            tag=gloss_cloud.getValue(tag);
            if (hasClass(form,"editnote")) {
                var input=getInput(form,"NOTE");
                // This erases whatever was being typed
                if (input) getbracketed(input,false);}}
        var ref=
            ((tag instanceof Ref)?(tag):
             ((typeof tag === 'string')&&
              ((tag.indexOf('|')>0)?
               (knodule.handleSubjectEntry(tag)):
               (tag.indexOf('@')>=0)?(fdjtKB.ref(tag)):
               (knodule.probe(tag)))));
        var text=
            ((ref)?
             (((ref.toHTML)&&(ref.toHTML()))||
              ref.name||ref.dterm||ref.EN||ref._qid||ref._id):
             (typeof tag === "string")?(tag):
             (tag.toString()));
        var tagval=tag;
        if (ref) {
            if (ref.knodule===knodule) tagval=ref.dterm;
            else tagval=ref._qid||ref._id||ref.dterm||ref.name||tag;}
        if ((ref)&&(ref.pool===Codex.sourcekb)) varname='SHARED';
        var checkspans=getChildren(tagselt,".checkspan");
        var i=0; var lim=checkspans.length;
        while (i<lim) {
            var cspan=checkspans[i++];
            if (((cspan.getAttribute("varname"))===varname)&&
                ((cspan.getAttribute("tagval"))===tagval)) {
                if ((typeof checked === 'undefined')||(checked))
                    addClass(cspan,"waschecked");
                return cspan;}}
        var span=fdjtUI.CheckSpan(
            "span.checkspan",varname,tagval,
            ((typeof checked === 'undefined')||(checked)));
        if ((typeof checked === 'undefined')||(checked))
            addClass(span,"waschecked");
        if (title) span.title=title;
        span.setAttribute("varname",varname);
        span.setAttribute("tagval",tag);
        addClass(span,((varname.toLowerCase())+"var"));
        if (typeof text === 'string')
            fdjtDOM.append(span,fdjtDOM(textspec,text));
        else fdjtDOM.append(span,text);
        fdjtDOM.append(tagselt,span," ");
        dropClass(tagselt,"empty");
        updateForm(form);
        return span;}
    Codex.addTag2Form=addTag;

    Codex.setGlossNetwork=function(form,network,checked){
        if (typeof form === 'string') form=fdjtID(form);
        if (!(form)) return;
        var input=getInput(form,'NETWORKS',network);
        if (!(input)) return;
        var cs=getParent(input,".checkspan");
        if (!(cs)) return;
        setCheckSpan(cs,checked);};

    /***** Setting the gloss target ******/

    // The target can be either a passage or another gloss
    function setGlossTarget(target,form){
        if (Codex.glosstarget) {
            dropClass(Codex.glosstarget,"codexglosstarget");}
        if (!(target)) {
            var cur=fdjtID("CODEXLIVEGLOSS");
            if (cur) cur.id=null;
            Codex.glosstarget=false;
            if (Codex.selecting) {
                Codex.selecting.clear();
                Codex.selecting=false;}
            return;}
        if (!gloss_cloud) Codex.glossCloud();
        var gloss=false;
	// Identify when the target is a gloss
        if ((typeof target === 'string')&&(fdjtID(target))) 
            target=fdjtID(target);
        else if ((typeof target === 'string')&&
                 (Codex.glosses.ref(target))) {
            gloss=Codex.glosses.ref(target);
            target=fdjtID(gloss.frag);}
        else if (target.pool===Codex.glosses) {
            gloss=target; target=fdjtID(gloss.frag);}
        else {}
	if ((gloss)&&(form)&&(!(form.nodeType))) {
	    // Passing a non-false non-node as a form forces a
	    // response, even if the user is the maker of the gloss
	    form=getGlossForm(gloss,true);}
	// Handle or create the form
	if (form) {
	    var frag=fdjtDOM.getInput(form,"FRAG");
	    if (frag.value!==target.id) {
		setExcerpt(form,false);
		fdjtDOM.addClass(form,"modified");
		frag.value=target.id;}}
	else {
	    if (gloss) form=getGlossForm(gloss);
	    else form=getGlossForm(target);
            if (!(form)) {
		fdjtUI.alert("There was a problem adding a gloss");
		return false;}}
        Codex.glosstarget=target;
        addClass(target,"codexglosstarget");
        Codex.GoTo(target,"addgloss",true);
        setCloudCuesFromTarget(gloss_cloud,target);
        setGlossForm(form);
        // Clear current selection and set up new selection
        if (Codex.selecting) {
            Codex.selecting.clear();
            Codex.selecting=false;}
        Codex.clearHighlights(target);
        var dups=Codex.getDups(target);
        Codex.selecting=
            fdjt.UI.Selecting(
                dups,{ontap: gloss_selecting_ontap,
                      onrelease: gloss_selecting_onrelease,
                      fortouch: Codex.touch,
                      holdthresh: 250,
                      movethresh: 250});
        if ((gloss)&&(gloss.excerpt)&&(gloss.excerpt.length))
            Codex.selecting.setString(gloss.excerpt);
        Codex.selecting.onchange=function(sel){
            var string=this.getString();
            var off=this.getOffset();
            Codex.setExcerpt(form,string,off);};
        return form;}
    Codex.setGlossTarget=setGlossTarget;

    var selecting_ontap=fdjt.UI.Selecting.tap_handler;
    function gloss_selecting_ontap(evt){
        if (Codex.mode!=="addgloss") {
            Codex.setMode("addgloss");
            fdjtUI.cancel(evt);}
        else if (Codex.hudup) {
            Codex.setHUD(false,false);
            fdjtUI.cancel(evt);}
        else return selecting_ontap(evt);}
    function gloss_selecting_onrelease(evt){
        evt=evt||event;
        Codex.UI.content_release(evt);
        Codex.setMode("addgloss");
        Codex.setHUD(true);}

    function setGlossForm(form){
        var cur=fdjtID("CODEXLIVEGLOSS");
        if (cur) cur.id=null;
        if (!(form)) {
	    Codex.glossform=false;
	    return;}
        form.id="CODEXLIVEGLOSS";
	Codex.glossform=form;
        var form_elt=getChild(form,"FORM");
        var mode=form_elt.className;
	var noteinput=getInput(form,"NOTE");
        var syncelt=getInput(form,"SYNC");
        syncelt.value=(Codex.syncstamp+1);
        /* Get the input appropriate to the mode. */
        if (mode==='editnote') {
            if (noteinput)
                gloss_cloud.complete(getbracketed(noteinput,false)||"");
            else gloss_cloud.complete("");}
        
        /* Do completions based on those input's values */
        Codex.outletCloud().complete();
        Codex.glossCloud().complete();}
    Codex.setGlossForm=setGlossForm;
    
    function setCloudCues(cloud,tags){
        // Clear any current tagcues from the last gloss
        var cursoft=getChildren(cloud.dom,".cue.softcue");
        var i=0; var lim=cursoft.length;
        while (i<lim) {
            var cur=cursoft[i++];
            dropClass(cur,"cue");
            dropClass(cur,"softcue");}
        // Get the tags on this element as cues
        var newcues=cloud.getByValue(tags);
        var i=0; var lim=newcues.length;
        while (i<lim) {
            var completion=newcues[i++];
            if (!(hasClass(completion,"cue"))) {
                addClass(completion,"cue");
                addClass(completion,"softcue");}}}
    function setCloudCuesFromTarget(cloud,target){
        var tags=[];
        var targetid=((target.codexbaseid)||(target.id));
        var info=Codex.docinfo[targetid];
        var glosses=Codex.glosses.find('frag',targetid);
        var knodule=Codex.knodule;
        if ((info)&&(info.tags)) tags=tags.concat(info.tags);
        if ((info)&&(info.autotags)&&(info.autotags.length)) {
            var autotags=info.autotags; var j=0; var jlim=autotags.length;
            while (j<jlim) {
                var kn=knodule.probe(autotags[j]);
                if (kn) tags.push(kn.tagString());
                j++;}}
        var i=0; var lim=glosses.length;
        while (i<lim) {
            var g=glosses[i++]; var gtags=g.tags;
            if (gtags) tags=tags.concat(gtags);}
        setCloudCues(cloud,tags);}
    Codex.setCloudCues=setCloudCues;
    Codex.setCloudCuesFromTarget=setCloudCuesFromTarget;
    
    /* Text handling for the gloss text input */

    var addgloss_timer=false;
    
    function handleBracketed(form,content,complete){
        dropClass("CODEXHEART","tagging");
        if (content[0]==='@') {
            var brk=content.indexOf(' ');
            if (brk<0) addLink(form,content.slice(1));
            else {
                addLink(form,content.slice(1,brk),
                        content.slice(brk+1));}}
        else if (content.indexOf('|')>=0) addTag(form,content);
        else {
            var completions=gloss_cloud.complete(content);
            if (!(completions)) {
                addTag(form,content);
                return;}
            var i=0; var lim=completions.length;
            var std=fdjtString.stdspace(content);
            while (i<lim) {
                var completion=completions[i++];
                if (content===gloss_cloud.getKey(completion)) {
                    addTag(form,completion);
                    return;}}
            if ((complete)&&(completions.length))
                addTag(form,completions[0]);      
            else addTag(form,std);
            gloss_cloud.complete("");}}

    function addlink_keypress(evt){
        var target=fdjtUI.T(evt);
        var content=target.value;
        var form=getParent(target,"FORM");
        var ch=evt.keyCode;
        if (ch===13) {
            if (fdjtString.isEmpty(content)) {
                submitEvent(target);
                return;}
            var brk=content.indexOf(' ');
            if (brk<0) addLink(form,content);
            else {
                addLink(form,content.slice(0,brk),
                        content.slice(brk+1));}
            fdjtUI.cancel(evt);
            target.value="";}}

    /* This handles embedded brackets */
    function noteinput_keypress(evt){
        var target=fdjtUI.T(evt);
        var string=target.value;
        var form=getParent(target,"FORM");
        var ch=evt.charCode;
        var wrapper=getParent(form,".codexglossform");
        addClass(wrapper,"modified");
        if (addgloss_timer) clearTimeout(addgloss_timer);
        if (ch===91) { /* [ */
            var pos=target.selectionStart, lim=string.length;
            if ((pos>0)&&(string[pos-1]==='\\')) return; 
            fdjtUI.cancel(evt);
            target.value=string.slice(0,pos)+"[]"+string.slice(pos);
            target.selectionStart=target.selectionEnd=pos+1;}
        else if (ch===93) { /* ] */
            var pos=target.selectionStart;
            if ((pos>0)&&(string[pos-1]==='\\')) return; 
            var content=getbracketed(target,true);
            if (!(content)) return;
            fdjtUI.cancel(evt);
            handleBracketed(form,content);}
        else {
            var content=getbracketed(target);
            if ((typeof content==='string')&& (content[0]!=='@'))
                addgloss_timer=setTimeout(function(){
                    var span=getbracketed(target,false);
                    // fdjtLog("Completing on %s",span);
                    if (span[0]!=='@') gloss_cloud.complete(span);},
                                          200);}}

    function noteinput_keydown(evt){
        evt=evt||event;
        var kc=evt.keyCode;
        var target=fdjtUI.T(evt);
        var form=getParent(target,'form');
        var mode=getGlossMode(form);
        if (kc===13) { // newline/enter
            if (!(mode)) {submitEvent(form);}
            else {
                var bracketed=getbracketed(target);
                if (bracketed) {
                    fdjtUI.cancel(evt);
                    handleBracketed(form,getbracketed(target,true),true);}
                else if (evt.ctrlKey) {
                    fdjtUI.cancel(evt);
                    submitEvent(target);}
                else if (!(evt.shiftKey)) {
                    fdjtUI.cancel(evt);
                    dropClass(form,"editnote");}
                else fdjtUI.cancelBubble(evt);}}
        else if (mode) {}
        else if ((kc===35)||(kc===91)) // # or [
            setGlossMode("addtag",form);
        else if (kc===32) // Space
            setGlossMode("editnote",form);
        else if ((kc===47)||(kc===58)) // /or :
            setGlossMode("addlink",form);
        else if ((kc===64)) // @
            setGlossMode("sharing",form);
        else {}}

    function get_addgloss_callback(form){
        return function(req){
            return addgloss_callback(req,form);}}

    function addgloss_callback(req,form){
        if (Codex.Trace.network)
            fdjtLog("Got AJAX gloss response %o from %o",req,sbook_mark_uri);
        dropClass(form.parentNode,"submitting");
        var json=JSON.parse(req.responseText);
        var ref=Codex.glosses.Import(json);
        fdjtDOM.remove(form.parentNode);
        var reps=document.getElementsByName(json.uuid);
        var i=0, lim=reps.length;
        while (i<lim) {
            var rep=reps[i++];
            if (hasClass(rep,"codexcard"))
                fdjtDOM.replace(rep,Codex.renderCard(ref));}
        /* Turn off the target lock */
        setGlossTarget(false);
        Codex.setTarget(false);
        Codex.setMode(false);}

    function clearGlossForm(form){
        // Clear the UUID, and other fields
        var uuid=getInput(form,"UUID");
        if (uuid) uuid.value="";
        var note=getInput(form,"NOTE");
        if (note) note.value="";
        var href=getInput(form,"HREF");
        if (href) href.value="";
        var tagselt=getChildren(form,".tags");
        if ((tagselt)&&(tagselt.length)) {
            var tags=getChildren(tagselt[0],".checkspan");
            fdjtDOM.remove(fdjtDOM.Array(tags));}}

    /***** The Gloss Cloud *****/

    var gloss_cloud=false;
    
    /* The completions element */
    function glossCloud(){
        if (gloss_cloud) return gloss_cloud;
        var completions=fdjtID("CODEXGLOSSCLOUD");
        completions.onclick=glosscloud_ontap;
        Codex.gloss_cloud=gloss_cloud=
            new fdjtUI.Completions(
                completions,fdjtID("CODEXTAGINPUT"),
                fdjtUI.FDJT_COMPLETE_OPTIONS|
                    fdjtUI.FDJT_COMPLETE_CLOUD|
                    fdjtUI.FDJT_COMPLETE_ANYWORD);
        return gloss_cloud;}
    Codex.glossCloud=glossCloud;
    
    function glosscloud_ontap(evt){
        var target=fdjtUI.T(evt);
        var completion=getParent(target,'.completion');
        if (completion) {
            var live=fdjtID("CODEXLIVEGLOSS");
            var form=((live)&&(getChild(live,"form")));
            addTag(form,completion);}
        fdjtUI.cancel(evt);}

    /***** The Outlet Cloud *****/

    var outlet_cloud=false;
    
    /* The completions element for outlets */
    function outletCloud(){
        if (outlet_cloud) return outlet_cloud;
        var completions=fdjtID("CODEXOUTLETCLOUD");
        completions.onclick=outletcloud_ontap;
        Codex.outlet_cloud=outlet_cloud=
            new fdjtUI.Completions(
                completions,fdjtID("CODEXOUTLETINPUT"),
                fdjtUI.FDJT_COMPLETE_OPTIONS|
                    fdjtUI.FDJT_COMPLETE_CLOUD|
                    fdjtUI.FDJT_COMPLETE_ANYWORD);
        var queue=Codex.outlet_cloud_queue;
        Codex.outlet_cloud_queue=[];
        Codex.addOutlets2UI(queue);
        return outlet_cloud;}
    Codex.outletCloud=outletCloud;
    
    function outletcloud_ontap(evt){
        var target=fdjtUI.T(evt);
        var completion=getParent(target,'.completion');
        if (completion) {
            var live=fdjtID("CODEXLIVEGLOSS");
            var form=((live)&&(getChild(live,"form")));
            if (hasClass(completion,"source")) {
                var value=completion.getAttribute("value");
                if (value) addOutlet(form,fdjtKB.ref(value),"SHARE");}
            else if (hasClass(completion,"network")) 
                addOutlet(form,completion,"NETWORK");
            else if (hasClass(completion,"email")) 
                if (value) addOutlet(form,completion,"EMAIL");
            else addOutlet(form,completion);}
        fdjtUI.cancel(evt);}

    /***** Saving (submitting/queueing) glosses *****/

    // Submits a gloss, queueing it if offline.
    function submitGloss(evt){
        evt=evt||event||null;
        var target=fdjtUI.T(evt);
        addClass(target.parentNode,"submitting");
        var form=(fdjtUI.T(evt));
        var proto=fdjtID();
        if (!((hasParent(form,".glossedit"))||(hasParent(form,".glossreply"))))
            // Only save defaults if adding a new gloss (what about reply?)
            saveGlossDefaults(form,getChild("CODEXADDGLOSSPROTOTYPE","FORM"));
        var uuidelt=getInput(form,"UUID");
        if (!((uuidelt)&&(uuidelt.value)&&(uuidelt.value.length>5))) {
            fdjtLog.warn('missing UUID');
            if (uuidelt) uuidelt.value=fdjtState.getUUID(Codex.nodeid);}
        if (!(Codex.persist))
            return fdjt.Ajax.onsubmit(evt,get_addgloss_callback(target));
        var ref=Codex.glosses.ref
        if (!(navigator.onLine)) return queueGloss(form,evt);
        // Eventually, we'll unpack the AJAX handler to let it handle
        //  connection failures by calling queueGloss.
        else return fdjt.Ajax.onsubmit(evt,get_addgloss_callback(target));}
    Codex.submitGloss=submitGloss;

    function finishGloss(glossdiv){
        if (!(glossdiv)) glossdiv=fdjtID("CODEXLIVEGLOSS");
        if (!(glossdiv)) {
            fdjtLog.warn("finishGloss called with no gloss to finish");
            return;}
        var form=((glossdiv.tagName==="FORM")?(glossdiv):
                  (getChild(glossdiv,"FORM")));
        if (!(form)) {
            fdjtLog.warn("finishGloss can't find the form to submit");
            return;}
        var submit_event = document.createEvent("HTMLEvents");
        submit_event.initEvent('submit',false,true);
        form.dispatchEvent(submit_event);}
    Codex.finishGloss=finishGloss;

    function cancelGloss_handler(evt){
        evt=evt||event;
        var target=fdjtUI.T(evt);
        var glossform=(target)&&
            (fdjtDOM.getParent(target,".codexglossform"));
        /* 
        if (fdjtDOM.hasClass(glossform,"modified")) {
            if (window.confirm("Save the changes to this gloss?"))
                finishGloss(target);
            else cancelGloss(target);}
        */
        cancelGloss(target);
        fdjtUI.cancel(evt);}

    function cancelGloss(arg){
        var evt=arg||event||null;
        var target=((!arg)?(fdjtID("CODEXLIVEGLOSS")):
                    (arg.nodeType)?(arg):(fdjtUI.T(arg)));
        var glossform=(target)&&
            (fdjtDOM.getParent(target,".codexglossform"));
        setGlossTarget(false);
        Codex.setMode(false);
        if ((arg)&&((arg.cancelable)||(arg.bubbles))) {
            fdjtUI.cancel(evt);}
        if (glossform) fdjtDOM.remove(glossform);}
    Codex.cancelGloss=cancelGloss;

    // We save gloss defaults on the prototype gloss form hidden in the DOM
    function saveGlossDefaults(form,proto){
        // Save gloss mode (??)
        var mode=form.className;
        swapClass(proto,glossmodes,mode);
        // Save post setting
        var post=getInput(form,"POSTGLOSS");
        var proto_post=getInput(form,"POSTGLOSS");
        setCheckSpan(proto_post,post.checked);
        // Save network settings
        var networks=getInputs(form,"NETWORKS");
        var i=0, lim=networks.length;
        while (i<lim) {
            var input=networks[i++];
            var proto_input=getInputFor(form,"NETWORKS",input.value);
            setCheckSpan(proto_input,input.checked);}
        // Save outlets
        clearOutlets(proto);
        var shared=getChild(form,".outlets");
        var inputs=getChildren(shared,"INPUT");
        // Here's the logic: we save all checked outlets and any
        // others up to 5.
        var i=0, lim=inputs.length, n_added=0;
        while (i<lim) {
            var input=inputs[i++];
            if (input.checked) {
                var checkspan=addOutlet(
                    proto,input.value,input.name,input.checked);
                addClass(checkspan,"waschecked");
                n_added++;}}
        if (n_added<6) {
            i=0; while (i<lim) {
                var input=inputs[i++];
                if (n_added>5) continue;
                if (!(input.checked)) {
                    var checkspan=addOutlet(
                        proto,input.value,input.name,input.checked);
                    n_added++;}}}}

    // Queues a gloss when offline
    function queueGloss(form,evt){
        var json=fdjt.Ajax.formJSON(form,["tags","xrefs"],true);
        var params=fdjt.Ajax.formParams(form);
        var queued=fdjtState.getLocal("queued("+Codex.refuri+")",true);
        if (!(queued)) queued=[];
        queued.push(json.uuid);
        var glossdata=
            {refuri: json.refuri,frag: json.frag,
             maker: json.user,_id: json.uuid,uuid: json.uuid,
             qid: json.uuid,gloss: json.uuid,
             created: fdjtTime()};
        glossdata.tstamp=fdjtTime.tick();
        if ((json.note)&&(!(fdjtString.isEmpty(json.note))))
            glossdata.note=json.note;
        if ((json.excerpt)&&(!(fdjtString.isEmpty(json.excerpt)))) {
            glossdata.excerpt=json.excerpt;
	    glossdata.exoff=json.exoff;}
        if ((json.details)&&(!(fdjtString.isEmpty(json.details))))
            glossdata.details=json.details;
        if ((json.tags)&&(json.tags.length>0)) glossdata.tags=json.tags;
        if ((json.xrefs)&&(json.xrefs.length>0)) glossdata.xrefs=json.xrefs;
        Codex.glosses.Import(glossdata);
        fdjtState.setLocal("params("+json.uuid+")",params);
        fdjtState.setLocal("queued("+Codex.refuri+")",queued,true);
        // Clear the UUID
        clearGlossForm(form);
        if (evt) fdjtUI.cancel(evt);
        dropClass(form.parentNode,"submitting");
        /* Turn off the target lock */
        setGlossTarget(false); Codex.setTarget(false); Codex.setMode(false);}

    // Saves queued glosses
    function writeGlosses(){
        if (!(Codex.persist)) return;
        var queued=fdjtState.getLocal("queued("+Codex.refuri+")",true);
        if ((!(queued))||(queued.length===0)) {
            fdjtState.dropLocal("queued("+Codex.refuri+")");
            return;}
        var ajax_uri=getChild(fdjtID("CODEXADDGLOSSPROTOTYPE"),"form").
            getAttribute("ajaxaction");
        var i=0; var lim=queued.length; var pending=[];
        while (i<lim) {
            var uuid=queued[i++];
            var params=fdjtState.getLocal("params("+uuid+")");
            if (params) pending.push(uuid);
            var req=new XMLHttpRequest();
            req.open('POST',ajax_uri);
            req.withCredentials='yes';
            req.onreadystatechange=function () {
                if ((req.readyState === 4) &&
                    (req.status>=200) && (req.status<300)) {
                    fdjtState.dropLocal("params("+uuid+")");
                    oncallback(req);}};
            try {
                req.setRequestHeader
                ("Content-type", "application/x-www-form-urlencoded");
                req.send(params);}
            catch (ex) {failed.push(uuid);}}
        if ((pending)&&(pending.length))
            fdjtState.setLocal("queued("+Codex.refuri+")",pending,true);
        else fdjtState.dropLocal("queued("+Codex.refuri+")");
        if ((pending)&&(pending.length>0)) return pending;
        else return false;}
    Codex.writeGlosses=writeGlosses;
    
    /* Gloss display */

    var objectkey=fdjtKB.objectkey;

    function glossBlock(id,spec,xfeatures,glosses,detail){
        var docinfo=Codex.docinfo[id];
        var all=[].concat(xfeatures||[]);
        var freq={}; var notes={}; var links={};
        var excerpt=false, exoff=0;
        if (!(glosses)) glosses=Codex.glosses.find('frag',id);
        // Initialize given features
        var i=0; var lim=all.length;
        while (i<lim) freq[all[i++]]=1;
        // Scan glosses
        var i=0; var lim=glosses.length;
        while (i<lim) {
            var gloss=glosses[i++]; var glossid;
            if (typeof gloss === 'string') {
                glossid=gloss; gloss=Codex.glosses.ref(glossid);}
            else glossid=gloss._id;
            var user=gloss.maker;
            var sources=gloss.audience;
            var tags=gloss.tags;
            if ((gloss.excerpt)&&(!(excerpt))) {
                excerpt=gloss.excerpt; exoff=gloss.exoff;}
            if ((sources)&&(!(sources instanceof Array))) sources=[sources];
            if ((tags)&&(!(tags instanceof Array))) tags=[tags];
            if (freq[user]) freq[user]++;
            else {freq[user]=1; all.push(user);}
            if (gloss.note) {
                if (notes[user]) fdjtKB.add(notes,user,glossid,true);
                else notes[user]=[glossid];}
            if (gloss.link) {
                if (links[user]) fdjtKB.add(links,user,glossid,true);
                else links[user]=[glossid];}
            if (sources) {
                var j=0; var jlim=sources.length;
                while (j<jlim) {
                    var source=sources[j++];
                    if (freq[source]) freq[source]++;
                    else {freq[source]=1; all.push(source);}
                    if (gloss.note) {
                        if (notes[source])
                            fdjtKB.add(notes,source,glossid,true);
                        else notes[source]=[glossid];}
                    if (gloss.link) {
                        if (links[source])
                            fdjtKB.add(links,source,glossid,true);
                        else links[source]=[glossid];}}}
            if (tags) {
                var j=0; var jlim=tags.length;
                while (j<jlim) {
                    var tag=tags[j++];
                    if (typeof tag === 'object') tag=objectkey(tag);
                    if (freq[tag]) freq[tag]++;
                    else {freq[tag]=1; all.push(tag);}}}}
        var tags=docinfo.tags;
        if ((tags)&&(!(tags instanceof Array))) tags=[tags];
        if (tags) {
            var i=0; var lim=tags.length;
            while (i<lim) {
                var tag=tags[i++];
                if (typeof tag === 'object') tag=objectkey(tag);
                if (freq[tag]) freq[tag]++;
                else {freq[tag]=1; all.push(tag);}}}
        var info=fdjtDOM(spec||"div.sbookgloss");
        var i=0; var lim=all.length;
        while (i<lim) {
            var tag=all[i]; var span=false;
            var taginfo=fdjtKB.ref(tag);
            if ((taginfo)&&(taginfo.kind)) {
                var srcspan=fdjtDOM("span.source",taginfo.name||tag);
                srcspan.setAttribute("tag",(((taginfo)&&(taginfo._id))||tag));
                span=fdjtDOM("span",srcspan);
                if (links[tag]) {
                    var sg=links[tag];
                    var j=0; var jlim=sg.length;
                    while (j<jlim) {
                        var icon=fdjtDOM.Image(cxicon("diaglink",64,64));
                        var gloss=Codex.glosses.ref(sg[j++]);
                        var anchor=fdjtDOM.Anchor(gloss.link,"a",icon);
                        anchor.title=gloss.note;
                        fdjtDOM(span," ",anchor);}}
                if (notes[tag]) {
                    var sg=notes[tag];
                    var j=0; var jlim=sg.length;
                    var icon=fdjtDOM.Image(cxicon("remark",64,64));
                    while (j<jlim) {
                        var gloss=Codex.glosses.ref(sg[j++]);
                        icon.title=gloss.note; fdjtDOM(span," ",icon);}}}
            else {
                span=fdjtDOM("span.dterm",taginfo||tag);
                span.setAttribute("tag",(((taginfo)&&(taginfo._id))||tag));}
            fdjtDOM(info,((i>0)&&(" \u00b7 ")),span);
            i++;}
        if (excerpt) {
            var range=fdjtDOM.findString(fdjtID(frag),excerpt,exoff);
            if (range) fdjtUI.Highlight(range,"highlightexcerpt");}
        else addClass(fdjtID(frag),"highlightpassage");
        info.onclick=sbookgloss_ontap;
        return info;}
    Codex.glossBlock=glossBlock;

    function sbookgloss_ontap(evt){
        var target=fdjtUI.T(evt);
        var parent=false;
        while (target) {
            if (!(target.getAttribute)) target=target.parentNode;
            else if (target.getAttribute("gloss")) 
                return Codex.showGloss(target.getAttribute("gloss"));
            else if (target.getAttribute("tag"))
                return Codex.startSearch(target.getAttribute("tag"));
            else if (target.getAttribute("source"))
                return Codex.startSearch(target.getAttribute("source"));
            else target=target.parentNode;}
        fdjtUI.cancel(evt);}

})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
/* -*- Mode: Javascript; Character-encoding: utf-8; -*- */

/* ###################### codex/layout.js ###################### */

/* Copyright (C) 2009-2012 beingmeta, inc.
   This file implements a Javascript/DHTML UI for reading
   large structured documents (sBooks).

   For more information on sbooks, visit www.sbooks.net
   For more information on knodules, visit www.knodules.net
   For more information about beingmeta, visit www.beingmeta.com

   This library uses the FDJT (www.fdjt.org) toolkit.

   This program comes with absolutely NO WARRANTY, including implied
   warranties of merchantability or fitness for any particular
   purpose.

   Use and redistribution (especially embedding in other
   CC licensed content) is permitted under the terms of the
   Creative Commons "Attribution-NonCommercial" license:

   http://creativecommons.org/licenses/by-nc/3.0/ 

   Other uses may be allowed based on prior agreement with
   beingmeta, inc.  Inquiries can be addressed to:

   licensing@beingmeta.com

   Enjoy!

*/

/* Reporting progress, debugging */
        
Codex.Paginate=
    (function(){

        var fdjtString=fdjt.String;
        var fdjtState=fdjt.State;
        var fdjtTime=fdjt.Time;
        var fdjtLog=fdjt.Log;
        var fdjtDOM=fdjt.DOM;
        var fdjtUI=fdjt.UI;
        var fdjtKB=fdjt.KB, fdjtID=fdjt.ID;
        var CodexLayout=fdjt.CodexLayout;

        var getGeometry=fdjtDOM.getGeometry;
        var getParent=fdjtDOM.getParent;
        var getChildren=fdjtDOM.getChildren;
        var hasClass=fdjtDOM.hasClass;
        var addClass=fdjtDOM.addClass;
        var dropClass=fdjtDOM.dropClass;
        var TOA=fdjtDOM.toArray;
        var isEmpty=fdjtString.isEmpty;
        var secs2short=fdjtTime.secs2short;
        var rootloop_skip=50;
        
        var atoi=parseInt;

        function Paginate(why,init){
            if (((Codex.layout)&&(!(Codex.layout.done)))) return;
            if (!(why)) why="because";
            dropClass(document.body,"cxSCROLL");
            addClass(document.body,"cxLAYOUT");
            var forced=((init)&&(init.forced));
            var height=getGeometry(fdjtID("CODEXPAGE")).height;
            var width=getGeometry(fdjtID("CODEXPAGE")).width;
            var bodysize=Codex.bodysize||"normal";
            var bodyfamily=Codex.bodyfamily||"serif";
            if (Codex.layout) {
                var current=Codex.layout;
                if ((!(forced))&&
                    (width===current.page_width)&&
                    (height===current.page_height)&&
                    (bodysize===current.bodysize)&&
                    (bodyfamily===current.bodyfamily)) {
                    fdjtLog("Skipping redundant pagination %j",current);
                    return;}
                // Repaginating, start with reversion
                Codex.layout.Revert();
                Codex.layout=false;}

            // Create a new layout
            var layout=new CodexLayout(getLayoutArgs());
            layout.bodysize=bodysize; layout.bodyfamily=bodyfamily;
            Codex.layout=layout;
            
            // Prepare to do the layout
            dropClass(document.body,"cxSCROLL");
            addClass(document.body,"cxBYPAGE");
            fdjtID("CODEXPAGE").style.visibility='hidden';
            fdjtID("CODEXCONTENT").style.visibility='hidden';
            
            // Now make the content (temporarily) the save width as
            // the page
            var saved_width=Codex.content.style.width;
            Codex.content.style.width=getGeometry(Codex.page).width+"px";

            // Now walk the content
            var content=Codex.content;
            var nodes=TOA(content.childNodes);
            fdjtLog("Laying out %d root nodes into %dx%d pages (%s)",
                    nodes.length,layout.width,layout.height,
                    (why||""));

            // Do the adjust font bit.  We rely on Codex.content
            //  having the same width as Codex.page
            fdjt.DOM.adjustFonts(content);

            // Now reset the width
            Codex.content.style.width=saved_width;

            // Get the document info
            var docinfo=Codex.docinfo;

            /* Lay out the coverpage */
            var coverpage=Codex.getCover();
            if (coverpage) layout.addContent(coverpage);
            
            var textWidth=fdjtDOM.textWidth;
            var hasText=fdjtDOM.hasText;

            function getPageTop(node) {
                if (hasClass(node,"codexpage")) {}
                else if ((node.id)&&(docinfo[node.id])) {
                    if (hasText(node)) return node;}
                else if ((node.codexbaseid)&&(docinfo[node.codexbaseid])) {
                    if (hasText(node)) return node;}
                else {}
                var children=node.childNodes;
                if (children) {
                    var i=0; var lim=children.length;
                    while (i<lim) {
                        var child=children[i++];
                        if (child.nodeType===1) {
                            var first=getPageTop(child);
                            if (first) return first;}}}
                return false;}

            function getDupNode(under,id){
                var children;
                if (under.nodeType!==1) return false;
                else if (under.codexbaseid===id) return under;
                if (!(children=under.childNodes))
                    return false;
                else if (!(children.length)) return false;
                else {
                    var i=0, lim=children.length;
                    while (i<lim) {
                        var found=getDupNode(children[i++],id);
                        if (found) return found;}}}

            function getLocOff(pages,topstart,topnode){
                var id=topstart.id; var locoff=0;
                var pagescan=topstart, pagenum, elt=topstart;
                while (pagescan) {
                    if (hasClass(pagescan,"codexpage")) {
                        break;}
                    else pagescan=pagescan.parentNode;}
                if (!(pagescan)) return locoff;
                else pagenum=parseInt(pagescan.getAttribute("data-pagenum"));
                while ((elt)&&(elt!==topnode)) {
                    var width=textWidth(elt);
                    if (width) locoff=locoff+width;
                    pagescan=pages[++pagenum];
                    if (pagescan) elt=getDupNode(pagescan,id);}
                return locoff;}
                
            function getPageTops(pages){
                var j=0, jlim=pages.length, running=0;
                while (j<jlim) {
                    var page=pages[j++];
                    var topnode=getPageTop(page);
                    if (topnode) {
                        var topstart=document.getElementById(
                            topnode.codexbaseid||topnode.id);
                        var locoff=((topstart===topnode)?(0):
                                    (getLocOff(pages,topstart,topnode)));
                        var id=topstart.id; var info=docinfo[id];
                        page.setAttribute("data-topid",id);
                        page.setAttribute(
                            "data-sbookloc",info.starts_at+locoff);
                        running=info.starts_at+locoff;}
                    else {
                        page.setAttribute("data-sbookloc",running);}}}

            var i=0; var lim=nodes.length;
            function rootloop(){
                if (i>=lim) {
                    layout.Finish();
                    layout_progress(layout);
                    var pages=layout.pages;
                    getPageTops(layout.pages);
                    fdjtID("CODEXPAGE").style.visibility='';
                    fdjtID("CODEXCONTENT").style.visibility='';
                    dropClass(document.body,"cxLAYOUT");
                    Codex.layout=layout;
                    Codex.pagecount=layout.pages.length;
                    setupPageInfo();
                    if (Codex.layoutdone) {
                        var fn=Codex.layoutdone;
                        Codex.layoutdone=false;
                        fn();}
                    Codex.GoTo(
                        Codex.location||Codex.target||
                            Codex.cover||Codex.titlepage||
                            fdjtID("CODEXPAGE1"),
                        "endLayout",false,false);
                    Codex.layout.running=false;
                    return false;}
                else {
                    var root=nodes[i++];
                    var timeslice=layout.timeslice||CodexLayout.timeslice||200;
                    var timeskip=layout.timeskip||CodexLayout.timeskip||50;
                    if (((root.nodeType===3)&&(!(isEmpty(root.nodeValue))))||
                        ((root.nodeType===1)&&
                         (root.tagName!=='LINK')&&(root.tagName!=='META')&&
                         (root.tagName!=='SCRIPT')&&(root.tagName!=='BASE'))) 
                        layout.addContent(root,timeslice,timeskip,
                                          layout.tracelevel,
                                          layout_progress,rootloop);
                    else return rootloop();}}

                /* Reporting progress, debugging */
        
            function layout_progress(info){
                var tracelevel=info.tracelevel;
                var started=info.started;
                var pagenum=info.pagenum;
                var now=fdjtTime();
                if (!(pagenum)) return;
                if (info.done) {
                    LayoutMessage(fdjtString(
                        "Finished laying out %d %dx%d pages in %s",
                        pagenum,
                        secs2short((info.done-info.started)/1000)));
                    fdjtLog("Finished laying out %d %dx%d pages in %s",
                            pagenum,info.width,info.height,
                            secs2short((info.done-info.started)/1000));}
                else {
                    if ((info.lastid)&&(Codex.docinfo)&&
                        ((Codex.docinfo[info.lastid]))) {
                        var docinfo=Codex.docinfo;
                        var maxloc=docinfo._maxloc;
                        var lastloc=docinfo[info.lastid].starts_at;
                        var pct=(100*lastloc)/maxloc;
                        fdjtUI.ProgressBar.setProgress("CODEXLAYOUTMESSAGE",pct);
                        LayoutMessage(fdjtString(
                            "Laid out %d pages (%d%%) in %s",
                            pagenum,Math.floor(pct),
                            secs2short((now-started)/1000)));
                        if (tracelevel)
                            fdjtLog("Laid out %d pages (%d%%) in %s",
                                    pagenum,Math.floor(pct),
                                    secs2short((now-started)/1000));}
                    else {
                        LayoutMessage(fdjtString(
                            "Laid out %d pages in %s",
                            info.pagenum,secs2short((now-started)/1000)));
                        if (tracelevel)
                            fdjtLog("Laid out %d pages in %s",
                                    info.pagenum,secs2short((now-started)/1000));}}}
        
            function LayoutMessage(msg){
                fdjtUI.ProgressBar.setMessage("CODEXLAYOUTMESSAGE",msg);}
            
            rootloop();}
        Codex.Paginate=Paginate;

        CodexLayout.prototype.onresize=function(evt){
            var content=Codex.content; var page=Codex.page;
            var page_width=fdjtDOM.getGeometry(page).width;
            var content_width=fdjtDOM.getGeometry(content).width;
            var view_width=fdjtDOM.viewWidth();
            var view_height=fdjtDOM.viewHeight();
            var page_margin=(view_width-page_width)/2;
            var content_margin=(view_width-content_width)/2;
            if (page_margin!==50) {
                page.style.left=page_margin+'px';
                page.style.right=page_margin+'px';}
            else page.style.left=page.style.right='';
            if (content_margin!==50) {
                content.style.left=content_margin+'px';
                content.style.right=content_margin+'px';}
            else content.style.left=content.style.right='';
            fdjtID("CODEXHEART").style.maxHeight=(view_height-100)+'px';
            if (Codex.bypage) Codex.Paginate("resize");
            else fdjt.DOM.adjustFonts(Codex.content);
            fdjt.DOM.adjustFonts(Codex.HUD);};
        
        Codex.addConfig(
            "layout",
            function(name,val){
                Codex.page_style=val;
                if (val==='bypage') {
                    if (!(Codex.docinfo)) {
                        // If there isn't any docinfo (during startup, for
                        // instance), don't bother actually paginating.
                        Codex.bypage=true;}
                    else if (!(Codex.bypage)) {
                        // set this
                        Codex.bypage=true;
                        if (Codex.postconfig)
                            // If we're in the middle of config,
                            // push off the work of paginating
                            Codex.postconfig.push(Paginate);
                        // Otherwise, paginate away
                        else Codex.Paginate("config");}}
                else {
                    // If you've already paginated, revert
                    if (Codex.layout) {
                        Codex.layout.Revert();
                        Codex.layout=false;}
                    else if (((Codex.layout)&&(!(Codex.layout.done)))) {
                        if (Codex.layout.timer) {
                            clearTimeout(Codex.layout.timer);
                            Codex.layout.timer=false;}
                        Codex.layout.Revert();
                        Codex.layout=false;}
                    Codex.bypage=false;
                    if (Codex.layout) {
                        Codex.layout.Revert();
                        Codex.layout=false;}
                    dropClass(document.body,"cxBYPAGE");
                    addClass(document.body,"cxSCROLL");
                    fdjt.DOM.adjustFonts(Codex.content);}});

        function updateLayoutProperty(name,val){
            // This updates layout properties
            fdjtDOM.swapClass(
                Codex.page,new RegExp("codex"+name+"\w*"),"codex"+name+val);
            Codex[name]=val;
            if (Codex.layout) {
                // If you're already paginated, repaginate.  Either
                // when done with the config or immediately.
                if (Codex.postconfig) {
                    Codex.postconfig.push(function(){
                        Codex.setMode(true);
                        Codex.Paginate(name);});}
                else {
                    Codex.setMode(true);
                    Codex.Paginate(name);}}}
        Codex.addConfig("bodysize",updateLayoutProperty);
        Codex.addConfig("bodyfamily",updateLayoutProperty);
        
        function getLayoutArgs(){
            var height=getGeometry(fdjtID("CODEXPAGE"),false,true).inner_height;
            var width=getGeometry(fdjtID("CODEXPAGE"),false,true).width;
            var container=fdjtDOM("div.codexpages#CODEXPAGES");
            var pagerule=fdjtDOM.addCSSRule(
                "div.codexpage",
                "width: "+width+"px; "+"height: "+height+"px;");
            var args={page_height: height,page_width: width,
                      container: container,pagerule: pagerule,
                      tracelevel: Codex.Trace.layout,
                      logfn: fdjtLog};
            fdjtDOM.replace("CODEXPAGES",container);
            Codex.pages=container;
            
            var avoidbreakinside=
                fdjtDOM.sel(fdjtDOM.getMeta("avoidbreakinside",true));
            if (avoidbreakinside) args.avoidbreakinside=avoidbreakinside;

            var abb=fdjtDOM.getMeta("alwaysbreakbefore",true);
            var fbb=fdjtDOM.getMeta("forcebreakbefore",true);
            var forcebreakbefore=fdjtDOM.sel(abb.concat(fbb));
            if (forcebreakbefore) args.forcebreakbefore=forcebreakbefore;

            var aba=fdjtDOM.getMeta("alwaysbreakafter",true);
            var fba=fdjtDOM.getMeta("forcebreakafter",true);
            var forcebreakafter=fdjtDOM.sel(aba.concat(fba));
            if (forcebreakafter) args.forcebreakafter=forcebreakafter;

            var avoidbreakafter=
                fdjtDOM.sel(fdjtDOM.getMeta("avoidbreakafter",true));
            if (avoidbreakafter) args.avoidbreakafter=avoidbreakafter;

            var avoidbreakbefore=
                fdjtDOM.sel(fdjtDOM.getMeta("avoidbreakbefore",true));
            if (avoidbreakbefore) args.avoidbreakbefore=avoidbreakbefore;
            
            var fullpages=fdjtDOM.sel(fdjtDOM.getMeta("sbookfullpage",true));
            if (fullpages) fullpages.push("sbookfullpage");
            else fullpages=["sbookfullpage"];
            args.fullpages=fullpages;
            
            var floatpages=fdjtDOM.sel(fdjtDOM.getMeta("sbookfloatpage",true));
            if (floatpages) floatpages.push("sbookfloatpage");
            else floatpages=["sbookfloatpage"];
            args.floatpages=floatpages;

            var scaletopage=fdjtDOM.getMeta("sbookscaletopage",true);;
            if ((scaletopage)&&(scaletopage.length)) 
                scaletopage.push("sbookscaletopage");
            else scaletopage=["sbookscaletopage"];
            args.scaletopage=scaletopage=fdjtDOM.sel(scaletopage);
            
            if ((fdjtDOM.getMeta("Codex.dontbreakblocks"))||
                (fdjtDOM.getMeta("Codex.keepblocks"))||
                (fdjtDOM.getMeta("~=Codex.dontbreakblocks"))||
                (fdjtDOM.getMeta("~=Codex.keepblocks"))||
                (fdjtDOM.getMeta("~dontbreakblocks"))||
                (fdjtDOM.getMeta("~keepblocks")))
                args.break_blocks=false;
            else args.break_blocks=true;
            
            if ((fdjtDOM.getMeta("Codex.dontscalepages"))||
                (fdjtDOM.getMeta("~=Codex.dontscalepages"))||
                (fdjtDOM.getMeta("dontscalepages")))
                args.scale_pages=false;
            else args.scale_pages=true;

            return args;}
        CodexLayout.getLayoutArgs=getLayoutArgs;

        /* Updating the page display */

        function updatePageDisplay(pagenum,location,classname) {
            if (!(classname)) classname="current";
            var npages=Codex.pagecount;
            var book_len=Codex.ends_at;
            var page_elt=fdjt.ID("CODEXPAGESPAN"+pagenum);
            var cur=getChildren("CODEXPAGEINFO","."+classname);
            if (cur[0]!==page_elt) {
                dropClass(cur,classname);
                addClass(page_elt,classname);}
            var locoff;
            if (typeof location==='number') {
                var max_loc=Codex.ends_at;
                var pct=(100*location)/max_loc;
                // This is (very roughly) intended to be the precision needed
                //  for line level (40 character) accuracy.
                var prec=Math.round(Math.log(max_loc/40)/Math.log(10))-2;
                if (prec<0) prec=0;
                locoff=fdjtDOM(
                    "span.locoff#CODEXLOCOFF",
                    fdjtString.precString(pct,prec)+"%");
                locoff.title=location+"/"+max_loc;}
            else locoff=fdjtDOM("span.locoff#CODEXLOCOFF");
            var pageno_text=fdjtDOM(
                "span#CODEXPAGENOTEXT.pageno",pagenum,"/",npages);
            fdjtDOM.replace("CODEXPAGENOTEXT",pageno_text);
            fdjtDOM.replace("CODEXLOCOFF",locoff);
            locoff.title=
                ((locoff.title)||"")+
                ((locoff.title)?("; "):(""))+
                "click to jump to a percentage location in the book";
            fdjtDOM.addListeners(
                locoff,Codex.UI.handlers[Codex.ui]["#CODEXLOCOFF"]);
            pageno_text.title="click to jump to a particular page";
            fdjtDOM.addListeners(
                pageno_text,Codex.UI.handlers[Codex.ui]["#CODEXPAGENOTEXT"]);}
        Codex.updatePageDisplay=updatePageDisplay;
        
        /* Page info */
        
        function setupPageInfo(){
            var i=0, n=Codex.pagecount; var html=[];
            var spanwidth=
                (fdjtID("CODEXPAGEINFO").offsetWidth)/n;
            var pagespanrule=fdjtDOM.addCSSRule(
                "div.pagespans > span","width: "+spanwidth+"px;");
            while (i<n) {
                html.push("<span id='CODEXPAGESPAN"+(i+1)+"'"+
                          "title='p"+(i+1)+". Hold to glimpse, tap to jump'"+
                          ">"+(i+1)+"</span>");
                i++;}
            var spans=fdjtID("CODEXPAGESPANS");
            spans.innerHTML=html.join("");}
        Codex.setupPageInfo=setupPageInfo;
        
        /* Movement by pages */
        
        var curpage=false;
        
        function GoToPage(spec,caller,pushstate){
            if (typeof pushstate === 'undefined') pushstate=false;
            if (Codex.previewing) stopPreview("GoToPage");
            dropClass(document.body,"codexhelp");
            if (Codex.layout) {
                var page=Codex.layout.getPage(spec)||
                    Codex.layout.getPage(1);
                var pagenum=parseInt(page.getAttribute("data-pagenum"));
                if (Codex.Trace.flips)
                    fdjtLog("GoToPage/%s Flipping to %o (%d) for %o",
                            caller,page,pagenum,spec);
                if (curpage) {
                    dropClass(curpage,"nextpage");
                    addClass(curpage,"lastpage");
                    dropClass(curpage,"curpage");}
                addClass(page,"nextpage");
                addClass(page,"curpage");
                var lastpage=curpage, nextpage=page;
                setTimeout(function(){
                    dropClass(lastpage,"lastpage");
                    dropClass(nextpage,"nextpage");},
                           300);
                if (typeof spec === 'number') {
                    var location=parseInt(page.getAttribute("data-sbookloc"));
                    Codex.setLocation(location);}
                updatePageDisplay(pagenum,Codex.location);
                curpage=page; Codex.curpage=pagenum;
                if (pushstate) {
                    var curnode=fdjtID(page.getAttribute("data-topid"));
                    Codex.setHead(curnode);}
                if ((pushstate)&&(page)) {
                    Codex.setState(
                        {location: atoi(page.getAttribute("data-sbookloc")),
                         page: atoi(page.getAttribute("data-pagenum")),
                         target: Codex.target.id});}
                var glossed=fdjtDOM.$(".glossed",page);
                if (glossed) {
                    var addGlossmark=Codex.UI.addGlossmark;
                    var i=0; var lim=glossed.length;
                    while (i<lim) addGlossmark(glossed[i++]);}}}
        Codex.GoToPage=GoToPage;
        

        /** Previewing **/

        var previewing=false;
        function startPreview(spec,caller){
            var page=((spec.nodeType)&&(getParent(spec,".codexpage")))||
                Codex.layout.getPage(spec)||
                Codex.layout.getPage(1);
            var pagenum=parseInt(page.getAttribute("data-pagenum"));
            var pageloc=parseInt(page.getAttribute("data-sbookloc"));
            if (previewing===page) return;
            if (previewing) dropClass(previewing,"previewpage");
            dropClass(getChildren(Codex.pages,".previewpage"),
                      "previewpage");
            if (Codex.Trace.flips)
                fdjtLog("startPagePreview/%s to %o (%d) for %o",
                        caller||"nocaller",page,pagenum,spec);
            if (curpage) addClass(curpage,"hidepage");
            // Using this timeout here avoids some glitches
            addClass(page,"previewpage");
            Codex.previewing=previewing=page;
            addClass(document.body,"cxPREVIEW");
            updatePageDisplay(pagenum,pageloc,"preview");}
        function stopPreview(caller){
            var pagenum=parseInt(curpage.getAttribute("data-pagenum"));
            if (Codex.Trace.flips)
                fdjtLog("stopPagePreview/%s from %o to %o (%d)",
                        caller||"nocaller",previewing,curpage,pagenum);
            if (!(previewing)) return;
            dropClass(previewing,"previewpage");
            dropClass(curpage,"hidepage");
            dropClass(getChildren(Codex.pages,".previewpage"),
                      "previewpage");
            Codex.previewing=previewing=false;
            dropClass(document.body,"cxPREVIEW");
            updatePageDisplay(pagenum,Codex.location,"current");}
        Codex.startPagePreview=startPreview;
        Codex.stopPagePreview=stopPreview;

        function getPage(arg){
            if (!(Codex.layout)) return -1;
            var node=((arg.nodeType)?(arg):
                      (typeof arg === "string")?
                      (fdjtID(arg)):(false));
            var page=Codex.layout.getPage(arg)||Codex.layout.getPage(1);
            return parseInt(page.getAttribute("data-pagenum"));}
        Codex.getPage=getPage;
        
        function displaySync(){
            if ((Codex.pagecount)&&(Codex.curpage))
                Codex.GoToPage(Codex.curpage,"displaySync");}
        Codex.displaySync=displaySync;

        // We handle this ourselves
        fdjt.UI.adjustFont.onresize=false;

        return Paginate;})();

/* Emacs local variables
   ;;;  Local variables: ***
   ;;;  compile-command: "cd ..; make" ***
   ;;;  indent-tabs-mode: nil ***
   ;;;  End: ***
*/
if ((typeof sbook_suppressed === "undefined")||(sbook_suppressed))
    window.onload=function(evt){sbookStartup();};


/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/searchbox.html" */

Codex.HTML.searchbox="<div class='query'> \
  <img class=\"clearsearch\" alt=\"X\" title=\"clear search\" \
       svg=\"http://static.beingmeta.com/g/codex/redx.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/redx64x64.png\" \
       onclick=\"Codex.UI.handlers.clearSearch(event); fdjt.UI.cancel(event); return false;\"/> \
  <input id=\"CODEXSEARCHINPUT\" \
         type=\"TEXT\" class=\"autoprompt searchinput\" \
         name=\"QTEXT\" value=\"\" isempty=\"yes\" autocomplete=\"off\" \
         onfocus=\"Codex.UI.handlers.search_focus(event);\" \
         onblur=\"Codex.UI.handlers.search_blur(event);\" \
         onkeydown=\"Codex.UI.handlers.search_keyup(event);\" \
         completeopts=\"anywhere cloud\" enterchars=\";\" maxcomplete=\"45\" \
         placeholder=\"type or click tags\" \
         completions=\"CODEXSEARCHCLOUD\" \
         results=\"CODEXSEARCHRESULTS\"/> \
  <span class=\"ampersand\">&amp;</span> \
  <strong id=\"CODEXSEARCHLABEL\">Searching for </strong> \
  <span id=\"CODEXSEARCHPROMPT\"> \
    <span class='fortouch'>Tap</span> \
    <span class='notouch'>Click</span> a tag or start typing \
    to search.</span> \
  <span id=\"CODEXSEARCHTAGS\" class=\"qtags\"></span> \
</div> \
<div class=\"resultinfo\"> \
  <div class=\"noresults\">No results</div> \
  <div class=\"noquery\">Add tags to refine query</div> \
  <span class=\"resultcount\" \
        onclick=\"Codex.showSearchResults(); fdjt.UI.cancel(event);\"> \
  </span> \
  <span class=\"sep vbar\">|</span> \
  <span class=\"refinecount\" \
        onclick=\"Codex.setMode('search'); fdjt.UI.cancel(event);\"> \
  </span> \
</div> \
<!-- \
     /* Emacs local variables \
     ;;;  Local variables: *** \
     ;;;  compile-command: \"cd ../..; make\" *** \
     ;;;  indent-tabs-mode: nil *** \
     ;;;  End: *** \
     */ \
    --> \
 \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/addgloss.html" */

Codex.HTML.addgloss="<form action=\"https://glosses.sbooks.net/glosses\" \
      ajaxaction=\"https://glosses.sbooks.net/glosses\" \
      method=\"POST\" target=\"addgloss\" \
      accept-charset=\"utf-8\" \
      class=\"editnote\"> \
  <div class=\"hidden\"> \
    <input type=\"HIDDEN\" name=\"FRAG\"/> \
    <input type=\"HIDDEN\" name=\"WSNID\"/> \
    <input type=\"HIDDEN\" name=\"REFURI\"/> \
    <input type=\"HIDDEN\" name=\"DOCURI\"/> \
    <input type=\"HIDDEN\" name=\"SYNC\"/> \
    <input type=\"HIDDEN\" name=\"USER\"/> \
    <input type=\"HIDDEN\" name=\"UUID\"/> \
    <input type=\"HIDDEN\" name=\"TAGLINE\"/> \
    <input type=\"HIDDEN\" name=\"LOCATION\"/> \
    <input type=\"HIDDEN\" name=\"LOCLEN\"/> \
    <input type=\"HIDDEN\" name=\"DOCTITLE\"/> \
    <input type=\"HIDDEN\" name=\"MYCOPYID\"/> \
    <input type=\"HIDDEN\" name=\"RE\"/> \
    <input type=\"HIDDEN\" name=\"THREAD\"/> \
    <!-- Force IE to send the form in UTF-8 --> \
    <input type=\"HIDDEN\" name=\"IEHACK\" VALUE=\"&#9760;\"/> \
  </div> \
  <div class=\"glosseditbox\"> \
    <span class=\"respdate\"></span> \
    <span class=\"clickable codexglossrespond\"> \
      Respond \
      <img svg=\"http://static.beingmeta.com/g/codex/remark_respond.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/remark_respond64x64.png\" \
           alt=\"remark balloon\"/></span> \
    <span class=\"clickable codexglossdelete\"> \
      Delete  \
      <img svg=\"http://static.beingmeta.com/g/codex/remark_delete.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/remark_delete64x64.png\" \
           alt=\"red x\"/></span> \
  </div> \
  <div class=\"response\"> \
    Repond to <span class=\"respmaker\"></span> \
    <span class=\"respdate\"></span> <span class=\"respnote\"></span>  \
    <span class=\"resptags\"></span> <span class=\"resplinks\"></span> \
  </div> \
  <div class=\"codexglossformbody\"> \
    <div class=\"rightcol\"> \
      <div class=\"altbutton submitbutton\" tabindex=\"1\"> \
        <img svg=\"http://static.beingmeta.com/g/codex/remark_add.svgz\" \
             src=\"http://static.beingmeta.com/g/codex/remark_add50x50.png\" \
             alt=\"Add\" title=\"add this gloss\" \
             class=\"button addbutton add\"/> \
        <img svg=\"http://static.beingmeta.com/g/codex/remark_edit.svgz\" \
             src=\"http://static.beingmeta.com/g/codex/remark_edit50x50.png\" \
             alt=\"Save\" title=\"save this gloss\" \
             class=\"button savebutton edit\"/> \
        <img svg=\"http://static.beingmeta.com/g/codex/remark_respond.svgz\" \
             src=\"http://static.beingmeta.com/g/codex/remark_respond50x50.png\" \
             alt=\"Reply\" title=\"respond to this gloss (thread)\" \
             class=\"button replybutton reply\"/> \
      </div> \
      <div class=\"glossexposure\"> \
        <div class=\"checkspan private\" tabindex=\"5\"> \
          <input type=\"CHECKBOX\" name=\"PRIVATE\" value=\"yes\" \
                 onchange=\"Codex.UI.changeGlossPrivacy(event);\"/> \
          <span class=\"checked\" \
                title=\"this gloss won't be shared with my associated networks\"> \
            Private</span> \
          <span class=\"unchecked\" \
                title=\"this gloss will be shared with my associated networks\"> \
            Shared</span> \
        </div> \
        <div class=\"checkspan postgloss\" tabindex=\"6\"> \
          <input TYPE=\"HIDDEN\" name=\"WASPOSTED\" VALUE=\"yes\" \
                 DISABLED=\"DISABLED\"/> \
          Post<input type=\"CHECKBOX\" name=\"POSTGLOSS\" value=\"yes\" \
                     onchange=\"Codex.UI.changeGlossPosting(event);\"/></div> \
      </div> \
    </div> \
    <div class=\"inputbox\"> \
      <div class=\"textbox\"> \
        <textarea name=\"NOTE\" \
                  placeholder=\"add text, [tag]s, or [@links w/title]\" \
                  title=\"add text, [tag]s, or [@links w/title]\" \
                  onfocus=\"Codex.UI.addgloss_focus(event);\" \
                  onblur=\"Codex.UI.addgloss_blur(event);\" \
                  wrap=\"virtual\" \
                  tabindex=\"0\"></textarea> \
      </div> \
      <div class=\"glossetc\"> \
        <span class=\"modebuttons\"><img svg=\"http://static.beingmeta.com/g/codex/remark_tag.svgz\" \
                                       src=\"http://static.beingmeta.com/g/codex/remark_tag64x64.png\" \
                                       title=\"add tags\" class=\"button\" alt=\"tag\" \
                                       tabindex=\"2\"/><img svg=\"http://static.beingmeta.com/g/codex/remark_link.svgz\" \
                                                                                                 src=\"http://static.beingmeta.com/g/codex/remark_link64x64.png\" \
                                                                                                 title=\"add web links\" class=\"button\" alt=\"link\" \
                                                                                                 tabindex=\"3\"/><img svg=\"http://static.beingmeta.com/g/codex/remark_share.svgz\" \
                                                                                                                                                            src=\"http://static.beingmeta.com/g/codex/remark_share64x64.png\" \
                                                                                                                                                            title=\"add outlets/share this gloss\" class=\"button\" alt=\"sharing\" tabindex=\"4\"/></span> \
        <img svg=\"http://static.beingmeta.com/g/codex/twistyclosed.svgz\" \
             src=\"http://static.beingmeta.com/g/codex/twistyclosed64x64.png\" \
             class=\"twisty\" alt=\"+\"/> \
        <img svg=\"http://static.beingmeta.com/g/codex/twistyopen.svgz\" \
             src=\"http://static.beingmeta.com/g/codex/twistyopen64x64.png\" \
             class=\"twisty\" alt=\"-\"/> \
        <span class=\"networks\"> \
        </span> \
        <span class=\"excerpt checkspan empty\"> \
          <input TYPE=\"CHECKBOX\" NAME=\"EXCERPT\" VALUE=\"\"/> \
          <img src=\"http://static.beingmeta.com/g/codex/redx64x64.png\" \
               svg=\"http://static.beingmeta.com/g/codex/redx.svgz\" \
               class=\"redx\" alt=\"x\"/> \
          <span class=\"text\"></span> \
        </span> \
        <input TYPE=\"HIDDEN\" NAME=\"EXOFF\" VALUE=\"\"/> \
        <span class=\"links empty\"><span class=\"head\">links</span></span> \
        <span class=\"tags empty\"><span class=\"head\">tags</span></span> \
        <span class=\"sharing codexsharegloss\"> \
          <span class=\"outlets empty\"><span class=\"head\">share&nbsp;w/&nbsp;</span></span> \
        </span> \
      </div> \
    </div> \
    <div class=\"fdjtclearfloats\"></div> \
  </div> \
</form> \
<!-- \
    /* Emacs local variables \
    ;;;  Local variables: *** \
    ;;;  compile-command: \"cd ../..; make\" *** \
    ;;;  indent-tabs-mode: nil *** \
    ;;;  End: *** \
    */ \
  --> \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/hud.html" */

Codex.HTML.hud="<div id=\"CODEXAPPSPLASH\" class=\"hudpanel\"></div> \
<div id=\"CODEXHELP\" class=\"hudpanel codexhelp\"></div> \
<div id=\"CODEXHUDHELP\"></div> \
<div id=\"CODEXKEYBOARDHELPBOX\" class=\"closed\"> \
  <span class=\"keep\" onclick=\"Codex.keyboardHelp(true);\">keep</span> \
  <span class=\"close\" onclick=\"Codex.keyboardHelp(false);\">close</span> \
  <div id=\"CODEXKEYBOARDHELP\"></div> \
  <div class=\"checkspan\" onclick=\"fdjt.UI.CheckSpan.onclick(event);\"> \
    <input TYPE=\"CHECKBOX\" NAME=\"CODEXKEYBOARDHELP\" VALUE=\"yes\" \
           CHECKED> \
    Show keyboard help \
  </div> \
</div> \
<div id=\"CODEXSCANNER\"> \
  <span class=\"expander\" id=\"CODEXEXPANDSCANNER\"> \
    <img svg=\"http://static.beingmeta.com/g/codex/twistyclosed.svgz\" \
         src=\"http://static.beingmeta.com/g/codex/twistyclosed64x64.png\" \
         alt=\"+\"/> \
    <img svg=\"http://static.beingmeta.com/g/codex/twistyopen.svgz\" \
         src=\"http://static.beingmeta.com/g/codex/twistyopen64x64.png\" \
         alt=\"-\"/> \
  </span> \
  <div id=\"CODEXSCAN\"></div> \
</div> \
<div id=\"CODEXHEAD\"> \
  <div class=\"helphud topcenter\"> \
    <span class=\"fortouch\">Tap</span><span class=\"notouch\">Click</span> \
    at the top of the page to highlight the interface. \
  </div> \
 \
  <img svg=\"http://static.beingmeta.com/g/codex/tocicon.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/tocicon50x50.png\" \
       alt=\"toc\" title=\"navigate sections\" \
       class=\"hudbutton hudmodebutton topleft clickable\" \
       id=\"CODEXTOCBUTTON\" \
       hudmode=\"toc\"/> \
  <img svg=\"http://static.beingmeta.com/g/codex/tagsearch.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/tagsearch50x50.png\" \
       alt=\"search\" title=\"search tags\" \
       class=\"hudbutton hudmodebutton topright clickable\" \
       id=\"CODEXSEARCHBUTTON\" \
       hudmode=\"search\"/> \
  <div class=\"helphud topleft\" data-hudmode=\"toc\"> \
    <span class=\"nobreak\"><span class=\"arrow\">&#x2190;</span>browse</span><br/> \
    <span class=\"nobreak\">sections</span></div> \
  <div class=\"helphud topright\" data-hudmode=\"search\"> \
    <span class=\"nobreak\"><span class=\"arrow\">&#x2192;</span>search</span><br/> \
    for&nbsp;tags</div> \
 \
  <div class=\"helphud topcenter\" style=\"display: none;\"> \
    <span class=\"fortouch\">tap</span><span class=\"notouch\">click</span> \
    here to see the book tools \
  </div> \
  <div id=\"CODEXHUDBUTTONS\"> \
    <div class=\"sbookplate\"> \
      <a href=\"https://auth.sbooks.net/admin/logout\" class=\"logout\" \
         onclick=\"if (Codex.refuri) Codex.clearOffline(Codex.refuri);\" \
         title=\"logout\"> \
        logout</a> \
      <a href=\"javascript:Codex.setMode('sbooksapp');\" name=\"IDLINK\" \
         id=\"CODEXUSERNAME\"> \
        (click to log in)</a> \
    </div> <!-- .flyleafplate --> \
    <div class=\"tabbar icons\" id=\"CODEXTABS\"> \
      <img svg=\"http://static.beingmeta.com/g/codex/about_tab.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/about_tab.png\" \
           alt=\"About\" class=\"tab\" contentid=\"CODEXABOUTBOOK\" \
           onclick=\"Codex.setMode.toggle('about'); return fdjt.UI.cancel(event);\" \
           title=\"information about this book\"/> \
      <img svg=\"http://static.beingmeta.com/g/codex/toc_tab.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/toc_tab.png\" \
           alt=\"ToC\" class=\"tab\" contentid=\"CODEXFLYTOC\" \
           onclick=\"Codex.setMode.toggle('flytoc'); return fdjt.UI.cancel(event);\" \
           title=\"Table of Contents (static)\"> \
      <img svg=\"http://static.beingmeta.com/g/codex/manage_tab.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/manage_tab.png\" \
           alt=\"sBooks\" class=\"tab cxUSER\" contentid=\"SBOOKSAPP\" \
           onclick=\"Codex.setMode.toggle('sbooksapp'); return fdjt.UI.cancel(event);\" \
           title=\"manage added layers for your sBook\"/> \
      <img svg=\"http://static.beingmeta.com/g/codex/settings_tab.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/settings_tab.png\" \
           alt=\"Device\" class=\"tab\" contentid=\"CODEXSETTINGS\" \
           onclick=\"Codex.setMode.toggle('device'); return fdjt.UI.cancel(event);\" \
           title=\"alter appearance and interaction\"/> \
      <img svg=\"http://static.beingmeta.com/g/codex/console_tab.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/console_tab.png\" \
           alt=\"Console\" class=\"tab\" contentid=\"CODEXCONSOLE\" \
           onclick=\"Codex.setMode.toggle('console'); return fdjt.UI.cancel(event);\" \
           title=\"show debugging console\" /> \
      <img svg=\"http://static.beingmeta.com/g/codex/login_tab.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/login_tab.png\" \
           alt=\"Login\" class=\"tab cxNOUSER\" contentid=\"SBOOKSAPP\" \
           onclick=\"Codex.setMode.toggle('sbooksapp'); return fdjt.UI.cancel(event);\" \
           title=\"login to sBooks\" /> \
    </div> <!-- .tabbar --> \
  </div> <!-- id=\"CODEXHUDBUTTONS\" --> \
  <div id=\"CODEXGOTOLOC\" class=\"hudpanel codexgoto\"> \
    Jump to percentage <input type=\"text\" name=\"GOTOLOC\" value=\"\" \
                              class=\"fdjtnumberinput\" \
                              id=\"CODEXLOCINPUT\" \
                              onkeypress=\"Codex.UI.goto_keypress(event);\"/> \
  </div> \
  <div id=\"CODEXGOTOPAGE\" class=\"hudpanel codexgoto\"> \
    Jump to page <input type=\"text\" name=\"GOTOPAGE\" value=\"\" \
                        class=\"fdjtnumberinput\" \
                        id=\"CODEXPAGEINPUT\" \
                        onkeypress=\"Codex.UI.goto_keypress(event);\"/> \
  </div> \
  <div id=\"CODEXTOC\" class=\"hudpanel\"></div> \
  <div id=\"CODEXSEARCH\" class=\"searchbox hudpanel notags\"> \
    <!-- This content comes from searchbox.html --> \
  </div> \
  <div id=\"CODEXADDGLOSS\" class=\"codexaddgloss hudpanel\"> \
    <div id=\"CODEXGLOSSFORMS\"> \
      <div class=\"codexglossform\" id=\"CODEXADDGLOSSPROTOTYPE\"> \
        <!-- This content comes from addgloss.html --> \
      </div> \
      <!-- This is populated with copies of the prototype DIV --> \
    </div> \
  </div> \
  <div id=\"CODEXGLOSS\" class=\"hudpanel\"> \
    <div class=\"editbar\"> \
      <span class=\"deletebutton\">Delete</span> \
      <span class=\"deletebutton\">Edit</span> \
      <span class=\"deletebutton\">Reply</span> \
    </div> \
    <div id=\"CODEXTARGETGLOSS\"> \
      <!-- This is generated on demand --> \
    </div> \
  </div> \
  <div id=\"CODEXSOURCES\" class=\"hudpanel codexsources\" \
       onclick=\"Codex.UI.handlers.sources_ontap(event);\"> \
    <img svg=\"http://static.beingmeta.com/g/codex/sbookspeople.svgz\" \
         src=\"http://static.beingmeta.com/g/codex/sbookspeople50x50.png\" \
         class=\"button everyone selected\" \
         alt=\"show all\" title=\"show all glosses\" \
         onclick=\"Codex.UI.handlers.everyone_ontap(event);\"/> \
  </div> \
  <div id=\"CODEXGLOSSES\" class=\"hudpanel\"> \
    <!-- This is populated when a glosspoint is tapped --> \
  </div> \
</div> <!-- CODEXHEAD --> \
<div class=\"helphud leftmiddle\"> \
  back page \
</div> \
<div class=\"helphud rightmiddle\"> \
  next page \
</div> \
<img svg=\"http://static.beingmeta.com/g/codex/page_right.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/page_right100h.png\" \
     title=\"go to the next page\" \
     id=\"CODEXNEXTPAGE\" class=\"codexpagebutton\" \
     alt=\"next\" onclick=\"Codex.pageForward(event);\"/> \
<img svg=\"http://static.beingmeta.com/g/codex/page_left.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/page_left100h.png\" \
     title=\"go to the previous page\" \
     id=\"CODEXPREVPAGE\" class=\"codexpagebutton\" \
     alt=\"prev\" onclick=\"Codex.pageBackward(event);\"/> \
<img svg=\"http://static.beingmeta.com/g/codex/scan_left.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/scan_left100x100.png\" \
     title=\"go to the previous result/gloss\" \
     id=\"CODEXPREVSCAN\" class=\"codexscanbutton\" \
     alt=\"prev\" onclick=\"Codex.scanBackward(event);\"/> \
<img svg=\"http://static.beingmeta.com/g/codex/scan_right_stop.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/scan_right_stop100x100.png\" \
     id=\"CODEXENDSCAN\" class=\"codexscanbutton\" \
     alt=\"end\"/> \
<img svg=\"http://static.beingmeta.com/g/codex/scan_right.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/scan_right100x100.png\" \
     title=\"go to the next result/gloss\" \
     id=\"CODEXNEXTSCAN\" class=\"codexscanbutton\" \
     alt=\"next\" onclick=\"Codex.scanForward(event);\"/> \
<img svg=\"http://static.beingmeta.com/g/codex/scan_left_stop.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/scan_left_stop100x100.png\" \
     id=\"CODEXSTARTSCAN\" class=\"codexscanbutton\" \
     alt=\"beginning\"/> \
<div id=\"CODEXHEART\"> \
</div> \
<!-- \
<img svg=\"http://static.beingmeta.com/g/codex/redx.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/redx128x128.png\" \
     class=\"codexclosehud\" alt=\"close\" id=\"CODEXSTOPSCAN\"/> \
--> \
<div id=\"CODEXFOOT\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/allglosses.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/allglosses50x50.png\" \
       alt=\"allglosses\" title=\"show all glosses\" \
       class=\"hudbutton hudmodebutton botleft clickable\" \
       id=\"CODEXALLGLOSSESBUTTON\" \
       hudmode=\"allglosses\"/> \
  <img svg=\"http://static.beingmeta.com/g/codex/helpicon.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/helpicon50x50.png\" \
       alt=\"help\" title=\"show contextual help\" \
       class=\"hudbutton hudmodebutton botright clickable\" \
       id=\"CODEXHELPBUTTON\"/> \
  <div id=\"CODEXSHOWTEXT\"> \
    <span> \
      <span class=\"fortouch\">Tap</span><span class=\"notouch\">Click</span> \
      here to return to the text \
      <!-- \
          <img svg=\"http://static.beingmeta.com/g/codex/redx.svgz\" \
               src=\"http://static.beingmeta.com/g/codex/redx128x128.png\" \
               class=\"codexclosehud\" alt=\"close\"/> \
          --> \
    </span> \
  </div> \
  <div class=\"helphud botleft\" data-hudmode=\"toc\"> \
    <span class=\"nobreak\"><span class=\"arrow\">&#x2190;</span>browse</span><br/> \
    <span class=\"nobreak\">glosses</span></div> \
  <div class=\"helphud botright\"> \
    <span class=\"nobreak\"><span class=\"arrow\">&#x2192;</span>toggle</span><br/> \
    help</div> \
  <div class=\"helphud botcenter\"> \
    <span style=\"font-size: 200%; font-weight: bold; float: left;\"> \
    &#x2193;</span> this bar shows where you are in the book: \
    <span class=\"fortouch\">tap</span><span class=\"notouch\">click</span> \
    to jump around, hold down to preview, \
    or <span style=\"white-space: nowrap;\"><span class=\"fortouch\">tap</span> \
    <span class=\"notouch\">click</span> numbers to change</span> \
  </div> \
</div> \
 \
<!-- \
    /* Emacs local variables \
    ;;;  Local variables: *** \
    ;;;  compile-command: \"cd ../..; make\" *** \
    ;;;  indent-tabs-mode: nil *** \
    ;;;  End: *** \
    */ \
  --> \
 \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/hudheart.html" */

Codex.HTML.hudheart="<div id=\"CODEXALLGLOSSES\" class=\"codexslice hudpanel\"> \
  <!-- This is filled in on startup --> \
</div> \
<div id=\"CODEXGLOSSATTACH\" class=\"hudpanel\"> \
  <form id=\"CODEXGLOSSATTACHFORM\"> \
    <table class=\"fdjtform\"> \
      <input TYPE=\"HIDDEN\" NAME=\"ATTACHING\" VALUE=\"\"/> \
      <tr><th>Title</th> \
        <td><INPUT TYPE=\"TEXT\" NAME=\"ATTACH.TITLE\" VALUE=\"\" \
                   ID=\"CODEXATTACHTITLE\" \
                   placeholder=\"how this reference is related to your gloss\"/> \
        <td><button id=\"CODEXATTACHCANCEL\">Cancel</button></td></tr> \
      <tr class=\"choosetype\"> \
        <th></th> \
        <td> \
          <span class=\"checkspan ischecked\"> \
            <input TYPE=\"RADIO\" NAME=\"ATTACHTYPE\" NAME=\"URL\"/>Web link</span> \
          <span class=\"checkspan ischecked\"> \
            <input TYPE=\"RADIO\" NAME=\"ATTACHTYPE\" NAME=\"UPLOAD\"/> \
            Upload file</span> \
          <span class=\"checkspan ischecked\"> \
            <input TYPE=\"RADIO\" NAME=\"ATTACHTYPE\" NAME=\"DETAIL\"/> \
            Detailed text</span></td> \
        <td></td></tr> \
      <tr class=\"url\"> \
        <th>URL</th> \
        <td><input TYPE=\"TEXT\" NAME=\"ATTACH.URL\" VALUE=\"\" \
                   ID=\"CODEXATTACHURL\" \
                   placeholder=\"an external URL relevant to this gloss\"/></td> \
        <td><button id=\"CODEXATTACHOK\" NAME=\"ATTACH\" \"LINK\"> \
            Link!</button></td></tr> \
      <tr class=\"upload\"> \
        <th>File</th> \
        <td><input TYPE=\"FILE\" NAME=\"ATTACH.FILE\" ID=\"CODEXATTACHFILE\"/></td> \
        <td><button id=\"CODEXUPLOADOK\" NAME=\"ATTACH\" \"UPLOAD\"> \
            Upload</button></td></tr> \
      <tr class=\"detail\"> \
        <th>Detail</th> \
        <td> \
          <textarea NAME=\"ATTACH.DETAIL\" ID=\"CODEXATTACHDETAIL\"></textarea> \
        </td> \
        <td><button id=\"CODEXDETAILOK\" NAME=\"ATTACH\" \"DETAIL\"> \
            Save</button></td></tr> \
    </table> \
  </form> \
</div> \
<div id=\"CODEXSEARCHCLOUD\" class=\"completions searchcloud hudpanel\"> \
  <div id=\"CODEXPRIMETAGS\" class=\"prime\"></div> \
  <div id=\"CODEXSEARCHTAGS\" class=\"normal\"></div> \
  <div class=\"sections\"></div> \
  <div id=\"CODEXSEARCHSOURCES\" class=\"sources\"></div> \
  <div class=\"weak\"></div> \
  <div class=\"words\"></div> \
</div> \
<div id=\"CODEXSEARCHRESULTS\" class=\"codexslice hudpanel\"></div> \
<div id=\"CODEXGLOSSOUTLETS\" class=\"hudpanel\"> \
  <div class=\"inputbox\"> \
    <input TYPE=\"TEXT\" NAME=\"OUTLET\" VALUE=\"\" \
           placeholder=\"Type a group or individual name\" \
           autocomplete=\"off\" \
           ID=\"CODEXOUTLETINPUT\"/> \
  </div> \
  <div id=\"CODEXOUTLETCLOUD\" class=\"completions showempty\"> \
    <span id=\"CODEXNETWORKBUTTONS\"> \
      <span class=\"facebook_share\"> \
        <span class=\"completion network\" \
              key=\"Facebook\" value=\":FACEBOOK\" \
              title=\"share (or not) this gloss with my Facebook friends\"> \
          <img src=\"http://static.beingmeta.com/g/codex/facebook64x64.png\" \
               alt=\"Facebook\"/> \
        </span> \
      </span> \
      <span class=\"twitter_share\"> \
        <span class=\"completion network\" \
              key=\"Twitter\" value=\":TWITTER\" \
              title=\"share (or not) this gloss with my Twitter followers\"> \
          <img src=\"http://static.beingmeta.com/g/codex/twitter64x64.png\" \
               alt=\"Twitter\" class=\"checked\"/> \
        </span> \
      </span> \
      <span class=\"linkedin_share\"> \
        <span class=\"completion network\" \
              key=\"LinkedIn\" value=\":LINKEDIN\" \
              title=\"share this gloss with my LinkedIn connections\"> \
          <img src=\"http://static.beingmeta.com/g/codex/linkedin64x64.png\" \
               alt=\"LinkedIn\" class=\"checked\"/> \
        </span> \
      </span> \
      <span class=\"google_share\"> \
        <span class=\"completion network\" \
              key=\"Google+\" value=\":GOOGLE\" \
              title=\"share this gloss with my Google+ connections\"> \
          <img src=\"http://static.beingmeta.com/g/codex/googleplus64x64.png\" \
               alt=\"Google+\" class=\"checked\"/> \
        </span> \
      </span> \
    </span> \
  </div> \
</div> \
<div id=\"CODEXGLOSSTAGS\" class=\"hudpanel\"> \
  <div class=\"inputbox\"> \
    <input TYPE=\"TEXT\" NAME=\"TAG\" VALUE=\"\" \
           placeholder=\"Type or define a tag, with completion\" \
           autocomplete=\"off\" \
           ID=\"CODEXTAGINPUT\"/> \
  </div> \
  <div id=\"CODEXGLOSSCLOUD\" class=\"completions showempty\"> \
    <div id=\"CODEXGLOSSCLOUDTAGS\"></div> \
    <div id=\"CODEXGLOSSCLOUDSOURCES\"></div> \
  </div> \
</div> \
<div id=\"CODEXCONSOLE\" class=\"tabcontent flyleaftab sbookconsole hudpanel\"> \
  <h1>Codex Console</h1> \
  <div class='message' id='CODEXCONSOLEMESSAGE'></div> \
  <div id=\"CODEXCONSOLELOG\" class='sbookmessagelog'></div> \
  <div id=\"CODEXCONSOLEINPUT\"> \
    <span class=\"button\" onclick=\"Codex.consolefn();\">run</span> \
    <textarea id=\"CODEXCONSOLETEXTINPUT\" \
              ontouchstart=\"fdjt.ID('CODEXCONSOLETEXTINPUT').focus()\"> \
    </textarea> \
  </div> \
</div> \
<div class=\"tabcontent flyleaftab hudpanel\" id=\"CODEXSETTINGS\"></div> \
<div class=\"tabcontent flyleaftab hudpanel\" id=\"CODEXFLYTOC\"></div> \
<div class=\"tabcontent flyleaftab sbookabout hudpanel\" id=\"CODEXABOUTBOOK\"> \
  <div id='CODEXABOUTBOOKCONTENT'> \
    <div class='title'></div> \
    <div class='byline'></div> \
    <div class='cover'></div> \
    <div class='publisher'></div> \
    <div class='copyright'></div> \
    <div class='description'></div> \
    <div class='digitized'></div> \
    <div class='sbookified'></div> \
    <div class='about'></div> \
  </div> \
</div> \
<iframe name=\"SBOOKSAPP\" id=\"SBOOKSAPP\" frameborder=\"0\" scrolling=\"auto\" \
        class=\"hudpanel tabcontent flyleaftab\"/> \
<iframe name=\"CODEXGLOSSCOMM\" id=\"CODEXGLOSSCOMM\" \
        frameborder=\"0\" scrolling=\"auto\" \
        class=\"hudpanel tabcontent\"/> \
<!-- \
    /* Emacs local variables \
    ;;;  Local variables: *** \
    ;;;  compile-command: \"cd ../..; make\" *** \
    ;;;  indent-tabs-mode: nil *** \
    ;;;  End: *** \
    */ \
  --> \
 \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/help.html" */

Codex.HTML.help="<!-- This is the help text for reading the book as a whole (it get's \
     displayed for help when there isn't an active reader mode) --> \
<img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
     alt=\"close\" class=\"closebutton\" \
     onclick=\"Codex.toggleHelp();\"/> \
<h1><span class=\"adjustfont\">Welcome to Codex, \
the <span class=\"s4sbook\">s</span>Books e-reader</span></h1> \
<table class=\"fdjt textual\"> \
  <!-- \
  <tr><th> \
      <img svg=\"http://static.beingmeta.com/g/codex/helpicon.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/helpicon32x32.png\" \
           alt=\"help/question mark\" class=\"left\"/></th> \
    <td class=\"text\"><span class=\"action\"> \
        <span class=\"fortouch\">Tap</span> <span class=\"notouch\">Click</span> \
        the help icon</span> in bottom right corner \
        to <span class=\"result\">toggle</span> contextual \
        help.</td></tr> \
  --> \
  <tr><th><img svg=\"http://static.beingmeta.com/g/codex/browser_edges.svgz\" \
               src=\"http://static.beingmeta.com/g/codex/browser_edges32x32.png\" \
               alt=\"top of browser\" class=\"left\"/></th> \
    <td class=\"text\"><span class=\"action\"> \
        <span class=\"fortouch\">Tap</span> <span class=\"notouch\">Click</span> \
        the sides</span> to <span class=\"result\">move by \
        pages</span>.</td> \
  <tr><th><img svg=\"http://static.beingmeta.com/g/codex/browser_top.svgz\" \
               src=\"http://static.beingmeta.com/g/codex/browser_top32x32.png\" \
               alt=\"bottom of browser\" class=\"left\"/></th> \
    <td class=\"text\"><span class=\"action\"> \
        <span class=\"fortouch\">Tap</span> <span class=\"notouch\">Click</span> \
        the top</span> to <span class=\"result\">bring up \
        the interface</span>.</td></tr> \
  <tr><th><img svg=\"http://static.beingmeta.com/g/codex/browser_bottom.svgz\" \
               src=\"http://static.beingmeta.com/g/codex/browser_bottom32x32.png\" \
               alt=\"edges of browser\" class=\"left\"/></th> \
    <td class=\"text\"><span class=\"action\"> \
        <span class=\"fortouch\">Tap</span> <span class=\"notouch\">Click</span> \
        the bottom</span> to <span class=\"result\">return \
        to the text</span>.</td></tr> \
  <tr><th><img svg=\"http://static.beingmeta.com/g/codex/browser_corners.svgz\" \
               src=\"http://static.beingmeta.com/g/codex/browser_corners32x32.png\" \
               alt=\"corners of browser\" class=\"left\"/></th> \
    <td class=\"text\"><span class=\"action\"> \
        <span class=\"fortouch\">Tap</span> <span class=\"notouch\">Click</span> \
        in the corners to:</span> \
      <table> \
        <tr><td class=\"icon\"> \
            <img svg=\"http://static.beingmeta.com/g/codex/tocicon.svgz\" \
                 src=\"http://static.beingmeta.com/g/codex/tocicon32x32.png\" \
                 alt=\"tocicon\"/></td> \
          <td class=\"textleft\">Browse by chapters or sections.</td> \
          <td class=\"textright\">Search by tags, phrases, or \
            concepts</td> \
          <td class=\"icon\"> \
            <img svg=\"http://static.beingmeta.com/g/codex/tagsearch.svgz\" \
                 src=\"http://static.beingmeta.com/g/codex/tagsearch32x32.png\" \
                 alt=\"tocicon\"/></td> \
        </tr> \
        <tr><td class=\"icon\"> \
            <img svg=\"http://static.beingmeta.com/g/codex/allglosses.svgz\" \
                 src=\"http://static.beingmeta.com/g/codex/allglosses32x32.png\" \
                 alt=\"people talking\"/></td> \
          <td class=\"textleft\">Browse people's glosses (notes, \
            links, tags, etc)</td> \
          <td class=\"textright\">Toggle contextual help (like this)</td> \
          <td class=\"icon\"> \
            <img svg=\"http://static.beingmeta.com/g/codex/helpicon.svgz\" \
                 src=\"http://static.beingmeta.com/g/codex/helpicon32x32.png\" \
                 alt=\"help/question mark\"/></td> \
        </tr> \
  </table></td></tr> \
  <tr><th><img svg=\"http://static.beingmeta.com/g/codex/sbookslogo.svgz\" \
               src=\"http://static.beingmeta.com/g/codex/sbookslogo32x32.png\" \
               alt=\"corners of browser\" class=\"left\"/></th> \
    <td class=\"text\"> \
      <strong><span style=\"color: blue;\">s</span>Books</strong> are \
      digital books enriched by layers of structure, semantics, and \
      annotations from your friends, colleagues, and chosen \
      communities.</td></tr> \
  <tr><th><img svg=\"http://static.beingmeta.com/g/codex/sbwedge.svgz\" \
               src=\"http://static.beingmeta.com/g/codex/sbwedge32x32.png\" \
               alt=\"corners of browser\" class=\"left\"/></th> \
    <td class=\"text\"> \
      <strong>Glosses</strong> are notes, tags, and links overlaid on \
      the content of this book and indicated by \
      <span class=\"fortouch\">tappable</span> \
      <span class=\"notouch\">clickable</span> \
      <img svg=\"http://static.beingmeta.com/g/codex/sbwedge.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/sbwedge16x16.png\" \
           class=\"inline\" \
           alt=\"asterisk\"/> icons in the text or margins.</td></tr> \
  <tr><th> \
      <img svg=\"http://static.beingmeta.com/g/codex/text_selection.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/text_selection32x32.png\" \
           alt=\"corners of browser\" class=\"notouch left\"/> \
      <img svg=\"http://static.beingmeta.com/g/codex/finger_selection.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/finger_selection32x32.png\" \
           alt=\"corners of browser\" class=\"fortouch left\"/></th> \
    <td class=\"text\"> \
      <strong>Add your own glosses</strong> by selecting text and then \
      adding notes, tags, or links in the pop-up form.  Keep them for \
      yourself or share them with your friends, colleagues, or social \
      networks.</td></tr> \
</table> \
</div> \
 \
<!-- \
    /* Emacs local variables \
    ;;;  Local variables: *** \
    ;;;  compile-command: \"cd ../..; make\" *** \
    ;;;  indent-tabs-mode: nil *** \
    ;;;  End: *** \
    */ \
  --> \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/hudhelp.html" */

Codex.HTML.hudhelp="<div id=\"CODEXTOCHELP\" class=\"helpbox atfoot\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <h3>Navigating your sBook</h3> \
  <div class=\"helpblock\"> \
    <p>The <strong>overleaf</strong> at the top of the page shows a map of \
      your book centered on the current location.  You can use it to \
      browse or navigate the book.</p> \
    <p><strong class=\"fortouch\">Tapping</strong> \
      <strong class=\"notouch\">Clicking</strong> on the map jumps to the \
      corresponding location in the book;</p> \
    <p><strong>Pressing or holding</strong> lets you glimpse the \
      location without actually jumping there.</p> \
  </div> \
  <p><strong>Layout stripes</strong> \
    <img class=\"screenshot right\" \
         src=\"http://static.beingmeta.com/g/codex/tocstripe_screenshot.png\"/> \
    display the arrangement and sizes of divisions at a particular \
    level in the book.  The segment for the current section is light \
    blue and contains a red tick indicates your relative \
    position.</p> \
  <p><strong>Subsection clouds</strong> appear when you're at the \
    beginning of a section which has its own subsections.  It consists \
    of a layout stripe for all of its subsections together a cloud of \
    subsection names.  Clicking a name or segment jumps to that \
    subsection.</p> \
</div> \
<div id=\"CODEXADDGLOSSHELP\" class=\"helpbox atfoot\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <h3>Add your own gloss to this passage</h3> \
  <blockquote> \
    <p><img svg=\"http://static.beingmeta.com/g/codex/remark.svgz\" \
            src=\"http://static.beingmeta.com/g/codex/remark64x64.png\" \
            class=\"inline\" alt=\"the balloon icon\"/> \
      Type your comments, ending with <kbd>Enter</kbd> or \
      <span class=\"fortouch\">tapping</span> \
      <span class=\"notouch\">clicking</span> \
      the right-most \
      <img svg=\"http://static.beingmeta.com/g/codex/remark_add.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/remark_add64x64.png\" \
           class=\"inline\" alt=\"the right-hand button\"/> icon.</p> \
    <p><img svg=\"http://static.beingmeta.com/g/codex/diaglink.svgz\" \
            src=\"http://static.beingmeta.com/g/codex/diaglink64x64.png\" \
            class=\"inline\" alt=\"the link icon\"/> \
      <strong>Add links</strong> \
      as <strong>[@</strong><em><tt>uri</tt></em> \
      <em>title</em><strong>]</strong>, \
      e.g. <strong>[@</strong><tt>http://www.whitehouse.gov/</tt> \
      The White House<strong>]</strong>.</p> \
    <p><img svg=\"http://static.beingmeta.com/g/codex/tagicon.svgz\" \
            src=\"http://static.beingmeta.com/g/codex/tagicon64x64.png\" \
            class=\"inline\" alt=\"the tag icon\"/> \
      <strong>Add tags</strong> by typing in the tags field, enclosing \
      note text in <strong>[</strong>brackets<strong>]</strong> \
      or <span class=\"fortouch\">tapping</span><span class=\"notouch\">clicking</span> \
      <span class=\"tag\">suggested tag</span>s in the <em>cloud</em>.</p> \
    <p><img svg=\"http://static.beingmeta.com/g/codex/tagicon.svgz\" \
            src=\"http://static.beingmeta.com/g/codex/tagicon64x64.png\" \
            class=\"inline\" alt=\"the tag icon\"/> \
      Specify <strong>synonyms</strong> for your tags (e.g. \
      <span class=\"tagsample\"><strong>[</strong>airplane|plane|aircraft<strong>]</strong></span>) \
      or describe <strong>relations</strong> \
      (e.g. <span class=\"tagsample\"> \
        <strong>[</strong>sloop|^sailboat|^boat<strong>]</strong></span>) \
      to make your tags <strong>more useful</strong> for browsing \
      and search by yourself or others.</p> \
</blockauote> \
</div> \
<div id=\"CODEXTOCSCANHELP\" class=\"helpbox atfoot\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <h3>Skimming by Sections</h3> \
  <blockquote> \
    <p>The <strong>overleaf</strong> at the top of the page shows the \
      <strong>current section</strong> with the arrangement and sizes of \
      the surrounding sections in the book.</p> \
    <p><strong class=\"notouch\">Clicking</strong> \
      <strong class=\"fortouch\">Tapping</strong> on a segment jumps to \
      the beginning of that section.  <strong class=\"notouch\">Holding \
        the mouse button down \
        over</strong><strong class=\"fortouch\">Pressing on</strong> a \
      segment shows you a preview of the section without going \
      there.</p> \
 \
    <p><strong class='fortouch'>Tap</strong> \
      <strong class='notouch'>Click</strong> the \
      <img svg=\"http://static.beingmeta.com/g/codex/scan_left.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/scan_left64x64.png\" \
           class=\"inline\"/> \
      <img svg=\"http://static.beingmeta.com/g/codex/scan_right.svgz\" \
           src=\"http://static.beingmeta.com/g/codex/scan_right64x64.png\" \
           class=\"inline\"/> \
      buttons to move forward or back by sections at the current level. \
      <span class=\"notouch\"><strong>Shift-clicking</strong> (holding the \
        shift key while clicking) in the right or left margin moves \
        forward or backward by section at the current level.</span> \
      <span class=\"fortouch\"><strong>Swiping</strong> with <strong>two \
          fingers</strong> advances by sections at the current level, as \
        does double-tapping the left or right edge.</span> \
    </p> \
  </blockquote> \
</div> \
<div id=\"CODEXSCANNINGHELP\" class=\"helpbox atfoot\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <h3>Scanning Glosses or Results</h3> \
  <blockquote> \
    <p>You're now <strong>scanning</strong> through your book based on \
      a list of either glosses or search results.  The current gloss \
      or search result is shown in the <strong>overlaf</strong> at the \
      top of the page.</p> \
    <p><span class=\"fortouch\">Tap</span> \
      <span class=\"notouch\">Click on</span> \
      the <strong>overleaf</strong> to return to the list \
      and <span class=\"notouch\">on</span> the <strong>content</strong> \
      to stop scanning.  <span class=\"fortouch\"><em>Hold</em> the \
      <img src=\"http://static.beingmeta.com/g/codex/twistyclosed64x64.png\" \
      alt=\"&gt;\" class=\"inline\"/> to expand the overleaf; <em>tap</em> \
      it to <strong>lock it open</strong> (again to unlock).</span> \
    <span class=\"notouch\"><em>Hover your mouse</em> over the overleaf \
    to <strong>expand it</strong> and tap on the \
    <img src=\"http://static.beingmeta.com/g/codex/twistyclosed64x64.png\" \
    alt=\"&gt;\" class=\"inline\"/> to <strong>lock it open</strong> \
    (again to unlock).</p> \
    <p>The \
        <img svg=\"http://static.beingmeta.com/g/codex/ScanLeft.svgz\" \
        src=\"http://static.beingmeta.com/g/codex/scan_left64x64.png\" \
        class=\"inline\"/> double \
        arrows \
        <img svg=\"http://static.beingmeta.com/g/codex/scan_right.svgz\" \
        src=\"http://static.beingmeta.com/g/codex/scan_right64x64.png\" \
        class=\"inline\"/> \
        and <span class=\"fortouch\"><strong>swiping with two \
        fingers</strong> (right or \
        left)</span> <strong class=\"notouch\">the left and right arrow \
        keys</strong> move forward or back through the glosses or \
        search results.</p> \
    <p>The <em>top line</em> of the overleaf shows the location of the \
      result in the book overall, both in the outline (the text links) \
      and the in content as a whole (the blue span).</p> \
  </blockquote> \
</div> \
<div id=\"CODEXGOTOPAGEHELP\" class=\"helpbox atfoot\" onclick=\"Codex.setMode(false);\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <p>Enter a page number at the top of the page to jump directly to that \
  page.<br/> Use the escape key or <strong class=\"fortouch\">tap</strong> \
  <strong class=\"notouch\">click</strong> at the bottom of the page to \
  cancel.</p> \
</div> \
<div id=\"CODEXGOTOLOCHELP\" class=\"helpbox atfoot\" onclick=\"Codex.setMode(false);\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <p>Enter a numeric percentage (in the field at the top of the page) \
  to jump directly to that point within the book.<br/>  These \
  percentages will remain stable even as page layout or font size \
  changes.  Use the escape key \
  or <strong class=\"fortouch\">tap</strong> \
  <strong class=\"notouch\">click</strong> at the bottom of the page to \
  cancel and return to the text.</p> \
</div> \
<div id=\"CODEXSEARCHINPUTHELP\" class=\"helpbox atfoot\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <h3>Searching your sBook</h3> \
  <p>You are searching for passages or glosses within your book, using \
    either <span class=\"dterm\">tags</span> \
    or <span class=\"rawterm\">literals</span>.  As you type or edit in \
    the search box, the cloud of tags and phrases will grow or shrink \
    to display matching phrases, tags, or synonyms of tags.</p> \
  <p><strong class=\"fortouch\">Tapping</strong> \
    <strong class=\"notouch\">Clicking</strong> \
    <em>adds a phrase or tag</em> to the current search, generating \
    both results and an updated cloud of phrases and tags.  Tags may \
    be related to other tags (for \
    example, <span class=\"dterm\">dachshund</span> \
    to <span class=\"dterm\">dog</span>) and those relationships are \
    used in your search.</p> \
  <p>Once you have specified <em>at least one tag or phrase</em>, you \
    can see the matching results by \
    either <span class=\"fortouch\">tapping</span> \
    <span class=\"notouch\">clicking</span> on the result count or \
    using the <kbd>Enter</kbd> key in an empty input box.  If there \
    are few enough results, it will switch to them automatically.</p> \
</div> \
<div id=\"CODEXSEARCHRESULTSHELP\" class=\"helpbox atfoot\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" onclick=\"Codex.toggleHelp();\"/> \
  <h3>Browsing search results</h3> \
  <blockquote> \
    <p>These are the <em>results of your search</em>, ordered by \
      relevance and position within the book.  You can return to \
      the <strong>tag/phrase cloud</strong> \
      by <span class=\"fortouch\">tapping</span> \
      <span class=\"notouch\">clicking</span> in the text box or on the \
      “<em>DDD associated tags</em>” beneath it.</p> \
    <p><strong class=\"fortouch\">Tap</strong> \
      <strong class=\"notouch\">Click</strong> a result to jump to that \
      part of the book and begin <strong>scanning</strong> the book \
      based on the results.  When scanning, you can use the \
      double-arrow buttons on the edges to move through the results \
      (you can also use <span class=\"fortouch\">two-fingered \
      swipes</span> \
      <span class=\"notouch\">your keyboard's arrow keys</span>). \
    </p> \
    <p><strong class=\"notouch\">Holding the mouse button down \
        on</strong><strong class=\"fortouch\">Pressing and holding \
        </strong> a result shows you a glimpse of the result's context \
        without leaving the list of results.</p> \
  </blockquote> \
</div> \
<div id=\"CODEXALLGLOSSESHELP\" class=\"helpbox atfoot\"> \
  <img svg=\"http://static.beingmeta.com/g/codex/hide_help.svgz\" \
       src=\"http://static.beingmeta.com/g/codex/hide_help24x24.png\" \
       alt=\"close\" class=\"closebutton\" \
       onclick=\"Codex.toggleHelp();\"/> \
  <h3>Browsing all glosses</h3> \
  <blockquote> \
    <p>These are all of the glosses overlaid on your copy of this \
      book.</p> \
    <p><strong>The pictures or icons at the top of the page</strong> \
      show the <em>creators or overlays</em> for all of the \
      glosses; <span class=\"fortouch\">tap</span> \
      <span class=\"notouch\">click</span> to limit the list to glosses \
      added by a particular person or shared thorough a particular \
      overlay.  <span class=\"notouch\">Using the <kbd>Shift</kbd> \
      key adds that individual or overlay to the displayed list.</span> \
      <span class=\"fortouch\">Tap</span> \
      <span class=\"notouch\">Click</span> again to clear your \
      selection. \
    </p> \
    <p><strong class=\"fortouch\">Tap</strong> \
      <strong class=\"notouch\">Click</strong> a gloss to jump to the \
      location where it has been applied; you can then begin \
      <strong>scanning</strong> the book based on the selected \
      glosses.  When scanning, you can use the double-arrow buttons on \
      the edges to move through the glosses (you can also \
      use <span class=\"fortouch\">two-fingered swipes</span> \
      <span class=\"notouch\">your keyboard's arrow keys</span>). \
    </p> \
    <p><strong class=\"notouch\">Holding the mouse button down \
        on</strong><strong class=\"fortouch\">Pressing and holding \
        </strong> a gloss will show you a glimpse of the gloss's \
        context without actually leaving the list of glosses.</p> \
 \
  </blockquote> \
</div> \
 \
<!-- \
    /* Emacs local variables \
    ;;;  Local variables: *** \
    ;;;  compile-command: \"cd ../..; make\" *** \
    ;;;  indent-tabs-mode: nil *** \
    ;;;  End: *** \
    */ \
  --> \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/console.html" */

Codex.HTML.console="<div class='message' id='CODEXCONSOLEMESSAGE'></div> \
<div id='SBOOKMESSAGELOG' class='sbookmessagelog'> \
</div> \
 \
 \
<!-- \
/* Emacs local variables \
;;;  Local variables: *** \
;;;  compile-command: \"cd ../..; make\" *** \
;;;  indent-tabs-mode: nil *** \
;;;  End: *** \
*/ \
--> \
 \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/messages.html" */

Codex.HTML.messages="<div class=\"startupmessages\"> \
  <div class=\"startupmessage fdjtprogress\" id=\"CODEXSTARTUPSCAN\"> \
    <div class=\"indicator\"></div> \
    <div class=\"message\"> \
      Scanning the book content for structure and metadata.</div> \
  </div> \
  <div class=\"startupmessage fdjtprogress\" id=\"CODEXSTARTUPTOC\"> \
    <div class=\"indicator\"></div> \
    <div class=\"message\"> \
      Setting up tables of content for book navigation.</div> \
  </div> \
  <div class=\"startupmessage fdjtprogress\" id=\"CODEXSTARTUPKNO\"> \
    <div class=\"indicator\"></div> \
    <div class=\"message\"> \
      Processing embedded or referenced knowledge bases. \
      <div id=\"CODEXSTARTUPKNODETAILS\"></div> \
    </div> \
  </div> \
  <div class=\"startupmessage fdjtprogress\" id=\"CODEXSTARTUPTAGGING\"> \
    <div class=\"indicator\"></div> \
    <div class=\"message\">Indexing with published tags.</div> \
  </div> \
  <div class=\"startupmessage fdjtprogress\" id=\"CODEXSTARTUPCLOUDS\"> \
    <div class=\"indicator\"></div> \
    <div class=\"message\">Setting up tag clouds for search and glossing.</div> \
  </div> \
</div> \
<div class=\"startupmessage fdjtprogress\" id=\"CODEXNEWGLOSSES\"> \
  <div class=\"indicator\"></div> \
  <div class=\"message\">Applying your glosses to your book.</div> \
</div> \
<!-- \
     /* Emacs local variables \
     ;;;  Local variables: *** \
     ;;;  compile-command: \"cd ../..; make\" *** \
     ;;;  End: *** \
     */ \
  --> \
 \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/settings.html" */

Codex.HTML.settings="<h1>Device Settings</h1> \
<form onsubmit=\"fdjt.UI.cancel(event); return false;\"> \
  <table class=\"settings\" onclick=\"fdjt.UI.CheckSpan.onclick(event);\"> \
    <tr class=\"checkspan\"> \
      <th><input TYPE=\"RADIO\" NAME=\"CODEXLOCAL\" VALUE=\"yes\" \
                 ID=\"CODEXLOCALCHECKBOX\"/></th> \
      <td>Save personal information and glosses on this computer</td> \
      <td><button onclick=\"Codex.UI.forceSyncAction(event);\"> \
          Sync</button> \
        <button onclick=\"return Codex.UI.clearOfflineAction(event);\"> \
          Reset</button></td> \
    </tr> \
    <tr><th rowspan=\"2\">Body font</th> \
      <td colspan=\"2\"> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXBODYSIZE\" VALUE=\"xlarge\"/>x-large</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXBODYSIZE\" VALUE=\"large\"/>large</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXBODYSIZE\" VALUE=\"normal\"/>normal</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXBODYSIZE\" VALUE=\"small\"/>small</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXBODYSIZE\" VALUE=\"tiny\"/>tiny</span> \
    </td></tr> \
    <tr> \
      <td colspan=\"2\"> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXBODYFAMILY\" VALUE=\"sans\"/>sans-serif</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXBODYFAMILY\" VALUE=\"serif\"/>serif</span></td></tr> \
    <tr> \
      <th>Layout</th> \
      <td colspan=\"2\"> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXLAYOUT\" VALUE=\"bypage\"/>by pages</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXLAYOUT\" VALUE=\"scrolling\"/>just scroll</span> \
      </td> \
    </tr> \
    <tr><th>Interface font</th> \
      <td colspan=\"2\"> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXUISIZE\" VALUE=\"large\"/>large</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXUISIZE\" VALUE=\"normal\"/>normal</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"RADIO\" NAME=\"CODEXUISIZE\" VALUE=\"small\"/>small</span></td></tr> \
    <tr><th>Animation</th> \
      <td colspan=\"2\"> \
        <span class=\"checkspan\"> \
          <input TYPE=\"CHECKBOX\" NAME=\"CODEXANIMATECONTENT\" VALUE=\"yes\"/>content (page flips, etc)</span> \
        <span class=\"checkspan\"> \
          <input TYPE=\"CHECKBOX\" NAME=\"CODEXANIMATEHUD\" VALUE=\"yes\"/>interface (HUD, etc)</span></td></tr> \
    <tr class=\"checkspan\"> \
      <th><input TYPE=\"CHECKBOX\" NAME=\"CODEXHIDESPLASH\" VALUE=\"yes\" \
                 id=\"CODEXHIDESPLASHSETTING\" \
                 CHECKED/></th> \
      <td colspan=\"2\"> \
        Hide the application splash page after startup</td></tr> \
    <tr class=\"checkspan\"> \
      <th><input TYPE=\"CHECKBOX\" NAME=\"CODEXKEYBOARDHELP\" VALUE=\"yes\" \
                 id=\"CODEXKEYBOARDHELPSETTING\" \
                 CHECKED/></th> \
      <td colspan=\"2\"> \
        Show keyboard help for Codex</td></tr> \
    <tr class=\"checkspan\"> \
      <th><input TYPE=\"CHECKBOX\" NAME=\"CODEXSHOWCONSOLE\" VALUE=\"yes\"/></th> \
      <td colspan=\"2\">Show the Codex console</td></tr> \
    <tr title=\"A name to display for this device when recording changes\"> \
      <th>Device name</th> \
      <td colspan=\"2\"> \
        <input TYPE=\"TEXT\" NAME=\"CODEXDEVICENAME\" value=\"\"/></td> \
    </tr> \
    <tr title=\"A unique id for this device.  You probably don't need to change this.\"> \
      <th>Device ID</th> \
      <td colspan=\"2\"> \
        <input TYPE=\"TEXT\" NAME=\"CODEXDEVICEID\" value=\"\" DISABLED/></td> \
    </tr> \
    <tr class=\"buttons\"> \
      <th/> \
      <td colspan=\"2\"> \
        <span class=\"button\" onclick=\"Codex.UI.settingsOK();\">OK</span> \
        <span class=\"button\" onclick=\"Codex.UI.settingsCancel();\">Cancel</span> \
        <span ID=\"CODEXSETTINGSMESSAGE\"></span> \
      </td> \
    </tr> \
  </table> \
</form> \
 \
<!-- \
    /* Emacs local variables \
    ;;;  Local variables: *** \
    ;;;  compile-command: \"cd ../..; make\" *** \
    ;;;  indent-tabs-mode: nil *** \
    ;;;  End: *** \
    */ \
  --> \
 \
";

/* Mode: Javascript; Character-encoding: utf-8; */

/* DO NOT EDIT THIS FILE!! It is automatically */
/*   generated from the file "codex/text/splash.html" */

Codex.HTML.splash="<img svg=\"http://static.beingmeta.com/g/codex/redx.svgz\" \
     src=\"http://static.beingmeta.com/g/codex/redx24x24.png\" \
     alt=\"close\" class=\"closebutton\" \
     onclick=\"Codex.setMode(false);\"/> \
<img class=\"cover\" id=\"CODEXSTATUSCOVER\"/> \
<p class=\"checkspan\" onclick=\"fdjt.UI.CheckSpan.onclick(event);\" \
   id=\"CODEXSPLASHCONFIG\"> \
  <span class=\"adjustfont\"> \
  <input TYPE=\"checkbox\" NAME=\"CODEXHIDESPLASH\" VALUE=\"yes\" \
         ID=\"HIDESPLASHCHECKBOX\" \
         onchange=\"fdjt.UI.Delayed(function(){var checked=fdjt.ID('HIDESPLASHCHECKBOX').checked; Codex.setConfig('hidesplash',checked,true);});\" \
         \"CHECKED\"/>Hide this page after startup (<em>if not needed</em>)</span></p> \
<h1>Welcome to <span style=\"color: blue;\">s</span>Books</h1> \
<p id=\"CODEXINTRO\"></p> \
<p><img svg=\"http://static.beingmeta.com/g/codex/sbookslogo.svgz\" \
        src=\"http://static.beingmeta.com/g/codex/sbookslogo32x32.png\" \
        alt=\"sBooks\" class=\"left\"/> \
  <strong><span style=\"color: blue;\">s</span>Books</strong> \
  are digital books personally customized with comments, tags, or links \
  from your friends, communities, and networks as well as (selectively) \
  experts, critics, or teachers.</p> \
<p><img svg=\"http://static.beingmeta.com/g/codex/helpicon.svgz\" \
        src=\"http://static.beingmeta.com/g/codex/helpicon32x32.png\" \
        alt=\"help/question mark\" class=\"left\"/> \
        This <strong><span style=\"color: blue;\">s</span>Books \
        reader</strong> web application makes it easy to navigate, \
        search, and annotate your book.<br/> \
  <strong><span class=\"fortouch\">Tap</span> <span class=\"notouch\">Click</span> \
  </strong> the help icon in bottom right for help with using the sBooks web \
  application.</p> \
<form action=\"https://glosses.sbooks.net/flyleaf\" target=\"SBOOKSAPP\" \
      NAME=\"CODEXSPLASHFORM\" ID=\"CODEXSPLASHFORM\" \
      method=\"POST\" \
      onsubmit=\"Codex.appinit=true; Codex.setMode('sbooksapp');\"> \
  <input TYPE=\"HIDDEN\" NAME=\"RETURN_TO\" VALUE=\"\" \
         ID=\"CODEXSPLASH_RETURN_TO\"/> \
  <input TYPE=\"HIDDEN\" NAME=\"LOGINFORM\" VALUE=\"yes\"/> \
  <input TYPE=\"HIDDEN\" NAME=\"TOPURI\" VALUE=\"\"/> \
  <input TYPE=\"HIDDEN\" NAME=\"REFURI\" VALUE=\"\"/> \
  <input TYPE=\"HIDDEN\" NAME=\"DOCURI\" VALUE=\"\"/> \
  <input TYPE=\"HIDDEN\" NAME=\"XQUERY\" VALUE=\"\"/> \
  <table class=\"fdjtform\"> \
    <tr class=\"cxwithuser\"> \
      <th class=\"image\"><img alt=\"you\" name=\"CODEXUSERPIC\"/></th> \
      <td><strong>This book</strong> is personalized with glosses for \
        <strong name=\"CODEXUSERNAME\">Somebody Interesting</strong>. \
        If that's not you, \
        please <a href=\"https://auth.sbooks.net/admin/logout\">logout</a>; \
        if it is you, you can view and update \
        your <a href=\"https://auth.sbooks.net/my/profile\" \
                target=\"_blank\">profile here</a>.</td></tr> \
    <tbody class=\"cxnouser\"> \
      <tr> \
        <td class=\"text\" colspan=\"2\"> \
          To save and share your notes, tags, and links, you need to \
          be logged into sBooks.  An sBooks account is free and can be \
          linked to your existing social networks or used to create a new \
          one around the books you love.</td></tr> \
      <tr> \
        <th><input type=\"SUBMIT\" name=\"ACTION\" value=\"Login\"/>&nbsp;with</th> \
        <td><input type=\"TEXT\" name=\"USERNAME\" value=\"\" \
                   placeholder=\"email address\"/></td></tr> \
      <tr><th>or&nbsp;use</th> \
        <td> \
          <button name=\"AUTHORITY\" value=\":FACEBOOK\"> \
            <img src=\"http://static.beingmeta.com/g/codex/facebook32x32.png\" \
                 alt=\"Facebook\" class=\"noautoscale\"/> \
          </button> \
          <button NAME=\"AUTHORITY\" VALUE=\":GPLUS\"> \
            <img src=\"http://static.beingmeta.com/g/codex/googleplus32x32.png\" \
                 alt=\"Google\" title=\"login using Google\"/> \
          </button> \
          <button NAME=\"AUTHORITY\" VALUE=\":TWITTER\"> \
            <img src=\"http://static.beingmeta.com/g/codex/twitter32x32.png\" \
                 alt=\"Twitter\" title=\"login with Twitter\"/> \
          </button> \
      </td></tr> \
    </tbody> \
    <tbody class=\"cxwithuser\">  \
      <tr><th class=\"button\" rowspan=\"2\"> \
          <button name=\"ACTION\" value=\":MAKEFRIEND\">Invite</button><br/> \
          your<br/>friends</th> \
        <td class=\"textbox\"> \
          <input TYPE=\"TEXT\" NAME=\"FRIENDS\" VALUE=\"\" \
                 onkeypress=\"fdjt.UI.submitOnEnter(event);\" \
                 placeholder=\"email addresses\"/></td></tr> \
      <tr><td>to join your <strong>personal circle</strong> at \
          <strong><span style=\"color: blue;\">s</span>Books</strong>. \
          This will allow you to see one another's notes, tags, and links \
          (glosses).</td></tr> \
    </tbody> \
    <tbody class=\"cxwithuser\"> \
      <tr><th class=\"button\" rowspan=\"2\"> \
          <button NAME=\"ACTION\" VALUE=\":MAKECIRCLE\">Gather</button><br/> \
          a tribe</th> \
        <td class=\"textbox\"> \
          <input TYPE=\"TEXT\" NAME=\"INVITING\" VALUE=\"\" \
                 onkeypress=\"fdjt.UI.submitOnEnter(event);\" \
                 placeholder=\"email addresses\"/></td></tr> \
      <tr><td>into a <strong>reading circle</strong> at \
          <strong><span style=\"color: blue;\">s</span>Books</strong>. \
          Members of a reading circle can see one another's glosses \
          on this book, sharing insights, opinions, and reactions.</td></tr> \
    </tbody> \
  </table> \
</form> \
<!-- \
    /* Emacs local variables \
    ;;;  Local variables: *** \
    ;;;  compile-command: \"cd ../..; make\" *** \
    ;;;  indent-tabs-mode: nil *** \
    ;;;  End: *** \
    */ \
  --> \
";

Codex.version='v0.5-469-g0a7400e';
Knodule.version='v0.8-34-g6fe7748';
// sBooks build information
Codex.buildhost='sliver.beingmeta.com';
Codex.buildtime='Sat Dec 22 07:12:46 PST 2012';
Codex.buildid='A8451447-834F-4E45-A05B-8D5644714292';

